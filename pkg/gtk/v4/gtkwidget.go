// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
		{T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
	})
}

// Allocation: a Allocation-struct of a widget represents region which has been
// allocated to the widget by its parent. It is a subregion of its parents
// allocation. See [GtkWidget’s geometry management
// section][geometry-management] for more information.
type Allocation gdk.Rectangle

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widget, frameClock gdk.FrameClock) bool

//export gotk4_TickCallback
func gotk4_TickCallback(arg0 *C.GtkWidget, arg1 *C.GdkFrameClock, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TickCallback)
	ret := fn(widget, frameClock, userData)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// Widget: gtkWidget is the base class all widgets in GTK derive from. It
// manages the widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - WidgetClass.get_request_mode() - WidgetClass.measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct Widget subclass that supports height-for-width or
// width-for-height geometry management for itself or its child widgets, the
// WidgetClass.get_request_mode() virtual function must be implemented as well
// and return the widget's preferred request mode. The default implementation of
// this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// WidgetClass.measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_measure() with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// gtk_widget_measure() with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// Widget will typically be requested its size a number of times before actually
// being allocated a size. The size a widget is finally allocated can of course
// differ from the size it has requested. For this reason, Widget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }
type Widget interface {
	gextras.Objector
	Accessible
	Buildable
	ConstraintTarget

	// ActionSetEnabled: enable or disable an action installed with
	// gtk_widget_class_install_action().
	ActionSetEnabled(w Widget, actionName string, enabled bool)
	// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
	// this function activates them. The activation will emit the signal set
	// using gtk_widget_class_set_activate_signal() during class initialization.
	//
	// Activation is what happens when you press Enter on a widget during key
	// navigation.
	//
	// If you wish to handle the activation keybinding yourself, it is
	// recommended to use gtk_widget_class_add_shortcut() with an action created
	// with gtk_signal_action_new().
	//
	// If @widget isn't activatable, the function returns false.
	Activate(w Widget) bool
	// ActivateActionVariant looks up the action in the action groups associated
	// with @widget and its ancestors, and activates it.
	//
	// If the action is in an action group added with
	// gtk_widget_insert_action_group(), the @name is expected to be prefixed
	// with the prefix that was used when the group was inserted.
	//
	// The arguments must match the actions expected parameter type, as returned
	// by g_action_get_parameter_type().
	ActivateActionVariant(w Widget, name string, args *glib.Variant) bool
	// ActivateDefault: activate the default.activate action from @widget.
	ActivateDefault(w Widget)
	// AddController adds @controller to @widget so that it will receive events.
	// You will usually want to call this function right after creating any kind
	// of EventController.
	AddController(w Widget, controller EventController)
	// AddCSSClass adds @css_class to @widget. After calling this function,
	// @widget's style will match for @css_class, after the CSS matching rules.
	AddCSSClass(w Widget, cssClass string)
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
	// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
	// mnemonic labels for the widget is cleared when the widget is destroyed,
	// so the caller must make sure to update its internal state at this point
	// as well, by using a connection to the Widget::destroy signal or a weak
	// notifier.
	AddMnemonicLabel(w Widget, label Widget)
	// AddTickCallback queues an animation frame update and adds a callback to
	// be called before each frame. Until the tick callback is removed, it will
	// be called frequently (usually at the frame rate of the output device or
	// as quickly as the application can be repainted, whichever is slower). For
	// this reason, is most suitable for handling graphics that change every
	// frame or every few frames. The tick callback does not automatically imply
	// a relayout or repaint. If you want a repaint or relayout, and aren’t
	// changing widget properties that would trigger that (for example, changing
	// the text of a Label), then you will have to call
	// gtk_widget_queue_resize() or gtk_widget_queue_draw() yourself.
	//
	// gdk_frame_clock_get_frame_time() should generally be used for timing
	// continuous animations and
	// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
	// display isolated frames at particular times.
	//
	// This is a more convenient alternative to connecting directly to the
	// FrameClock::update signal of FrameClock, since you don't have to worry
	// about when a FrameClock is assigned to a widget.
	AddTickCallback(w Widget)
	// Allocate: this function is only used by Widget subclasses, to assign a
	// size, position and (optionally) baseline to their child widgets.
	//
	// In this function, the allocation and baseline may be adjusted. The given
	// allocation will be forced to be bigger than the widget's minimum size, as
	// well as at least 0×0 in size.
	//
	// For a version that does not take a transform, see
	// gtk_widget_size_allocate()
	Allocate(w Widget, width int, height int, baseline int, transform *gsk.Transform)
	// ChildFocus: this function is used by custom widget implementations; if
	// you're writing an app, you’d use gtk_widget_grab_focus() to move the
	// focus to a particular widget.
	//
	// gtk_widget_child_focus() is called by widgets as the user moves around
	// the window using keyboard shortcuts. @direction indicates what kind of
	// motion is taking place (up, down, left, right, tab forward, tab
	// backward). gtk_widget_child_focus() calls the WidgetClass.focus() vfunc;
	// widgets override this vfunc in order to implement appropriate focus
	// behavior.
	//
	// The default focus() vfunc for a widget should return true if moving in
	// @direction left the focus on a focusable location inside that widget, and
	// false if moving in @direction moved the focus outside the widget. If
	// returning true, widgets normally call gtk_widget_grab_focus() to place
	// the focus accordingly; if returning false, they don’t modify the current
	// focus location.
	ChildFocus(w Widget, direction DirectionType) bool
	// ComputeBounds computes the bounds for @widget in the coordinate space of
	// @target. FIXME: Explain what "bounds" are.
	//
	// If the operation is successful, true is returned. If @widget has no
	// bounds or the bounds cannot be expressed in @target's coordinate space
	// (for example if both widgets are in different windows), false is returned
	// and @bounds is set to the zero rectangle.
	//
	// It is valid for @widget and @target to be the same widget.
	ComputeBounds(w Widget, target Widget) (outBounds *graphene.Rect, ok bool)
	// ComputeExpand computes whether a container should give this widget extra
	// space when possible. Containers should check this, rather than looking at
	// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
	//
	// This function already checks whether the widget is visible, so visibility
	// does not need to be checked separately. Non-visible widgets are not
	// expanded.
	//
	// The computed expand value uses either the expand setting explicitly set
	// on the widget itself, or, if none has been explicitly set, the widget may
	// expand if some of its children do.
	ComputeExpand(w Widget, orientation Orientation) bool
	// ComputePoint translates the given @point in @widget's coordinates to
	// coordinates relative to @target’s coordinate system. In order to perform
	// this operation, both widgets must share a common root.
	ComputePoint(w Widget, target Widget, point *graphene.Point) (outPoint *graphene.Point, ok bool)
	// ComputeTransform computes a matrix suitable to describe a transformation
	// from @widget's coordinate system into @target's coordinate system.
	ComputeTransform(w Widget, target Widget) (outTransform *graphene.Matrix, ok bool)
	// Contains tests if the point at (@x, @y) is contained in @widget.
	//
	// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of @widget's content area.
	Contains(w Widget, x float64, y float64) bool
	// CreatePangoContext creates a new Context with the appropriate font map,
	// font options, font description, and base direction for drawing text for
	// this widget. See also gtk_widget_get_pango_context().
	CreatePangoContext(w Widget)
	// CreatePangoLayout creates a new Layout with the appropriate font map,
	// font description, and base direction for drawing text for this widget.
	//
	// If you keep a Layout created in this way around, you need to re-create it
	// when the widget Context is replaced. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	CreatePangoLayout(w Widget, text string)
	// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
	// @start_y) and ending at (@current_x, @current_y) has passed the GTK drag
	// threshold, and thus should trigger the beginning of a drag-and-drop
	// operation.
	DragCheckThreshold(w Widget, startX int, startY int, currentX int, currentY int) bool
	// ErrorBell notifies the user about an input-related error on this widget.
	// If the Settings:gtk-error-bell setting is true, it calls
	// gdk_surface_beep(), otherwise it does nothing.
	//
	// Note that the effect of gdk_surface_beep() can be configured in many
	// ways, depending on the windowing backend and the desktop environment or
	// window manager that is used.
	ErrorBell(w Widget)
	// AllocatedBaseline returns the baseline that has currently been allocated
	// to @widget. This function is intended to be used when implementing
	// handlers for the WidgetClass.snapshot() function, and when allocating
	// child widgets in WidgetClass.size_allocate().
	AllocatedBaseline(w Widget)
	// AllocatedHeight returns the height that has currently been allocated to
	// @widget.
	AllocatedHeight(w Widget)
	// AllocatedWidth returns the width that has currently been allocated to
	// @widget.
	AllocatedWidth(w Widget)
	// Ancestor gets the first ancestor of @widget with type @widget_type. For
	// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
	// Box that’s an ancestor of @widget. No reference will be added to the
	// returned widget; it should not be unreferenced.
	//
	// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
	// considers @widget to be an ancestor of itself.
	Ancestor(w Widget, widgetType externglib.Type)
	// CanFocus determines whether the input focus can enter @widget or any of
	// its children.
	//
	// See gtk_widget_set_focusable().
	CanFocus(w Widget) bool
	// CanTarget queries whether @widget can be the target of pointer events.
	CanTarget(w Widget) bool
	// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
	// you feel a need to use this function, your code probably needs
	// reorganization.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	ChildVisible(w Widget) bool
	// Clipboard: this is a utility function to get the clipboard object for the
	// Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	Clipboard(w Widget)
	// CSSClasses returns the list of css classes applied to @widget.
	CSSClasses(w Widget)
	// CSSName returns the CSS name that is used for @self.
	CSSName(s Widget)
	// Cursor queries the cursor set via gtk_widget_set_cursor(). See that
	// function for details.
	Cursor(w Widget)
	// Direction gets the reading direction for a particular widget. See
	// gtk_widget_set_direction().
	Direction(w Widget)
	// Display: get the Display for the toplevel window associated with this
	// widget. This function can only be called after the widget has been added
	// to a widget hierarchy with a Window at the top.
	//
	// In general, you should only create display specific resources when a
	// widget has been realized, and you should free those resources when the
	// widget is unrealized.
	Display(w Widget)
	// FirstChild returns the widgets first child.
	//
	// This API is primarily meant for widget implementations.
	FirstChild(w Widget)
	// FocusChild returns the current focus child of @widget.
	FocusChild(w Widget)
	// FocusOnClick returns whether the widget should grab focus when it is
	// clicked with the mouse. See gtk_widget_set_focus_on_click().
	FocusOnClick(w Widget) bool
	// Focusable determines whether @widget can own the input focus. See
	// gtk_widget_set_focusable().
	Focusable(w Widget) bool
	// FontMap gets the font map that has been set with
	// gtk_widget_set_font_map().
	FontMap(w Widget)
	// FontOptions returns the #cairo_font_options_t used for Pango rendering.
	// When not set, the defaults font options for the Display will be used.
	FontOptions(w Widget)
	// FrameClock obtains the frame clock for a widget. The frame clock is a
	// global “ticker” that can be used to drive animations and repaints. The
	// most common reason to get the frame clock is to call
	// gdk_frame_clock_get_frame_time(), in order to get a time to use for
	// animating. For example you might record the start of the animation with
	// an initial value from gdk_frame_clock_get_frame_time(), and then update
	// the animation by calling gdk_frame_clock_get_frame_time() again during
	// each repaint.
	//
	// gdk_frame_clock_request_phase() will result in a new frame on the clock,
	// but won’t necessarily repaint any widgets. To repaint a widget, you have
	// to use gtk_widget_queue_draw() which invalidates the widget (thus
	// scheduling it to receive a draw on the next frame).
	// gtk_widget_queue_draw() will also end up requesting a frame on the
	// appropriate frame clock.
	//
	// A widget’s frame clock will not change while the widget is mapped.
	// Reparenting a widget (which implies a temporary unmap) can change the
	// widget’s frame clock.
	//
	// Unrealized widgets do not have a frame clock.
	FrameClock(w Widget)
	// Halign gets the value of the Widget:halign property.
	//
	// For backwards compatibility reasons this method will never return
	// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
	// Baselines are not supported for horizontal alignment.
	Halign(w Widget)
	// HasTooltip returns the current value of the has-tooltip property. See
	// Widget:has-tooltip for more information.
	HasTooltip(w Widget) bool
	// Height returns the content height of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Height(w Widget)
	// Hexpand gets whether the widget would like any available extra horizontal
	// space. When a user resizes a Window, widgets with expand=TRUE generally
	// receive the extra space. For example, a list or scrollable area or
	// document in your window would often be set to expand.
	//
	// Containers should use gtk_widget_compute_expand() rather than this
	// function, to see whether a widget, or any of its children, has the expand
	// flag set. If any child of a widget wants to expand, the parent may ask to
	// expand also.
	//
	// This function only looks at the widget’s own hexpand flag, rather than
	// computing whether the entire widget tree rooted at this widget wants to
	// expand.
	Hexpand(w Widget) bool
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	HexpandSet(w Widget) bool
	// LastChild returns the widgets last child.
	//
	// This API is primarily meant for widget implementations.
	LastChild(w Widget)
	// LayoutManager retrieves the layout manager set using
	// gtk_widget_set_layout_manager().
	LayoutManager(w Widget)
	// Mapped: whether the widget is mapped.
	Mapped(w Widget) bool
	// MarginBottom gets the value of the Widget:margin-bottom property.
	MarginBottom(w Widget)
	// MarginEnd gets the value of the Widget:margin-end property.
	MarginEnd(w Widget)
	// MarginStart gets the value of the Widget:margin-start property.
	MarginStart(w Widget)
	// MarginTop gets the value of the Widget:margin-top property.
	MarginTop(w Widget)
	// Name retrieves the name of a widget. See gtk_widget_set_name() for the
	// significance of widget names.
	Name(w Widget)
	// Native returns the GtkNative widget that contains @widget, or nil if the
	// widget is not contained inside a widget tree with a native ancestor.
	//
	// Native widgets will return themselves here.
	Native(w Widget)
	// NextSibling returns the widgets next sibling.
	//
	// This API is primarily meant for widget implementations.
	NextSibling(w Widget)
	// Opacity fetches the requested opacity for this widget. See
	// gtk_widget_set_opacity().
	Opacity(w Widget)
	// Overflow returns the value set via gtk_widget_set_overflow().
	Overflow(w Widget)
	// PangoContext gets a Context with the appropriate font map, font
	// description, and base direction for this widget. Unlike the context
	// returned by gtk_widget_create_pango_context(), this context is owned by
	// the widget (it can be used until the screen for the widget changes or the
	// widget is removed from its toplevel), and will be updated to match any
	// changes to the widget’s attributes. This can be tracked by listening to
	// changes of the Widget:root property on the widget.
	PangoContext(w Widget)
	// Parent returns the parent widget of @widget.
	Parent(w Widget)
	// PreferredSize retrieves the minimum and natural size of a widget, taking
	// into account the widget’s preference for height-for-width management.
	//
	// This is used to retrieve a suitable size by container widgets which do
	// not impose any restrictions on the child placement. It can be used to
	// deduce toplevel window and menu sizes as well as child widgets in
	// free-form containers such as GtkLayout.
	//
	// Handle with care. Note that the natural height of a height-for-width
	// widget will generally be a smaller size than the minimum height, since
	// the required height for the natural width is generally smaller than the
	// required height for the minimum width.
	//
	// Use gtk_widget_measure() if you want to support baseline alignment.
	PreferredSize(w Widget) (minimumSize *Requisition, naturalSize *Requisition)
	// PrevSibling returns the widgets previous sibling.
	//
	// This API is primarily meant for widget implementations.
	PrevSibling(w Widget)
	// PrimaryClipboard: this is a utility function to get the primary clipboard
	// object for the Display that @widget is using.
	//
	// Note that this function always works, even when @widget is not realized
	// yet.
	PrimaryClipboard(w Widget)
	// Realized determines whether @widget is realized.
	Realized(w Widget) bool
	// ReceivesDefault determines whether @widget is always treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	//
	// See gtk_widget_set_receives_default().
	ReceivesDefault(w Widget) bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	RequestMode(w Widget)
	// Root returns the Root widget of @widget or nil if the widget is not
	// contained inside a widget tree with a root widget.
	//
	// Root widgets will return themselves here.
	Root(w Widget)
	// ScaleFactor retrieves the internal scale factor that maps from window
	// coordinates to the actual device pixels. On traditional systems this is
	// 1, on high density outputs, it can be a higher value (typically 2).
	//
	// See gdk_surface_get_scale_factor().
	ScaleFactor(w Widget)
	// Sensitive returns the widget’s sensitivity (in the sense of returning the
	// value that has been set using gtk_widget_set_sensitive()).
	//
	// The effective sensitivity of a widget is however determined by both its
	// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
	Sensitive(w Widget) bool
	// Settings gets the settings object holding the settings used for this
	// widget.
	//
	// Note that this function can only be called when the Widget is attached to
	// a toplevel, since the settings object is specific to a particular
	// Display. If you want to monitor the widget for changes in its settings,
	// connect to notify::display.
	Settings(w Widget)
	// Size returns the content width or height of the widget, depending on
	// @orientation. This is equivalent to calling gtk_widget_get_width() for
	// GTK_ORIENTATION_HORIZONTAL or gtk_widget_get_height() for
	// GTK_ORIENTATION_VERTICAL, but can be used when writing
	// orientation-independent code, such as when implementing Orientable
	// widgets.
	Size(w Widget, orientation Orientation)
	// SizeRequest gets the size request that was explicitly set for the widget
	// using gtk_widget_set_size_request(). A value of -1 stored in @width or
	// @height indicates that that dimension has not been set explicitly and the
	// natural requisition of the widget will be used instead. See
	// gtk_widget_set_size_request(). To get the size a widget will actually
	// request, call gtk_widget_measure() instead of this function.
	SizeRequest(w Widget) (width int, height int)
	// StateFlags returns the widget state as a flag set. It is worth mentioning
	// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
	// that is, also based on parent insensitivity, even if @widget itself is
	// sensitive.
	//
	// Also note that if you are looking for a way to obtain the StateFlags to
	// pass to a StyleContext method, you should look at
	// gtk_style_context_get_state().
	StateFlags(w Widget)
	// StyleContext returns the style context associated to @widget. The
	// returned object is guaranteed to be the same for the lifetime of @widget.
	StyleContext(w Widget)
	// TemplateChild: fetch an object build from the template XML for
	// @widget_type in this @widget instance.
	//
	// This will only report children which were previously declared with
	// gtk_widget_class_bind_template_child_full() or one of its variants.
	//
	// This function is only meant to be called for code which is private to the
	// @widget_type which declared the child and is meant for language bindings
	// which cannot easily make use of the GObject structure offsets.
	TemplateChild(w Widget, widgetType externglib.Type, name string)
	// TooltipMarkup gets the contents of the tooltip for @widget set using
	// gtk_widget_set_tooltip_markup().
	TooltipMarkup(w Widget)
	// TooltipText gets the contents of the tooltip for @widget.
	//
	// If the @widget's tooltip was set using gtk_widget_set_tooltip_markup(),
	// this function will return the escaped text.
	TooltipText(w Widget)
	// Valign gets the value of the Widget:valign property.
	Valign(w Widget)
	// Vexpand gets whether the widget would like any available extra vertical
	// space.
	//
	// See gtk_widget_get_hexpand() for more detail.
	Vexpand(w Widget) bool
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
	// explicitly set the expand flag on this widget.
	//
	// See gtk_widget_get_hexpand_set() for more detail.
	VexpandSet(w Widget) bool
	// Visible determines whether the widget is visible. If you want to take
	// into account whether the widget’s parent is also marked as visible, use
	// gtk_widget_is_visible() instead.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See gtk_widget_set_visible().
	Visible(w Widget) bool
	// Width returns the content width of the widget, as passed to its
	// size-allocate implementation. This is the size you should be using in
	// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
	Width(w Widget)
	// GrabFocus causes @widget (or one of its descendents) to have the keyboard
	// focus for the Window it's inside.
	//
	// If @widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of @widget that is focusable, it will
	// not take focus and false will be returned.
	//
	// Calling gtk_widget_grab_focus() on an already focused widget is allowed,
	// should not have an effect, and return true.
	GrabFocus(w Widget) bool
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	HasCSSClass(w Widget, cssClass string) bool
	// HasDefault determines whether @widget is the current default widget
	// within its toplevel.
	HasDefault(w Widget) bool
	// HasFocus determines if the widget has the global input focus. See
	// gtk_widget_is_focus() for the difference between having the global input
	// focus, and only having the focus within a toplevel.
	HasFocus(w Widget) bool
	// HasVisibleFocus determines if the widget should show a visible indication
	// that it has the global input focus. This is a convenience function that
	// takes into account whether focus indication should currently be shown in
	// the toplevel window of @widget. See gtk_window_get_focus_visible() for
	// more information about focus indication.
	//
	// To find out if the widget has the global input focus, use
	// gtk_widget_has_focus().
	HasVisibleFocus(w Widget) bool
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide(w Widget)
	// InDestruction returns whether the widget is currently being destroyed.
	// This information can sometimes be used to avoid doing unnecessary work.
	InDestruction(w Widget) bool
	// InitTemplate creates and initializes child widgets defined in templates.
	// This function must be called in the instance initializer for any class
	// which assigned itself a template using gtk_widget_class_set_template()
	//
	// It is important to call this function in the instance initializer of a
	// Widget subclass and not in #GObject.constructed() or
	// #GObject.constructor() for two reasons.
	//
	// One reason is that generally derived widgets will assume that parent
	// class composite widgets have been created in their instance initializers.
	//
	// Another reason is that when calling g_object_new() on a widget with
	// composite templates, it’s important to build the composite widgets before
	// the construct properties are set. Properties passed to g_object_new()
	// should take precedence over properties set in the private template XML.
	InitTemplate(w Widget)
	// InsertActionGroup inserts @group into @widget. Children of @widget that
	// implement Actionable can then be associated with actions in @group by
	// setting their “action-name” to @prefix.`action-name`.
	//
	// Note that inheritance is defined for individual actions. I.e. even if you
	// insert a group with prefix @prefix, actions with the same prefix will
	// still be inherited from the parent, unless the group contains an action
	// with the same name.
	//
	// If @group is nil, a previously inserted group for @name is removed from
	// @widget.
	InsertActionGroup(w Widget, name string, group gio.ActionGroup)
	// InsertAfter inserts @widget into the child widget list of @parent.
	//
	// It will be placed after @previous_sibling, or at the beginning if
	// @previous_sibling is nil.
	//
	// After calling this function, gtk_widget_get_prev_sibling(widget) will
	// return @previous_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertAfter(w Widget, parent Widget, previousSibling Widget)
	// InsertBefore inserts @widget into the child widget list of @parent.
	//
	// It will be placed before @next_sibling, or at the end if @next_sibling is
	// nil.
	//
	// After calling this function, gtk_widget_get_next_sibling(widget) will
	// return @next_sibling.
	//
	// If @parent is already set as the parent widget of @widget, this function
	// can also be used to reorder @widget in the child widget list of @parent.
	//
	// This API is primarily meant for widget implementations; if you are just
	// using a widget, you *must* use its own API for adding children.
	InsertBefore(w Widget, parent Widget, nextSibling Widget)
	// IsAncestor determines whether @widget is somewhere inside @ancestor,
	// possibly with intermediate containers.
	IsAncestor(w Widget, ancestor Widget) bool
	// IsDrawable determines whether @widget can be drawn to. A widget can be
	// drawn if it is mapped and visible.
	IsDrawable(w Widget) bool
	// IsFocus determines if the widget is the focus widget within its toplevel.
	// (This does not mean that the Widget:has-focus property is necessarily
	// set; Widget:has-focus will only be set if the toplevel widget
	// additionally has the global input focus.)
	IsFocus(w Widget) bool
	// IsSensitive returns the widget’s effective sensitivity, which means it is
	// sensitive itself and also its parent widget is sensitive
	IsSensitive(w Widget) bool
	// IsVisible determines whether the widget and all its parents are marked as
	// visible.
	//
	// This function does not check if the widget is obscured in any way.
	//
	// See also gtk_widget_get_visible() and gtk_widget_set_visible()
	IsVisible(w Widget) bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When true is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When false is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns true.
	//
	// Whenever the default handler returns true, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	KeynavFailed(w Widget, direction DirectionType) bool
	// ListMnemonicLabels returns a newly allocated list of the widgets,
	// normally labels, for which this widget is the target of a mnemonic (see
	// for example, gtk_label_set_mnemonic_widget()).
	//
	// The widgets in the list are not individually referenced. If you want to
	// iterate through the list and perform actions involving callbacks that
	// might destroy the widgets, you must call `g_list_foreach (result,
	// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
	// afterwards.
	ListMnemonicLabels(w Widget)
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map(w Widget)
	// Measure measures @widget in the orientation @orientation and for the
	// given @for_size. As an example, if @orientation is
	// GTK_ORIENTATION_HORIZONTAL and @for_size is 300, this functions will
	// compute the minimum and natural width of @widget if it is allocated at a
	// height of 300 pixels.
	//
	// See [GtkWidget’s geometry management section][geometry-management] for a
	// more details on implementing WidgetClass.measure().
	Measure(w Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int)
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	MnemonicActivate(w Widget, groupCycling bool) bool
	// ObserveChildren returns a Model to track the children of @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// children and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveChildren(w Widget)
	// ObserveControllers returns a Model to track the EventControllers of
	// @widget.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// controllers and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveControllers(w Widget)
	// Pick finds the descendant of @widget (including @widget itself) closest
	// to the screen at the point (@x, @y). The point must be given in widget
	// coordinates, so (0, 0) is assumed to be the top left of @widget's content
	// area.
	//
	// Usually widgets will return nil if the given coordinate is not contained
	// in @widget checked via gtk_widget_contains(). Otherwise they will
	// recursively try to find a child that does not return nil. Widgets are
	// however free to customize their picking algorithm.
	//
	// This function is used on the toplevel to determine the widget below the
	// mouse cursor for purposes of hover highlighting and delivering events.
	Pick(w Widget, x float64, y float64, flags PickFlags)
	// QueueAllocate: this function is only for use in widget implementations.
	//
	// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
	// function. Use this function instead of gtk_widget_queue_resize() when the
	// @widget's size request didn't change but it wants to reposition its
	// contents.
	//
	// An example user of this function is gtk_widget_set_halign().
	QueueAllocate(w Widget)
	// QueueDraw schedules this widget to be redrawn in paint phase of the
	// current or the next frame. This means @widget's GtkWidgetClass.snapshot()
	// implementation will be called.
	QueueDraw(w Widget)
	// QueueResize: this function is only for use in widget implementations.
	// Flags a widget to have its size renegotiated; should be called when a
	// widget for some reason has a new size request. For example, when you
	// change the text in a Label, Label queues a resize to ensure there’s
	// enough space for the new text.
	//
	// Note that you cannot call gtk_widget_queue_resize() on a widget from
	// inside its implementation of the GtkWidgetClass::size_allocate virtual
	// method. Calls to gtk_widget_queue_resize() from inside
	// GtkWidgetClass::size_allocate will be silently ignored.
	QueueResize(w Widget)
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. Normally realization happens implicitly; if you show a widget and
	// all its parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to @widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::realize.
	Realize(w Widget)
	// RemoveController removes @controller from @widget, so that it doesn't
	// process events anymore. It should not be used again.
	//
	// Widgets will remove all event controllers automatically when they are
	// destroyed, there is normally no need to call this function.
	RemoveController(w Widget, controller EventController)
	// RemoveCSSClass removes @css_class from @widget. After this, the style of
	// @widget will stop matching for @css_class.
	RemoveCSSClass(w Widget, cssClass string)
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
	// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
	// have previously been added to the list with
	// gtk_widget_add_mnemonic_label().
	RemoveMnemonicLabel(w Widget, label Widget)
	// RemoveTickCallback removes a tick callback previously registered with
	// gtk_widget_add_tick_callback().
	RemoveTickCallback(w Widget, id uint)
	// SetCanFocus specifies whether the input focus can enter the widget or any
	// of its children.
	//
	// Applications should set @can_focus to false to mark a widget as for
	// pointer/touch use only.
	//
	// Note that having @can_focus be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// focusable and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetCanFocus(w Widget, canFocus bool)
	// SetCanTarget sets whether @widget can be the target of pointer events.
	SetCanTarget(w Widget, canTarget bool)
	// SetChildVisible sets whether @widget should be mapped along with its when
	// its parent is mapped and @widget has been shown with gtk_widget_show().
	//
	// The child visibility can be set for widget before it is added to a
	// container with gtk_widget_set_parent(), to avoid mapping children
	// unnecessary before immediately unmapping them. However it will be reset
	// to its default state of true when the widget is removed from a container.
	//
	// Note that changing the child visibility of a widget does not queue a
	// resize on the widget. Most of the time, the size of a widget is computed
	// from all visible children, whether or not they are mapped. If this is not
	// the case, the container can queue a resize itself.
	//
	// This function is only useful for container implementations and never
	// should be called by an application.
	SetChildVisible(w Widget, childVisible bool)
	// SetCSSClasses: will clear all css classes applied to @widget and replace
	// them with @classes.
	SetCSSClasses(w Widget, classes []string)
	// SetCursor sets the cursor to be shown when pointer devices point towards
	// @widget.
	//
	// If the @cursor is NULL, @widget will use the cursor inherited from the
	// parent widget.
	SetCursor(w Widget, cursor gdk.Cursor)
	// SetCursorFromName sets a named cursor to be shown when pointer devices
	// point towards @widget.
	//
	// This is a utility function that creates a cursor via
	// gdk_cursor_new_from_name() and then sets it on @widget with
	// gtk_widget_set_cursor(). See those 2 functions for details.
	//
	// On top of that, this function allows @name to be nil, which will do the
	// same as calling gtk_widget_set_cursor() with a nil cursor.
	SetCursorFromName(w Widget, name string)
	// SetDirection sets the reading direction on a particular widget. This
	// direction controls the primary direction for widgets containing text, and
	// also the direction in which the children of a container are packed. The
	// ability to set the direction is present in order so that correct
	// localization into languages with right-to-left reading directions can be
	// done. Generally, applications will let the default reading direction
	// present, except for containers where the containers are arranged in an
	// order that is explicitly visual rather than logical (such as buttons for
	// text justification).
	//
	// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
	// gtk_widget_set_default_direction() will be used.
	SetDirection(w Widget, dir TextDirection)
	// SetFocusChild: set @child as the current focus child of @widget. The
	// previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call gtk_widget_grab_focus() on
	// it.
	SetFocusChild(w Widget, child Widget)
	// SetFocusOnClick sets whether the widget should grab focus when it is
	// clicked with the mouse. Making mouse clicks not grab focus is useful in
	// places like toolbars where you don’t want the keyboard focus removed from
	// the main area of the application.
	SetFocusOnClick(w Widget, focusOnClick bool)
	// SetFocusable specifies whether @widget can own the input focus.
	//
	// Widget implementations should set @focusable to true in their init()
	// function if they want to receive keyboard input.
	//
	// Note that having @focusable be true is only one of the necessary
	// conditions for being focusable. A widget must also be sensitive and
	// can-focus and not have an ancestor that is marked as not can-focus in
	// order to receive input focus.
	//
	// See gtk_widget_grab_focus() for actually setting the input focus on a
	// widget.
	SetFocusable(w Widget, focusable bool)
	// SetFontMap sets the font map to use for Pango rendering. The font map is
	// the object that is used to look up fonts. Setting a custom font map can
	// be useful in special situations, e.g. when you need to add
	// application-specific fonts to the set of available fonts.
	//
	// When not set, the widget will inherit the font map from its parent.
	SetFontMap(w Widget, fontMap pango.FontMap)
	// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
	// this widget. When not set, the default font options for the Display will
	// be used.
	SetFontOptions(w Widget, options *cairo.FontOptions)
	// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
	// property.
	SetHalign(w Widget, align Align)
	// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
	// See Widget:has-tooltip for more information.
	SetHasTooltip(w Widget, hasTooltip bool)
	// SetHexpand sets whether the widget would like any available extra
	// horizontal space. When a user resizes a Window, widgets with expand=TRUE
	// generally receive the extra space. For example, a list or scrollable area
	// or document in your window would often be set to expand.
	//
	// Call this function to set the expand flag if you would like your widget
	// to become larger horizontally when the window has extra room.
	//
	// By default, widgets automatically expand if any of their children want to
	// expand. (To see if a widget will automatically expand given its current
	// children and state, call gtk_widget_compute_expand(). A container can
	// decide how the expandability of children affects the expansion of the
	// container by overriding the compute_expand virtual method on Widget.).
	//
	// Setting hexpand explicitly with this function will override the automatic
	// expand behavior.
	//
	// This function forces the widget to expand or not to expand, regardless of
	// children. The override occurs because gtk_widget_set_hexpand() sets the
	// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
	// widget’s hexpand value to be used, rather than looking at children and
	// widget state.
	SetHexpand(w Widget, expand bool)
	// SetHexpandSet sets whether the hexpand flag (see
	// gtk_widget_get_hexpand()) will be used.
	//
	// The hexpand-set property will be set automatically when you call
	// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
	// this function would be to unset an explicit expand flag.
	//
	// If hexpand is set, then it overrides any computed expand value based on
	// child widgets. If hexpand is not set, then the expand value depends on
	// whether any children of the widget would like to expand.
	//
	// There are few reasons to use this function, but it’s here for
	// completeness and consistency.
	SetHexpandSet(w Widget, set bool)
	// SetLayoutManager sets the layout manager delegate instance that provides
	// an implementation for measuring and allocating the children of @widget.
	SetLayoutManager(w Widget, layoutManager LayoutManager)
	// SetMarginBottom sets the bottom margin of @widget. See the
	// Widget:margin-bottom property.
	SetMarginBottom(w Widget, margin int)
	// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
	// property.
	SetMarginEnd(w Widget, margin int)
	// SetMarginStart sets the start margin of @widget. See the
	// Widget:margin-start property.
	SetMarginStart(w Widget, margin int)
	// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
	// property.
	SetMarginTop(w Widget, margin int)
	// SetName widgets can be named, which allows you to refer to them from a
	// CSS file. You can apply a style to widgets with a particular name in the
	// CSS file. See the documentation for the CSS syntax (on the same page as
	// the docs for StyleContext).
	//
	// Note that the CSS syntax has certain special characters to delimit and
	// represent elements in a selector (period, #, >, *...), so using these
	// will make your widget impossible to match by name. Any combination of
	// alphanumeric symbols, dashes and underscores will suffice.
	SetName(w Widget, name string)
	// SetOpacity: request the @widget to be rendered partially transparent,
	// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
	// values are clamped to the [0,1] range).
	//
	// Opacity works on both toplevel widgets and child widgets, although there
	// are some limitations: For toplevel widgets, applying opacity depends on
	// the capabilities of the windowing system. On X11, this has any effect
	// only on X displays with a compositing manager, see
	// gdk_display_is_composited(). On Windows and Wayland it should always
	// work, although setting a window’s opacity after the window has been shown
	// may cause some flicker.
	//
	// Note that the opacity is inherited through inclusion — if you set a
	// toplevel to be partially translucent, all of its content will appear
	// translucent, since it is ultimatively rendered on that toplevel. The
	// opacity value itself is not inherited by child widgets (since that would
	// make widgets deeper in the hierarchy progressively more translucent). As
	// a consequence, Popovers and other Native widgets with their own surface
	// will use their own opacity value, and thus by default appear
	// non-translucent, even if they are attached to a toplevel that is
	// translucent.
	SetOpacity(w Widget, opacity float64)
	// SetOverflow sets how @widget treats content that is drawn outside the
	// widget's content area. See the definition of Overflow for details.
	//
	// This setting is provided for widget implementations and should not be
	// used by application code.
	//
	// The default value is GTK_OVERFLOW_VISIBLE.
	SetOverflow(w Widget, overflow Overflow)
	// SetParent: this function is useful only when implementing subclasses of
	// Widget.
	//
	// Sets @parent as the parent widget of @widget, and takes care of some
	// details such as updating the state and style of the child to reflect its
	// new location and resizing the parent. The opposite function is
	// gtk_widget_unparent().
	SetParent(w Widget, parent Widget)
	// SetReceivesDefault specifies whether @widget will be treated as the
	// default widget within its toplevel when it has the focus, even if another
	// widget is the default.
	SetReceivesDefault(w Widget, receivesDefault bool)
	// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
	// the user can interact with it. Insensitive widgets are “grayed out” and
	// the user can’t interact with them. Insensitive widgets are known as
	// “inactive”, “disabled”, or “ghosted” in some other toolkits.
	SetSensitive(w Widget, sensitive bool)
	// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
	// size request will be at least @width by @height. You can use this
	// function to force a widget to be larger than it normally would be.
	//
	// In most cases, gtk_window_set_default_size() is a better choice for
	// toplevel windows than this function; setting the default size will still
	// allow users to shrink the window. Setting the size request will force
	// them to leave the window at least as large as the size request. When
	// dealing with window sizes, gtk_window_set_geometry_hints() can be a
	// useful function as well.
	//
	// Note the inherent danger of setting any fixed size - themes, translations
	// into other languages, different fonts, and user action can all change the
	// appropriate size for a given widget. So, it's basically impossible to
	// hardcode a size that will always be correct.
	//
	// The size request of a widget is the smallest size a widget can accept
	// while still functioning well and drawing itself correctly. However in
	// some strange cases a widget may be allocated less than its requested
	// size, and in many cases a widget may be allocated more space than it
	// requested.
	//
	// If the size request in a given direction is -1 (unset), then the
	// “natural” size request of the widget will be used instead.
	//
	// The size request set here does not include any margin from the Widget
	// properties margin-left, margin-right, margin-top, and margin-bottom, but
	// it does include pretty much all other padding or border properties set by
	// any subclass of Widget.
	SetSizeRequest(w Widget, width int, height int)
	// SetStateFlags: this function is for use in widget implementations. Turns
	// on flag values in the current widget state (insensitive, prelighted,
	// etc.).
	//
	// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
	// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
	// direction, use gtk_widget_set_direction().
	SetStateFlags(w Widget, flags StateFlags, clear bool)
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
	// marked up with the [Pango text markup language][PangoMarkupFormat].
	//
	// This function will take care of setting the Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
	SetTooltipMarkup(w Widget, markup string)
	// SetTooltipText sets @text as the contents of the tooltip.
	//
	// If @text contains any markup, it will be escaped.
	//
	// This function will take care of setting Widget:has-tooltip as a side
	// effect, and of the default handler for the Widget::query-tooltip signal.
	//
	// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
	SetTooltipText(w Widget, text string)
	// SetValign sets the vertical alignment of @widget. See the Widget:valign
	// property.
	SetValign(w Widget, align Align)
	// SetVexpand sets whether the widget would like any available extra
	// vertical space.
	//
	// See gtk_widget_set_hexpand() for more detail.
	SetVexpand(w Widget, expand bool)
	// SetVexpandSet sets whether the vexpand flag (see
	// gtk_widget_get_vexpand()) will be used.
	//
	// See gtk_widget_set_hexpand_set() for more detail.
	SetVexpandSet(w Widget, set bool)
	// SetVisible sets the visibility state of @widget. Note that setting this
	// to true doesn’t mean the widget is actually viewable, see
	// gtk_widget_get_visible().
	//
	// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
	// nicer to use when the visibility of the widget depends on some condition.
	SetVisible(w Widget, visible bool)
	// ShouldLayout returns whether @widget should contribute to the measuring
	// and allocation of its parent. This is false for invisible children, but
	// also for children that have their own surface.
	ShouldLayout(w Widget) bool
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show(w Widget)
	// SnapshotChild: when a widget receives a call to the snapshot function, it
	// must send synthetic WidgetClass.snapshot() calls to all children. This
	// function provides a convenient way of doing this. A widget, when it
	// receives a call to its WidgetClass.snapshot() function, calls
	// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
	// the widget received.
	//
	// gtk_widget_snapshot_child() takes care of translating the origin of
	// @snapshot, and deciding whether the child needs to be snapshot.
	//
	// This function does nothing for children that implement Native.
	SnapshotChild(w Widget, child Widget, snapshot Snapshot)
	// TranslateCoordinates: translate coordinates relative to @src_widget’s
	// allocation to coordinates relative to @dest_widget’s allocations. In
	// order to perform this operation, both widget must share a common
	// toplevel.
	TranslateCoordinates(s Widget, destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool)
	// TriggerTooltipQuery triggers a tooltip query on the display where the
	// toplevel of @widget is located.
	TriggerTooltipQuery(w Widget)
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap(w Widget)
	// Unparent: this function is only for use in widget implementations. It
	// should be called by parent widgets to dissociate @widget from the parent,
	// typically in dispose.
	Unparent(w Widget)
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget).
	Unrealize(w Widget)
	// UnsetStateFlags: this function is for use in widget implementations.
	// Turns off flag values for the current widget state (insensitive,
	// prelighted, etc.). See gtk_widget_set_state_flags().
	UnsetStateFlags(w Widget, flags StateFlags)
}

// widget implements the Widget interface.
type widget struct {
	gextras.Objector
	Accessible
	Buildable
	ConstraintTarget
}

var _ Widget = (*widget)(nil)

// WrapWidget wraps a GObject to the right type. It is
// primarily used internally.
func WrapWidget(obj *externglib.Object) Widget {
	return Widget{
		Objector:         obj,
		Accessible:       WrapAccessible(obj),
		Buildable:        WrapBuildable(obj),
		ConstraintTarget: WrapConstraintTarget(obj),
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWidget(obj), nil
}

// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
func (w widget) ActionSetEnabled(w Widget, actionName string, enabled bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	if enabled {
		arg2 = C.gboolean(1)
	}

	C.gtk_widget_action_set_enabled(arg0, arg1, arg2)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. The activation will emit the signal set
// using gtk_widget_class_set_activate_signal() during class initialization.
//
// Activation is what happens when you press Enter on a widget during key
// navigation.
//
// If you wish to handle the activation keybinding yourself, it is
// recommended to use gtk_widget_class_add_shortcut() with an action created
// with gtk_signal_action_new().
//
// If @widget isn't activatable, the function returns false.
func (w widget) Activate(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_activate(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ActivateActionVariant looks up the action in the action groups associated
// with @widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// gtk_widget_insert_action_group(), the @name is expected to be prefixed
// with the prefix that was used when the group was inserted.
//
// The arguments must match the actions expected parameter type, as returned
// by g_action_get_parameter_type().
func (w widget) ActivateActionVariant(w Widget, name string, args *glib.Variant) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GVariant

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(args.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_activate_action_variant(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// ActivateDefault: activate the default.activate action from @widget.
func (w widget) ActivateDefault(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_activate_default(arg0)
}

// AddController adds @controller to @widget so that it will receive events.
// You will usually want to call this function right after creating any kind
// of EventController.
func (w widget) AddController(w Widget, controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

	C.gtk_widget_add_controller(arg0, arg1)
}

// AddCSSClass adds @css_class to @widget. After calling this function,
// @widget's style will match for @css_class, after the CSS matching rules.
func (w widget) AddCSSClass(w Widget, cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_add_css_class(arg0, arg1)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of
// mnemonic labels for the widget is cleared when the widget is destroyed,
// so the caller must make sure to update its internal state at this point
// as well, by using a connection to the Widget::destroy signal or a weak
// notifier.
func (w widget) AddMnemonicLabel(w Widget, label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_add_mnemonic_label(arg0, arg1)
}

// AddTickCallback queues an animation frame update and adds a callback to
// be called before each frame. Until the tick callback is removed, it will
// be called frequently (usually at the frame rate of the output device or
// as quickly as the application can be repainted, whichever is slower). For
// this reason, is most suitable for handling graphics that change every
// frame or every few frames. The tick callback does not automatically imply
// a relayout or repaint. If you want a repaint or relayout, and aren’t
// changing widget properties that would trigger that (for example, changing
// the text of a Label), then you will have to call
// gtk_widget_queue_resize() or gtk_widget_queue_draw() yourself.
//
// gdk_frame_clock_get_frame_time() should generally be used for timing
// continuous animations and
// gdk_frame_timings_get_predicted_presentation_time() if you are trying to
// display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// FrameClock::update signal of FrameClock, since you don't have to worry
// about when a FrameClock is assigned to a widget.
func (w widget) AddTickCallback(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_add_tick_callback(arg0, arg1, arg2, arg3)
}

// Allocate: this function is only used by Widget subclasses, to assign a
// size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size, as
// well as at least 0×0 in size.
//
// For a version that does not take a transform, see
// gtk_widget_size_allocate()
func (w widget) Allocate(w Widget, width int, height int, baseline int, transform *gsk.Transform) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.GskTransform

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(width)
	arg2 = C.int(height)
	arg3 = C.int(baseline)
	arg4 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_widget_allocate(arg0, arg1, arg2, arg3, arg4)
}

// ChildFocus: this function is used by custom widget implementations; if
// you're writing an app, you’d use gtk_widget_grab_focus() to move the
// focus to a particular widget.
//
// gtk_widget_child_focus() is called by widgets as the user moves around
// the window using keyboard shortcuts. @direction indicates what kind of
// motion is taking place (up, down, left, right, tab forward, tab
// backward). gtk_widget_child_focus() calls the WidgetClass.focus() vfunc;
// widgets override this vfunc in order to implement appropriate focus
// behavior.
//
// The default focus() vfunc for a widget should return true if moving in
// @direction left the focus on a focusable location inside that widget, and
// false if moving in @direction moved the focus outside the widget. If
// returning true, widgets normally call gtk_widget_grab_focus() to place
// the focus accordingly; if returning false, they don’t modify the current
// focus location.
func (w widget) ChildFocus(w Widget, direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkDirectionType)(direction)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_child_focus(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ComputeBounds computes the bounds for @widget in the coordinate space of
// @target. FIXME: Explain what "bounds" are.
//
// If the operation is successful, true is returned. If @widget has no
// bounds or the bounds cannot be expressed in @target's coordinate space
// (for example if both widgets are in different windows), false is returned
// and @bounds is set to the zero rectangle.
//
// It is valid for @widget and @target to be the same widget.
func (w widget) ComputeBounds(w Widget, target Widget) (outBounds *graphene.Rect, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	var arg2 C.graphene_rect_t
	var outBounds *graphene.Rect
	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_compute_bounds(arg0, arg1, &arg2)

	outBounds = graphene.WrapRect(unsafe.Pointer(&arg2))
	if cret {
		ok = true
	}

	return outBounds, ok
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not
// expanded.
//
// The computed expand value uses either the expand setting explicitly set
// on the widget itself, or, if none has been explicitly set, the widget may
// expand if some of its children do.
func (w widget) ComputeExpand(w Widget, orientation Orientation) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkOrientation)(orientation)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_compute_expand(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ComputePoint translates the given @point in @widget's coordinates to
// coordinates relative to @target’s coordinate system. In order to perform
// this operation, both widgets must share a common root.
func (w widget) ComputePoint(w Widget, target Widget, point *graphene.Point) (outPoint *graphene.Point, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.graphene_point_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))
	arg2 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	var arg3 C.graphene_point_t
	var outPoint *graphene.Point
	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_compute_point(arg0, arg1, arg2, &arg3)

	outPoint = graphene.WrapPoint(unsafe.Pointer(&arg3))
	if cret {
		ok = true
	}

	return outPoint, ok
}

// ComputeTransform computes a matrix suitable to describe a transformation
// from @widget's coordinate system into @target's coordinate system.
func (w widget) ComputeTransform(w Widget, target Widget) (outTransform *graphene.Matrix, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	var arg2 C.graphene_matrix_t
	var outTransform *graphene.Matrix
	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_compute_transform(arg0, arg1, &arg2)

	outTransform = graphene.WrapMatrix(unsafe.Pointer(&arg2))
	if cret {
		ok = true
	}

	return outTransform, ok
}

// Contains tests if the point at (@x, @y) is contained in @widget.
//
// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of @widget's content area.
func (w widget) Contains(w Widget, x float64, y float64) bool {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.double(x)
	arg2 = C.double(y)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_contains(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// CreatePangoContext creates a new Context with the appropriate font map,
// font options, font description, and base direction for drawing text for
// this widget. See also gtk_widget_get_pango_context().
func (w widget) CreatePangoContext(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_create_pango_context(arg0)
}

// CreatePangoLayout creates a new Layout with the appropriate font map,
// font description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by listening to
// changes of the Widget:root property on the widget.
func (w widget) CreatePangoLayout(w Widget, text string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_create_pango_layout(arg0, arg1)
}

// DragCheckThreshold checks to see if a mouse drag starting at (@start_x,
// @start_y) and ending at (@current_x, @current_y) has passed the GTK drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
func (w widget) DragCheckThreshold(w Widget, startX int, startY int, currentX int, currentY int) bool {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(startX)
	arg2 = C.int(startY)
	arg3 = C.int(currentX)
	arg4 = C.int(currentY)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_drag_check_threshold(arg0, arg1, arg2, arg3, arg4)

	if cret {
		ok = true
	}

	return ok
}

// ErrorBell notifies the user about an input-related error on this widget.
// If the Settings:gtk-error-bell setting is true, it calls
// gdk_surface_beep(), otherwise it does nothing.
//
// Note that the effect of gdk_surface_beep() can be configured in many
// ways, depending on the windowing backend and the desktop environment or
// window manager that is used.
func (w widget) ErrorBell(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_error_bell(arg0)
}

// AllocatedBaseline returns the baseline that has currently been allocated
// to @widget. This function is intended to be used when implementing
// handlers for the WidgetClass.snapshot() function, and when allocating
// child widgets in WidgetClass.size_allocate().
func (w widget) AllocatedBaseline(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_allocated_baseline(arg0)
}

// AllocatedHeight returns the height that has currently been allocated to
// @widget.
func (w widget) AllocatedHeight(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_allocated_height(arg0)
}

// AllocatedWidth returns the width that has currently been allocated to
// @widget.
func (w widget) AllocatedWidth(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_allocated_width(arg0)
}

// Ancestor gets the first ancestor of @widget with type @widget_type. For
// example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
// Box that’s an ancestor of @widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
func (w widget) Ancestor(w Widget, widgetType externglib.Type) {
	var arg0 *C.GtkWidget
	var arg1 C.GType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 := C.GType(widgetType)

	C.gtk_widget_get_ancestor(arg0, arg1)
}

// CanFocus determines whether the input focus can enter @widget or any of
// its children.
//
// See gtk_widget_set_focusable().
func (w widget) CanFocus(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_can_focus(arg0)

	if cret {
		ok = true
	}

	return ok
}

// CanTarget queries whether @widget can be the target of pointer events.
func (w widget) CanTarget(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_can_target(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If
// you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (w widget) ChildVisible(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_child_visible(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Clipboard: this is a utility function to get the clipboard object for the
// Display that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (w widget) Clipboard(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_clipboard(arg0)
}

// CSSClasses returns the list of css classes applied to @widget.
func (w widget) CSSClasses(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_css_classes(arg0)
}

// CSSName returns the CSS name that is used for @self.
func (s widget) CSSName(s Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))

	C.gtk_widget_get_css_name(arg0)
}

// Cursor queries the cursor set via gtk_widget_set_cursor(). See that
// function for details.
func (w widget) Cursor(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_cursor(arg0)
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
func (w widget) Direction(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_direction(arg0)
}

// Display: get the Display for the toplevel window associated with this
// widget. This function can only be called after the widget has been added
// to a widget hierarchy with a Window at the top.
//
// In general, you should only create display specific resources when a
// widget has been realized, and you should free those resources when the
// widget is unrealized.
func (w widget) Display(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_display(arg0)
}

// FirstChild returns the widgets first child.
//
// This API is primarily meant for widget implementations.
func (w widget) FirstChild(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_first_child(arg0)
}

// FocusChild returns the current focus child of @widget.
func (w widget) FocusChild(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_focus_child(arg0)
}

// FocusOnClick returns whether the widget should grab focus when it is
// clicked with the mouse. See gtk_widget_set_focus_on_click().
func (w widget) FocusOnClick(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_focus_on_click(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Focusable determines whether @widget can own the input focus. See
// gtk_widget_set_focusable().
func (w widget) Focusable(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_focusable(arg0)

	if cret {
		ok = true
	}

	return ok
}

// FontMap gets the font map that has been set with
// gtk_widget_set_font_map().
func (w widget) FontMap(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_font_map(arg0)
}

// FontOptions returns the #cairo_font_options_t used for Pango rendering.
// When not set, the defaults font options for the Display will be used.
func (w widget) FontOptions(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_font_options(arg0)
}

// FrameClock obtains the frame clock for a widget. The frame clock is a
// global “ticker” that can be used to drive animations and repaints. The
// most common reason to get the frame clock is to call
// gdk_frame_clock_get_frame_time(), in order to get a time to use for
// animating. For example you might record the start of the animation with
// an initial value from gdk_frame_clock_get_frame_time(), and then update
// the animation by calling gdk_frame_clock_get_frame_time() again during
// each repaint.
//
// gdk_frame_clock_request_phase() will result in a new frame on the clock,
// but won’t necessarily repaint any widgets. To repaint a widget, you have
// to use gtk_widget_queue_draw() which invalidates the widget (thus
// scheduling it to receive a draw on the next frame).
// gtk_widget_queue_draw() will also end up requesting a frame on the
// appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
func (w widget) FrameClock(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_frame_clock(arg0)
}

// Halign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
func (w widget) Halign(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_halign(arg0)
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
func (w widget) HasTooltip(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_has_tooltip(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Height returns the content height of the widget, as passed to its
// size-allocate implementation. This is the size you should be using in
// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
func (w widget) Height(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_height(arg0)
}

// Hexpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or
// document in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this
// function, to see whether a widget, or any of its children, has the expand
// flag set. If any child of a widget wants to expand, the parent may ask to
// expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
func (w widget) Hexpand(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_hexpand(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HexpandSet gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) HexpandSet(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_hexpand_set(arg0)

	if cret {
		ok = true
	}

	return ok
}

// LastChild returns the widgets last child.
//
// This API is primarily meant for widget implementations.
func (w widget) LastChild(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_last_child(arg0)
}

// LayoutManager retrieves the layout manager set using
// gtk_widget_set_layout_manager().
func (w widget) LayoutManager(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_layout_manager(arg0)
}

// Mapped: whether the widget is mapped.
func (w widget) Mapped(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_mapped(arg0)

	if cret {
		ok = true
	}

	return ok
}

// MarginBottom gets the value of the Widget:margin-bottom property.
func (w widget) MarginBottom(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_margin_bottom(arg0)
}

// MarginEnd gets the value of the Widget:margin-end property.
func (w widget) MarginEnd(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_margin_end(arg0)
}

// MarginStart gets the value of the Widget:margin-start property.
func (w widget) MarginStart(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_margin_start(arg0)
}

// MarginTop gets the value of the Widget:margin-top property.
func (w widget) MarginTop(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_margin_top(arg0)
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
func (w widget) Name(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_name(arg0)
}

// Native returns the GtkNative widget that contains @widget, or nil if the
// widget is not contained inside a widget tree with a native ancestor.
//
// Native widgets will return themselves here.
func (w widget) Native(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_native(arg0)
}

// NextSibling returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
func (w widget) NextSibling(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_next_sibling(arg0)
}

// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
func (w widget) Opacity(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_opacity(arg0)
}

// Overflow returns the value set via gtk_widget_set_overflow().
func (w widget) Overflow(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_overflow(arg0)
}

// PangoContext gets a Context with the appropriate font map, font
// description, and base direction for this widget. Unlike the context
// returned by gtk_widget_create_pango_context(), this context is owned by
// the widget (it can be used until the screen for the widget changes or the
// widget is removed from its toplevel), and will be updated to match any
// changes to the widget’s attributes. This can be tracked by listening to
// changes of the Widget:root property on the widget.
func (w widget) PangoContext(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_pango_context(arg0)
}

// Parent returns the parent widget of @widget.
func (w widget) Parent(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_parent(arg0)
}

// PreferredSize retrieves the minimum and natural size of a widget, taking
// into account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do
// not impose any restrictions on the child placement. It can be used to
// deduce toplevel window and menu sizes as well as child widgets in
// free-form containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width
// widget will generally be a smaller size than the minimum height, since
// the required height for the natural width is generally smaller than the
// required height for the minimum width.
//
// Use gtk_widget_measure() if you want to support baseline alignment.
func (w widget) PreferredSize(w Widget) (minimumSize *Requisition, naturalSize *Requisition) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var arg1 C.GtkRequisition
	var minimumSize *Requisition
	var arg2 C.GtkRequisition
	var naturalSize *Requisition

	C.gtk_widget_get_preferred_size(arg0, &arg1, &arg2)

	minimumSize = WrapRequisition(unsafe.Pointer(&arg1))
	naturalSize = WrapRequisition(unsafe.Pointer(&arg2))

	return minimumSize, naturalSize
}

// PrevSibling returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
func (w widget) PrevSibling(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_prev_sibling(arg0)
}

// PrimaryClipboard: this is a utility function to get the primary clipboard
// object for the Display that @widget is using.
//
// Note that this function always works, even when @widget is not realized
// yet.
func (w widget) PrimaryClipboard(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_primary_clipboard(arg0)
}

// Realized determines whether @widget is realized.
func (w widget) Realized(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_realized(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ReceivesDefault determines whether @widget is always treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
//
// See gtk_widget_set_receives_default().
func (w widget) ReceivesDefault(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_receives_default(arg0)

	if cret {
		ok = true
	}

	return ok
}

// RequestMode gets whether the widget prefers a height-for-width layout or
// a width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or
// in context of their allocation capabilities.
func (w widget) RequestMode(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_request_mode(arg0)
}

// Root returns the Root widget of @widget or nil if the widget is not
// contained inside a widget tree with a root widget.
//
// Root widgets will return themselves here.
func (w widget) Root(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_root(arg0)
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is
// 1, on high density outputs, it can be a higher value (typically 2).
//
// See gdk_surface_get_scale_factor().
func (w widget) ScaleFactor(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_scale_factor(arg0)
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its
// own and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
func (w widget) Sensitive(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_sensitive(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Settings gets the settings object holding the settings used for this
// widget.
//
// Note that this function can only be called when the Widget is attached to
// a toplevel, since the settings object is specific to a particular
// Display. If you want to monitor the widget for changes in its settings,
// connect to notify::display.
func (w widget) Settings(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_settings(arg0)
}

// Size returns the content width or height of the widget, depending on
// @orientation. This is equivalent to calling gtk_widget_get_width() for
// GTK_ORIENTATION_HORIZONTAL or gtk_widget_get_height() for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing Orientable
// widgets.
func (w widget) Size(w Widget, orientation Orientation) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkOrientation)(orientation)

	C.gtk_widget_get_size(arg0, arg1)
}

// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly and the
// natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_measure() instead of this function.
func (w widget) SizeRequest(w Widget) (width int, height int) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var arg1 C.int
	var width int
	var arg2 C.int
	var height int

	C.gtk_widget_get_size_request(arg0, &arg1, &arg2)

	width = int(&arg1)
	height = int(&arg2)

	return width, height
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned,
// that is, also based on parent insensitivity, even if @widget itself is
// sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to
// pass to a StyleContext method, you should look at
// gtk_style_context_get_state().
func (w widget) StateFlags(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_state_flags(arg0)
}

// StyleContext returns the style context associated to @widget. The
// returned object is guaranteed to be the same for the lifetime of @widget.
func (w widget) StyleContext(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_style_context(arg0)
}

// TemplateChild: fetch an object build from the template XML for
// @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
func (w widget) TemplateChild(w Widget, widgetType externglib.Type, name string) {
	var arg0 *C.GtkWidget
	var arg1 C.GType
	var arg2 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 := C.GType(widgetType)
	arg2 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	C.gtk_widget_get_template_child(arg0, arg1, arg2)
}

// TooltipMarkup gets the contents of the tooltip for @widget set using
// gtk_widget_set_tooltip_markup().
func (w widget) TooltipMarkup(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_tooltip_markup(arg0)
}

// TooltipText gets the contents of the tooltip for @widget.
//
// If the @widget's tooltip was set using gtk_widget_set_tooltip_markup(),
// this function will return the escaped text.
func (w widget) TooltipText(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_tooltip_text(arg0)
}

// Valign gets the value of the Widget:valign property.
func (w widget) Valign(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_valign(arg0)
}

// Vexpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
func (w widget) Vexpand(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_vexpand(arg0)

	if cret {
		ok = true
	}

	return ok
}

// VexpandSet gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
func (w widget) VexpandSet(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_vexpand_set(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Visible determines whether the widget is visible. If you want to take
// into account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
func (w widget) Visible(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_get_visible(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Width returns the content width of the widget, as passed to its
// size-allocate implementation. This is the size you should be using in
// GtkWidgetClass.snapshot(). For pointer events, see gtk_widget_contains().
func (w widget) Width(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_get_width(arg0)
}

// GrabFocus causes @widget (or one of its descendents) to have the keyboard
// focus for the Window it's inside.
//
// If @widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of @widget that is focusable, it will
// not take focus and false will be returned.
//
// Calling gtk_widget_grab_focus() on an already focused widget is allowed,
// should not have an effect, and return true.
func (w widget) GrabFocus(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_grab_focus(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HasCSSClass returns whether @css_class is currently applied to @widget.
func (w widget) HasCSSClass(w Widget, cssClass string) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_has_css_class(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// HasDefault determines whether @widget is the current default widget
// within its toplevel.
func (w widget) HasDefault(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_has_default(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
func (w widget) HasFocus(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_has_focus(arg0)

	if cret {
		ok = true
	}

	return ok
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function that
// takes into account whether focus indication should currently be shown in
// the toplevel window of @widget. See gtk_window_get_focus_visible() for
// more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
func (w widget) HasVisibleFocus(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_has_visible_focus(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (w widget) Hide(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_hide(arg0)
}

// InDestruction returns whether the widget is currently being destroyed.
// This information can sometimes be used to avoid doing unnecessary work.
func (w widget) InDestruction(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_in_destruction(arg0)

	if cret {
		ok = true
	}

	return ok
}

// InitTemplate creates and initializes child widgets defined in templates.
// This function must be called in the instance initializer for any class
// which assigned itself a template using gtk_widget_class_set_template()
//
// It is important to call this function in the instance initializer of a
// Widget subclass and not in #GObject.constructed() or
// #GObject.constructor() for two reasons.
//
// One reason is that generally derived widgets will assume that parent
// class composite widgets have been created in their instance initializers.
//
// Another reason is that when calling g_object_new() on a widget with
// composite templates, it’s important to build the composite widgets before
// the construct properties are set. Properties passed to g_object_new()
// should take precedence over properties set in the private template XML.
func (w widget) InitTemplate(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_init_template(arg0)
}

// InsertActionGroup inserts @group into @widget. Children of @widget that
// implement Actionable can then be associated with actions in @group by
// setting their “action-name” to @prefix.`action-name`.
//
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix @prefix, actions with the same prefix will
// still be inherited from the parent, unless the group contains an action
// with the same name.
//
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
func (w widget) InsertActionGroup(w Widget, name string, group gio.ActionGroup) {
	var arg0 *C.GtkWidget
	var arg1 *C.char
	var arg2 *C.GActionGroup

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

	C.gtk_widget_insert_action_group(arg0, arg1, arg2)
}

// InsertAfter inserts @widget into the child widget list of @parent.
//
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is nil.
//
// After calling this function, gtk_widget_get_prev_sibling(widget) will
// return @previous_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (w widget) InsertAfter(w Widget, parent Widget, previousSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(previousSibling.Native()))

	C.gtk_widget_insert_after(arg0, arg1, arg2)
}

// InsertBefore inserts @widget into the child widget list of @parent.
//
// It will be placed before @next_sibling, or at the end if @next_sibling is
// nil.
//
// After calling this function, gtk_widget_get_next_sibling(widget) will
// return @next_sibling.
//
// If @parent is already set as the parent widget of @widget, this function
// can also be used to reorder @widget in the child widget list of @parent.
//
// This API is primarily meant for widget implementations; if you are just
// using a widget, you *must* use its own API for adding children.
func (w widget) InsertBefore(w Widget, parent Widget, nextSibling Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
	arg2 = (*C.GtkWidget)(unsafe.Pointer(nextSibling.Native()))

	C.gtk_widget_insert_before(arg0, arg1, arg2)
}

// IsAncestor determines whether @widget is somewhere inside @ancestor,
// possibly with intermediate containers.
func (w widget) IsAncestor(w Widget, ancestor Widget) bool {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_is_ancestor(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// IsDrawable determines whether @widget can be drawn to. A widget can be
// drawn if it is mapped and visible.
func (w widget) IsDrawable(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_is_drawable(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily
// set; Widget:has-focus will only be set if the toplevel widget
// additionally has the global input focus.)
func (w widget) IsFocus(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_is_focus(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive
func (w widget) IsSensitive(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_is_sensitive(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk_widget_get_visible() and gtk_widget_set_visible()
func (w widget) IsVisible(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_is_visible(arg0)

	if cret {
		ok = true
	}

	return ok
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of
// gtk_widget_child_focus():
//
// When true is returned, stay in the widget, the failed keyboard navigation
// is OK and/or there is nowhere we can/should move the focus to.
//
// When false is returned, the caller should continue with keyboard
// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
// on the widget’s toplevel.
//
// The default ::keynav-failed handler returns false for GTK_DIR_TAB_FORWARD
// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
// returns true.
//
// Whenever the default handler returns true, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard
// navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license
// keys.
func (w widget) KeynavFailed(w Widget, direction DirectionType) bool {
	var arg0 *C.GtkWidget
	var arg1 C.GtkDirectionType

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkDirectionType)(direction)

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_keynav_failed(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ListMnemonicLabels returns a newly allocated list of the widgets,
// normally labels, for which this widget is the target of a mnemonic (see
// for example, gtk_label_set_mnemonic_widget()).
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that
// might destroy the widgets, you must call `g_list_foreach (result,
// (GFunc)g_object_ref, NULL)` first, and then unref all the widgets
// afterwards.
func (w widget) ListMnemonicLabels(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_list_mnemonic_labels(arg0)
}

// Map: this function is only for use in widget implementations. Causes a
// widget to be mapped if it isn’t already.
func (w widget) Map(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_map(arg0)
}

// Measure measures @widget in the orientation @orientation and for the
// given @for_size. As an example, if @orientation is
// GTK_ORIENTATION_HORIZONTAL and @for_size is 300, this functions will
// compute the minimum and natural width of @widget if it is allocated at a
// height of 300 pixels.
//
// See [GtkWidget’s geometry management section][geometry-management] for a
// more details on implementing WidgetClass.measure().
func (w widget) Measure(w Widget, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOrientation
	var arg2 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkOrientation)(orientation)
	arg2 = C.int(forSize)

	var arg3 C.int
	var minimum int
	var arg4 C.int
	var natural int
	var arg5 C.int
	var minimumBaseline int
	var arg6 C.int
	var naturalBaseline int

	C.gtk_widget_measure(arg0, arg1, arg2, &arg3, &arg4, &arg5, &arg6)

	minimum = int(&arg3)
	natural = int(&arg4)
	minimumBaseline = int(&arg5)
	naturalBaseline = int(&arg6)

	return minimum, natural, minimumBaseline, naturalBaseline
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
func (w widget) MnemonicActivate(w Widget, groupCycling bool) bool {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if groupCycling {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_mnemonic_activate(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ObserveChildren returns a Model to track the children of @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (w widget) ObserveChildren(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_observe_children(arg0)
}

// ObserveControllers returns a Model to track the EventControllers of
// @widget.
//
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (w widget) ObserveControllers(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_observe_controllers(arg0)
}

// Pick finds the descendant of @widget (including @widget itself) closest
// to the screen at the point (@x, @y). The point must be given in widget
// coordinates, so (0, 0) is assumed to be the top left of @widget's content
// area.
//
// Usually widgets will return nil if the given coordinate is not contained
// in @widget checked via gtk_widget_contains(). Otherwise they will
// recursively try to find a child that does not return nil. Widgets are
// however free to customize their picking algorithm.
//
// This function is used on the toplevel to determine the widget below the
// mouse cursor for purposes of hover highlighting and delivering events.
func (w widget) Pick(w Widget, x float64, y float64, flags PickFlags) {
	var arg0 *C.GtkWidget
	var arg1 C.double
	var arg2 C.double
	var arg3 C.GtkPickFlags

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.double(x)
	arg2 = C.double(y)
	arg3 = (C.GtkPickFlags)(flags)

	C.gtk_widget_pick(arg0, arg1, arg2, arg3)
}

// QueueAllocate: this function is only for use in widget implementations.
//
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate
// function. Use this function instead of gtk_widget_queue_resize() when the
// @widget's size request didn't change but it wants to reposition its
// contents.
//
// An example user of this function is gtk_widget_set_halign().
func (w widget) QueueAllocate(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_allocate(arg0)
}

// QueueDraw schedules this widget to be redrawn in paint phase of the
// current or the next frame. This means @widget's GtkWidgetClass.snapshot()
// implementation will be called.
func (w widget) QueueDraw(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_draw(arg0)
}

// QueueResize: this function is only for use in widget implementations.
// Flags a widget to have its size renegotiated; should be called when a
// widget for some reason has a new size request. For example, when you
// change the text in a Label, Label queues a resize to ensure there’s
// enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from
// inside its implementation of the GtkWidgetClass::size_allocate virtual
// method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
func (w widget) QueueResize(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_queue_resize(arg0)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be
// realized; calling gtk_widget_realize() realizes the widget’s parents in
// addition to @widget itself. If a widget is not yet inside a toplevel
// window when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget
// is realized automatically, such as Widget::realize.
func (w widget) Realize(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_realize(arg0)
}

// RemoveController removes @controller from @widget, so that it doesn't
// process events anymore. It should not be used again.
//
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
func (w widget) RemoveController(w Widget, controller EventController) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkEventController

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

	C.gtk_widget_remove_controller(arg0, arg1)
}

// RemoveCSSClass removes @css_class from @widget. After this, the style of
// @widget will stop matching for @css_class.
func (w widget) RemoveCSSClass(w Widget, cssClass string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(cssClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_remove_css_class(arg0, arg1)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must
// have previously been added to the list with
// gtk_widget_add_mnemonic_label().
func (w widget) RemoveMnemonicLabel(w Widget, label Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

	C.gtk_widget_remove_mnemonic_label(arg0, arg1)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
func (w widget) RemoveTickCallback(w Widget, id uint) {
	var arg0 *C.GtkWidget
	var arg1 C.guint

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(arg0, arg1)
}

// SetCanFocus specifies whether the input focus can enter the widget or any
// of its children.
//
// Applications should set @can_focus to false to mark a widget as for
// pointer/touch use only.
//
// Note that having @can_focus be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// focusable and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See gtk_widget_grab_focus() for actually setting the input focus on a
// widget.
func (w widget) SetCanFocus(w Widget, canFocus bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canFocus {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_can_focus(arg0, arg1)
}

// SetCanTarget sets whether @widget can be the target of pointer events.
func (w widget) SetCanTarget(w Widget, canTarget bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if canTarget {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_can_target(arg0, arg1)
}

// SetChildVisible sets whether @widget should be mapped along with its when
// its parent is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a
// container with gtk_widget_set_parent(), to avoid mapping children
// unnecessary before immediately unmapping them. However it will be reset
// to its default state of true when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a
// resize on the widget. Most of the time, the size of a widget is computed
// from all visible children, whether or not they are mapped. If this is not
// the case, the container can queue a resize itself.
//
// This function is only useful for container implementations and never
// should be called by an application.
func (w widget) SetChildVisible(w Widget, childVisible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if childVisible {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_child_visible(arg0, arg1)
}

// SetCSSClasses: will clear all css classes applied to @widget and replace
// them with @classes.
func (w widget) SetCSSClasses(w Widget, classes []string) {
	var arg0 *C.GtkWidget
	var arg1 **C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.malloc(len(classes) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.char
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(classes)))

		for i := range classes {
			out[i] = (*C.char)(C.CString(classes[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_widget_set_css_classes(arg0, arg1)
}

// SetCursor sets the cursor to be shown when pointer devices point towards
// @widget.
//
// If the @cursor is NULL, @widget will use the cursor inherited from the
// parent widget.
func (w widget) SetCursor(w Widget, cursor gdk.Cursor) {
	var arg0 *C.GtkWidget
	var arg1 *C.GdkCursor

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gtk_widget_set_cursor(arg0, arg1)
}

// SetCursorFromName sets a named cursor to be shown when pointer devices
// point towards @widget.
//
// This is a utility function that creates a cursor via
// gdk_cursor_new_from_name() and then sets it on @widget with
// gtk_widget_set_cursor(). See those 2 functions for details.
//
// On top of that, this function allows @name to be nil, which will do the
// same as calling gtk_widget_set_cursor() with a nil cursor.
func (w widget) SetCursorFromName(w Widget, name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_cursor_from_name(arg0, arg1)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct
// localization into languages with right-to-left reading directions can be
// done. Generally, applications will let the default reading direction
// present, except for containers where the containers are arranged in an
// order that is explicitly visual rather than logical (such as buttons for
// text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
func (w widget) SetDirection(w Widget, dir TextDirection) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkTextDirection

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction(arg0, arg1)
}

// SetFocusChild: set @child as the current focus child of @widget. The
// previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk_widget_grab_focus() on
// it.
func (w widget) SetFocusChild(w Widget, child Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_widget_set_focus_child(arg0, arg1)
}

// SetFocusOnClick sets whether the widget should grab focus when it is
// clicked with the mouse. Making mouse clicks not grab focus is useful in
// places like toolbars where you don’t want the keyboard focus removed from
// the main area of the application.
func (w widget) SetFocusOnClick(w Widget, focusOnClick bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusOnClick {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_focus_on_click(arg0, arg1)
}

// SetFocusable specifies whether @widget can own the input focus.
//
// Widget implementations should set @focusable to true in their init()
// function if they want to receive keyboard input.
//
// Note that having @focusable be true is only one of the necessary
// conditions for being focusable. A widget must also be sensitive and
// can-focus and not have an ancestor that is marked as not can-focus in
// order to receive input focus.
//
// See gtk_widget_grab_focus() for actually setting the input focus on a
// widget.
func (w widget) SetFocusable(w Widget, focusable bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if focusable {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_focusable(arg0, arg1)
}

// SetFontMap sets the font map to use for Pango rendering. The font map is
// the object that is used to look up fonts. Setting a custom font map can
// be useful in special situations, e.g. when you need to add
// application-specific fonts to the set of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
func (w widget) SetFontMap(w Widget, fontMap pango.FontMap) {
	var arg0 *C.GtkWidget
	var arg1 *C.PangoFontMap

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

	C.gtk_widget_set_font_map(arg0, arg1)
}

// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Display will
// be used.
func (w widget) SetFontOptions(w Widget, options *cairo.FontOptions) {
	var arg0 *C.GtkWidget
	var arg1 *C.cairo_font_options_t

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

	C.gtk_widget_set_font_options(arg0, arg1)
}

// SetHalign sets the horizontal alignment of @widget. See the Widget:halign
// property.
func (w widget) SetHalign(w Widget, align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_halign(arg0, arg1)
}

// SetHasTooltip sets the has-tooltip property on @widget to @has_tooltip.
// See Widget:has-tooltip for more information.
func (w widget) SetHasTooltip(w Widget, hasTooltip bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if hasTooltip {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_has_tooltip(arg0, arg1)
}

// SetHexpand sets whether the widget would like any available extra
// horizontal space. When a user resizes a Window, widgets with expand=TRUE
// generally receive the extra space. For example, a list or scrollable area
// or document in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget
// to become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can
// decide how the expandability of children affects the expansion of the
// container by overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and
// widget state.
func (w widget) SetHexpand(w Widget, expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_hexpand(arg0, arg1)
}

// SetHexpandSet sets whether the hexpand flag (see
// gtk_widget_get_hexpand()) will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on
// child widgets. If hexpand is not set, then the expand value depends on
// whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for
// completeness and consistency.
func (w widget) SetHexpandSet(w Widget, set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_hexpand_set(arg0, arg1)
}

// SetLayoutManager sets the layout manager delegate instance that provides
// an implementation for measuring and allocating the children of @widget.
func (w widget) SetLayoutManager(w Widget, layoutManager LayoutManager) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkLayoutManager

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkLayoutManager)(unsafe.Pointer(layoutManager.Native()))

	C.gtk_widget_set_layout_manager(arg0, arg1)
}

// SetMarginBottom sets the bottom margin of @widget. See the
// Widget:margin-bottom property.
func (w widget) SetMarginBottom(w Widget, margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_bottom(arg0, arg1)
}

// SetMarginEnd sets the end margin of @widget. See the Widget:margin-end
// property.
func (w widget) SetMarginEnd(w Widget, margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_end(arg0, arg1)
}

// SetMarginStart sets the start margin of @widget. See the
// Widget:margin-start property.
func (w widget) SetMarginStart(w Widget, margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_start(arg0, arg1)
}

// SetMarginTop sets the top margin of @widget. See the Widget:margin-top
// property.
func (w widget) SetMarginTop(w Widget, margin int) {
	var arg0 *C.GtkWidget
	var arg1 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(margin)

	C.gtk_widget_set_margin_top(arg0, arg1)
}

// SetName widgets can be named, which allows you to refer to them from a
// CSS file. You can apply a style to widgets with a particular name in the
// CSS file. See the documentation for the CSS syntax (on the same page as
// the docs for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these
// will make your widget impossible to match by name. Any combination of
// alphanumeric symbols, dashes and underscores will suffice.
func (w widget) SetName(w Widget, name string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_name(arg0, arg1)
}

// SetOpacity: request the @widget to be rendered partially transparent,
// with opacity 0 being fully transparent and 1 fully opaque. (Opacity
// values are clamped to the [0,1] range).
//
// Opacity works on both toplevel widgets and child widgets, although there
// are some limitations: For toplevel widgets, applying opacity depends on
// the capabilities of the windowing system. On X11, this has any effect
// only on X displays with a compositing manager, see
// gdk_display_is_composited(). On Windows and Wayland it should always
// work, although setting a window’s opacity after the window has been shown
// may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set a
// toplevel to be partially translucent, all of its content will appear
// translucent, since it is ultimatively rendered on that toplevel. The
// opacity value itself is not inherited by child widgets (since that would
// make widgets deeper in the hierarchy progressively more translucent). As
// a consequence, Popovers and other Native widgets with their own surface
// will use their own opacity value, and thus by default appear
// non-translucent, even if they are attached to a toplevel that is
// translucent.
func (w widget) SetOpacity(w Widget, opacity float64) {
	var arg0 *C.GtkWidget
	var arg1 C.double

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(arg0, arg1)
}

// SetOverflow sets how @widget treats content that is drawn outside the
// widget's content area. See the definition of Overflow for details.
//
// This setting is provided for widget implementations and should not be
// used by application code.
//
// The default value is GTK_OVERFLOW_VISIBLE.
func (w widget) SetOverflow(w Widget, overflow Overflow) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkOverflow

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkOverflow)(overflow)

	C.gtk_widget_set_overflow(arg0, arg1)
}

// SetParent: this function is useful only when implementing subclasses of
// Widget.
//
// Sets @parent as the parent widget of @widget, and takes care of some
// details such as updating the state and style of the child to reflect its
// new location and resizing the parent. The opposite function is
// gtk_widget_unparent().
func (w widget) SetParent(w Widget, parent Widget) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

	C.gtk_widget_set_parent(arg0, arg1)
}

// SetReceivesDefault specifies whether @widget will be treated as the
// default widget within its toplevel when it has the focus, even if another
// widget is the default.
func (w widget) SetReceivesDefault(w Widget, receivesDefault bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if receivesDefault {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_receives_default(arg0, arg1)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if
// the user can interact with it. Insensitive widgets are “grayed out” and
// the user can’t interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
func (w widget) SetSensitive(w Widget, sensitive bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if sensitive {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_sensitive(arg0, arg1)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s
// size request will be at least @width by @height. You can use this
// function to force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for
// toplevel windows than this function; setting the default size will still
// allow users to shrink the window. Setting the size request will force
// them to leave the window at least as large as the size request. When
// dealing with window sizes, gtk_window_set_geometry_hints() can be a
// useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept
// while still functioning well and drawing itself correctly. However in
// some strange cases a widget may be allocated less than its requested
// size, and in many cases a widget may be allocated more space than it
// requested.
//
// If the size request in a given direction is -1 (unset), then the
// “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but
// it does include pretty much all other padding or border properties set by
// any subclass of Widget.
func (w widget) SetSizeRequest(w Widget, width int, height int) {
	var arg0 *C.GtkWidget
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = C.int(width)
	arg2 = C.int(height)

	C.gtk_widget_set_size_request(arg0, arg1, arg2)
}

// SetStateFlags: this function is for use in widget implementations. Turns
// on flag values in the current widget state (insensitive, prelighted,
// etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
func (w widget) SetStateFlags(w Widget, flags StateFlags, clear bool) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags
	var arg2 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(flags)
	if clear {
		arg2 = C.gboolean(1)
	}

	C.gtk_widget_set_state_flags(arg0, arg1, arg2)
}

// SetTooltipMarkup sets @markup as the contents of the tooltip, which is
// marked up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting the Widget:has-tooltip as a side
// effect, and of the default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
func (w widget) SetTooltipMarkup(w Widget, markup string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_markup(arg0, arg1)
}

// SetTooltipText sets @text as the contents of the tooltip.
//
// If @text contains any markup, it will be escaped.
//
// This function will take care of setting Widget:has-tooltip as a side
// effect, and of the default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
func (w widget) SetTooltipText(w Widget, text string) {
	var arg0 *C.GtkWidget
	var arg1 *C.char

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gtk_widget_set_tooltip_text(arg0, arg1)
}

// SetValign sets the vertical alignment of @widget. See the Widget:valign
// property.
func (w widget) SetValign(w Widget, align Align) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkAlign

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkAlign)(align)

	C.gtk_widget_set_valign(arg0, arg1)
}

// SetVexpand sets whether the widget would like any available extra
// vertical space.
//
// See gtk_widget_set_hexpand() for more detail.
func (w widget) SetVexpand(w Widget, expand bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if expand {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_vexpand(arg0, arg1)
}

// SetVexpandSet sets whether the vexpand flag (see
// gtk_widget_get_vexpand()) will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
func (w widget) SetVexpandSet(w Widget, set bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if set {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_vexpand_set(arg0, arg1)
}

// SetVisible sets the visibility state of @widget. Note that setting this
// to true doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
func (w widget) SetVisible(w Widget, visible bool) {
	var arg0 *C.GtkWidget
	var arg1 C.gboolean

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	if visible {
		arg1 = C.gboolean(1)
	}

	C.gtk_widget_set_visible(arg0, arg1)
}

// ShouldLayout returns whether @widget should contribute to the measuring
// and allocation of its parent. This is false for invisible children, but
// also for children that have their own surface.
func (w widget) ShouldLayout(w Widget) bool {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_should_layout(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their toplevel
// container is realized and mapped.
func (w widget) Show(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_show(arg0)
}

// SnapshotChild: when a widget receives a call to the snapshot function, it
// must send synthetic WidgetClass.snapshot() calls to all children. This
// function provides a convenient way of doing this. A widget, when it
// receives a call to its WidgetClass.snapshot() function, calls
// gtk_widget_snapshot_child() once for each child, passing in the @snapshot
// the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of
// @snapshot, and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement Native.
func (w widget) SnapshotChild(w Widget, child Widget, snapshot Snapshot) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 *C.GtkSnapshot

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	arg2 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))

	C.gtk_widget_snapshot_child(arg0, arg1, arg2)
}

// TranslateCoordinates: translate coordinates relative to @src_widget’s
// allocation to coordinates relative to @dest_widget’s allocations. In
// order to perform this operation, both widget must share a common
// toplevel.
func (s widget) TranslateCoordinates(s Widget, destWidget Widget, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
	var arg0 *C.GtkWidget
	var arg1 *C.GtkWidget
	var arg2 C.double
	var arg3 C.double

	arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
	arg2 = C.double(srcX)
	arg3 = C.double(srcY)

	var arg4 C.double
	var destX float64
	var arg5 C.double
	var destY float64
	var cret C.gboolean
	var ok bool

	cret = C.gtk_widget_translate_coordinates(arg0, arg1, arg2, arg3, &arg4, &arg5)

	destX = float64(&arg4)
	destY = float64(&arg5)
	if cret {
		ok = true
	}

	return destX, destY, ok
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located.
func (w widget) TriggerTooltipQuery(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_trigger_tooltip_query(arg0)
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (w widget) Unmap(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unmap(arg0)
}

// Unparent: this function is only for use in widget implementations. It
// should be called by parent widgets to dissociate @widget from the parent,
// typically in dispose.
func (w widget) Unparent(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unparent(arg0)
}

// Unrealize: this function is only useful in widget implementations. Causes
// a widget to be unrealized (frees all GDK resources associated with the
// widget).
func (w widget) Unrealize(w Widget) {
	var arg0 *C.GtkWidget

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

	C.gtk_widget_unrealize(arg0)
}

// UnsetStateFlags: this function is for use in widget implementations.
// Turns off flag values for the current widget state (insensitive,
// prelighted, etc.). See gtk_widget_set_state_flags().
func (w widget) UnsetStateFlags(w Widget, flags StateFlags) {
	var arg0 *C.GtkWidget
	var arg1 C.GtkStateFlags

	arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
	arg1 = (C.GtkStateFlags)(flags)

	C.gtk_widget_unset_state_flags(arg0, arg1)
}

// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Requisition struct {
	native C.GtkRequisition
}

// WrapRequisition wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRequisition(ptr unsafe.Pointer) *Requisition {
	if ptr == nil {
		return nil
	}

	return (*Requisition)(ptr)
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRequisition(unsafe.Pointer(b)), nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() {
	C.gtk_requisition_new()
}

// Native returns the underlying C source pointer.
func (r *Requisition) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Width gets the field inside the struct.
func (r *Requisition) Width() int {
	var v int
	v = int(r.native.width)
	return v
}

// Height gets the field inside the struct.
func (r *Requisition) Height() int {
	var v int
	v = int(r.native.height)
	return v
}

// Copy copies a Requisition.
func (r *Requisition) Copy(r *Requisition) {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	C.gtk_requisition_copy(arg0)
}

// Free frees a Requisition.
func (r *Requisition) Free(r *Requisition) {
	var arg0 *C.GtkRequisition

	arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

	C.gtk_requisition_free(arg0)
}
