// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_media_stream_get_type()), F: marshalMediaStream},
	})
}

// MediaStream is the integration point for media playback inside GTK.
//
// GTK provides an implementation of the MediaStream interface that is called
// MediaFile.
//
// Apart from application-facing API for stream playback, MediaStream has a
// number of APIs that are only useful for implementations and should not be
// used in applications: gtk_media_stream_prepared(),
// gtk_media_stream_unprepared(), gtk_media_stream_update(),
// gtk_media_stream_ended(), gtk_media_stream_seek_success(),
// gtk_media_stream_seek_failed(), gtk_media_stream_gerror(),
// gtk_media_stream_error(), gtk_media_stream_error_valist().
type MediaStream interface {
	gextras.Objector
	gdk.Paintable

	// Ended pauses the media stream and marks it as ended. This is a hint only,
	// calls to GtkMediaStream.play() may still happen.
	Ended()
	// Gerror sets @self into an error state. This will pause the stream (you
	// can check for an error via gtk_media_stream_get_error() in your
	// GtkMediaStream.pause() implementation), abort pending seeks and mark the
	// stream as prepared.
	//
	// if the stream is already in an error state, this call will be ignored and
	// the existing error will be retained. FIXME: Or do we want to set the new
	// error?
	//
	// To unset an error, the stream must be reset via a call to
	// gtk_media_stream_unprepared().
	Gerror(error *glib.Error)
	// Duration gets the duration of the stream. If the duration is not known, 0
	// will be returned.
	Duration() int64
	// GetEnded returns whether the streams playback is finished.
	GetEnded() bool
	// Error: if the stream is in an error state, returns the #GError explaining
	// that state. Any type of error can be reported here depending on the
	// implementation of the media stream.
	//
	// A media stream in an error cannot be operated on, calls like
	// gtk_media_stream_play() or gtk_media_stream_seek() will not have any
	// effect.
	//
	// MediaStream itself does not provide a way to unset an error, but
	// implementations may provide options. For example, a MediaFile will unset
	// errors when a new source is set with ie gtk_media_file_set_file().
	Error() *glib.Error
	// Loop returns whether the stream is set to loop. See
	// gtk_media_stream_set_loop() for details.
	Loop() bool
	// Muted returns whether the audio for the stream is muted. See
	// gtk_media_stream_set_muted() for details.
	Muted() bool
	// Playing: return whether the stream is currently playing.
	Playing() bool
	// Timestamp returns the current presentation timestamp in microseconds.
	Timestamp() int64
	// Volume returns the volume of the audio for the stream. See
	// gtk_media_stream_set_volume() for details.
	Volume() float64
	// HasAudio returns whether the stream has audio.
	HasAudio() bool
	// HasVideo returns whether the stream has video.
	HasVideo() bool
	// IsPrepared returns whether the stream has finished initializing and
	// existence of audio and video is known.
	IsPrepared() bool
	// IsSeekable checks if a stream may be seekable.
	//
	// This is meant to be a hint. Streams may not allow seeking even if this
	// function returns true. However, if this function returns false, streams
	// are guaranteed to not be seekable and user interfaces may hide controls
	// that allow seeking.
	//
	// It is allowed to call gtk_media_stream_seek() on a non-seekable stream,
	// though it will not do anything.
	IsSeekable() bool
	// IsSeeking checks if there is currently a seek operation going on.
	IsSeeking() bool
	// Pause pauses playback of the stream. If the stream is not playing, do
	// nothing.
	Pause()
	// Play starts playing the stream. If the stream is in error or already
	// playing, do nothing.
	Play()
	// Prepared: called by MediaStream implementations to advertise the stream
	// being ready to play and providing details about the stream.
	//
	// Note that the arguments are hints. If the stream implementation cannot
	// determine the correct values, it is better to err on the side of caution
	// and return true. User interfaces will use those values to determine what
	// controls to show.
	//
	// This function may not be called again until the stream has been reset via
	// gtk_media_stream_unprepared().
	Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64)
	// Realize: called by users to attach the media stream to a Surface they
	// manage. The stream can then access the resources of @surface for its
	// rendering purposes. In particular, media streams might want to create
	// GLContexts or sync to the FrameClock.
	//
	// Whoever calls this function is responsible for calling
	// gtk_media_stream_unrealize() before either the stream or @surface get
	// destroyed.
	//
	// Multiple calls to this function may happen from different users of the
	// video, even with the same @surface. Each of these calls must be followed
	// by its own call to gtk_media_stream_unrealize().
	//
	// It is not required to call this function to make a media stream work.
	Realize(surface gdk.Surface)
	// Seek: start a seek operation on @self to @timestamp. If @timestamp is out
	// of range, it will be clamped.
	//
	// Seek operations may not finish instantly. While a seek operation is in
	// process, the GtkMediaStream:seeking property will be set.
	//
	// When calling gtk_media_stream_seek() during an ongoing seek operation,
	// the new seek will override any pending seek.
	Seek(timestamp int64)
	// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
	// failure. This will not cause an error on the stream and will assume that
	// playback continues as if no seek had happened.
	//
	// See gtk_media_stream_seek_success() for the other way of ending a seek.
	SeekFailed()
	// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
	// successfully. This function will unset the GtkMediaStream:ended property
	// if it was set.
	//
	// See gtk_media_stream_seek_failed() for the other way of ending a seek.
	SeekSuccess()
	// SetLoop sets whether the stream should loop, ie restart playback from the
	// beginning instead of stopping at the end.
	//
	// Not all streams may support looping, in particular non-seekable streams.
	// Those streams will ignore the loop setting and just end.
	SetLoop(loop bool)
	// SetMuted sets whether the audio stream should be muted. Muting a stream
	// will cause no audio to be played, but it does not modify the volume. This
	// means that muting and then unmuting the stream will restore the volume
	// settings.
	//
	// If the stream has no audio, calling this function will still work but it
	// will not have an audible effect.
	SetMuted(muted bool)
	// SetPlaying starts or pauses playback of the stream.
	SetPlaying(playing bool)
	// SetVolume sets the volume of the audio stream. This function call will
	// work even if the stream is muted.
	//
	// The given @volume should range from 0.0 for silence to 1.0 for as loud as
	// possible. Values outside of this range will be clamped to the nearest
	// value.
	//
	// If the stream has no audio or is muted, calling this function will still
	// work but it will not have an immediate audible effect. When the stream is
	// unmuted, the new volume setting will take effect.
	SetVolume(volume float64)
	// Unprepared resets a given media stream implementation.
	// gtk_media_stream_prepared() can now be called again.
	//
	// This function will also reset any error state the stream was in.
	Unprepared()
	// Unrealize undoes a previous call to gtk_media_stream_realize() and causes
	// the stream to release all resources it had allocated from @surface.
	Unrealize(surface gdk.Surface)
	// Update: media stream implementations should regularly call this function
	// to update the timestamp reported by the stream. It is up to
	// implementations to call this at the frequency they deem appropriate.
	Update(timestamp int64)
}

// mediaStream implements the MediaStream interface.
type mediaStream struct {
	gextras.Objector
	gdk.Paintable
}

var _ MediaStream = (*mediaStream)(nil)

// WrapMediaStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMediaStream(obj *externglib.Object) MediaStream {
	return MediaStream{
		Objector:      obj,
		gdk.Paintable: gdk.WrapPaintable(obj),
	}
}

func marshalMediaStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMediaStream(obj), nil
}

// Ended pauses the media stream and marks it as ended. This is a hint only,
// calls to GtkMediaStream.play() may still happen.
func (s mediaStream) Ended() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_ended(arg0)
}

// Gerror sets @self into an error state. This will pause the stream (you
// can check for an error via gtk_media_stream_get_error() in your
// GtkMediaStream.pause() implementation), abort pending seeks and mark the
// stream as prepared.
//
// if the stream is already in an error state, this call will be ignored and
// the existing error will be retained. FIXME: Or do we want to set the new
// error?
//
// To unset an error, the stream must be reset via a call to
// gtk_media_stream_unprepared().
func (s mediaStream) Gerror(error *glib.Error) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GError

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GError)(unsafe.Pointer(error.Native()))

	C.gtk_media_stream_gerror(arg0, error)
}

// Duration gets the duration of the stream. If the duration is not known, 0
// will be returned.
func (s mediaStream) Duration() int64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gint64
	var ret1 int64

	cret = C.gtk_media_stream_get_duration(arg0)

	ret1 = C.gint64(cret)

	return ret1
}

// GetEnded returns whether the streams playback is finished.
func (s mediaStream) GetEnded() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_get_ended(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Error: if the stream is in an error state, returns the #GError explaining
// that state. Any type of error can be reported here depending on the
// implementation of the media stream.
//
// A media stream in an error cannot be operated on, calls like
// gtk_media_stream_play() or gtk_media_stream_seek() will not have any
// effect.
//
// MediaStream itself does not provide a way to unset an error, but
// implementations may provide options. For example, a MediaFile will unset
// errors when a new source is set with ie gtk_media_file_set_file().
func (s mediaStream) Error() *glib.Error {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret *C.GError
	var ret1 *glib.Error

	cret = C.gtk_media_stream_get_error(arg0)

	ret1 = glib.WrapError(unsafe.Pointer(cret))

	return ret1
}

// Loop returns whether the stream is set to loop. See
// gtk_media_stream_set_loop() for details.
func (s mediaStream) Loop() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_get_loop(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Muted returns whether the audio for the stream is muted. See
// gtk_media_stream_set_muted() for details.
func (s mediaStream) Muted() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_get_muted(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Playing: return whether the stream is currently playing.
func (s mediaStream) Playing() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_get_playing(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Timestamp returns the current presentation timestamp in microseconds.
func (s mediaStream) Timestamp() int64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gint64
	var ret1 int64

	cret = C.gtk_media_stream_get_timestamp(arg0)

	ret1 = C.gint64(cret)

	return ret1
}

// Volume returns the volume of the audio for the stream. See
// gtk_media_stream_set_volume() for details.
func (s mediaStream) Volume() float64 {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.double
	var ret1 float64

	cret = C.gtk_media_stream_get_volume(arg0)

	ret1 = C.double(cret)

	return ret1
}

// HasAudio returns whether the stream has audio.
func (s mediaStream) HasAudio() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_has_audio(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// HasVideo returns whether the stream has video.
func (s mediaStream) HasVideo() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_has_video(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsPrepared returns whether the stream has finished initializing and
// existence of audio and video is known.
func (s mediaStream) IsPrepared() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_is_prepared(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsSeekable checks if a stream may be seekable.
//
// This is meant to be a hint. Streams may not allow seeking even if this
// function returns true. However, if this function returns false, streams
// are guaranteed to not be seekable and user interfaces may hide controls
// that allow seeking.
//
// It is allowed to call gtk_media_stream_seek() on a non-seekable stream,
// though it will not do anything.
func (s mediaStream) IsSeekable() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_is_seekable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsSeeking checks if there is currently a seek operation going on.
func (s mediaStream) IsSeeking() bool {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_media_stream_is_seeking(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Pause pauses playback of the stream. If the stream is not playing, do
// nothing.
func (s mediaStream) Pause() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_pause(arg0)
}

// Play starts playing the stream. If the stream is in error or already
// playing, do nothing.
func (s mediaStream) Play() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_play(arg0)
}

// Prepared: called by MediaStream implementations to advertise the stream
// being ready to play and providing details about the stream.
//
// Note that the arguments are hints. If the stream implementation cannot
// determine the correct values, it is better to err on the side of caution
// and return true. User interfaces will use those values to determine what
// controls to show.
//
// This function may not be called again until the stream has been reset via
// gtk_media_stream_unprepared().
func (s mediaStream) Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean
	var arg2 C.gboolean
	var arg3 C.gboolean
	var arg4 C.gint64

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if hasAudio {
		arg1 = C.gboolean(1)
	}
	if hasVideo {
		arg2 = C.gboolean(1)
	}
	if seekable {
		arg3 = C.gboolean(1)
	}
	arg4 = C.gint64(duration)

	C.gtk_media_stream_prepared(arg0, hasAudio, hasVideo, seekable, duration)
}

// Realize: called by users to attach the media stream to a Surface they
// manage. The stream can then access the resources of @surface for its
// rendering purposes. In particular, media streams might want to create
// GLContexts or sync to the FrameClock.
//
// Whoever calls this function is responsible for calling
// gtk_media_stream_unrealize() before either the stream or @surface get
// destroyed.
//
// Multiple calls to this function may happen from different users of the
// video, even with the same @surface. Each of these calls must be followed
// by its own call to gtk_media_stream_unrealize().
//
// It is not required to call this function to make a media stream work.
func (s mediaStream) Realize(surface gdk.Surface) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GdkSurface

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gtk_media_stream_realize(arg0, surface)
}

// Seek: start a seek operation on @self to @timestamp. If @timestamp is out
// of range, it will be clamped.
//
// Seek operations may not finish instantly. While a seek operation is in
// process, the GtkMediaStream:seeking property will be set.
//
// When calling gtk_media_stream_seek() during an ongoing seek operation,
// the new seek will override any pending seek.
func (s mediaStream) Seek(timestamp int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gint64

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = C.gint64(timestamp)

	C.gtk_media_stream_seek(arg0, timestamp)
}

// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
// failure. This will not cause an error on the stream and will assume that
// playback continues as if no seek had happened.
//
// See gtk_media_stream_seek_success() for the other way of ending a seek.
func (s mediaStream) SeekFailed() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_seek_failed(arg0)
}

// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
// successfully. This function will unset the GtkMediaStream:ended property
// if it was set.
//
// See gtk_media_stream_seek_failed() for the other way of ending a seek.
func (s mediaStream) SeekSuccess() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_seek_success(arg0)
}

// SetLoop sets whether the stream should loop, ie restart playback from the
// beginning instead of stopping at the end.
//
// Not all streams may support looping, in particular non-seekable streams.
// Those streams will ignore the loop setting and just end.
func (s mediaStream) SetLoop(loop bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if loop {
		arg1 = C.gboolean(1)
	}

	C.gtk_media_stream_set_loop(arg0, loop)
}

// SetMuted sets whether the audio stream should be muted. Muting a stream
// will cause no audio to be played, but it does not modify the volume. This
// means that muting and then unmuting the stream will restore the volume
// settings.
//
// If the stream has no audio, calling this function will still work but it
// will not have an audible effect.
func (s mediaStream) SetMuted(muted bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if muted {
		arg1 = C.gboolean(1)
	}

	C.gtk_media_stream_set_muted(arg0, muted)
}

// SetPlaying starts or pauses playback of the stream.
func (s mediaStream) SetPlaying(playing bool) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gboolean

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	if playing {
		arg1 = C.gboolean(1)
	}

	C.gtk_media_stream_set_playing(arg0, playing)
}

// SetVolume sets the volume of the audio stream. This function call will
// work even if the stream is muted.
//
// The given @volume should range from 0.0 for silence to 1.0 for as loud as
// possible. Values outside of this range will be clamped to the nearest
// value.
//
// If the stream has no audio or is muted, calling this function will still
// work but it will not have an immediate audible effect. When the stream is
// unmuted, the new volume setting will take effect.
func (s mediaStream) SetVolume(volume float64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.double

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = C.double(volume)

	C.gtk_media_stream_set_volume(arg0, volume)
}

// Unprepared resets a given media stream implementation.
// gtk_media_stream_prepared() can now be called again.
//
// This function will also reset any error state the stream was in.
func (s mediaStream) Unprepared() {
	var arg0 *C.GtkMediaStream

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

	C.gtk_media_stream_unprepared(arg0)
}

// Unrealize undoes a previous call to gtk_media_stream_realize() and causes
// the stream to release all resources it had allocated from @surface.
func (s mediaStream) Unrealize(surface gdk.Surface) {
	var arg0 *C.GtkMediaStream
	var arg1 *C.GdkSurface

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gtk_media_stream_unrealize(arg0, surface)
}

// Update: media stream implementations should regularly call this function
// to update the timestamp reported by the stream. It is up to
// implementations to call this at the frequency they deem appropriate.
func (s mediaStream) Update(timestamp int64) {
	var arg0 *C.GtkMediaStream
	var arg1 C.gint64

	arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
	arg1 = C.gint64(timestamp)

	C.gtk_media_stream_update(arg0, timestamp)
}
