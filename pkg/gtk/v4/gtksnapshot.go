// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_snapshot_get_type()), F: marshalSnapshot},
	})
}

// Snapshot: `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
//
// It functions in a similar way to a cairo context, and maintains a stack of
// render nodes and their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_…
// functions operate on. Use the gtk_snapshot_push_… functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a `GtkSnapshot` object is as an argument to the
// GtkWidgetClass.snapshot() vfunc. If you need to create your own
// `GtkSnapshot`, use [ctor@Gtk.Snapshot.new].
type Snapshot interface {
	gdk.Snapshot

	// AppendBorder appends a stroked border rectangle inside the given
	// @outline.
	//
	// The four sides of the border can have different widths and colors.
	AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)
	// AppendCairo creates a new `GskCairoNode` and appends it to the current
	// render node of @snapshot, without changing the current node.
	AppendCairo(bounds *graphene.Rect) *cairo.Context
	// AppendColor creates a new render node drawing the @color into the given
	// @bounds and appends it to the current render node of @snapshot.
	//
	// You should try to avoid calling this function if @color is transparent.
	AppendColor(color *gdk.RGBA, bounds *graphene.Rect)
	// AppendConicGradient appends a conic gradient node with the given stops to
	// @snapshot.
	AppendConicGradient()
	// AppendInsetShadow appends an inset shadow into the box given by @outline.
	AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)

	AppendLayout(layout pango.Layout, color *gdk.RGBA)
	// AppendLinearGradient appends a linear gradient node with the given stops
	// to @snapshot.
	AppendLinearGradient()
	// AppendNode appends @node to the current render node of @snapshot, without
	// changing the current node.
	//
	// If @snapshot does not have a current node yet, @node will become the
	// initial node.
	AppendNode(node gsk.RenderNode)
	// AppendOutsetShadow appends an outset shadow node around the box given by
	// @outline.
	AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)
	// AppendRadialGradient appends a radial gradient node with the given stops
	// to @snapshot.
	AppendRadialGradient()
	// AppendRepeatingLinearGradient appends a repeating linear gradient node
	// with the given stops to @snapshot.
	AppendRepeatingLinearGradient()
	// AppendRepeatingRadialGradient appends a repeating radial gradient node
	// with the given stops to @snapshot.
	AppendRepeatingRadialGradient()
	// AppendTexture creates a new render node drawing the @texture into the
	// given @bounds and appends it to the current render node of @snapshot.
	AppendTexture(texture gdk.Texture, bounds *graphene.Rect)
	// FreeToNode returns the node that was constructed by @snapshot and frees
	// @snapshot.
	FreeToNode() gsk.RenderNode
	// FreeToPaintable returns a paintable for the node that was constructed by
	// @snapshot and frees @snapshot.
	FreeToPaintable(size *graphene.Size) gdk.Paintable
	// GLShaderPopTexture removes the top element from the stack of render nodes
	// and adds it to the nearest `GskGLShaderNode` below it.
	//
	// This must be called the same number of times as the number of textures is
	// needed for the shader in [method@Gtk.Snapshot.push_gl_shader].
	GLShaderPopTexture()
	// Perspective applies a perspective projection transform.
	//
	// See [method@Gsk.Transform.perspective] for a discussion on the details.
	Perspective(depth float32)
	// Pop removes the top element from the stack of render nodes, and appends
	// it to the node underneath it.
	Pop()
	// PushBlend blends together two images with the given blend mode.
	//
	// Until the first call to [method@Gtk.Snapshot.pop], the bottom image for
	// the blend operation will be recorded. After that call, the top image to
	// be blended will be recorded until the second call to
	// [method@Gtk.Snapshot.pop].
	//
	// Calling this function requires two subsequent calls to
	// [method@Gtk.Snapshot.pop].
	PushBlend(blendMode gsk.BlendMode)
	// PushBlur blurs an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushBlur(radius float64)
	// PushClip clips an image to a rectangle.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushClip(bounds *graphene.Rect)
	// PushColorMatrix modifies the colors of an image by applying an affine
	// transformation in RGB space.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)
	// PushCrossFade snapshots a cross-fade operation between two images with
	// the given @progress.
	//
	// Until the first call to [method@Gtk.Snapshot.pop], the start image will
	// be snapshot. After that call, the end image will be recorded until the
	// second call to [method@Gtk.Snapshot.pop].
	//
	// Calling this function requires two subsequent calls to
	// [method@Gtk.Snapshot.pop].
	PushCrossFade(progress float64)
	// PushGLShader: push a `GskGLShaderNode`.
	//
	// The node uses the given [class@Gsk.GLShader] and uniform values
	// Additionally this takes a list of @n_children other nodes which will be
	// passed to the `GskGLShaderNode`.
	//
	// The @take_args argument is a block of data to use for uniform arguments,
	// as per types and offsets defined by the @shader. Normally this is
	// generated by [method@Gsk.GLShader.format_args] or
	// [struct@Gsk.ShaderArgsBuilder].
	//
	// The snapshotter takes ownership of @take_args, so the caller should not
	// free it after this.
	//
	// If the renderer doesn't support GL shaders, or if there is any problem
	// when compiling the shader, then the node will draw pink. You should use
	// [method@Gsk.GLShader.compile] to ensure the @shader will work for the
	// renderer before using it.
	//
	// If the shader requires textures (see
	// [method@Gsk.GLShader.get_n_textures]), then it is expected that you call
	// [method@Gtk.Snapshot.gl_shader_pop_texture] the number of times that are
	// required. Each of these calls will generate a node that is added as a
	// child to the `GskGLShaderNode`, which in turn will render these offscreen
	// and pass as a texture to the shader.
	//
	// Once all textures (if any) are pop:ed, you must call the regular
	// [method@Gtk.Snapshot.pop].
	//
	// If you want to use pre-existing textures as input to the shader rather
	// than rendering new ones, use [method@Gtk.Snapshot.append_texture] to push
	// a texture node. These will be used directly rather than being
	// re-rendered.
	//
	// For details on how to write shaders, see [class@Gsk.GLShader].
	PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes)
	// PushOpacity modifies the opacity of an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushOpacity(opacity float64)
	// PushRepeat creates a node that repeats the child node.
	//
	// The child is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect)
	// PushRoundedClip clips an image to a rounded rectangle.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushRoundedClip(bounds *gsk.RoundedRect)
	// PushShadow applies a shadow to an image.
	//
	// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	PushShadow(shadow *gsk.Shadow, nShadows uint)
	// RenderBackground creates a render node for the CSS background according
	// to @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderBackground(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFocus creates a render node for the focus outline according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFocus(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderFrame creates a render node for the CSS border according to
	// @context, and appends it to the current node of @snapshot, without
	// changing the current node.
	RenderFrame(context StyleContext, x float64, y float64, width float64, height float64)
	// RenderInsertionCursor draws a text caret using @snapshot at the specified
	// index of @layout.
	RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction)
	// RenderLayout creates a render node for rendering @layout according to the
	// style information in @context, and appends it to the current node of
	// @snapshot, without changing the current node.
	RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout)
	// Restore restores @snapshot to the state saved by a preceding call to
	// gtk_snapshot_save() and removes that state from the stack of saved
	// states.
	Restore()
	// Rotate rotates @@snapshot's coordinate system by @angle degrees in 2D
	// space - or in 3D speak, rotates around the Z axis.
	//
	// To rotate around other axes, use [method@Gsk.Transform.rotate_3d].
	Rotate(angle float32)
	// Rotate3D rotates @snapshot's coordinate system by @angle degrees around
	// @axis.
	//
	// For a rotation in 2D space, use [method@Gsk.Transform.rotate].
	Rotate3D(angle float32, axis *graphene.Vec3)
	// Save makes a copy of the current state of @snapshot and saves it on an
	// internal stack.
	//
	// When [method@Gtk.Snapshot.restore] is called, @snapshot will be restored
	// to the saved state. Multiple calls to gtk_snapshot_save() and
	// gtk_snapshot_restore() can be nested; each call to gtk_snapshot_restore()
	// restores the state from the matching paired gtk_snapshot_save().
	//
	// It is necessary to clear all saved states with corresponding calls to
	// gtk_snapshot_restore().
	Save()
	// Scale scales @snapshot's coordinate system in 2-dimensional space by the
	// given factors.
	//
	// Use [method@Gtk.Snapshot.scale_3d] to scale in all 3 dimensions.
	Scale(factorX float32, factorY float32)
	// Scale3D scales @snapshot's coordinate system by the given factors.
	Scale3D(factorX float32, factorY float32, factorZ float32)
	// ToNode returns the render node that was constructed by @snapshot.
	//
	// After calling this function, it is no longer possible to add more nodes
	// to @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToNode() gsk.RenderNode
	// ToPaintable returns a paintable encapsulating the render node that was
	// constructed by @snapshot.
	//
	// After calling this function, it is no longer possible to add more nodes
	// to @snapshot. The only function that should be called after this is
	// g_object_unref().
	ToPaintable(size *graphene.Size) gdk.Paintable
	// Transform transforms @snapshot's coordinate system with the given
	// @transform.
	Transform(transform *gsk.Transform)
	// TransformMatrix transforms @snapshot's coordinate system with the given
	// @matrix.
	TransformMatrix(matrix *graphene.Matrix)
	// Translate translates @snapshot's coordinate system by @point in
	// 2-dimensional space.
	Translate(point *graphene.Point)
	// Translate3D translates @snapshot's coordinate system by @point.
	Translate3D(point *graphene.Point3D)
}

// snapshot implements the Snapshot interface.
type snapshot struct {
	gdk.Snapshot
}

var _ Snapshot = (*snapshot)(nil)

// WrapSnapshot wraps a GObject to the right type. It is
// primarily used internally.
func WrapSnapshot(obj *externglib.Object) Snapshot {
	return Snapshot{
		gdk.Snapshot: gdk.WrapSnapshot(obj),
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSnapshot(obj), nil
}

// NewSnapshot constructs a class Snapshot.
func NewSnapshot() Snapshot {
	cret := new(C.GtkSnapshot)
	var goret Snapshot

	cret = C.gtk_snapshot_new()

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Snapshot)

	return goret
}

// AppendBorder appends a stroked border rectangle inside the given
// @outline.
//
// The four sides of the border can have different widths and colors.
func (s snapshot) AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.float
	var arg3 *C.GdkRGBA

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	defer runtime.KeepAlive(&arg2)
	arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))
	defer runtime.KeepAlive(&arg3)

	C.gtk_snapshot_append_border(arg0, arg1, arg2, arg3)
}

// AppendCairo creates a new `GskCairoNode` and appends it to the current
// render node of @snapshot, without changing the current node.
func (s snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	cret := new(C.cairo_t)
	var goret *cairo.Context

	cret = C.gtk_snapshot_append_cairo(arg0, arg1)

	goret = cairo.WrapContext(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *cairo.Context) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// AppendColor creates a new render node drawing the @color into the given
// @bounds and appends it to the current render node of @snapshot.
//
// You should try to avoid calling this function if @color is transparent.
func (s snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GdkRGBA
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_append_color(arg0, arg1, arg2)
}

// AppendConicGradient appends a conic gradient node with the given stops to
// @snapshot.
func (s snapshot) AppendConicGradient() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_append_conic_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendInsetShadow appends an inset shadow into the box given by @outline.
func (s snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_inset_shadow(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

func (s snapshot) AppendLayout(layout pango.Layout, color *gdk.RGBA) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.PangoLayout
	var arg2 *C.GdkRGBA

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

	C.gtk_snapshot_append_layout(arg0, arg1, arg2)
}

// AppendLinearGradient appends a linear gradient node with the given stops
// to @snapshot.
func (s snapshot) AppendLinearGradient() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_append_linear_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendNode appends @node to the current render node of @snapshot, without
// changing the current node.
//
// If @snapshot does not have a current node yet, @node will become the
// initial node.
func (s snapshot) AppendNode(node gsk.RenderNode) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRenderNode

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	C.gtk_snapshot_append_node(arg0, arg1)
}

// AppendOutsetShadow appends an outset shadow node around the box given by
// @outline.
func (s snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_outset_shadow(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AppendRadialGradient appends a radial gradient node with the given stops
// to @snapshot.
func (s snapshot) AppendRadialGradient() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_append_radial_gradient(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AppendRepeatingLinearGradient appends a repeating linear gradient node
// with the given stops to @snapshot.
func (s snapshot) AppendRepeatingLinearGradient() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_append_repeating_linear_gradient(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendRepeatingRadialGradient appends a repeating radial gradient node
// with the given stops to @snapshot.
func (s snapshot) AppendRepeatingRadialGradient() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_append_repeating_radial_gradient(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// AppendTexture creates a new render node drawing the @texture into the
// given @bounds and appends it to the current render node of @snapshot.
func (s snapshot) AppendTexture(texture gdk.Texture, bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GdkTexture
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_append_texture(arg0, arg1, arg2)
}

// FreeToNode returns the node that was constructed by @snapshot and frees
// @snapshot.
func (s snapshot) FreeToNode() gsk.RenderNode {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	cret := new(C.GskRenderNode)
	var goret gsk.RenderNode

	cret = C.gtk_snapshot_free_to_node(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gsk.RenderNode)

	return goret
}

// FreeToPaintable returns a paintable for the node that was constructed by
// @snapshot and frees @snapshot.
func (s snapshot) FreeToPaintable(size *graphene.Size) gdk.Paintable {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_size_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_size_t)(unsafe.Pointer(size.Native()))

	cret := new(C.GdkPaintable)
	var goret gdk.Paintable

	cret = C.gtk_snapshot_free_to_paintable(arg0, arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return goret
}

// GLShaderPopTexture removes the top element from the stack of render nodes
// and adds it to the nearest `GskGLShaderNode` below it.
//
// This must be called the same number of times as the number of textures is
// needed for the shader in [method@Gtk.Snapshot.push_gl_shader].
func (s snapshot) GLShaderPopTexture() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_gl_shader_pop_texture(arg0)
}

// Perspective applies a perspective projection transform.
//
// See [method@Gsk.Transform.perspective] for a discussion on the details.
func (s snapshot) Perspective(depth float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.float(depth)

	C.gtk_snapshot_perspective(arg0, arg1)
}

// Pop removes the top element from the stack of render nodes, and appends
// it to the node underneath it.
func (s snapshot) Pop() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_pop(arg0)
}

// PushBlend blends together two images with the given blend mode.
//
// Until the first call to [method@Gtk.Snapshot.pop], the bottom image for
// the blend operation will be recorded. After that call, the top image to
// be blended will be recorded until the second call to
// [method@Gtk.Snapshot.pop].
//
// Calling this function requires two subsequent calls to
// [method@Gtk.Snapshot.pop].
func (s snapshot) PushBlend(blendMode gsk.BlendMode) {
	var arg0 *C.GtkSnapshot
	var arg1 C.GskBlendMode

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (C.GskBlendMode)(blendMode)

	C.gtk_snapshot_push_blend(arg0, arg1)
}

// PushBlur blurs an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushBlur(radius float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.double(radius)

	C.gtk_snapshot_push_blur(arg0, arg1)
}

// PushClip clips an image to a rectangle.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushClip(bounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_push_clip(arg0, arg1)
}

// PushColorMatrix modifies the colors of an image by applying an affine
// transformation in RGB space.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_matrix_t
	var arg2 *C.graphene_vec4_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix.Native()))
	arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset.Native()))

	C.gtk_snapshot_push_color_matrix(arg0, arg1, arg2)
}

// PushCrossFade snapshots a cross-fade operation between two images with
// the given @progress.
//
// Until the first call to [method@Gtk.Snapshot.pop], the start image will
// be snapshot. After that call, the end image will be recorded until the
// second call to [method@Gtk.Snapshot.pop].
//
// Calling this function requires two subsequent calls to
// [method@Gtk.Snapshot.pop].
func (s snapshot) PushCrossFade(progress float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.double(progress)

	C.gtk_snapshot_push_cross_fade(arg0, arg1)
}

// PushGLShader: push a `GskGLShaderNode`.
//
// The node uses the given [class@Gsk.GLShader] and uniform values
// Additionally this takes a list of @n_children other nodes which will be
// passed to the `GskGLShaderNode`.
//
// The @take_args argument is a block of data to use for uniform arguments,
// as per types and offsets defined by the @shader. Normally this is
// generated by [method@Gsk.GLShader.format_args] or
// [struct@Gsk.ShaderArgsBuilder].
//
// The snapshotter takes ownership of @take_args, so the caller should not
// free it after this.
//
// If the renderer doesn't support GL shaders, or if there is any problem
// when compiling the shader, then the node will draw pink. You should use
// [method@Gsk.GLShader.compile] to ensure the @shader will work for the
// renderer before using it.
//
// If the shader requires textures (see
// [method@Gsk.GLShader.get_n_textures]), then it is expected that you call
// [method@Gtk.Snapshot.gl_shader_pop_texture] the number of times that are
// required. Each of these calls will generate a node that is added as a
// child to the `GskGLShaderNode`, which in turn will render these offscreen
// and pass as a texture to the shader.
//
// Once all textures (if any) are pop:ed, you must call the regular
// [method@Gtk.Snapshot.pop].
//
// If you want to use pre-existing textures as input to the shader rather
// than rendering new ones, use [method@Gtk.Snapshot.append_texture] to push
// a texture node. These will be used directly rather than being
// re-rendered.
//
// For details on how to write shaders, see [class@Gsk.GLShader].
func (s snapshot) PushGLShader(shader gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskGLShader
	var arg2 *C.graphene_rect_t
	var arg3 *C.GBytes

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskGLShader)(unsafe.Pointer(shader.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	arg3 = (*C.GBytes)(unsafe.Pointer(takeArgs.Native()))

	C.gtk_snapshot_push_gl_shader(arg0, arg1, arg2, arg3)
}

// PushOpacity modifies the opacity of an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushOpacity(opacity float64) {
	var arg0 *C.GtkSnapshot
	var arg1 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.double(opacity)

	C.gtk_snapshot_push_opacity(arg0, arg1)
}

// PushRepeat creates a node that repeats the child node.
//
// The child is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds.Native()))

	C.gtk_snapshot_push_repeat(arg0, arg1, arg2)
}

// PushRoundedClip clips an image to a rounded rectangle.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushRoundedClip(bounds *gsk.RoundedRect) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskRoundedRect

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRoundedRect)(unsafe.Pointer(bounds.Native()))

	C.gtk_snapshot_push_rounded_clip(arg0, arg1)
}

// PushShadow applies a shadow to an image.
//
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
func (s snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskShadow
	var arg2 C.gsize

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskShadow)(unsafe.Pointer(shadow.Native()))
	arg2 = C.gsize(nShadows)

	C.gtk_snapshot_push_shadow(arg0, arg1, arg2)
}

// RenderBackground creates a render node for the CSS background according
// to @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (s snapshot) RenderBackground(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_background(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFocus creates a render node for the focus outline according to
// @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (s snapshot) RenderFocus(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_focus(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderFrame creates a render node for the CSS border according to
// @context, and appends it to the current node of @snapshot, without
// changing the current node.
func (s snapshot) RenderFrame(context StyleContext, x float64, y float64, width float64, height float64) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = C.double(width)
	arg5 = C.double(height)

	C.gtk_snapshot_render_frame(arg0, arg1, arg2, arg3, arg4, arg5)
}

// RenderInsertionCursor draws a text caret using @snapshot at the specified
// index of @layout.
func (s snapshot) RenderInsertionCursor(context StyleContext, x float64, y float64, layout pango.Layout, index int, direction pango.Direction) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.PangoLayout
	var arg5 C.int
	var arg6 C.PangoDirection

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	arg5 = C.int(index)
	arg6 = (C.PangoDirection)(direction)

	C.gtk_snapshot_render_insertion_cursor(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// RenderLayout creates a render node for rendering @layout according to the
// style information in @context, and appends it to the current node of
// @snapshot, without changing the current node.
func (s snapshot) RenderLayout(context StyleContext, x float64, y float64, layout pango.Layout) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GtkStyleContext
	var arg2 C.double
	var arg3 C.double
	var arg4 *C.PangoLayout

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
	arg2 = C.double(x)
	arg3 = C.double(y)
	arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.gtk_snapshot_render_layout(arg0, arg1, arg2, arg3, arg4)
}

// Restore restores @snapshot to the state saved by a preceding call to
// gtk_snapshot_save() and removes that state from the stack of saved
// states.
func (s snapshot) Restore() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_restore(arg0)
}

// Rotate rotates @@snapshot's coordinate system by @angle degrees in 2D
// space - or in 3D speak, rotates around the Z axis.
//
// To rotate around other axes, use [method@Gsk.Transform.rotate_3d].
func (s snapshot) Rotate(angle float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.float(angle)

	C.gtk_snapshot_rotate(arg0, arg1)
}

// Rotate3D rotates @snapshot's coordinate system by @angle degrees around
// @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate].
func (s snapshot) Rotate3D(angle float32, axis *graphene.Vec3) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.gtk_snapshot_rotate_3d(arg0, arg1, arg2)
}

// Save makes a copy of the current state of @snapshot and saves it on an
// internal stack.
//
// When [method@Gtk.Snapshot.restore] is called, @snapshot will be restored
// to the saved state. Multiple calls to gtk_snapshot_save() and
// gtk_snapshot_restore() can be nested; each call to gtk_snapshot_restore()
// restores the state from the matching paired gtk_snapshot_save().
//
// It is necessary to clear all saved states with corresponding calls to
// gtk_snapshot_restore().
func (s snapshot) Save() {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	C.gtk_snapshot_save(arg0)
}

// Scale scales @snapshot's coordinate system in 2-dimensional space by the
// given factors.
//
// Use [method@Gtk.Snapshot.scale_3d] to scale in all 3 dimensions.
func (s snapshot) Scale(factorX float32, factorY float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)

	C.gtk_snapshot_scale(arg0, arg1, arg2)
}

// Scale3D scales @snapshot's coordinate system by the given factors.
func (s snapshot) Scale3D(factorX float32, factorY float32, factorZ float32) {
	var arg0 *C.GtkSnapshot
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	C.gtk_snapshot_scale_3d(arg0, arg1, arg2, arg3)
}

// ToNode returns the render node that was constructed by @snapshot.
//
// After calling this function, it is no longer possible to add more nodes
// to @snapshot. The only function that should be called after this is
// g_object_unref().
func (s snapshot) ToNode() gsk.RenderNode {
	var arg0 *C.GtkSnapshot

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

	cret := new(C.GskRenderNode)
	var goret gsk.RenderNode

	cret = C.gtk_snapshot_to_node(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gsk.RenderNode)

	return goret
}

// ToPaintable returns a paintable encapsulating the render node that was
// constructed by @snapshot.
//
// After calling this function, it is no longer possible to add more nodes
// to @snapshot. The only function that should be called after this is
// g_object_unref().
func (s snapshot) ToPaintable(size *graphene.Size) gdk.Paintable {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_size_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_size_t)(unsafe.Pointer(size.Native()))

	cret := new(C.GdkPaintable)
	var goret gdk.Paintable

	cret = C.gtk_snapshot_to_paintable(arg0, arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return goret
}

// Transform transforms @snapshot's coordinate system with the given
// @transform.
func (s snapshot) Transform(transform *gsk.Transform) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.GskTransform

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	C.gtk_snapshot_transform(arg0, arg1)
}

// TransformMatrix transforms @snapshot's coordinate system with the given
// @matrix.
func (s snapshot) TransformMatrix(matrix *graphene.Matrix) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	C.gtk_snapshot_transform_matrix(arg0, arg1)
}

// Translate translates @snapshot's coordinate system by @point in
// 2-dimensional space.
func (s snapshot) Translate(point *graphene.Point) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_point_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	C.gtk_snapshot_translate(arg0, arg1)
}

// Translate3D translates @snapshot's coordinate system by @point.
func (s snapshot) Translate3D(point *graphene.Point3D) {
	var arg0 *C.GtkSnapshot
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
	arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.gtk_snapshot_translate_3d(arg0, arg1)
}
