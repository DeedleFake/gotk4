// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
	})
}

// TextCharPredicate: the predicate function used by
// gtk_text_iter_forward_find_char() and gtk_text_iter_backward_find_char().
type TextCharPredicate func() (ok bool)

//export gotk4_TextCharPredicate
func gotk4_TextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(TextCharPredicate)
	fn(ok)

	if ok {
		cret = C.gboolean(1)
	}
}

// TextIter: an iterator for the contents of a `GtkTextBuffer`.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

// WrapTextIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextIter(ptr unsafe.Pointer) *TextIter {
	if ptr == nil {
		return nil
	}

	return (*TextIter)(ptr)
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTextIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Assign assigns the value of @other to @iter.
//
// This function is not useful in applications, because iterators can be
// assigned with `GtkTextIter i = j;`.
//
// The function is used by language bindings.
func (i *TextIter) Assign(other *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

	C.gtk_text_iter_assign(arg0, arg1)
}

// BackwardChar moves backward by one character offset.
//
// Returns true if movement was possible; if @iter was the first in the buffer
// (character offset 0), this function returns false for convenience when
// writing loops.
func (i *TextIter) BackwardChar() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_char(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardChars moves @count characters backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false.
func (i *TextIter) BackwardChars(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_chars(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (i *TextIter) BackwardCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_cursor_position(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardCursorPositions moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) BackwardCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_cursor_positions(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardLine moves @iter to the start of the previous line.
//
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore, if @iter was already on line 0,
// but not at the start of the line, @iter is snapped to the start of the line
// and the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardLines moves @count lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_lines(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// @match_end will never be set to a `GtkTextIter` located after @iter, even if
// there is a possible @match_start before or at @iter.
func (i *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.char
	var arg2 C.GtkTextSearchFlags
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	arg3 := new(C.GtkTextIter)
	var ret3 *TextIter
	arg4 := new(C.GtkTextIter)
	var ret4 *TextIter
	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_search(arg0, arg1, arg2, arg3, arg4, arg5)

	ret3 = WrapTextIter(unsafe.Pointer(arg3))
	ret4 = WrapTextIter(unsafe.Pointer(arg4))
	if cret {
		goret = true
	}

	return ret3, ret4, goret
}

// BackwardSentenceStart moves backward to the previous sentence start.
//
// If @iter is already at the start of a sentence, moves backward to the next
// one.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) BackwardSentenceStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_sentence_start(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times.
//
// If @count is negative, moves forward instead of backward.
func (i *TextIter) BackwardSentenceStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_sentence_starts(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// @tag, or to the next toggle of any tag if @tag is nil.
//
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles before @iter. Sets @iter to the
// location of the toggle, or the start of the buffer if no toggle is found.
func (i *TextIter) BackwardToTagToggle(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_to_tag_toggle(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (i *TextIter) BackwardVisibleCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_cursor_position(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.backward_cursor_position] for details.
func (i *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_cursor_positions(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleLine moves @iter to the start of the previous visible line.
//
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (i *TextIter) BackwardVisibleLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleLines moves @count visible lines backward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
func (i *TextIter) BackwardVisibleLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_lines(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
//
// If @iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) BackwardVisibleWordStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_word_start(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
func (i *TextIter) BackwardVisibleWordStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_visible_word_starts(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// BackwardWordStart moves backward to the previous word start.
//
// If @iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (i *TextIter) BackwardWordStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_word_start(arg0)

	if cret {
		goret = true
	}

	return goret
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
func (i *TextIter) BackwardWordStarts(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_backward_word_starts(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable.
//
// If text inserted at @iter would be editable then the user should be allowed
// to insert text at @iter. [method@Gtk.TextBuffer.insert_interactive] uses this
// function to decide whether insertions are allowed at a given position.
func (i *TextIter) CanInsert(defaultEditability bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultEditability {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_can_insert(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if they’re equal.
//
// Ordering is in character offset order, i.e. the first character in the buffer
// is less than the second character in the buffer.
func (l *TextIter) Compare(rhs *TextIter) int {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_compare(arg0, arg1)

	goret = int(cret)

	return goret
}

// Copy creates a dynamically-allocated copy of an iterator.
//
// This function is not useful in applications, because iterators can be copied
// with a simple assignment (`GtkTextIter i = j;`).
//
// The function is used by language bindings.
func (i *TextIter) Copy() *TextIter {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	cret := new(C.GtkTextIter)
	var goret *TextIter

	cret = C.gtk_text_iter_copy(arg0)

	goret = WrapTextIter(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *TextIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Editable returns whether the character at @iter is within an editable region
// of text.
//
// Non-editable text is “locked” and can’t be changed by the user via TextView.
// If no tags applied to this text affect editability, @default_setting will be
// returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// @iter, because for insertion you don’t want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// [method@Gtk.TextIter.can_insert] to handle this case.
func (i *TextIter) Editable(defaultSetting bool) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if defaultSetting {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_editable(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line.
//
// Delimiters will be either a newline, a carriage return, a carriage return
// followed by a newline, or a Unicode paragraph separator character.
//
// Note that an iterator pointing to the \n of a \r\n pair will not be counted
// as the end of a line, the line ends before the \r. The end iterator is
// considered to be at the end of a line, even though there are no paragraph
// delimiter chars there.
func (i *TextIter) EndsLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_ends_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// EndsSentence determines whether @iter ends a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) EndsSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_ends_sentence(arg0)

	if cret {
		goret = true
	}

	return goret
}

// EndsTag returns true if @tag is toggled off at exactly this point.
//
// If @tag is nil, returns true if any tag is toggled off at this point.
//
// Note that if this function returns true, it means that @iter is at the end of
// the tagged range, but that the character at @iter is outside the tagged
// range. In other words, unlike [method@Gtk.TextIter.starts_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag] will return false for
// the same parameters.
func (i *TextIter) EndsTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_ends_tag(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// EndsWord determines whether @iter ends a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) EndsWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_ends_word(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism.
//
// This function is very fast; you can expect it to perform better than e.g.
// getting the character offset for each iterator and comparing the offsets
// yourself. Also, it’s a bit faster than [method@Gtk.TextIter.compare].
func (l *TextIter) Equal(rhs *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_equal(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardChar moves @iter forward by one character offset.
//
// Note that images embedded in the buffer occupy 1 character slot, so this
// function may actually move onto an image instead of a character, if you have
// images in your buffer. If @iter is the end iterator or one character before
// it, @iter will now point at the end iterator, and this function returns false
// for convenience when writing loops.
func (i *TextIter) ForwardChar() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_char(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardChars moves @count characters if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the new position of @iter is different
// from its original position, and dereferenceable (the last iterator in the
// buffer is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
func (i *TextIter) ForwardChars(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_chars(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardCursorPosition moves @iter forward by a single cursor position.
//
// Cursor positions are (unsurprisingly) positions where the cursor can appear.
// Perhaps surprisingly, there may not be a cursor position between all
// characters. The most common example for European languages would be a
// carriage return/newline sequence.
//
// For some Unicode characters, the equivalent of say the letter “a” with an
// accent mark will be represented as two characters, first the letter then a
// "combining mark" that causes the accent to be rendered; so the cursor can’t
// go between those two characters.
//
// See also the [struct@Pango.LogAttr] struct and the [func@Pango.break]
// function.
func (i *TextIter) ForwardCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_cursor_position(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardCursorPositions moves up to @count cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_cursor_positions(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardLine moves @iter to the start of the next line.
//
// If the iter is already on the last line of the buffer, moves the iter to the
// end of the current line. If after the operation, the iter is at the end of
// the buffer and not dereferenceable, returns false. Otherwise, returns true.
func (i *TextIter) ForwardLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardLines moves @count lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_lines(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardSearch searches forward for @str.
//
// Any match is returned by setting @match_start to the first character of the
// match and @match_end to the first character after the match. The search will
// not continue past @limit. Note that a search is a linear or O(n) operation,
// so you may wish to use @limit to avoid locking up your UI on large buffers.
//
// @match_start will never be set to a `GtkTextIter` located before @iter, even
// if there is a possible @match_end after or at @iter.
func (i *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var arg0 *C.GtkTextIter
	var arg1 *C.char
	var arg2 C.GtkTextSearchFlags
	var arg5 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GtkTextSearchFlags)(flags)
	arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

	arg3 := new(C.GtkTextIter)
	var ret3 *TextIter
	arg4 := new(C.GtkTextIter)
	var ret4 *TextIter
	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_search(arg0, arg1, arg2, arg3, arg4, arg5)

	ret3 = WrapTextIter(unsafe.Pointer(arg3))
	ret4 = WrapTextIter(unsafe.Pointer(arg4))
	if cret {
		goret = true
	}

	return ret3, ret4, goret
}

// ForwardSentenceEnd moves forward to the next sentence end.
//
// If @iter is at the end of a sentence, moves to the next end of sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) ForwardSentenceEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_sentence_end(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times.
//
// If @count is negative, moves backward instead of forward.
func (i *TextIter) ForwardSentenceEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_sentence_ends(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardToEnd moves @iter forward to the “end iterator”, which points one past
// the last valid character in the buffer.
//
// gtk_text_iter_get_char() called on the end iterator returns 0, which is
// convenient for writing loops.
func (i *TextIter) ForwardToEnd() {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_forward_to_end(arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters.
//
// The possible characters are either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character.
//
// If the iterator is already at the paragraph delimiter characters, moves to
// the paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
func (i *TextIter) ForwardToLineEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_to_line_end(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the @tag,
// or to the next toggle of any tag if @tag is nil.
//
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles after @iter. Sets @iter to the
// location of the toggle, or to the end of the buffer if no toggle is found.
func (i *TextIter) ForwardToTagToggle(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_to_tag_toggle(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardVisibleCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_cursor_position(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
//
// See [method@Gtk.TextIter.forward_cursor_position] for details.
func (i *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_cursor_positions(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleLine moves @iter to the start of the next visible line.
//
// Returns true if there was a next line to move to, and false if @iter was
// simply moved to the end of the buffer and is now not dereferenceable, or if
// @iter was already at the end of the buffer.
func (i *TextIter) ForwardVisibleLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleLines moves @count visible lines forward, if possible.
//
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
func (i *TextIter) ForwardVisibleLines(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_lines(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleWordEnd moves forward to the next visible word end.
//
// If @iter is currently on a word end, moves forward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (i *TextIter) ForwardVisibleWordEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_word_end(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
func (i *TextIter) ForwardVisibleWordEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_visible_word_ends(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// ForwardWordEnd moves forward to the next word end.
//
// If @iter is currently on a word end, moves forward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) ForwardWordEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_word_end(arg0)

	if cret {
		goret = true
	}

	return goret
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
func (i *TextIter) ForwardWordEnds(count int) bool {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(count)

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_forward_word_ends(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// Free: free an iterator allocated on the heap.
//
// This function is intended for use in language bindings, and is not especially
// useful for applications, because iterators can simply be allocated on the
// stack.
func (i *TextIter) Free() {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	C.gtk_text_iter_free(arg0)
}

// Buffer returns the `GtkTextBuffer` this iterator is associated with.
func (i *TextIter) Buffer() TextBuffer {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret *C.GtkTextBuffer
	var goret TextBuffer

	cret = C.gtk_text_iter_get_buffer(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextBuffer)

	return goret
}

// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) BytesInLine() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_bytes_in_line(arg0)

	goret = int(cret)

	return goret
}

// Char: the Unicode character at this iterator is returned.
//
// Equivalent to operator* on a C++ iterator. If the element at this iterator is
// a non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character.
//
// So you can write a loop which ends when this function returns 0.
func (i *TextIter) Char() uint32 {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gunichar
	var goret uint32

	cret = C.gtk_text_iter_get_char(arg0)

	goret = uint32(cret)

	return goret
}

// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
func (i *TextIter) CharsInLine() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_chars_in_line(arg0)

	goret = int(cret)

	return goret
}

// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned.
//
// Otherwise, nil is returned.
func (i *TextIter) ChildAnchor() TextChildAnchor {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret *C.GtkTextChildAnchor
	var goret TextChildAnchor

	cret = C.gtk_text_iter_get_child_anchor(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TextChildAnchor)

	return goret
}

// Language returns the language in effect at @iter.
//
// If no tags affecting language apply to @iter, the return value is identical
// to that of [func@Gtk.get_default_language].
func (i *TextIter) Language() *pango.Language {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	cret := new(C.PangoLanguage)
	var goret *pango.Language

	cret = C.gtk_text_iter_get_language(arg0)

	goret = pango.WrapLanguage(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *pango.Language) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Line returns the line number containing the iterator.
//
// Lines in a `GtkTextBuffer` are numbered beginning with 0 for the first line
// in the buffer.
func (i *TextIter) Line() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_line(arg0)

	goret = int(cret)

	return goret
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line.
//
// Remember that `GtkTextBuffer` encodes text in UTF-8, and that characters can
// require a variable number of bytes to represent.
func (i *TextIter) LineIndex() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_line_index(arg0)

	goret = int(cret)

	return goret
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line.
//
// The first character on the line has offset 0.
func (i *TextIter) LineOffset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_line_offset(arg0)

	goret = int(cret)

	return goret
}

// Marks returns a list of all `GtkTextMark` at this location.
//
// Because marks are not iterable (they don’t take up any "space" in the buffer,
// they are just marks in between iterable locations), multiple marks can exist
// in the same place.
//
// The returned list is not in any meaningful order.
func (i *TextIter) Marks() *glib.SList {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	cret := new(C.GSList)
	var goret *glib.SList

	cret = C.gtk_text_iter_get_marks(arg0)

	goret = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Offset returns the character offset of an iterator.
//
// Each character in a `GtkTextBuffer` has an offset, starting with 0 for the
// first character in the buffer. Use [method@Gtk,TextBuffer.get_iter_at_offset]
// to convert an offset back into an iterator.
func (i *TextIter) Offset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_offset(arg0)

	goret = int(cret)

	return goret
}

// Paintable: if the element at @iter is a paintable, the paintable is returned.
//
// Otherwise, nil is returned.
func (i *TextIter) Paintable() gdk.Paintable {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret *C.GdkPaintable
	var goret gdk.Paintable

	cret = C.gtk_text_iter_get_paintable(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gdk.Paintable)

	return goret
}

// Slice returns the text in the given range.
//
// A “slice” is an array of characters encoded in UTF-8 format, including the
// Unicode “unknown” character 0xFFFC for iterable non-character elements in the
// buffer, such as images. Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte offsets in
// the text buffer. Note that 0xFFFC can occur in normal text as well, so it is
// not a reliable indicator that a paintable or widget is in the buffer.
func (s *TextIter) Slice(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	cret := new(C.char)
	var goret string

	cret = C.gtk_text_iter_get_slice(arg0, arg1)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Tags returns a list of tags that apply to @iter, in ascending order of
// priority.
//
// The highest-priority tags are last.
//
// The `GtkTextTag`s in the list don’t have a reference added, but you have to
// free the list itself.
func (i *TextIter) Tags() *glib.SList {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	cret := new(C.GSList)
	var goret *glib.SList

	cret = C.gtk_text_iter_get_tags(arg0)

	goret = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Text returns text in the given range.
//
// If the range contains non-text elements such as images, the character and
// byte offsets in the returned string will not correspond to character and byte
// offsets in the buffer. If you want offsets to correspond, see
// [method@Gtk.TextIter.get_slice].
func (s *TextIter) Text(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	cret := new(C.char)
	var goret string

	cret = C.gtk_text_iter_get_text(arg0, arg1)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ToggledTags returns a list of `GtkTextTag` that are toggled on or off at this
// point.
//
// If @toggled_on is true, the list contains tags that are toggled on. If a tag
// is toggled on at @iter, then some non-empty range of characters following
// @iter has that tag applied to it. If a tag is toggled off, then some
// non-empty range following @iter does not have the tag applied to it.
func (i *TextIter) ToggledTags(toggledOn bool) *glib.SList {
	var arg0 *C.GtkTextIter
	var arg1 C.gboolean

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	if toggledOn {
		arg1 = C.gboolean(1)
	}

	cret := new(C.GSList)
	var goret *glib.SList

	cret = C.gtk_text_iter_get_toggled_tags(arg0, arg1)

	goret = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
func (i *TextIter) VisibleLineIndex() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_visible_line_index(arg0)

	goret = int(cret)

	return goret
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
func (i *TextIter) VisibleLineOffset() int {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.gtk_text_iter_get_visible_line_offset(arg0)

	goret = int(cret)

	return goret
}

// VisibleSlice returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_slice], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleSlice(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	cret := new(C.char)
	var goret string

	cret = C.gtk_text_iter_get_visible_slice(arg0, arg1)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// VisibleText returns visible text in the given range.
//
// Like [method@Gtk.TextIter.get_text], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// “invisible” attribute turned on has been applied to it.
func (s *TextIter) VisibleText(end *TextIter) string {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	cret := new(C.char)
	var goret string

	cret = C.gtk_text_iter_get_visible_text(arg0, arg1)

	goret = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag.
//
// See also [method@Gtk.TextIter.starts_tag] and [method@Gtk.TextIter.ends_tag].
func (i *TextIter) HasTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_has_tag(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// InRange checks whether @iter falls in the range [@start, @end).
//
// @start and @end must be in ascending order.
func (i *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter
	var arg2 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
	arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_in_range(arg0, arg1, arg2)

	if cret {
		goret = true
	}

	return goret
}

// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence).
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) InsideSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_inside_sentence(arg0)

	if cret {
		goret = true
	}

	return goret
}

// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace).
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// Note that if [method@Gtk.TextIter.starts_word] returns true, then this
// function returns true too, since @iter points to the first character of the
// word.
func (i *TextIter) InsideWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_inside_word(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsCursorPosition: determine if @iter is at a cursor position.
//
// See [method@Gtk.TextIter.forward_cursor_position] or [struct@Pango.LogAttr]
// or [func@Pango.break] for details on what a cursor position is.
func (i *TextIter) IsCursorPosition() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_is_cursor_position(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsEnd returns true if @iter is the end iterator.
//
// This means it is one past the last dereferenceable iterator in the buffer.
// gtk_text_iter_is_end() is the most efficient way to check whether an iterator
// is the end iterator.
func (i *TextIter) IsEnd() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_is_end(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsStart returns true if @iter is the first iterator in the buffer.
func (i *TextIter) IsStart() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_is_start(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Order swaps the value of @first and @second if @second comes before @first in
// the buffer.
//
// That is, ensures that @first and @second are in sequence. Most text buffer
// functions that take a range call this automatically on your behalf, so
// there’s no real reason to call it yourself in those cases. There are some
// exceptions, such as [method@Gtk.TextIter.in_range], that expect a pre-sorted
// range.
func (f *TextIter) Order(second *TextIter) {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
	arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

	C.gtk_text_iter_order(arg0, arg1)
}

// SetLine moves iterator @iter to the start of the line @line_number.
//
// If @line_number is negative or larger than or equal to the number of lines in
// the buffer, moves @iter to the start of the last line in the buffer.
func (i *TextIter) SetLine(lineNumber int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(lineNumber)

	C.gtk_text_iter_set_line(arg0, arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
func (i *TextIter) SetLineIndex(byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_line_index(arg0, arg1)
}

// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset.
//
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, @iter moves to the start of the next line.
// See [method@Gtk.TextIter.set_line_index] if you have a byte index rather than
// a character offset.
func (i *TextIter) SetLineOffset(charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_line_offset(arg0, arg1)
}

// SetOffset sets @iter to point to @char_offset.
//
// @char_offset counts from the start of the entire text buffer, starting with
// 0.
func (i *TextIter) SetOffset(charOffset int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(charOffset)

	C.gtk_text_iter_set_offset(arg0, arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (i *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(arg0, arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (i *TextIter) SetVisibleLineOffset(charOnLine int) {
	var arg0 *C.GtkTextIter
	var arg1 C.int

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(arg0, arg1)
}

// StartsLine returns true if @iter begins a paragraph.
//
// This is the case if [method@Gtk.TextIter.get_line_offset] would return 0.
// However this function is potentially more efficient than
// [method@Gtk.TextIter.get_line_offset], because it doesn’t have to compute the
// offset, it just has to see whether it’s 0.
func (i *TextIter) StartsLine() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_starts_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// StartsSentence determines whether @iter begins a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (i *TextIter) StartsSentence() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_starts_sentence(arg0)

	if cret {
		goret = true
	}

	return goret
}

// StartsTag returns true if @tag is toggled on at exactly this point.
//
// If @tag is nil, returns true if any tag is toggled on at this point.
//
// Note that if this function returns true, it means that @iter is at the
// beginning of the tagged range, and that the character at @iter is inside the
// tagged range. In other words, unlike [method@Gtk.TextIter.ends_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag will also return true for
// the same parameters.
func (i *TextIter) StartsTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_starts_tag(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}

// StartsWord determines whether @iter begins a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (i *TextIter) StartsWord() bool {
	var arg0 *C.GtkTextIter

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_starts_word(arg0)

	if cret {
		goret = true
	}

	return goret
}

// TogglesTag gets whether a range with @tag applied to it begins or ends at
// @iter.
//
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag())
func (i *TextIter) TogglesTag(tag TextTag) bool {
	var arg0 *C.GtkTextIter
	var arg1 *C.GtkTextTag

	arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.gtk_text_iter_toggles_tag(arg0, arg1)

	if cret {
		goret = true
	}

	return goret
}
