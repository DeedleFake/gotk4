// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
		{T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
		{T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
	})
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a `GtkScrolledWindow.`
//
// This is effectively the opposite of where the scroll bars are placed.
type CornerType int

const (
	// TopLeft: place the scrollbars on the right and bottom of the widget
	// (default behaviour).
	CornerTypeTopLeft CornerType = 0
	// BottomLeft: place the scrollbars on the top and right of the widget.
	CornerTypeBottomLeft CornerType = 1
	// TopRight: place the scrollbars on the left and bottom of the widget.
	CornerTypeTopRight CornerType = 2
	// BottomRight: place the scrollbars on the top and left of the widget.
	CornerTypeBottomRight CornerType = 3
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType int

const (
	// always: the scrollbar is always visible. The view size is independent of
	// the content.
	PolicyTypeAlways PolicyType = 0
	// automatic: the scrollbar will appear and disappear as necessary. For
	// example, when all of a `GtkTreeView` can not be seen.
	PolicyTypeAutomatic PolicyType = 1
	// never: the scrollbar should never appear. In this mode the content
	// determines the size.
	PolicyTypeNever PolicyType = 2
	// external: don't show a scrollbar, but don't force the size to follow the
	// content. This can be used e.g. to make multiple scrolled windows share a
	// scrollbar.
	PolicyTypeExternal PolicyType = 3
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrolledWindow: `GtkScrolledWindow` is a container that makes its child
// scrollable.
//
// It does so using either internally added scrollbars or externally associated
// adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// [iface@Gtk.Scrollable] interface, are added directly. For other types of
// widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
// scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
// intelligently accounts for whether or not the added child is a
// `GtkScrollable`. If it isn’t, then it wraps the child in a `GtkViewport`.
// Therefore, you can just add any child widget and not worry about the details.
//
// If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
// you can remove both your added child widget from the `GtkViewport`, and the
// `GtkViewport` from the `GtkScrolledWindow`, like this:
//
// “`c GtkWidget *scrolled_window = gtk_scrolled_window_new (); GtkWidget
// *child_widget = gtk_button_new ();
//
// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
// // add a GtkViewport. gtk_box_append (GTK_BOX (scrolled_window),
// // child_widget);
//
// // Either of these will result in child_widget being unparented:
// // gtk_box_remove (GTK_BOX (scrolled_window), child_widget); // or
// // gtk_box_remove (GTK_BOX (scrolled_window), gtk_bin_get_child (GTK_BIN
// // (scrolled_window))); “`
//
// Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
// [property@Gtk.ScrolledWindow:vscrollbar-policy] are GTK_POLICY_NEVER or
// GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
// around its child. The scroll position of the child, and if applicable the
// scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
// and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
// `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
// but note that the “step_increment” and “page_increment” fields are only
// effective if the policy causes scrollbars to be present.
//
// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with `GtkScrollbar` and for example a `GtkGrid`.
//
//
// Touch support
//
// `GtkScrolledWindow` has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will expose
// 'kinetic' behavior. This can be turned off with the
// [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.
//
// `GtkScrolledWindow` also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// [signal@Gtk.ScrolledWindow::edge-overshot] signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the [property@Gtk.ScrolledWindow:overlay-scrolling] property.
//
//
// CSS nodes
//
// `GtkScrolledWindow` has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when [property@Gtk.ScrolledWindow:has-frame] is
// true.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
//
// Accessibility
//
// `GtkScrolledWindow` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow interface {
	Widget

	Child() Widget

	HAdjustment() Adjustment

	HasFrame() bool

	HScrollbar() Widget

	KineticScrolling() bool

	MaxContentHeight() int

	MaxContentWidth() int

	MinContentHeight() int

	MinContentWidth() int

	OverlayScrolling() bool

	Placement() CornerType

	Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)

	PropagateNaturalHeight() bool

	PropagateNaturalWidth() bool

	VAdjustment() Adjustment

	VScrollbar() Widget

	SetChildScrolledWindow(child Widget)

	SetHAdjustmentScrolledWindow(hadjustment Adjustment)

	SetHasFrameScrolledWindow(hasFrame bool)

	SetKineticScrollingScrolledWindow(kineticScrolling bool)

	SetMaxContentHeightScrolledWindow(height int)

	SetMaxContentWidthScrolledWindow(width int)

	SetMinContentHeightScrolledWindow(height int)

	SetMinContentWidthScrolledWindow(width int)

	SetOverlayScrollingScrolledWindow(overlayScrolling bool)

	SetPlacementScrolledWindow(windowPlacement CornerType)

	SetPolicyScrolledWindow(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)

	SetPropagateNaturalHeightScrolledWindow(propagate bool)

	SetPropagateNaturalWidthScrolledWindow(propagate bool)

	SetVAdjustmentScrolledWindow(vadjustment Adjustment)

	UnsetPlacementScrolledWindow()
}

// scrolledWindow implements the ScrolledWindow class.
type scrolledWindow struct {
	Widget
}

// WrapScrolledWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrolledWindow(obj *externglib.Object) ScrolledWindow {
	return scrolledWindow{
		Widget: WrapWidget(obj),
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrolledWindow(obj), nil
}

func NewScrolledWindow() ScrolledWindow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_scrolled_window_new()

	var _scrolledWindow ScrolledWindow // out

	_scrolledWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ScrolledWindow)

	return _scrolledWindow
}

func (s scrolledWindow) Child() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_child(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) HAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrolledWindow) HasFrame() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_has_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) HScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) KineticScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) MaxContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s scrolledWindow) MaxContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s scrolledWindow) MinContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s scrolledWindow) MinContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s scrolledWindow) OverlayScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) Placement() CornerType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkCornerType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_placement(_arg0)

	var _cornerType CornerType // out

	_cornerType = CornerType(_cret)

	return _cornerType
}

func (s scrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // in
	var _arg2 C.GtkPolicyType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)

	var _hscrollbarPolicy PolicyType // out
	var _vscrollbarPolicy PolicyType // out

	_hscrollbarPolicy = PolicyType(_arg1)
	_vscrollbarPolicy = PolicyType(_arg2)

	return _hscrollbarPolicy, _vscrollbarPolicy
}

func (s scrolledWindow) PropagateNaturalHeight() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) PropagateNaturalWidth() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s scrolledWindow) VAdjustment() Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)

	var _adjustment Adjustment // out

	_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

	return _adjustment
}

func (s scrolledWindow) VScrollbar() Widget {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)

	var _widget Widget // out

	_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

	return _widget
}

func (s scrolledWindow) SetChildScrolledWindow(child Widget) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_scrolled_window_set_child(_arg0, _arg1)
}

func (s scrolledWindow) SetHAdjustmentScrolledWindow(hadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}

func (s scrolledWindow) SetHasFrameScrolledWindow(hasFrame bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_has_frame(_arg0, _arg1)
}

func (s scrolledWindow) SetKineticScrollingScrolledWindow(kineticScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if kineticScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}

func (s scrolledWindow) SetMaxContentHeightScrolledWindow(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}

func (s scrolledWindow) SetMaxContentWidthScrolledWindow(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}

func (s scrolledWindow) SetMinContentHeightScrolledWindow(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}

func (s scrolledWindow) SetMinContentWidthScrolledWindow(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}

func (s scrolledWindow) SetOverlayScrollingScrolledWindow(overlayScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if overlayScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}

func (s scrolledWindow) SetPlacementScrolledWindow(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkCornerType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkCornerType(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}

func (s scrolledWindow) SetPolicyScrolledWindow(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // out
	var _arg2 C.GtkPolicyType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = C.GtkPolicyType(hscrollbarPolicy)
	_arg2 = C.GtkPolicyType(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}

func (s scrolledWindow) SetPropagateNaturalHeightScrolledWindow(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}

func (s scrolledWindow) SetPropagateNaturalWidthScrolledWindow(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}

func (s scrolledWindow) SetVAdjustmentScrolledWindow(vadjustment Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}

func (s scrolledWindow) UnsetPlacementScrolledWindow() {
	var _arg0 *C.GtkScrolledWindow // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

	C.gtk_scrolled_window_unset_placement(_arg0)
}

func (s scrolledWindow) AccessibleRole() AccessibleRole {
	return WrapAccessible(gextras.InternObject(s)).AccessibleRole()
}

func (s scrolledWindow) ResetProperty(property AccessibleProperty) {
	WrapAccessible(gextras.InternObject(s)).ResetProperty(property)
}

func (s scrolledWindow) ResetRelation(relation AccessibleRelation) {
	WrapAccessible(gextras.InternObject(s)).ResetRelation(relation)
}

func (s scrolledWindow) ResetState(state AccessibleState) {
	WrapAccessible(gextras.InternObject(s)).ResetState(state)
}

func (s scrolledWindow) UpdatePropertyValue(properties []AccessibleProperty, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdatePropertyValue(properties, values)
}

func (s scrolledWindow) UpdateRelationValue(relations []AccessibleRelation, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateRelationValue(relations, values)
}

func (s scrolledWindow) UpdateStateValue(states []AccessibleState, values []externglib.Value) {
	WrapAccessible(gextras.InternObject(s)).UpdateStateValue(states, values)
}

func (b scrolledWindow) BuildableID() string {
	return WrapBuildable(gextras.InternObject(b)).BuildableID()
}
