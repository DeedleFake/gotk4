// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_list_item_get_type()), F: marshalListItem},
	})
}

// ListItem is the object that list-handling containers such as ListView use to
// represent items in a Model. They are managed by the container and cannot be
// created by application code.
//
// ListItems need to be populated by application code. This is done by calling
// gtk_list_item_set_child().
//
// ListItems exist in 2 stages:
//
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the ListItem:item property is set to nil.
//
// 2. The bound stage where the listitem references an item from the list. The
// ListItem:item property is not nil.
type ListItem interface {
	gextras.Objector

	// Activatable checks if a list item has been set to be activatable via
	// gtk_list_item_set_activatable().
	Activatable() bool
	// Child gets the child previously set via gtk_list_item_set_child() or nil
	// if none was set.
	Child() Widget
	// Item gets the item that is currently displayed in model that @self is
	// currently bound to or nil if @self is unbound.
	Item() gextras.Objector
	// Position gets the position in the model that @self currently displays. If
	// @self is unbound, GTK_INVALID_LIST_POSITION is returned.
	Position() uint
	// Selectable checks if a list item has been set to be selectable via
	// gtk_list_item_set_selectable().
	//
	// Do not confuse this function with gtk_list_item_get_selected().
	Selectable() bool
	// Selected checks if the item is displayed as selected. The selected state
	// is maintained by the container and its list model and cannot be set
	// otherwise.
	Selected() bool
	// SetActivatable sets @self to be activatable.
	//
	// If an item is activatable, double-clicking on the item, using the Return
	// key or calling gtk_widget_activate() will activate the item. Activating
	// instructs the containing view to handle activation. ListView for example
	// will be emitting the ListView::activate signal.
	//
	// By default, list items are activatable
	SetActivatable(activatable bool)
	// SetChild sets the child to be used for this listitem.
	//
	// This function is typically called by applications when setting up a
	// listitem so that the widget can be reused when binding it multiple times.
	SetChild(child Widget)
	// SetSelectable sets @self to be selectable. If an item is selectable,
	// clicking on the item or using the keyboard will try to select or unselect
	// the item. If this succeeds is up to the model to determine, as it is
	// managing the selected state.
	//
	// Note that this means that making an item non-selectable has no influence
	// on the selected state at all. A non-selectable item may still be
	// selected.
	//
	// By default, list items are selectable. When rebinding them to a new item,
	// they will also be reset to be selectable by GTK.
	SetSelectable(selectable bool)
}

// listItem implements the ListItem interface.
type listItem struct {
	gextras.Objector
}

var _ ListItem = (*listItem)(nil)

// WrapListItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapListItem(obj *externglib.Object) ListItem {
	return ListItem{
		Objector: obj,
	}
}

func marshalListItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListItem(obj), nil
}

// Activatable checks if a list item has been set to be activatable via
// gtk_list_item_set_activatable().
func (s listItem) Activatable() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_list_item_get_activatable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Child gets the child previously set via gtk_list_item_set_child() or nil
// if none was set.
func (s listItem) Child() Widget {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret *C.GtkWidget
	var ret1 Widget

	cret = C.gtk_list_item_get_child(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Widget)

	return ret1
}

// Item gets the item that is currently displayed in model that @self is
// currently bound to or nil if @self is unbound.
func (s listItem) Item() gextras.Objector {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret C.gpointer
	var ret1 gextras.Objector

	cret = C.gtk_list_item_get_item(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(gextras.Objector)

	return ret1
}

// Position gets the position in the model that @self currently displays. If
// @self is unbound, GTK_INVALID_LIST_POSITION is returned.
func (s listItem) Position() uint {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret C.guint
	var ret1 uint

	cret = C.gtk_list_item_get_position(arg0)

	ret1 = C.guint(cret)

	return ret1
}

// Selectable checks if a list item has been set to be selectable via
// gtk_list_item_set_selectable().
//
// Do not confuse this function with gtk_list_item_get_selected().
func (s listItem) Selectable() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_list_item_get_selectable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Selected checks if the item is displayed as selected. The selected state
// is maintained by the container and its list model and cannot be set
// otherwise.
func (s listItem) Selected() bool {
	var arg0 *C.GtkListItem

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gtk_list_item_get_selected(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SetActivatable sets @self to be activatable.
//
// If an item is activatable, double-clicking on the item, using the Return
// key or calling gtk_widget_activate() will activate the item. Activating
// instructs the containing view to handle activation. ListView for example
// will be emitting the ListView::activate signal.
//
// By default, list items are activatable
func (s listItem) SetActivatable(activatable bool) {
	var arg0 *C.GtkListItem
	var arg1 C.gboolean

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	if activatable {
		arg1 = C.gboolean(1)
	}

	C.gtk_list_item_set_activatable(arg0, activatable)
}

// SetChild sets the child to be used for this listitem.
//
// This function is typically called by applications when setting up a
// listitem so that the widget can be reused when binding it multiple times.
func (s listItem) SetChild(child Widget) {
	var arg0 *C.GtkListItem
	var arg1 *C.GtkWidget

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_list_item_set_child(arg0, child)
}

// SetSelectable sets @self to be selectable. If an item is selectable,
// clicking on the item or using the keyboard will try to select or unselect
// the item. If this succeeds is up to the model to determine, as it is
// managing the selected state.
//
// Note that this means that making an item non-selectable has no influence
// on the selected state at all. A non-selectable item may still be
// selected.
//
// By default, list items are selectable. When rebinding them to a new item,
// they will also be reset to be selectable by GTK.
func (s listItem) SetSelectable(selectable bool) {
	var arg0 *C.GtkListItem
	var arg1 C.gboolean

	arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
	if selectable {
		arg1 = C.gboolean(1)
	}

	C.gtk_list_item_set_selectable(arg0, selectable)
}
