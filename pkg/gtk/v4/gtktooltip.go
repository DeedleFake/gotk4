// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
	})
}

// Tooltip: `GtkTooltip` is an object representing a widget tooltip.
//
// Basic tooltips can be realized simply by using
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup] without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per `GtkTreeView`
// row or cell, you will have to do a little more work:
//
// - Set the [property@Gtk.Widget:has-tooltip] property to true. This will make
// GTK monitor the widget for motion and related events which are needed to
// determine when and where to show a tooltip.
//
// - Connect to the [signal@Gtk.Widget::query-tooltip] signal. This signal will
// be emitted when a tooltip is supposed to be shown. One of the arguments
// passed to the signal handler is a `GtkTooltip` object. This is the object
// that we are about to display as a tooltip, and can be manipulated in your
// callback using functions like [method@Gtk.Tooltip.set_icon]. There are
// functions for setting the tooltipâ€™s markup, setting an image from a named
// icon, or even putting in a custom widget.
//
// - Return true from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return false, it will not be shown.
type Tooltip interface {
	gextras.Objector

	// SetCustomTooltip replaces the widget packed into the tooltip with
	// @custom_widget. @custom_widget does not get destroyed when the tooltip
	// goes away. By default a box with a Image and Label is embedded in the
	// tooltip, which can be configured using gtk_tooltip_set_markup() and
	// gtk_tooltip_set_icon().
	SetCustomTooltip(customWidget Widget)
	// SetIconFromIconNameTooltip sets the icon of the tooltip (which is in
	// front of the text) to be the icon indicated by @icon_name with the size
	// indicated by @size. If @icon_name is nil, the image will be hidden.
	SetIconFromIconNameTooltip(iconName string)
	// SetMarkupTooltip sets the text of the tooltip to be @markup.
	//
	// The string must be marked up with Pango markup. If @markup is nil, the
	// label will be hidden.
	SetMarkupTooltip(markup string)
	// SetTextTooltip sets the text of the tooltip to be @text.
	//
	// If @text is nil, the label will be hidden. See also
	// [method@Gtk.Tooltip.set_markup].
	SetTextTooltip(text string)
	// SetTipAreaTooltip sets the area of the widget, where the contents of this
	// tooltip apply, to be @rect (in widget coordinates). This is especially
	// useful for properly setting tooltips on TreeView rows and cells,
	// IconViews, etc.
	//
	// For setting tooltips on TreeView, please refer to the convenience
	// functions for this: gtk_tree_view_set_tooltip_row() and
	// gtk_tree_view_set_tooltip_cell().
	SetTipAreaTooltip(rect gdk.Rectangle)
}

// tooltip implements the Tooltip class.
type tooltip struct {
	gextras.Objector
}

// WrapTooltip wraps a GObject to the right type. It is
// primarily used internally.
func WrapTooltip(obj *externglib.Object) Tooltip {
	return tooltip{
		Objector: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTooltip(obj), nil
}

func (t tooltip) SetCustomTooltip(customWidget Widget) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

	C.gtk_tooltip_set_custom(_arg0, _arg1)
}

func (t tooltip) SetIconFromIconNameTooltip(iconName string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1)
}

func (t tooltip) SetMarkupTooltip(markup string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_markup(_arg0, _arg1)
}

func (t tooltip) SetTextTooltip(text string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tooltip_set_text(_arg0, _arg1)
}

func (t tooltip) SetTipAreaTooltip(rect gdk.Rectangle) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect))

	C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}
