// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNode},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNode},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNode},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNode},
		{T: externglib.Type(C.gsk_cairo_renderer_get_type()), F: marshalCairoRenderer},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNode},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNode},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNode},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNode},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNode},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNode},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNode},
		{T: externglib.Type(C.gsk_gl_renderer_get_type()), F: marshalGLRenderer},
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNode},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNode},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNode},
		{T: externglib.Type(C.gsk_ngl_renderer_get_type()), F: marshalNglRenderer},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNode},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNode},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNode},
		{T: externglib.Type(C.gsk_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNode},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNode},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNode},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNode},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNode},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNode},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNode},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNode},
		{T: externglib.Type(C.gsk_vulkan_renderer_get_type()), F: marshalVulkanRenderer},
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// BlendModeDefault: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// BlendModeMultiply: the source color is multiplied by the destination and
	// replaces the destination
	BlendModeMultiply BlendMode = 1
	// BlendModeScreen multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen BlendMode = 2
	// BlendModeOverlay multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// BlendModeDarken selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// BlendModeLighten selects the lighter of the destination and source colors
	BlendModeLighten BlendMode = 5
	// BlendModeColorDodge brightens the destination color to reflect the source
	// color
	BlendModeColorDodge BlendMode = 6
	// BlendModeColorBurn darkens the destination color to reflect the source
	// color
	BlendModeColorBurn BlendMode = 7
	// BlendModeHardLight multiplies or screens the colors, depending on the
	// source color value
	BlendModeHardLight BlendMode = 8
	// BlendModeSoftLight darkens or lightens the colors, depending on the
	// source color value
	BlendModeSoftLight BlendMode = 9
	// BlendModeDifference subtracts the darker of the two constituent colors
	// from the lighter color
	BlendModeDifference BlendMode = 10
	// BlendModeExclusion produces an effect similar to that of the difference
	// mode but lower in contrast
	BlendModeExclusion BlendMode = 11
	// BlendModeColor creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// BlendModeHue creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// BlendModeSaturation creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// BlendModeLuminosity creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// CornerTopLeft: the top left corner
	CornerTopLeft Corner = 0
	// CornerTopRight: the top right corner
	CornerTopRight Corner = 1
	// CornerBottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// CornerBottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that `GskGLShaders`
// declare.
//
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// GLUniformTypeFloat: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// GLUniformTypeInt: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// GLUniformTypeUint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// GLUniformTypeBool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// GLUniformTypeVec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// GLUniformTypeVec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// GLUniformTypeVec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// RenderNodeTypeNotARenderNode: error type. No node will ever have this
	// type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// RenderNodeTypeContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// RenderNodeTypeCairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// RenderNodeTypeColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// RenderNodeTypeLinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RenderNodeTypeRepeatingLinearGradientNode: a node drawing a repeating
	// linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RenderNodeTypeRadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RenderNodeTypeRepeatingRadialGradientNode: a node drawing a repeating
	// radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// RenderNodeTypeConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// RenderNodeTypeBorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// RenderNodeTypeTextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// RenderNodeTypeInsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// RenderNodeTypeOutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// RenderNodeTypeTransformNode: a node that renders its child after applying
	// a matrix transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// RenderNodeTypeOpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// RenderNodeTypeColorMatrixNode: a node that applies a color matrix to
	// every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RenderNodeTypeRepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// RenderNodeTypeClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RenderNodeTypeRoundedClipNode: a node that clips its child to a rounded
	// rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// RenderNodeTypeShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// RenderNodeTypeBlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// RenderNodeTypeCrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// RenderNodeTypeTextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// RenderNodeTypeBlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// RenderNodeTypeDebugNode: debug information that does not affect the
	// rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// RenderNodeTypeGLShaderNode: a node that uses OpenGL fragment shaders to
	// render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// ScalingFilterLinear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// ScalingFilterNearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// SerializationErrorUnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// SerializationErrorUnsupportedVersion: the version of the data is not
	// understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// SerializationErrorInvalidData: the given data may not exist in a proper
	// serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories. So if you
// want to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via multiplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// TransformCategoryUnknown: the category of the matrix has not been
	// determined.
	TransformCategoryUnknown TransformCategory = 0
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny TransformCategory = 1
	// TransformCategory3D: the matrix is a 3D matrix. This means that the w
	// column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// TransformCategory2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// TransformCategory2DAffine: the matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// TransformCategory2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// TransformCategoryIdentity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BlendNode: a render node applying a blending function between its two child
// nodes.
type BlendNode interface {

	// BlendMode retrieves the blend mode used by @node.
	BlendMode() BlendMode
	// BottomChild retrieves the bottom `GskRenderNode` child of the @node.
	BottomChild() RenderNode
	// TopChild retrieves the top `GskRenderNode` child of the @node.
	TopChild() RenderNode
}

// blendNode implements the BlendNode class.
type blendNode struct {
	RenderNode
}

// WrapBlendNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlendNode(obj *externglib.Object) BlendNode {
	return blendNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlendNode(obj), nil
}

// NewBlendNode creates a `GskRenderNode` that will use @blend_mode to blend the
// @top node onto the @bottom node.
func NewBlendNode(bottom RenderNode, top RenderNode, blendMode BlendMode) BlendNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.GskBlendMode   // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(bottom.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(top.Native()))
	_arg3 = (C.GskBlendMode)(blendMode)

	_cret = C.gsk_blend_node_new(_arg1, _arg2, _arg3)

	var _blendNode BlendNode // out

	_blendNode = WrapBlendNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blendNode
}

func (n blendNode) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)

	var _blendMode BlendMode // out

	_blendMode = BlendMode(_cret)

	return _blendMode
}

func (n blendNode) BottomChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n blendNode) TopChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

// BlurNode: a render node applying a blur effect to its single child.
type BlurNode interface {

	// Child retrieves the child `GskRenderNode` of the blur @node.
	Child() RenderNode
	// Radius retrieves the blur radius of the @node.
	Radius() float32
}

// blurNode implements the BlurNode class.
type blurNode struct {
	RenderNode
}

// WrapBlurNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlurNode(obj *externglib.Object) BlurNode {
	return blurNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlurNode(obj), nil
}

// NewBlurNode creates a render node that blurs the child.
func NewBlurNode(child RenderNode, radius float32) BlurNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (C.float)(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)

	var _blurNode BlurNode // out

	_blurNode = WrapBlurNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

func (n blurNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n blurNode) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// BorderNode: a render node for a border.
type BorderNode interface {

	// Colors retrieves the colors of the border.
	Colors() *gdk.RGBA
	// Outline retrieves the outline of the border.
	Outline() *RoundedRect
	// Widths retrieves the stroke widths of the border.
	Widths() [4]float32
}

// borderNode implements the BorderNode class.
type borderNode struct {
	RenderNode
}

// WrapBorderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBorderNode(obj *externglib.Object) BorderNode {
	return borderNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBorderNode(obj), nil
}

// NewBorderNode creates a `GskRenderNode` that will stroke a border rectangle
// inside the given @outline.
//
// The 4 sides of the border can have different widths and colors.
func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) BorderNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float
	var _arg3 *C.GdkRGBA
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)

	var _borderNode BorderNode // out

	_borderNode = WrapBorderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _borderNode
}

func (n borderNode) Colors() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = gdk.WrapRGBA(unsafe.Pointer(_cret))

	return _rgbA
}

func (n borderNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n borderNode) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)

	var _gfloats [4]float32

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// CairoNode: a render node for a Cairo surface.
type CairoNode interface {

	// DrawContext creates a Cairo context for drawing using the surface
	// associated to the render node.
	//
	// If no surface exists yet, a surface will be created optimized for
	// rendering to @renderer.
	DrawContext() *cairo.Context
	// Surface retrieves the Cairo surface used by the render node.
	Surface() *cairo.Surface
}

// cairoNode implements the CairoNode class.
type cairoNode struct {
	RenderNode
}

// WrapCairoNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoNode(obj *externglib.Object) CairoNode {
	return cairoNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoNode(obj), nil
}

// NewCairoNode creates a `GskRenderNode` that will render a cairo surface into
// the area given by @bounds.
//
// You can draw to the cairo surface using
// [method@Gsk.CairoNode.get_draw_context].
func NewCairoNode(bounds *graphene.Rect) CairoNode {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.gsk_cairo_node_new(_arg1)

	var _cairoNode CairoNode // out

	_cairoNode = WrapCairoNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

func (n cairoNode) DrawContext() *cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _context
}

func (n cairoNode) Surface() *cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(unsafe.Pointer(_cret))

	return _surface
}

// CairoRenderer: a GSK renderer that is using cairo.
//
// Since it is using cairo, this renderer cannot support 3D transformations.
type CairoRenderer interface {
}

// cairoRenderer implements the CairoRenderer class.
type cairoRenderer struct {
	Renderer
}

// WrapCairoRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoRenderer(obj *externglib.Object) CairoRenderer {
	return cairoRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoRenderer(obj), nil
}

// NewCairoRenderer creates a new Cairo renderer.
//
// The Cairo renderer is the fallback renderer drawing in ways similar to how
// GTK 3 drew its content. Its primary use is as comparison tool.
//
// The Cairo renderer is incomplete. It cannot render 3D transformed content and
// will instead render an error marker. Its usage should be avoided.
func NewCairoRenderer() CairoRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_cairo_renderer_new()

	var _cairoRenderer CairoRenderer // out

	_cairoRenderer = WrapCairoRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoRenderer
}

// ClipNode: a render node applying a rectangular clip to its single child node.
type ClipNode interface {

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrieves the clip rectangle for @node.
	Clip() *graphene.Rect
}

// clipNode implements the ClipNode class.
type clipNode struct {
	RenderNode
}

// WrapClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipNode(obj *externglib.Object) ClipNode {
	return clipNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipNode(obj), nil
}

// NewClipNode creates a `GskRenderNode` that will clip the @child to the area
// given by @clip.
func NewClipNode(child RenderNode, clip *graphene.Rect) ClipNode {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(clip.Native()))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)

	var _clipNode ClipNode // out

	_clipNode = WrapClipNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

func (n clipNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n clipNode) Clip() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)

	var _rect *graphene.Rect // out

	_rect = graphene.WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// ColorMatrixNode: a render node controlling the color matrix of its single
// child node.
type ColorMatrixNode interface {

	// Child gets the child node that is getting its colors modified by the
	// given @node.
	Child() RenderNode
	// ColorMatrix retrieves the color matrix used by the @node.
	ColorMatrix() *graphene.Matrix
	// ColorOffset retrieves the color offset used by the @node.
	ColorOffset() *graphene.Vec4
}

// colorMatrixNode implements the ColorMatrixNode class.
type colorMatrixNode struct {
	RenderNode
}

// WrapColorMatrixNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorMatrixNode(obj *externglib.Object) ColorMatrixNode {
	return colorMatrixNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorMatrixNode(obj), nil
}

// NewColorMatrixNode creates a `GskRenderNode` that will drawn the @child with
// @color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
func NewColorMatrixNode(child RenderNode, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) ColorMatrixNode {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix.Native()))
	_arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset.Native()))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)

	var _colorMatrixNode ColorMatrixNode // out

	_colorMatrixNode = WrapColorMatrixNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

func (n colorMatrixNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n colorMatrixNode) ColorMatrix() *graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)

	var _matrix *graphene.Matrix // out

	_matrix = graphene.WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

func (n colorMatrixNode) ColorOffset() *graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)

	var _vec4 *graphene.Vec4 // out

	_vec4 = graphene.WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// ColorNode: a render node for a solid color.
type ColorNode interface {

	// Color retrieves the color of the given @node.
	Color() *gdk.RGBA
}

// colorNode implements the ColorNode class.
type colorNode struct {
	RenderNode
}

// WrapColorNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorNode(obj *externglib.Object) ColorNode {
	return colorNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorNode(obj), nil
}

// NewColorNode creates a `GskRenderNode` that will render the color specified
// by @rgba into the area given by @bounds.
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) ColorNode {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.gsk_color_node_new(_arg1, _arg2)

	var _colorNode ColorNode // out

	_colorNode = WrapColorNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

func (n colorNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = gdk.WrapRGBA(unsafe.Pointer(_cret))

	return _rgbA
}

// ConicGradientNode: a render node for a conic gradient.
type ConicGradientNode interface {

	// Angle retrieves the angle for the gradient in radians, normalized in [0,
	// 2 * PI].
	//
	// The angle is starting at the top and going clockwise, as expressed in the
	// css specification:
	//
	//    angle = 90 - gsk_conic_gradient_node_get_rotation()
	Angle() float32
	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Rotation retrieves the rotation for the gradient in degrees.
	Rotation() float32
}

// conicGradientNode implements the ConicGradientNode class.
type conicGradientNode struct {
	RenderNode
}

// WrapConicGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapConicGradientNode(obj *externglib.Object) ConicGradientNode {
	return conicGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConicGradientNode(obj), nil
}

// NewConicGradientNode creates a `GskRenderNode` that draws a conic gradient.
//
// The conic gradient starts around @center in the direction of @rotation. A
// rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) ConicGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(rotation)
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _conicGradientNode ConicGradientNode // out

	_conicGradientNode = WrapConicGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _conicGradientNode
}

func (n conicGradientNode) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n conicGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)

	var _point *graphene.Point // out

	_point = graphene.WrapPoint(unsafe.Pointer(_cret))

	return _point
}

func (n conicGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (n conicGradientNode) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// ContainerNode: a render node that can contain other render nodes.
type ContainerNode interface {

	// Child gets one of the children of @container.
	Child(idx uint) RenderNode
	// NChildren retrieves the number of direct children of @node.
	NChildren() uint
}

// containerNode implements the ContainerNode class.
type containerNode struct {
	RenderNode
}

// WrapContainerNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainerNode(obj *externglib.Object) ContainerNode {
	return containerNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainerNode(obj), nil
}

// NewContainerNode creates a new `GskRenderNode` instance for holding the given
// @children.
//
// The new node will acquire a reference to each of the children.
func NewContainerNode(children []RenderNode) ContainerNode {
	var _arg1 **C.GskRenderNode
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = C.guint(len(children))
	_arg1 = (**C.GskRenderNode)(C.malloc(C.ulong(len(children)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)

	var _containerNode ContainerNode // out

	_containerNode = WrapContainerNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

func (n containerNode) Child(idx uint) RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = (C.guint)(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n containerNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// CrossFadeNode: a render node cross fading between two child nodes.
type CrossFadeNode interface {

	// EndChild retrieves the child `GskRenderNode` at the end of the
	// cross-fade.
	EndChild() RenderNode
	// Progress retrieves the progress value of the cross fade.
	Progress() float32
	// StartChild retrieves the child `GskRenderNode` at the beginning of the
	// cross-fade.
	StartChild() RenderNode
}

// crossFadeNode implements the CrossFadeNode class.
type crossFadeNode struct {
	RenderNode
}

// WrapCrossFadeNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCrossFadeNode(obj *externglib.Object) CrossFadeNode {
	return crossFadeNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCrossFadeNode(obj), nil
}

// NewCrossFadeNode creates a `GskRenderNode` that will do a cross-fade between
// @start and @end.
func NewCrossFadeNode(start RenderNode, end RenderNode, progress float32) CrossFadeNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(end.Native()))
	_arg3 = (C.float)(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)

	var _crossFadeNode CrossFadeNode // out

	_crossFadeNode = WrapCrossFadeNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

func (n crossFadeNode) EndChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n crossFadeNode) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n crossFadeNode) StartChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

// DebugNode: a render node that emits a debugging message when drawing its
// child node.
type DebugNode interface {

	// Child gets the child node that is getting drawn by the given @node.
	Child() RenderNode
	// Message gets the debug message that was set on this node
	Message() string
}

// debugNode implements the DebugNode class.
type debugNode struct {
	RenderNode
}

// WrapDebugNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapDebugNode(obj *externglib.Object) DebugNode {
	return debugNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDebugNode(obj), nil
}

// NewDebugNode creates a `GskRenderNode` that will add debug information about
// the given @child.
//
// Adding this node has no visual effect.
func NewDebugNode(child RenderNode, message string) DebugNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(message))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)

	var _debugNode DebugNode // out

	_debugNode = WrapDebugNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

func (n debugNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n debugNode) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GLRenderer: a GSK renderer that is using OpenGL.
type GLRenderer interface {
}

// glRenderer implements the GLRenderer class.
type glRenderer struct {
	Renderer
}

// WrapGLRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLRenderer(obj *externglib.Object) GLRenderer {
	return glRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalGLRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLRenderer(obj), nil
}

// NewGLRenderer creates a new Renderer using OpenGL. This is the default
// renderer used by GTK.
func NewGLRenderer() GLRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_gl_renderer_new()

	var _glRenderer GLRenderer // out

	_glRenderer = WrapGLRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glRenderer
}

// GLShader: a `GskGLShader` is a snippet of GLSL that is meant to run in the
// fragment shader of the rendering pipeline.
//
// A fragment shader gets the coordinates being rendered as input and produces
// the pixel values for that particular pixel. Additionally, the shader can
// declare a set of other input arguments, called uniforms (as they are uniform
// over all the calls to your shader in each instance of use). A shader can also
// receive up to 4 textures that it can use as input when producing the pixel
// data.
//
// `GskGLShader` is usually used with gtk_snapshot_push_gl_shader() to produce a
// [class@Gsk.GLShaderNode] in the rendering hierarchy, and then its input
// textures are constructed by rendering the child nodes to textures before
// rendering the shader node itself. (You can pass texture nodes as children if
// you want to directly use a texture as input).
//
// The actual shader code is GLSL code that gets combined with some other code
// into the fragment shader. Since the exact capabilities of the GPU driver
// differs between different OpenGL drivers and hardware, GTK adds some defines
// that you can use to ensure your GLSL code runs on as many drivers as it can.
//
// If the OpenGL driver is GLES, then the shader language version is set to 100,
// and GSK_GLES will be defined in the shader.
//
// Otherwise, if the OpenGL driver does not support the 3.2 core profile, then
// the shader will run with language version 110 for GL2 and 130 for GL3, and
// GSK_LEGACY will be defined in the shader.
//
// If the OpenGL driver supports the 3.2 code profile, it will be used, the
// shader language version is set to 150, and GSK_GL3 will be defined in the
// shader.
//
// The main function the shader must implement is:
//
// “`glsl void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2
// resolution, in vec2 uv) “`
//
// Where the input @fragCoord is the coordinate of the pixel we're currently
// rendering, relative to the boundary rectangle that was specified in the
// `GskGLShaderNode`, and @resolution is the width and height of that rectangle.
// This is in the typical GTK coordinate system with the origin in the top left.
// @uv contains the u and v coordinates that can be used to index a texture at
// the corresponding point. These coordinates are in the [0..1]x[0..1] region,
// with 0, 0 being in the lower left corder (which is typical for OpenGL).
//
// The output @fragColor should be a RGBA color (with premultiplied alpha) that
// will be used as the output for the specified pixel location. Note that this
// output will be automatically clipped to the clip region of the glshader node.
//
// In addition to the function arguments the shader can define up to 4 uniforms
// for textures which must be called u_textureN (i.e. u_texture1 to u_texture4)
// as well as any custom uniforms you want of types int, uint, bool, float,
// vec2, vec3 or vec4.
//
// All textures sources contain premultiplied alpha colors, but if some there
// are outer sources of colors there is a gsk_premultiply() helper to compute
// premultiplication when needed.
//
// Note that GTK parses the uniform declarations, so each uniform has to be on a
// line by itself with no other code, like so:
//
// “`glsl uniform float u_time; uniform vec3 u_color; uniform sampler2D
// u_texture1; uniform sampler2D u_texture2; “`
//
// GTK uses the the "gsk" namespace in the symbols it uses in the shader, so
// your code should not use any symbols with the prefix gsk or GSK. There are
// some helper functions declared that you can use:
//
// “`glsl vec4 GskTexture(sampler2D sampler, vec2 texCoords); “`
//
// This samples a texture (e.g. u_texture1) at the specified coordinates, and
// containes some helper ifdefs to ensure that it works on all OpenGL versions.
//
// You can compile the shader yourself using [method@Gsk.GLShader.compile],
// otherwise the GSK renderer will do it when it handling the glshader node. If
// errors occurs, the returned @error will include the glsl sources, so you can
// see what GSK was passing to the compiler. You can also set GSK_DEBUG=shaders
// in the environment to see the sources and other relevant information about
// all shaders that GSK is handling.
//
//
// An example shader
//
// “`glsl uniform float position; uniform sampler2D u_texture1; uniform
// sampler2D u_texture2;
//
// void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in
// vec2 uv) { vec4 source1 = GskTexture(u_texture1, uv); vec4 source2 =
// GskTexture(u_texture2, uv);
//
//    fragColor = position * source1 + (1.0 - position) * source2;
//
// } “`
type GLShader interface {

	// CompileGLShader tries to compile the @shader for the given @renderer.
	//
	// If there is a problem, this function returns false and reports an error.
	// You should use this function before relying on the shader for rendering
	// and use a fallback with a simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	CompileGLShader(renderer Renderer) error
	// FindUniformByNameGLShader looks for a uniform by the name @name, and
	// returns the index of the uniform, or -1 if it was not found.
	FindUniformByNameGLShader(name string) int
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

// glShader implements the GLShader class.
type glShader struct {
	gextras.Objector
}

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return glShader{
		Objector: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// NewGLShaderFromResource creates a `GskGLShader` that will render pixels using
// the specified code.
func NewGLShaderFromResource(resourcePath string) GLShader {
	var _arg1 *C.char        // out
	var _cret *C.GskGLShader // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_new_from_resource(_arg1)

	var _glShader GLShader // out

	_glShader = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(GLShader)

	return _glShader
}

func (s glShader) CompileGLShader(renderer Renderer) error {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GskRenderer // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRenderer)(unsafe.Pointer(renderer.Native()))

	C.gsk_gl_shader_compile(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s glShader) FindUniformByNameGLShader(name string) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.char        // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_find_uniform_by_name(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s glShader) ArgsSize() uint {
	var _arg0 *C.GskGLShader // out
	var _cret C.gsize        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_args_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (s glShader) NTextures() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_n_textures(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s glShader) NUniforms() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_n_uniforms(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s glShader) Resource() string {
	var _arg0 *C.GskGLShader // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_resource(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s glShader) UniformName(idx int) string {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s glShader) UniformOffset(idx int) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_offset(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (s glShader) UniformType(idx int) GLUniformType {
	var _arg0 *C.GskGLShader     // out
	var _arg1 C.int              // out
	var _cret C.GskGLUniformType // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_type(_arg0, _arg1)

	var _glUniformType GLUniformType // out

	_glUniformType = GLUniformType(_cret)

	return _glUniformType
}

// GLShaderNode: a render node using a GL shader when drawing its children
// nodes.
type GLShaderNode interface {

	// Child gets one of the children.
	Child(idx uint) RenderNode
	// NChildren returns the number of children
	NChildren() uint
	// Shader gets shader code for the node.
	Shader() GLShader
}

// glShaderNode implements the GLShaderNode class.
type glShaderNode struct {
	RenderNode
}

// WrapGLShaderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShaderNode(obj *externglib.Object) GLShaderNode {
	return glShaderNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShaderNode(obj), nil
}

func (n glShaderNode) Child(idx uint) RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = (C.guint)(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n glShaderNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (n glShaderNode) Shader() GLShader {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)

	var _glShader GLShader // out

	_glShader = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(GLShader)

	return _glShader
}

// InsetShadowNode: a render node for an inset shadow.
type InsetShadowNode interface {

	// BlurRadius retrieves the blur radius to apply to the shadow.
	BlurRadius() float32
	// Color retrieves the color of the inset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the inset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the inset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the inset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads inwards.
	Spread() float32
}

// insetShadowNode implements the InsetShadowNode class.
type insetShadowNode struct {
	RenderNode
}

// WrapInsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapInsetShadowNode(obj *externglib.Object) InsetShadowNode {
	return insetShadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInsetShadowNode(obj), nil
}

// NewInsetShadowNode creates a `GskRenderNode` that will render an inset shadow
// into the box given by @outline.
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) InsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg3 = (C.float)(dx)
	_arg4 = (C.float)(dy)
	_arg5 = (C.float)(spread)
	_arg6 = (C.float)(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _insetShadowNode InsetShadowNode // out

	_insetShadowNode = WrapInsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

func (n insetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n insetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = gdk.WrapRGBA(unsafe.Pointer(_cret))

	return _rgbA
}

func (n insetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n insetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n insetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n insetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// LinearGradientNode: a render node for a linear gradient.
type LinearGradientNode interface {

	// End retrieves the final point of the linear gradient.
	End() *graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the initial point of the linear gradient.
	Start() *graphene.Point
}

// linearGradientNode implements the LinearGradientNode class.
type linearGradientNode struct {
	RenderNode
}

// WrapLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinearGradientNode(obj *externglib.Object) LinearGradientNode {
	return linearGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinearGradientNode(obj), nil
}

// NewLinearGradientNode creates a `GskRenderNode` that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by @bounds.
func NewLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) LinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end.Native()))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _linearGradientNode LinearGradientNode // out

	_linearGradientNode = WrapLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _linearGradientNode
}

func (n linearGradientNode) End() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)

	var _point *graphene.Point // out

	_point = graphene.WrapPoint(unsafe.Pointer(_cret))

	return _point
}

func (n linearGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (n linearGradientNode) Start() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)

	var _point *graphene.Point // out

	_point = graphene.WrapPoint(unsafe.Pointer(_cret))

	return _point
}

type NglRenderer interface {
}

// nglRenderer implements the NglRenderer class.
type nglRenderer struct {
	Renderer
}

// WrapNglRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapNglRenderer(obj *externglib.Object) NglRenderer {
	return nglRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalNglRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNglRenderer(obj), nil
}

// NewNglRenderer creates a new Renderer using the new OpenGL renderer.
func NewNglRenderer() NglRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_ngl_renderer_new()

	var _nglRenderer NglRenderer // out

	_nglRenderer = WrapNglRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _nglRenderer
}

// OpacityNode: a render node controlling the opacity of its single child node.
type OpacityNode interface {

	// Child gets the child node that is getting opacityed by the given @node.
	Child() RenderNode
	// Opacity gets the transparency factor for an opacity node.
	Opacity() float32
}

// opacityNode implements the OpacityNode class.
type opacityNode struct {
	RenderNode
}

// WrapOpacityNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOpacityNode(obj *externglib.Object) OpacityNode {
	return opacityNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOpacityNode(obj), nil
}

// NewOpacityNode creates a `GskRenderNode` that will drawn the @child with
// reduced @opacity.
func NewOpacityNode(child RenderNode, opacity float32) OpacityNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (C.float)(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)

	var _opacityNode OpacityNode // out

	_opacityNode = WrapOpacityNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

func (n opacityNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n opacityNode) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// OutsetShadowNode: a render node for an outset shadow.
type OutsetShadowNode interface {

	// BlurRadius retrieves the blur radius of the shadow.
	BlurRadius() float32
	// Color retrieves the color of the outset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the outset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the outset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the outset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads outwards.
	Spread() float32
}

// outsetShadowNode implements the OutsetShadowNode class.
type outsetShadowNode struct {
	RenderNode
}

// WrapOutsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutsetShadowNode(obj *externglib.Object) OutsetShadowNode {
	return outsetShadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutsetShadowNode(obj), nil
}

// NewOutsetShadowNode creates a `GskRenderNode` that will render an outset
// shadow around the box given by @outline.
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) OutsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg3 = (C.float)(dx)
	_arg4 = (C.float)(dy)
	_arg5 = (C.float)(spread)
	_arg6 = (C.float)(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _outsetShadowNode OutsetShadowNode // out

	_outsetShadowNode = WrapOutsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

func (n outsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n outsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = gdk.WrapRGBA(unsafe.Pointer(_cret))

	return _rgbA
}

func (n outsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n outsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n outsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n outsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// RadialGradientNode: a render node for a radial gradient.
type RadialGradientNode interface {

	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// End retrieves the end value for the gradient.
	End() float32
	// Hradius retrieves the horizonal radius for the gradient.
	Hradius() float32
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the start value for the gradient.
	Start() float32
	// Vradius retrieves the vertical radius for the gradient.
	Vradius() float32
}

// radialGradientNode implements the RadialGradientNode class.
type radialGradientNode struct {
	RenderNode
}

// WrapRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadialGradientNode(obj *externglib.Object) RadialGradientNode {
	return radialGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadialGradientNode(obj), nil
}

// NewRadialGradientNode creates a `GskRenderNode` that draws a radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(hradius)
	_arg4 = (C.float)(vradius)
	_arg5 = (C.float)(start)
	_arg6 = (C.float)(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _radialGradientNode RadialGradientNode // out

	_radialGradientNode = WrapRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radialGradientNode
}

func (n radialGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)

	var _point *graphene.Point // out

	_point = graphene.WrapPoint(unsafe.Pointer(_cret))

	return _point
}

func (n radialGradientNode) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n radialGradientNode) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n radialGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (n radialGradientNode) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (n radialGradientNode) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Renderer: `GskRenderer` is a class that renders a scene graph defined via a
// tree of [class@Gsk.RenderNode] instances.
//
// Typically you will use a `GskRenderer` instance to repeatedly call
// [method@Gsk.Renderer.render] to update the contents of its associated
// [class@Gdk.Surface].
//
// It is necessary to realize a `GskRenderer` instance using
// [method@Gsk.Renderer.realize] before calling [method@Gsk.Renderer.render], in
// order to create the appropriate windowing system resources needed to render
// the scene.
type Renderer interface {

	// Surface retrieves the `GdkSurface` set using gsk_enderer_realize().
	//
	// If the renderer has not been realized yet, nil will be returned.
	Surface() gdk.Surface
	// IsRealizedRenderer checks whether the @renderer is realized or not.
	IsRealizedRenderer() bool
	// RealizeRenderer creates the resources needed by the @renderer to render
	// the scene graph.
	RealizeRenderer(surface gdk.Surface) error
	// RenderRenderer renders the scene graph, described by a tree of
	// `GskRenderNode` instances, ensuring that the given @region gets redrawn.
	//
	// Renderers must ensure that changes of the contents given by the @root
	// node as well as the area given by @region are redrawn. They are however
	// free to not redraw any pixel outside of @region if they can guarantee
	// that it didn't change.
	//
	// The @renderer will acquire a reference on the `GskRenderNode` tree while
	// the rendering is in progress.
	RenderRenderer(root RenderNode, region *cairo.Region)
	// RenderTextureRenderer renders the scene graph, described by a tree of
	// `GskRenderNode` instances, to a `GdkTexture`.
	//
	// The @renderer will acquire a reference on the `GskRenderNode` tree while
	// the rendering is in progress.
	//
	// If you want to apply any transformations to @root, you should put it into
	// a transform node and pass that node instead.
	RenderTextureRenderer(root RenderNode, viewport *graphene.Rect) gdk.Texture
	// UnrealizeRenderer releases all the resources created by
	// gsk_renderer_realize().
	UnrealizeRenderer()
}

// renderer implements the Renderer class.
type renderer struct {
	gextras.Objector
}

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return renderer{
		Objector: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

// NewRendererForSurface creates an appropriate `GskRenderer` instance for the
// given @surface.
//
// If the `GSK_RENDERER` environment variable is set, GSK will try that renderer
// first, before trying the backend-specific default. The ultimate fallback is
// the cairo renderer.
//
// The renderer will be realized before it is returned.
func NewRendererForSurface(surface gdk.Surface) Renderer {
	var _arg1 *C.GdkSurface  // out
	var _cret *C.GskRenderer // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	_cret = C.gsk_renderer_new_for_surface(_arg1)

	var _renderer Renderer // out

	_renderer = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _renderer
}

func (r renderer) Surface() gdk.Surface {
	var _arg0 *C.GskRenderer // out
	var _cret *C.GdkSurface  // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.gsk_renderer_get_surface(_arg0)

	var _surface gdk.Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Surface)

	return _surface
}

func (r renderer) IsRealizedRenderer() bool {
	var _arg0 *C.GskRenderer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.gsk_renderer_is_realized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (r renderer) RealizeRenderer(surface gdk.Surface) error {
	var _arg0 *C.GskRenderer // out
	var _arg1 *C.GdkSurface  // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gsk_renderer_realize(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (r renderer) RenderRenderer(root RenderNode, region *cairo.Region) {
	var _arg0 *C.GskRenderer    // out
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.cairo_region_t // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(root.Native()))
	_arg2 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gsk_renderer_render(_arg0, _arg1, _arg2)
}

func (r renderer) RenderTextureRenderer(root RenderNode, viewport *graphene.Rect) gdk.Texture {
	var _arg0 *C.GskRenderer     // out
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GdkTexture      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(root.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(viewport.Native()))

	_cret = C.gsk_renderer_render_texture(_arg0, _arg1, _arg2)

	var _texture gdk.Texture // out

	_texture = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Texture)

	return _texture
}

func (r renderer) UnrealizeRenderer() {
	var _arg0 *C.GskRenderer // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	C.gsk_renderer_unrealize(_arg0)
}

// RepeatNode: a render node repeating its single child node.
type RepeatNode interface {

	// Child retrieves the child of @node.
	Child() RenderNode
	// ChildBounds retrieves the bounding rectangle of the child of @node.
	ChildBounds() *graphene.Rect
}

// repeatNode implements the RepeatNode class.
type repeatNode struct {
	RenderNode
}

// WrapRepeatNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatNode(obj *externglib.Object) RepeatNode {
	return repeatNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatNode(obj), nil
}

// NewRepeatNode creates a `GskRenderNode` that will repeat the drawing of
// @child across the given @bounds.
func NewRepeatNode(bounds *graphene.Rect, child RenderNode, childBounds *graphene.Rect) RepeatNode {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds.Native()))

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)

	var _repeatNode RepeatNode // out

	_repeatNode = WrapRepeatNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

func (n repeatNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n repeatNode) ChildBounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)

	var _rect *graphene.Rect // out

	_rect = graphene.WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// RepeatingLinearGradientNode: a render node for a repeating linear gradient.
type RepeatingLinearGradientNode interface {
}

// repeatingLinearGradientNode implements the RepeatingLinearGradientNode class.
type repeatingLinearGradientNode struct {
	RenderNode
}

// WrapRepeatingLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingLinearGradientNode(obj *externglib.Object) RepeatingLinearGradientNode {
	return repeatingLinearGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingLinearGradientNode(obj), nil
}

// NewRepeatingLinearGradientNode creates a `GskRenderNode` that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by @bounds.
func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) RepeatingLinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end.Native()))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _repeatingLinearGradientNode RepeatingLinearGradientNode // out

	_repeatingLinearGradientNode = WrapRepeatingLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingLinearGradientNode
}

// RepeatingRadialGradientNode: a render node for a repeating radial gradient.
type RepeatingRadialGradientNode interface {
}

// repeatingRadialGradientNode implements the RepeatingRadialGradientNode class.
type repeatingRadialGradientNode struct {
	RenderNode
}

// WrapRepeatingRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingRadialGradientNode(obj *externglib.Object) RepeatingRadialGradientNode {
	return repeatingRadialGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingRadialGradientNode(obj), nil
}

// NewRepeatingRadialGradientNode creates a `GskRenderNode` that draws a
// repeating radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RepeatingRadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
	_arg3 = (C.float)(hradius)
	_arg4 = (C.float)(vradius)
	_arg5 = (C.float)(start)
	_arg6 = (C.float)(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _repeatingRadialGradientNode RepeatingRadialGradientNode // out

	_repeatingRadialGradientNode = WrapRepeatingRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingRadialGradientNode
}

// RoundedClipNode: a render node applying a rounded rectangle clip to its
// single child.
type RoundedClipNode interface {

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrieves the rounded rectangle used to clip the contents of the
	// @node.
	Clip() *RoundedRect
}

// roundedClipNode implements the RoundedClipNode class.
type roundedClipNode struct {
	RenderNode
}

// WrapRoundedClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRoundedClipNode(obj *externglib.Object) RoundedClipNode {
	return roundedClipNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRoundedClipNode(obj), nil
}

// NewRoundedClipNode creates a `GskRenderNode` that will clip the @child to the
// area given by @clip.
func NewRoundedClipNode(child RenderNode, clip *RoundedRect) RoundedClipNode {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskRoundedRect)(unsafe.Pointer(clip.Native()))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)

	var _roundedClipNode RoundedClipNode // out

	_roundedClipNode = WrapRoundedClipNode(externglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

func (n roundedClipNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n roundedClipNode) Clip() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// ShadowNode: a render node drawing one or more shadows behind its single child
// node.
type ShadowNode interface {

	// Child retrieves the child `GskRenderNode` of the shadow @node.
	Child() RenderNode
	// NShadows retrieves the number of shadows in the @node.
	NShadows() uint
	// Shadow retrieves the shadow data at the given index @i.
	Shadow(i uint) *Shadow
}

// shadowNode implements the ShadowNode class.
type shadowNode struct {
	RenderNode
}

// WrapShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapShadowNode(obj *externglib.Object) ShadowNode {
	return shadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShadowNode(obj), nil
}

// NewShadowNode creates a `GskRenderNode` that will draw a @child with the
// given @shadows below it.
func NewShadowNode(child RenderNode, shadows []Shadow) ShadowNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = C.gsize(len(shadows))
	_arg2 = (*C.GskShadow)(unsafe.Pointer(&shadows[0]))

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)

	var _shadowNode ShadowNode // out

	_shadowNode = WrapShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shadowNode
}

func (n shadowNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n shadowNode) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

func (n shadowNode) Shadow(i uint) *Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = (C.gsize)(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)

	var _shadow *Shadow // out

	_shadow = WrapShadow(unsafe.Pointer(_cret))

	return _shadow
}

// TextNode: a render node drawing a set of glyphs.
type TextNode interface {

	// Color retrieves the color used by the text @node.
	Color() *gdk.RGBA
	// Font returns the font used by the text @node.
	Font() pango.Font
	// NumGlyphs retrieves the number of glyphs in the text node.
	NumGlyphs() uint
	// Offset retrieves the offset applied to the text.
	Offset() *graphene.Point
	// HasColorGlyphsTextNode checks whether the text @node has color glyphs.
	HasColorGlyphsTextNode() bool
}

// textNode implements the TextNode class.
type textNode struct {
	RenderNode
}

// WrapTextNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextNode(obj *externglib.Object) TextNode {
	return textNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextNode(obj), nil
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that @color may not be used if the font contains color glyphs.
func NewTextNode(font pango.Font, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) TextNode {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs.Native()))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
	_arg4 = (*C.graphene_point_t)(unsafe.Pointer(offset.Native()))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)

	var _textNode TextNode // out

	_textNode = WrapTextNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textNode
}

func (n textNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = gdk.WrapRGBA(unsafe.Pointer(_cret))

	return _rgbA
}

func (n textNode) Font() pango.Font {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_font(_arg0)

	var _font pango.Font // out

	_font = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Font)

	return _font
}

func (n textNode) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (n textNode) Offset() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)

	var _point *graphene.Point // out

	_point = graphene.WrapPoint(unsafe.Pointer(_cret))

	return _point
}

func (n textNode) HasColorGlyphsTextNode() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextureNode: a render node for a Texture.
type TextureNode interface {

	// Texture retrieves the `GdkTexture` used when creating this
	// `GskRenderNode`.
	Texture() gdk.Texture
}

// textureNode implements the TextureNode class.
type textureNode struct {
	RenderNode
}

// WrapTextureNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextureNode(obj *externglib.Object) TextureNode {
	return textureNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextureNode(obj), nil
}

// NewTextureNode creates a `GskRenderNode` that will render the given @texture
// into the area given by @bounds.
func NewTextureNode(texture gdk.Texture, bounds *graphene.Rect) TextureNode {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)

	var _textureNode TextureNode // out

	_textureNode = WrapTextureNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

func (n textureNode) Texture() gdk.Texture {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)

	var _texture gdk.Texture // out

	_texture = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Texture)

	return _texture
}

// TransformNode: a render node applying a `GskTransform` to its single child
// node.
type TransformNode interface {

	// Child gets the child node that is getting transformed by the given @node.
	Child() RenderNode
	// Transform retrieves the `GskTransform` used by the @node.
	Transform() *Transform
}

// transformNode implements the TransformNode class.
type transformNode struct {
	RenderNode
}

// WrapTransformNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTransformNode(obj *externglib.Object) TransformNode {
	return transformNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTransformNode(obj), nil
}

// NewTransformNode creates a `GskRenderNode` that will transform the given
// @child with the given @transform.
func NewTransformNode(child RenderNode, transform *Transform) TransformNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)

	var _transformNode TransformNode // out

	_transformNode = WrapTransformNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

func (n transformNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n transformNode) Transform() *Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

// VulkanRenderer: a GSK renderer that is using Vulkan.
type VulkanRenderer interface {
}

// vulkanRenderer implements the VulkanRenderer class.
type vulkanRenderer struct {
	Renderer
}

// WrapVulkanRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanRenderer(obj *externglib.Object) VulkanRenderer {
	return vulkanRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalVulkanRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanRenderer(obj), nil
}

func NewVulkanRenderer() VulkanRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_vulkan_renderer_new()

	var _vulkanRenderer VulkanRenderer // out

	_vulkanRenderer = WrapVulkanRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _vulkanRenderer
}

// ColorStop: a color stop in a gradient node.
type ColorStop C.GskColorStop

// WrapColorStop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorStop(ptr unsafe.Pointer) *ColorStop {
	return (*ColorStop)(ptr)
}

// Native returns the underlying C source pointer.
func (c *ColorStop) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// ParseLocation: a location in a parse buffer.
type ParseLocation C.GskParseLocation

// WrapParseLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParseLocation(ptr unsafe.Pointer) *ParseLocation {
	return (*ParseLocation)(ptr)
}

// Native returns the underlying C source pointer.
func (p *ParseLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// [method@Gsk.RoundedRect.normalize]; this function will ensure that the bounds
// of the rectangle are normalized and ensure that the corner values are
// positive and the corners do not overlap.
//
// All functions taking a `GskRoundedRect` as an argument will internally
// operate on a normalized copy; all functions returning a `GskRoundedRect` will
// always return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in the CSS
// specification (https://drafts.csswg.org/css-backgrounds-3/#border-radius).
type RoundedRect C.GskRoundedRect

// WrapRoundedRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRoundedRect(ptr unsafe.Pointer) *RoundedRect {
	return (*RoundedRect)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// ContainsPoint checks if the given @point is inside the rounded rectangle.
func (s *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var _arg0 *C.GskRoundedRect   // out
	var _arg1 *C.graphene_point_t // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_rounded_rect_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsRect checks if the given @rect is contained inside the rounded
// rectangle.
func (s *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	_cret = C.gsk_rounded_rect_contains_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init initializes the given `GskRoundedRect` with the given values.
//
// This function will implicitly normalize the `GskRoundedRect` before
// returning.
func (s *RoundedRect) Init(bounds *graphene.Rect, topLeft *graphene.Size, topRight *graphene.Size, bottomRight *graphene.Size, bottomLeft *graphene.Size) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.graphene_size_t // out
	var _arg3 *C.graphene_size_t // out
	var _arg4 *C.graphene_size_t // out
	var _arg5 *C.graphene_size_t // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_size_t)(unsafe.Pointer(topLeft.Native()))
	_arg3 = (*C.graphene_size_t)(unsafe.Pointer(topRight.Native()))
	_arg4 = (*C.graphene_size_t)(unsafe.Pointer(bottomRight.Native()))
	_arg5 = (*C.graphene_size_t)(unsafe.Pointer(bottomLeft.Native()))

	_cret = C.gsk_rounded_rect_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// InitCopy initializes @self using the given @src rectangle.
//
// This function will not normalize the `GskRoundedRect`, so make sure the
// source is normalized.
func (s *RoundedRect) InitCopy(src *RoundedRect) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(src.Native()))

	_cret = C.gsk_rounded_rect_init_copy(_arg0, _arg1)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// InitFromRect initializes @self to the given @bounds and sets the radius of
// all four corners to @radius.
func (s *RoundedRect) InitFromRect(bounds *graphene.Rect, radius float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.float            // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (C.float)(radius)

	_cret = C.gsk_rounded_rect_init_from_rect(_arg0, _arg1, _arg2)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// IntersectsRect checks if part of the given @rect is contained inside the
// rounded rectangle.
func (s *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	_cret = C.gsk_rounded_rect_intersects_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRectilinear checks if all corners of @self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if [ctor@Gsk.ClipNode.new] or
// [ctor@Gsk.RoundedClipNode.new] should be called.
func (s *RoundedRect) IsRectilinear() bool {
	var _arg0 *C.GskRoundedRect // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_rounded_rect_is_rectilinear(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Normalize normalizes the passed rectangle.
//
// This function will ensure that the bounds of the rectangle are normalized and
// ensure that the corner values are positive and the corners do not overlap.
func (s *RoundedRect) Normalize() *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_rounded_rect_normalize(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// Offset offsets the bound's origin by @dx and @dy.
//
// The size and corners of the rectangle are unchanged.
func (s *RoundedRect) Offset(dx float32, dy float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(dx)
	_arg2 = (C.float)(dy)

	_cret = C.gsk_rounded_rect_offset(_arg0, _arg1, _arg2)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// Shrink shrinks (or grows) the given rectangle by moving the 4 sides according
// to the offsets given.
//
// The corner radii will be changed in a way that tries to keep the center of
// the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass negative values
// for the @top, @right, @bottom or @left.
func (s *RoundedRect) Shrink(top float32, right float32, bottom float32, left float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(top)
	_arg2 = (C.float)(right)
	_arg3 = (C.float)(bottom)
	_arg4 = (C.float)(left)

	_cret = C.gsk_rounded_rect_shrink(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder C.GskShaderArgsBuilder

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*ShaderArgsBuilder)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// Ref increases the reference count of a `GskShaderArgsBuilder` by one.
func (b *ShaderArgsBuilder) Ref() *ShaderArgsBuilder {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _cret *C.GskShaderArgsBuilder // in

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gsk_shader_args_builder_ref(_arg0)

	var _shaderArgsBuilder *ShaderArgsBuilder // out

	_shaderArgsBuilder = WrapShaderArgsBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_shaderArgsBuilder, func(v *ShaderArgsBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _shaderArgsBuilder
}

// SetBool sets the value of the uniform @idx.
//
// The uniform must be of bool type.
func (b *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	if value {
		_arg2 = C.TRUE
	}

	C.gsk_shader_args_builder_set_bool(_arg0, _arg1, _arg2)
}

// SetFloat sets the value of the uniform @idx.
//
// The uniform must be of float type.
func (b *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.float                 // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.float)(value)

	C.gsk_shader_args_builder_set_float(_arg0, _arg1, _arg2)
}

// SetInt sets the value of the uniform @idx.
//
// The uniform must be of int type.
func (b *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gint32                // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.gint32)(value)

	C.gsk_shader_args_builder_set_int(_arg0, _arg1, _arg2)
}

// SetUint sets the value of the uniform @idx.
//
// The uniform must be of uint type.
func (b *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.guint32               // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.guint32)(value)

	C.gsk_shader_args_builder_set_uint(_arg0, _arg1, _arg2)
}

// SetVec2 sets the value of the uniform @idx.
//
// The uniform must be of vec2 type.
func (b *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec2_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec2_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec2(_arg0, _arg1, _arg2)
}

// SetVec3 sets the value of the uniform @idx.
//
// The uniform must be of vec3 type.
func (b *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec3_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec3(_arg0, _arg1, _arg2)
}

// SetVec4 sets the value of the uniform @idx.
//
// The uniform must be of vec4 type.
func (b *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec4_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec4(_arg0, _arg1, _arg2)
}

// Unref decreases the reference count of a `GskShaderArgBuilder` by one.
//
// If the resulting reference count is zero, frees the builder.
func (b *ShaderArgsBuilder) Unref() {
	var _arg0 *C.GskShaderArgsBuilder // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	C.gsk_shader_args_builder_unref(_arg0)
}

// Shadow: the shadow parameters in a shadow node.
type Shadow C.GskShadow

// WrapShadow wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShadow(ptr unsafe.Pointer) *Shadow {
	return (*Shadow)(ptr)
}

// Native returns the underlying C source pointer.
func (s *Shadow) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// Transform: `GskTransform` is an object to describe transform matrices.
//
// Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how a
// transform was constructed, and allows inspecting them. It is modeled after
// the way CSS describes transforms.
//
// `GskTransform` objects are immutable and cannot be changed after creation.
// This means code can safely expose them as properties of objects without
// having to worry about others changing them.
type Transform C.GskTransform

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Transform)(unsafe.Pointer(b)), nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.GskTransform // in

	_cret = C.gsk_transform_new()

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Equal checks two transforms for equality.
func (f *Transform) Equal(second *Transform) bool {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(second.Native()))

	_cret = C.gsk_transform_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Category returns the category this transform belongs to.
func (s *Transform) Category() TransformCategory {
	var _arg0 *C.GskTransform        // out
	var _cret C.GskTransformCategory // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_get_category(_arg0)

	var _transformCategory TransformCategory // out

	_transformCategory = TransformCategory(_cret)

	return _transformCategory
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (s *Transform) Invert() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_invert(_arg0)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Matrix multiplies @next with the given @matrix.
func (n *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _arg0 *C.GskTransform      // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.GskTransform      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	_cret = C.gsk_transform_matrix(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
func (n *Transform) Perspective(depth float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(depth)

	_cret = C.gsk_transform_perspective(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Ref acquires a reference on the given `GskTransform`.
func (s *Transform) Ref() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_ref(_arg0)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

// Rotate rotates @next @angle degrees in 2D - or in 3D-speak, around the z
// axis.
func (n *Transform) Rotate(angle float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(angle)

	_cret = C.gsk_transform_rotate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate]
func (n *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _arg0 *C.GskTransform    // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.GskTransform    // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	_cret = C.gsk_transform_rotate_3d(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale scales @next in 2-dimensional space by the given factors.
//
// Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.
func (n *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)

	_cret = C.gsk_transform_scale(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale3D scales @next by the given factors.
func (n *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _arg3 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)
	_arg3 = (C.float)(factorZ)

	_cret = C.gsk_transform_scale_3d(_arg0, _arg1, _arg2, _arg3)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// To2D converts a `GskTransform` to a 2D transformation matrix.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
// “` | xx yx | | a b 0 | | xy yy | = | c d 0 | | dx dy | | tx ty 1 | “`
//
// This function can be used to convert between a `GskTransform` and a matrix
// type from other 2D drawing libraries, in particular Cairo.
func (s *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in
	var _arg5 C.float         // in
	var _arg6 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _outXx float32 // out
	var _outYx float32 // out
	var _outXy float32 // out
	var _outYy float32 // out
	var _outDx float32 // out
	var _outDy float32 // out

	_outXx = (float32)(_arg1)
	_outYx = (float32)(_arg2)
	_outXy = (float32)(_arg3)
	_outYy = (float32)(_arg4)
	_outDx = (float32)(_arg5)
	_outDy = (float32)(_arg6)

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a `GskTransform` to 2D affine transformation factors.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (s *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_affine(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _outScaleX float32 // out
	var _outScaleY float32 // out
	var _outDx float32     // out
	var _outDy float32     // out

	_outScaleX = (float32)(_arg1)
	_outScaleY = (float32)(_arg2)
	_outDx = (float32)(_arg3)
	_outDy = (float32)(_arg4)

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// ToMatrix computes the actual value of @self and stores it in @out_matrix.
//
// The previous value of @out_matrix will be ignored.
func (s *Transform) ToMatrix() graphene.Matrix {
	var _arg0 *C.GskTransform // out
	var _outMatrix graphene.Matrix

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_matrix(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_outMatrix)))

	return _outMatrix
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with [func@Gsk.Transform.parse].
//
// This is a wrapper around [method@Gsk.Transform.print].
func (s *Transform) String() string {
	var _arg0 *C.GskTransform // out
	var _cret *C.char         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTranslate converts a `GskTransform` to a translation operation.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (s *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_translate(_arg0, &_arg1, &_arg2)

	var _outDx float32 // out
	var _outDy float32 // out

	_outDx = (float32)(_arg1)
	_outDy = (float32)(_arg2)

	return _outDx, _outDy
}

// Transform applies all the operations from @other to @next.
func (n *Transform) Transform(other *Transform) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(other.Native()))

	_cret = C.gsk_transform_transform(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// TransformBounds transforms a `graphene_rect_t` using the given transform
// @self.
//
// The result is the bounding box containing the coplanar quad.
func (s *Transform) TransformBounds(rect *graphene.Rect) graphene.Rect {
	var _arg0 *C.GskTransform    // out
	var _arg1 *C.graphene_rect_t // out
	var _outRect graphene.Rect

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	C.gsk_transform_transform_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_outRect)))

	return _outRect
}

// TransformPoint transforms a `graphene_point_t` using the given transform
// @self.
func (s *Transform) TransformPoint(point *graphene.Point) graphene.Point {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _outPoint graphene.Point

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	C.gsk_transform_transform_point(_arg0, _arg1, (*C.graphene_point_t)(unsafe.Pointer(&_outPoint)))

	return _outPoint
}

// Translate translates @next in 2-dimensional space by @point.
func (n *Transform) Translate(point *graphene.Point) *Transform {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _cret *C.GskTransform     // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_transform_translate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Translate3D translates @next by @point.
func (n *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _arg0 *C.GskTransform       // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.GskTransform       // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_transform_translate_3d(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Unref releases a reference on the given `GskTransform`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Transform) Unref() {
	var _arg0 *C.GskTransform // out

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_unref(_arg0)
}
