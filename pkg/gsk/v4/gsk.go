// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/graphene"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},
		{T: externglib.Type(C.gsk_cairo_renderer_get_type()), F: marshalCairoRenderer},
		{T: externglib.Type(C.gsk_gl_renderer_get_type()), F: marshalGLRenderer},
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_ngl_renderer_get_type()), F: marshalNglRenderer},
		{T: externglib.Type(C.gsk_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.gsk_vulkan_renderer_get_type()), F: marshalVulkanRenderer},
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// BlendModeDefault: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// BlendModeMultiply: the source color is multiplied by the destination and
	// replaces the destination
	BlendModeMultiply BlendMode = 1
	// BlendModeScreen multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen BlendMode = 2
	// BlendModeOverlay multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// BlendModeDarken selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// BlendModeLighten selects the lighter of the destination and source colors
	BlendModeLighten BlendMode = 5
	// BlendModeColorDodge brightens the destination color to reflect the source
	// color
	BlendModeColorDodge BlendMode = 6
	// BlendModeColorBurn darkens the destination color to reflect the source
	// color
	BlendModeColorBurn BlendMode = 7
	// BlendModeHardLight multiplies or screens the colors, depending on the
	// source color value
	BlendModeHardLight BlendMode = 8
	// BlendModeSoftLight darkens or lightens the colors, depending on the
	// source color value
	BlendModeSoftLight BlendMode = 9
	// BlendModeDifference subtracts the darker of the two constituent colors
	// from the lighter color
	BlendModeDifference BlendMode = 10
	// BlendModeExclusion produces an effect similar to that of the difference
	// mode but lower in contrast
	BlendModeExclusion BlendMode = 11
	// BlendModeColor creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// BlendModeHue creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// BlendModeSaturation creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// BlendModeLuminosity creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// CornerTopLeft: the top left corner
	CornerTopLeft Corner = 0
	// CornerTopRight: the top right corner
	CornerTopRight Corner = 1
	// CornerBottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// CornerBottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that `GskGLShaders`
// declare.
//
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// GLUniformTypeFloat: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// GLUniformTypeInt: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// GLUniformTypeUint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// GLUniformTypeBool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// GLUniformTypeVec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// GLUniformTypeVec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// GLUniformTypeVec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// RenderNodeTypeNotARenderNode: error type. No node will ever have this
	// type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// RenderNodeTypeContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// RenderNodeTypeCairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// RenderNodeTypeColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// RenderNodeTypeLinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RenderNodeTypeRepeatingLinearGradientNode: a node drawing a repeating
	// linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RenderNodeTypeRadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RenderNodeTypeRepeatingRadialGradientNode: a node drawing a repeating
	// radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// RenderNodeTypeConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// RenderNodeTypeBorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// RenderNodeTypeTextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// RenderNodeTypeInsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// RenderNodeTypeOutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// RenderNodeTypeTransformNode: a node that renders its child after applying
	// a matrix transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// RenderNodeTypeOpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// RenderNodeTypeColorMatrixNode: a node that applies a color matrix to
	// every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RenderNodeTypeRepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// RenderNodeTypeClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RenderNodeTypeRoundedClipNode: a node that clips its child to a rounded
	// rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// RenderNodeTypeShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// RenderNodeTypeBlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// RenderNodeTypeCrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// RenderNodeTypeTextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// RenderNodeTypeBlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// RenderNodeTypeDebugNode: debug information that does not affect the
	// rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// RenderNodeTypeGLShaderNode: a node that uses OpenGL fragment shaders to
	// render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// ScalingFilterLinear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// ScalingFilterNearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// SerializationErrorUnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// SerializationErrorUnsupportedVersion: the version of the data is not
	// understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// SerializationErrorInvalidData: the given data may not exist in a proper
	// serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories. So if you
// want to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via multiplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// TransformCategoryUnknown: the category of the matrix has not been
	// determined.
	TransformCategoryUnknown TransformCategory = 0
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny TransformCategory = 1
	// TransformCategory3D: the matrix is a 3D matrix. This means that the w
	// column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// TransformCategory2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// TransformCategory2DAffine: the matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// TransformCategory2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// TransformCategoryIdentity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CairoRenderer: a GSK renderer that is using cairo.
//
// Since it is using cairo, this renderer cannot support 3D transformations.
type CairoRenderer interface {
	Renderer
}

// cairoRenderer implements the CairoRenderer class.
type cairoRenderer struct {
	Renderer
}

var _ CairoRenderer = (*cairoRenderer)(nil)

// WrapCairoRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoRenderer(obj *externglib.Object) CairoRenderer {
	return cairoRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoRenderer(obj), nil
}

// NewCairoRenderer creates a new Cairo renderer.
//
// The Cairo renderer is the fallback renderer drawing in ways similar to how
// GTK 3 drew its content. Its primary use is as comparison tool.
//
// The Cairo renderer is incomplete. It cannot render 3D transformed content and
// will instead render an error marker. Its usage should be avoided.
func NewCairoRenderer() CairoRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_cairo_renderer_new()

	var _cairoRenderer CairoRenderer // out

	_cairoRenderer = WrapCairoRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoRenderer
}

// GLRenderer: a GSK renderer that is using OpenGL.
type GLRenderer interface {
	Renderer
}

// glRenderer implements the GLRenderer class.
type glRenderer struct {
	Renderer
}

var _ GLRenderer = (*glRenderer)(nil)

// WrapGLRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLRenderer(obj *externglib.Object) GLRenderer {
	return glRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalGLRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLRenderer(obj), nil
}

// NewGLRenderer creates a new Renderer using OpenGL. This is the default
// renderer used by GTK.
func NewGLRenderer() GLRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_gl_renderer_new()

	var _glRenderer GLRenderer // out

	_glRenderer = WrapGLRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glRenderer
}

// GLShader: a `GskGLShader` is a snippet of GLSL that is meant to run in the
// fragment shader of the rendering pipeline.
//
// A fragment shader gets the coordinates being rendered as input and produces
// the pixel values for that particular pixel. Additionally, the shader can
// declare a set of other input arguments, called uniforms (as they are uniform
// over all the calls to your shader in each instance of use). A shader can also
// receive up to 4 textures that it can use as input when producing the pixel
// data.
//
// `GskGLShader` is usually used with gtk_snapshot_push_gl_shader() to produce a
// [class@Gsk.GLShaderNode] in the rendering hierarchy, and then its input
// textures are constructed by rendering the child nodes to textures before
// rendering the shader node itself. (You can pass texture nodes as children if
// you want to directly use a texture as input).
//
// The actual shader code is GLSL code that gets combined with some other code
// into the fragment shader. Since the exact capabilities of the GPU driver
// differs between different OpenGL drivers and hardware, GTK adds some defines
// that you can use to ensure your GLSL code runs on as many drivers as it can.
//
// If the OpenGL driver is GLES, then the shader language version is set to 100,
// and GSK_GLES will be defined in the shader.
//
// Otherwise, if the OpenGL driver does not support the 3.2 core profile, then
// the shader will run with language version 110 for GL2 and 130 for GL3, and
// GSK_LEGACY will be defined in the shader.
//
// If the OpenGL driver supports the 3.2 code profile, it will be used, the
// shader language version is set to 150, and GSK_GL3 will be defined in the
// shader.
//
// The main function the shader must implement is:
//
// “`glsl void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2
// resolution, in vec2 uv) “`
//
// Where the input @fragCoord is the coordinate of the pixel we're currently
// rendering, relative to the boundary rectangle that was specified in the
// `GskGLShaderNode`, and @resolution is the width and height of that rectangle.
// This is in the typical GTK coordinate system with the origin in the top left.
// @uv contains the u and v coordinates that can be used to index a texture at
// the corresponding point. These coordinates are in the [0..1]x[0..1] region,
// with 0, 0 being in the lower left corder (which is typical for OpenGL).
//
// The output @fragColor should be a RGBA color (with premultiplied alpha) that
// will be used as the output for the specified pixel location. Note that this
// output will be automatically clipped to the clip region of the glshader node.
//
// In addition to the function arguments the shader can define up to 4 uniforms
// for textures which must be called u_textureN (i.e. u_texture1 to u_texture4)
// as well as any custom uniforms you want of types int, uint, bool, float,
// vec2, vec3 or vec4.
//
// All textures sources contain premultiplied alpha colors, but if some there
// are outer sources of colors there is a gsk_premultiply() helper to compute
// premultiplication when needed.
//
// Note that GTK parses the uniform declarations, so each uniform has to be on a
// line by itself with no other code, like so:
//
// “`glsl uniform float u_time; uniform vec3 u_color; uniform sampler2D
// u_texture1; uniform sampler2D u_texture2; “`
//
// GTK uses the the "gsk" namespace in the symbols it uses in the shader, so
// your code should not use any symbols with the prefix gsk or GSK. There are
// some helper functions declared that you can use:
//
// “`glsl vec4 GskTexture(sampler2D sampler, vec2 texCoords); “`
//
// This samples a texture (e.g. u_texture1) at the specified coordinates, and
// containes some helper ifdefs to ensure that it works on all OpenGL versions.
//
// You can compile the shader yourself using [method@Gsk.GLShader.compile],
// otherwise the GSK renderer will do it when it handling the glshader node. If
// errors occurs, the returned @error will include the glsl sources, so you can
// see what GSK was passing to the compiler. You can also set GSK_DEBUG=shaders
// in the environment to see the sources and other relevant information about
// all shaders that GSK is handling.
//
//
// An example shader
//
// “`glsl uniform float position; uniform sampler2D u_texture1; uniform
// sampler2D u_texture2;
//
// void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in
// vec2 uv) { vec4 source1 = GskTexture(u_texture1, uv); vec4 source2 =
// GskTexture(u_texture2, uv);
//
//    fragColor = position * source1 + (1.0 - position) * source2;
//
// } “`
type GLShader interface {
	gextras.Objector

	// Compile tries to compile the @shader for the given @renderer.
	//
	// If there is a problem, this function returns false and reports an error.
	// You should use this function before relying on the shader for rendering
	// and use a fallback with a simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) error
	// FindUniformByName looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

// glShader implements the GLShader class.
type glShader struct {
	gextras.Objector
}

var _ GLShader = (*glShader)(nil)

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return glShader{
		Objector: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// NewGLShaderFromResource creates a `GskGLShader` that will render pixels using
// the specified code.
func NewGLShaderFromResource(resourcePath string) GLShader {
	var _arg1 *C.char        // out
	var _cret *C.GskGLShader // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_new_from_resource(_arg1)

	var _glShader GLShader // out

	_glShader = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(GLShader)

	return _glShader
}

// Compile tries to compile the @shader for the given @renderer.
//
// If there is a problem, this function returns false and reports an error. You
// should use this function before relying on the shader for rendering and use a
// fallback with a simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means that
// the widget has to be realized. Commonly you want to call this from the
// realize signal of a widget, or during widget snapshot.
func (s glShader) Compile(renderer Renderer) error {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.GskRenderer // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRenderer)(unsafe.Pointer(renderer.Native()))

	C.gsk_gl_shader_compile(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// FindUniformByName looks for a uniform by the name @name, and returns the
// index of the uniform, or -1 if it was not found.
func (s glShader) FindUniformByName(name string) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 *C.char        // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gsk_gl_shader_find_uniform_by_name(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ArgsSize: get the size of the data block used to specify arguments for this
// shader.
func (s glShader) ArgsSize() uint {
	var _arg0 *C.GskGLShader // out
	var _cret C.gsize        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_args_size(_arg0)

	var _gsize uint // out

	_gsize = (uint)(_cret)

	return _gsize
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase. It
// is determined by looking at the highest u_textureN value that the shader
// defines.
func (s glShader) NTextures() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_n_textures(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// NUniforms: get the number of declared uniforms for this shader.
func (s glShader) NUniforms() int {
	var _arg0 *C.GskGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_n_uniforms(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Resource gets the resource path for the GLSL sourcecode being used to render
// this shader.
func (s glShader) Resource() string {
	var _arg0 *C.GskGLShader // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_gl_shader_get_resource(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UniformName: get the name of the declared uniform for this shader at index
// @idx.
func (s glShader) UniformName(idx int) string {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret *C.char        // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_name(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
func (s glShader) UniformOffset(idx int) int {
	var _arg0 *C.GskGLShader // out
	var _arg1 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_offset(_arg0, _arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UniformType: get the type of the declared uniform for this shader at index
// @idx.
func (s glShader) UniformType(idx int) GLUniformType {
	var _arg0 *C.GskGLShader     // out
	var _arg1 C.int              // out
	var _cret C.GskGLUniformType // in

	_arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	_arg1 = (C.int)(idx)

	_cret = C.gsk_gl_shader_get_uniform_type(_arg0, _arg1)

	var _glUniformType GLUniformType // out

	_glUniformType = GLUniformType(_cret)

	return _glUniformType
}

type NglRenderer interface {
	Renderer
}

// nglRenderer implements the NglRenderer class.
type nglRenderer struct {
	Renderer
}

var _ NglRenderer = (*nglRenderer)(nil)

// WrapNglRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapNglRenderer(obj *externglib.Object) NglRenderer {
	return nglRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalNglRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNglRenderer(obj), nil
}

// NewNglRenderer creates a new Renderer using the new OpenGL renderer.
func NewNglRenderer() NglRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_ngl_renderer_new()

	var _nglRenderer NglRenderer // out

	_nglRenderer = WrapNglRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _nglRenderer
}

// Renderer: `GskRenderer` is a class that renders a scene graph defined via a
// tree of [class@Gsk.RenderNode] instances.
//
// Typically you will use a `GskRenderer` instance to repeatedly call
// [method@Gsk.Renderer.render] to update the contents of its associated
// [class@Gdk.Surface].
//
// It is necessary to realize a `GskRenderer` instance using
// [method@Gsk.Renderer.realize] before calling [method@Gsk.Renderer.render], in
// order to create the appropriate windowing system resources needed to render
// the scene.
type Renderer interface {
	gextras.Objector

	// Surface retrieves the `GdkSurface` set using gsk_enderer_realize().
	//
	// If the renderer has not been realized yet, nil will be returned.
	Surface() gdk.Surface
	// IsRealized checks whether the @renderer is realized or not.
	IsRealized() bool
	// Realize creates the resources needed by the @renderer to render the scene
	// graph.
	Realize(surface gdk.Surface) error
	// Render renders the scene graph, described by a tree of `GskRenderNode`
	// instances, ensuring that the given @region gets redrawn.
	//
	// Renderers must ensure that changes of the contents given by the @root
	// node as well as the area given by @region are redrawn. They are however
	// free to not redraw any pixel outside of @region if they can guarantee
	// that it didn't change.
	//
	// The @renderer will acquire a reference on the `GskRenderNode` tree while
	// the rendering is in progress.
	Render(root RenderNode, region *cairo.Region)
	// RenderTexture renders the scene graph, described by a tree of
	// `GskRenderNode` instances, to a `GdkTexture`.
	//
	// The @renderer will acquire a reference on the `GskRenderNode` tree while
	// the rendering is in progress.
	//
	// If you want to apply any transformations to @root, you should put it into
	// a transform node and pass that node instead.
	RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture
	// Unrealize releases all the resources created by gsk_renderer_realize().
	Unrealize()
}

// renderer implements the Renderer class.
type renderer struct {
	gextras.Objector
}

var _ Renderer = (*renderer)(nil)

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return renderer{
		Objector: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

// NewRendererForSurface creates an appropriate `GskRenderer` instance for the
// given @surface.
//
// If the `GSK_RENDERER` environment variable is set, GSK will try that renderer
// first, before trying the backend-specific default. The ultimate fallback is
// the cairo renderer.
//
// The renderer will be realized before it is returned.
func NewRendererForSurface(surface gdk.Surface) Renderer {
	var _arg1 *C.GdkSurface  // out
	var _cret *C.GskRenderer // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	_cret = C.gsk_renderer_new_for_surface(_arg1)

	var _renderer Renderer // out

	_renderer = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _renderer
}

// Surface retrieves the `GdkSurface` set using gsk_enderer_realize().
//
// If the renderer has not been realized yet, nil will be returned.
func (r renderer) Surface() gdk.Surface {
	var _arg0 *C.GskRenderer // out
	var _cret *C.GdkSurface  // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.gsk_renderer_get_surface(_arg0)

	var _surface gdk.Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Surface)

	return _surface
}

// IsRealized checks whether the @renderer is realized or not.
func (r renderer) IsRealized() bool {
	var _arg0 *C.GskRenderer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.gsk_renderer_is_realized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize creates the resources needed by the @renderer to render the scene
// graph.
func (r renderer) Realize(surface gdk.Surface) error {
	var _arg0 *C.GskRenderer // out
	var _arg1 *C.GdkSurface  // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	C.gsk_renderer_realize(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Render renders the scene graph, described by a tree of `GskRenderNode`
// instances, ensuring that the given @region gets redrawn.
//
// Renderers must ensure that changes of the contents given by the @root node as
// well as the area given by @region are redrawn. They are however free to not
// redraw any pixel outside of @region if they can guarantee that it didn't
// change.
//
// The @renderer will acquire a reference on the `GskRenderNode` tree while the
// rendering is in progress.
func (r renderer) Render(root RenderNode, region *cairo.Region) {
	var _arg0 *C.GskRenderer    // out
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.cairo_region_t // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(root.Native()))
	_arg2 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gsk_renderer_render(_arg0, _arg1, _arg2)
}

// RenderTexture renders the scene graph, described by a tree of `GskRenderNode`
// instances, to a `GdkTexture`.
//
// The @renderer will acquire a reference on the `GskRenderNode` tree while the
// rendering is in progress.
//
// If you want to apply any transformations to @root, you should put it into a
// transform node and pass that node instead.
func (r renderer) RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture {
	var _arg0 *C.GskRenderer     // out
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GdkTexture      // in

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(root.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(viewport.Native()))

	_cret = C.gsk_renderer_render_texture(_arg0, _arg1, _arg2)

	var _texture gdk.Texture // out

	_texture = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Texture)

	return _texture
}

// Unrealize releases all the resources created by gsk_renderer_realize().
func (r renderer) Unrealize() {
	var _arg0 *C.GskRenderer // out

	_arg0 = (*C.GskRenderer)(unsafe.Pointer(r.Native()))

	C.gsk_renderer_unrealize(_arg0)
}

// VulkanRenderer: a GSK renderer that is using Vulkan.
type VulkanRenderer interface {
	Renderer
}

// vulkanRenderer implements the VulkanRenderer class.
type vulkanRenderer struct {
	Renderer
}

var _ VulkanRenderer = (*vulkanRenderer)(nil)

// WrapVulkanRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanRenderer(obj *externglib.Object) VulkanRenderer {
	return vulkanRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalVulkanRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanRenderer(obj), nil
}

func NewVulkanRenderer() VulkanRenderer {
	var _cret *C.GskRenderer // in

	_cret = C.gsk_vulkan_renderer_new()

	var _vulkanRenderer VulkanRenderer // out

	_vulkanRenderer = WrapVulkanRenderer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _vulkanRenderer
}

// ColorStop: a color stop in a gradient node.
type ColorStop struct {
	native C.GskColorStop
}

// WrapColorStop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorStop(ptr unsafe.Pointer) *ColorStop {
	if ptr == nil {
		return nil
	}

	return (*ColorStop)(ptr)
}

// Native returns the underlying C source pointer.
func (c *ColorStop) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// ParseLocation: a location in a parse buffer.
type ParseLocation struct {
	native C.GskParseLocation
}

// WrapParseLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParseLocation(ptr unsafe.Pointer) *ParseLocation {
	if ptr == nil {
		return nil
	}

	return (*ParseLocation)(ptr)
}

// Native returns the underlying C source pointer.
func (p *ParseLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// [method@Gsk.RoundedRect.normalize]; this function will ensure that the bounds
// of the rectangle are normalized and ensure that the corner values are
// positive and the corners do not overlap.
//
// All functions taking a `GskRoundedRect` as an argument will internally
// operate on a normalized copy; all functions returning a `GskRoundedRect` will
// always return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in the CSS
// specification (https://drafts.csswg.org/css-backgrounds-3/#border-radius).
type RoundedRect struct {
	native C.GskRoundedRect
}

// WrapRoundedRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRoundedRect(ptr unsafe.Pointer) *RoundedRect {
	if ptr == nil {
		return nil
	}

	return (*RoundedRect)(ptr)
}

// Native returns the underlying C source pointer.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// ContainsPoint checks if the given @point is inside the rounded rectangle.
func (s *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var _arg0 *C.GskRoundedRect   // out
	var _arg1 *C.graphene_point_t // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_rounded_rect_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsRect checks if the given @rect is contained inside the rounded
// rectangle.
func (s *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	_cret = C.gsk_rounded_rect_contains_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Init initializes the given `GskRoundedRect` with the given values.
//
// This function will implicitly normalize the `GskRoundedRect` before
// returning.
func (s *RoundedRect) Init(bounds *graphene.Rect, topLeft *graphene.Size, topRight *graphene.Size, bottomRight *graphene.Size, bottomLeft *graphene.Size) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.graphene_size_t // out
	var _arg3 *C.graphene_size_t // out
	var _arg4 *C.graphene_size_t // out
	var _arg5 *C.graphene_size_t // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (*C.graphene_size_t)(unsafe.Pointer(topLeft.Native()))
	_arg3 = (*C.graphene_size_t)(unsafe.Pointer(topRight.Native()))
	_arg4 = (*C.graphene_size_t)(unsafe.Pointer(bottomRight.Native()))
	_arg5 = (*C.graphene_size_t)(unsafe.Pointer(bottomLeft.Native()))

	_cret = C.gsk_rounded_rect_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// InitCopy initializes @self using the given @src rectangle.
//
// This function will not normalize the `GskRoundedRect`, so make sure the
// source is normalized.
func (s *RoundedRect) InitCopy(src *RoundedRect) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(src.Native()))

	_cret = C.gsk_rounded_rect_init_copy(_arg0, _arg1)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// InitFromRect initializes @self to the given @bounds and sets the radius of
// all four corners to @radius.
func (s *RoundedRect) InitFromRect(bounds *graphene.Rect, radius float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.float            // out
	var _cret *C.GskRoundedRect  // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
	_arg2 = (C.float)(radius)

	_cret = C.gsk_rounded_rect_init_from_rect(_arg0, _arg1, _arg2)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// IntersectsRect checks if part of the given @rect is contained inside the
// rounded rectangle.
func (s *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect  // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	_cret = C.gsk_rounded_rect_intersects_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRectilinear checks if all corners of @self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if [ctor@Gsk.ClipNode.new] or
// [ctor@Gsk.RoundedClipNode.new] should be called.
func (s *RoundedRect) IsRectilinear() bool {
	var _arg0 *C.GskRoundedRect // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_rounded_rect_is_rectilinear(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Normalize normalizes the passed rectangle.
//
// This function will ensure that the bounds of the rectangle are normalized and
// ensure that the corner values are positive and the corners do not overlap.
func (s *RoundedRect) Normalize() *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_rounded_rect_normalize(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// Offset offsets the bound's origin by @dx and @dy.
//
// The size and corners of the rectangle are unchanged.
func (s *RoundedRect) Offset(dx float32, dy float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(dx)
	_arg2 = (C.float)(dy)

	_cret = C.gsk_rounded_rect_offset(_arg0, _arg1, _arg2)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// Shrink shrinks (or grows) the given rectangle by moving the 4 sides according
// to the offsets given.
//
// The corner radii will be changed in a way that tries to keep the center of
// the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass negative values
// for the @top, @right, @bottom or @left.
func (s *RoundedRect) Shrink(top float32, right float32, bottom float32, left float32) *RoundedRect {
	var _arg0 *C.GskRoundedRect // out
	var _arg1 C.float           // out
	var _arg2 C.float           // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(top)
	_arg2 = (C.float)(right)
	_arg3 = (C.float)(bottom)
	_arg4 = (C.float)(left)

	_cret = C.gsk_rounded_rect_shrink(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _roundedRect *RoundedRect // out

	_roundedRect = WrapRoundedRect(unsafe.Pointer(_cret))

	return _roundedRect
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native C.GskShaderArgsBuilder
}

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	if ptr == nil {
		return nil
	}

	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShaderArgsBuilder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Ref increases the reference count of a `GskShaderArgsBuilder` by one.
func (b *ShaderArgsBuilder) Ref() *ShaderArgsBuilder {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _cret *C.GskShaderArgsBuilder // in

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gsk_shader_args_builder_ref(_arg0)

	var _shaderArgsBuilder *ShaderArgsBuilder // out

	_shaderArgsBuilder = WrapShaderArgsBuilder(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_shaderArgsBuilder, func(v *ShaderArgsBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _shaderArgsBuilder
}

// SetBool sets the value of the uniform @idx.
//
// The uniform must be of bool type.
func (b *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	if value {
		_arg2 = C.TRUE
	}

	C.gsk_shader_args_builder_set_bool(_arg0, _arg1, _arg2)
}

// SetFloat sets the value of the uniform @idx.
//
// The uniform must be of float type.
func (b *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.float                 // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.float)(value)

	C.gsk_shader_args_builder_set_float(_arg0, _arg1, _arg2)
}

// SetInt sets the value of the uniform @idx.
//
// The uniform must be of int type.
func (b *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.gint32                // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.gint32)(value)

	C.gsk_shader_args_builder_set_int(_arg0, _arg1, _arg2)
}

// SetUint sets the value of the uniform @idx.
//
// The uniform must be of uint type.
func (b *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 C.guint32               // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (C.guint32)(value)

	C.gsk_shader_args_builder_set_uint(_arg0, _arg1, _arg2)
}

// SetVec2 sets the value of the uniform @idx.
//
// The uniform must be of vec2 type.
func (b *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec2_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec2_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec2(_arg0, _arg1, _arg2)
}

// SetVec3 sets the value of the uniform @idx.
//
// The uniform must be of vec3 type.
func (b *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec3_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec3(_arg0, _arg1, _arg2)
}

// SetVec4 sets the value of the uniform @idx.
//
// The uniform must be of vec4 type.
func (b *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var _arg0 *C.GskShaderArgsBuilder // out
	var _arg1 C.int                   // out
	var _arg2 *C.graphene_vec4_t      // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.int)(idx)
	_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec4(_arg0, _arg1, _arg2)
}

// Unref decreases the reference count of a `GskShaderArgBuilder` by one.
//
// If the resulting reference count is zero, frees the builder.
func (b *ShaderArgsBuilder) Unref() {
	var _arg0 *C.GskShaderArgsBuilder // out

	_arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	C.gsk_shader_args_builder_unref(_arg0)
}

// Shadow: the shadow parameters in a shadow node.
type Shadow struct {
	native C.GskShadow
}

// WrapShadow wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShadow(ptr unsafe.Pointer) *Shadow {
	if ptr == nil {
		return nil
	}

	return (*Shadow)(ptr)
}

// Native returns the underlying C source pointer.
func (s *Shadow) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Transform: `GskTransform` is an object to describe transform matrices.
//
// Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how a
// transform was constructed, and allows inspecting them. It is modeled after
// the way CSS describes transforms.
//
// `GskTransform` objects are immutable and cannot be changed after creation.
// This means code can safely expose them as properties of objects without
// having to worry about others changing them.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	if ptr == nil {
		return nil
	}

	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTransform(unsafe.Pointer(b)), nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.GskTransform // in

	_cret = C.gsk_transform_new()

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Equal checks two transforms for equality.
func (f *Transform) Equal(second *Transform) bool {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(second.Native()))

	_cret = C.gsk_transform_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Category returns the category this transform belongs to.
func (s *Transform) Category() TransformCategory {
	var _arg0 *C.GskTransform        // out
	var _cret C.GskTransformCategory // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_get_category(_arg0)

	var _transformCategory TransformCategory // out

	_transformCategory = TransformCategory(_cret)

	return _transformCategory
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (s *Transform) Invert() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_invert(_arg0)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Matrix multiplies @next with the given @matrix.
func (n *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _arg0 *C.GskTransform      // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.GskTransform      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	_cret = C.gsk_transform_matrix(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
func (n *Transform) Perspective(depth float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(depth)

	_cret = C.gsk_transform_perspective(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Ref acquires a reference on the given `GskTransform`.
func (s *Transform) Ref() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_ref(_arg0)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

// Rotate rotates @next @angle degrees in 2D - or in 3D-speak, around the z
// axis.
func (n *Transform) Rotate(angle float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(angle)

	_cret = C.gsk_transform_rotate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate]
func (n *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _arg0 *C.GskTransform    // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.GskTransform    // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	_cret = C.gsk_transform_rotate_3d(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale scales @next in 2-dimensional space by the given factors.
//
// Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.
func (n *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)

	_cret = C.gsk_transform_scale(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale3D scales @next by the given factors.
func (n *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _arg3 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)
	_arg3 = (C.float)(factorZ)

	_cret = C.gsk_transform_scale_3d(_arg0, _arg1, _arg2, _arg3)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// To2D converts a `GskTransform` to a 2D transformation matrix.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
// “` | xx yx | | a b 0 | | xy yy | = | c d 0 | | dx dy | | tx ty 1 | “`
//
// This function can be used to convert between a `GskTransform` and a matrix
// type from other 2D drawing libraries, in particular Cairo.
func (s *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in
	var _arg5 C.float         // in
	var _arg6 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _outXx float32 // out
	var _outYx float32 // out
	var _outXy float32 // out
	var _outYy float32 // out
	var _outDx float32 // out
	var _outDy float32 // out

	_outXx = (float32)(_arg1)
	_outYx = (float32)(_arg2)
	_outXy = (float32)(_arg3)
	_outYy = (float32)(_arg4)
	_outDx = (float32)(_arg5)
	_outDy = (float32)(_arg6)

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a `GskTransform` to 2D affine transformation factors.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (s *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_affine(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _outScaleX float32 // out
	var _outScaleY float32 // out
	var _outDx float32     // out
	var _outDy float32     // out

	_outScaleX = (float32)(_arg1)
	_outScaleY = (float32)(_arg2)
	_outDx = (float32)(_arg3)
	_outDy = (float32)(_arg4)

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// ToMatrix computes the actual value of @self and stores it in @out_matrix.
//
// The previous value of @out_matrix will be ignored.
func (s *Transform) ToMatrix() graphene.Matrix {
	var _arg0 *C.GskTransform // out
	var _outMatrix graphene.Matrix

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_matrix(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_outMatrix)))

	return _outMatrix
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with [func@Gsk.Transform.parse].
//
// This is a wrapper around [method@Gsk.Transform.print].
func (s *Transform) String() string {
	var _arg0 *C.GskTransform // out
	var _cret *C.char         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	_cret = C.gsk_transform_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTranslate converts a `GskTransform` to a translation operation.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (s *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_to_translate(_arg0, &_arg1, &_arg2)

	var _outDx float32 // out
	var _outDy float32 // out

	_outDx = (float32)(_arg1)
	_outDy = (float32)(_arg2)

	return _outDx, _outDy
}

// Transform applies all the operations from @other to @next.
func (n *Transform) Transform(other *Transform) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(other.Native()))

	_cret = C.gsk_transform_transform(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// TransformBounds transforms a `graphene_rect_t` using the given transform
// @self.
//
// The result is the bounding box containing the coplanar quad.
func (s *Transform) TransformBounds(rect *graphene.Rect) graphene.Rect {
	var _arg0 *C.GskTransform    // out
	var _arg1 *C.graphene_rect_t // out
	var _outRect graphene.Rect

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	C.gsk_transform_transform_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_outRect)))

	return _outRect
}

// TransformPoint transforms a `graphene_point_t` using the given transform
// @self.
func (s *Transform) TransformPoint(point *graphene.Point) graphene.Point {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _outPoint graphene.Point

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	C.gsk_transform_transform_point(_arg0, _arg1, (*C.graphene_point_t)(unsafe.Pointer(&_outPoint)))

	return _outPoint
}

// Translate translates @next in 2-dimensional space by @point.
func (n *Transform) Translate(point *graphene.Point) *Transform {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _cret *C.GskTransform     // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_transform_translate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Translate3D translates @next by @point.
func (n *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _arg0 *C.GskTransform       // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.GskTransform       // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.gsk_transform_translate_3d(_arg0, _arg1)

	var _transform *Transform // out

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Unref releases a reference on the given `GskTransform`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Transform) Unref() {
	var _arg0 *C.GskTransform // out

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_unref(_arg0)
}
