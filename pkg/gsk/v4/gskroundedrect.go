// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/graphene"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// [method@Gsk.RoundedRect.normalize]; this function will ensure that the bounds
// of the rectangle are normalized and ensure that the corner values are
// positive and the corners do not overlap.
//
// All functions taking a `GskRoundedRect` as an argument will internally
// operate on a normalized copy; all functions returning a `GskRoundedRect` will
// always return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in the CSS
// specification (https://drafts.csswg.org/css-backgrounds-3/#border-radius).
type RoundedRect struct {
	native C.GskRoundedRect
}

// WrapRoundedRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRoundedRect(ptr unsafe.Pointer) *RoundedRect {
	if ptr == nil {
		return nil
	}

	return (*RoundedRect)(ptr)
}

func marshalRoundedRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRoundedRect(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// ContainsPoint checks if the given @point is inside the rounded rectangle.
func (s *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var _arg0 *C.GskRoundedRect
	var _arg1 *C.graphene_point_t

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	var _cret C.gboolean

	_cret = C.gsk_rounded_rect_contains_point(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainsRect checks if the given @rect is contained inside the rounded
// rectangle.
func (s *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect
	var _arg1 *C.graphene_rect_t

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	var _cret C.gboolean

	_cret = C.gsk_rounded_rect_contains_rect(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IntersectsRect checks if part of the given @rect is contained inside the
// rounded rectangle.
func (s *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var _arg0 *C.GskRoundedRect
	var _arg1 *C.graphene_rect_t

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	var _cret C.gboolean

	_cret = C.gsk_rounded_rect_intersects_rect(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IsRectilinear checks if all corners of @self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if [ctor@Gsk.ClipNode.new] or
// [ctor@Gsk.RoundedClipNode.new] should be called.
func (s *RoundedRect) IsRectilinear() bool {
	var _arg0 *C.GskRoundedRect

	_arg0 = (*C.GskRoundedRect)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean

	_cret = C.gsk_rounded_rect_is_rectilinear(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}
