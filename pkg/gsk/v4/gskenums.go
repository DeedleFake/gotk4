// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// Default: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = iota
	// Multiply: the source color is multiplied by the destination and replaces
	// the destination
	BlendModeMultiply
	// Screen multiplies the complements of the destination and source color
	// values, then complements the result.
	BlendModeScreen
	// Overlay multiplies or screens the colors, depending on the destination
	// color value. This is the inverse of hard-list
	BlendModeOverlay
	// Darken selects the darker of the destination and source colors
	BlendModeDarken
	// Lighten selects the lighter of the destination and source colors
	BlendModeLighten
	// ColorDodge brightens the destination color to reflect the source color
	BlendModeColorDodge
	// ColorBurn darkens the destination color to reflect the source color
	BlendModeColorBurn
	// HardLight multiplies or screens the colors, depending on the source color
	// value
	BlendModeHardLight
	// SoftLight darkens or lightens the colors, depending on the source color
	// value
	BlendModeSoftLight
	// Difference subtracts the darker of the two constituent colors from the
	// lighter color
	BlendModeDifference
	// Exclusion produces an effect similar to that of the difference mode but
	// lower in contrast
	BlendModeExclusion
	// Color creates a color with the hue and saturation of the source color and
	// the luminosity of the destination color
	BlendModeColor
	// Hue creates a color with the hue of the source color and the saturation
	// and luminosity of the destination color
	BlendModeHue
	// Saturation creates a color with the saturation of the source color and
	// the hue and luminosity of the destination color
	BlendModeSaturation
	// Luminosity creates a color with the luminosity of the source color and
	// the hue and saturation of the destination color
	BlendModeLuminosity
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// TopLeft: the top left corner
	CornerTopLeft Corner = iota
	// TopRight: the top right corner
	CornerTopRight
	// BottomRight: the bottom right corner
	CornerBottomRight
	// BottomLeft: the bottom left corner
	CornerBottomLeft
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that `GskGLShaders`
// declare.
//
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// None: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = iota
	// Float uniform
	GLUniformTypeFloat
	// Int: GLSL int / gint32 uniform
	GLUniformTypeInt
	// Uint: GLSL uint / guint32 uniform
	GLUniformTypeUint
	// Bool: GLSL bool / gboolean uniform
	GLUniformTypeBool
	// Vec2: GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2
	// Vec3: GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3
	// Vec4: GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// NotARenderNode: error type. No node will ever have this type.
	RenderNodeTypeNotARenderNode RenderNodeType = iota
	// ContainerNode: node containing a stack of children
	RenderNodeTypeContainerNode
	// CairoNode: node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode
	// ColorNode: node drawing a single color rectangle
	RenderNodeTypeColorNode
	// LinearGradientNode: node drawing a linear gradient
	RenderNodeTypeLinearGradientNode
	// RepeatingLinearGradientNode: node drawing a repeating linear gradient
	RenderNodeTypeRepeatingLinearGradientNode
	// RadialGradientNode: node drawing a radial gradient
	RenderNodeTypeRadialGradientNode
	// RepeatingRadialGradientNode: node drawing a repeating radial gradient
	RenderNodeTypeRepeatingRadialGradientNode
	// ConicGradientNode: node drawing a conic gradient
	RenderNodeTypeConicGradientNode
	// BorderNode: node stroking a border around an area
	RenderNodeTypeBorderNode
	// TextureNode: node drawing a Texture
	RenderNodeTypeTextureNode
	// InsetShadowNode: node drawing an inset shadow
	RenderNodeTypeInsetShadowNode
	// OutsetShadowNode: node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode
	// TransformNode: node that renders its child after applying a matrix
	// transform
	RenderNodeTypeTransformNode
	// OpacityNode: node that changes the opacity of its child
	RenderNodeTypeOpacityNode
	// ColorMatrixNode: node that applies a color matrix to every pixel
	RenderNodeTypeColorMatrixNode
	// RepeatNode: node that repeats the child's contents
	RenderNodeTypeRepeatNode
	// ClipNode: node that clips its child to a rectangular area
	RenderNodeTypeClipNode
	// RoundedClipNode: node that clips its child to a rounded rectangle
	RenderNodeTypeRoundedClipNode
	// ShadowNode: node that draws a shadow below its child
	RenderNodeTypeShadowNode
	// BlendNode: node that blends two children together
	RenderNodeTypeBlendNode
	// CrossFadeNode: node that cross-fades between two children
	RenderNodeTypeCrossFadeNode
	// TextNode: node containing a glyph string
	RenderNodeTypeTextNode
	// BlurNode: node that applies a blur
	RenderNodeTypeBlurNode
	// DebugNode: debug information that does not affect the rendering
	RenderNodeTypeDebugNode
	// GLShaderNode: node that uses OpenGL fragment shaders to render
	RenderNodeTypeGLShaderNode
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// Linear interpolation filter
	ScalingFilterLinear ScalingFilter = iota
	// Nearest neighbor interpolation filter
	ScalingFilterNearest
	// Trilinear: linear interpolation along each axis, plus mipmap generation,
	// with linear interpolation along the mipmap levels
	ScalingFilterTrilinear
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// UnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = iota
	// UnsupportedVersion: the version of the data is not understood
	SerializationErrorUnsupportedVersion
	// InvalidData: the given data may not exist in a proper serialization
	SerializationErrorInvalidData
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories. So if you
// want to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via multiplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// Unknown: the category of the matrix has not been determined.
	TransformCategoryUnknown TransformCategory = iota
	// Any: analyzing the matrix concluded that it does not fit in any other
	// category.
	TransformCategoryAny
	// 3D: the matrix is a 3D matrix. This means that the w column (the last
	// column) has the values (0, 0, 0, 1).
	TransformCategory3D
	// 2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D
	// 2DAffine: the matrix is a combination of 2D scale and 2D translation
	// operations. In particular, this means that any rectangle can be
	// transformed exactly using this matrix.
	TransformCategory2DAffine
	// 2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate
	// Identity: the matrix is the identity matrix.
	TransformCategoryIdentity
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}
