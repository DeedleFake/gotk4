// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// default: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// multiply: the source color is multiplied by the destination and replaces
	// the destination
	BlendModeMultiply BlendMode = 1
	// screen multiplies the complements of the destination and source color
	// values, then complements the result.
	BlendModeScreen BlendMode = 2
	// overlay multiplies or screens the colors, depending on the destination
	// color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// darken selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// lighten selects the lighter of the destination and source colors
	BlendModeLighten BlendMode = 5
	// ColorDodge brightens the destination color to reflect the source color
	BlendModeColorDodge BlendMode = 6
	// ColorBurn darkens the destination color to reflect the source color
	BlendModeColorBurn BlendMode = 7
	// HardLight multiplies or screens the colors, depending on the source color
	// value
	BlendModeHardLight BlendMode = 8
	// SoftLight darkens or lightens the colors, depending on the source color
	// value
	BlendModeSoftLight BlendMode = 9
	// difference subtracts the darker of the two constituent colors from the
	// lighter color
	BlendModeDifference BlendMode = 10
	// exclusion produces an effect similar to that of the difference mode but
	// lower in contrast
	BlendModeExclusion BlendMode = 11
	// color creates a color with the hue and saturation of the source color and
	// the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// hue creates a color with the hue of the source color and the saturation
	// and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// saturation creates a color with the saturation of the source color and
	// the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// luminosity creates a color with the luminosity of the source color and
	// the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// TopLeft: the top left corner
	CornerTopLeft Corner = 0
	// TopRight: the top right corner
	CornerTopRight Corner = 1
	// BottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// BottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that `GskGLShaders`
// declare.
//
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// none: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// float: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// int: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// uint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// bool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// vec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// vec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// vec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// NotARenderNode: error type. No node will ever have this type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// ContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// CairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// ColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// LinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RepeatingLinearGradientNode: a node drawing a repeating linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RepeatingRadialGradientNode: a node drawing a repeating radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// ConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// BorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// TextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// InsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// OutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// TransformNode: a node that renders its child after applying a matrix
	// transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// OpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// ColorMatrixNode: a node that applies a color matrix to every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// ClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RoundedClipNode: a node that clips its child to a rounded rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// ShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// BlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// CrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// TextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// BlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// DebugNode: debug information that does not affect the rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// GLShaderNode: a node that uses OpenGL fragment shaders to render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// linear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// nearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// trilinear: linear interpolation along each axis, plus mipmap generation,
	// with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// UnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// UnsupportedVersion: the version of the data is not understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// InvalidData: the given data may not exist in a proper serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK.
//
// Note that any category includes matrices of all later categories. So if you
// want to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via multiplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// unknown: the category of the matrix has not been determined.
	TransformCategoryUnknown TransformCategory = 0
	// any: analyzing the matrix concluded that it does not fit in any other
	// category.
	TransformCategoryAny TransformCategory = 1
	// 3D: the matrix is a 3D matrix. This means that the w column (the last
	// column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// 2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// 2DAffine: the matrix is a combination of 2D scale and 2D translation
	// operations. In particular, this means that any rectangle can be
	// transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// 2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// identity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}
