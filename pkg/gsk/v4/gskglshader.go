// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
	})
}

// GLShader: a `GskGLShader` is a snippet of GLSL that is meant to run in the
// fragment shader of the rendering pipeline.
//
// A fragment shader gets the coordinates being rendered as input and produces
// the pixel values for that particular pixel. Additionally, the shader can
// declare a set of other input arguments, called uniforms (as they are uniform
// over all the calls to your shader in each instance of use). A shader can also
// receive up to 4 textures that it can use as input when producing the pixel
// data.
//
// `GskGLShader` is usually used with gtk_snapshot_push_gl_shader() to produce a
// [class@Gsk.GLShaderNode] in the rendering hierarchy, and then its input
// textures are constructed by rendering the child nodes to textures before
// rendering the shader node itself. (You can pass texture nodes as children if
// you want to directly use a texture as input).
//
// The actual shader code is GLSL code that gets combined with some other code
// into the fragment shader. Since the exact capabilities of the GPU driver
// differs between different OpenGL drivers and hardware, GTK adds some defines
// that you can use to ensure your GLSL code runs on as many drivers as it can.
//
// If the OpenGL driver is GLES, then the shader language version is set to 100,
// and GSK_GLES will be defined in the shader.
//
// Otherwise, if the OpenGL driver does not support the 3.2 core profile, then
// the shader will run with language version 110 for GL2 and 130 for GL3, and
// GSK_LEGACY will be defined in the shader.
//
// If the OpenGL driver supports the 3.2 code profile, it will be used, the
// shader language version is set to 150, and GSK_GL3 will be defined in the
// shader.
//
// The main function the shader must implement is:
//
// “`glsl void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2
// resolution, in vec2 uv) “`
//
// Where the input @fragCoord is the coordinate of the pixel we're currently
// rendering, relative to the boundary rectangle that was specified in the
// `GskGLShaderNode`, and @resolution is the width and height of that rectangle.
// This is in the typical GTK coordinate system with the origin in the top left.
// @uv contains the u and v coordinates that can be used to index a texture at
// the corresponding point. These coordinates are in the [0..1]x[0..1] region,
// with 0, 0 being in the lower left corder (which is typical for OpenGL).
//
// The output @fragColor should be a RGBA color (with premultiplied alpha) that
// will be used as the output for the specified pixel location. Note that this
// output will be automatically clipped to the clip region of the glshader node.
//
// In addition to the function arguments the shader can define up to 4 uniforms
// for textures which must be called u_textureN (i.e. u_texture1 to u_texture4)
// as well as any custom uniforms you want of types int, uint, bool, float,
// vec2, vec3 or vec4.
//
// All textures sources contain premultiplied alpha colors, but if some there
// are outer sources of colors there is a gsk_premultiply() helper to compute
// premultiplication when needed.
//
// Note that GTK parses the uniform declarations, so each uniform has to be on a
// line by itself with no other code, like so:
//
// “`glsl uniform float u_time; uniform vec3 u_color; uniform sampler2D
// u_texture1; uniform sampler2D u_texture2; “`
//
// GTK uses the the "gsk" namespace in the symbols it uses in the shader, so
// your code should not use any symbols with the prefix gsk or GSK. There are
// some helper functions declared that you can use:
//
// “`glsl vec4 GskTexture(sampler2D sampler, vec2 texCoords); “`
//
// This samples a texture (e.g. u_texture1) at the specified coordinates, and
// containes some helper ifdefs to ensure that it works on all OpenGL versions.
//
// You can compile the shader yourself using [method@Gsk.GLShader.compile],
// otherwise the GSK renderer will do it when it handling the glshader node. If
// errors occurs, the returned @error will include the glsl sources, so you can
// see what GSK was passing to the compiler. You can also set GSK_DEBUG=shaders
// in the environment to see the sources and other relevant information about
// all shaders that GSK is handling.
//
//
// An example shader
//
// “`glsl uniform float position; uniform sampler2D u_texture1; uniform
// sampler2D u_texture2;
//
// void mainImage(out vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in
// vec2 uv) { vec4 source1 = GskTexture(u_texture1, uv); vec4 source2 =
// GskTexture(u_texture2, uv);
//
//    fragColor = position * source1 + (1.0 - position) * source2;
//
// } “`
type GLShader interface {
	gextras.Objector

	// Compile tries to compile the @shader for the given @renderer.
	//
	// If there is a problem, this function returns false and reports an error.
	// You should use this function before relying on the shader for rendering
	// and use a fallback with a simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) error
	// FindUniformByName looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgBool gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of bool type.
	ArgBool(args *glib.Bytes, idx int) bool
	// ArgFloat gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of float type.
	ArgFloat(args *glib.Bytes, idx int) float32
	// ArgInt gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of int type.
	ArgInt(args *glib.Bytes, idx int) int32
	// ArgUint gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of uint type.
	ArgUint(args *glib.Bytes, idx int) uint32
	// ArgVec2 gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of vec2 type.
	ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2)
	// ArgVec3 gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of vec3 type.
	ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3)
	// ArgVec4 gets the value of the uniform @idx in the @args block.
	//
	// The uniform must be of vec4 type.
	ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4)
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// Source gets the GLSL sourcecode being used to render this shader.
	Source() *glib.Bytes
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

// glShader implements the GLShader interface.
type glShader struct {
	gextras.Objector
}

var _ GLShader = (*glShader)(nil)

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return GLShader{
		Objector: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// NewGLShaderFromBytes constructs a class GLShader.
func NewGLShaderFromBytes(sourcecode *glib.Bytes) GLShader {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(sourcecode.Native())

	ret := C.gsk_gl_shader_new_from_bytes(arg1)

	var ret0 GLShader

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GLShader)

	return ret0
}

// NewGLShaderFromResource constructs a class GLShader.
func NewGLShaderFromResource(resourcePath string) GLShader {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_new_from_resource(arg1)

	var ret0 GLShader

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GLShader)

	return ret0
}

// Compile tries to compile the @shader for the given @renderer.
//
// If there is a problem, this function returns false and reports an error.
// You should use this function before relying on the shader for rendering
// and use a fallback with a simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means
// that the widget has to be realized. Commonly you want to call this from
// the realize signal of a widget, or during widget snapshot.
func (s glShader) Compile(renderer Renderer) error {
	var arg0 *C.GskGLShader
	var arg1 *C.GskRenderer
	var gError *C.GError

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_gl_shader_compile(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FindUniformByName looks for a uniform by the name @name, and returns the
// index of the uniform, or -1 if it was not found.
func (s glShader) FindUniformByName(name string) int {
	var arg0 *C.GskGLShader
	var arg1 *C.char

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_find_uniform_by_name(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ArgBool gets the value of the uniform @idx in the @args block.
//
// The uniform must be of bool type.
func (s glShader) ArgBool(args *glib.Bytes, idx int) bool {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_bool(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ArgFloat gets the value of the uniform @idx in the @args block.
//
// The uniform must be of float type.
func (s glShader) ArgFloat(args *glib.Bytes, idx int) float32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_float(arg0, arg1, arg2)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ArgInt gets the value of the uniform @idx in the @args block.
//
// The uniform must be of int type.
func (s glShader) ArgInt(args *glib.Bytes, idx int) int32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_int(arg0, arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// ArgUint gets the value of the uniform @idx in the @args block.
//
// The uniform must be of uint type.
func (s glShader) ArgUint(args *glib.Bytes, idx int) uint32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_uint(arg0, arg1, arg2)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// ArgVec2 gets the value of the uniform @idx in the @args block.
//
// The uniform must be of vec2 type.
func (s glShader) ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec2_t

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec2_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec2(arg0, arg1, arg2, arg3)
}

// ArgVec3 gets the value of the uniform @idx in the @args block.
//
// The uniform must be of vec3 type.
func (s glShader) ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec3_t

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec3_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec3(arg0, arg1, arg2, arg3)
}

// ArgVec4 gets the value of the uniform @idx in the @args block.
//
// The uniform must be of vec4 type.
func (s glShader) ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec4_t

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec4_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec4(arg0, arg1, arg2, arg3)
}

// ArgsSize: get the size of the data block used to specify arguments for
// this shader.
func (s glShader) ArgsSize() uint {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(s.Native())

	ret := C.gsk_gl_shader_get_args_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase.
// It is determined by looking at the highest u_textureN value that the
// shader defines.
func (s glShader) NTextures() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(s.Native())

	ret := C.gsk_gl_shader_get_n_textures(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NUniforms: get the number of declared uniforms for this shader.
func (s glShader) NUniforms() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(s.Native())

	ret := C.gsk_gl_shader_get_n_uniforms(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Resource gets the resource path for the GLSL sourcecode being used to
// render this shader.
func (s glShader) Resource() string {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(s.Native())

	ret := C.gsk_gl_shader_get_resource(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Source gets the GLSL sourcecode being used to render this shader.
func (s glShader) Source() *glib.Bytes {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(s.Native())

	ret := C.gsk_gl_shader_get_source(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
	}

	return ret0
}

// UniformName: get the name of the declared uniform for this shader at
// index @idx.
func (s glShader) UniformName(idx int) string {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
func (s glShader) UniformOffset(idx int) int {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_offset(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UniformType: get the type of the declared uniform for this shader at
// index @idx.
func (s glShader) UniformType(idx int) GLUniformType {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(s.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_type(arg0, arg1)

	var ret0 GLUniformType

	ret0 = GLUniformType(ret)

	return ret0
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native C.GskShaderArgsBuilder
}

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	if ptr == nil {
		return nil
	}

	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShaderArgsBuilder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewShaderArgsBuilder constructs a struct ShaderArgsBuilder.
func NewShaderArgsBuilder(shader GLShader, initialValues *glib.Bytes) *ShaderArgsBuilder {
	var arg1 *C.GskGLShader
	var arg2 *C.GBytes

	arg1 = (*C.GskGLShader)(shader.Native())
	arg2 = (*C.GBytes)(initialValues.Native())

	ret := C.gsk_shader_args_builder_new(arg1, arg2)

	var ret0 *ShaderArgsBuilder

	{
		ret0 = WrapShaderArgsBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ShaderArgsBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FreeToArgs creates a new #GBytes args from the current state of the given
// @builder, and frees the @builder instance.
//
// Any uniforms of the shader that have not been explicitly set on the @builder
// are zero-initialized.
func (b *ShaderArgsBuilder) FreeToArgs() *glib.Bytes {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())

	ret := C.gsk_shader_args_builder_free_to_args(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref increases the reference count of a `GskShaderArgsBuilder` by one.
func (b *ShaderArgsBuilder) Ref() *ShaderArgsBuilder {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())

	ret := C.gsk_shader_args_builder_ref(arg0)

	var ret0 *ShaderArgsBuilder

	{
		ret0 = WrapShaderArgsBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ShaderArgsBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// SetBool sets the value of the uniform @idx.
//
// The uniform must be of bool type.
func (b *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	if value {
		arg2 = C.TRUE
	}

	C.gsk_shader_args_builder_set_bool(arg0, arg1, arg2)
}

// SetFloat sets the value of the uniform @idx.
//
// The uniform must be of float type.
func (b *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.float

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = C.float(value)

	C.gsk_shader_args_builder_set_float(arg0, arg1, arg2)
}

// SetInt sets the value of the uniform @idx.
//
// The uniform must be of int type.
func (b *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gint32

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = C.gint32(value)

	C.gsk_shader_args_builder_set_int(arg0, arg1, arg2)
}

// SetUint sets the value of the uniform @idx.
//
// The uniform must be of uint type.
func (b *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.guint32

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = C.guint32(value)

	C.gsk_shader_args_builder_set_uint(arg0, arg1, arg2)
}

// SetVec2 sets the value of the uniform @idx.
//
// The uniform must be of vec2 type.
func (b *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec2_t

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec2_t)(value.Native())

	C.gsk_shader_args_builder_set_vec2(arg0, arg1, arg2)
}

// SetVec3 sets the value of the uniform @idx.
//
// The uniform must be of vec3 type.
func (b *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec3_t)(value.Native())

	C.gsk_shader_args_builder_set_vec3(arg0, arg1, arg2)
}

// SetVec4 sets the value of the uniform @idx.
//
// The uniform must be of vec4 type.
func (b *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec4_t

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec4_t)(value.Native())

	C.gsk_shader_args_builder_set_vec4(arg0, arg1, arg2)
}

// ToArgs creates a new `GBytes` args from the current state of the given
// @builder.
//
// Any uniforms of the shader that have not been explicitly set on the @builder
// are zero-initialized.
//
// The given `GskShaderArgsBuilder` is reset once this function returns; you
// cannot call this function multiple times on the same @builder instance.
//
// This function is intended primarily for bindings. C code should use
// [method@Gsk.ShaderArgsBuilder.free_to_args].
func (b *ShaderArgsBuilder) ToArgs() *glib.Bytes {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())

	ret := C.gsk_shader_args_builder_to_args(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count of a `GskShaderArgBuilder` by one.
//
// If the resulting reference count is zero, frees the builder.
func (b *ShaderArgsBuilder) Unref() {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(b.Native())

	C.gsk_shader_args_builder_unref(arg0)
}
