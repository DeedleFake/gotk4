// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/graphene"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
	})
}

// GLShader: an object representing a GL shader program.
type GLShader interface {
	gextras.Objector

	// Compile tries to compile the @shader for the given @renderer, and reports
	// false with an error if there is a problem. You should use this function
	// before relying on the shader for rendering and use a fallback with a
	// simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) error
	// FindUniformByName looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

// glShader implements the GLShader interface.
type glShader struct {
	gextras.Objector
}

var _ GLShader = (*glShader)(nil)

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return GLShader{
		Objector: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// NewGLShaderFromResource constructs a class GLShader.
func NewGLShaderFromResource(resourcePath string) GLShader {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GskGLShader

	cret = C.gsk_gl_shader_new_from_resource(arg1)

	var glShader GLShader

	glShader = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(GLShader)

	return glShader
}

// Compile tries to compile the @shader for the given @renderer, and reports
// false with an error if there is a problem. You should use this function
// before relying on the shader for rendering and use a fallback with a
// simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means
// that the widget has to be realized. Commonly you want to call this from
// the realize signal of a widget, or during widget snapshot.
func (s glShader) Compile(renderer Renderer) error {
	var arg0 *C.GskGLShader
	var arg1 *C.GskRenderer

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GskRenderer)(unsafe.Pointer(renderer.Native()))

	var cerr *C.GError

	C.gsk_gl_shader_compile(arg0, arg1, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// FindUniformByName looks for a uniform by the name @name, and returns the
// index of the uniform, or -1 if it was not found.
func (s glShader) FindUniformByName(name string) int {
	var arg0 *C.GskGLShader
	var arg1 *C.char

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.int

	cret = C.gsk_gl_shader_find_uniform_by_name(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// ArgsSize: get the size of the data block used to specify arguments for
// this shader.
func (s glShader) ArgsSize() uint {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	var cret C.gsize

	cret = C.gsk_gl_shader_get_args_size(arg0)

	var gsize uint

	gsize = (uint)(cret)

	return gsize
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase.
// It is determined by looking at the highest u_textureN value that the
// shader defines.
func (s glShader) NTextures() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gsk_gl_shader_get_n_textures(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NUniforms: get the number of declared uniforms for this shader.
func (s glShader) NUniforms() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	var cret C.int

	cret = C.gsk_gl_shader_get_n_uniforms(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Resource gets the resource path for the GLSL sourcecode being used to
// render this shader.
func (s glShader) Resource() string {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))

	var cret *C.char

	cret = C.gsk_gl_shader_get_resource(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// UniformName: get the name of the declared uniform for this shader at
// index @idx.
func (s glShader) UniformName(idx int) string {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	arg1 = C.int(idx)

	var cret *C.char

	cret = C.gsk_gl_shader_get_uniform_name(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
func (s glShader) UniformOffset(idx int) int {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	arg1 = C.int(idx)

	var cret C.int

	cret = C.gsk_gl_shader_get_uniform_offset(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// UniformType: get the type of the declared uniform for this shader at
// index @idx.
func (s glShader) UniformType(idx int) GLUniformType {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(unsafe.Pointer(s.Native()))
	arg1 = C.int(idx)

	var cret C.GskGLUniformType

	cret = C.gsk_gl_shader_get_uniform_type(arg0, arg1)

	var glUniformType GLUniformType

	glUniformType = GLUniformType(cret)

	return glUniformType
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native C.GskShaderArgsBuilder
}

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	if ptr == nil {
		return nil
	}

	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShaderArgsBuilder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Ref increases the reference count of a ShaderArgsBuilder by one.
func (b *ShaderArgsBuilder) Ref() *ShaderArgsBuilder {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	var cret *C.GskShaderArgsBuilder

	cret = C.gsk_shader_args_builder_ref(arg0)

	var shaderArgsBuilder *ShaderArgsBuilder

	shaderArgsBuilder = WrapShaderArgsBuilder(unsafe.Pointer(cret))
	runtime.SetFinalizer(shaderArgsBuilder, func(v *ShaderArgsBuilder) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return shaderArgsBuilder
}

// SetBool sets the value of the uniform @idx. The uniform must be of bool type.
func (b *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	if value {
		arg2 = C.gboolean(1)
	}

	C.gsk_shader_args_builder_set_bool(arg0, arg1, arg2)
}

// SetFloat sets the value of the uniform @idx. The uniform must be of float
// type.
func (b *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.float

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = C.float(value)

	C.gsk_shader_args_builder_set_float(arg0, arg1, arg2)
}

// SetInt sets the value of the uniform @idx. The uniform must be of int type.
func (b *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gint32

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = C.gint32(value)

	C.gsk_shader_args_builder_set_int(arg0, arg1, arg2)
}

// SetUint sets the value of the uniform @idx. The uniform must be of uint type.
func (b *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.guint32

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = C.guint32(value)

	C.gsk_shader_args_builder_set_uint(arg0, arg1, arg2)
}

// SetVec2 sets the value of the uniform @idx. The uniform must be of vec2 type.
func (b *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec2_t

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec2_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec2(arg0, arg1, arg2)
}

// SetVec3 sets the value of the uniform @idx. The uniform must be of vec3 type.
func (b *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec3(arg0, arg1, arg2)
}

// SetVec4 sets the value of the uniform @idx. The uniform must be of vec4 type.
func (b *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec4_t

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(value.Native()))

	C.gsk_shader_args_builder_set_vec4(arg0, arg1, arg2)
}

// Unref decreases the reference count of a ShaderArgBuilder by one. If the
// resulting reference count is zero, frees the builder.
func (b *ShaderArgsBuilder) Unref() {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(unsafe.Pointer(b.Native()))

	C.gsk_shader_args_builder_unref(arg0)
}
