// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
	})
}

// Transform: `GskTransform` is an object to describe transform matrices.
//
// Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how a
// transform was constructed, and allows inspecting them. It is modeled after
// the way CSS describes transforms.
//
// `GskTransform` objects are immutable and cannot be changed after creation.
// This means code can safely expose them as properties of objects without
// having to worry about others changing them.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	if ptr == nil {
		return nil
	}

	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTransform(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	ret := C.gsk_transform_new()

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Equal checks two transforms for equality.
func (f *Transform) Equal(second *Transform) bool {
	var arg0 *C.GskTransform
	var arg1 *C.GskTransform

	arg0 = (*C.GskTransform)(f.Native())
	arg1 = (*C.GskTransform)(second.Native())

	ret := C.gsk_transform_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Category returns the category this transform belongs to.
func (s *Transform) Category() TransformCategory {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(s.Native())

	ret := C.gsk_transform_get_category(arg0)

	var ret0 TransformCategory

	ret0 = TransformCategory(ret)

	return ret0
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (s *Transform) Invert() *Transform {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(s.Native())

	ret := C.gsk_transform_invert(arg0)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Matrix multiplies @next with the given @matrix.
func (n *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = (*C.graphene_matrix_t)(matrix.Native())

	ret := C.gsk_transform_matrix(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
func (n *Transform) Perspective(depth float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = C.float(depth)

	ret := C.gsk_transform_perspective(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Print converts @self into a human-readable string representation suitable for
// printing.
//
// The result of this function can later be parsed with
// [func@Gsk.Transform.parse].
func (s *Transform) Print(string *glib.String) {
	var arg0 *C.GskTransform
	var arg1 *C.GString

	arg0 = (*C.GskTransform)(s.Native())
	arg1 = (*C.GString)(string.Native())

	C.gsk_transform_print(arg0, arg1)
}

// Ref acquires a reference on the given `GskTransform`.
func (s *Transform) Ref() *Transform {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(s.Native())

	ret := C.gsk_transform_ref(arg0)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
	}

	return ret0
}

// Rotate rotates @next @angle degrees in 2D - or in 3D-speak, around the z
// axis.
func (n *Transform) Rotate(angle float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = C.float(angle)

	ret := C.gsk_transform_rotate(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate]
func (n *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(axis.Native())

	ret := C.gsk_transform_rotate_3d(arg0, arg1, arg2)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Scale scales @next in 2-dimensional space by the given factors.
//
// Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.
func (n *Transform) Scale(factorX float32, factorY float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)

	ret := C.gsk_transform_scale(arg0, arg1, arg2)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Scale3D scales @next by the given factors.
func (n *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	ret := C.gsk_transform_scale_3d(arg0, arg1, arg2, arg3)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// To2D converts a `GskTransform` to a 2D transformation matrix.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
// “` | xx yx | | a b 0 | | xy yy | = | c d 0 | | dx dy | | tx ty 1 | “`
//
// This function can be used to convert between a `GskTransform` and a matrix
// type from other 2D drawing libraries, in particular Cairo.
func (s *Transform) To2D() (outXX float32, outYX float32, outXY float32, outYY float32, outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out
	var arg3 *C.float // out
	var arg4 *C.float // out
	var arg5 *C.float // out
	var arg6 *C.float // out

	arg0 = (*C.GskTransform)(s.Native())

	C.gsk_transform_to_2d(arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 float32
	var ret1 float32
	var ret2 float32
	var ret3 float32
	var ret4 float32
	var ret5 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	ret2 = float32(arg3)

	ret3 = float32(arg4)

	ret4 = float32(arg5)

	ret5 = float32(arg6)

	return ret0, ret1, ret2, ret3, ret4, ret5
}

// ToAffine converts a `GskTransform` to 2D affine transformation factors.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (s *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out
	var arg3 *C.float // out
	var arg4 *C.float // out

	arg0 = (*C.GskTransform)(s.Native())

	C.gsk_transform_to_affine(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 float32
	var ret1 float32
	var ret2 float32
	var ret3 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	ret2 = float32(arg3)

	ret3 = float32(arg4)

	return ret0, ret1, ret2, ret3
}

// ToMatrix computes the actual value of @self and stores it in @out_matrix.
//
// The previous value of @out_matrix will be ignored.
func (s *Transform) ToMatrix() graphene.Matrix {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_matrix_t // out

	arg0 = (*C.GskTransform)(s.Native())

	C.gsk_transform_to_matrix(arg0, &arg1)

	var ret0 *graphene.Matrix

	{
		ret0 = graphene.WrapMatrix(unsafe.Pointer(arg1))
	}

	return ret0
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with [func@Gsk.Transform.parse].
//
// This is a wrapper around [method@Gsk.Transform.print].
func (s *Transform) String() string {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(s.Native())

	ret := C.gsk_transform_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ToTranslate converts a `GskTransform` to a translation operation.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (s *Transform) ToTranslate() (outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out

	arg0 = (*C.GskTransform)(s.Native())

	C.gsk_transform_to_translate(arg0, &arg1, &arg2)

	var ret0 float32
	var ret1 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	return ret0, ret1
}

// Transform applies all the operations from @other to @next.
func (n *Transform) Transform(other *Transform) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.GskTransform

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = (*C.GskTransform)(other.Native())

	ret := C.gsk_transform_transform(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TransformBounds transforms a `graphene_rect_t` using the given transform
// @self.
//
// The result is the bounding box containing the coplanar quad.
func (s *Transform) TransformBounds(rect *graphene.Rect) graphene.Rect {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.GskTransform)(s.Native())
	arg1 = (*C.graphene_rect_t)(rect.Native())

	C.gsk_transform_transform_bounds(arg0, arg1, &arg2)

	var ret0 *graphene.Rect

	{
		ret0 = graphene.WrapRect(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformPoint transforms a `graphene_point_t` using the given transform
// @self.
func (s *Transform) TransformPoint(point *graphene.Point) graphene.Point {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_point_t // out

	arg0 = (*C.GskTransform)(s.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	C.gsk_transform_transform_point(arg0, arg1, &arg2)

	var ret0 *graphene.Point

	{
		ret0 = graphene.WrapPoint(unsafe.Pointer(arg2))
	}

	return ret0
}

// Translate translates @next in 2-dimensional space by @point.
func (n *Transform) Translate(point *graphene.Point) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point_t

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	ret := C.gsk_transform_translate(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Translate3D translates @next by @point.
func (n *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.GskTransform)(n.Native())
	arg1 = (*C.graphene_point3d_t)(point.Native())

	ret := C.gsk_transform_translate_3d(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref releases a reference on the given `GskTransform`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Transform) Unref() {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(s.Native())

	C.gsk_transform_unref(arg0)
}
