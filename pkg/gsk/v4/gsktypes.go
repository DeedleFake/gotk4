// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/graphene"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
	})
}

// Transform: `GskTransform` is an object to describe transform matrices.
//
// Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how a
// transform was constructed, and allows inspecting them. It is modeled after
// the way CSS describes transforms.
//
// `GskTransform` objects are immutable and cannot be changed after creation.
// This means code can safely expose them as properties of objects without
// having to worry about others changing them.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Transform)(unsafe.Pointer(b)), nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.GskTransform // in

	_cret = C.gsk_transform_new()

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Equal checks two transforms for equality.
func (f *Transform) Equal(second *Transform) bool {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(f))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(second))

	_cret = C.gsk_transform_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Category returns the category this transform belongs to.
func (s *Transform) Category() TransformCategory {
	var _arg0 *C.GskTransform        // out
	var _cret C.GskTransformCategory // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	_cret = C.gsk_transform_get_category(_arg0)

	var _transformCategory TransformCategory // out

	_transformCategory = TransformCategory(_cret)

	return _transformCategory
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (s *Transform) Invert() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	_cret = C.gsk_transform_invert(_arg0)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Matrix multiplies @next with the given @matrix.
func (n *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _arg0 *C.GskTransform      // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.GskTransform      // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix))

	_cret = C.gsk_transform_matrix(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
func (n *Transform) Perspective(depth float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = C.float(depth)

	_cret = C.gsk_transform_perspective(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Ref acquires a reference on the given `GskTransform`.
func (s *Transform) ref() *Transform {
	var _arg0 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	_cret = C.gsk_transform_ref(_arg0)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Rotate rotates @next @angle degrees in 2D - or in 3D-speak, around the z
// axis.
func (n *Transform) Rotate(angle float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = C.float(angle)

	_cret = C.gsk_transform_rotate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use [method@Gsk.Transform.rotate]
func (n *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _arg0 *C.GskTransform    // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.GskTransform    // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis))

	_cret = C.gsk_transform_rotate_3d(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Scale scales @next in 2-dimensional space by the given factors.
//
// Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.
func (n *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)

	_cret = C.gsk_transform_scale(_arg0, _arg1, _arg2)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Scale3D scales @next by the given factors.
func (n *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // out
	var _arg2 C.float         // out
	var _arg3 C.float         // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)
	_arg3 = C.float(factorZ)

	_cret = C.gsk_transform_scale_3d(_arg0, _arg1, _arg2, _arg3)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// To2D converts a `GskTransform` to a 2D transformation matrix.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
// “` | xx yx | | a b 0 | | xy yy | = | c d 0 | | dx dy | | tx ty 1 | “`
//
// This function can be used to convert between a `GskTransform` and a matrix
// type from other 2D drawing libraries, in particular Cairo.
func (s *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in
	var _arg5 C.float         // in
	var _arg6 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	C.gsk_transform_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _outXx float32 // out
	var _outYx float32 // out
	var _outXy float32 // out
	var _outYy float32 // out
	var _outDx float32 // out
	var _outDy float32 // out

	_outXx = float32(_arg1)
	_outYx = float32(_arg2)
	_outXy = float32(_arg3)
	_outYy = float32(_arg4)
	_outDx = float32(_arg5)
	_outDy = float32(_arg6)

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a `GskTransform` to 2D affine transformation factors.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (s *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in
	var _arg3 C.float         // in
	var _arg4 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	C.gsk_transform_to_affine(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _outScaleX float32 // out
	var _outScaleY float32 // out
	var _outDx float32     // out
	var _outDy float32     // out

	_outScaleX = float32(_arg1)
	_outScaleY = float32(_arg2)
	_outDx = float32(_arg3)
	_outDy = float32(_arg4)

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with [func@Gsk.Transform.parse].
//
// This is a wrapper around [method@Gsk.Transform.print].
func (s *Transform) String() string {
	var _arg0 *C.GskTransform // out
	var _cret *C.char         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	_cret = C.gsk_transform_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTranslate converts a `GskTransform` to a translation operation.
//
// @self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (s *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _arg0 *C.GskTransform // out
	var _arg1 C.float         // in
	var _arg2 C.float         // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	C.gsk_transform_to_translate(_arg0, &_arg1, &_arg2)

	var _outDx float32 // out
	var _outDy float32 // out

	_outDx = float32(_arg1)
	_outDy = float32(_arg2)

	return _outDx, _outDy
}

// Transform applies all the operations from @other to @next.
func (n *Transform) Transform(other *Transform) *Transform {
	var _arg0 *C.GskTransform // out
	var _arg1 *C.GskTransform // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(other))

	_cret = C.gsk_transform_transform(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Translate translates @next in 2-dimensional space by @point.
func (n *Transform) Translate(point *graphene.Point) *Transform {
	var _arg0 *C.GskTransform     // out
	var _arg1 *C.graphene_point_t // out
	var _cret *C.GskTransform     // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point))

	_cret = C.gsk_transform_translate(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Translate3D translates @next by @point.
func (n *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _arg0 *C.GskTransform       // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.GskTransform       // in

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point))

	_cret = C.gsk_transform_translate_3d(_arg0, _arg1)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}

// Unref releases a reference on the given `GskTransform`.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Transform) unref() {
	var _arg0 *C.GskTransform // out

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s))

	C.gsk_transform_unref(_arg0)
}
