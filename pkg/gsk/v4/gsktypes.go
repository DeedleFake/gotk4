// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
	})
}

// Transform: the `GskTransform` structure contains only private data.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	if ptr == nil {
		return nil
	}

	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTransform(unsafe.Pointer(b)), nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.GskTransform

	cret = C.gsk_transform_new()

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Equal checks two transforms for equality.
func (f *Transform) Equal(second *Transform) bool {
	var _arg0 *C.GskTransform
	var _arg1 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(second.Native()))

	var _cret C.gboolean

	cret = C.gsk_transform_equal(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Category returns the category this transform belongs to.
func (s *Transform) Category() TransformCategory {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _cret C.GskTransformCategory

	cret = C.gsk_transform_get_category(_arg0)

	var _transformCategory TransformCategory

	_transformCategory = TransformCategory(_cret)

	return _transformCategory
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (s *Transform) Invert() *Transform {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_invert(_arg0)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Matrix multiplies @next with the given @matrix.
func (n *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 *C.graphene_matrix_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_matrix(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Perspective applies a perspective projection transform. This transform scales
// points in X and Y based on their Z value, scaling points with positive Z
// values away from the origin, and those with negative Z values towards the
// origin. Points on the z=0 plane are unchanged.
func (n *Transform) Perspective(depth float32) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 C.float

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = C.float(depth)

	var _cret *C.GskTransform

	cret = C.gsk_transform_perspective(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Print converts @self into a human-readable string representation suitable for
// printing that can later be parsed with gsk_transform_parse().
func (s *Transform) Print(string *glib.String) {
	var _arg0 *C.GskTransform
	var _arg1 *C.GString

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GString)(unsafe.Pointer(string.Native()))

	C.gsk_transform_print(_arg0, _arg1)
}

// Ref acquires a reference on the given Transform.
func (s *Transform) Ref() *Transform {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_ref(_arg0)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))

	return _transform
}

// Rotate rotates @next @angle degrees in 2D - or in 3Dspeak, around the z axis.
func (n *Transform) Rotate(angle float32) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 C.float

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = C.float(angle)

	var _cret *C.GskTransform

	cret = C.gsk_transform_rotate(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use gsk_transform_rotate().
func (n *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 C.float
	var _arg2 *C.graphene_vec3_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_rotate_3d(_arg0, _arg1, _arg2)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale scales @next in 2-dimensional space by the given factors. Use
// gsk_transform_scale_3d() to scale in all 3 dimensions.
func (n *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 C.float
	var _arg2 C.float

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)

	var _cret *C.GskTransform

	cret = C.gsk_transform_scale(_arg0, _arg1, _arg2)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Scale3D scales @next by the given factors.
func (n *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 C.float
	var _arg2 C.float
	var _arg3 C.float

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)
	_arg3 = C.float(factorZ)

	var _cret *C.GskTransform

	cret = C.gsk_transform_scale_3d(_arg0, _arg1, _arg2, _arg3)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// To2D converts a Transform to a 2D transformation matrix. @self must be a 2D
// transformation. If you are not sure, use gsk_transform_get_category() >=
// GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
//    | xx yx |   |  a  b  0 |
//    | xy yy | = |  c  d  0 |
//    | dx dy |   | tx ty  1 |
//
// This function can be used to convert between a Transform and a matrix type
// from other 2D drawing libraries, in particular Cairo.
func (s *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _arg1 C.float
	var _arg2 C.float
	var _arg3 C.float
	var _arg4 C.float
	var _arg5 C.float
	var _arg6 C.float

	C.gsk_transform_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _outXx float32
	var _outYx float32
	var _outXy float32
	var _outYy float32
	var _outDx float32
	var _outDy float32

	_outXx = (float32)(_arg1)
	_outYx = (float32)(_arg2)
	_outXy = (float32)(_arg3)
	_outYy = (float32)(_arg4)
	_outDx = (float32)(_arg5)
	_outDy = (float32)(_arg6)

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a Transform to 2D affine transformation factors. @self must
// be a 2D transformation. If you are not sure, use gsk_transform_get_category()
// >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (s *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _arg1 C.float
	var _arg2 C.float
	var _arg3 C.float
	var _arg4 C.float

	C.gsk_transform_to_affine(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _outScaleX float32
	var _outScaleY float32
	var _outDx float32
	var _outDy float32

	_outScaleX = (float32)(_arg1)
	_outScaleY = (float32)(_arg2)
	_outDx = (float32)(_arg3)
	_outDy = (float32)(_arg4)

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// ToMatrix computes the actual value of @self and stores it in @out_matrix. The
// previous value of @out_matrix will be ignored.
func (s *Transform) ToMatrix() graphene.Matrix {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _outMatrix graphene.Matrix

	C.gsk_transform_to_matrix(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_outMatrix)))

	return _outMatrix
}

// String converts a matrix into a string that is suitable for printing and can
// later be parsed with gsk_transform_parse().
//
// This is a wrapper around gsk_transform_print(), see that function for
// details.
func (s *Transform) String() string {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _cret *C.char

	cret = C.gsk_transform_to_string(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToTranslate converts a Transform to a translation operation. @self must be a
// 2D transformation. If you are not sure, use gsk_transform_get_category() >=
// GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (s *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	var _arg1 C.float
	var _arg2 C.float

	C.gsk_transform_to_translate(_arg0, &_arg1, &_arg2)

	var _outDx float32
	var _outDy float32

	_outDx = (float32)(_arg1)
	_outDy = (float32)(_arg2)

	return _outDx, _outDy
}

// Transform applies all the operations from @other to @next.
func (n *Transform) Transform(other *Transform) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GskTransform)(unsafe.Pointer(other.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_transform(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// TransformBounds transforms a #graphene_rect_t using the given transform
// @self. The result is the bounding box containing the coplanar quad.
func (s *Transform) TransformBounds(rect *graphene.Rect) graphene.Rect {
	var _arg0 *C.GskTransform
	var _arg1 *C.graphene_rect_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(rect.Native()))

	var _outRect graphene.Rect

	C.gsk_transform_transform_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_outRect)))

	return _outRect
}

// TransformPoint transforms a #graphene_point_t using the given transform
// @self.
func (s *Transform) TransformPoint(point *graphene.Point) graphene.Point {
	var _arg0 *C.GskTransform
	var _arg1 *C.graphene_point_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	var _outPoint graphene.Point

	C.gsk_transform_transform_point(_arg0, _arg1, (*C.graphene_point_t)(unsafe.Pointer(&_outPoint)))

	return _outPoint
}

// Translate translates @next in 2dimensional space by @point.
func (n *Transform) Translate(point *graphene.Point) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 *C.graphene_point_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_translate(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Translate3D translates @next by @point.
func (n *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _arg0 *C.GskTransform
	var _arg1 *C.graphene_point3d_t

	_arg0 = (*C.GskTransform)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	var _cret *C.GskTransform

	cret = C.gsk_transform_translate_3d(_arg0, _arg1)

	var _transform *Transform

	_transform = WrapTransform(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _transform
}

// Unref releases a reference on the given Transform.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (s *Transform) Unref() {
	var _arg0 *C.GskTransform

	_arg0 = (*C.GskTransform)(unsafe.Pointer(s.Native()))

	C.gsk_transform_unref(_arg0)
}
