// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNode},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNode},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNode},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNode},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNode},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNode},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNode},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNode},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNode},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNode},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNode},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNode},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNode},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNode},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNode},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNode},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNode},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNode},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNode},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNode},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNode},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNode},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNode},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNode},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNode},
	})
}

// BlendNode: render node applying a blending function between its two child
// nodes.
type BlendNode interface {
	RenderNode

	// BlendMode retrieves the blend mode used by @node.
	BlendMode() BlendMode
	// BottomChild retrieves the bottom `GskRenderNode` child of the @node.
	BottomChild() RenderNode
	// TopChild retrieves the top `GskRenderNode` child of the @node.
	TopChild() RenderNode
}

// blendNode implements the BlendNode class.
type blendNode struct {
	RenderNode
}

// WrapBlendNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlendNode(obj *externglib.Object) BlendNode {
	return blendNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlendNode(obj), nil
}

// NewBlendNode creates a `GskRenderNode` that will use @blend_mode to blend the
// @top node onto the @bottom node.
func NewBlendNode(bottom RenderNode, top RenderNode, blendMode BlendMode) BlendNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.GskBlendMode   // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(bottom.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(top.Native()))
	_arg3 = C.GskBlendMode(blendMode)

	_cret = C.gsk_blend_node_new(_arg1, _arg2, _arg3)

	var _blendNode BlendNode // out

	_blendNode = WrapBlendNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blendNode
}

func (n blendNode) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)

	var _blendMode BlendMode // out

	_blendMode = BlendMode(_cret)

	return _blendMode
}

func (n blendNode) BottomChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n blendNode) TopChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

// BlurNode: render node applying a blur effect to its single child.
type BlurNode interface {
	RenderNode

	// Child retrieves the child `GskRenderNode` of the blur @node.
	Child() RenderNode
	// Radius retrieves the blur radius of the @node.
	Radius() float32
}

// blurNode implements the BlurNode class.
type blurNode struct {
	RenderNode
}

// WrapBlurNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlurNode(obj *externglib.Object) BlurNode {
	return blurNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlurNode(obj), nil
}

// NewBlurNode creates a render node that blurs the child.
func NewBlurNode(child RenderNode, radius float32) BlurNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)

	var _blurNode BlurNode // out

	_blurNode = WrapBlurNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

func (n blurNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n blurNode) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BorderNode: render node for a border.
type BorderNode interface {
	RenderNode

	// Colors retrieves the colors of the border.
	Colors() gdk.RGBA
	// Outline retrieves the outline of the border.
	Outline() RoundedRect
	// Widths retrieves the stroke widths of the border.
	Widths() [4]float32
}

// borderNode implements the BorderNode class.
type borderNode struct {
	RenderNode
}

// WrapBorderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBorderNode(obj *externglib.Object) BorderNode {
	return borderNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBorderNode(obj), nil
}

// NewBorderNode creates a `GskRenderNode` that will stroke a border rectangle
// inside the given @outline.
//
// The 4 sides of the border can have different widths and colors.
func NewBorderNode(outline RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) BorderNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float
	var _arg3 *C.GdkRGBA
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)

	var _borderNode BorderNode // out

	_borderNode = WrapBorderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _borderNode
}

func (n borderNode) Colors() gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)

	var _rgbA gdk.RGBA // out

	_rgbA = (gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

func (n borderNode) Outline() RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)

	var _roundedRect RoundedRect // out

	_roundedRect = (RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n borderNode) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)

	var _gfloats [4]float32

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// CairoNode: render node for a Cairo surface.
type CairoNode interface {
	RenderNode

	// DrawContext creates a Cairo context for drawing using the surface
	// associated to the render node.
	//
	// If no surface exists yet, a surface will be created optimized for
	// rendering to @renderer.
	DrawContext() cairo.Context
	// Surface retrieves the Cairo surface used by the render node.
	Surface() cairo.Surface
}

// cairoNode implements the CairoNode class.
type cairoNode struct {
	RenderNode
}

// WrapCairoNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoNode(obj *externglib.Object) CairoNode {
	return cairoNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoNode(obj), nil
}

// NewCairoNode creates a `GskRenderNode` that will render a cairo surface into
// the area given by @bounds.
//
// You can draw to the cairo surface using
// [method@Gsk.CairoNode.get_draw_context].
func NewCairoNode(bounds graphene.Rect) CairoNode {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_cairo_node_new(_arg1)

	var _cairoNode CairoNode // out

	_cairoNode = WrapCairoNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

func (n cairoNode) DrawContext() cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)

	var _context cairo.Context // out

	_context = (cairo.Context)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_context, func(v cairo.Context) {
		C.free(unsafe.Pointer(v))
	})

	return _context
}

func (n cairoNode) Surface() cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)

	var _surface cairo.Surface // out

	_surface = (cairo.Surface)(unsafe.Pointer(_cret))

	return _surface
}

// ClipNode: render node applying a rectangular clip to its single child node.
type ClipNode interface {
	RenderNode

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrieves the clip rectangle for @node.
	Clip() graphene.Rect
}

// clipNode implements the ClipNode class.
type clipNode struct {
	RenderNode
}

// WrapClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipNode(obj *externglib.Object) ClipNode {
	return clipNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipNode(obj), nil
}

// NewClipNode creates a `GskRenderNode` that will clip the @child to the area
// given by @clip.
func NewClipNode(child RenderNode, clip graphene.Rect) ClipNode {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(clip))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)

	var _clipNode ClipNode // out

	_clipNode = WrapClipNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

func (n clipNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n clipNode) Clip() graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)

	var _rect graphene.Rect // out

	_rect = (graphene.Rect)(unsafe.Pointer(_cret))

	return _rect
}

// ColorMatrixNode: render node controlling the color matrix of its single child
// node.
type ColorMatrixNode interface {
	RenderNode

	// Child gets the child node that is getting its colors modified by the
	// given @node.
	Child() RenderNode
	// ColorMatrix retrieves the color matrix used by the @node.
	ColorMatrix() graphene.Matrix
	// ColorOffset retrieves the color offset used by the @node.
	ColorOffset() graphene.Vec4
}

// colorMatrixNode implements the ColorMatrixNode class.
type colorMatrixNode struct {
	RenderNode
}

// WrapColorMatrixNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorMatrixNode(obj *externglib.Object) ColorMatrixNode {
	return colorMatrixNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorMatrixNode(obj), nil
}

// NewColorMatrixNode creates a `GskRenderNode` that will drawn the @child with
// @color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
func NewColorMatrixNode(child RenderNode, colorMatrix graphene.Matrix, colorOffset graphene.Vec4) ColorMatrixNode {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix))
	_arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)

	var _colorMatrixNode ColorMatrixNode // out

	_colorMatrixNode = WrapColorMatrixNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

func (n colorMatrixNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n colorMatrixNode) ColorMatrix() graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)

	var _matrix graphene.Matrix // out

	_matrix = (graphene.Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

func (n colorMatrixNode) ColorOffset() graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)

	var _vec4 graphene.Vec4 // out

	_vec4 = (graphene.Vec4)(unsafe.Pointer(_cret))

	return _vec4
}

// ColorNode: render node for a solid color.
type ColorNode interface {
	RenderNode

	// Color retrieves the color of the given @node.
	Color() gdk.RGBA
}

// colorNode implements the ColorNode class.
type colorNode struct {
	RenderNode
}

// WrapColorNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorNode(obj *externglib.Object) ColorNode {
	return colorNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorNode(obj), nil
}

// NewColorNode creates a `GskRenderNode` that will render the color specified
// by @rgba into the area given by @bounds.
func NewColorNode(rgba gdk.RGBA, bounds graphene.Rect) ColorNode {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_color_node_new(_arg1, _arg2)

	var _colorNode ColorNode // out

	_colorNode = WrapColorNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

func (n colorNode) Color() gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_node_get_color(_arg0)

	var _rgbA gdk.RGBA // out

	_rgbA = (gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// ConicGradientNode: render node for a conic gradient.
type ConicGradientNode interface {
	RenderNode

	// Angle retrieves the angle for the gradient in radians, normalized in [0,
	// 2 * PI].
	//
	// The angle is starting at the top and going clockwise, as expressed in the
	// css specification:
	//
	//    angle = 90 - gsk_conic_gradient_node_get_rotation()
	Angle() float32
	// Center retrieves the center pointer for the gradient.
	Center() graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Rotation retrieves the rotation for the gradient in degrees.
	Rotation() float32
}

// conicGradientNode implements the ConicGradientNode class.
type conicGradientNode struct {
	RenderNode
}

// WrapConicGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapConicGradientNode(obj *externglib.Object) ConicGradientNode {
	return conicGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConicGradientNode(obj), nil
}

// NewConicGradientNode creates a `GskRenderNode` that draws a conic gradient.
//
// The conic gradient starts around @center in the direction of @rotation. A
// rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
func NewConicGradientNode(bounds graphene.Rect, center graphene.Point, rotation float32, colorStops []ColorStop) ConicGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(rotation)
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _conicGradientNode ConicGradientNode // out

	_conicGradientNode = WrapConicGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _conicGradientNode
}

func (n conicGradientNode) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n conicGradientNode) Center() graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)

	var _point graphene.Point // out

	_point = (graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

func (n conicGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

func (n conicGradientNode) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ContainerNode: render node that can contain other render nodes.
type ContainerNode interface {
	RenderNode

	// Child gets one of the children of @container.
	Child(idx uint) RenderNode
	// NChildren retrieves the number of direct children of @node.
	NChildren() uint
}

// containerNode implements the ContainerNode class.
type containerNode struct {
	RenderNode
}

// WrapContainerNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainerNode(obj *externglib.Object) ContainerNode {
	return containerNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainerNode(obj), nil
}

// NewContainerNode creates a new `GskRenderNode` instance for holding the given
// @children.
//
// The new node will acquire a reference to each of the children.
func NewContainerNode(children []RenderNode) ContainerNode {
	var _arg1 **C.GskRenderNode
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = C.guint(len(children))
	_arg1 = (**C.GskRenderNode)(C.malloc(C.ulong(len(children)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)

	var _containerNode ContainerNode // out

	_containerNode = WrapContainerNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

func (n containerNode) Child(idx uint) RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n containerNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrossFadeNode: render node cross fading between two child nodes.
type CrossFadeNode interface {
	RenderNode

	// EndChild retrieves the child `GskRenderNode` at the end of the
	// cross-fade.
	EndChild() RenderNode
	// Progress retrieves the progress value of the cross fade.
	Progress() float32
	// StartChild retrieves the child `GskRenderNode` at the beginning of the
	// cross-fade.
	StartChild() RenderNode
}

// crossFadeNode implements the CrossFadeNode class.
type crossFadeNode struct {
	RenderNode
}

// WrapCrossFadeNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCrossFadeNode(obj *externglib.Object) CrossFadeNode {
	return crossFadeNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCrossFadeNode(obj), nil
}

// NewCrossFadeNode creates a `GskRenderNode` that will do a cross-fade between
// @start and @end.
func NewCrossFadeNode(start RenderNode, end RenderNode, progress float32) CrossFadeNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(end.Native()))
	_arg3 = C.float(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)

	var _crossFadeNode CrossFadeNode // out

	_crossFadeNode = WrapCrossFadeNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

func (n crossFadeNode) EndChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n crossFadeNode) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n crossFadeNode) StartChild() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

// DebugNode: render node that emits a debugging message when drawing its child
// node.
type DebugNode interface {
	RenderNode

	// Child gets the child node that is getting drawn by the given @node.
	Child() RenderNode
	// Message gets the debug message that was set on this node
	Message() string
}

// debugNode implements the DebugNode class.
type debugNode struct {
	RenderNode
}

// WrapDebugNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapDebugNode(obj *externglib.Object) DebugNode {
	return debugNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDebugNode(obj), nil
}

// NewDebugNode creates a `GskRenderNode` that will add debug information about
// the given @child.
//
// Adding this node has no visual effect.
func NewDebugNode(child RenderNode, message string) DebugNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(message))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)

	var _debugNode DebugNode // out

	_debugNode = WrapDebugNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

func (n debugNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n debugNode) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GLShaderNode: render node using a GL shader when drawing its children nodes.
type GLShaderNode interface {
	RenderNode

	// Child gets one of the children.
	Child(idx uint) RenderNode
	// NChildren returns the number of children
	NChildren() uint
	// Shader gets shader code for the node.
	Shader() GLShader
}

// glShaderNode implements the GLShaderNode class.
type glShaderNode struct {
	RenderNode
}

// WrapGLShaderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShaderNode(obj *externglib.Object) GLShaderNode {
	return glShaderNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShaderNode(obj), nil
}

func (n glShaderNode) Child(idx uint) RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n glShaderNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (n glShaderNode) Shader() GLShader {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)

	var _glShader GLShader // out

	_glShader = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(GLShader)

	return _glShader
}

// InsetShadowNode: render node for an inset shadow.
type InsetShadowNode interface {
	RenderNode

	// BlurRadius retrieves the blur radius to apply to the shadow.
	BlurRadius() float32
	// Color retrieves the color of the inset shadow.
	Color() gdk.RGBA
	// Dx retrieves the horizontal offset of the inset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the inset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the inset shadow.
	Outline() RoundedRect
	// Spread retrieves how much the shadow spreads inwards.
	Spread() float32
}

// insetShadowNode implements the InsetShadowNode class.
type insetShadowNode struct {
	RenderNode
}

// WrapInsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapInsetShadowNode(obj *externglib.Object) InsetShadowNode {
	return insetShadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInsetShadowNode(obj), nil
}

// NewInsetShadowNode creates a `GskRenderNode` that will render an inset shadow
// into the box given by @outline.
func NewInsetShadowNode(outline RoundedRect, color gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) InsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _insetShadowNode InsetShadowNode // out

	_insetShadowNode = WrapInsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

func (n insetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n insetShadowNode) Color() gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)

	var _rgbA gdk.RGBA // out

	_rgbA = (gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

func (n insetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n insetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n insetShadowNode) Outline() RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)

	var _roundedRect RoundedRect // out

	_roundedRect = (RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n insetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// LinearGradientNode: render node for a linear gradient.
type LinearGradientNode interface {
	RenderNode

	// End retrieves the final point of the linear gradient.
	End() graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the initial point of the linear gradient.
	Start() graphene.Point
}

// linearGradientNode implements the LinearGradientNode class.
type linearGradientNode struct {
	RenderNode
}

// WrapLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinearGradientNode(obj *externglib.Object) LinearGradientNode {
	return linearGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinearGradientNode(obj), nil
}

// NewLinearGradientNode creates a `GskRenderNode` that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by @bounds.
func NewLinearGradientNode(bounds graphene.Rect, start graphene.Point, end graphene.Point, colorStops []ColorStop) LinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _linearGradientNode LinearGradientNode // out

	_linearGradientNode = WrapLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _linearGradientNode
}

func (n linearGradientNode) End() graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)

	var _point graphene.Point // out

	_point = (graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

func (n linearGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

func (n linearGradientNode) Start() graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)

	var _point graphene.Point // out

	_point = (graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// OpacityNode: render node controlling the opacity of its single child node.
type OpacityNode interface {
	RenderNode

	// Child gets the child node that is getting opacityed by the given @node.
	Child() RenderNode
	// Opacity gets the transparency factor for an opacity node.
	Opacity() float32
}

// opacityNode implements the OpacityNode class.
type opacityNode struct {
	RenderNode
}

// WrapOpacityNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOpacityNode(obj *externglib.Object) OpacityNode {
	return opacityNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOpacityNode(obj), nil
}

// NewOpacityNode creates a `GskRenderNode` that will drawn the @child with
// reduced @opacity.
func NewOpacityNode(child RenderNode, opacity float32) OpacityNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)

	var _opacityNode OpacityNode // out

	_opacityNode = WrapOpacityNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

func (n opacityNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n opacityNode) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// OutsetShadowNode: render node for an outset shadow.
type OutsetShadowNode interface {
	RenderNode

	// BlurRadius retrieves the blur radius of the shadow.
	BlurRadius() float32
	// Color retrieves the color of the outset shadow.
	Color() gdk.RGBA
	// Dx retrieves the horizontal offset of the outset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the outset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the outset shadow.
	Outline() RoundedRect
	// Spread retrieves how much the shadow spreads outwards.
	Spread() float32
}

// outsetShadowNode implements the OutsetShadowNode class.
type outsetShadowNode struct {
	RenderNode
}

// WrapOutsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutsetShadowNode(obj *externglib.Object) OutsetShadowNode {
	return outsetShadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutsetShadowNode(obj), nil
}

// NewOutsetShadowNode creates a `GskRenderNode` that will render an outset
// shadow around the box given by @outline.
func NewOutsetShadowNode(outline RoundedRect, color gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) OutsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _outsetShadowNode OutsetShadowNode // out

	_outsetShadowNode = WrapOutsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

func (n outsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n outsetShadowNode) Color() gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)

	var _rgbA gdk.RGBA // out

	_rgbA = (gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

func (n outsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n outsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n outsetShadowNode) Outline() RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)

	var _roundedRect RoundedRect // out

	_roundedRect = (RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

func (n outsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RadialGradientNode: render node for a radial gradient.
type RadialGradientNode interface {
	RenderNode

	// Center retrieves the center pointer for the gradient.
	Center() graphene.Point
	// End retrieves the end value for the gradient.
	End() float32
	// Hradius retrieves the horizonal radius for the gradient.
	Hradius() float32
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the start value for the gradient.
	Start() float32
	// Vradius retrieves the vertical radius for the gradient.
	Vradius() float32
}

// radialGradientNode implements the RadialGradientNode class.
type radialGradientNode struct {
	RenderNode
}

// WrapRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadialGradientNode(obj *externglib.Object) RadialGradientNode {
	return radialGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadialGradientNode(obj), nil
}

// NewRadialGradientNode creates a `GskRenderNode` that draws a radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRadialGradientNode(bounds graphene.Rect, center graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _radialGradientNode RadialGradientNode // out

	_radialGradientNode = WrapRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radialGradientNode
}

func (n radialGradientNode) Center() graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)

	var _point graphene.Point // out

	_point = (graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

func (n radialGradientNode) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n radialGradientNode) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n radialGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

func (n radialGradientNode) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

func (n radialGradientNode) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RepeatNode: render node repeating its single child node.
type RepeatNode interface {
	RenderNode

	// Child retrieves the child of @node.
	Child() RenderNode
	// ChildBounds retrieves the bounding rectangle of the child of @node.
	ChildBounds() graphene.Rect
}

// repeatNode implements the RepeatNode class.
type repeatNode struct {
	RenderNode
}

// WrapRepeatNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatNode(obj *externglib.Object) RepeatNode {
	return repeatNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatNode(obj), nil
}

// NewRepeatNode creates a `GskRenderNode` that will repeat the drawing of
// @child across the given @bounds.
func NewRepeatNode(bounds graphene.Rect, child RenderNode, childBounds graphene.Rect) RepeatNode {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds))

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)

	var _repeatNode RepeatNode // out

	_repeatNode = WrapRepeatNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

func (n repeatNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n repeatNode) ChildBounds() graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)

	var _rect graphene.Rect // out

	_rect = (graphene.Rect)(unsafe.Pointer(_cret))

	return _rect
}

// RepeatingLinearGradientNode: render node for a repeating linear gradient.
type RepeatingLinearGradientNode interface {
	RenderNode
}

// repeatingLinearGradientNode implements the RepeatingLinearGradientNode class.
type repeatingLinearGradientNode struct {
	RenderNode
}

// WrapRepeatingLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingLinearGradientNode(obj *externglib.Object) RepeatingLinearGradientNode {
	return repeatingLinearGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingLinearGradientNode(obj), nil
}

// NewRepeatingLinearGradientNode creates a `GskRenderNode` that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by @bounds.
func NewRepeatingLinearGradientNode(bounds graphene.Rect, start graphene.Point, end graphene.Point, colorStops []ColorStop) RepeatingLinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _repeatingLinearGradientNode RepeatingLinearGradientNode // out

	_repeatingLinearGradientNode = WrapRepeatingLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingLinearGradientNode
}

// RepeatingRadialGradientNode: render node for a repeating radial gradient.
type RepeatingRadialGradientNode interface {
	RenderNode
}

// repeatingRadialGradientNode implements the RepeatingRadialGradientNode class.
type repeatingRadialGradientNode struct {
	RenderNode
}

// WrapRepeatingRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingRadialGradientNode(obj *externglib.Object) RepeatingRadialGradientNode {
	return repeatingRadialGradientNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingRadialGradientNode(obj), nil
}

// NewRepeatingRadialGradientNode creates a `GskRenderNode` that draws a
// repeating radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRepeatingRadialGradientNode(bounds graphene.Rect, center graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RepeatingRadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _repeatingRadialGradientNode RepeatingRadialGradientNode // out

	_repeatingRadialGradientNode = WrapRepeatingRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingRadialGradientNode
}

// RoundedClipNode: render node applying a rounded rectangle clip to its single
// child.
type RoundedClipNode interface {
	RenderNode

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrieves the rounded rectangle used to clip the contents of the
	// @node.
	Clip() RoundedRect
}

// roundedClipNode implements the RoundedClipNode class.
type roundedClipNode struct {
	RenderNode
}

// WrapRoundedClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRoundedClipNode(obj *externglib.Object) RoundedClipNode {
	return roundedClipNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRoundedClipNode(obj), nil
}

// NewRoundedClipNode creates a `GskRenderNode` that will clip the @child to the
// area given by @clip.
func NewRoundedClipNode(child RenderNode, clip RoundedRect) RoundedClipNode {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskRoundedRect)(unsafe.Pointer(clip))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)

	var _roundedClipNode RoundedClipNode // out

	_roundedClipNode = WrapRoundedClipNode(externglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

func (n roundedClipNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n roundedClipNode) Clip() RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)

	var _roundedRect RoundedRect // out

	_roundedRect = (RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

// ShadowNode: render node drawing one or more shadows behind its single child
// node.
type ShadowNode interface {
	RenderNode

	// Child retrieves the child `GskRenderNode` of the shadow @node.
	Child() RenderNode
	// NShadows retrieves the number of shadows in the @node.
	NShadows() uint
	// Shadow retrieves the shadow data at the given index @i.
	Shadow(i uint) Shadow
}

// shadowNode implements the ShadowNode class.
type shadowNode struct {
	RenderNode
}

// WrapShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapShadowNode(obj *externglib.Object) ShadowNode {
	return shadowNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShadowNode(obj), nil
}

// NewShadowNode creates a `GskRenderNode` that will draw a @child with the
// given @shadows below it.
func NewShadowNode(child RenderNode, shadows []Shadow) ShadowNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = C.gsize(len(shadows))
	_arg2 = (*C.GskShadow)(unsafe.Pointer(&shadows[0]))

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)

	var _shadowNode ShadowNode // out

	_shadowNode = WrapShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shadowNode
}

func (n shadowNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n shadowNode) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

func (n shadowNode) Shadow(i uint) Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.gsize(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)

	var _shadow Shadow // out

	_shadow = (Shadow)(unsafe.Pointer(_cret))

	return _shadow
}

// TextNode: render node drawing a set of glyphs.
type TextNode interface {
	RenderNode

	// Color retrieves the color used by the text @node.
	Color() gdk.RGBA
	// Font returns the font used by the text @node.
	Font() pango.Font
	// NumGlyphs retrieves the number of glyphs in the text node.
	NumGlyphs() uint
	// Offset retrieves the offset applied to the text.
	Offset() graphene.Point
	// HasColorGlyphsTextNode checks whether the text @node has color glyphs.
	HasColorGlyphsTextNode() bool
}

// textNode implements the TextNode class.
type textNode struct {
	RenderNode
}

// WrapTextNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextNode(obj *externglib.Object) TextNode {
	return textNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextNode(obj), nil
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that @color may not be used if the font contains color glyphs.
func NewTextNode(font pango.Font, glyphs pango.GlyphString, color gdk.RGBA, offset graphene.Point) TextNode {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg4 = (*C.graphene_point_t)(unsafe.Pointer(offset))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)

	var _textNode TextNode // out

	_textNode = WrapTextNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textNode
}

func (n textNode) Color() gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_color(_arg0)

	var _rgbA gdk.RGBA // out

	_rgbA = (gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

func (n textNode) Font() pango.Font {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_font(_arg0)

	var _font pango.Font // out

	_font = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Font)

	return _font
}

func (n textNode) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (n textNode) Offset() graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)

	var _point graphene.Point // out

	_point = (graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

func (n textNode) HasColorGlyphsTextNode() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextureNode: render node for a Texture.
type TextureNode interface {
	RenderNode

	// Texture retrieves the `GdkTexture` used when creating this
	// `GskRenderNode`.
	Texture() gdk.Texture
}

// textureNode implements the TextureNode class.
type textureNode struct {
	RenderNode
}

// WrapTextureNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextureNode(obj *externglib.Object) TextureNode {
	return textureNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextureNode(obj), nil
}

// NewTextureNode creates a `GskRenderNode` that will render the given @texture
// into the area given by @bounds.
func NewTextureNode(texture gdk.Texture, bounds graphene.Rect) TextureNode {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)

	var _textureNode TextureNode // out

	_textureNode = WrapTextureNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

func (n textureNode) Texture() gdk.Texture {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)

	var _texture gdk.Texture // out

	_texture = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Texture)

	return _texture
}

// TransformNode: render node applying a `GskTransform` to its single child
// node.
type TransformNode interface {
	RenderNode

	// Child gets the child node that is getting transformed by the given @node.
	Child() RenderNode
	// Transform retrieves the `GskTransform` used by the @node.
	Transform() Transform
}

// transformNode implements the TransformNode class.
type transformNode struct {
	RenderNode
}

// WrapTransformNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTransformNode(obj *externglib.Object) TransformNode {
	return transformNode{
		RenderNode: WrapRenderNode(obj),
	}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTransformNode(obj), nil
}

// NewTransformNode creates a `GskRenderNode` that will transform the given
// @child with the given @transform.
func NewTransformNode(child RenderNode, transform Transform) TransformNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskTransform)(unsafe.Pointer(transform))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)

	var _transformNode TransformNode // out

	_transformNode = WrapTransformNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

func (n transformNode) Child() RenderNode {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)

	var _renderNode RenderNode // out

	_renderNode = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(RenderNode)

	return _renderNode
}

func (n transformNode) Transform() Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)

	var _transform Transform // out

	_transform = (Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)

	return _transform
}
