// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNode},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNode},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNode},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNode},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNode},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNode},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNode},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNode},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNode},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNode},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNode},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNode},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNode},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNode},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNode},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNode},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNode},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNode},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNode},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNode},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNode},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNode},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNode},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNode},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNode},
	})
}

// BlendNode: render node applying a blending function between its two child
// nodes.
type BlendNode interface {
	gextras.Objector

	// BlendMode retrieves the blend mode used by @node.
	BlendMode() BlendMode
	// BottomChild retrieves the bottom `GskRenderNode` child of the @node.
	BottomChild() *RenderNodeClass
	// TopChild retrieves the top `GskRenderNode` child of the @node.
	TopChild() *RenderNodeClass
}

// BlendNodeClass implements the BlendNode interface.
type BlendNodeClass struct {
	RenderNodeClass
}

var _ BlendNode = (*BlendNodeClass)(nil)

func wrapBlendNode(obj *externglib.Object) BlendNode {
	return &BlendNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBlendNode(obj), nil
}

// BlendMode retrieves the blend mode used by @node.
func (n *BlendNodeClass) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)

	var _blendMode BlendMode // out

	_blendMode = (BlendMode)(_cret)

	return _blendMode
}

// BottomChild retrieves the bottom `GskRenderNode` child of the @node.
func (n *BlendNodeClass) BottomChild() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// TopChild retrieves the top `GskRenderNode` child of the @node.
func (n *BlendNodeClass) TopChild() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// BlurNode: render node applying a blur effect to its single child.
type BlurNode interface {
	gextras.Objector

	// Child retrieves the child `GskRenderNode` of the blur @node.
	Child() *RenderNodeClass
	// Radius retrieves the blur radius of the @node.
	Radius() float32
}

// BlurNodeClass implements the BlurNode interface.
type BlurNodeClass struct {
	RenderNodeClass
}

var _ BlurNode = (*BlurNodeClass)(nil)

func wrapBlurNode(obj *externglib.Object) BlurNode {
	return &BlurNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBlurNode(obj), nil
}

// NewBlurNode creates a render node that blurs the child.
func NewBlurNode(child RenderNode, radius float32) *BlurNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)

	var _blurNode *BlurNodeClass // out

	_blurNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*BlurNodeClass)

	return _blurNode
}

// Child retrieves the child `GskRenderNode` of the blur @node.
func (n *BlurNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Radius retrieves the blur radius of the @node.
func (n *BlurNodeClass) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BorderNode: render node for a border.
type BorderNode interface {
	gextras.Objector

	// Colors retrieves the colors of the border.
	Colors() *gdk.RGBA
	// Outline retrieves the outline of the border.
	Outline() *RoundedRect
	// Widths retrieves the stroke widths of the border.
	Widths() [4]float32
}

// BorderNodeClass implements the BorderNode interface.
type BorderNodeClass struct {
	RenderNodeClass
}

var _ BorderNode = (*BorderNodeClass)(nil)

func wrapBorderNode(obj *externglib.Object) BorderNode {
	return &BorderNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBorderNode(obj), nil
}

// NewBorderNode creates a `GskRenderNode` that will stroke a border rectangle
// inside the given @outline.
//
// The 4 sides of the border can have different widths and colors.
func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) *BorderNodeClass {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float
	var _arg3 *C.GdkRGBA
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)

	var _borderNode *BorderNodeClass // out

	_borderNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*BorderNodeClass)

	return _borderNode
}

// Colors retrieves the colors of the border.
func (n *BorderNodeClass) Colors() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// Outline retrieves the outline of the border.
func (n *BorderNodeClass) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
func (n *BorderNodeClass) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)

	var _gfloats [4]float32

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// CairoNode: render node for a Cairo surface.
type CairoNode interface {
	gextras.Objector

	// DrawContext creates a Cairo context for drawing using the surface
	// associated to the render node.
	//
	// If no surface exists yet, a surface will be created optimized for
	// rendering to @renderer.
	DrawContext() *cairo.Context
	// Surface retrieves the Cairo surface used by the render node.
	Surface() *cairo.Surface
}

// CairoNodeClass implements the CairoNode interface.
type CairoNodeClass struct {
	RenderNodeClass
}

var _ CairoNode = (*CairoNodeClass)(nil)

func wrapCairoNode(obj *externglib.Object) CairoNode {
	return &CairoNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCairoNode(obj), nil
}

// NewCairoNode creates a `GskRenderNode` that will render a cairo surface into
// the area given by @bounds.
//
// You can draw to the cairo surface using
// [method@Gsk.CairoNode.get_draw_context].
func NewCairoNode(bounds *graphene.Rect) *CairoNodeClass {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_cairo_node_new(_arg1)

	var _cairoNode *CairoNodeClass // out

	_cairoNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*CairoNodeClass)

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to @renderer.
func (n *CairoNodeClass) DrawContext() *cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)

	var _context *cairo.Context // out

	_context = (*cairo.Context)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.free(unsafe.Pointer(v))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
func (n *CairoNodeClass) Surface() *cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)

	var _surface *cairo.Surface // out

	_surface = (*cairo.Surface)(unsafe.Pointer(_cret))

	return _surface
}

// ClipNode: render node applying a rectangular clip to its single child node.
type ClipNode interface {
	gextras.Objector

	// Child gets the child node that is getting clipped by the given @node.
	Child() *RenderNodeClass
	// Clip retrieves the clip rectangle for @node.
	Clip() *graphene.Rect
}

// ClipNodeClass implements the ClipNode interface.
type ClipNodeClass struct {
	RenderNodeClass
}

var _ ClipNode = (*ClipNodeClass)(nil)

func wrapClipNode(obj *externglib.Object) ClipNode {
	return &ClipNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapClipNode(obj), nil
}

// NewClipNode creates a `GskRenderNode` that will clip the @child to the area
// given by @clip.
func NewClipNode(child RenderNode, clip *graphene.Rect) *ClipNodeClass {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(clip))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)

	var _clipNode *ClipNodeClass // out

	_clipNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ClipNodeClass)

	return _clipNode
}

// Child gets the child node that is getting clipped by the given @node.
func (n *ClipNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Clip retrieves the clip rectangle for @node.
func (n *ClipNodeClass) Clip() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(unsafe.Pointer(_cret))

	return _rect
}

// ColorMatrixNode: render node controlling the color matrix of its single child
// node.
type ColorMatrixNode interface {
	gextras.Objector

	// Child gets the child node that is getting its colors modified by the
	// given @node.
	Child() *RenderNodeClass
	// ColorMatrix retrieves the color matrix used by the @node.
	ColorMatrix() *graphene.Matrix
	// ColorOffset retrieves the color offset used by the @node.
	ColorOffset() *graphene.Vec4
}

// ColorMatrixNodeClass implements the ColorMatrixNode interface.
type ColorMatrixNodeClass struct {
	RenderNodeClass
}

var _ ColorMatrixNode = (*ColorMatrixNodeClass)(nil)

func wrapColorMatrixNode(obj *externglib.Object) ColorMatrixNode {
	return &ColorMatrixNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapColorMatrixNode(obj), nil
}

// NewColorMatrixNode creates a `GskRenderNode` that will drawn the @child with
// @color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
func NewColorMatrixNode(child RenderNode, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNodeClass {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix))
	_arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)

	var _colorMatrixNode *ColorMatrixNodeClass // out

	_colorMatrixNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ColorMatrixNodeClass)

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// @node.
func (n *ColorMatrixNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the @node.
func (n *ColorMatrixNodeClass) ColorMatrix() *graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// ColorOffset retrieves the color offset used by the @node.
func (n *ColorMatrixNodeClass) ColorOffset() *graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(unsafe.Pointer(_cret))

	return _vec4
}

// ColorNode: render node for a solid color.
type ColorNode interface {
	gextras.Objector

	// Color retrieves the color of the given @node.
	Color() *gdk.RGBA
}

// ColorNodeClass implements the ColorNode interface.
type ColorNodeClass struct {
	RenderNodeClass
}

var _ ColorNode = (*ColorNodeClass)(nil)

func wrapColorNode(obj *externglib.Object) ColorNode {
	return &ColorNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapColorNode(obj), nil
}

// NewColorNode creates a `GskRenderNode` that will render the color specified
// by @rgba into the area given by @bounds.
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNodeClass {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_color_node_new(_arg1, _arg2)

	var _colorNode *ColorNodeClass // out

	_colorNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ColorNodeClass)

	return _colorNode
}

// Color retrieves the color of the given @node.
func (n *ColorNodeClass) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_color_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// ConicGradientNode: render node for a conic gradient.
type ConicGradientNode interface {
	gextras.Objector

	// Angle retrieves the angle for the gradient in radians, normalized in [0,
	// 2 * PI].
	//
	// The angle is starting at the top and going clockwise, as expressed in the
	// css specification:
	//
	//    angle = 90 - gsk_conic_gradient_node_get_rotation()
	Angle() float32
	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Rotation retrieves the rotation for the gradient in degrees.
	Rotation() float32
}

// ConicGradientNodeClass implements the ConicGradientNode interface.
type ConicGradientNodeClass struct {
	RenderNodeClass
}

var _ ConicGradientNode = (*ConicGradientNodeClass)(nil)

func wrapConicGradientNode(obj *externglib.Object) ConicGradientNode {
	return &ConicGradientNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapConicGradientNode(obj), nil
}

// NewConicGradientNode creates a `GskRenderNode` that draws a conic gradient.
//
// The conic gradient starts around @center in the direction of @rotation. A
// rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) *ConicGradientNodeClass {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(rotation)
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _conicGradientNode *ConicGradientNodeClass // out

	_conicGradientNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ConicGradientNodeClass)

	return _conicGradientNode
}

// Angle retrieves the angle for the gradient in radians, normalized in [0, 2 *
// PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation()
func (n *ConicGradientNodeClass) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
func (n *ConicGradientNodeClass) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
func (n *ConicGradientNodeClass) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
func (n *ConicGradientNodeClass) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ContainerNode: render node that can contain other render nodes.
type ContainerNode interface {
	gextras.Objector

	// Child gets one of the children of @container.
	Child(idx uint) *RenderNodeClass
	// NChildren retrieves the number of direct children of @node.
	NChildren() uint
}

// ContainerNodeClass implements the ContainerNode interface.
type ContainerNodeClass struct {
	RenderNodeClass
}

var _ ContainerNode = (*ContainerNodeClass)(nil)

func wrapContainerNode(obj *externglib.Object) ContainerNode {
	return &ContainerNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapContainerNode(obj), nil
}

// NewContainerNode creates a new `GskRenderNode` instance for holding the given
// @children.
//
// The new node will acquire a reference to each of the children.
func NewContainerNode(children []*RenderNodeClass) *ContainerNodeClass {
	var _arg1 **C.GskRenderNode
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = C.guint(len(children))
	_arg1 = (**C.GskRenderNode)(C.malloc(C.ulong(len(children)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)

	var _containerNode *ContainerNodeClass // out

	_containerNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ContainerNodeClass)

	return _containerNode
}

// Child gets one of the children of @container.
func (n *ContainerNodeClass) Child(idx uint) *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// NChildren retrieves the number of direct children of @node.
func (n *ContainerNodeClass) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrossFadeNode: render node cross fading between two child nodes.
type CrossFadeNode interface {
	gextras.Objector

	// EndChild retrieves the child `GskRenderNode` at the end of the
	// cross-fade.
	EndChild() *RenderNodeClass
	// Progress retrieves the progress value of the cross fade.
	Progress() float32
	// StartChild retrieves the child `GskRenderNode` at the beginning of the
	// cross-fade.
	StartChild() *RenderNodeClass
}

// CrossFadeNodeClass implements the CrossFadeNode interface.
type CrossFadeNodeClass struct {
	RenderNodeClass
}

var _ CrossFadeNode = (*CrossFadeNodeClass)(nil)

func wrapCrossFadeNode(obj *externglib.Object) CrossFadeNode {
	return &CrossFadeNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCrossFadeNode(obj), nil
}

// NewCrossFadeNode creates a `GskRenderNode` that will do a cross-fade between
// @start and @end.
func NewCrossFadeNode(start RenderNode, end RenderNode, progress float32) *CrossFadeNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(end.Native()))
	_arg3 = C.float(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)

	var _crossFadeNode *CrossFadeNodeClass // out

	_crossFadeNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*CrossFadeNodeClass)

	return _crossFadeNode
}

// EndChild retrieves the child `GskRenderNode` at the end of the cross-fade.
func (n *CrossFadeNodeClass) EndChild() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
func (n *CrossFadeNodeClass) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// StartChild retrieves the child `GskRenderNode` at the beginning of the
// cross-fade.
func (n *CrossFadeNodeClass) StartChild() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// DebugNode: render node that emits a debugging message when drawing its child
// node.
type DebugNode interface {
	gextras.Objector

	// Child gets the child node that is getting drawn by the given @node.
	Child() *RenderNodeClass
	// Message gets the debug message that was set on this node
	Message() string
}

// DebugNodeClass implements the DebugNode interface.
type DebugNodeClass struct {
	RenderNodeClass
}

var _ DebugNode = (*DebugNodeClass)(nil)

func wrapDebugNode(obj *externglib.Object) DebugNode {
	return &DebugNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDebugNode(obj), nil
}

// NewDebugNode creates a `GskRenderNode` that will add debug information about
// the given @child.
//
// Adding this node has no visual effect.
func NewDebugNode(child RenderNode, message string) *DebugNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(C.CString(message))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)

	var _debugNode *DebugNodeClass // out

	_debugNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*DebugNodeClass)

	return _debugNode
}

// Child gets the child node that is getting drawn by the given @node.
func (n *DebugNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Message gets the debug message that was set on this node
func (n *DebugNodeClass) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// GLShaderNode: render node using a GL shader when drawing its children nodes.
type GLShaderNode interface {
	gextras.Objector

	// Child gets one of the children.
	Child(idx uint) *RenderNodeClass
	// NChildren returns the number of children
	NChildren() uint
	// Shader gets shader code for the node.
	Shader() *GLShaderClass
}

// GLShaderNodeClass implements the GLShaderNode interface.
type GLShaderNodeClass struct {
	RenderNodeClass
}

var _ GLShaderNode = (*GLShaderNodeClass)(nil)

func wrapGLShaderNode(obj *externglib.Object) GLShaderNode {
	return &GLShaderNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapGLShaderNode(obj), nil
}

// Child gets one of the children.
func (n *GLShaderNodeClass) Child(idx uint) *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// NChildren returns the number of children
func (n *GLShaderNodeClass) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Shader gets shader code for the node.
func (n *GLShaderNodeClass) Shader() *GLShaderClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)

	var _glShader *GLShaderClass // out

	_glShader = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*GLShaderClass)

	return _glShader
}

// InsetShadowNode: render node for an inset shadow.
type InsetShadowNode interface {
	gextras.Objector

	// BlurRadius retrieves the blur radius to apply to the shadow.
	BlurRadius() float32
	// Color retrieves the color of the inset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the inset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the inset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the inset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads inwards.
	Spread() float32
}

// InsetShadowNodeClass implements the InsetShadowNode interface.
type InsetShadowNodeClass struct {
	RenderNodeClass
}

var _ InsetShadowNode = (*InsetShadowNodeClass)(nil)

func wrapInsetShadowNode(obj *externglib.Object) InsetShadowNode {
	return &InsetShadowNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapInsetShadowNode(obj), nil
}

// NewInsetShadowNode creates a `GskRenderNode` that will render an inset shadow
// into the box given by @outline.
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) *InsetShadowNodeClass {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _insetShadowNode *InsetShadowNodeClass // out

	_insetShadowNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*InsetShadowNodeClass)

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
func (n *InsetShadowNodeClass) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the inset shadow.
func (n *InsetShadowNodeClass) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
func (n *InsetShadowNodeClass) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
func (n *InsetShadowNodeClass) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
func (n *InsetShadowNodeClass) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
func (n *InsetShadowNodeClass) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// LinearGradientNode: render node for a linear gradient.
type LinearGradientNode interface {
	gextras.Objector

	// End retrieves the final point of the linear gradient.
	End() *graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the initial point of the linear gradient.
	Start() *graphene.Point
}

// LinearGradientNodeClass implements the LinearGradientNode interface.
type LinearGradientNodeClass struct {
	RenderNodeClass
}

var _ LinearGradientNode = (*LinearGradientNodeClass)(nil)

func wrapLinearGradientNode(obj *externglib.Object) LinearGradientNode {
	return &LinearGradientNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapLinearGradientNode(obj), nil
}

// NewLinearGradientNode creates a `GskRenderNode` that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by @bounds.
func NewLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) *LinearGradientNodeClass {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _linearGradientNode *LinearGradientNodeClass // out

	_linearGradientNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*LinearGradientNodeClass)

	return _linearGradientNode
}

// End retrieves the final point of the linear gradient.
func (n *LinearGradientNodeClass) End() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
func (n *LinearGradientNodeClass) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
func (n *LinearGradientNodeClass) Start() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// OpacityNode: render node controlling the opacity of its single child node.
type OpacityNode interface {
	gextras.Objector

	// Child gets the child node that is getting opacityed by the given @node.
	Child() *RenderNodeClass
	// Opacity gets the transparency factor for an opacity node.
	Opacity() float32
}

// OpacityNodeClass implements the OpacityNode interface.
type OpacityNodeClass struct {
	RenderNodeClass
}

var _ OpacityNode = (*OpacityNodeClass)(nil)

func wrapOpacityNode(obj *externglib.Object) OpacityNode {
	return &OpacityNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapOpacityNode(obj), nil
}

// NewOpacityNode creates a `GskRenderNode` that will drawn the @child with
// reduced @opacity.
func NewOpacityNode(child RenderNode, opacity float32) *OpacityNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)

	var _opacityNode *OpacityNodeClass // out

	_opacityNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*OpacityNodeClass)

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given @node.
func (n *OpacityNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
func (n *OpacityNodeClass) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// OutsetShadowNode: render node for an outset shadow.
type OutsetShadowNode interface {
	gextras.Objector

	// BlurRadius retrieves the blur radius of the shadow.
	BlurRadius() float32
	// Color retrieves the color of the outset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the outset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the outset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the outset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads outwards.
	Spread() float32
}

// OutsetShadowNodeClass implements the OutsetShadowNode interface.
type OutsetShadowNodeClass struct {
	RenderNodeClass
}

var _ OutsetShadowNode = (*OutsetShadowNodeClass)(nil)

func wrapOutsetShadowNode(obj *externglib.Object) OutsetShadowNode {
	return &OutsetShadowNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapOutsetShadowNode(obj), nil
}

// NewOutsetShadowNode creates a `GskRenderNode` that will render an outset
// shadow around the box given by @outline.
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) *OutsetShadowNodeClass {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _outsetShadowNode *OutsetShadowNodeClass // out

	_outsetShadowNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*OutsetShadowNodeClass)

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
func (n *OutsetShadowNodeClass) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the outset shadow.
func (n *OutsetShadowNodeClass) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
func (n *OutsetShadowNodeClass) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
func (n *OutsetShadowNodeClass) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
func (n *OutsetShadowNodeClass) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
func (n *OutsetShadowNodeClass) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RadialGradientNode: render node for a radial gradient.
type RadialGradientNode interface {
	gextras.Objector

	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// End retrieves the end value for the gradient.
	End() float32
	// Hradius retrieves the horizonal radius for the gradient.
	Hradius() float32
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the start value for the gradient.
	Start() float32
	// Vradius retrieves the vertical radius for the gradient.
	Vradius() float32
}

// RadialGradientNodeClass implements the RadialGradientNode interface.
type RadialGradientNodeClass struct {
	RenderNodeClass
}

var _ RadialGradientNode = (*RadialGradientNodeClass)(nil)

func wrapRadialGradientNode(obj *externglib.Object) RadialGradientNode {
	return &RadialGradientNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRadialGradientNode(obj), nil
}

// NewRadialGradientNode creates a `GskRenderNode` that draws a radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) *RadialGradientNodeClass {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _radialGradientNode *RadialGradientNodeClass // out

	_radialGradientNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*RadialGradientNodeClass)

	return _radialGradientNode
}

// Center retrieves the center pointer for the gradient.
func (n *RadialGradientNodeClass) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// End retrieves the end value for the gradient.
func (n *RadialGradientNodeClass) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
func (n *RadialGradientNodeClass) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
func (n *RadialGradientNodeClass) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the start value for the gradient.
func (n *RadialGradientNodeClass) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
func (n *RadialGradientNodeClass) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RepeatNode: render node repeating its single child node.
type RepeatNode interface {
	gextras.Objector

	// Child retrieves the child of @node.
	Child() *RenderNodeClass
	// ChildBounds retrieves the bounding rectangle of the child of @node.
	ChildBounds() *graphene.Rect
}

// RepeatNodeClass implements the RepeatNode interface.
type RepeatNodeClass struct {
	RenderNodeClass
}

var _ RepeatNode = (*RepeatNodeClass)(nil)

func wrapRepeatNode(obj *externglib.Object) RepeatNode {
	return &RepeatNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatNode(obj), nil
}

// NewRepeatNode creates a `GskRenderNode` that will repeat the drawing of
// @child across the given @bounds.
func NewRepeatNode(bounds *graphene.Rect, child RenderNode, childBounds *graphene.Rect) *RepeatNodeClass {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds))

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)

	var _repeatNode *RepeatNodeClass // out

	_repeatNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*RepeatNodeClass)

	return _repeatNode
}

// Child retrieves the child of @node.
func (n *RepeatNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of @node.
func (n *RepeatNodeClass) ChildBounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(unsafe.Pointer(_cret))

	return _rect
}

// RepeatingLinearGradientNode: render node for a repeating linear gradient.
type RepeatingLinearGradientNode interface {
	gextras.Objector

	privateRepeatingLinearGradientNodeClass()
}

// RepeatingLinearGradientNodeClass implements the RepeatingLinearGradientNode interface.
type RepeatingLinearGradientNodeClass struct {
	RenderNodeClass
}

var _ RepeatingLinearGradientNode = (*RepeatingLinearGradientNodeClass)(nil)

func wrapRepeatingLinearGradientNode(obj *externglib.Object) RepeatingLinearGradientNode {
	return &RepeatingLinearGradientNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatingLinearGradientNode(obj), nil
}

// NewRepeatingLinearGradientNode creates a `GskRenderNode` that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by @bounds.
func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) *RepeatingLinearGradientNodeClass {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(start))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(end))
	_arg5 = C.gsize(len(colorStops))
	_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _repeatingLinearGradientNode *RepeatingLinearGradientNodeClass // out

	_repeatingLinearGradientNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*RepeatingLinearGradientNodeClass)

	return _repeatingLinearGradientNode
}

func (*RepeatingLinearGradientNodeClass) privateRepeatingLinearGradientNodeClass() {}

// RepeatingRadialGradientNode: render node for a repeating radial gradient.
type RepeatingRadialGradientNode interface {
	gextras.Objector

	privateRepeatingRadialGradientNodeClass()
}

// RepeatingRadialGradientNodeClass implements the RepeatingRadialGradientNode interface.
type RepeatingRadialGradientNodeClass struct {
	RenderNodeClass
}

var _ RepeatingRadialGradientNode = (*RepeatingRadialGradientNodeClass)(nil)

func wrapRepeatingRadialGradientNode(obj *externglib.Object) RepeatingRadialGradientNode {
	return &RepeatingRadialGradientNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatingRadialGradientNode(obj), nil
}

// NewRepeatingRadialGradientNode creates a `GskRenderNode` that draws a
// repeating radial gradient.
//
// The radial gradient starts around @center. The size of the gradient is
// dictated by @hradius in horizontal orientation and by @vradius in vertial
// orientation.
func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) *RepeatingRadialGradientNodeClass {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = C.gsize(len(colorStops))
	_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)

	var _repeatingRadialGradientNode *RepeatingRadialGradientNodeClass // out

	_repeatingRadialGradientNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*RepeatingRadialGradientNodeClass)

	return _repeatingRadialGradientNode
}

func (*RepeatingRadialGradientNodeClass) privateRepeatingRadialGradientNodeClass() {}

// RoundedClipNode: render node applying a rounded rectangle clip to its single
// child.
type RoundedClipNode interface {
	gextras.Objector

	// Child gets the child node that is getting clipped by the given @node.
	Child() *RenderNodeClass
	// Clip retrieves the rounded rectangle used to clip the contents of the
	// @node.
	Clip() *RoundedRect
}

// RoundedClipNodeClass implements the RoundedClipNode interface.
type RoundedClipNodeClass struct {
	RenderNodeClass
}

var _ RoundedClipNode = (*RoundedClipNodeClass)(nil)

func wrapRoundedClipNode(obj *externglib.Object) RoundedClipNode {
	return &RoundedClipNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRoundedClipNode(obj), nil
}

// NewRoundedClipNode creates a `GskRenderNode` that will clip the @child to the
// area given by @clip.
func NewRoundedClipNode(child RenderNode, clip *RoundedRect) *RoundedClipNodeClass {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskRoundedRect)(unsafe.Pointer(clip))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)

	var _roundedClipNode *RoundedClipNodeClass // out

	_roundedClipNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RoundedClipNodeClass)

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given @node.
func (n *RoundedClipNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the @node.
func (n *RoundedClipNodeClass) Clip() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(unsafe.Pointer(_cret))

	return _roundedRect
}

// ShadowNode: render node drawing one or more shadows behind its single child
// node.
type ShadowNode interface {
	gextras.Objector

	// Child retrieves the child `GskRenderNode` of the shadow @node.
	Child() *RenderNodeClass
	// NShadows retrieves the number of shadows in the @node.
	NShadows() uint
	// Shadow retrieves the shadow data at the given index @i.
	Shadow(i uint) *Shadow
}

// ShadowNodeClass implements the ShadowNode interface.
type ShadowNodeClass struct {
	RenderNodeClass
}

var _ ShadowNode = (*ShadowNodeClass)(nil)

func wrapShadowNode(obj *externglib.Object) ShadowNode {
	return &ShadowNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapShadowNode(obj), nil
}

// NewShadowNode creates a `GskRenderNode` that will draw a @child with the
// given @shadows below it.
func NewShadowNode(child RenderNode, shadows []Shadow) *ShadowNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = C.gsize(len(shadows))
	_arg2 = (*C.GskShadow)(unsafe.Pointer(&shadows[0]))

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)

	var _shadowNode *ShadowNodeClass // out

	_shadowNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*ShadowNodeClass)

	return _shadowNode
}

// Child retrieves the child `GskRenderNode` of the shadow @node.
func (n *ShadowNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// NShadows retrieves the number of shadows in the @node.
func (n *ShadowNodeClass) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Shadow retrieves the shadow data at the given index @i.
func (n *ShadowNodeClass) Shadow(i uint) *Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))
	_arg1 = C.gsize(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(unsafe.Pointer(_cret))

	return _shadow
}

// TextNode: render node drawing a set of glyphs.
type TextNode interface {
	gextras.Objector

	// Color retrieves the color used by the text @node.
	Color() *gdk.RGBA
	// Font returns the font used by the text @node.
	Font() *pango.FontClass
	// NumGlyphs retrieves the number of glyphs in the text node.
	NumGlyphs() uint
	// Offset retrieves the offset applied to the text.
	Offset() *graphene.Point
	// HasColorGlyphs checks whether the text @node has color glyphs.
	HasColorGlyphs() bool
}

// TextNodeClass implements the TextNode interface.
type TextNodeClass struct {
	RenderNodeClass
}

var _ TextNode = (*TextNodeClass)(nil)

func wrapTextNode(obj *externglib.Object) TextNode {
	return &TextNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextNode(obj), nil
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that @color may not be used if the font contains color glyphs.
func NewTextNode(font pango.Font, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNodeClass {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(color))
	_arg4 = (*C.graphene_point_t)(unsafe.Pointer(offset))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)

	var _textNode *TextNodeClass // out

	_textNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*TextNodeClass)

	return _textNode
}

// Color retrieves the color used by the text @node.
func (n *TextNodeClass) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_color(_arg0)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(unsafe.Pointer(_cret))

	return _rgbA
}

// Font returns the font used by the text @node.
func (n *TextNodeClass) Font() *pango.FontClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_font(_arg0)

	var _font *pango.FontClass // out

	_font = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*pango.FontClass)

	return _font
}

// NumGlyphs retrieves the number of glyphs in the text node.
func (n *TextNodeClass) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Offset retrieves the offset applied to the text.
func (n *TextNodeClass) Offset() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(unsafe.Pointer(_cret))

	return _point
}

// HasColorGlyphs checks whether the text @node has color glyphs.
func (n *TextNodeClass) HasColorGlyphs() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextureNode: render node for a Texture.
type TextureNode interface {
	gextras.Objector

	// Texture retrieves the `GdkTexture` used when creating this
	// `GskRenderNode`.
	Texture() *gdk.TextureClass
}

// TextureNodeClass implements the TextureNode interface.
type TextureNodeClass struct {
	RenderNodeClass
}

var _ TextureNode = (*TextureNodeClass)(nil)

func wrapTextureNode(obj *externglib.Object) TextureNode {
	return &TextureNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextureNode(obj), nil
}

// NewTextureNode creates a `GskRenderNode` that will render the given @texture
// into the area given by @bounds.
func NewTextureNode(texture gdk.Texture, bounds *graphene.Rect) *TextureNodeClass {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)

	var _textureNode *TextureNodeClass // out

	_textureNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*TextureNodeClass)

	return _textureNode
}

// Texture retrieves the `GdkTexture` used when creating this `GskRenderNode`.
func (n *TextureNodeClass) Texture() *gdk.TextureClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)

	var _texture *gdk.TextureClass // out

	_texture = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*gdk.TextureClass)

	return _texture
}

// TransformNode: render node applying a `GskTransform` to its single child
// node.
type TransformNode interface {
	gextras.Objector

	// Child gets the child node that is getting transformed by the given @node.
	Child() *RenderNodeClass
	// Transform retrieves the `GskTransform` used by the @node.
	Transform() *Transform
}

// TransformNodeClass implements the TransformNode interface.
type TransformNodeClass struct {
	RenderNodeClass
}

var _ TransformNode = (*TransformNodeClass)(nil)

func wrapTransformNode(obj *externglib.Object) TransformNode {
	return &TransformNodeClass{
		RenderNodeClass: RenderNodeClass{
			Object: obj,
		},
	}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTransformNode(obj), nil
}

// NewTransformNode creates a `GskRenderNode` that will transform the given
// @child with the given @transform.
func NewTransformNode(child RenderNode, transform *Transform) *TransformNodeClass {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskTransform)(unsafe.Pointer(transform))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)

	var _transformNode *TransformNodeClass // out

	_transformNode = (gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))).(*TransformNodeClass)

	return _transformNode
}

// Child gets the child node that is getting transformed by the given @node.
func (n *TransformNodeClass) Child() *RenderNodeClass {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)

	var _renderNode *RenderNodeClass // out

	_renderNode = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*RenderNodeClass)

	return _renderNode
}

// Transform retrieves the `GskTransform` used by the @node.
func (n *TransformNodeClass) Transform() *Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(n.Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)

	var _transform *Transform // out

	_transform = (*Transform)(unsafe.Pointer(_cret))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(_transform, func(v *Transform) {
		C.gsk_transform_unref((*C.GskTransform)(unsafe.Pointer(v)))
	})

	return _transform
}
