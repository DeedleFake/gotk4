// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},

		// Records
		// Skipped CairoRendererClass.
		// Skipped ColorStop.
		// Skipped GLRendererClass.
		// Skipped GLShaderClass.
		// Skipped ParseLocation.
		// Skipped RendererClass.
		// Skipped RoundedRect.
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
		// Skipped Shadow.
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
		// Skipped VulkanRendererClass.

		// Classes
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNode},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNode},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNode},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNode},
		{T: externglib.Type(C.gsk_cairo_renderer_get_type()), F: marshalCairoRenderer},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNode},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNode},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNode},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNode},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNode},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNode},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNode},
		{T: externglib.Type(C.gsk_gl_renderer_get_type()), F: marshalGLRenderer},
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNode},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNode},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNode},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNode},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNode},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNode},
		// Skipped RenderNode.
		{T: externglib.Type(C.gsk_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNode},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNode},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNode},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNode},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNode},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNode},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNode},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNode},
		{T: externglib.Type(C.gsk_vulkan_renderer_get_type()), F: marshalVulkanRenderer},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// BlendModeDefault: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// BlendModeMultiply: the source color is multiplied by the destination and
	// replaces the destination
	BlendModeMultiply BlendMode = 1
	// BlendModeScreen: multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen BlendMode = 2
	// BlendModeOverlay: multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// BlendModeDarken: selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// BlendModeLighten: selects the lighter of the destination and source
	// colors
	BlendModeLighten BlendMode = 5
	// BlendModeColorDodge: brightens the destination color to reflect the
	// source color
	BlendModeColorDodge BlendMode = 6
	// BlendModeColorBurn: darkens the destination color to reflect the source
	// color
	BlendModeColorBurn BlendMode = 7
	// BlendModeHardLight: multiplies or screens the colors, depending on the
	// source color value
	BlendModeHardLight BlendMode = 8
	// BlendModeSoftLight: darkens or lightens the colors, depending on the
	// source color value
	BlendModeSoftLight BlendMode = 9
	// BlendModeDifference: subtracts the darker of the two constituent colors
	// from the lighter color
	BlendModeDifference BlendMode = 10
	// BlendModeExclusion: produces an effect similar to that of the difference
	// mode but lower in contrast
	BlendModeExclusion BlendMode = 11
	// BlendModeColor: creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// BlendModeHue: creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// BlendModeSaturation: creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// BlendModeLuminosity: creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// CornerTopLeft: the top left corner
	CornerTopLeft Corner = 0
	// CornerTopRight: the top right corner
	CornerTopRight Corner = 1
	// CornerBottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// CornerBottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that GLShaders declare.
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// GLUniformTypeFloat: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// GLUniformTypeInt: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// GLUniformTypeUint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// GLUniformTypeBool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// GLUniformTypeVec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// GLUniformTypeVec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// GLUniformTypeVec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// RenderNodeTypeNotARenderNode: error type. No node will ever have this
	// type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// RenderNodeTypeContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// RenderNodeTypeCairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// RenderNodeTypeColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// RenderNodeTypeLinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RenderNodeTypeRepeatingLinearGradientNode: a node drawing a repeating
	// linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RenderNodeTypeRadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RenderNodeTypeRepeatingRadialGradientNode: a node drawing a repeating
	// radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// RenderNodeTypeConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// RenderNodeTypeBorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// RenderNodeTypeTextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// RenderNodeTypeInsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// RenderNodeTypeOutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// RenderNodeTypeTransformNode: a node that renders its child after applying
	// a matrix transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// RenderNodeTypeOpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// RenderNodeTypeColorMatrixNode: a node that applies a color matrix to
	// every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RenderNodeTypeRepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// RenderNodeTypeClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RenderNodeTypeRoundedClipNode: a node that clips its child to a rounded
	// rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// RenderNodeTypeShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// RenderNodeTypeBlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// RenderNodeTypeCrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// RenderNodeTypeTextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// RenderNodeTypeBlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// RenderNodeTypeDebugNode: debug information that does not affect the
	// rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// RenderNodeTypeGLShaderNode: a node that uses OpenGL fragment shaders to
	// render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// ScalingFilterLinear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// ScalingFilterNearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError: errors that can happen during (de)serialization.
type SerializationError int

const (
	// SerializationErrorUnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// SerializationErrorUnsupportedVersion: the version of the data is not
	// understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// SerializationErrorInvalidData: the given data may not exist in a proper
	// serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK. Note
// that any category includes matrices of all later categories. So if you want
// to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via mutliplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// TransformCategoryUnknown: the category of the matrix has not been
	// determined.
	TransformCategoryUnknown TransformCategory = 0
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny TransformCategory = 1
	// TransformCategory3D: the matrix is a 3D matrix. This means that the w
	// column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// TransformCategory2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// TransformCategory2DAffine: the matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// TransformCategory2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// TransformCategoryIdentity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type ParseErrorFunc func(start *ParseLocation, end *ParseLocation, error *glib.Error)

//export cParseErrorFunc
func cParseErrorFunc(arg0 *C.GskParseLocation, arg1 *C.GskParseLocation, arg2 *C.GError, arg3 C.gpointer)

func SerializationErrorQuark() glib.Quark {
	ret := C.gsk_serialization_error_quark()

	var ret0 glib.Quark
	{
		tmp := uint32(ret)
		ret0 = Quark(tmp)
	}

	return ret0
}

// TransformParse: parses the given @string into a transform and puts it in
// @out_transform. Strings printed via gsk_transform_to_string() can be read in
// again successfully using this function.
//
// If @string does not describe a valid transform, false is returned and nil is
// put in @out_transform.
func TransformParse(string string) (*Transform, bool) {
	var arg0 string
	arg0 = C.GoString(string)
	defer C.free(unsafe.Pointer(string))

	var arg1 **C.GskTransform // out

	ret := C.gsk_transform_parse(arg0, &arg1)

	var ret0 **Transform
	ret0 = wrapTransform(arg1)

	var ret1 bool
	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ColorStop: a color stop in a gradient node.
type ColorStop struct {
	// Offset: the offset of the color stop
	Offset float32
	// Color: the color at the given offset
	Color gdk.RGBA

	native *C.GskColorStop
}

func wrapColorStop(p *C.GskColorStop) *ColorStop {
	var v ColorStop

	v.Offset = float32(p.offset)
	v.Color = wrapRGBA(p.color)

	return &v
}

func marshalColorStop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskColorStop)(unsafe.Pointer(b))

	return wrapColorStop(c)
}

// Native returns the pointer to *C.GskColorStop. The caller is expected to
// cast.
func (c *ColorStop) Native() unsafe.Pointer {
	return unsafe.Pointer(c.native)
}

// ParseLocation: a location in a parse buffer.
type ParseLocation struct {
	// Bytes: the offset of the location in the parse buffer, as bytes
	Bytes uint
	// Chars: the offset of the location in the parse buffer, as characters
	Chars uint
	// Lines: the line of the location in the parse buffer
	Lines uint
	// LineBytes: the position in the line, as bytes
	LineBytes uint
	// LineChars: the position in the line, as characters
	LineChars uint

	native *C.GskParseLocation
}

func wrapParseLocation(p *C.GskParseLocation) *ParseLocation {
	var v ParseLocation

	v.Bytes = uint(p.bytes)
	v.Chars = uint(p.chars)
	v.Lines = uint(p.lines)
	v.LineBytes = uint(p.line_bytes)
	v.LineChars = uint(p.line_chars)

	return &v
}

func marshalParseLocation(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskParseLocation)(unsafe.Pointer(b))

	return wrapParseLocation(c)
}

// Native returns the pointer to *C.GskParseLocation. The caller is expected to
// cast.
func (p *ParseLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(p.native)
}

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// gsk_rounded_rect_normalize(); this function will ensure that the bounds of
// the rectangle are normalized and ensure that the corner values are positive
// and the corners do not overlap. All functions taking a RoundedRect as an
// argument will internally operate on a normalized copy; all functions
// returning a RoundedRect will always return a normalized one.
type RoundedRect struct {
	// Bounds: the bounds of the rectangle
	Bounds graphene.Rect
	// Corner: the size of the 4 rounded corners
	Corner [4]graphene.Size

	native *C.GskRoundedRect
}

func wrapRoundedRect(p *C.GskRoundedRect) *RoundedRect {
	var v RoundedRect

	v.Bounds = wrapRect(p.bounds)
	{
		var a [4]graphene.Size
		cArray := ([4]graphene_size_t)(p.corner)

		for i := 0; i < 4; i++ {
			src := cArray[i]
			a[i] = wrapSize(src)
		}
	}

	return &v
}

func marshalRoundedRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskRoundedRect)(unsafe.Pointer(b))

	return wrapRoundedRect(c)
}

// Native returns the pointer to *C.GskRoundedRect. The caller is expected to
// cast.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native *C.GskShaderArgsBuilder
}

func wrapShaderArgsBuilder(p *C.GskShaderArgsBuilder) *ShaderArgsBuilder {
	v := ShaderArgsBuilder{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*ShaderArgsBuilder).free)

	return &v
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskShaderArgsBuilder)(unsafe.Pointer(b))

	return wrapShaderArgsBuilder(c)
}

func (s *ShaderArgsBuilder) free() {}

// Native returns the pointer to *C.GskShaderArgsBuilder. The caller is expected to
// cast.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewShaderArgsBuilder(shader GLShader, initialValues *glib.Bytes) *ShaderArgsBuilder

// Shadow: the shadow parameters in a shadow node.
type Shadow struct {
	// Color: the color of the shadow
	Color gdk.RGBA
	// Dx: the horizontal offset of the shadow
	Dx float32
	// Dy: the vertical offset of the shadow
	Dy float32
	// Radius: the radius of the shadow
	Radius float32

	native *C.GskShadow
}

func wrapShadow(p *C.GskShadow) *Shadow {
	var v Shadow

	v.Color = wrapRGBA(p.color)
	v.Dx = float32(p.dx)
	v.Dy = float32(p.dy)
	v.Radius = float32(p.radius)

	return &v
}

func marshalShadow(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskShadow)(unsafe.Pointer(b))

	return wrapShadow(c)
}

// Native returns the pointer to *C.GskShadow. The caller is expected to
// cast.
func (s *Shadow) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// Transform: the `GskTransform` structure contains only private data.
type Transform struct {
	native *C.GskTransform
}

func wrapTransform(p *C.GskTransform) *Transform {
	v := Transform{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Transform).free)

	return &v
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GskTransform)(unsafe.Pointer(b))

	return wrapTransform(c)
}

func (t *Transform) free() {}

// Native returns the pointer to *C.GskTransform. The caller is expected to
// cast.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

func NewTransform() *Transform

// BlendNode: a render node applying a blending function between its two child
// nodes.
type BlendNode interface {
	RenderNode

	// BlendMode: retrieves the blend mode used by @node.
	BlendMode() BlendMode
	// BottomChild: retrieves the bottom RenderNode child of the @node.
	BottomChild() RenderNode
	// TopChild: retrieves the top RenderNode child of the @node.
	TopChild() RenderNode
}

type blendNode struct {
	renderNode
}

func wrapBlendNode(obj *externglib.Object) BlendNode {
	return blendNode{renderNode{obj}}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBlendNode(bottom RenderNode, top RenderNode, blendMode BlendMode) BlendNode

func (b blendNode) BlendMode() BlendMode

func (b blendNode) BottomChild() RenderNode

func (b blendNode) TopChild() RenderNode

// BlurNode: a render node applying a blur effect to its single child.
type BlurNode interface {
	RenderNode

	// Child: retrieves the child RenderNode of the blur @node.
	Child() RenderNode
	// Radius: retrieves the blur radius of the @node.
	Radius() float32
}

type blurNode struct {
	renderNode
}

func wrapBlurNode(obj *externglib.Object) BlurNode {
	return blurNode{renderNode{obj}}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBlurNode(child RenderNode, radius float32) BlurNode

func (b blurNode) Child() RenderNode

func (b blurNode) Radius() float32

// BorderNode: a render node for a border.
type BorderNode interface {
	RenderNode

	// Colors: retrieves the colors of the border.
	Colors() *gdk.RGBA
	// Outline: retrieves the outline of the border.
	Outline() *RoundedRect
	// Widths: retrieves the stroke widths of the border.
	Widths() [4]float32
}

type borderNode struct {
	renderNode
}

func wrapBorderNode(obj *externglib.Object) BorderNode {
	return borderNode{renderNode{obj}}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) BorderNode

func (b borderNode) Colors() *gdk.RGBA

func (b borderNode) Outline() *RoundedRect

func (b borderNode) Widths() [4]float32

// CairoNode: a render node for a Cairo surface.
type CairoNode interface {
	RenderNode

	// DrawContext: creates a Cairo context for drawing using the surface
	// associated to the render node.
	//
	// If no surface exists yet, a surface will be created optimized for
	// rendering to @renderer.
	DrawContext() *cairo.Context
	// Surface: retrieves the Cairo surface used by the render node.
	Surface() *cairo.Surface
}

type cairoNode struct {
	renderNode
}

func wrapCairoNode(obj *externglib.Object) CairoNode {
	return cairoNode{renderNode{obj}}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCairoNode(bounds *graphene.Rect) CairoNode

func (c cairoNode) DrawContext() *cairo.Context

func (c cairoNode) Surface() *cairo.Surface

type CairoRenderer interface {
	Renderer
}

type cairoRenderer struct {
	renderer
}

func wrapCairoRenderer(obj *externglib.Object) CairoRenderer {
	return cairoRenderer{renderer{*externglib.Object{obj}}}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCairoRenderer() CairoRenderer

// ClipNode: a render node applying a rectangular clip to its single child node.
type ClipNode interface {
	RenderNode

	// Child: gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip: retrieves the clip rectangle for @node.
	Clip() *graphene.Rect
}

type clipNode struct {
	renderNode
}

func wrapClipNode(obj *externglib.Object) ClipNode {
	return clipNode{renderNode{obj}}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewClipNode(child RenderNode, clip *graphene.Rect) ClipNode

func (c clipNode) Child() RenderNode

func (c clipNode) Clip() *graphene.Rect

// ColorMatrixNode: a render node controlling the color matrix of its single
// child node.
type ColorMatrixNode interface {
	RenderNode

	// Child: gets the child node that is getting its colors modified by the
	// given @node.
	Child() RenderNode
	// ColorMatrix: retrieves the color matrix used by the @node.
	ColorMatrix() *graphene.Matrix
	// ColorOffset: retrieves the color offset used by the @node.
	ColorOffset() *graphene.Vec4
}

type colorMatrixNode struct {
	renderNode
}

func wrapColorMatrixNode(obj *externglib.Object) ColorMatrixNode {
	return colorMatrixNode{renderNode{obj}}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColorMatrixNode(child RenderNode, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) ColorMatrixNode

func (c colorMatrixNode) Child() RenderNode

func (c colorMatrixNode) ColorMatrix() *graphene.Matrix

func (c colorMatrixNode) ColorOffset() *graphene.Vec4

// ColorNode: a render node for a solid color.
type ColorNode interface {
	RenderNode

	// Color: retrieves the color of the given @node.
	Color() *gdk.RGBA
}

type colorNode struct {
	renderNode
}

func wrapColorNode(obj *externglib.Object) ColorNode {
	return colorNode{renderNode{obj}}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) ColorNode

func (c colorNode) Color() *gdk.RGBA

// ConicGradientNode: a render node for a conic gradient.
type ConicGradientNode interface {
	RenderNode

	// Center: retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// ColorStops: retrieves the color stops in the gradient.
	ColorStops() (uint, []ColorStop)
	// NColorStops: retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Rotation: retrieves the rotation for the gradient in degrees.
	Rotation() float32
}

type conicGradientNode struct {
	renderNode
}

func wrapConicGradientNode(obj *externglib.Object) ConicGradientNode {
	return conicGradientNode{renderNode{obj}}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) ConicGradientNode

func (c conicGradientNode) Center() *graphene.Point

func (c conicGradientNode) ColorStops() (uint, []ColorStop)

func (c conicGradientNode) NColorStops() uint

func (c conicGradientNode) Rotation() float32

// ContainerNode: a render node that can contain other render nodes.
type ContainerNode interface {
	RenderNode

	// Child: gets one of the children of @container.
	Child(idx uint) RenderNode
	// NChildren: retrieves the number of direct children of @node.
	NChildren() uint
}

type containerNode struct {
	renderNode
}

func wrapContainerNode(obj *externglib.Object) ContainerNode {
	return containerNode{renderNode{obj}}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewContainerNode(children []RenderNode) ContainerNode

func (c containerNode) Child(idx uint) RenderNode

func (c containerNode) NChildren() uint

// CrossFadeNode: a render node cross fading between two child nodes.
type CrossFadeNode interface {
	RenderNode

	// EndChild: retrieves the child RenderNode at the end of the cross-fade.
	EndChild() RenderNode
	// Progress: retrieves the progress value of the cross fade.
	Progress() float32
	// StartChild: retrieves the child RenderNode at the beginning of the
	// cross-fade.
	StartChild() RenderNode
}

type crossFadeNode struct {
	renderNode
}

func wrapCrossFadeNode(obj *externglib.Object) CrossFadeNode {
	return crossFadeNode{renderNode{obj}}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCrossFadeNode(start RenderNode, end RenderNode, progress float32) CrossFadeNode

func (c crossFadeNode) EndChild() RenderNode

func (c crossFadeNode) Progress() float32

func (c crossFadeNode) StartChild() RenderNode

// DebugNode: a render node that emits a debugging message when drawing its
// child node.
type DebugNode interface {
	RenderNode

	// Child: gets the child node that is getting drawn by the given @node.
	Child() RenderNode
	// Message: gets the debug message that was set on this node
	Message() string
}

type debugNode struct {
	renderNode
}

func wrapDebugNode(obj *externglib.Object) DebugNode {
	return debugNode{renderNode{obj}}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewDebugNode(child RenderNode, message string) DebugNode

func (d debugNode) Child() RenderNode

func (d debugNode) Message() string

type GLRenderer interface {
	Renderer
}

type glRenderer struct {
	renderer
}

func wrapGLRenderer(obj *externglib.Object) GLRenderer {
	return glRenderer{renderer{*externglib.Object{obj}}}
}

func marshalGLRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGLRenderer() GLRenderer

// GLShader: an object representing a GL shader program.
type GLShader interface {
	gextras.Objector

	// Compile: tries to compile the @shader for the given @renderer, and
	// reports false with an error if there is a problem. You should use this
	// function before relying on the shader for rendering and use a fallback
	// with a simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) bool
	// FindUniformByName: looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgBool: gets the value of the uniform @idx in the @args block. The
	// uniform must be of bool type.
	ArgBool(args *glib.Bytes, idx int) bool
	// ArgFloat: gets the value of the uniform @idx in the @args block. The
	// uniform must be of float type.
	ArgFloat(args *glib.Bytes, idx int) float32
	// ArgInt: gets the value of the uniform @idx in the @args block. The
	// uniform must be of int type.
	ArgInt(args *glib.Bytes, idx int) int32
	// ArgUint: gets the value of the uniform @idx in the @args block. The
	// uniform must be of uint type.
	ArgUint(args *glib.Bytes, idx int) uint32
	// ArgVec2: gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec2 type.
	ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2)
	// ArgVec3: gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec3 type.
	ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3)
	// ArgVec4: gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec4 type.
	ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4)
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures: returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource: gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// Source: gets the GLSL sourcecode being used to render this shader.
	Source() *glib.Bytes
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

type glShader struct {
	*externglib.Object
}

func wrapGLShader(obj *externglib.Object) GLShader {
	return glShader{*externglib.Object{obj}}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGLShader(sourcecode *glib.Bytes) GLShader

func NewGLShader(resourcePath string) GLShader

func (g glShader) Compile(renderer Renderer) bool

func (g glShader) FindUniformByName(name string) int

func (g glShader) ArgBool(args *glib.Bytes, idx int) bool

func (g glShader) ArgFloat(args *glib.Bytes, idx int) float32

func (g glShader) ArgInt(args *glib.Bytes, idx int) int32

func (g glShader) ArgUint(args *glib.Bytes, idx int) uint32

func (g glShader) ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2)

func (g glShader) ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3)

func (g glShader) ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4)

func (g glShader) ArgsSize() uint

func (g glShader) NTextures() int

func (g glShader) NUniforms() int

func (g glShader) Resource() string

func (g glShader) Source() *glib.Bytes

func (g glShader) UniformName(idx int) string

func (g glShader) UniformOffset(idx int) int

func (g glShader) UniformType(idx int) GLUniformType

// GLShaderNode: a render node using a GL shader when drawing its children
// nodes.
type GLShaderNode interface {
	RenderNode

	// Args: gets args for the node.
	Args() *glib.Bytes
	// Child: gets one of the children.
	Child(idx uint) RenderNode
	// NChildren: returns the number of children
	NChildren() uint
	// Shader: gets shader code for the node.
	Shader() GLShader
}

type glShaderNode struct {
	renderNode
}

func wrapGLShaderNode(obj *externglib.Object) GLShaderNode {
	return glShaderNode{renderNode{obj}}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGLShaderNode(shader GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNode) GLShaderNode

func (g glShaderNode) Args() *glib.Bytes

func (g glShaderNode) Child(idx uint) RenderNode

func (g glShaderNode) NChildren() uint

func (g glShaderNode) Shader() GLShader

// InsetShadowNode: a render node for an inset shadow.
type InsetShadowNode interface {
	RenderNode

	// BlurRadius: retrieves the blur radius to apply to the shadow.
	BlurRadius() float32
	// Color: retrieves the color of the inset shadow.
	Color() *gdk.RGBA
	// Dx: retrieves the horizontal offset of the inset shadow.
	Dx() float32
	// Dy: retrieves the vertical offset of the inset shadow.
	Dy() float32
	// Outline: retrieves the outline rectangle of the inset shadow.
	Outline() *RoundedRect
	// Spread: retrieves how much the shadow spreads inwards.
	Spread() float32
}

type insetShadowNode struct {
	renderNode
}

func wrapInsetShadowNode(obj *externglib.Object) InsetShadowNode {
	return insetShadowNode{renderNode{obj}}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) InsetShadowNode

func (i insetShadowNode) BlurRadius() float32

func (i insetShadowNode) Color() *gdk.RGBA

func (i insetShadowNode) Dx() float32

func (i insetShadowNode) Dy() float32

func (i insetShadowNode) Outline() *RoundedRect

func (i insetShadowNode) Spread() float32

// LinearGradientNode: a render node for a linear gradient.
type LinearGradientNode interface {
	RenderNode

	// ColorStops: retrieves the color stops in the gradient.
	ColorStops() (uint, []ColorStop)
	// End: retrieves the final point of the linear gradient.
	End() *graphene.Point
	// NColorStops: retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start: retrieves the initial point of the linear gradient.
	Start() *graphene.Point
}

type linearGradientNode struct {
	renderNode
}

func wrapLinearGradientNode(obj *externglib.Object) LinearGradientNode {
	return linearGradientNode{renderNode{obj}}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) LinearGradientNode

func (l linearGradientNode) ColorStops() (uint, []ColorStop)

func (l linearGradientNode) End() *graphene.Point

func (l linearGradientNode) NColorStops() uint

func (l linearGradientNode) Start() *graphene.Point

// OpacityNode: a render node controlling the opacity of its single child node.
type OpacityNode interface {
	RenderNode

	// Child: gets the child node that is getting opacityed by the given @node.
	Child() RenderNode
	// Opacity: gets the transparency factor for an opacity node.
	Opacity() float32
}

type opacityNode struct {
	renderNode
}

func wrapOpacityNode(obj *externglib.Object) OpacityNode {
	return opacityNode{renderNode{obj}}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewOpacityNode(child RenderNode, opacity float32) OpacityNode

func (o opacityNode) Child() RenderNode

func (o opacityNode) Opacity() float32

// OutsetShadowNode: a render node for an outset shadow.
type OutsetShadowNode interface {
	RenderNode

	// BlurRadius: retrieves the blur radius of the shadow.
	BlurRadius() float32
	// Color: retrieves the color of the outset shadow.
	Color() *gdk.RGBA
	// Dx: retrieves the horizontal offset of the outset shadow.
	Dx() float32
	// Dy: retrieves the vertical offset of the outset shadow.
	Dy() float32
	// Outline: retrieves the outline rectangle of the outset shadow.
	Outline() *RoundedRect
	// Spread: retrieves how much the shadow spreads outwards.
	Spread() float32
}

type outsetShadowNode struct {
	renderNode
}

func wrapOutsetShadowNode(obj *externglib.Object) OutsetShadowNode {
	return outsetShadowNode{renderNode{obj}}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) OutsetShadowNode

func (o outsetShadowNode) BlurRadius() float32

func (o outsetShadowNode) Color() *gdk.RGBA

func (o outsetShadowNode) Dx() float32

func (o outsetShadowNode) Dy() float32

func (o outsetShadowNode) Outline() *RoundedRect

func (o outsetShadowNode) Spread() float32

// RadialGradientNode: a render node for a radial gradient.
type RadialGradientNode interface {
	RenderNode

	// Center: retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// ColorStops: retrieves the color stops in the gradient.
	ColorStops() (uint, []ColorStop)
	// End: retrieves the end value for the gradient.
	End() float32
	// Hradius: retrieves the horizonal radius for the gradient.
	Hradius() float32
	// NColorStops: retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start: retrieves the start value for the gradient.
	Start() float32
	// Vradius: retrieves the vertical radius for the gradient.
	Vradius() float32
}

type radialGradientNode struct {
	renderNode
}

func wrapRadialGradientNode(obj *externglib.Object) RadialGradientNode {
	return radialGradientNode{renderNode{obj}}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RadialGradientNode

func (r radialGradientNode) Center() *graphene.Point

func (r radialGradientNode) ColorStops() (uint, []ColorStop)

func (r radialGradientNode) End() float32

func (r radialGradientNode) Hradius() float32

func (r radialGradientNode) NColorStops() uint

func (r radialGradientNode) Start() float32

func (r radialGradientNode) Vradius() float32

// Renderer: base type for the object managing the rendering pipeline for a
// Surface.
type Renderer interface {
	gextras.Objector

	// Surface: retrieves the Surface set using gsk_renderer_realize(). If the
	// renderer has not been realized yet, nil will be returned.
	Surface() gdk.Surface
	// IsRealized: checks whether the @renderer is realized or not.
	IsRealized() bool
	// Realize: creates the resources needed by the @renderer to render the
	// scene graph.
	Realize(surface gdk.Surface) bool
	// Render: renders the scene graph, described by a tree of RenderNode
	// instances, ensuring that the given @region gets redrawn.
	//
	// Renderers must ensure that changes of the contents given by the @root
	// node as well as the area given by @region are redrawn. They are however
	// free to not redraw any pixel outside of @region if they can guarantee
	// that it didn't change.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	Render(root RenderNode, region *cairo.Region)
	// RenderTexture: renders the scene graph, described by a tree of RenderNode
	// instances, to a Texture.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	//
	// If you want to apply any transformations to @root, you should put it into
	// a transform node and pass that node instead.
	RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture
	// Unrealize: releases all the resources created by gsk_renderer_realize().
	Unrealize()
}

type renderer struct {
	*externglib.Object
}

func wrapRenderer(obj *externglib.Object) Renderer {
	return renderer{*externglib.Object{obj}}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRenderer(surface gdk.Surface) Renderer

func (r renderer) Surface() gdk.Surface

func (r renderer) IsRealized() bool

func (r renderer) Realize(surface gdk.Surface) bool

func (r renderer) Render(root RenderNode, region *cairo.Region)

func (r renderer) RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture

func (r renderer) Unrealize()

// RepeatNode: a render node repeating its single child node.
type RepeatNode interface {
	RenderNode

	// Child: retrieves the child of @node.
	Child() RenderNode
	// ChildBounds: retrieves the bounding rectangle of the child of @node.
	ChildBounds() *graphene.Rect
}

type repeatNode struct {
	renderNode
}

func wrapRepeatNode(obj *externglib.Object) RepeatNode {
	return repeatNode{renderNode{obj}}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRepeatNode(bounds *graphene.Rect, child RenderNode, childBounds *graphene.Rect) RepeatNode

func (r repeatNode) Child() RenderNode

func (r repeatNode) ChildBounds() *graphene.Rect

// RepeatingLinearGradientNode: a render node for a repeating linear gradient.
type RepeatingLinearGradientNode interface {
	RenderNode
}

type repeatingLinearGradientNode struct {
	renderNode
}

func wrapRepeatingLinearGradientNode(obj *externglib.Object) RepeatingLinearGradientNode {
	return repeatingLinearGradientNode{renderNode{obj}}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) RepeatingLinearGradientNode

// RepeatingRadialGradientNode: a render node for a repeating radial gradient.
type RepeatingRadialGradientNode interface {
	RenderNode
}

type repeatingRadialGradientNode struct {
	renderNode
}

func wrapRepeatingRadialGradientNode(obj *externglib.Object) RepeatingRadialGradientNode {
	return repeatingRadialGradientNode{renderNode{obj}}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RepeatingRadialGradientNode

// RoundedClipNode: a render node applying a rounded rectangle clip to its
// single child.
type RoundedClipNode interface {
	RenderNode

	// Child: gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip: retrievs the rounded rectangle used to clip the contents of the
	// @node.
	Clip() *RoundedRect
}

type roundedClipNode struct {
	renderNode
}

func wrapRoundedClipNode(obj *externglib.Object) RoundedClipNode {
	return roundedClipNode{renderNode{obj}}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewRoundedClipNode(child RenderNode, clip *RoundedRect) RoundedClipNode

func (r roundedClipNode) Child() RenderNode

func (r roundedClipNode) Clip() *RoundedRect

// ShadowNode: a render node drawing one or more shadows behind its single child
// node.
type ShadowNode interface {
	RenderNode

	// Child: retrieves the child RenderNode of the shadow @node.
	Child() RenderNode
	// NShadows: retrieves the number of shadows in the @node.
	NShadows() uint
	// Shadow: retrieves the shadow data at the given index @i.
	Shadow(i uint) *Shadow
}

type shadowNode struct {
	renderNode
}

func wrapShadowNode(obj *externglib.Object) ShadowNode {
	return shadowNode{renderNode{obj}}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewShadowNode(child RenderNode, shadows []Shadow) ShadowNode

func (s shadowNode) Child() RenderNode

func (s shadowNode) NShadows() uint

func (s shadowNode) Shadow(i uint) *Shadow

// TextNode: a render node drawing a set of glyphs.
type TextNode interface {
	RenderNode

	// Color: retrieves the color used by the text @node.
	Color() *gdk.RGBA
	// Font: returns the font used by the text @node.
	Font() pango.Font
	// Glyphs: retrieves the glyph information in the @node.
	Glyphs() (uint, []pango.GlyphInfo)
	// NumGlyphs: retrieves the number of glyphs in the text node.
	NumGlyphs() uint
	// Offset: retrieves the offset applied to the text.
	Offset() *graphene.Point
	// HasColorGlyphs: checks whether the text @node has color glyphs.
	HasColorGlyphs() bool
}

type textNode struct {
	renderNode
}

func wrapTextNode(obj *externglib.Object) TextNode {
	return textNode{renderNode{obj}}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextNode(font pango.Font, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) TextNode

func (t textNode) Color() *gdk.RGBA

func (t textNode) Font() pango.Font

func (t textNode) Glyphs() (uint, []pango.GlyphInfo)

func (t textNode) NumGlyphs() uint

func (t textNode) Offset() *graphene.Point

func (t textNode) HasColorGlyphs() bool

// TextureNode: a render node for a Texture.
type TextureNode interface {
	RenderNode

	// Texture: retrieves the Texture used when creating this RenderNode.
	Texture() gdk.Texture
}

type textureNode struct {
	renderNode
}

func wrapTextureNode(obj *externglib.Object) TextureNode {
	return textureNode{renderNode{obj}}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTextureNode(texture gdk.Texture, bounds *graphene.Rect) TextureNode

func (t textureNode) Texture() gdk.Texture

// TransformNode: a render node applying a Transform to its single child node.
type TransformNode interface {
	RenderNode

	// Child: gets the child node that is getting transformed by the given
	// @node.
	Child() RenderNode
	// Transform: retrieves the Transform used by the @node.
	Transform() *Transform
}

type transformNode struct {
	renderNode
}

func wrapTransformNode(obj *externglib.Object) TransformNode {
	return transformNode{renderNode{obj}}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTransformNode(child RenderNode, transform *Transform) TransformNode

func (t transformNode) Child() RenderNode

func (t transformNode) Transform() *Transform

type VulkanRenderer interface {
	Renderer
}

type vulkanRenderer struct {
	renderer
}

func wrapVulkanRenderer(obj *externglib.Object) VulkanRenderer {
	return vulkanRenderer{renderer{*externglib.Object{obj}}}
}

func marshalVulkanRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewVulkanRenderer() VulkanRenderer
