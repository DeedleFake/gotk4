// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gsk/gsk.h>
//
// extern void gotk4_ParseErrorFunc(const GskParseLocation* _0, const GskParseLocation* _1, const GError* _2, gpointer _3);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
		{T: externglib.Type(C.gsk_cairo_renderer_get_type()), F: marshalCairoRenderer},
		{T: externglib.Type(C.gsk_gl_renderer_get_type()), F: marshalGLRenderer},
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.gsk_vulkan_renderer_get_type()), F: marshalVulkanRenderer},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// BlendModeDefault: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// BlendModeMultiply: the source color is multiplied by the destination and
	// replaces the destination
	BlendModeMultiply BlendMode = 1
	// BlendModeScreen multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen BlendMode = 2
	// BlendModeOverlay multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// BlendModeDarken selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// BlendModeLighten selects the lighter of the destination and source colors
	BlendModeLighten BlendMode = 5
	// BlendModeColorDodge brightens the destination color to reflect the source
	// color
	BlendModeColorDodge BlendMode = 6
	// BlendModeColorBurn darkens the destination color to reflect the source
	// color
	BlendModeColorBurn BlendMode = 7
	// BlendModeHardLight multiplies or screens the colors, depending on the
	// source color value
	BlendModeHardLight BlendMode = 8
	// BlendModeSoftLight darkens or lightens the colors, depending on the
	// source color value
	BlendModeSoftLight BlendMode = 9
	// BlendModeDifference subtracts the darker of the two constituent colors
	// from the lighter color
	BlendModeDifference BlendMode = 10
	// BlendModeExclusion produces an effect similar to that of the difference
	// mode but lower in contrast
	BlendModeExclusion BlendMode = 11
	// BlendModeColor creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// BlendModeHue creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// BlendModeSaturation creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// BlendModeLuminosity creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// CornerTopLeft: the top left corner
	CornerTopLeft Corner = 0
	// CornerTopRight: the top right corner
	CornerTopRight Corner = 1
	// CornerBottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// CornerBottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that GLShaders declare.
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// GLUniformTypeFloat: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// GLUniformTypeInt: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// GLUniformTypeUint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// GLUniformTypeBool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// GLUniformTypeVec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// GLUniformTypeVec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// GLUniformTypeVec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// RenderNodeTypeNotARenderNode: error type. No node will ever have this
	// type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// RenderNodeTypeContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// RenderNodeTypeCairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// RenderNodeTypeColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// RenderNodeTypeLinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RenderNodeTypeRepeatingLinearGradientNode: a node drawing a repeating
	// linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RenderNodeTypeRadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RenderNodeTypeRepeatingRadialGradientNode: a node drawing a repeating
	// radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// RenderNodeTypeConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// RenderNodeTypeBorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// RenderNodeTypeTextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// RenderNodeTypeInsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// RenderNodeTypeOutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// RenderNodeTypeTransformNode: a node that renders its child after applying
	// a matrix transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// RenderNodeTypeOpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// RenderNodeTypeColorMatrixNode: a node that applies a color matrix to
	// every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RenderNodeTypeRepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// RenderNodeTypeClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RenderNodeTypeRoundedClipNode: a node that clips its child to a rounded
	// rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// RenderNodeTypeShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// RenderNodeTypeBlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// RenderNodeTypeCrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// RenderNodeTypeTextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// RenderNodeTypeBlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// RenderNodeTypeDebugNode: debug information that does not affect the
	// rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// RenderNodeTypeGLShaderNode: a node that uses OpenGL fragment shaders to
	// render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// ScalingFilterLinear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// ScalingFilterNearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// SerializationErrorUnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// SerializationErrorUnsupportedVersion: the version of the data is not
	// understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// SerializationErrorInvalidData: the given data may not exist in a proper
	// serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK. Note
// that any category includes matrices of all later categories. So if you want
// to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via mutliplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// TransformCategoryUnknown: the category of the matrix has not been
	// determined.
	TransformCategoryUnknown TransformCategory = 0
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny TransformCategory = 1
	// TransformCategory3D: the matrix is a 3D matrix. This means that the w
	// column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// TransformCategory2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// TransformCategory2DAffine: the matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// TransformCategory2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// TransformCategoryIdentity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ParseErrorFunc: the type of callback that is called when a parse error occurs
// during deserialization of node data.
type ParseErrorFunc func(start *ParseLocation, end *ParseLocation, error *glib.Error)

//export gotk4_ParseErrorFunc
func gotk4_ParseErrorFunc(arg0 *C.GskParseLocation, arg1 *C.GskParseLocation, arg2 *C.GError, arg3 C.gpointer) {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var start *ParseLocation
	var end *ParseLocation
	var error *glib.Error

	{
		start = WrapParseLocation(unsafe.Pointer(arg0))
	}

	{
		end = WrapParseLocation(unsafe.Pointer(arg1))
	}

	{
		error = glib.WrapError(unsafe.Pointer(arg2))
	}

	v.(ParseErrorFunc)(start, end, error)
}

func SerializationErrorQuark() glib.Quark {

	ret := C.gsk_serialization_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// TransformParse parses the given @string into a transform and puts it in
// @out_transform. Strings printed via gsk_transform_to_string() can be read in
// again successfully using this function.
//
// If @string does not describe a valid transform, false is returned and nil is
// put in @out_transform.
func TransformParse(string string) (outTransform *Transform, ok bool) {
	var arg1 *C.char
	var arg2 **C.GskTransform // out

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_transform_parse(arg1, &arg2)

	var ret0 **Transform
	var ret1 bool

	{
		ret0 = WrapTransform(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v **Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret1 = C.BOOL(ret) != 0

	return ret0, ret1
}

// ColorStop: a color stop in a gradient node.
type ColorStop struct {
	native C.GskColorStop
}

// WrapColorStop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorStop(ptr unsafe.Pointer) *ColorStop {
	if ptr == nil {
		return nil
	}

	return (*ColorStop)(ptr)
}

func marshalColorStop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorStop(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ColorStop) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Offset gets the field inside the struct.
func (c *ColorStop) Offset() float32 {
	var ret float32
	ret = float32(c.native.offset)
	return ret
}

// Color gets the field inside the struct.
func (c *ColorStop) Color() gdk.RGBA {
	var ret gdk.RGBA
	{
		ret = gdk.WrapRGBA(unsafe.Pointer(c.native.color))
	}
	return ret
}

// ParseLocation: a location in a parse buffer.
type ParseLocation struct {
	native C.GskParseLocation
}

// WrapParseLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParseLocation(ptr unsafe.Pointer) *ParseLocation {
	if ptr == nil {
		return nil
	}

	return (*ParseLocation)(ptr)
}

func marshalParseLocation(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapParseLocation(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *ParseLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Bytes gets the field inside the struct.
func (p *ParseLocation) Bytes() uint {
	var ret uint
	ret = uint(p.native.bytes)
	return ret
}

// Chars gets the field inside the struct.
func (p *ParseLocation) Chars() uint {
	var ret uint
	ret = uint(p.native.chars)
	return ret
}

// Lines gets the field inside the struct.
func (p *ParseLocation) Lines() uint {
	var ret uint
	ret = uint(p.native.lines)
	return ret
}

// LineBytes gets the field inside the struct.
func (p *ParseLocation) LineBytes() uint {
	var ret uint
	ret = uint(p.native.line_bytes)
	return ret
}

// LineChars gets the field inside the struct.
func (p *ParseLocation) LineChars() uint {
	var ret uint
	ret = uint(p.native.line_chars)
	return ret
}

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// gsk_rounded_rect_normalize(); this function will ensure that the bounds of
// the rectangle are normalized and ensure that the corner values are positive
// and the corners do not overlap. All functions taking a RoundedRect as an
// argument will internally operate on a normalized copy; all functions
// returning a RoundedRect will always return a normalized one.
type RoundedRect struct {
	native C.GskRoundedRect
}

// WrapRoundedRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRoundedRect(ptr unsafe.Pointer) *RoundedRect {
	if ptr == nil {
		return nil
	}

	return (*RoundedRect)(ptr)
}

func marshalRoundedRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRoundedRect(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Bounds gets the field inside the struct.
func (r *RoundedRect) Bounds() graphene.Rect {
	var ret graphene.Rect
	{
		ret = graphene.WrapRect(unsafe.Pointer(r.native.bounds))
	}
	return ret
}

// Corner gets the field inside the struct.
func (r *RoundedRect) Corner() [4]graphene.Size {
	var ret [4]graphene.Size
	{
		cArray := ([4]graphene_size_t)(r.native.corner)

		for i := 0; i < 4; i++ {
			src := cArray[i]
			{
				ret[i] = graphene.WrapSize(unsafe.Pointer(src))
			}
		}
	}
	return ret
}

// ContainsPoint checks if the given @point is inside the rounded rectangle.
// This function returns false if the point is in the rounded corner areas.
func (self *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var arg0 *C.GskRoundedRect
	var arg1 *C.graphene_point_t

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	ret := C.gsk_rounded_rect_contains_point(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ContainsRect checks if the given @rect is contained inside the rounded
// rectangle. This function returns false if @rect extends into one of the
// rounded corner areas.
func (self *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var arg0 *C.GskRoundedRect
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.graphene_rect_t)(rect.Native())

	ret := C.gsk_rounded_rect_contains_rect(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Init initializes the given RoundedRect with the given values.
//
// This function will implicitly normalize the RoundedRect before returning.
func (self *RoundedRect) Init(bounds *graphene.Rect, topLeft *graphene.Size, topRight *graphene.Size, bottomRight *graphene.Size, bottomLeft *graphene.Size) *RoundedRect {
	var arg0 *C.GskRoundedRect
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_size_t
	var arg3 *C.graphene_size_t
	var arg4 *C.graphene_size_t
	var arg5 *C.graphene_size_t

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_size_t)(topLeft.Native())
	arg3 = (*C.graphene_size_t)(topRight.Native())
	arg4 = (*C.graphene_size_t)(bottomRight.Native())
	arg5 = (*C.graphene_size_t)(bottomLeft.Native())

	ret := C.gsk_rounded_rect_init(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// InitCopy initializes @self using the given @src rectangle.
//
// This function will not normalize the RoundedRect, so make sure the source is
// normalized.
func (self *RoundedRect) InitCopy(src *RoundedRect) *RoundedRect {
	var arg0 *C.GskRoundedRect
	var arg1 *C.GskRoundedRect

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.GskRoundedRect)(src.Native())

	ret := C.gsk_rounded_rect_init_copy(arg0, arg1)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromRect initializes @self to the given @bounds and sets the radius of
// all four corners to @radius.
func (self *RoundedRect) InitFromRect(bounds *graphene.Rect, radius float32) *RoundedRect {
	var arg0 *C.GskRoundedRect
	var arg1 *C.graphene_rect_t
	var arg2 C.float

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = C.float(radius)

	ret := C.gsk_rounded_rect_init_from_rect(arg0, arg1, arg2)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// IntersectsRect checks if part of the given @rect is contained inside the
// rounded rectangle. This function returns false if @rect only extends into one
// of the rounded corner areas but not into the rounded rectangle itself.
func (self *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var arg0 *C.GskRoundedRect
	var arg1 *C.graphene_rect_t

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = (*C.graphene_rect_t)(rect.Native())

	ret := C.gsk_rounded_rect_intersects_rect(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// IsRectilinear checks if all corners of @self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if gsk_clip_node_new() or
// gsk_rounded_clip_node_new() should be called.
func (self *RoundedRect) IsRectilinear() bool {
	var arg0 *C.GskRoundedRect

	arg0 = (*C.GskRoundedRect)(self.Native())

	ret := C.gsk_rounded_rect_is_rectilinear(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Normalize normalizes the passed rectangle.
//
// this function will ensure that the bounds of the rectangle are normalized and
// ensure that the corner values are positive and the corners do not overlap.
func (self *RoundedRect) Normalize() *RoundedRect {
	var arg0 *C.GskRoundedRect

	arg0 = (*C.GskRoundedRect)(self.Native())

	ret := C.gsk_rounded_rect_normalize(arg0)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// Offset offsets the bound's origin by @dx and @dy.
//
// The size and corners of the rectangle are unchanged.
func (self *RoundedRect) Offset(dx float32, dy float32) *RoundedRect {
	var arg0 *C.GskRoundedRect
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = C.float(dx)
	arg2 = C.float(dy)

	ret := C.gsk_rounded_rect_offset(arg0, arg1, arg2)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// Shrink shrinks (or grows) the given rectangle by moving the 4 sides according
// to the offsets given. The corner radii will be changed in a way that tries to
// keep the center of the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass negative values
// for the @top, @right, @bottom or @left.
func (self *RoundedRect) Shrink(top float32, right float32, bottom float32, left float32) *RoundedRect {
	var arg0 *C.GskRoundedRect
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.GskRoundedRect)(self.Native())
	arg1 = C.float(top)
	arg2 = C.float(right)
	arg3 = C.float(bottom)
	arg4 = C.float(left)

	ret := C.gsk_rounded_rect_shrink(arg0, arg1, arg2, arg3, arg4)

	var ret0 *RoundedRect

	{
		ret0 = WrapRoundedRect(unsafe.Pointer(ret))
	}

	return ret0
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native C.GskShaderArgsBuilder
}

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	if ptr == nil {
		return nil
	}

	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShaderArgsBuilder(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewShaderArgsBuilder constructs a struct ShaderArgsBuilder.
func NewShaderArgsBuilder(shader GLShader, initialValues *glib.Bytes) *ShaderArgsBuilder {
	var arg1 *C.GskGLShader
	var arg2 *C.GBytes

	arg1 = (*C.GskGLShader)(shader.Native())
	arg2 = (*C.GBytes)(initialValues.Native())

	ret := C.gsk_shader_args_builder_new(arg1, arg2)

	var ret0 *ShaderArgsBuilder

	{
		ret0 = WrapShaderArgsBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ShaderArgsBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FreeToArgs creates a new #GBytes args from the current state of the given
// @builder, and frees the @builder instance. Any uniforms of the shader that
// have not been explicitly set on the @builder are zero-initialized.
func (builder *ShaderArgsBuilder) FreeToArgs() *glib.Bytes {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())

	ret := C.gsk_shader_args_builder_free_to_args(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Ref increases the reference count of a ShaderArgsBuilder by one.
func (builder *ShaderArgsBuilder) Ref() *ShaderArgsBuilder {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())

	ret := C.gsk_shader_args_builder_ref(arg0)

	var ret0 *ShaderArgsBuilder

	{
		ret0 = WrapShaderArgsBuilder(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ShaderArgsBuilder) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// SetBool sets the value of the uniform @idx. The uniform must be of bool type.
func (builder *ShaderArgsBuilder) SetBool(idx int, value bool) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	if value {
		arg2 = C.TRUE
	}

	C.gsk_shader_args_builder_set_bool(arg0, arg1, arg2)
}

// SetFloat sets the value of the uniform @idx. The uniform must be of float
// type.
func (builder *ShaderArgsBuilder) SetFloat(idx int, value float32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.float

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = C.float(value)

	C.gsk_shader_args_builder_set_float(arg0, arg1, arg2)
}

// SetInt sets the value of the uniform @idx. The uniform must be of int type.
func (builder *ShaderArgsBuilder) SetInt(idx int, value int32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.gint32

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = C.gint32(value)

	C.gsk_shader_args_builder_set_int(arg0, arg1, arg2)
}

// SetUint sets the value of the uniform @idx. The uniform must be of uint type.
func (builder *ShaderArgsBuilder) SetUint(idx int, value uint32) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 C.guint32

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = C.guint32(value)

	C.gsk_shader_args_builder_set_uint(arg0, arg1, arg2)
}

// SetVec2 sets the value of the uniform @idx. The uniform must be of vec2 type.
func (builder *ShaderArgsBuilder) SetVec2(idx int, value *graphene.Vec2) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec2_t

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec2_t)(value.Native())

	C.gsk_shader_args_builder_set_vec2(arg0, arg1, arg2)
}

// SetVec3 sets the value of the uniform @idx. The uniform must be of vec3 type.
func (builder *ShaderArgsBuilder) SetVec3(idx int, value *graphene.Vec3) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec3_t)(value.Native())

	C.gsk_shader_args_builder_set_vec3(arg0, arg1, arg2)
}

// SetVec4 sets the value of the uniform @idx. The uniform must be of vec4 type.
func (builder *ShaderArgsBuilder) SetVec4(idx int, value *graphene.Vec4) {
	var arg0 *C.GskShaderArgsBuilder
	var arg1 C.int
	var arg2 *C.graphene_vec4_t

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())
	arg1 = C.int(idx)
	arg2 = (*C.graphene_vec4_t)(value.Native())

	C.gsk_shader_args_builder_set_vec4(arg0, arg1, arg2)
}

// ToArgs creates a new #GBytes args from the current state of the given
// @builder. Any uniforms of the shader that have not been explicitly set on the
// @builder are zero-initialized.
//
// The given ShaderArgsBuilder is reset once this function returns; you cannot
// call this function multiple times on the same @builder instance.
//
// This function is intended primarily for bindings. C code should use
// gsk_shader_args_builder_free_to_args().
func (builder *ShaderArgsBuilder) ToArgs() *glib.Bytes {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())

	ret := C.gsk_shader_args_builder_to_args(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref decreases the reference count of a ShaderArgBuilder by one. If the
// resulting reference count is zero, frees the builder.
func (builder *ShaderArgsBuilder) Unref() {
	var arg0 *C.GskShaderArgsBuilder

	arg0 = (*C.GskShaderArgsBuilder)(builder.Native())

	C.gsk_shader_args_builder_unref(arg0)
}

// Shadow: the shadow parameters in a shadow node.
type Shadow struct {
	native C.GskShadow
}

// WrapShadow wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShadow(ptr unsafe.Pointer) *Shadow {
	if ptr == nil {
		return nil
	}

	return (*Shadow)(ptr)
}

func marshalShadow(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShadow(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *Shadow) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Color gets the field inside the struct.
func (s *Shadow) Color() gdk.RGBA {
	var ret gdk.RGBA
	{
		ret = gdk.WrapRGBA(unsafe.Pointer(s.native.color))
	}
	return ret
}

// Dx gets the field inside the struct.
func (s *Shadow) Dx() float32 {
	var ret float32
	ret = float32(s.native.dx)
	return ret
}

// Dy gets the field inside the struct.
func (s *Shadow) Dy() float32 {
	var ret float32
	ret = float32(s.native.dy)
	return ret
}

// Radius gets the field inside the struct.
func (s *Shadow) Radius() float32 {
	var ret float32
	ret = float32(s.native.radius)
	return ret
}

// Transform: the `GskTransform` structure contains only private data.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	if ptr == nil {
		return nil
	}

	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTransform(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {

	ret := C.gsk_transform_new()

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Equal checks two transforms for equality.
func (first *Transform) Equal(second *Transform) bool {
	var arg0 *C.GskTransform
	var arg1 *C.GskTransform

	arg0 = (*C.GskTransform)(first.Native())
	arg1 = (*C.GskTransform)(second.Native())

	ret := C.gsk_transform_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Category returns the category this transform belongs to.
func (self *Transform) Category() TransformCategory {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(self.Native())

	ret := C.gsk_transform_get_category(arg0)

	var ret0 TransformCategory

	ret0 = TransformCategory(ret)

	return ret0
}

// Invert inverts the given transform.
//
// If @self is not invertible, nil is returned. Note that inverting nil also
// returns nil, which is the correct inverse of nil. If you need to
// differentiate between those cases, you should check @self is not nil before
// calling this function.
func (self *Transform) Invert() *Transform {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(self.Native())

	ret := C.gsk_transform_invert(arg0)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Matrix multiplies @next with the given @matrix.
func (next *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = (*C.graphene_matrix_t)(matrix.Native())

	ret := C.gsk_transform_matrix(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Perspective applies a perspective projection transform. This transform scales
// points in X and Y based on their Z value, scaling points with positive Z
// values away from the origin, and those with negative Z values towards the
// origin. Points on the z=0 plane are unchanged.
func (next *Transform) Perspective(depth float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = C.float(depth)

	ret := C.gsk_transform_perspective(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Print converts @self into a human-readable string representation suitable for
// printing that can later be parsed with gsk_transform_parse().
func (self *Transform) Print(string *glib.String) {
	var arg0 *C.GskTransform
	var arg1 *C.GString

	arg0 = (*C.GskTransform)(self.Native())
	arg1 = (*C.GString)(string.Native())

	C.gsk_transform_print(arg0, arg1)
}

// Ref acquires a reference on the given Transform.
func (self *Transform) Ref() *Transform {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(self.Native())

	ret := C.gsk_transform_ref(arg0)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
	}

	return ret0
}

// Rotate rotates @next @angle degrees in 2D - or in 3Dspeak, around the z axis.
func (next *Transform) Rotate(angle float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = C.float(angle)

	ret := C.gsk_transform_rotate(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Rotate3D rotates @next @angle degrees around @axis.
//
// For a rotation in 2D space, use gsk_transform_rotate().
func (next *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(axis.Native())

	ret := C.gsk_transform_rotate_3d(arg0, arg1, arg2)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Scale scales @next in 2-dimensional space by the given factors. Use
// gsk_transform_scale_3d() to scale in all 3 dimensions.
func (next *Transform) Scale(factorX float32, factorY float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)

	ret := C.gsk_transform_scale(arg0, arg1, arg2)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Scale3D scales @next by the given factors.
func (next *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var arg0 *C.GskTransform
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	ret := C.gsk_transform_scale_3d(arg0, arg1, arg2, arg3)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// To2D converts a Transform to a 2D transformation matrix. @self must be a 2D
// transformation. If you are not sure, use gsk_transform_get_category() >=
// GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
//    | xx yx |   |  a  b  0 |
//    | xy yy | = |  c  d  0 |
//    | dx dy |   | tx ty  1 |
//
// This function can be used to convert between a Transform and a matrix type
// from other 2D drawing libraries, in particular Cairo.
func (self *Transform) To2D() (outXX float32, outYX float32, outXY float32, outYY float32, outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out
	var arg3 *C.float // out
	var arg4 *C.float // out
	var arg5 *C.float // out
	var arg6 *C.float // out

	arg0 = (*C.GskTransform)(self.Native())

	C.gsk_transform_to_2d(arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 float32
	var ret1 float32
	var ret2 float32
	var ret3 float32
	var ret4 float32
	var ret5 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	ret2 = float32(arg3)

	ret3 = float32(arg4)

	ret4 = float32(arg5)

	ret5 = float32(arg6)

	return ret0, ret1, ret2, ret3, ret4, ret5
}

// ToAffine converts a Transform to 2D affine transformation factors. @self must
// be a 2D transformation. If you are not sure, use gsk_transform_get_category()
// >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
func (self *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out
	var arg3 *C.float // out
	var arg4 *C.float // out

	arg0 = (*C.GskTransform)(self.Native())

	C.gsk_transform_to_affine(arg0, &arg1, &arg2, &arg3, &arg4)

	var ret0 float32
	var ret1 float32
	var ret2 float32
	var ret3 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	ret2 = float32(arg3)

	ret3 = float32(arg4)

	return ret0, ret1, ret2, ret3
}

// ToMatrix computes the actual value of @self and stores it in @out_matrix. The
// previous value of @out_matrix will be ignored.
func (self *Transform) ToMatrix() graphene.Matrix {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_matrix_t // out

	arg0 = (*C.GskTransform)(self.Native())

	C.gsk_transform_to_matrix(arg0, &arg1)

	var ret0 *graphene.Matrix

	{
		ret0 = graphene.WrapMatrix(unsafe.Pointer(arg1))
	}

	return ret0
}

// String converts a matrix into a string that is suitable for printing and can
// later be parsed with gsk_transform_parse().
//
// This is a wrapper around gsk_transform_print(), see that function for
// details.
func (self *Transform) String() string {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(self.Native())

	ret := C.gsk_transform_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ToTranslate converts a Transform to a translation operation. @self must be a
// 2D transformation. If you are not sure, use gsk_transform_get_category() >=
// GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
func (self *Transform) ToTranslate() (outDx float32, outDy float32) {
	var arg0 *C.GskTransform
	var arg1 *C.float // out
	var arg2 *C.float // out

	arg0 = (*C.GskTransform)(self.Native())

	C.gsk_transform_to_translate(arg0, &arg1, &arg2)

	var ret0 float32
	var ret1 float32

	ret0 = float32(arg1)

	ret1 = float32(arg2)

	return ret0, ret1
}

// Transform applies all the operations from @other to @next.
func (next *Transform) Transform(other *Transform) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.GskTransform

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = (*C.GskTransform)(other.Native())

	ret := C.gsk_transform_transform(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// TransformBounds transforms a #graphene_rect_t using the given transform
// @self. The result is the bounding box containing the coplanar quad.
func (self *Transform) TransformBounds(rect *graphene.Rect) graphene.Rect {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.GskTransform)(self.Native())
	arg1 = (*C.graphene_rect_t)(rect.Native())

	C.gsk_transform_transform_bounds(arg0, arg1, &arg2)

	var ret0 *graphene.Rect

	{
		ret0 = graphene.WrapRect(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformPoint transforms a #graphene_point_t using the given transform
// @self.
func (self *Transform) TransformPoint(point *graphene.Point) graphene.Point {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_point_t // out

	arg0 = (*C.GskTransform)(self.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	C.gsk_transform_transform_point(arg0, arg1, &arg2)

	var ret0 *graphene.Point

	{
		ret0 = graphene.WrapPoint(unsafe.Pointer(arg2))
	}

	return ret0
}

// Translate translates @next in 2dimensional space by @point.
func (next *Transform) Translate(point *graphene.Point) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point_t

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = (*C.graphene_point_t)(point.Native())

	ret := C.gsk_transform_translate(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Translate3D translates @next by @point.
func (next *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var arg0 *C.GskTransform
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.GskTransform)(next.Native())
	arg1 = (*C.graphene_point3d_t)(point.Native())

	ret := C.gsk_transform_translate_3d(arg0, arg1)

	var ret0 *Transform

	{
		ret0 = WrapTransform(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Transform) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Unref releases a reference on the given Transform.
//
// If the reference was the last, the resources associated to the @self are
// freed.
func (self *Transform) Unref() {
	var arg0 *C.GskTransform

	arg0 = (*C.GskTransform)(self.Native())

	C.gsk_transform_unref(arg0)
}

type CairoRenderer interface {
	Renderer
}

// cairoRenderer implements the CairoRenderer interface.
type cairoRenderer struct {
	Renderer
}

var _ CairoRenderer = (*cairoRenderer)(nil)

// WrapCairoRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoRenderer(obj *externglib.Object) CairoRenderer {
	return CairoRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoRenderer(obj), nil
}

// NewCairoRenderer constructs a class CairoRenderer.
func NewCairoRenderer() CairoRenderer {

	ret := C.gsk_cairo_renderer_new()

	var ret0 CairoRenderer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(CairoRenderer)

	return ret0
}

type GLRenderer interface {
	Renderer
}

// glRenderer implements the GLRenderer interface.
type glRenderer struct {
	Renderer
}

var _ GLRenderer = (*glRenderer)(nil)

// WrapGLRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLRenderer(obj *externglib.Object) GLRenderer {
	return GLRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalGLRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLRenderer(obj), nil
}

// NewGLRenderer constructs a class GLRenderer.
func NewGLRenderer() GLRenderer {

	ret := C.gsk_gl_renderer_new()

	var ret0 GLRenderer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GLRenderer)

	return ret0
}

// GLShader: an object representing a GL shader program.
type GLShader interface {
	gextras.Objector

	// Compile tries to compile the @shader for the given @renderer, and reports
	// false with an error if there is a problem. You should use this function
	// before relying on the shader for rendering and use a fallback with a
	// simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) error
	// FindUniformByName looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgBool gets the value of the uniform @idx in the @args block. The
	// uniform must be of bool type.
	ArgBool(args *glib.Bytes, idx int) bool
	// ArgFloat gets the value of the uniform @idx in the @args block. The
	// uniform must be of float type.
	ArgFloat(args *glib.Bytes, idx int) float32
	// ArgInt gets the value of the uniform @idx in the @args block. The uniform
	// must be of int type.
	ArgInt(args *glib.Bytes, idx int) int32
	// ArgUint gets the value of the uniform @idx in the @args block. The
	// uniform must be of uint type.
	ArgUint(args *glib.Bytes, idx int) uint32
	// ArgVec2 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec2 type.
	ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2)
	// ArgVec3 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec3 type.
	ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3)
	// ArgVec4 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec4 type.
	ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4)
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// Source gets the GLSL sourcecode being used to render this shader.
	Source() *glib.Bytes
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

// glShader implements the GLShader interface.
type glShader struct {
	gextras.Objector
}

var _ GLShader = (*glShader)(nil)

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return GLShader{
		Objector: obj,
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// NewGLShaderFromBytes constructs a class GLShader.
func NewGLShaderFromBytes(sourcecode *glib.Bytes) GLShader {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(sourcecode.Native())

	ret := C.gsk_gl_shader_new_from_bytes(arg1)

	var ret0 GLShader

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GLShader)

	return ret0
}

// NewGLShaderFromResource constructs a class GLShader.
func NewGLShaderFromResource(resourcePath string) GLShader {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_new_from_resource(arg1)

	var ret0 GLShader

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(GLShader)

	return ret0
}

// Compile tries to compile the @shader for the given @renderer, and reports
// false with an error if there is a problem. You should use this function
// before relying on the shader for rendering and use a fallback with a
// simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means
// that the widget has to be realized. Commonly you want to call this from
// the realize signal of a widget, or during widget snapshot.
func (shader glShader) Compile(renderer Renderer) error {
	var arg0 *C.GskGLShader
	var arg1 *C.GskRenderer
	var gError *C.GError

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_gl_shader_compile(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// FindUniformByName looks for a uniform by the name @name, and returns the
// index of the uniform, or -1 if it was not found.
func (shader glShader) FindUniformByName(name string) int {
	var arg0 *C.GskGLShader
	var arg1 *C.char

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_find_uniform_by_name(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ArgBool gets the value of the uniform @idx in the @args block. The
// uniform must be of bool type.
func (shader glShader) ArgBool(args *glib.Bytes, idx int) bool {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_bool(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ArgFloat gets the value of the uniform @idx in the @args block. The
// uniform must be of float type.
func (shader glShader) ArgFloat(args *glib.Bytes, idx int) float32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_float(arg0, arg1, arg2)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ArgInt gets the value of the uniform @idx in the @args block. The uniform
// must be of int type.
func (shader glShader) ArgInt(args *glib.Bytes, idx int) int32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_int(arg0, arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// ArgUint gets the value of the uniform @idx in the @args block. The
// uniform must be of uint type.
func (shader glShader) ArgUint(args *glib.Bytes, idx int) uint32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_uint(arg0, arg1, arg2)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// ArgVec2 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec2 type.
func (shader glShader) ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec2_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec2_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec2(arg0, arg1, arg2, arg3)
}

// ArgVec3 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec3 type.
func (shader glShader) ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec3_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec3_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec3(arg0, arg1, arg2, arg3)
}

// ArgVec4 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec4 type.
func (shader glShader) ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec4_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec4_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec4(arg0, arg1, arg2, arg3)
}

// ArgsSize: get the size of the data block used to specify arguments for
// this shader.
func (shader glShader) ArgsSize() uint {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_args_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase.
// It is determined by looking at the highest u_textureN value that the
// shader defines.
func (shader glShader) NTextures() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_n_textures(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NUniforms: get the number of declared uniforms for this shader.
func (shader glShader) NUniforms() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_n_uniforms(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Resource gets the resource path for the GLSL sourcecode being used to
// render this shader.
func (shader glShader) Resource() string {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_resource(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Source gets the GLSL sourcecode being used to render this shader.
func (shader glShader) Source() *glib.Bytes {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_source(arg0)

	var ret0 *glib.Bytes

	{
		ret0 = glib.WrapBytes(unsafe.Pointer(ret))
	}

	return ret0
}

// UniformName: get the name of the declared uniform for this shader at
// index @idx.
func (shader glShader) UniformName(idx int) string {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
func (shader glShader) UniformOffset(idx int) int {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_offset(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UniformType: get the type of the declared uniform for this shader at
// index @idx.
func (shader glShader) UniformType(idx int) GLUniformType {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_type(arg0, arg1)

	var ret0 GLUniformType

	ret0 = GLUniformType(ret)

	return ret0
}

// Renderer: base type for the object managing the rendering pipeline for a
// Surface.
type Renderer interface {
	gextras.Objector

	// Surface retrieves the Surface set using gsk_renderer_realize(). If the
	// renderer has not been realized yet, nil will be returned.
	Surface() gdk.Surface
	// IsRealized checks whether the @renderer is realized or not.
	IsRealized() bool
	// Realize creates the resources needed by the @renderer to render the scene
	// graph.
	Realize(surface gdk.Surface) error
	// Render renders the scene graph, described by a tree of RenderNode
	// instances, ensuring that the given @region gets redrawn.
	//
	// Renderers must ensure that changes of the contents given by the @root
	// node as well as the area given by @region are redrawn. They are however
	// free to not redraw any pixel outside of @region if they can guarantee
	// that it didn't change.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	Render(root RenderNode, region *cairo.Region)
	// RenderTexture renders the scene graph, described by a tree of RenderNode
	// instances, to a Texture.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	//
	// If you want to apply any transformations to @root, you should put it into
	// a transform node and pass that node instead.
	RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture
	// Unrealize releases all the resources created by gsk_renderer_realize().
	Unrealize()
}

// renderer implements the Renderer interface.
type renderer struct {
	gextras.Objector
}

var _ Renderer = (*renderer)(nil)

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return Renderer{
		Objector: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

// NewRendererForSurface constructs a class Renderer.
func NewRendererForSurface(surface gdk.Surface) Renderer {
	var arg1 *C.GdkSurface

	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gsk_renderer_new_for_surface(arg1)

	var ret0 Renderer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Renderer)

	return ret0
}

// Surface retrieves the Surface set using gsk_renderer_realize(). If the
// renderer has not been realized yet, nil will be returned.
func (renderer renderer) Surface() gdk.Surface {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_renderer_get_surface(arg0)

	var ret0 gdk.Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gdk.Surface)

	return ret0
}

// IsRealized checks whether the @renderer is realized or not.
func (renderer renderer) IsRealized() bool {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_renderer_is_realized(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// Realize creates the resources needed by the @renderer to render the scene
// graph.
func (renderer renderer) Realize(surface gdk.Surface) error {
	var arg0 *C.GskRenderer
	var arg1 *C.GdkSurface
	var gError *C.GError

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gsk_renderer_realize(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Render renders the scene graph, described by a tree of RenderNode
// instances, ensuring that the given @region gets redrawn.
//
// Renderers must ensure that changes of the contents given by the @root
// node as well as the area given by @region are redrawn. They are however
// free to not redraw any pixel outside of @region if they can guarantee
// that it didn't change.
//
// The @renderer will acquire a reference on the RenderNode tree while the
// rendering is in progress.
func (renderer renderer) Render(root RenderNode, region *cairo.Region) {
	var arg0 *C.GskRenderer
	var arg1 *C.GskRenderNode
	var arg2 *C.cairo_region_t

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GskRenderNode)(root.Native())
	arg2 = (*C.cairo_region_t)(region.Native())

	C.gsk_renderer_render(arg0, arg1, arg2)
}

// RenderTexture renders the scene graph, described by a tree of RenderNode
// instances, to a Texture.
//
// The @renderer will acquire a reference on the RenderNode tree while the
// rendering is in progress.
//
// If you want to apply any transformations to @root, you should put it into
// a transform node and pass that node instead.
func (renderer renderer) RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture {
	var arg0 *C.GskRenderer
	var arg1 *C.GskRenderNode
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GskRenderNode)(root.Native())
	arg2 = (*C.graphene_rect_t)(viewport.Native())

	ret := C.gsk_renderer_render_texture(arg0, arg1, arg2)

	var ret0 gdk.Texture

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gdk.Texture)

	return ret0
}

// Unrealize releases all the resources created by gsk_renderer_realize().
func (renderer renderer) Unrealize() {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	C.gsk_renderer_unrealize(arg0)
}

type VulkanRenderer interface {
	Renderer
}

// vulkanRenderer implements the VulkanRenderer interface.
type vulkanRenderer struct {
	Renderer
}

var _ VulkanRenderer = (*vulkanRenderer)(nil)

// WrapVulkanRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanRenderer(obj *externglib.Object) VulkanRenderer {
	return VulkanRenderer{
		Renderer: WrapRenderer(obj),
	}
}

func marshalVulkanRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanRenderer(obj), nil
}

// NewVulkanRenderer constructs a class VulkanRenderer.
func NewVulkanRenderer() VulkanRenderer {

	ret := C.gsk_vulkan_renderer_new()

	var ret0 VulkanRenderer

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(VulkanRenderer)

	return ret0
}
