// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gsk/gsk.h>
//
// extern void gotk4_ParseErrorFunc(const GskParseLocation*, const GskParseLocation*, const GError*, gpointer)
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gsk_blend_mode_get_type()), F: marshalBlendMode},
		{T: externglib.Type(C.gsk_corner_get_type()), F: marshalCorner},
		{T: externglib.Type(C.gsk_gl_uniform_type_get_type()), F: marshalGLUniformType},
		{T: externglib.Type(C.gsk_render_node_type_get_type()), F: marshalRenderNodeType},
		{T: externglib.Type(C.gsk_scaling_filter_get_type()), F: marshalScalingFilter},
		{T: externglib.Type(C.gsk_serialization_error_get_type()), F: marshalSerializationError},
		{T: externglib.Type(C.gsk_transform_category_get_type()), F: marshalTransformCategory},

		// Records
		// Skipped CairoRendererClass.
		// Skipped ColorStop.
		// Skipped GLRendererClass.
		// Skipped GLShaderClass.
		// Skipped ParseLocation.
		// Skipped RendererClass.
		// Skipped RoundedRect.
		{T: externglib.Type(C.gsk_shader_args_builder_get_type()), F: marshalShaderArgsBuilder},
		// Skipped Shadow.
		{T: externglib.Type(C.gsk_transform_get_type()), F: marshalTransform},
		// Skipped VulkanRendererClass.

		// Classes
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNode},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNode},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNode},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNode},
		{T: externglib.Type(C.gsk_cairo_renderer_get_type()), F: marshalCairoRenderer},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNode},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNode},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNode},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNode},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNode},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNode},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNode},
		{T: externglib.Type(C.gsk_gl_renderer_get_type()), F: marshalGLRenderer},
		{T: externglib.Type(C.gsk_gl_shader_get_type()), F: marshalGLShader},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNode},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNode},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNode},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNode},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNode},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNode},
		// Skipped RenderNode.
		{T: externglib.Type(C.gsk_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNode},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNode},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNode},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNode},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNode},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNode},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNode},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNode},
		{T: externglib.Type(C.gsk_vulkan_renderer_get_type()), F: marshalVulkanRenderer},
	})
}

// BlendMode: the blend modes available for render nodes.
//
// The implementation of each blend mode is deferred to the rendering pipeline.
//
// See https://www.w3.org/TR/compositing-1/#blending for more information on
// blending and blend modes.
type BlendMode int

const (
	// BlendModeDefault: the default blend mode, which specifies no blending
	BlendModeDefault BlendMode = 0
	// BlendModeMultiply: the source color is multiplied by the destination and
	// replaces the destination
	BlendModeMultiply BlendMode = 1
	// BlendModeScreen multiplies the complements of the destination and source
	// color values, then complements the result.
	BlendModeScreen BlendMode = 2
	// BlendModeOverlay multiplies or screens the colors, depending on the
	// destination color value. This is the inverse of hard-list
	BlendModeOverlay BlendMode = 3
	// BlendModeDarken selects the darker of the destination and source colors
	BlendModeDarken BlendMode = 4
	// BlendModeLighten selects the lighter of the destination and source colors
	BlendModeLighten BlendMode = 5
	// BlendModeColorDodge brightens the destination color to reflect the source
	// color
	BlendModeColorDodge BlendMode = 6
	// BlendModeColorBurn darkens the destination color to reflect the source
	// color
	BlendModeColorBurn BlendMode = 7
	// BlendModeHardLight multiplies or screens the colors, depending on the
	// source color value
	BlendModeHardLight BlendMode = 8
	// BlendModeSoftLight darkens or lightens the colors, depending on the
	// source color value
	BlendModeSoftLight BlendMode = 9
	// BlendModeDifference subtracts the darker of the two constituent colors
	// from the lighter color
	BlendModeDifference BlendMode = 10
	// BlendModeExclusion produces an effect similar to that of the difference
	// mode but lower in contrast
	BlendModeExclusion BlendMode = 11
	// BlendModeColor creates a color with the hue and saturation of the source
	// color and the luminosity of the destination color
	BlendModeColor BlendMode = 12
	// BlendModeHue creates a color with the hue of the source color and the
	// saturation and luminosity of the destination color
	BlendModeHue BlendMode = 13
	// BlendModeSaturation creates a color with the saturation of the source
	// color and the hue and luminosity of the destination color
	BlendModeSaturation BlendMode = 14
	// BlendModeLuminosity creates a color with the luminosity of the source
	// color and the hue and saturation of the destination color
	BlendModeLuminosity BlendMode = 15
)

func marshalBlendMode(p uintptr) (interface{}, error) {
	return BlendMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Corner: the corner indices used by RoundedRect.
type Corner int

const (
	// CornerTopLeft: the top left corner
	CornerTopLeft Corner = 0
	// CornerTopRight: the top right corner
	CornerTopRight Corner = 1
	// CornerBottomRight: the bottom right corner
	CornerBottomRight Corner = 2
	// CornerBottomLeft: the bottom left corner
	CornerBottomLeft Corner = 3
)

func marshalCorner(p uintptr) (interface{}, error) {
	return Corner(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLUniformType: this defines the types of the uniforms that GLShaders declare.
// It defines both what the type is called in the GLSL shader code, and what the
// corresponding C type is on the Gtk side.
type GLUniformType int

const (
	// GLUniformTypeNone: no type, used for uninitialized or unspecified values.
	GLUniformTypeNone GLUniformType = 0
	// GLUniformTypeFloat: a float uniform
	GLUniformTypeFloat GLUniformType = 1
	// GLUniformTypeInt: a GLSL int / gint32 uniform
	GLUniformTypeInt GLUniformType = 2
	// GLUniformTypeUint: a GLSL uint / guint32 uniform
	GLUniformTypeUint GLUniformType = 3
	// GLUniformTypeBool: a GLSL bool / gboolean uniform
	GLUniformTypeBool GLUniformType = 4
	// GLUniformTypeVec2: a GLSL vec2 / graphene_vec2_t uniform
	GLUniformTypeVec2 GLUniformType = 5
	// GLUniformTypeVec3: a GLSL vec3 / graphene_vec3_t uniform
	GLUniformTypeVec3 GLUniformType = 6
	// GLUniformTypeVec4: a GLSL vec4 / graphene_vec4_t uniform
	GLUniformTypeVec4 GLUniformType = 7
)

func marshalGLUniformType(p uintptr) (interface{}, error) {
	return GLUniformType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderNodeType: the type of a node determines what the node is rendering.
type RenderNodeType int

const (
	// RenderNodeTypeNotARenderNode: error type. No node will ever have this
	// type.
	RenderNodeTypeNotARenderNode RenderNodeType = 0
	// RenderNodeTypeContainerNode: a node containing a stack of children
	RenderNodeTypeContainerNode RenderNodeType = 1
	// RenderNodeTypeCairoNode: a node drawing a #cairo_surface_t
	RenderNodeTypeCairoNode RenderNodeType = 2
	// RenderNodeTypeColorNode: a node drawing a single color rectangle
	RenderNodeTypeColorNode RenderNodeType = 3
	// RenderNodeTypeLinearGradientNode: a node drawing a linear gradient
	RenderNodeTypeLinearGradientNode RenderNodeType = 4
	// RenderNodeTypeRepeatingLinearGradientNode: a node drawing a repeating
	// linear gradient
	RenderNodeTypeRepeatingLinearGradientNode RenderNodeType = 5
	// RenderNodeTypeRadialGradientNode: a node drawing a radial gradient
	RenderNodeTypeRadialGradientNode RenderNodeType = 6
	// RenderNodeTypeRepeatingRadialGradientNode: a node drawing a repeating
	// radial gradient
	RenderNodeTypeRepeatingRadialGradientNode RenderNodeType = 7
	// RenderNodeTypeConicGradientNode: a node drawing a conic gradient
	RenderNodeTypeConicGradientNode RenderNodeType = 8
	// RenderNodeTypeBorderNode: a node stroking a border around an area
	RenderNodeTypeBorderNode RenderNodeType = 9
	// RenderNodeTypeTextureNode: a node drawing a Texture
	RenderNodeTypeTextureNode RenderNodeType = 10
	// RenderNodeTypeInsetShadowNode: a node drawing an inset shadow
	RenderNodeTypeInsetShadowNode RenderNodeType = 11
	// RenderNodeTypeOutsetShadowNode: a node drawing an outset shadow
	RenderNodeTypeOutsetShadowNode RenderNodeType = 12
	// RenderNodeTypeTransformNode: a node that renders its child after applying
	// a matrix transform
	RenderNodeTypeTransformNode RenderNodeType = 13
	// RenderNodeTypeOpacityNode: a node that changes the opacity of its child
	RenderNodeTypeOpacityNode RenderNodeType = 14
	// RenderNodeTypeColorMatrixNode: a node that applies a color matrix to
	// every pixel
	RenderNodeTypeColorMatrixNode RenderNodeType = 15
	// RenderNodeTypeRepeatNode: a node that repeats the child's contents
	RenderNodeTypeRepeatNode RenderNodeType = 16
	// RenderNodeTypeClipNode: a node that clips its child to a rectangular area
	RenderNodeTypeClipNode RenderNodeType = 17
	// RenderNodeTypeRoundedClipNode: a node that clips its child to a rounded
	// rectangle
	RenderNodeTypeRoundedClipNode RenderNodeType = 18
	// RenderNodeTypeShadowNode: a node that draws a shadow below its child
	RenderNodeTypeShadowNode RenderNodeType = 19
	// RenderNodeTypeBlendNode: a node that blends two children together
	RenderNodeTypeBlendNode RenderNodeType = 20
	// RenderNodeTypeCrossFadeNode: a node that cross-fades between two children
	RenderNodeTypeCrossFadeNode RenderNodeType = 21
	// RenderNodeTypeTextNode: a node containing a glyph string
	RenderNodeTypeTextNode RenderNodeType = 22
	// RenderNodeTypeBlurNode: a node that applies a blur
	RenderNodeTypeBlurNode RenderNodeType = 23
	// RenderNodeTypeDebugNode: debug information that does not affect the
	// rendering
	RenderNodeTypeDebugNode RenderNodeType = 24
	// RenderNodeTypeGLShaderNode: a node that uses OpenGL fragment shaders to
	// render
	RenderNodeTypeGLShaderNode RenderNodeType = 25
)

func marshalRenderNodeType(p uintptr) (interface{}, error) {
	return RenderNodeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScalingFilter: the filters used when scaling texture data.
//
// The actual implementation of each filter is deferred to the rendering
// pipeline.
type ScalingFilter int

const (
	// ScalingFilterLinear: linear interpolation filter
	ScalingFilterLinear ScalingFilter = 0
	// ScalingFilterNearest: nearest neighbor interpolation filter
	ScalingFilterNearest ScalingFilter = 1
	// ScalingFilterTrilinear: linear interpolation along each axis, plus mipmap
	// generation, with linear interpolation along the mipmap levels
	ScalingFilterTrilinear ScalingFilter = 2
)

func marshalScalingFilter(p uintptr) (interface{}, error) {
	return ScalingFilter(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SerializationError errors that can happen during (de)serialization.
type SerializationError int

const (
	// SerializationErrorUnsupportedFormat: the format can not be identified
	SerializationErrorUnsupportedFormat SerializationError = 0
	// SerializationErrorUnsupportedVersion: the version of the data is not
	// understood
	SerializationErrorUnsupportedVersion SerializationError = 1
	// SerializationErrorInvalidData: the given data may not exist in a proper
	// serialization
	SerializationErrorInvalidData SerializationError = 2
)

func marshalSerializationError(p uintptr) (interface{}, error) {
	return SerializationError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TransformCategory: the categories of matrices relevant for GSK and GTK. Note
// that any category includes matrices of all later categories. So if you want
// to for example check if a matrix is a 2D matrix, `category >=
// GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
//
// Also keep in mind that rounding errors may cause matrices to not conform to
// their categories. Otherwise, matrix operations done via mutliplication will
// not worsen categories. So for the matrix multiplication `C = A * B`,
// `category(C) = MIN (category(A), category(B))`.
type TransformCategory int

const (
	// TransformCategoryUnknown: the category of the matrix has not been
	// determined.
	TransformCategoryUnknown TransformCategory = 0
	// TransformCategoryAny: analyzing the matrix concluded that it does not fit
	// in any other category.
	TransformCategoryAny TransformCategory = 1
	// TransformCategory3D: the matrix is a 3D matrix. This means that the w
	// column (the last column) has the values (0, 0, 0, 1).
	TransformCategory3D TransformCategory = 2
	// TransformCategory2D: the matrix is a 2D matrix. This is equivalent to
	// graphene_matrix_is_2d() returning true. In particular, this means that
	// Cairo can deal with the matrix.
	TransformCategory2D TransformCategory = 3
	// TransformCategory2DAffine: the matrix is a combination of 2D scale and 2D
	// translation operations. In particular, this means that any rectangle can
	// be transformed exactly using this matrix.
	TransformCategory2DAffine TransformCategory = 4
	// TransformCategory2DTranslate: the matrix is a 2D translation.
	TransformCategory2DTranslate TransformCategory = 5
	// TransformCategoryIdentity: the matrix is the identity matrix.
	TransformCategoryIdentity TransformCategory = 6
)

func marshalTransformCategory(p uintptr) (interface{}, error) {
	return TransformCategory(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ParseErrorFunc: the type of callback that is called when a parse error occurs
// during deserialization of node data.
type ParseErrorFunc func(start *ParseLocation, end *ParseLocation, error *glib.Error)

//export gotk4_ParseErrorFunc
func gotk4_ParseErrorFunc(arg0 *C.GskParseLocation, arg1 *C.GskParseLocation, arg2 *C.GError, arg3 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var start *ParseLocation
	var end *ParseLocation
	var error *glib.Error

	start = WrapParseLocation(arg0)

	end = WrapParseLocation(arg1)

	error = glib.WrapError(arg2)

	v.(ParseErrorFunc)(start, end, error)
}

func SerializationErrorQuark() glib.Quark {

	ret := C.gsk_serialization_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// TransformParse parses the given @string into a transform and puts it in
// @out_transform. Strings printed via gsk_transform_to_string() can be read in
// again successfully using this function.
//
// If @string does not describe a valid transform, false is returned and nil is
// put in @out_transform.
func TransformParse(string string) (outTransform *Transform, ok bool) {
	var arg1 *C.char
	var arg2 **C.GskTransform // out

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_transform_parse(arg1, &arg2)

	var ret0 **Transform
	var ret1 bool

	ret0 = WrapTransform(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ColorStop: a color stop in a gradient node.
type ColorStop struct {
	native C.GskColorStop
}

// WrapColorStop wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColorStop(ptr unsafe.Pointer) *ColorStop {
	if ptr == nil {
		return nil
	}

	return (*ColorStop)(ptr)
}

func marshalColorStop(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColorStop(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (c *ColorStop) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Offset gets the field inside the struct.
func (o *ColorStop) Offset() float32 {
	var ret float32
	ret = float32(c.native.offset)
	return ret
}

// Color gets the field inside the struct.
func (c *ColorStop) Color() gdk.RGBA {
	var ret gdk.RGBA
	ret = gdk.WrapRGBA(c.native.color)
	return ret
}

// ParseLocation: a location in a parse buffer.
type ParseLocation struct {
	native C.GskParseLocation
}

// WrapParseLocation wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParseLocation(ptr unsafe.Pointer) *ParseLocation {
	if ptr == nil {
		return nil
	}

	return (*ParseLocation)(ptr)
}

func marshalParseLocation(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapParseLocation(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *ParseLocation) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Bytes gets the field inside the struct.
func (b *ParseLocation) Bytes() uint {
	var ret uint
	ret = uint(p.native.bytes)
	return ret
}

// Chars gets the field inside the struct.
func (c *ParseLocation) Chars() uint {
	var ret uint
	ret = uint(p.native.chars)
	return ret
}

// Lines gets the field inside the struct.
func (l *ParseLocation) Lines() uint {
	var ret uint
	ret = uint(p.native.lines)
	return ret
}

// LineBytes gets the field inside the struct.
func (l *ParseLocation) LineBytes() uint {
	var ret uint
	ret = uint(p.native.line_bytes)
	return ret
}

// LineChars gets the field inside the struct.
func (l *ParseLocation) LineChars() uint {
	var ret uint
	ret = uint(p.native.line_chars)
	return ret
}

// RoundedRect: a rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// gsk_rounded_rect_normalize(); this function will ensure that the bounds of
// the rectangle are normalized and ensure that the corner values are positive
// and the corners do not overlap. All functions taking a RoundedRect as an
// argument will internally operate on a normalized copy; all functions
// returning a RoundedRect will always return a normalized one.
type RoundedRect struct {
	native C.GskRoundedRect
}

// WrapRoundedRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRoundedRect(ptr unsafe.Pointer) *RoundedRect {
	if ptr == nil {
		return nil
	}

	return (*RoundedRect)(ptr)
}

func marshalRoundedRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRoundedRect(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *RoundedRect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Bounds gets the field inside the struct.
func (b *RoundedRect) Bounds() graphene.Rect {
	var ret graphene.Rect
	ret = graphene.WrapRect(r.native.bounds)
	return ret
}

// Corner gets the field inside the struct.
func (c *RoundedRect) Corner() [4]graphene.Size {
	var ret [4]graphene.Size
	{
		cArray := ([4]graphene_size_t)(r.native.corner)

		for i := 0; i < 4; i++ {
			src := cArray[i]
			ret[i] = graphene.WrapSize(src)
		}
	}
	return ret
}

// ShaderArgsBuilder: an object to build the uniforms data for a GLShader.
type ShaderArgsBuilder struct {
	native C.GskShaderArgsBuilder
}

// WrapShaderArgsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShaderArgsBuilder(ptr unsafe.Pointer) *ShaderArgsBuilder {
	if ptr == nil {
		return nil
	}

	return (*ShaderArgsBuilder)(ptr)
}

func marshalShaderArgsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShaderArgsBuilder(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *ShaderArgsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// New_ constructs a struct ShaderArgsBuilder.
func New_(shader GLShader, initialValues *glib.Bytes) *ShaderArgsBuilder {
	var arg1 *C.GskGLShader
	var arg2 *C.GBytes

	arg1 = (*C.GskGLShader)(shader.Native())
	arg2 = (*C.GBytes)(initialValues.Native())

	ret := C.gsk_shader_args_builder_new(arg1, arg2)

	var ret0 *ShaderArgsBuilder

	ret0 = WrapShaderArgsBuilder(ret)

	return ret0
}

// Shadow: the shadow parameters in a shadow node.
type Shadow struct {
	native C.GskShadow
}

// WrapShadow wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapShadow(ptr unsafe.Pointer) *Shadow {
	if ptr == nil {
		return nil
	}

	return (*Shadow)(ptr)
}

func marshalShadow(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapShadow(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *Shadow) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Color gets the field inside the struct.
func (c *Shadow) Color() gdk.RGBA {
	var ret gdk.RGBA
	ret = gdk.WrapRGBA(s.native.color)
	return ret
}

// Dx gets the field inside the struct.
func (d *Shadow) Dx() float32 {
	var ret float32
	ret = float32(s.native.dx)
	return ret
}

// Dy gets the field inside the struct.
func (d *Shadow) Dy() float32 {
	var ret float32
	ret = float32(s.native.dy)
	return ret
}

// Radius gets the field inside the struct.
func (r *Shadow) Radius() float32 {
	var ret float32
	ret = float32(s.native.radius)
	return ret
}

// Transform: the `GskTransform` structure contains only private data.
type Transform struct {
	native C.GskTransform
}

// WrapTransform wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTransform(ptr unsafe.Pointer) *Transform {
	if ptr == nil {
		return nil
	}

	return (*Transform)(ptr)
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTransform(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *Transform) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// New_ constructs a struct Transform.
func New_() *Transform {

	ret := C.gsk_transform_new()

	var ret0 *Transform

	ret0 = WrapTransform(ret)

	return ret0
}

// BlendNode: a render node applying a blending function between its two child
// nodes.
type BlendNode interface {
	RenderNode

	// BlendMode retrieves the blend mode used by @node.
	BlendMode() BlendMode
	// BottomChild retrieves the bottom RenderNode child of the @node.
	BottomChild() RenderNode
	// TopChild retrieves the top RenderNode child of the @node.
	TopChild() RenderNode
}

type blendNode struct {
	renderNode
}

// WrapBlendNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlendNode(obj *externglib.Object) BlendNode {
	return blendNode{renderNode{obj}}
}

func marshalBlendNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlendNode(obj), nil
}

// New_ constructs a class BlendNode.
func New_(bottom RenderNode, top RenderNode, blendMode BlendMode) BlendNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.GskRenderNode
	var arg3 C.GskBlendMode

	arg1 = (*C.GskRenderNode)(bottom.Native())
	arg2 = (*C.GskRenderNode)(top.Native())
	arg3 = (C.GskBlendMode)(blendMode)

	ret := C.gsk_blend_node_new(arg1, arg2, arg3)

	var ret0 BlendNode

	ret0 = WrapBlendNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BlendMode retrieves the blend mode used by @node.
func (node blendNode) BlendMode() BlendMode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_blend_node_get_blend_mode(arg0)

	var ret0 BlendMode

	ret0 = BlendMode(ret)

	return ret0
}

// BottomChild retrieves the bottom RenderNode child of the @node.
func (node blendNode) BottomChild() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_blend_node_get_bottom_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TopChild retrieves the top RenderNode child of the @node.
func (node blendNode) TopChild() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_blend_node_get_top_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BlurNode: a render node applying a blur effect to its single child.
type BlurNode interface {
	RenderNode

	// Child retrieves the child RenderNode of the blur @node.
	Child() RenderNode
	// Radius retrieves the blur radius of the @node.
	Radius() float32
}

type blurNode struct {
	renderNode
}

// WrapBlurNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBlurNode(obj *externglib.Object) BlurNode {
	return blurNode{renderNode{obj}}
}

func marshalBlurNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBlurNode(obj), nil
}

// New_ constructs a class BlurNode.
func New_(child RenderNode, radius float32) BlurNode {
	var arg1 *C.GskRenderNode
	var arg2 C.float

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = C.float(radius)

	ret := C.gsk_blur_node_new(arg1, arg2)

	var ret0 BlurNode

	ret0 = WrapBlurNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child retrieves the child RenderNode of the blur @node.
func (node blurNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_blur_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Radius retrieves the blur radius of the @node.
func (node blurNode) Radius() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_blur_node_get_radius(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// BorderNode: a render node for a border.
type BorderNode interface {
	RenderNode

	// Colors retrieves the colors of the border.
	Colors() *gdk.RGBA
	// Outline retrieves the outline of the border.
	Outline() *RoundedRect
	// Widths retrieves the stroke widths of the border.
	Widths() [4]float32
}

type borderNode struct {
	renderNode
}

// WrapBorderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapBorderNode(obj *externglib.Object) BorderNode {
	return borderNode{renderNode{obj}}
}

func marshalBorderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBorderNode(obj), nil
}

// New_ constructs a class BorderNode.
func New_(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) BorderNode {
	var arg1 *C.GskRoundedRect
	var arg2 *C.float
	var arg3 *C.GdkRGBA

	arg1 = (*C.GskRoundedRect)(outline.Native())
	{
		arg2 = (*C.float)(&borderWidth)
		defer runtime.KeepAlive(&borderWidth)
	}
	{
		dst := &arg3

		for i := 0; i < 4; i++ {
			src := borderColor[i]
			dst[i] = (C.GdkRGBA)(src.Native())
		}
	}

	ret := C.gsk_border_node_new(arg1, arg2, arg3)

	var ret0 BorderNode

	ret0 = WrapBorderNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Colors retrieves the colors of the border.
func (node borderNode) Colors() *gdk.RGBA {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_border_node_get_colors(arg0)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(ret)

	return ret0
}

// Outline retrieves the outline of the border.
func (node borderNode) Outline() *RoundedRect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_border_node_get_outline(arg0)

	var ret0 *RoundedRect

	ret0 = WrapRoundedRect(ret)

	return ret0
}

// Widths retrieves the stroke widths of the border.
func (node borderNode) Widths() [4]float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_border_node_get_widths(arg0)

	var ret0 [4]float32

	ret0 = [4]float32(ret)

	return ret0
}

// CairoNode: a render node for a Cairo surface.
type CairoNode interface {
	RenderNode

	// DrawContext creates a Cairo context for drawing using the surface
	// associated to the render node.
	//
	// If no surface exists yet, a surface will be created optimized for
	// rendering to @renderer.
	DrawContext() *cairo.Context
	// Surface retrieves the Cairo surface used by the render node.
	Surface() *cairo.Surface
}

type cairoNode struct {
	renderNode
}

// WrapCairoNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoNode(obj *externglib.Object) CairoNode {
	return cairoNode{renderNode{obj}}
}

func marshalCairoNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoNode(obj), nil
}

// New_ constructs a class CairoNode.
func New_(bounds *graphene.Rect) CairoNode {
	var arg1 *C.graphene_rect_t

	arg1 = (*C.graphene_rect_t)(bounds.Native())

	ret := C.gsk_cairo_node_new(arg1)

	var ret0 CairoNode

	ret0 = WrapCairoNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DrawContext creates a Cairo context for drawing using the surface
// associated to the render node.
//
// If no surface exists yet, a surface will be created optimized for
// rendering to @renderer.
func (node cairoNode) DrawContext() *cairo.Context {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_cairo_node_get_draw_context(arg0)

	var ret0 *cairo.Context

	ret0 = cairo.WrapContext(ret)

	return ret0
}

// Surface retrieves the Cairo surface used by the render node.
func (node cairoNode) Surface() *cairo.Surface {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_cairo_node_get_surface(arg0)

	var ret0 *cairo.Surface

	ret0 = cairo.WrapSurface(ret)

	return ret0
}

type CairoRenderer interface {
	Renderer
}

type cairoRenderer struct {
	renderer
}

// WrapCairoRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoRenderer(obj *externglib.Object) CairoRenderer {
	return cairoRenderer{renderer{*externglib.Object{obj}}}
}

func marshalCairoRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoRenderer(obj), nil
}

// New_ constructs a class CairoRenderer.
func New_() Renderer {

	ret := C.gsk_cairo_renderer_new()

	var ret0 Renderer

	ret0 = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClipNode: a render node applying a rectangular clip to its single child node.
type ClipNode interface {
	RenderNode

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrieves the clip rectangle for @node.
	Clip() *graphene.Rect
}

type clipNode struct {
	renderNode
}

// WrapClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipNode(obj *externglib.Object) ClipNode {
	return clipNode{renderNode{obj}}
}

func marshalClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipNode(obj), nil
}

// New_ constructs a class ClipNode.
func New_(child RenderNode, clip *graphene.Rect) ClipNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.graphene_rect_t

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = (*C.graphene_rect_t)(clip.Native())

	ret := C.gsk_clip_node_new(arg1, arg2)

	var ret0 ClipNode

	ret0 = WrapClipNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting clipped by the given @node.
func (node clipNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_clip_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Clip retrieves the clip rectangle for @node.
func (node clipNode) Clip() *graphene.Rect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_clip_node_get_clip(arg0)

	var ret0 *graphene.Rect

	ret0 = graphene.WrapRect(ret)

	return ret0
}

// ColorMatrixNode: a render node controlling the color matrix of its single
// child node.
type ColorMatrixNode interface {
	RenderNode

	// Child gets the child node that is getting its colors modified by the
	// given @node.
	Child() RenderNode
	// ColorMatrix retrieves the color matrix used by the @node.
	ColorMatrix() *graphene.Matrix
	// ColorOffset retrieves the color offset used by the @node.
	ColorOffset() *graphene.Vec4
}

type colorMatrixNode struct {
	renderNode
}

// WrapColorMatrixNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorMatrixNode(obj *externglib.Object) ColorMatrixNode {
	return colorMatrixNode{renderNode{obj}}
}

func marshalColorMatrixNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorMatrixNode(obj), nil
}

// New_ constructs a class ColorMatrixNode.
func New_(child RenderNode, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) ColorMatrixNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.graphene_matrix_t
	var arg3 *C.graphene_vec4_t

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = (*C.graphene_matrix_t)(colorMatrix.Native())
	arg3 = (*C.graphene_vec4_t)(colorOffset.Native())

	ret := C.gsk_color_matrix_node_new(arg1, arg2, arg3)

	var ret0 ColorMatrixNode

	ret0 = WrapColorMatrixNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting its colors modified by the
// given @node.
func (node colorMatrixNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_color_matrix_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColorMatrix retrieves the color matrix used by the @node.
func (node colorMatrixNode) ColorMatrix() *graphene.Matrix {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_color_matrix_node_get_color_matrix(arg0)

	var ret0 *graphene.Matrix

	ret0 = graphene.WrapMatrix(ret)

	return ret0
}

// ColorOffset retrieves the color offset used by the @node.
func (node colorMatrixNode) ColorOffset() *graphene.Vec4 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_color_matrix_node_get_color_offset(arg0)

	var ret0 *graphene.Vec4

	ret0 = graphene.WrapVec4(ret)

	return ret0
}

// ColorNode: a render node for a solid color.
type ColorNode interface {
	RenderNode

	// Color retrieves the color of the given @node.
	Color() *gdk.RGBA
}

type colorNode struct {
	renderNode
}

// WrapColorNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapColorNode(obj *externglib.Object) ColorNode {
	return colorNode{renderNode{obj}}
}

func marshalColorNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapColorNode(obj), nil
}

// New_ constructs a class ColorNode.
func New_(rgba *gdk.RGBA, bounds *graphene.Rect) ColorNode {
	var arg1 *C.GdkRGBA
	var arg2 *C.graphene_rect_t

	arg1 = (*C.GdkRGBA)(rgba.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	ret := C.gsk_color_node_new(arg1, arg2)

	var ret0 ColorNode

	ret0 = WrapColorNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Color retrieves the color of the given @node.
func (node colorNode) Color() *gdk.RGBA {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_color_node_get_color(arg0)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(ret)

	return ret0
}

// ConicGradientNode: a render node for a conic gradient.
type ConicGradientNode interface {
	RenderNode

	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// ColorStops retrieves the color stops in the gradient.
	ColorStops() (nStops uint, colorStops []ColorStop)
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Rotation retrieves the rotation for the gradient in degrees.
	Rotation() float32
}

type conicGradientNode struct {
	renderNode
}

// WrapConicGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapConicGradientNode(obj *externglib.Object) ConicGradientNode {
	return conicGradientNode{renderNode{obj}}
}

func marshalConicGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConicGradientNode(obj), nil
}

// New_ constructs a class ConicGradientNode.
func New_(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) ConicGradientNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(rotation)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(colorStops))))
		sliceHeader.Len = len(colorStops)
		sliceHeader.Cap = len(colorStops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(colorStops); i++ {
			src := colorStops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(colorStops)
	}

	ret := C.gsk_conic_gradient_node_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 ConicGradientNode

	ret0 = WrapConicGradientNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Center retrieves the center pointer for the gradient.
func (node conicGradientNode) Center() *graphene.Point {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_conic_gradient_node_get_center(arg0)

	var ret0 *graphene.Point

	ret0 = graphene.WrapPoint(ret)

	return ret0
}

// ColorStops retrieves the color stops in the gradient.
func (node conicGradientNode) ColorStops() (nStops uint, colorStops []ColorStop) {
	var arg0 *C.GskRenderNode
	var arg1 *C.gsize // out

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_conic_gradient_node_get_color_stops(arg0, &arg1)

	var ret0 uint
	var ret1 []ColorStop

	ret0 = uint(arg1)

	{
		ret1 = make([]ColorStop, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GskColorStop)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = WrapColorStop(src)
		}
	}

	return ret0, ret1
}

// NColorStops retrieves the number of color stops in the gradient.
func (node conicGradientNode) NColorStops() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_conic_gradient_node_get_n_color_stops(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Rotation retrieves the rotation for the gradient in degrees.
func (node conicGradientNode) Rotation() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_conic_gradient_node_get_rotation(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ContainerNode: a render node that can contain other render nodes.
type ContainerNode interface {
	RenderNode

	// Child gets one of the children of @container.
	Child(idx uint) RenderNode
	// NChildren retrieves the number of direct children of @node.
	NChildren() uint
}

type containerNode struct {
	renderNode
}

// WrapContainerNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapContainerNode(obj *externglib.Object) ContainerNode {
	return containerNode{renderNode{obj}}
}

func marshalContainerNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContainerNode(obj), nil
}

// New_ constructs a class ContainerNode.
func New_(children []RenderNode) ContainerNode {
	var arg1 **C.GskRenderNode
	var arg2 C.guint

	{
		var dst []*C.GskRenderNode
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(children))))
		sliceHeader.Len = len(children)
		sliceHeader.Cap = len(children)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(children); i++ {
			src := children[i]
			dst[i] = (*C.GskRenderNode)(src.Native())
		}

		arg1 = (**C.GskRenderNode)(unsafe.Pointer(sliceHeader.Data))
		arg2 = len(children)
	}

	ret := C.gsk_container_node_new(arg1, arg2)

	var ret0 ContainerNode

	ret0 = WrapContainerNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets one of the children of @container.
func (node containerNode) Child(idx uint) RenderNode {
	var arg0 *C.GskRenderNode
	var arg1 C.guint

	arg0 = (*C.GskRenderNode)(node.Native())
	arg1 = C.guint(idx)

	ret := C.gsk_container_node_get_child(arg0, arg1)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NChildren retrieves the number of direct children of @node.
func (node containerNode) NChildren() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_container_node_get_n_children(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// CrossFadeNode: a render node cross fading between two child nodes.
type CrossFadeNode interface {
	RenderNode

	// EndChild retrieves the child RenderNode at the end of the cross-fade.
	EndChild() RenderNode
	// Progress retrieves the progress value of the cross fade.
	Progress() float32
	// StartChild retrieves the child RenderNode at the beginning of the
	// cross-fade.
	StartChild() RenderNode
}

type crossFadeNode struct {
	renderNode
}

// WrapCrossFadeNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapCrossFadeNode(obj *externglib.Object) CrossFadeNode {
	return crossFadeNode{renderNode{obj}}
}

func marshalCrossFadeNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCrossFadeNode(obj), nil
}

// New_ constructs a class CrossFadeNode.
func New_(start RenderNode, end RenderNode, progress float32) CrossFadeNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.GskRenderNode
	var arg3 C.float

	arg1 = (*C.GskRenderNode)(start.Native())
	arg2 = (*C.GskRenderNode)(end.Native())
	arg3 = C.float(progress)

	ret := C.gsk_cross_fade_node_new(arg1, arg2, arg3)

	var ret0 CrossFadeNode

	ret0 = WrapCrossFadeNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// EndChild retrieves the child RenderNode at the end of the cross-fade.
func (node crossFadeNode) EndChild() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_cross_fade_node_get_end_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Progress retrieves the progress value of the cross fade.
func (node crossFadeNode) Progress() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_cross_fade_node_get_progress(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// StartChild retrieves the child RenderNode at the beginning of the
// cross-fade.
func (node crossFadeNode) StartChild() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_cross_fade_node_get_start_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DebugNode: a render node that emits a debugging message when drawing its
// child node.
type DebugNode interface {
	RenderNode

	// Child gets the child node that is getting drawn by the given @node.
	Child() RenderNode
	// Message gets the debug message that was set on this node
	Message() string
}

type debugNode struct {
	renderNode
}

// WrapDebugNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapDebugNode(obj *externglib.Object) DebugNode {
	return debugNode{renderNode{obj}}
}

func marshalDebugNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDebugNode(obj), nil
}

// New_ constructs a class DebugNode.
func New_(child RenderNode, message string) DebugNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.char

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = (*C.gchar)(C.CString(message))

	ret := C.gsk_debug_node_new(arg1, arg2)

	var ret0 DebugNode

	ret0 = WrapDebugNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting drawn by the given @node.
func (node debugNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_debug_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Message gets the debug message that was set on this node
func (node debugNode) Message() string {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_debug_node_get_message(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

type GLRenderer interface {
	Renderer
}

type glRenderer struct {
	renderer
}

// WrapGLRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLRenderer(obj *externglib.Object) GLRenderer {
	return glRenderer{renderer{*externglib.Object{obj}}}
}

func marshalGLRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLRenderer(obj), nil
}

// New_ constructs a class GLRenderer.
func New_() Renderer {

	ret := C.gsk_gl_renderer_new()

	var ret0 Renderer

	ret0 = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// GLShader: an object representing a GL shader program.
type GLShader interface {
	gextras.Objector

	// Compile tries to compile the @shader for the given @renderer, and reports
	// false with an error if there is a problem. You should use this function
	// before relying on the shader for rendering and use a fallback with a
	// simpler shader or without shaders if it fails.
	//
	// Note that this will modify the rendering state (for example change the
	// current GL context) and requires the renderer to be set up. This means
	// that the widget has to be realized. Commonly you want to call this from
	// the realize signal of a widget, or during widget snapshot.
	Compile(renderer Renderer) bool
	// FindUniformByName looks for a uniform by the name @name, and returns the
	// index of the uniform, or -1 if it was not found.
	FindUniformByName(name string) int
	// ArgBool gets the value of the uniform @idx in the @args block. The
	// uniform must be of bool type.
	ArgBool(args *glib.Bytes, idx int) bool
	// ArgFloat gets the value of the uniform @idx in the @args block. The
	// uniform must be of float type.
	ArgFloat(args *glib.Bytes, idx int) float32
	// ArgInt gets the value of the uniform @idx in the @args block. The uniform
	// must be of int type.
	ArgInt(args *glib.Bytes, idx int) int32
	// ArgUint gets the value of the uniform @idx in the @args block. The
	// uniform must be of uint type.
	ArgUint(args *glib.Bytes, idx int) uint32
	// ArgVec2 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec2 type.
	ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2)
	// ArgVec3 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec3 type.
	ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3)
	// ArgVec4 gets the value of the uniform @idx in the @args block. The
	// uniform must be of vec4 type.
	ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4)
	// ArgsSize: get the size of the data block used to specify arguments for
	// this shader.
	ArgsSize() uint
	// NTextures returns the number of textures that the shader requires.
	//
	// This can be used to check that the a passed shader works in your usecase.
	// It is determined by looking at the highest u_textureN value that the
	// shader defines.
	NTextures() int
	// NUniforms: get the number of declared uniforms for this shader.
	NUniforms() int
	// Resource gets the resource path for the GLSL sourcecode being used to
	// render this shader.
	Resource() string
	// Source gets the GLSL sourcecode being used to render this shader.
	Source() *glib.Bytes
	// UniformName: get the name of the declared uniform for this shader at
	// index @idx.
	UniformName(idx int) string
	// UniformOffset: get the offset into the data block where data for this
	// uniforms is stored.
	UniformOffset(idx int) int
	// UniformType: get the type of the declared uniform for this shader at
	// index @idx.
	UniformType(idx int) GLUniformType
}

type glShader struct {
	*externglib.Object
}

// WrapGLShader wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShader(obj *externglib.Object) GLShader {
	return glShader{*externglib.Object{obj}}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShader(obj), nil
}

// New_FromBytes constructs a class GLShader.
func New_FromBytes(sourcecode *glib.Bytes) GLShader {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(sourcecode.Native())

	ret := C.gsk_gl_shader_new_from_bytes(arg1)

	var ret0 GLShader

	ret0 = WrapGLShader(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// New_FromResource constructs a class GLShader.
func New_FromResource(resourcePath string) GLShader {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_new_from_resource(arg1)

	var ret0 GLShader

	ret0 = WrapGLShader(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Compile tries to compile the @shader for the given @renderer, and reports
// false with an error if there is a problem. You should use this function
// before relying on the shader for rendering and use a fallback with a
// simpler shader or without shaders if it fails.
//
// Note that this will modify the rendering state (for example change the
// current GL context) and requires the renderer to be set up. This means
// that the widget has to be realized. Commonly you want to call this from
// the realize signal of a widget, or during widget snapshot.
func (shader glShader) Compile(renderer Renderer) bool {
	var arg0 *C.GskGLShader
	var arg1 *C.GskRenderer

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_gl_shader_compile(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FindUniformByName looks for a uniform by the name @name, and returns the
// index of the uniform, or -1 if it was not found.
func (shader glShader) FindUniformByName(name string) int {
	var arg0 *C.GskGLShader
	var arg1 *C.char

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gsk_gl_shader_find_uniform_by_name(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ArgBool gets the value of the uniform @idx in the @args block. The
// uniform must be of bool type.
func (shader glShader) ArgBool(args *glib.Bytes, idx int) bool {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_bool(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ArgFloat gets the value of the uniform @idx in the @args block. The
// uniform must be of float type.
func (shader glShader) ArgFloat(args *glib.Bytes, idx int) float32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_float(arg0, arg1, arg2)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ArgInt gets the value of the uniform @idx in the @args block. The uniform
// must be of int type.
func (shader glShader) ArgInt(args *glib.Bytes, idx int) int32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_int(arg0, arg1, arg2)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// ArgUint gets the value of the uniform @idx in the @args block. The
// uniform must be of uint type.
func (shader glShader) ArgUint(args *glib.Bytes, idx int) uint32 {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)

	ret := C.gsk_gl_shader_get_arg_uint(arg0, arg1, arg2)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// ArgVec2 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec2 type.
func (shader glShader) ArgVec2(args *glib.Bytes, idx int, outValue *graphene.Vec2) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec2_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec2_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec2(arg0, arg1, arg2, arg3)
}

// ArgVec3 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec3 type.
func (shader glShader) ArgVec3(args *glib.Bytes, idx int, outValue *graphene.Vec3) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec3_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec3_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec3(arg0, arg1, arg2, arg3)
}

// ArgVec4 gets the value of the uniform @idx in the @args block. The
// uniform must be of vec4 type.
func (shader glShader) ArgVec4(args *glib.Bytes, idx int, outValue *graphene.Vec4) {
	var arg0 *C.GskGLShader
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.graphene_vec4_t

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = (*C.GBytes)(args.Native())
	arg2 = C.int(idx)
	arg3 = (*C.graphene_vec4_t)(outValue.Native())

	C.gsk_gl_shader_get_arg_vec4(arg0, arg1, arg2, arg3)
}

// ArgsSize: get the size of the data block used to specify arguments for
// this shader.
func (shader glShader) ArgsSize() uint {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_args_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// NTextures returns the number of textures that the shader requires.
//
// This can be used to check that the a passed shader works in your usecase.
// It is determined by looking at the highest u_textureN value that the
// shader defines.
func (shader glShader) NTextures() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_n_textures(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// NUniforms: get the number of declared uniforms for this shader.
func (shader glShader) NUniforms() int {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_n_uniforms(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Resource gets the resource path for the GLSL sourcecode being used to
// render this shader.
func (shader glShader) Resource() string {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_resource(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Source gets the GLSL sourcecode being used to render this shader.
func (shader glShader) Source() *glib.Bytes {
	var arg0 *C.GskGLShader

	arg0 = (*C.GskGLShader)(shader.Native())

	ret := C.gsk_gl_shader_get_source(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// UniformName: get the name of the declared uniform for this shader at
// index @idx.
func (shader glShader) UniformName(idx int) string {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UniformOffset: get the offset into the data block where data for this
// uniforms is stored.
func (shader glShader) UniformOffset(idx int) int {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_offset(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UniformType: get the type of the declared uniform for this shader at
// index @idx.
func (shader glShader) UniformType(idx int) GLUniformType {
	var arg0 *C.GskGLShader
	var arg1 C.int

	arg0 = (*C.GskGLShader)(shader.Native())
	arg1 = C.int(idx)

	ret := C.gsk_gl_shader_get_uniform_type(arg0, arg1)

	var ret0 GLUniformType

	ret0 = GLUniformType(ret)

	return ret0
}

// GLShaderNode: a render node using a GL shader when drawing its children
// nodes.
type GLShaderNode interface {
	RenderNode

	// Args gets args for the node.
	Args() *glib.Bytes
	// Child gets one of the children.
	Child(idx uint) RenderNode
	// NChildren returns the number of children
	NChildren() uint
	// Shader gets shader code for the node.
	Shader() GLShader
}

type glShaderNode struct {
	renderNode
}

// WrapGLShaderNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLShaderNode(obj *externglib.Object) GLShaderNode {
	return glShaderNode{renderNode{obj}}
}

func marshalGLShaderNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLShaderNode(obj), nil
}

// New_ constructs a class GLShaderNode.
func New_(shader GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNode) GLShaderNode {
	var arg1 *C.GskGLShader
	var arg2 *C.graphene_rect_t
	var arg3 *C.GBytes
	var arg4 **C.GskRenderNode
	var arg5 C.guint

	arg1 = (*C.GskGLShader)(shader.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())
	arg3 = (*C.GBytes)(args.Native())
	{
		var dst []*C.GskRenderNode
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(children))))
		sliceHeader.Len = len(children)
		sliceHeader.Cap = len(children)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(children); i++ {
			src := children[i]
			dst[i] = (*C.GskRenderNode)(src.Native())
		}

		arg4 = (**C.GskRenderNode)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(children)
	}

	ret := C.gsk_gl_shader_node_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 GLShaderNode

	ret0 = WrapGLShaderNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Args gets args for the node.
func (node glShaderNode) Args() *glib.Bytes {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_gl_shader_node_get_args(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// Child gets one of the children.
func (node glShaderNode) Child(idx uint) RenderNode {
	var arg0 *C.GskRenderNode
	var arg1 C.guint

	arg0 = (*C.GskRenderNode)(node.Native())
	arg1 = C.guint(idx)

	ret := C.gsk_gl_shader_node_get_child(arg0, arg1)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NChildren returns the number of children
func (node glShaderNode) NChildren() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_gl_shader_node_get_n_children(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Shader gets shader code for the node.
func (node glShaderNode) Shader() GLShader {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_gl_shader_node_get_shader(arg0)

	var ret0 GLShader

	ret0 = WrapGLShader(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// InsetShadowNode: a render node for an inset shadow.
type InsetShadowNode interface {
	RenderNode

	// BlurRadius retrieves the blur radius to apply to the shadow.
	BlurRadius() float32
	// Color retrieves the color of the inset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the inset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the inset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the inset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads inwards.
	Spread() float32
}

type insetShadowNode struct {
	renderNode
}

// WrapInsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapInsetShadowNode(obj *externglib.Object) InsetShadowNode {
	return insetShadowNode{renderNode{obj}}
}

func marshalInsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInsetShadowNode(obj), nil
}

// New_ constructs a class InsetShadowNode.
func New_(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) InsetShadowNode {
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg1 = (*C.GskRoundedRect)(outline.Native())
	arg2 = (*C.GdkRGBA)(color.Native())
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	ret := C.gsk_inset_shadow_node_new(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 InsetShadowNode

	ret0 = WrapInsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BlurRadius retrieves the blur radius to apply to the shadow.
func (node insetShadowNode) BlurRadius() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_blur_radius(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Color retrieves the color of the inset shadow.
func (node insetShadowNode) Color() *gdk.RGBA {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_color(arg0)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(ret)

	return ret0
}

// Dx retrieves the horizontal offset of the inset shadow.
func (node insetShadowNode) Dx() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_dx(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Dy retrieves the vertical offset of the inset shadow.
func (node insetShadowNode) Dy() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_dy(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Outline retrieves the outline rectangle of the inset shadow.
func (node insetShadowNode) Outline() *RoundedRect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_outline(arg0)

	var ret0 *RoundedRect

	ret0 = WrapRoundedRect(ret)

	return ret0
}

// Spread retrieves how much the shadow spreads inwards.
func (node insetShadowNode) Spread() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_inset_shadow_node_get_spread(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// LinearGradientNode: a render node for a linear gradient.
type LinearGradientNode interface {
	RenderNode

	// ColorStops retrieves the color stops in the gradient.
	ColorStops() (nStops uint, colorStops []ColorStop)
	// End retrieves the final point of the linear gradient.
	End() *graphene.Point
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the initial point of the linear gradient.
	Start() *graphene.Point
}

type linearGradientNode struct {
	renderNode
}

// WrapLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapLinearGradientNode(obj *externglib.Object) LinearGradientNode {
	return linearGradientNode{renderNode{obj}}
}

func marshalLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLinearGradientNode(obj), nil
}

// New_ constructs a class LinearGradientNode.
func New_(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) LinearGradientNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(start.Native())
	arg3 = (*C.graphene_point_t)(end.Native())
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(colorStops))))
		sliceHeader.Len = len(colorStops)
		sliceHeader.Cap = len(colorStops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(colorStops); i++ {
			src := colorStops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(colorStops)
	}

	ret := C.gsk_linear_gradient_node_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 LinearGradientNode

	ret0 = WrapLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ColorStops retrieves the color stops in the gradient.
func (node linearGradientNode) ColorStops() (nStops uint, colorStops []ColorStop) {
	var arg0 *C.GskRenderNode
	var arg1 *C.gsize // out

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_linear_gradient_node_get_color_stops(arg0, &arg1)

	var ret0 uint
	var ret1 []ColorStop

	ret0 = uint(arg1)

	{
		ret1 = make([]ColorStop, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GskColorStop)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = WrapColorStop(src)
		}
	}

	return ret0, ret1
}

// End retrieves the final point of the linear gradient.
func (node linearGradientNode) End() *graphene.Point {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_linear_gradient_node_get_end(arg0)

	var ret0 *graphene.Point

	ret0 = graphene.WrapPoint(ret)

	return ret0
}

// NColorStops retrieves the number of color stops in the gradient.
func (node linearGradientNode) NColorStops() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_linear_gradient_node_get_n_color_stops(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Start retrieves the initial point of the linear gradient.
func (node linearGradientNode) Start() *graphene.Point {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_linear_gradient_node_get_start(arg0)

	var ret0 *graphene.Point

	ret0 = graphene.WrapPoint(ret)

	return ret0
}

// OpacityNode: a render node controlling the opacity of its single child node.
type OpacityNode interface {
	RenderNode

	// Child gets the child node that is getting opacityed by the given @node.
	Child() RenderNode
	// Opacity gets the transparency factor for an opacity node.
	Opacity() float32
}

type opacityNode struct {
	renderNode
}

// WrapOpacityNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOpacityNode(obj *externglib.Object) OpacityNode {
	return opacityNode{renderNode{obj}}
}

func marshalOpacityNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOpacityNode(obj), nil
}

// New_ constructs a class OpacityNode.
func New_(child RenderNode, opacity float32) OpacityNode {
	var arg1 *C.GskRenderNode
	var arg2 C.float

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = C.float(opacity)

	ret := C.gsk_opacity_node_new(arg1, arg2)

	var ret0 OpacityNode

	ret0 = WrapOpacityNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting opacityed by the given @node.
func (node opacityNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_opacity_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Opacity gets the transparency factor for an opacity node.
func (node opacityNode) Opacity() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_opacity_node_get_opacity(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// OutsetShadowNode: a render node for an outset shadow.
type OutsetShadowNode interface {
	RenderNode

	// BlurRadius retrieves the blur radius of the shadow.
	BlurRadius() float32
	// Color retrieves the color of the outset shadow.
	Color() *gdk.RGBA
	// Dx retrieves the horizontal offset of the outset shadow.
	Dx() float32
	// Dy retrieves the vertical offset of the outset shadow.
	Dy() float32
	// Outline retrieves the outline rectangle of the outset shadow.
	Outline() *RoundedRect
	// Spread retrieves how much the shadow spreads outwards.
	Spread() float32
}

type outsetShadowNode struct {
	renderNode
}

// WrapOutsetShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutsetShadowNode(obj *externglib.Object) OutsetShadowNode {
	return outsetShadowNode{renderNode{obj}}
}

func marshalOutsetShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutsetShadowNode(obj), nil
}

// New_ constructs a class OutsetShadowNode.
func New_(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) OutsetShadowNode {
	var arg1 *C.GskRoundedRect
	var arg2 *C.GdkRGBA
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg1 = (*C.GskRoundedRect)(outline.Native())
	arg2 = (*C.GdkRGBA)(color.Native())
	arg3 = C.float(dx)
	arg4 = C.float(dy)
	arg5 = C.float(spread)
	arg6 = C.float(blurRadius)

	ret := C.gsk_outset_shadow_node_new(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 OutsetShadowNode

	ret0 = WrapOutsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BlurRadius retrieves the blur radius of the shadow.
func (node outsetShadowNode) BlurRadius() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_blur_radius(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Color retrieves the color of the outset shadow.
func (node outsetShadowNode) Color() *gdk.RGBA {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_color(arg0)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(ret)

	return ret0
}

// Dx retrieves the horizontal offset of the outset shadow.
func (node outsetShadowNode) Dx() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_dx(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Dy retrieves the vertical offset of the outset shadow.
func (node outsetShadowNode) Dy() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_dy(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Outline retrieves the outline rectangle of the outset shadow.
func (node outsetShadowNode) Outline() *RoundedRect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_outline(arg0)

	var ret0 *RoundedRect

	ret0 = WrapRoundedRect(ret)

	return ret0
}

// Spread retrieves how much the shadow spreads outwards.
func (node outsetShadowNode) Spread() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_outset_shadow_node_get_spread(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// RadialGradientNode: a render node for a radial gradient.
type RadialGradientNode interface {
	RenderNode

	// Center retrieves the center pointer for the gradient.
	Center() *graphene.Point
	// ColorStops retrieves the color stops in the gradient.
	ColorStops() (nStops uint, colorStops []ColorStop)
	// End retrieves the end value for the gradient.
	End() float32
	// Hradius retrieves the horizonal radius for the gradient.
	Hradius() float32
	// NColorStops retrieves the number of color stops in the gradient.
	NColorStops() uint
	// Start retrieves the start value for the gradient.
	Start() float32
	// Vradius retrieves the vertical radius for the gradient.
	Vradius() float32
}

type radialGradientNode struct {
	renderNode
}

// WrapRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRadialGradientNode(obj *externglib.Object) RadialGradientNode {
	return radialGradientNode{renderNode{obj}}
}

func marshalRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRadialGradientNode(obj), nil
}

// New_ constructs a class RadialGradientNode.
func New_(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RadialGradientNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float
	var arg7 *C.GskColorStop
	var arg8 C.gsize

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(hradius)
	arg4 = C.float(vradius)
	arg5 = C.float(start)
	arg6 = C.float(end)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(colorStops))))
		sliceHeader.Len = len(colorStops)
		sliceHeader.Cap = len(colorStops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(colorStops); i++ {
			src := colorStops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg7 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg8 = len(colorStops)
	}

	ret := C.gsk_radial_gradient_node_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)

	var ret0 RadialGradientNode

	ret0 = WrapRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Center retrieves the center pointer for the gradient.
func (node radialGradientNode) Center() *graphene.Point {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_center(arg0)

	var ret0 *graphene.Point

	ret0 = graphene.WrapPoint(ret)

	return ret0
}

// ColorStops retrieves the color stops in the gradient.
func (node radialGradientNode) ColorStops() (nStops uint, colorStops []ColorStop) {
	var arg0 *C.GskRenderNode
	var arg1 *C.gsize // out

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_color_stops(arg0, &arg1)

	var ret0 uint
	var ret1 []ColorStop

	ret0 = uint(arg1)

	{
		ret1 = make([]ColorStop, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.GskColorStop)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = WrapColorStop(src)
		}
	}

	return ret0, ret1
}

// End retrieves the end value for the gradient.
func (node radialGradientNode) End() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_end(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Hradius retrieves the horizonal radius for the gradient.
func (node radialGradientNode) Hradius() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_hradius(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// NColorStops retrieves the number of color stops in the gradient.
func (node radialGradientNode) NColorStops() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_n_color_stops(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Start retrieves the start value for the gradient.
func (node radialGradientNode) Start() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_start(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Vradius retrieves the vertical radius for the gradient.
func (node radialGradientNode) Vradius() float32 {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_radial_gradient_node_get_vradius(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Renderer: base type for the object managing the rendering pipeline for a
// Surface.
type Renderer interface {
	gextras.Objector

	// Surface retrieves the Surface set using gsk_renderer_realize(). If the
	// renderer has not been realized yet, nil will be returned.
	Surface() gdk.Surface
	// IsRealized checks whether the @renderer is realized or not.
	IsRealized() bool
	// Realize creates the resources needed by the @renderer to render the scene
	// graph.
	Realize(surface gdk.Surface) bool
	// Render renders the scene graph, described by a tree of RenderNode
	// instances, ensuring that the given @region gets redrawn.
	//
	// Renderers must ensure that changes of the contents given by the @root
	// node as well as the area given by @region are redrawn. They are however
	// free to not redraw any pixel outside of @region if they can guarantee
	// that it didn't change.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	Render(root RenderNode, region *cairo.Region)
	// RenderTexture renders the scene graph, described by a tree of RenderNode
	// instances, to a Texture.
	//
	// The @renderer will acquire a reference on the RenderNode tree while the
	// rendering is in progress.
	//
	// If you want to apply any transformations to @root, you should put it into
	// a transform node and pass that node instead.
	RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture
	// Unrealize releases all the resources created by gsk_renderer_realize().
	Unrealize()
}

type renderer struct {
	*externglib.Object
}

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return renderer{*externglib.Object{obj}}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

// New_ForSurface constructs a class Renderer.
func New_ForSurface(surface gdk.Surface) Renderer {
	var arg1 *C.GdkSurface

	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gsk_renderer_new_for_surface(arg1)

	var ret0 Renderer

	ret0 = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Surface retrieves the Surface set using gsk_renderer_realize(). If the
// renderer has not been realized yet, nil will be returned.
func (renderer renderer) Surface() gdk.Surface {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_renderer_get_surface(arg0)

	var ret0 gdk.Surface

	ret0 = gdk.WrapSurface(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsRealized checks whether the @renderer is realized or not.
func (renderer renderer) IsRealized() bool {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	ret := C.gsk_renderer_is_realized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Realize creates the resources needed by the @renderer to render the scene
// graph.
func (renderer renderer) Realize(surface gdk.Surface) bool {
	var arg0 *C.GskRenderer
	var arg1 *C.GdkSurface

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gsk_renderer_realize(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Render renders the scene graph, described by a tree of RenderNode
// instances, ensuring that the given @region gets redrawn.
//
// Renderers must ensure that changes of the contents given by the @root
// node as well as the area given by @region are redrawn. They are however
// free to not redraw any pixel outside of @region if they can guarantee
// that it didn't change.
//
// The @renderer will acquire a reference on the RenderNode tree while the
// rendering is in progress.
func (renderer renderer) Render(root RenderNode, region *cairo.Region) {
	var arg0 *C.GskRenderer
	var arg1 *C.GskRenderNode
	var arg2 *C.cairo_region_t

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GskRenderNode)(root.Native())
	arg2 = (*C.cairo_region_t)(region.Native())

	C.gsk_renderer_render(arg0, arg1, arg2)
}

// RenderTexture renders the scene graph, described by a tree of RenderNode
// instances, to a Texture.
//
// The @renderer will acquire a reference on the RenderNode tree while the
// rendering is in progress.
//
// If you want to apply any transformations to @root, you should put it into
// a transform node and pass that node instead.
func (renderer renderer) RenderTexture(root RenderNode, viewport *graphene.Rect) gdk.Texture {
	var arg0 *C.GskRenderer
	var arg1 *C.GskRenderNode
	var arg2 *C.graphene_rect_t

	arg0 = (*C.GskRenderer)(renderer.Native())
	arg1 = (*C.GskRenderNode)(root.Native())
	arg2 = (*C.graphene_rect_t)(viewport.Native())

	ret := C.gsk_renderer_render_texture(arg0, arg1, arg2)

	var ret0 gdk.Texture

	ret0 = gdk.WrapTexture(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Unrealize releases all the resources created by gsk_renderer_realize().
func (renderer renderer) Unrealize() {
	var arg0 *C.GskRenderer

	arg0 = (*C.GskRenderer)(renderer.Native())

	C.gsk_renderer_unrealize(arg0)
}

// RepeatNode: a render node repeating its single child node.
type RepeatNode interface {
	RenderNode

	// Child retrieves the child of @node.
	Child() RenderNode
	// ChildBounds retrieves the bounding rectangle of the child of @node.
	ChildBounds() *graphene.Rect
}

type repeatNode struct {
	renderNode
}

// WrapRepeatNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatNode(obj *externglib.Object) RepeatNode {
	return repeatNode{renderNode{obj}}
}

func marshalRepeatNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatNode(obj), nil
}

// New_ constructs a class RepeatNode.
func New_(bounds *graphene.Rect, child RenderNode, childBounds *graphene.Rect) RepeatNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.GskRenderNode
	var arg3 *C.graphene_rect_t

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.GskRenderNode)(child.Native())
	arg3 = (*C.graphene_rect_t)(childBounds.Native())

	ret := C.gsk_repeat_node_new(arg1, arg2, arg3)

	var ret0 RepeatNode

	ret0 = WrapRepeatNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child retrieves the child of @node.
func (node repeatNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_repeat_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChildBounds retrieves the bounding rectangle of the child of @node.
func (node repeatNode) ChildBounds() *graphene.Rect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_repeat_node_get_child_bounds(arg0)

	var ret0 *graphene.Rect

	ret0 = graphene.WrapRect(ret)

	return ret0
}

// RepeatingLinearGradientNode: a render node for a repeating linear gradient.
type RepeatingLinearGradientNode interface {
	RenderNode
}

type repeatingLinearGradientNode struct {
	renderNode
}

// WrapRepeatingLinearGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingLinearGradientNode(obj *externglib.Object) RepeatingLinearGradientNode {
	return repeatingLinearGradientNode{renderNode{obj}}
}

func marshalRepeatingLinearGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingLinearGradientNode(obj), nil
}

// New_ constructs a class RepeatingLinearGradientNode.
func New_(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) RepeatingLinearGradientNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 *C.graphene_point_t
	var arg4 *C.GskColorStop
	var arg5 C.gsize

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(start.Native())
	arg3 = (*C.graphene_point_t)(end.Native())
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(colorStops))))
		sliceHeader.Len = len(colorStops)
		sliceHeader.Cap = len(colorStops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(colorStops); i++ {
			src := colorStops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg4 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg5 = len(colorStops)
	}

	ret := C.gsk_repeating_linear_gradient_node_new(arg1, arg2, arg3, arg4, arg5)

	var ret0 RepeatingLinearGradientNode

	ret0 = WrapRepeatingLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// RepeatingRadialGradientNode: a render node for a repeating radial gradient.
type RepeatingRadialGradientNode interface {
	RenderNode
}

type repeatingRadialGradientNode struct {
	renderNode
}

// WrapRepeatingRadialGradientNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRepeatingRadialGradientNode(obj *externglib.Object) RepeatingRadialGradientNode {
	return repeatingRadialGradientNode{renderNode{obj}}
}

func marshalRepeatingRadialGradientNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRepeatingRadialGradientNode(obj), nil
}

// New_ constructs a class RepeatingRadialGradientNode.
func New_(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) RepeatingRadialGradientNode {
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_point_t
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float
	var arg7 *C.GskColorStop
	var arg8 C.gsize

	arg1 = (*C.graphene_rect_t)(bounds.Native())
	arg2 = (*C.graphene_point_t)(center.Native())
	arg3 = C.float(hradius)
	arg4 = C.float(vradius)
	arg5 = C.float(start)
	arg6 = C.float(end)
	{
		var dst []C.GskColorStop
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskColorStop * len(colorStops))))
		sliceHeader.Len = len(colorStops)
		sliceHeader.Cap = len(colorStops)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(colorStops); i++ {
			src := colorStops[i]
			dst[i] = (C.GskColorStop)(src.Native())
		}

		arg7 = (*C.GskColorStop)(unsafe.Pointer(sliceHeader.Data))
		arg8 = len(colorStops)
	}

	ret := C.gsk_repeating_radial_gradient_node_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)

	var ret0 RepeatingRadialGradientNode

	ret0 = WrapRepeatingRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// RoundedClipNode: a render node applying a rounded rectangle clip to its
// single child.
type RoundedClipNode interface {
	RenderNode

	// Child gets the child node that is getting clipped by the given @node.
	Child() RenderNode
	// Clip retrievs the rounded rectangle used to clip the contents of the
	// @node.
	Clip() *RoundedRect
}

type roundedClipNode struct {
	renderNode
}

// WrapRoundedClipNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapRoundedClipNode(obj *externglib.Object) RoundedClipNode {
	return roundedClipNode{renderNode{obj}}
}

func marshalRoundedClipNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRoundedClipNode(obj), nil
}

// New_ constructs a class RoundedClipNode.
func New_(child RenderNode, clip *RoundedRect) RoundedClipNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.GskRoundedRect

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = (*C.GskRoundedRect)(clip.Native())

	ret := C.gsk_rounded_clip_node_new(arg1, arg2)

	var ret0 RoundedClipNode

	ret0 = WrapRoundedClipNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting clipped by the given @node.
func (node roundedClipNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_rounded_clip_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Clip retrievs the rounded rectangle used to clip the contents of the
// @node.
func (node roundedClipNode) Clip() *RoundedRect {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_rounded_clip_node_get_clip(arg0)

	var ret0 *RoundedRect

	ret0 = WrapRoundedRect(ret)

	return ret0
}

// ShadowNode: a render node drawing one or more shadows behind its single child
// node.
type ShadowNode interface {
	RenderNode

	// Child retrieves the child RenderNode of the shadow @node.
	Child() RenderNode
	// NShadows retrieves the number of shadows in the @node.
	NShadows() uint
	// Shadow retrieves the shadow data at the given index @i.
	Shadow(i uint) *Shadow
}

type shadowNode struct {
	renderNode
}

// WrapShadowNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapShadowNode(obj *externglib.Object) ShadowNode {
	return shadowNode{renderNode{obj}}
}

func marshalShadowNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapShadowNode(obj), nil
}

// New_ constructs a class ShadowNode.
func New_(child RenderNode, shadows []Shadow) ShadowNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.GskShadow
	var arg3 C.gsize

	arg1 = (*C.GskRenderNode)(child.Native())
	{
		var dst []C.GskShadow
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(C.malloc(C.sizeof_GskShadow * len(shadows))))
		sliceHeader.Len = len(shadows)
		sliceHeader.Cap = len(shadows)
		defer C.free(unsafe.Pointer(sliceHeader.Data))

		for i := 0; i < len(shadows); i++ {
			src := shadows[i]
			dst[i] = (C.GskShadow)(src.Native())
		}

		arg2 = (*C.GskShadow)(unsafe.Pointer(sliceHeader.Data))
		arg3 = len(shadows)
	}

	ret := C.gsk_shadow_node_new(arg1, arg2, arg3)

	var ret0 ShadowNode

	ret0 = WrapShadowNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child retrieves the child RenderNode of the shadow @node.
func (node shadowNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_shadow_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NShadows retrieves the number of shadows in the @node.
func (node shadowNode) NShadows() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_shadow_node_get_n_shadows(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Shadow retrieves the shadow data at the given index @i.
func (node shadowNode) Shadow(i uint) *Shadow {
	var arg0 *C.GskRenderNode
	var arg1 C.gsize

	arg0 = (*C.GskRenderNode)(node.Native())
	arg1 = C.gsize(i)

	ret := C.gsk_shadow_node_get_shadow(arg0, arg1)

	var ret0 *Shadow

	ret0 = WrapShadow(ret)

	return ret0
}

// TextNode: a render node drawing a set of glyphs.
type TextNode interface {
	RenderNode

	// Color retrieves the color used by the text @node.
	Color() *gdk.RGBA
	// Font returns the font used by the text @node.
	Font() pango.Font
	// Glyphs retrieves the glyph information in the @node.
	Glyphs() (nGlyphs uint, glyphInfos []pango.GlyphInfo)
	// NumGlyphs retrieves the number of glyphs in the text node.
	NumGlyphs() uint
	// Offset retrieves the offset applied to the text.
	Offset() *graphene.Point
	// HasColorGlyphs checks whether the text @node has color glyphs.
	HasColorGlyphs() bool
}

type textNode struct {
	renderNode
}

// WrapTextNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextNode(obj *externglib.Object) TextNode {
	return textNode{renderNode{obj}}
}

func marshalTextNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextNode(obj), nil
}

// New_ constructs a class TextNode.
func New_(font pango.Font, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) TextNode {
	var arg1 *C.PangoFont
	var arg2 *C.PangoGlyphString
	var arg3 *C.GdkRGBA
	var arg4 *C.graphene_point_t

	arg1 = (*C.PangoFont)(font.Native())
	arg2 = (*C.PangoGlyphString)(glyphs.Native())
	arg3 = (*C.GdkRGBA)(color.Native())
	arg4 = (*C.graphene_point_t)(offset.Native())

	ret := C.gsk_text_node_new(arg1, arg2, arg3, arg4)

	var ret0 TextNode

	ret0 = WrapTextNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Color retrieves the color used by the text @node.
func (node textNode) Color() *gdk.RGBA {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_get_color(arg0)

	var ret0 *gdk.RGBA

	ret0 = gdk.WrapRGBA(ret)

	return ret0
}

// Font returns the font used by the text @node.
func (node textNode) Font() pango.Font {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_get_font(arg0)

	var ret0 pango.Font

	ret0 = pango.WrapFont(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Glyphs retrieves the glyph information in the @node.
func (node textNode) Glyphs() (nGlyphs uint, glyphInfos []pango.GlyphInfo) {
	var arg0 *C.GskRenderNode
	var arg1 *C.guint // out

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_get_glyphs(arg0, &arg1)

	var ret0 uint
	var ret1 []pango.GlyphInfo

	ret0 = uint(arg1)

	{
		ret1 = make([]pango.GlyphInfo, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.PangoGlyphInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = pango.WrapGlyphInfo(src)
		}
	}

	return ret0, ret1
}

// NumGlyphs retrieves the number of glyphs in the text node.
func (node textNode) NumGlyphs() uint {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_get_num_glyphs(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Offset retrieves the offset applied to the text.
func (node textNode) Offset() *graphene.Point {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_get_offset(arg0)

	var ret0 *graphene.Point

	ret0 = graphene.WrapPoint(ret)

	return ret0
}

// HasColorGlyphs checks whether the text @node has color glyphs.
func (node textNode) HasColorGlyphs() bool {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_text_node_has_color_glyphs(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TextureNode: a render node for a Texture.
type TextureNode interface {
	RenderNode

	// Texture retrieves the Texture used when creating this RenderNode.
	Texture() gdk.Texture
}

type textureNode struct {
	renderNode
}

// WrapTextureNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTextureNode(obj *externglib.Object) TextureNode {
	return textureNode{renderNode{obj}}
}

func marshalTextureNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTextureNode(obj), nil
}

// New_ constructs a class TextureNode.
func New_(texture gdk.Texture, bounds *graphene.Rect) TextureNode {
	var arg1 *C.GdkTexture
	var arg2 *C.graphene_rect_t

	arg1 = (*C.GdkTexture)(texture.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	ret := C.gsk_texture_node_new(arg1, arg2)

	var ret0 TextureNode

	ret0 = WrapTextureNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Texture retrieves the Texture used when creating this RenderNode.
func (node textureNode) Texture() gdk.Texture {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_texture_node_get_texture(arg0)

	var ret0 gdk.Texture

	ret0 = gdk.WrapTexture(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TransformNode: a render node applying a Transform to its single child node.
type TransformNode interface {
	RenderNode

	// Child gets the child node that is getting transformed by the given @node.
	Child() RenderNode
	// Transform retrieves the Transform used by the @node.
	Transform() *Transform
}

type transformNode struct {
	renderNode
}

// WrapTransformNode wraps a GObject to the right type. It is
// primarily used internally.
func WrapTransformNode(obj *externglib.Object) TransformNode {
	return transformNode{renderNode{obj}}
}

func marshalTransformNode(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTransformNode(obj), nil
}

// New_ constructs a class TransformNode.
func New_(child RenderNode, transform *Transform) TransformNode {
	var arg1 *C.GskRenderNode
	var arg2 *C.GskTransform

	arg1 = (*C.GskRenderNode)(child.Native())
	arg2 = (*C.GskTransform)(transform.Native())

	ret := C.gsk_transform_node_new(arg1, arg2)

	var ret0 TransformNode

	ret0 = WrapTransformNode(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Child gets the child node that is getting transformed by the given @node.
func (node transformNode) Child() RenderNode {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_transform_node_get_child(arg0)

	var ret0 RenderNode

	ret0 = WrapRenderNode(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Transform retrieves the Transform used by the @node.
func (node transformNode) Transform() *Transform {
	var arg0 *C.GskRenderNode

	arg0 = (*C.GskRenderNode)(node.Native())

	ret := C.gsk_transform_node_get_transform(arg0)

	var ret0 *Transform

	ret0 = WrapTransform(ret)

	return ret0
}

type VulkanRenderer interface {
	Renderer
}

type vulkanRenderer struct {
	renderer
}

// WrapVulkanRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanRenderer(obj *externglib.Object) VulkanRenderer {
	return vulkanRenderer{renderer{*externglib.Object{obj}}}
}

func marshalVulkanRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanRenderer(obj), nil
}

// New_ constructs a class VulkanRenderer.
func New_() Renderer {

	ret := C.gsk_vulkan_renderer_new()

	var ret0 Renderer

	ret0 = WrapRenderer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}
