// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_layout_get_type()), F: marshalLayout},
		{T: externglib.Type(C.pango_layout_iter_get_type()), F: marshalLayoutIter},
		{T: externglib.Type(C.pango_layout_line_get_type()), F: marshalLayoutLine},
	})
}

// LayoutRun: a `PangoLayoutRun` represents a single run within a
// `PangoLayoutLine`.
//
// It is simply an alternate name for [struct@Pango.GlyphItem]. See the
// [struct@Pango.GlyphItem] docs for details on the fields.
type LayoutRun GlyphItem

// Layout: a `PangoLayout` structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. `PangoLayout`
// provides a high-level driver for formatting entire paragraphs of text at
// once. This includes paragraph-level functionality such as line breaking,
// justification, alignment and ellipsization.
//
// A `PangoLayout is initialized with a `PangoContext`, UTF-8 string and set of
// attributes for that string. Once that is done, the set of formatted lines can
// be extracted from the object, the layout can be rendered, and conversion
// between logical character positions within the layout's text, and the
// physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a `PangoLayout`.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// !Pango Layout Parameters (layout.png)
//
// It is possible, as well, to ignore the 2-D setup, and simply treat the
// results of a `PangoLayout` as a list of lines.
type Layout interface {
	gextras.Objector

	// ContextChanged forces recomputation of any state in the `PangoLayout`
	// that might depend on the layout's context.
	//
	// This function should be called if you make changes to the context
	// subsequent to creating the layout.
	ContextChanged()
	// Copy creates a deep copy-by-value of the layout.
	//
	// The attribute list, tab array, and text from the original layout are all
	// copied by value.
	Copy() Layout
	// Alignment gets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	Alignment() Alignment
	// Attributes gets the attribute list for the layout, if any.
	Attributes() *AttrList
	// AutoDir gets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// See [method@Pango.Layout.set_auto_dir].
	AutoDir() bool
	// Baseline gets the Y position of baseline of the first line in @layout.
	Baseline() int
	// CharacterCount returns the number of Unicode characters in the the text
	// of @layout.
	CharacterCount() int
	// Context retrieves the `PangoContext` used for this layout.
	Context() Context
	// CursorPos: given an index within a layout, determines the positions that
	// of the strong and weak cursors if the insertion point is at that index.
	//
	// The position of each cursor is stored as a zero-width rectangle. The
	// strong cursor location is the location where characters of the
	// directionality equal to the base direction of the layout are inserted.
	// The weak cursor location is the location where characters of the
	// directionality opposite to the base direction of the layout are inserted.
	CursorPos(index_ int) (strongPos *Rectangle, weakPos *Rectangle)
	// Direction gets the text direction at the given character position in
	// @layout.
	Direction(index int) Direction
	// Ellipsize gets the type of ellipsization being performed for @layout.
	//
	// See [method@Pango.Layout.set_ellipsize].
	//
	// Use [method@Pango.Layout.is_ellipsized] to query whether any paragraphs
	// were actually ellipsized.
	Ellipsize() EllipsizeMode
	// Extents computes the logical and ink extents of @layout.
	//
	// Logical extents are usually what you want for positioning things. Note
	// that both extents may have non-zero x and y. You may want to use those to
	// offset where you render the layout. Not doing that is a very typical bug
	// that shows up as right-to-left layouts not being correctly positioned in
	// a layout with a set width.
	//
	// The extents are given in layout coordinates and in Pango units; layout
	// coordinates begin at the top left corner of the layout.
	Extents() (inkRect *Rectangle, logicalRect *Rectangle)
	// FontDescription gets the font description for the layout, if any.
	FontDescription() *FontDescription
	// Height gets the height of layout used for ellipsization.
	//
	// See [method@Pango.Layout.set_height] for details.
	Height() int
	// Indent gets the paragraph indent width in Pango units.
	//
	// A negative value indicates a hanging indentation.
	Indent() int
	// Iter returns an iterator to iterate over the visual extents of the
	// layout.
	Iter() *LayoutIter
	// Justify gets whether each complete line should be stretched to fill the
	// entire width of the layout.
	Justify() bool
	// Line retrieves a particular line from a `PangoLayout`.
	//
	// Use the faster [method@Pango.Layout.get_line_readonly] if you do not plan
	// to modify the contents of the line (glyphs, glyph widths, etc.).
	Line(line int) *LayoutLine
	// LineCount retrieves the count of lines for the @layout.
	LineCount() int
	// LineReadonly retrieves a particular line from a `PangoLayout`.
	//
	// This is a faster alternative to [method@Pango.Layout.get_line], but the
	// user is not expected to modify the contents of the line (glyphs, glyph
	// widths, etc.).
	LineReadonly(line int) *LayoutLine
	// LineSpacing gets the line spacing factor of @layout.
	//
	// See [method@Pango.Layout.set_line_spacing].
	LineSpacing() float32
	// Lines returns the lines of the @layout as a list.
	//
	// Use the faster [method@Pango.Layout.get_lines_readonly] if you do not
	// plan to modify the contents of the lines (glyphs, glyph widths, etc.).
	Lines() *glib.SList
	// LinesReadonly returns the lines of the @layout as a list.
	//
	// This is a faster alternative to [method@Pango.Layout.get_lines], but the
	// user is not expected to modify the contents of the lines (glyphs, glyph
	// widths, etc.).
	LinesReadonly() *glib.SList
	// LogAttrs retrieves an array of logical attributes for each character in
	// the @layout.
	LogAttrs()
	// LogAttrsReadonly retrieves an array of logical attributes for each
	// character in the @layout.
	//
	// This is a faster alternative to [method@Pango.Layout.get_log_attrs]. The
	// returned array is part of @layout and must not be modified. Modifying the
	// layout will invalidate the returned array.
	//
	// The number of attributes returned in @n_attrs will be one more than the
	// total number of characters in the layout, since there need to be
	// attributes corresponding to both the position before the first character
	// and the position after the last character.
	LogAttrsReadonly() []LogAttr
	// PixelExtents computes the logical and ink extents of @layout in device
	// units.
	//
	// This function just calls [method@Pango.Layout.get_extents] followed by
	// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
	// such that the rounded rectangles fully contain the unrounded one (that
	// is, passes them as first argument to `pango_extents_to_pixels()`).
	PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle)
	// PixelSize determines the logical width and height of a `PangoLayout` in
	// device units.
	//
	// [method@Pango.Layout.get_size] returns the width and height scaled by
	// PANGO_SCALE. This is simply a convenience function around
	// [method@Pango.Layout.get_pixel_extents].
	PixelSize() (width int, height int)
	// Serial returns the current serial number of @layout.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new layout is created and is increased whenever the layout is changed
	// using any of the setter functions, or the `PangoContext` it uses has
	// changed. The serial may wrap, but will never have the value 0. Since it
	// can wrap, never compare it with "less than", always use "not equals".
	//
	// This can be used to automatically detect changes to a `PangoLayout`, and
	// is useful for example to decide whether a layout needs redrawing. To
	// force the serial to be increased, use
	// [method@Pango.Layout.context_changed].
	Serial() uint
	// SingleParagraphMode obtains whether @layout is in single paragraph mode.
	//
	// See [method@Pango.Layout.set_single_paragraph_mode].
	SingleParagraphMode() bool
	// Size determines the logical width and height of a `PangoLayout` in Pango
	// units.
	//
	// This is simply a convenience function around
	// [method@Pango.Layout.get_extents].
	Size() (width int, height int)
	// Spacing gets the amount of spacing between the lines of the layout.
	Spacing() int
	// Tabs gets the current `PangoTabArray` used by this layout.
	//
	// If no `PangoTabArray` has been set, then the default tabs are in use and
	// nil is returned. Default tabs are every 8 spaces.
	//
	// The return value should be freed with [method@Pango.TabArray.free].
	Tabs() *TabArray
	// Text gets the text in the layout. The returned text should not be freed
	// or modified.
	Text() string
	// UnknownGlyphsCount counts the number of unknown glyphs in @layout.
	//
	// This function can be used to determine if there are any fonts available
	// to render all characters in a certain string, or when used in combination
	// with PANGO_ATTR_FALLBACK, to check if a certain font supports all the
	// characters in the string.
	UnknownGlyphsCount() int
	// Width gets the width to which the lines of the `PangoLayout` should wrap.
	Width() int
	// Wrap gets the wrap mode for the layout.
	//
	// Use [method@Pango.Layout.is_wrapped] to query whether any paragraphs were
	// actually wrapped.
	Wrap() WrapMode
	// IndexToLineX converts from byte @index_ within the @layout to line and X
	// position.
	//
	// The X position is measured from the left edge of the line.
	IndexToLineX(index_ int, trailing bool) (line int, xPos int)
	// IndexToPos converts from an index within a `PangoLayout` to the onscreen
	// position corresponding to the grapheme at that index.
	//
	// The return value is represented as rectangle. Note that `pos->x` is
	// always the leading edge of the grapheme and `pos->x + pos->width` the
	// trailing edge of the grapheme. If the directionality of the grapheme is
	// right-to-left, then `pos->width` will be negative.
	IndexToPos(index_ int) *Rectangle
	// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
	//
	// This returns true if the ellipsization mode for @layout is not
	// PANGO_ELLIPSIZE_NONE, a positive width is set on @layout, and there are
	// paragraphs exceeding that width that have to be ellipsized.
	IsEllipsized() bool
	// IsWrapped queries whether the layout had to wrap any paragraphs.
	//
	// This returns true if a positive width is set on @layout, ellipsization
	// mode of @layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs
	// exceeding the layout width that have to be wrapped.
	IsWrapped() bool
	// MoveCursorVisually computes a new cursor position from an old position
	// and a count of positions to move visually.
	//
	// If @direction is positive, then the new strong cursor position will be
	// one position to the right of the old cursor position. If @direction is
	// negative, then the new strong cursor position will be one position to the
	// left of the old cursor position.
	//
	// In the presence of bidirectional text, the correspondence between logical
	// and visual order will depend on the direction of the current run, and
	// there may be jumps when the cursor is moved off of the end of a run.
	//
	// Motion here is in cursor positions, not in characters, so a single call
	// to [method@Pango.Layout.move_cursor_visually] may move the cursor over
	// multiple characters when multiple characters combine to form a single
	// grapheme.
	MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int)
	// SetAlignment sets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	SetAlignment(alignment Alignment)
	// SetAttributes sets the text attributes for a layout object. References
	// @attrs, so the caller can unref its reference.
	SetAttributes(attrs *AttrList)
	// SetAutoDir sets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// When this flag is on (the default), then paragraphs in @layout that begin
	// with strong right-to-left characters (Arabic and Hebrew principally),
	// will have right-to-left layout, paragraphs with letters from other
	// scripts will have left-to-right layout. Paragraphs with only neutral
	// characters get their direction from the surrounding paragraphs.
	//
	// When false, the choice between left-to-right and right-to-left layout is
	// done according to the base direction of the layout's `PangoContext`. (See
	// [method@Pango.Context.set_base_dir]).
	//
	// When the auto-computed direction of a paragraph differs from the base
	// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
	// PANGO_ALIGN_RIGHT are swapped.
	SetAutoDir(autoDir bool)
	// SetEllipsize sets the type of ellipsization being performed for @layout.
	//
	// Depending on the ellipsization mode @ellipsize text is removed from the
	// start, middle, or end of text so they fit within the width and height of
	// layout set with [method@Pango.Layout.set_width] and
	// [method@Pango.Layout.set_height].
	//
	// If the layout contains characters such as newlines that force it to be
	// layed out in multiple paragraphs, then whether each paragraph is
	// ellipsized separately or the entire layout is ellipsized as a whole
	// depends on the set height of the layout. See
	// [method@Pango.Layout.set_height] for details.
	SetEllipsize(ellipsize EllipsizeMode)
	// SetFontDescription sets the default font description for the layout.
	//
	// If no font description is set on the layout, the font description from
	// the layout's context is used.
	SetFontDescription(desc *FontDescription)
	// SetHeight sets the height to which the `PangoLayout` should be ellipsized
	// at.
	//
	// There are two different behaviors, based on whether @height is positive
	// or negative.
	//
	// If @height is positive, it will be the maximum height of the layout. Only
	// lines would be shown that would fit, and if there is any text omitted, an
	// ellipsis added. At least one line is included in each paragraph
	// regardless of how small the height value is. A value of zero will render
	// exactly one line for the entire layout.
	//
	// If @height is negative, it will be the (negative of) maximum number of
	// lines per paragraph. That is, the total number of lines shown may well be
	// more than this value if the layout contains multiple paragraphs of text.
	// The default value of -1 means that first line of each paragraph is
	// ellipsized. This behavior may be changed in the future to act per layout
	// instead of per paragraph. File a bug against pango at
	// https://gitlab.gnome.org/gnome/pango
	// (https://gitlab.gnome.org/gnome/pango) if your code relies on this
	// behavior.
	//
	// Height setting only has effect if a positive width is set on @layout and
	// ellipsization mode of @layout is not PANGO_ELLIPSIZE_NONE. The behavior
	// is undefined if a height other than -1 is set and ellipsization mode is
	// set to PANGO_ELLIPSIZE_NONE, and may change in the future.
	SetHeight(height int)
	// SetIndent sets the width in Pango units to indent each paragraph.
	//
	// A negative value of @indent will produce a hanging indentation. That is,
	// the first line will have the full width, and subsequent lines will be
	// indented by the absolute value of @indent.
	//
	// The indent setting is ignored if layout alignment is set to
	// PANGO_ALIGN_CENTER.
	SetIndent(indent int)
	// SetJustify sets whether each complete line should be stretched to fill
	// the entire width of the layout.
	//
	// Stretching is typically done by adding whitespace, but for some scripts
	// (such as Arabic), the justification may be done in more complex ways,
	// like extending the characters.
	//
	// Note that this setting is not implemented and so is ignored in Pango
	// older than 1.18.
	SetJustify(justify bool)
	// SetLineSpacing sets a factor for line spacing.
	//
	// Typical values are: 0, 1, 1.5, 2. The default values is 0.
	//
	// If @factor is non-zero, lines are placed so that
	//
	//    baseline2 = baseline1 + factor * height2
	//
	// where height2 is the line height of the second line (as determined by the
	// font(s)). In this case, the spacing set with
	// [method@Pango.Layout.set_spacing] is ignored.
	//
	// If @factor is zero, spacing is applied as before.
	SetLineSpacing(factor float32)
	// SetMarkup sets the layout text and attribute list from marked-up text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// This is the Same as [method@Pango.Layout.set_markup_with_accel], but the
	// markup text isn't scanned for accelerators.
	SetMarkup(markup string, length int)
	// SetMarkupWithAccel sets the layout text and attribute list from marked-up
	// text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// If @accel_marker is nonzero, the given character will mark the character
	// following it as an accelerator. For example, @accel_marker might be an
	// ampersand or underscore. All characters marked as an accelerator will
	// receive a PANGO_UNDERLINE_LOW attribute, and the first character so
	// marked will be returned in @accel_char. Two @accel_marker characters
	// following each other produce a single literal @accel_marker character.
	SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32
	// SetSingleParagraphMode sets the single paragraph mode of @layout.
	//
	// If @setting is true, do not treat newlines and similar characters as
	// paragraph separators; instead, keep all text in a single paragraph, and
	// display a glyph for paragraph separator characters. Used when you want to
	// allow editing of newlines on a single text line.
	SetSingleParagraphMode(setting bool)
	// SetSpacing sets the amount of spacing in Pango unit between the lines of
	// the layout.
	//
	//
	// When placing lines with spacing, Pango arranges things so that
	//
	// line2.top = line1.bottom + spacing
	//
	// Note: Since 1.44, Pango defaults to using the line height (as determined
	// by the font) for placing lines. The @spacing set with this function is
	// only taken into account when the line height factor is set to zero with
	// [method@Pango.Layout.set_line_spacing].
	SetSpacing(spacing int)
	// SetTabs sets the tabs to use for @layout, overriding the default tabs.
	//
	// By default, tabs are every 8 spaces. If @tabs is nil, the default tabs
	// are reinstated. @tabs is copied into the layout; you must free your copy
	// of @tabs yourself.
	SetTabs(tabs *TabArray)
	// SetText sets the text of the layout.
	//
	// This function validates @text and renders invalid UTF-8 with a
	// placeholder glyph.
	//
	// Note that if you have used [method@Pango.Layout.set_markup] or
	// [method@Pango.Layout.set_markup_with_accel] on @layout before, you may
	// want to call [method@Pango.Layout.set_attributes] to clear the attributes
	// set on the layout from the markup as this function does not clear
	// attributes.
	SetText(text string, length int)
	// SetWidth sets the width to which the lines of the `PangoLayout` should
	// wrap or ellipsized.
	//
	// The default value is -1: no width set.
	SetWidth(width int)
	// SetWrap sets the wrap mode.
	//
	// The wrap mode only has effect if a width is set on the layout with
	// [method@Pango.Layout.set_width]. To turn off wrapping, set the width to
	// -1.
	SetWrap(wrap WrapMode)
	// XYToIndex converts from X and Y position within a layout to the byte
	// index to the character at that logical position.
	//
	// If the Y position is not inside the layout, the closest position is
	// chosen (the position will be clamped inside the layout). If the X
	// position is not within the layout, then the start or the end of the line
	// is chosen as described for [method@Pango.LayoutLine.x_to_index]. If
	// either the X or Y positions were not inside the layout, then the function
	// returns false; on an exact hit, it returns true.
	XYToIndex(x int, y int) (index_ int, trailing int, ok bool)
}

// layout implements the Layout interface.
type layout struct {
	gextras.Objector
}

var _ Layout = (*layout)(nil)

// WrapLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayout(obj *externglib.Object) Layout {
	return Layout{
		Objector: obj,
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayout(obj), nil
}

// NewLayout constructs a class Layout.
func NewLayout(context Context) Layout {
	var arg1 *C.PangoContext

	arg1 = (*C.PangoContext)(unsafe.Pointer(context.Native()))

	cret := new(C.PangoLayout)
	var goret Layout

	cret = C.pango_layout_new(arg1)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Layout)

	return goret
}

// ContextChanged forces recomputation of any state in the `PangoLayout`
// that might depend on the layout's context.
//
// This function should be called if you make changes to the context
// subsequent to creating the layout.
func (l layout) ContextChanged() {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_context_changed(arg0)
}

// Copy creates a deep copy-by-value of the layout.
//
// The attribute list, tab array, and text from the original layout are all
// copied by value.
func (s layout) Copy() Layout {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(s.Native()))

	cret := new(C.PangoLayout)
	var goret Layout

	cret = C.pango_layout_copy(arg0)

	goret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Layout)

	return goret
}

// Alignment gets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
func (l layout) Alignment() Alignment {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.PangoAlignment
	var goret Alignment

	cret = C.pango_layout_get_alignment(arg0)

	goret = Alignment(cret)

	return goret
}

// Attributes gets the attribute list for the layout, if any.
func (l layout) Attributes() *AttrList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.PangoAttrList
	var goret *AttrList

	cret = C.pango_layout_get_attributes(arg0)

	goret = WrapAttrList(unsafe.Pointer(cret))

	return goret
}

// AutoDir gets whether to calculate the base direction for the layout
// according to its contents.
//
// See [method@Pango.Layout.set_auto_dir].
func (l layout) AutoDir() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_get_auto_dir(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Baseline gets the Y position of baseline of the first line in @layout.
func (l layout) Baseline() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_baseline(arg0)

	goret = int(cret)

	return goret
}

// CharacterCount returns the number of Unicode characters in the the text
// of @layout.
func (l layout) CharacterCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gint
	var goret int

	cret = C.pango_layout_get_character_count(arg0)

	goret = int(cret)

	return goret
}

// Context retrieves the `PangoContext` used for this layout.
func (l layout) Context() Context {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.PangoContext
	var goret Context

	cret = C.pango_layout_get_context(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Context)

	return goret
}

// CursorPos: given an index within a layout, determines the positions that
// of the strong and weak cursors if the insertion point is at that index.
//
// The position of each cursor is stored as a zero-width rectangle. The
// strong cursor location is the location where characters of the
// directionality equal to the base direction of the layout are inserted.
// The weak cursor location is the location where characters of the
// directionality opposite to the base direction of the layout are inserted.
func (l layout) CursorPos(index_ int) (strongPos *Rectangle, weakPos *Rectangle) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(index_)

	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle
	arg3 := new(C.PangoRectangle)
	var ret3 *Rectangle

	C.pango_layout_get_cursor_pos(arg0, arg1, arg2, arg3)

	ret2 = WrapRectangle(unsafe.Pointer(arg2))
	ret3 = WrapRectangle(unsafe.Pointer(arg3))

	return ret2, ret3
}

// Direction gets the text direction at the given character position in
// @layout.
func (l layout) Direction(index int) Direction {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(index)

	var cret C.PangoDirection
	var goret Direction

	cret = C.pango_layout_get_direction(arg0, arg1)

	goret = Direction(cret)

	return goret
}

// Ellipsize gets the type of ellipsization being performed for @layout.
//
// See [method@Pango.Layout.set_ellipsize].
//
// Use [method@Pango.Layout.is_ellipsized] to query whether any paragraphs
// were actually ellipsized.
func (l layout) Ellipsize() EllipsizeMode {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.PangoEllipsizeMode
	var goret EllipsizeMode

	cret = C.pango_layout_get_ellipsize(arg0)

	goret = EllipsizeMode(cret)

	return goret
}

// Extents computes the logical and ink extents of @layout.
//
// Logical extents are usually what you want for positioning things. Note
// that both extents may have non-zero x and y. You may want to use those to
// offset where you render the layout. Not doing that is a very typical bug
// that shows up as right-to-left layouts not being correctly positioned in
// a layout with a set width.
//
// The extents are given in layout coordinates and in Pango units; layout
// coordinates begin at the top left corner of the layout.
func (l layout) Extents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_get_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// FontDescription gets the font description for the layout, if any.
func (l layout) FontDescription() *FontDescription {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.PangoFontDescription
	var goret *FontDescription

	cret = C.pango_layout_get_font_description(arg0)

	goret = WrapFontDescription(unsafe.Pointer(cret))

	return goret
}

// Height gets the height of layout used for ellipsization.
//
// See [method@Pango.Layout.set_height] for details.
func (l layout) Height() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_height(arg0)

	goret = int(cret)

	return goret
}

// Indent gets the paragraph indent width in Pango units.
//
// A negative value indicates a hanging indentation.
func (l layout) Indent() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_indent(arg0)

	goret = int(cret)

	return goret
}

// Iter returns an iterator to iterate over the visual extents of the
// layout.
func (l layout) Iter() *LayoutIter {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	cret := new(C.PangoLayoutIter)
	var goret *LayoutIter

	cret = C.pango_layout_get_iter(arg0)

	goret = WrapLayoutIter(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *LayoutIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Justify gets whether each complete line should be stretched to fill the
// entire width of the layout.
func (l layout) Justify() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_get_justify(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Line retrieves a particular line from a `PangoLayout`.
//
// Use the faster [method@Pango.Layout.get_line_readonly] if you do not plan
// to modify the contents of the line (glyphs, glyph widths, etc.).
func (l layout) Line(line int) *LayoutLine {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(line)

	var cret *C.PangoLayoutLine
	var goret *LayoutLine

	cret = C.pango_layout_get_line(arg0, arg1)

	goret = WrapLayoutLine(unsafe.Pointer(cret))

	return goret
}

// LineCount retrieves the count of lines for the @layout.
func (l layout) LineCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_line_count(arg0)

	goret = int(cret)

	return goret
}

// LineReadonly retrieves a particular line from a `PangoLayout`.
//
// This is a faster alternative to [method@Pango.Layout.get_line], but the
// user is not expected to modify the contents of the line (glyphs, glyph
// widths, etc.).
func (l layout) LineReadonly(line int) *LayoutLine {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(line)

	var cret *C.PangoLayoutLine
	var goret *LayoutLine

	cret = C.pango_layout_get_line_readonly(arg0, arg1)

	goret = WrapLayoutLine(unsafe.Pointer(cret))

	return goret
}

// LineSpacing gets the line spacing factor of @layout.
//
// See [method@Pango.Layout.set_line_spacing].
func (l layout) LineSpacing() float32 {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.float
	var goret float32

	cret = C.pango_layout_get_line_spacing(arg0)

	goret = float32(cret)

	return goret
}

// Lines returns the lines of the @layout as a list.
//
// Use the faster [method@Pango.Layout.get_lines_readonly] if you do not
// plan to modify the contents of the lines (glyphs, glyph widths, etc.).
func (l layout) Lines() *glib.SList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.GSList
	var goret *glib.SList

	cret = C.pango_layout_get_lines(arg0)

	goret = glib.WrapSList(unsafe.Pointer(cret))

	return goret
}

// LinesReadonly returns the lines of the @layout as a list.
//
// This is a faster alternative to [method@Pango.Layout.get_lines], but the
// user is not expected to modify the contents of the lines (glyphs, glyph
// widths, etc.).
func (l layout) LinesReadonly() *glib.SList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.GSList
	var goret *glib.SList

	cret = C.pango_layout_get_lines_readonly(arg0)

	goret = glib.WrapSList(unsafe.Pointer(cret))

	return goret
}

// LogAttrs retrieves an array of logical attributes for each character in
// the @layout.
func (l layout) LogAttrs() {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_log_attrs(arg0, arg1, arg2)

	return ret1, ret2
}

// LogAttrsReadonly retrieves an array of logical attributes for each
// character in the @layout.
//
// This is a faster alternative to [method@Pango.Layout.get_log_attrs]. The
// returned array is part of @layout and must not be modified. Modifying the
// layout will invalidate the returned array.
//
// The number of attributes returned in @n_attrs will be one more than the
// total number of characters in the layout, since there need to be
// attributes corresponding to both the position before the first character
// and the position after the last character.
func (l layout) LogAttrsReadonly() []LogAttr {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.PangoLogAttr
	var arg1 *C.gint
	var goret []LogAttr

	cret = C.pango_layout_get_log_attrs_readonly(arg0, arg1)

	goret = make([]LogAttr, arg1)
	for i := 0; i < uintptr(arg1); i++ {
		src := (C.PangoLogAttr)(ptr.Add(unsafe.Pointer(cret), i))
		goret[i] = *WrapLogAttr(unsafe.Pointer(&src))
	}

	return ret1, goret
}

// PixelExtents computes the logical and ink extents of @layout in device
// units.
//
// This function just calls [method@Pango.Layout.get_extents] followed by
// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
// such that the rounded rectangles fully contain the unrounded one (that
// is, passes them as first argument to `pango_extents_to_pixels()`).
func (l layout) PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_get_pixel_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// PixelSize determines the logical width and height of a `PangoLayout` in
// device units.
//
// [method@Pango.Layout.get_size] returns the width and height scaled by
// PANGO_SCALE. This is simply a convenience function around
// [method@Pango.Layout.get_pixel_extents].
func (l layout) PixelSize() (width int, height int) {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	arg1 := new(C.int)
	var ret1 int
	arg2 := new(C.int)
	var ret2 int

	C.pango_layout_get_pixel_size(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// Serial returns the current serial number of @layout.
//
// The serial number is initialized to an small number larger than zero when
// a new layout is created and is increased whenever the layout is changed
// using any of the setter functions, or the `PangoContext` it uses has
// changed. The serial may wrap, but will never have the value 0. Since it
// can wrap, never compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a `PangoLayout`, and
// is useful for example to decide whether a layout needs redrawing. To
// force the serial to be increased, use
// [method@Pango.Layout.context_changed].
func (l layout) Serial() uint {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.guint
	var goret uint

	cret = C.pango_layout_get_serial(arg0)

	goret = uint(cret)

	return goret
}

// SingleParagraphMode obtains whether @layout is in single paragraph mode.
//
// See [method@Pango.Layout.set_single_paragraph_mode].
func (l layout) SingleParagraphMode() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_get_single_paragraph_mode(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Size determines the logical width and height of a `PangoLayout` in Pango
// units.
//
// This is simply a convenience function around
// [method@Pango.Layout.get_extents].
func (l layout) Size() (width int, height int) {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	arg1 := new(C.int)
	var ret1 int
	arg2 := new(C.int)
	var ret2 int

	C.pango_layout_get_size(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// Spacing gets the amount of spacing between the lines of the layout.
func (l layout) Spacing() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_spacing(arg0)

	goret = int(cret)

	return goret
}

// Tabs gets the current `PangoTabArray` used by this layout.
//
// If no `PangoTabArray` has been set, then the default tabs are in use and
// nil is returned. Default tabs are every 8 spaces.
//
// The return value should be freed with [method@Pango.TabArray.free].
func (l layout) Tabs() *TabArray {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	cret := new(C.PangoTabArray)
	var goret *TabArray

	cret = C.pango_layout_get_tabs(arg0)

	goret = WrapTabArray(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Text gets the text in the layout. The returned text should not be freed
// or modified.
func (l layout) Text() string {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret *C.char
	var goret string

	cret = C.pango_layout_get_text(arg0)

	goret = C.GoString(cret)

	return goret
}

// UnknownGlyphsCount counts the number of unknown glyphs in @layout.
//
// This function can be used to determine if there are any fonts available
// to render all characters in a certain string, or when used in combination
// with PANGO_ATTR_FALLBACK, to check if a certain font supports all the
// characters in the string.
func (l layout) UnknownGlyphsCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_unknown_glyphs_count(arg0)

	goret = int(cret)

	return goret
}

// Width gets the width to which the lines of the `PangoLayout` should wrap.
func (l layout) Width() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_get_width(arg0)

	goret = int(cret)

	return goret
}

// Wrap gets the wrap mode for the layout.
//
// Use [method@Pango.Layout.is_wrapped] to query whether any paragraphs were
// actually wrapped.
func (l layout) Wrap() WrapMode {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.PangoWrapMode
	var goret WrapMode

	cret = C.pango_layout_get_wrap(arg0)

	goret = WrapMode(cret)

	return goret
}

// IndexToLineX converts from byte @index_ within the @layout to line and X
// position.
//
// The X position is measured from the left edge of the line.
func (l layout) IndexToLineX(index_ int, trailing bool) (line int, xPos int) {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(index_)
	if trailing {
		arg2 = C.gboolean(1)
	}

	arg3 := new(C.int)
	var ret3 int
	arg4 := new(C.int)
	var ret4 int

	C.pango_layout_index_to_line_x(arg0, arg1, arg2, arg3, arg4)

	ret3 = int(*arg3)
	ret4 = int(*arg4)

	return ret3, ret4
}

// IndexToPos converts from an index within a `PangoLayout` to the onscreen
// position corresponding to the grapheme at that index.
//
// The return value is represented as rectangle. Note that `pos->x` is
// always the leading edge of the grapheme and `pos->x + pos->width` the
// trailing edge of the grapheme. If the directionality of the grapheme is
// right-to-left, then `pos->width` will be negative.
func (l layout) IndexToPos(index_ int) *Rectangle {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(index_)

	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_index_to_pos(arg0, arg1, arg2)

	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret2
}

// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
//
// This returns true if the ellipsization mode for @layout is not
// PANGO_ELLIPSIZE_NONE, a positive width is set on @layout, and there are
// paragraphs exceeding that width that have to be ellipsized.
func (l layout) IsEllipsized() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_is_ellipsized(arg0)

	if cret {
		goret = true
	}

	return goret
}

// IsWrapped queries whether the layout had to wrap any paragraphs.
//
// This returns true if a positive width is set on @layout, ellipsization
// mode of @layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs
// exceeding the layout width that have to be wrapped.
func (l layout) IsWrapped() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_is_wrapped(arg0)

	if cret {
		goret = true
	}

	return goret
}

// MoveCursorVisually computes a new cursor position from an old position
// and a count of positions to move visually.
//
// If @direction is positive, then the new strong cursor position will be
// one position to the right of the old cursor position. If @direction is
// negative, then the new strong cursor position will be one position to the
// left of the old cursor position.
//
// In the presence of bidirectional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and
// there may be jumps when the cursor is moved off of the end of a run.
//
// Motion here is in cursor positions, not in characters, so a single call
// to [method@Pango.Layout.move_cursor_visually] may move the cursor over
// multiple characters when multiple characters combine to form a single
// grapheme.
func (l layout) MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if strong {
		arg1 = C.gboolean(1)
	}
	arg2 = C.int(oldIndex)
	arg3 = C.int(oldTrailing)
	arg4 = C.int(direction)

	arg5 := new(C.int)
	var ret5 int
	arg6 := new(C.int)
	var ret6 int

	C.pango_layout_move_cursor_visually(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	ret5 = int(*arg5)
	ret6 = int(*arg6)

	return ret5, ret6
}

// SetAlignment sets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
func (l layout) SetAlignment(alignment Alignment) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoAlignment

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (C.PangoAlignment)(alignment)

	C.pango_layout_set_alignment(arg0, arg1)
}

// SetAttributes sets the text attributes for a layout object. References
// @attrs, so the caller can unref its reference.
func (l layout) SetAttributes(attrs *AttrList) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoAttrList

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.pango_layout_set_attributes(arg0, arg1)
}

// SetAutoDir sets whether to calculate the base direction for the layout
// according to its contents.
//
// When this flag is on (the default), then paragraphs in @layout that begin
// with strong right-to-left characters (Arabic and Hebrew principally),
// will have right-to-left layout, paragraphs with letters from other
// scripts will have left-to-right layout. Paragraphs with only neutral
// characters get their direction from the surrounding paragraphs.
//
// When false, the choice between left-to-right and right-to-left layout is
// done according to the base direction of the layout's `PangoContext`. (See
// [method@Pango.Context.set_base_dir]).
//
// When the auto-computed direction of a paragraph differs from the base
// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
// PANGO_ALIGN_RIGHT are swapped.
func (l layout) SetAutoDir(autoDir bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if autoDir {
		arg1 = C.gboolean(1)
	}

	C.pango_layout_set_auto_dir(arg0, arg1)
}

// SetEllipsize sets the type of ellipsization being performed for @layout.
//
// Depending on the ellipsization mode @ellipsize text is removed from the
// start, middle, or end of text so they fit within the width and height of
// layout set with [method@Pango.Layout.set_width] and
// [method@Pango.Layout.set_height].
//
// If the layout contains characters such as newlines that force it to be
// layed out in multiple paragraphs, then whether each paragraph is
// ellipsized separately or the entire layout is ellipsized as a whole
// depends on the set height of the layout. See
// [method@Pango.Layout.set_height] for details.
func (l layout) SetEllipsize(ellipsize EllipsizeMode) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (C.PangoEllipsizeMode)(ellipsize)

	C.pango_layout_set_ellipsize(arg0, arg1)
}

// SetFontDescription sets the default font description for the layout.
//
// If no font description is set on the layout, the font description from
// the layout's context is used.
func (l layout) SetFontDescription(desc *FontDescription) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoFontDescription

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))

	C.pango_layout_set_font_description(arg0, arg1)
}

// SetHeight sets the height to which the `PangoLayout` should be ellipsized
// at.
//
// There are two different behaviors, based on whether @height is positive
// or negative.
//
// If @height is positive, it will be the maximum height of the layout. Only
// lines would be shown that would fit, and if there is any text omitted, an
// ellipsis added. At least one line is included in each paragraph
// regardless of how small the height value is. A value of zero will render
// exactly one line for the entire layout.
//
// If @height is negative, it will be the (negative of) maximum number of
// lines per paragraph. That is, the total number of lines shown may well be
// more than this value if the layout contains multiple paragraphs of text.
// The default value of -1 means that first line of each paragraph is
// ellipsized. This behavior may be changed in the future to act per layout
// instead of per paragraph. File a bug against pango at
// https://gitlab.gnome.org/gnome/pango
// (https://gitlab.gnome.org/gnome/pango) if your code relies on this
// behavior.
//
// Height setting only has effect if a positive width is set on @layout and
// ellipsization mode of @layout is not PANGO_ELLIPSIZE_NONE. The behavior
// is undefined if a height other than -1 is set and ellipsization mode is
// set to PANGO_ELLIPSIZE_NONE, and may change in the future.
func (l layout) SetHeight(height int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(height)

	C.pango_layout_set_height(arg0, arg1)
}

// SetIndent sets the width in Pango units to indent each paragraph.
//
// A negative value of @indent will produce a hanging indentation. That is,
// the first line will have the full width, and subsequent lines will be
// indented by the absolute value of @indent.
//
// The indent setting is ignored if layout alignment is set to
// PANGO_ALIGN_CENTER.
func (l layout) SetIndent(indent int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(indent)

	C.pango_layout_set_indent(arg0, arg1)
}

// SetJustify sets whether each complete line should be stretched to fill
// the entire width of the layout.
//
// Stretching is typically done by adding whitespace, but for some scripts
// (such as Arabic), the justification may be done in more complex ways,
// like extending the characters.
//
// Note that this setting is not implemented and so is ignored in Pango
// older than 1.18.
func (l layout) SetJustify(justify bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if justify {
		arg1 = C.gboolean(1)
	}

	C.pango_layout_set_justify(arg0, arg1)
}

// SetLineSpacing sets a factor for line spacing.
//
// Typical values are: 0, 1, 1.5, 2. The default values is 0.
//
// If @factor is non-zero, lines are placed so that
//
//    baseline2 = baseline1 + factor * height2
//
// where height2 is the line height of the second line (as determined by the
// font(s)). In this case, the spacing set with
// [method@Pango.Layout.set_spacing] is ignored.
//
// If @factor is zero, spacing is applied as before.
func (l layout) SetLineSpacing(factor float32) {
	var arg0 *C.PangoLayout
	var arg1 C.float

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.float(factor)

	C.pango_layout_set_line_spacing(arg0, arg1)
}

// SetMarkup sets the layout text and attribute list from marked-up text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// This is the Same as [method@Pango.Layout.set_markup_with_accel], but the
// markup text isn't scanned for accelerators.
func (l layout) SetMarkup(markup string, length int) {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	C.pango_layout_set_markup(arg0, arg1, arg2)
}

// SetMarkupWithAccel sets the layout text and attribute list from marked-up
// text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will
// receive a PANGO_UNDERLINE_LOW attribute, and the first character so
// marked will be returned in @accel_char. Two @accel_marker characters
// following each other produce a single literal @accel_marker character.
func (l layout) SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32 {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.gunichar

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = C.gunichar(accelMarker)

	arg4 := new(C.gunichar)
	var ret4 uint32

	C.pango_layout_set_markup_with_accel(arg0, arg1, arg2, arg3, arg4)

	ret4 = uint32(*arg4)

	return ret4
}

// SetSingleParagraphMode sets the single paragraph mode of @layout.
//
// If @setting is true, do not treat newlines and similar characters as
// paragraph separators; instead, keep all text in a single paragraph, and
// display a glyph for paragraph separator characters. Used when you want to
// allow editing of newlines on a single text line.
func (l layout) SetSingleParagraphMode(setting bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.pango_layout_set_single_paragraph_mode(arg0, arg1)
}

// SetSpacing sets the amount of spacing in Pango unit between the lines of
// the layout.
//
//
// When placing lines with spacing, Pango arranges things so that
//
// line2.top = line1.bottom + spacing
//
// Note: Since 1.44, Pango defaults to using the line height (as determined
// by the font) for placing lines. The @spacing set with this function is
// only taken into account when the line height factor is set to zero with
// [method@Pango.Layout.set_line_spacing].
func (l layout) SetSpacing(spacing int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(spacing)

	C.pango_layout_set_spacing(arg0, arg1)
}

// SetTabs sets the tabs to use for @layout, overriding the default tabs.
//
// By default, tabs are every 8 spaces. If @tabs is nil, the default tabs
// are reinstated. @tabs is copied into the layout; you must free your copy
// of @tabs yourself.
func (l layout) SetTabs(tabs *TabArray) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoTabArray

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.pango_layout_set_tabs(arg0, arg1)
}

// SetText sets the text of the layout.
//
// This function validates @text and renders invalid UTF-8 with a
// placeholder glyph.
//
// Note that if you have used [method@Pango.Layout.set_markup] or
// [method@Pango.Layout.set_markup_with_accel] on @layout before, you may
// want to call [method@Pango.Layout.set_attributes] to clear the attributes
// set on the layout from the markup as this function does not clear
// attributes.
func (l layout) SetText(text string, length int) {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	C.pango_layout_set_text(arg0, arg1, arg2)
}

// SetWidth sets the width to which the lines of the `PangoLayout` should
// wrap or ellipsized.
//
// The default value is -1: no width set.
func (l layout) SetWidth(width int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(width)

	C.pango_layout_set_width(arg0, arg1)
}

// SetWrap sets the wrap mode.
//
// The wrap mode only has effect if a width is set on the layout with
// [method@Pango.Layout.set_width]. To turn off wrapping, set the width to
// -1.
func (l layout) SetWrap(wrap WrapMode) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoWrapMode

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = (C.PangoWrapMode)(wrap)

	C.pango_layout_set_wrap(arg0, arg1)
}

// XYToIndex converts from X and Y position within a layout to the byte
// index to the character at that logical position.
//
// If the Y position is not inside the layout, the closest position is
// chosen (the position will be clamped inside the layout). If the X
// position is not within the layout, then the start or the end of the line
// is chosen as described for [method@Pango.LayoutLine.x_to_index]. If
// either the X or Y positions were not inside the layout, then the function
// returns false; on an exact hit, it returns true.
func (l layout) XYToIndex(x int, y int) (index_ int, trailing int, ok bool) {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	arg3 := new(C.int)
	var ret3 int
	arg4 := new(C.int)
	var ret4 int
	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_xy_to_index(arg0, arg1, arg2, arg3, arg4)

	ret3 = int(*arg3)
	ret4 = int(*arg4)
	if cret {
		goret = true
	}

	return ret3, ret4, goret
}

// LayoutIter: a `PangoLayoutIter` can be used to iterate over the visual
// extents of a `PangoLayout`.
//
// To obtain a `PangoLayoutIter`, use [method@Pango.Layout.get_iter].
//
// The `PangoLayoutIter` structure is opaque, and has no user-visible fields.
type LayoutIter struct {
	native C.PangoLayoutIter
}

// WrapLayoutIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutIter(ptr unsafe.Pointer) *LayoutIter {
	if ptr == nil {
		return nil
	}

	return (*LayoutIter)(ptr)
}

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LayoutIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// AtLastLine determines whether @iter is on the last line of the layout.
func (i *LayoutIter) AtLastLine() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_iter_at_last_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// Copy copies a `PangoLayoutIter`.
func (i *LayoutIter) Copy() *LayoutIter {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	cret := new(C.PangoLayoutIter)
	var goret *LayoutIter

	cret = C.pango_layout_iter_copy(arg0)

	goret = WrapLayoutIter(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *LayoutIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Free frees an iterator that's no longer in use.
func (i *LayoutIter) Free() {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_free(arg0)
}

// Baseline gets the Y position of the current line's baseline, in layout
// coordinates (origin at top left of the entire layout).
func (i *LayoutIter) Baseline() int {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_iter_get_baseline(arg0)

	goret = int(cret)

	return goret
}

// CharExtents gets the extents of the current character, in layout coordinates
// (origin is the top left of the entire layout). Only logical extents can
// sensibly be obtained for characters; ink extents make sense only down to the
// level of clusters.
func (i *LayoutIter) CharExtents() *Rectangle {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle

	C.pango_layout_iter_get_char_extents(arg0, arg1)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))

	return ret1
}

// ClusterExtents gets the extents of the current cluster, in layout coordinates
// (origin is the top left of the entire layout).
func (i *LayoutIter) ClusterExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_iter_get_cluster_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// Index gets the current byte index. Note that iterating forward by char moves
// in visual order, not logical order, so indexes may not be sequential. Also,
// the index may be equal to the length of the text in the layout, if on the nil
// run (see [method@Pango.LayoutIter.get_run]).
func (i *LayoutIter) Index() int {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.int
	var goret int

	cret = C.pango_layout_iter_get_index(arg0)

	goret = int(cret)

	return goret
}

// Layout gets the layout associated with a `PangoLayoutIter`.
func (i *LayoutIter) Layout() Layout {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret *C.PangoLayout
	var goret Layout

	cret = C.pango_layout_iter_get_layout(arg0)

	goret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Layout)

	return goret
}

// LayoutExtents obtains the extents of the `PangoLayout` being iterated over.
// @ink_rect or @logical_rect can be nil if you aren't interested in them.
func (i *LayoutIter) LayoutExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_iter_get_layout_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// Line gets the current line.
//
// Use the faster [method@Pango.LayoutIter.get_line_readonly] if you do not plan
// to modify the contents of the line (glyphs, glyph widths, etc.).
func (i *LayoutIter) Line() *LayoutLine {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret *C.PangoLayoutLine
	var goret *LayoutLine

	cret = C.pango_layout_iter_get_line(arg0)

	goret = WrapLayoutLine(unsafe.Pointer(cret))

	return goret
}

// LineExtents obtains the extents of the current line. @ink_rect or
// @logical_rect can be nil if you aren't interested in them. Extents are in
// layout coordinates (origin is the top-left corner of the entire
// `PangoLayout`). Thus the extents returned by this function will be the same
// width/height but not at the same x/y as the extents returned from
// [method@Pango.LayoutLine.get_extents].
func (i *LayoutIter) LineExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_iter_get_line_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// LineReadonly gets the current line for read-only access.
//
// This is a faster alternative to [method@Pango.LayoutIter.get_line], but the
// user is not expected to modify the contents of the line (glyphs, glyph
// widths, etc.).
func (i *LayoutIter) LineReadonly() *LayoutLine {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret *C.PangoLayoutLine
	var goret *LayoutLine

	cret = C.pango_layout_iter_get_line_readonly(arg0)

	goret = WrapLayoutLine(unsafe.Pointer(cret))

	return goret
}

// LineYrange divides the vertical space in the `PangoLayout` being iterated
// over between the lines in the layout, and returns the space belonging to the
// current line. A line's range includes the line's logical extents, plus half
// of the spacing above and below the line, if [method@Pango.Layout.set_spacing]
// has been called to set layout spacing. The Y positions are in layout
// coordinates (origin at top left of the entire layout).
//
// Note: Since 1.44, Pango uses line heights for placing lines, and there may be
// gaps between the ranges returned by this function.
func (i *LayoutIter) LineYrange() (y0 int, y1 int) {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.int)
	var ret1 int
	arg2 := new(C.int)
	var ret2 int

	C.pango_layout_iter_get_line_yrange(arg0, arg1, arg2)

	ret1 = int(*arg1)
	ret2 = int(*arg2)

	return ret1, ret2
}

// RunExtents gets the extents of the current run in layout coordinates (origin
// is the top left of the entire layout).
func (i *LayoutIter) RunExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_iter_get_run_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// NextChar moves @iter forward to the next character in visual order. If @iter
// was already at the end of the layout, returns false.
func (i *LayoutIter) NextChar() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_iter_next_char(arg0)

	if cret {
		goret = true
	}

	return goret
}

// NextCluster moves @iter forward to the next cluster in visual order. If @iter
// was already at the end of the layout, returns false.
func (i *LayoutIter) NextCluster() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_iter_next_cluster(arg0)

	if cret {
		goret = true
	}

	return goret
}

// NextLine moves @iter forward to the start of the next line. If @iter is
// already on the last line, returns false.
func (i *LayoutIter) NextLine() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_iter_next_line(arg0)

	if cret {
		goret = true
	}

	return goret
}

// NextRun moves @iter forward to the next run in visual order. If @iter was
// already at the end of the layout, returns false.
func (i *LayoutIter) NextRun() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_iter_next_run(arg0)

	if cret {
		goret = true
	}

	return goret
}

// LayoutLine: a `PangoLayoutLine` represents one of the lines resulting from
// laying out a paragraph via `PangoLayout`.
//
// `PangoLayoutLine` structures are obtained by calling
// [method@Pango.Layout.get_line] and are only valid until the text, attributes,
// or settings of the parent `PangoLayout` are modified.
type LayoutLine struct {
	native C.PangoLayoutLine
}

// WrapLayoutLine wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutLine(ptr unsafe.Pointer) *LayoutLine {
	if ptr == nil {
		return nil
	}

	return (*LayoutLine)(ptr)
}

func marshalLayoutLine(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutLine(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LayoutLine) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// Layout gets the field inside the struct.
func (l *LayoutLine) Layout() Layout {
	var v Layout
	v = gextras.CastObject(externglib.Take(unsafe.Pointer(l.native.layout.Native()))).(Layout)
	return v
}

// StartIndex gets the field inside the struct.
func (l *LayoutLine) StartIndex() int {
	var v int
	v = int(l.native.start_index)
	return v
}

// Length gets the field inside the struct.
func (l *LayoutLine) Length() int {
	var v int
	v = int(l.native.length)
	return v
}

// Runs gets the field inside the struct.
func (l *LayoutLine) Runs() *glib.SList {
	var v *glib.SList
	v = glib.WrapSList(unsafe.Pointer(l.native.runs))
	return v
}

// Extents computes the logical and ink extents of a layout line. See
// [method@Pango.Font.get_glyph_extents] for details about the interpretation of
// the rectangles.
func (l *LayoutLine) Extents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_line_get_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// Height computes the height of the line, i.e. the distance between this and
// the previous lines baseline.
func (l *LayoutLine) Height() int {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))

	arg1 := new(C.int)
	var ret1 int

	C.pango_layout_line_get_height(arg0, arg1)

	ret1 = int(*arg1)

	return ret1
}

// PixelExtents computes the logical and ink extents of @layout_line in device
// units.
//
// This function just calls [method@Pango.LayoutLine.get_extents] followed by
// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect such
// that the rounded rectangles fully contain the unrounded one (that is, passes
// them as first argument to [func@extents_to_pixels]).
func (l *LayoutLine) PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))

	arg1 := new(C.PangoRectangle)
	var ret1 *Rectangle
	arg2 := new(C.PangoRectangle)
	var ret2 *Rectangle

	C.pango_layout_line_get_pixel_extents(arg0, arg1, arg2)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))
	ret2 = WrapRectangle(unsafe.Pointer(arg2))

	return ret1, ret2
}

// XRanges gets a list of visual ranges corresponding to a given logical range.
// This list is not necessarily minimal - there may be consecutive ranges which
// are adjacent. The ranges will be sorted from left to right. The ranges are
// with respect to the left edge of the entire layout, not with respect to the
// line.
func (l *LayoutLine) XRanges(startIndex int, endIndex int) {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))
	arg1 = C.int(startIndex)
	arg2 = C.int(endIndex)

	C.pango_layout_line_get_x_ranges(arg0, arg1, arg2, arg3, arg4)

	return ret3, ret4
}

// IndexToX converts an index within a line to a X position.
func (l *LayoutLine) IndexToX(index_ int, trailing bool) int {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int
	var arg2 C.gboolean

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))
	arg1 = C.int(index_)
	if trailing {
		arg2 = C.gboolean(1)
	}

	arg3 := new(C.int)
	var ret3 int

	C.pango_layout_line_index_to_x(arg0, arg1, arg2, arg3)

	ret3 = int(*arg3)

	return ret3
}

// Ref: increase the reference count of a `PangoLayoutLine` by one.
func (l *LayoutLine) Ref() *LayoutLine {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))

	cret := new(C.PangoLayoutLine)
	var goret *LayoutLine

	cret = C.pango_layout_line_ref(arg0)

	goret = WrapLayoutLine(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret, func(v *LayoutLine) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret
}

// Unref: decrease the reference count of a `PangoLayoutLine` by one. If the
// result is zero, the line and all associated memory will be freed.
func (l *LayoutLine) Unref() {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))

	C.pango_layout_line_unref(arg0)
}

// XToIndex converts from x offset to the byte index of the corresponding
// character within the text of the layout. If @x_pos is outside the line,
// @index_ and @trailing will point to the very first or very last position in
// the line. This determination is based on the resolved direction of the
// paragraph; for example, if the resolved direction is right-to-left, then an X
// position to the right of the line (after it) results in 0 being stored in
// @index_ and @trailing. An X position to the left of the line results in
// @index_ pointing to the (logical) last grapheme in the line and @trailing
// being set to the number of characters in that grapheme. The reverse is true
// for a left-to-right line.
func (l *LayoutLine) XToIndex(xPos int) (index_ int, trailing int, ok bool) {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int

	arg0 = (*C.PangoLayoutLine)(unsafe.Pointer(l.Native()))
	arg1 = C.int(xPos)

	arg2 := new(C.int)
	var ret2 int
	arg3 := new(C.int)
	var ret3 int
	var cret C.gboolean
	var goret bool

	cret = C.pango_layout_line_x_to_index(arg0, arg1, arg2, arg3)

	ret2 = int(*arg2)
	ret3 = int(*arg3)
	if cret {
		goret = true
	}

	return ret2, ret3, goret
}
