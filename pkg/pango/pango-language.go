// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_language_get_type()), F: marshalLanguage},
	})
}

// Language: the `PangoLanguage` structure is used to represent a language.
//
// `PangoLanguage` pointers can be efficiently copied and compared with each
// other.
type Language struct {
	native C.PangoLanguage
}

// WrapLanguage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLanguage(ptr unsafe.Pointer) *Language {
	if ptr == nil {
		return nil
	}

	return (*Language)(ptr)
}

func marshalLanguage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLanguage(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *Language) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// SampleString: get a string that is representative of the characters needed to
// render a particular language.
//
// The sample text may be a pangram, but is not necessarily. It is chosen to be
// demonstrative of normal text in the language, as well as exposing font
// feature requirements unique to the language. It is suitable for use as sample
// text in a font selection dialog.
//
// If @language is nil, the default language as found by
// [type_func@Pango.Language.get_default] is used.
//
// If Pango does not have a sample string for @language, the classic "The quick
// brown fox..." is returned. This can be detected by comparing the returned
// pointer value to that returned for (non-existent) language code "xx". That
// is, compare to:
//
// “` pango_language_get_sample_string (pango_language_from_string ("xx")) “`
func (l *Language) SampleString() string {
	var _arg0 *C.PangoLanguage // out

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))

	var _cret *C.char // in

	_cret = C.pango_language_get_sample_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Scripts determines the scripts used to to write @language.
//
// If nothing is known about the language tag @language, or if @language is nil,
// then nil is returned. The list of scripts returned starts with the script
// that the language uses most and continues to the one it uses least.
//
// The value @num_script points at will be set to the number of scripts in the
// returned array (or zero if nil is returned).
//
// Most languages use only one script for writing, but there are some that use
// two (Latin and Cyrillic for example), and a few use three (Japanese for
// example). Applications should not make any assumptions on the maximum number
// of scripts returned though, except that it is positive if the return value is
// not nil, and it is a small number.
//
// The [method@Pango.Language.includes_script] function uses this function
// internally.
//
// Note: while the return value is declared as `PangoScript`, the returned
// values are from the `GUnicodeScript` enumeration, which may have more values.
// Callers need to handle unknown values.
func (l *Language) Scripts() []Script {
	var _arg0 *C.PangoLanguage // out

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))

	var _cret *C.PangoScript
	var _arg1 C.int // in

	_cret = C.pango_language_get_scripts(_arg0, &_arg1)

	var _scripts []Script

	{
		src := unsafe.Slice(_cret, _arg1)
		_scripts = make([]Script, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_scripts[i] = Script(src[i])
		}
	}

	return _scripts
}

// IncludesScript determines if @script is one of the scripts used to write
// @language. The returned value is conservative; if nothing is known about the
// language tag @language, true will be returned, since, as far as Pango knows,
// @script might be used to write @language.
//
// This routine is used in Pango's itemization process when determining if a
// supplied language tag is relevant to a particular section of text. It
// probably is not useful for applications in most circumstances.
//
// This function uses [method@Pango.Language.get_scripts] internally.
func (l *Language) IncludesScript(script Script) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 C.PangoScript    // out

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoScript)(script)

	var _cret C.gboolean // in

	_cret = C.pango_language_includes_script(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches checks if a language tag matches one of the elements in a list of
// language ranges.
//
// A language tag is considered to match a range in the list if the range is
// '*', the range is exactly the tag, or the range is a prefix of the tag, and
// the character after it in the tag is '-'.
func (l *Language) Matches(rangeList string) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 *C.char          // out

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(rangeList))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.pango_language_matches(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String gets the RFC-3066 format string representing the given language tag.
func (l *Language) String() string {
	var _arg0 *C.PangoLanguage // out

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))

	var _cret *C.char // in

	_cret = C.pango_language_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}
