// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_script_iter_get_type()), F: marshalScriptIter},
	})
}

// ScriptForUnichar looks up the script for a particular character.
//
// The script of a character is defined by Unicode Standard Annex \#24. No check
// is made for @ch being a valid Unicode character; if you pass in invalid
// character, the result is undefined.
//
// Note that while the return type of this function is declared as
// `PangoScript`, as of Pango 1.18, this function simply returns the return
// value of g_unichar_get_script(). Callers must be prepared to handle unknown
// values.
func ScriptForUnichar(ch uint32) Script {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_script_for_unichar(arg1)

	var ret0 Script

	ret0 = Script(ret)

	return ret0
}

// ScriptGetSampleLanguage finds a language tag that is reasonably
// representative of @script.
//
// The language will usually be the most widely spoken or used language written
// in that script: for instance, the sample language for PANGO_SCRIPT_CYRILLIC
// is ru (Russian), the sample language for PANGO_SCRIPT_ARABIC is ar.
//
// For some scripts, no sample language will be returned because there is no
// language that is sufficiently representative. The best example of this is
// PANGO_SCRIPT_HAN, where various different variants of written Chinese,
// Japanese, and Korean all use significantly different sets of Han characters
// and forms of shared characters. No sample language can be provided for many
// historical scripts as well.
//
// As of 1.18, this function checks the environment variables `PANGO_LANGUAGE`
// and `LANGUAGE` (checked in that order) first. If one of them is set, it is
// parsed as a list of language tags separated by colons or other separators.
// This function will return the first language in the parsed list that Pango
// believes may use @script for writing. This last predicate is tested using
// [method@Pango.Language.includes_script]. This can be used to control Pango's
// font selection for non-primary languages. For example, a `PANGO_LANGUAGE`
// enviroment variable set to "en:fa" makes Pango choose fonts suitable for
// Persian (fa) instead of Arabic (ar) when a segment of Arabic text is found in
// an otherwise non-Arabic text. The same trick can be used to choose a default
// language for PANGO_SCRIPT_HAN when setting context language is not feasible.
func ScriptGetSampleLanguage(script Script) *Language {
	var arg1 C.PangoScript

	arg1 = (C.PangoScript)(script)

	ret := C.pango_script_get_sample_language(arg1)

	var ret0 *Language

	{
		ret0 = WrapLanguage(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ScriptIter: a `PangoScriptIter` is used to iterate through a string and
// identify ranges in different scripts.
type ScriptIter struct {
	native C.PangoScriptIter
}

// WrapScriptIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScriptIter(ptr unsafe.Pointer) *ScriptIter {
	if ptr == nil {
		return nil
	}

	return (*ScriptIter)(ptr)
}

func marshalScriptIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScriptIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *ScriptIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewScriptIter constructs a struct ScriptIter.
func NewScriptIter(text string, length int) *ScriptIter {
	var arg1 *C.char
	var arg2 C.int

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	ret := C.pango_script_iter_new(arg1, arg2)

	var ret0 *ScriptIter

	{
		ret0 = WrapScriptIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ScriptIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a ScriptIter created with pango_script_iter_new().
func (i *ScriptIter) Free() {
	var arg0 *C.PangoScriptIter

	arg0 = (*C.PangoScriptIter)(i.Native())

	C.pango_script_iter_free(arg0)
}

// Range gets information about the range to which @iter currently points. The
// range is the set of locations p where *start <= p < *end. (That is, it
// doesn't include the character stored at *end)
//
// Note that while the type of the @script argument is declared as PangoScript,
// as of Pango 1.18, this function simply returns GUnicodeScript values. Callers
// must be prepared to handle unknown values.
func (i *ScriptIter) Range() (start string, end string, script Script) {
	var arg0 *C.PangoScriptIter
	var arg1 **C.char       // out
	var arg2 **C.char       // out
	var arg3 *C.PangoScript // out

	arg0 = (*C.PangoScriptIter)(i.Native())

	C.pango_script_iter_get_range(arg0, &arg1, &arg2, &arg3)

	var ret0 string
	var ret1 string
	var ret2 *Script

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret2 = (*Script)(arg3)

	return ret0, ret1, ret2
}

// Next advances a ScriptIter to the next range. If @iter is already at the end,
// it is left unchanged and false is returned.
func (i *ScriptIter) Next() bool {
	var arg0 *C.PangoScriptIter

	arg0 = (*C.PangoScriptIter)(i.Native())

	ret := C.pango_script_iter_next(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}
