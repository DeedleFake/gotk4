// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <pango/pango.h>
import "C"

// IsZeroWidth checks if a character that should not be normally rendered.
//
// This includes all Unicode characters with "ZERO WIDTH" in their name, as well
// as *bidi* formatting characters, and a few other ones. This is totally
// different from g_unichar_iszerowidth() and is at best misnamed.
func IsZeroWidth(ch uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_is_zero_width(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Log2VisGetEmbeddingLevels: return the bidirectional embedding levels of the
// input paragraph.
//
// The bidirectional embedding levels are defined by the Unicode Bidirectional
// Algorithm available at:
//
//    http://www.unicode.org/reports/tr9/
//
// If the input base direction is a weak direction, the direction of the
// characters in the text will determine the final resolved direction.
func Log2VisGetEmbeddingLevels(text string, length int, pbaseDir *Direction) byte {
	var arg1 *C.gchar
	var arg2 C.int
	var arg3 *C.PangoDirection

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoDirection)(pbaseDir)

	ret := C.pango_log2vis_get_embedding_levels(arg1, arg2, arg3)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ParseEnum parses an enum type and stores the result in @value.
//
// If @str does not match the nick name of any of the possible values for the
// enum and is not an integer, false is returned, a warning is issued if @warn
// is true, and a string representing the list of possible values is stored in
// @possible_values. The list is slash-separated, eg. "none/start/middle/end".
// If failed and @possible_values is not nil, returned string should be freed
// using g_free().
func ParseEnum(typ externglib.Type, str string, warn bool) (value int, possibleValues string, ok bool) {
	var arg1 C.GType
	var arg2 *C.char
	var arg3 *C.int // out
	var arg4 C.gboolean
	var arg5 **C.char // out

	arg1 = C.GType(typ)
	arg2 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg2))
	if warn {
		arg4 = C.TRUE
	}

	ret := C.pango_parse_enum(arg1, arg2, &arg3, arg4, &arg5)

	var ret0 int
	var ret1 string
	var ret2 bool

	ret0 = int(arg3)

	ret1 = C.GoString(arg5)
	C.free(unsafe.Pointer(arg5))

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// ParseStretch parses a font stretch.
//
// The allowed values are "ultra_condensed", "extra_condensed", "condensed",
// "semi_condensed", "normal", "semi_expanded", "expanded", "extra_expanded" and
// "ultra_expanded". Case variations are ignored and the '_' characters may be
// omitted.
func ParseStretch(str string, warn bool) (stretch Stretch, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoStretch // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	if warn {
		arg3 = C.TRUE
	}

	ret := C.pango_parse_stretch(arg1, &arg2, arg3)

	var ret0 *Stretch
	var ret1 bool

	ret0 = (*Stretch)(arg2)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// ParseStyle parses a font style.
//
// The allowed values are "normal", "italic" and "oblique", case variations
// being ignored.
func ParseStyle(str string, warn bool) (style Style, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoStyle // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	if warn {
		arg3 = C.TRUE
	}

	ret := C.pango_parse_style(arg1, &arg2, arg3)

	var ret0 *Style
	var ret1 bool

	ret0 = (*Style)(arg2)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// ParseVariant parses a font variant.
//
// The allowed values are "normal" and "smallcaps" or "small_caps", case
// variations being ignored.
func ParseVariant(str string, warn bool) (variant Variant, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoVariant // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	if warn {
		arg3 = C.TRUE
	}

	ret := C.pango_parse_variant(arg1, &arg2, arg3)

	var ret0 *Variant
	var ret1 bool

	ret0 = (*Variant)(arg2)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// ParseWeight parses a font weight.
//
// The allowed values are "heavy", "ultrabold", "bold", "normal", "light",
// "ultraleight" and integers. Case variations are ignored.
func ParseWeight(str string, warn bool) (weight Weight, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoWeight // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	if warn {
		arg3 = C.TRUE
	}

	ret := C.pango_parse_weight(arg1, &arg2, arg3)

	var ret0 *Weight
	var ret1 bool

	ret0 = (*Weight)(arg2)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// QuantizeLineGeometry quantizes the thickness and position of a line to whole
// device pixels.
//
// This is typically used for underline or strikethrough. The purpose of this
// function is to avoid such lines looking blurry.
//
// Care is taken to make sure @thickness is at least one pixel when this
// function returns, but returned @position may become zero as a result of
// rounding.
func QuantizeLineGeometry(thickness int, position int) {
	var arg1 *C.int
	var arg2 *C.int

	arg1 = (*C.int)(thickness)
	arg2 = (*C.int)(position)

	C.pango_quantize_line_geometry(arg1, arg2)
}

// ReadLine reads an entire line from a file into a buffer.
//
// Lines may be delimited with '\n', '\r', '\n\r', or '\r\n'. The delimiter is
// not written into the buffer. Text after a '#' character is treated as a
// comment and skipped. '\' can be used to escape a
//
// character.
//
// '\' proceeding a line delimiter combines adjacent lines. A '\' proceeding any
// other character is ignored and written into the output buffer unmodified.
func ReadLine(stream interface{}, str *glib.String) int {
	var arg1 *C.FILE
	var arg2 *C.GString

	arg1 = C.gpointer(box.Assign(stream))
	arg2 = (*C.GString)(str.Native())

	ret := C.pango_read_line(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ScanInt scans an integer.
//
// Leading white space is skipped.
func ScanInt(pos string) (out int, ok bool) {
	var arg1 **C.char
	var arg2 *C.int // out

	arg1 = (*C.gchar)(C.CString(pos))

	ret := C.pango_scan_int(arg1, &arg2)

	var ret0 int
	var ret1 bool

	ret0 = int(arg2)

	ret1 = C.bool(ret) != C.false

	return ret0, ret1
}

// ScanString scans a string into a #GString buffer.
//
// The string may either be a sequence of non-white-space characters, or a
// quoted string with '"'. Instead a quoted string, '\"' represents a literal
// quote. Leading white space outside of quotes is skipped.
func ScanString(pos string, out *glib.String) bool {
	var arg1 **C.char
	var arg2 *C.GString

	arg1 = (*C.gchar)(C.CString(pos))
	arg2 = (*C.GString)(out.Native())

	ret := C.pango_scan_string(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ScanWord scans a word into a #GString buffer.
//
// A word consists of [A-Za-z_] followed by zero or more [A-Za-z_0-9]. Leading
// white space is skipped.
func ScanWord(pos string, out *glib.String) bool {
	var arg1 **C.char
	var arg2 *C.GString

	arg1 = (*C.gchar)(C.CString(pos))
	arg2 = (*C.GString)(out.Native())

	ret := C.pango_scan_word(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SkipSpace skips 0 or more characters of white space.
func SkipSpace(pos string) bool {
	var arg1 **C.char

	arg1 = (*C.gchar)(C.CString(pos))

	ret := C.pango_skip_space(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SplitFileList splits a G_SEARCHPATH_SEPARATOR-separated list of files,
// stripping white space and substituting ~/ with $HOME/.
func SplitFileList(str string) []string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_split_file_list(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// TrimString trims leading and trailing whitespace from a string.
func TrimString(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_trim_string(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
func Version() int {
	ret := C.pango_version()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
func VersionCheck(requiredMajor int, requiredMinor int, requiredMicro int) string {
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int

	arg1 = C.int(requiredMajor)
	arg2 = C.int(requiredMinor)
	arg3 = C.int(requiredMicro)

	ret := C.pango_version_check(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
func VersionString() string {
	ret := C.pango_version_string()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}
