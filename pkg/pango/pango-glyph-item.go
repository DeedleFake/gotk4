// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_glyph_item_get_type()), F: marshalGlyphItem},
		{T: externglib.Type(C.pango_glyph_item_iter_get_type()), F: marshalGlyphItemIter},
	})
}

// GlyphItem: a `PangoGlyphItem` is a pair of a `PangoItem` and the glyphs
// resulting from shaping the items text.
//
// As an example of the usage of `PangoGlyphItem`, the results of shaping text
// with `PangoLayout` is a list of `PangoLayoutLine`, each of which contains a
// list of `PangoGlyphItem`.
type GlyphItem struct {
	native C.PangoGlyphItem
}

// WrapGlyphItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItem(ptr unsafe.Pointer) *GlyphItem {
	if ptr == nil {
		return nil
	}

	return (*GlyphItem)(ptr)
}

func marshalGlyphItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItem(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *GlyphItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Item gets the field inside the struct.
func (g *GlyphItem) Item() *Item {
	var ret *Item
	{
		ret = WrapItem(unsafe.Pointer(g.native.item))
	}
	return ret
}

// Glyphs gets the field inside the struct.
func (g *GlyphItem) Glyphs() *GlyphString {
	var ret *GlyphString
	{
		ret = WrapGlyphString(unsafe.Pointer(g.native.glyphs))
	}
	return ret
}

// ApplyAttrs splits a shaped item (`PangoGlyphItem`) into multiple items based
// on an attribute list.
//
// The idea is that if you have attributes that don't affect shaping, such as
// color or underline, to avoid affecting shaping, you filter them out
// ([method@Pango.AttrList.filter]), apply the shaping process and then reapply
// them to the result using this function.
//
// All attributes that start or end inside a cluster are applied to that
// cluster; for instance, if half of a cluster is underlined and the other-half
// strikethrough, then the cluster will end up with both underline and
// strikethrough attributes. In these cases, it may happen that
// @item->extra_attrs for some of the result items can have multiple attributes
// of the same type.
//
// This function takes ownership of @glyph_item; it will be reused as one of the
// elements in the list.
func (g *GlyphItem) ApplyAttrs(text string, list *AttrList) *glib.SList {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 *C.PangoAttrList

	arg0 = (*C.PangoGlyphItem)(g.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_glyph_item_apply_attrs(arg0, arg1, arg2)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Copy: make a deep copy of an existing `PangoGlyphItem` structure.
func (o *GlyphItem) Copy() *GlyphItem {
	var arg0 *C.PangoGlyphItem

	arg0 = (*C.PangoGlyphItem)(o.Native())

	ret := C.pango_glyph_item_copy(arg0)

	var ret0 *GlyphItem

	{
		ret0 = WrapGlyphItem(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *GlyphItem) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a `PangoGlyphItem` and resources to which it points.
func (g *GlyphItem) Free() {
	var arg0 *C.PangoGlyphItem

	arg0 = (*C.PangoGlyphItem)(g.Native())

	C.pango_glyph_item_free(arg0)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item).
//
// This function is similar in function to pango_item_split() (and uses it
// internally.)
func (o *GlyphItem) Split(text string, splitIndex int) *GlyphItem {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoGlyphItem)(o.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(splitIndex)

	ret := C.pango_glyph_item_split(arg0, arg1, arg2)

	var ret0 *GlyphItem

	{
		ret0 = WrapGlyphItem(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *GlyphItem) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// GlyphItemIter: a `PangoGlyphItemIter` is an iterator over the clusters in a
// `PangoGlyphItem`.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing @start_index and @start_char values. If @glyph_item
// is right-to-left (that is, if `glyph_item->item->analysis.level` is odd),
// then @start_glyph decreases as the iterator moves forward. Moreover, in
// right-to-left cases, @start_glyph is greater than @end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or pango_glyph_item_iter_init_end(), for
// forward and backward iteration respectively, and walked over using any
// desired mixture of pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
// “` PangoGlyphItemIter cluster_iter; gboolean have_cluster;
//
// for (have_cluster = pango_glyph_item_iter_init_start (&cluster_iter,
// glyph_item, text); have_cluster; have_cluster =
// pango_glyph_item_iter_next_cluster (&cluster_iter)) { ... } “`
//
// Note that @text is the start of the text for layout, which is then indexed by
// `glyph_item->item->offset` to get to the text of @glyph_item. The
// @start_index and @end_index values can directly index into @text. The
// @start_glyph, @end_glyph, @start_char, and @end_char values however are
// zero-based for the @glyph_item. For each cluster, the item pointed at by the
// start variables is included in the cluster while the one pointed at by end
// variables is not.
//
// None of the members of a `PangoGlyphItemIter` should be modified manually.
type GlyphItemIter struct {
	native C.PangoGlyphItemIter
}

// WrapGlyphItemIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItemIter(ptr unsafe.Pointer) *GlyphItemIter {
	if ptr == nil {
		return nil
	}

	return (*GlyphItemIter)(ptr)
}

func marshalGlyphItemIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItemIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *GlyphItemIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphItem gets the field inside the struct.
func (g *GlyphItemIter) GlyphItem() *GlyphItem {
	var ret *GlyphItem
	{
		ret = WrapGlyphItem(unsafe.Pointer(g.native.glyph_item))
	}
	return ret
}

// Text gets the field inside the struct.
func (g *GlyphItemIter) Text() string {
	var ret string
	ret = C.GoString(g.native.text)
	return ret
}

// StartGlyph gets the field inside the struct.
func (g *GlyphItemIter) StartGlyph() int {
	var ret int
	ret = int(g.native.start_glyph)
	return ret
}

// StartIndex gets the field inside the struct.
func (g *GlyphItemIter) StartIndex() int {
	var ret int
	ret = int(g.native.start_index)
	return ret
}

// StartChar gets the field inside the struct.
func (g *GlyphItemIter) StartChar() int {
	var ret int
	ret = int(g.native.start_char)
	return ret
}

// EndGlyph gets the field inside the struct.
func (g *GlyphItemIter) EndGlyph() int {
	var ret int
	ret = int(g.native.end_glyph)
	return ret
}

// EndIndex gets the field inside the struct.
func (g *GlyphItemIter) EndIndex() int {
	var ret int
	ret = int(g.native.end_index)
	return ret
}

// EndChar gets the field inside the struct.
func (g *GlyphItemIter) EndChar() int {
	var ret int
	ret = int(g.native.end_char)
	return ret
}

// Copy: make a shallow copy of an existing `PangoGlyphItemIter` structure.
func (o *GlyphItemIter) Copy() *GlyphItemIter {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(o.Native())

	ret := C.pango_glyph_item_iter_copy(arg0)

	var ret0 *GlyphItemIter

	{
		ret0 = WrapGlyphItemIter(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *GlyphItemIter) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a `PangoGlyphItem`Iter.
func (i *GlyphItemIter) Free() {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(i.Native())

	C.pango_glyph_item_iter_free(arg0)
}

// InitEnd initializes a `PangoGlyphItemIter` structure to point to the last
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) InitEnd(glyphItem *GlyphItem, text string) bool {
	var arg0 *C.PangoGlyphItemIter
	var arg1 *C.PangoGlyphItem
	var arg2 *C.char

	arg0 = (*C.PangoGlyphItemIter)(i.Native())
	arg1 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.pango_glyph_item_iter_init_end(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// InitStart initializes a `PangoGlyphItemIter` structure to point to the first
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) InitStart(glyphItem *GlyphItem, text string) bool {
	var arg0 *C.PangoGlyphItemIter
	var arg1 *C.PangoGlyphItem
	var arg2 *C.char

	arg0 = (*C.PangoGlyphItemIter)(i.Native())
	arg1 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.pango_glyph_item_iter_init_start(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// NextCluster advances the iterator to the next cluster in the glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) NextCluster() bool {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(i.Native())

	ret := C.pango_glyph_item_iter_next_cluster(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PrevCluster moves the iterator to the preceding cluster in the glyph item.
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) PrevCluster() bool {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(i.Native())

	ret := C.pango_glyph_item_iter_prev_cluster(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}
