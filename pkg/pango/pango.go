// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <pango/pango.h>
//
// extern gpointer gotk4_AttrDataCopyFunc(gconstpointer)
// extern gboolean gotk4_AttrFilterFunc(PangoAttribute*, gpointer)
// extern gboolean gotk4_FontsetForeachFunc(PangoFontset*, PangoFont*, gpointer)
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.pango_alignment_get_type()), F: marshalAlignment},
		{T: externglib.Type(C.pango_attr_type_get_type()), F: marshalAttrType},
		{T: externglib.Type(C.pango_bidi_type_get_type()), F: marshalBidiType},
		{T: externglib.Type(C.pango_coverage_level_get_type()), F: marshalCoverageLevel},
		{T: externglib.Type(C.pango_direction_get_type()), F: marshalDirection},
		{T: externglib.Type(C.pango_ellipsize_mode_get_type()), F: marshalEllipsizeMode},
		{T: externglib.Type(C.pango_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.pango_gravity_hint_get_type()), F: marshalGravityHint},
		{T: externglib.Type(C.pango_overline_get_type()), F: marshalOverline},
		{T: externglib.Type(C.pango_render_part_get_type()), F: marshalRenderPart},
		{T: externglib.Type(C.pango_script_get_type()), F: marshalScript},
		{T: externglib.Type(C.pango_stretch_get_type()), F: marshalStretch},
		{T: externglib.Type(C.pango_style_get_type()), F: marshalStyle},
		{T: externglib.Type(C.pango_tab_align_get_type()), F: marshalTabAlign},
		{T: externglib.Type(C.pango_underline_get_type()), F: marshalUnderline},
		{T: externglib.Type(C.pango_variant_get_type()), F: marshalVariant},
		{T: externglib.Type(C.pango_weight_get_type()), F: marshalWeight},
		{T: externglib.Type(C.pango_wrap_mode_get_type()), F: marshalWrapMode},

		// Bitfields
		{T: externglib.Type(C.pango_font_mask_get_type()), F: marshalFontMask},
		{T: externglib.Type(C.pango_shape_flags_get_type()), F: marshalShapeFlags},
		{T: externglib.Type(C.pango_show_flags_get_type()), F: marshalShowFlags},

		// Records
		// Skipped Analysis.
		// Skipped AttrClass.
		// Skipped AttrColor.
		// Skipped AttrFloat.
		// Skipped AttrFontDesc.
		// Skipped AttrFontFeatures.
		// Skipped AttrInt.
		{T: externglib.Type(C.pango_attr_iterator_get_type()), F: marshalAttrIterator},
		// Skipped AttrLanguage.
		{T: externglib.Type(C.pango_attr_list_get_type()), F: marshalAttrList},
		// Skipped AttrShape.
		// Skipped AttrSize.
		// Skipped AttrString.
		{T: externglib.Type(C.pango_attribute_get_type()), F: marshalAttribute},
		{T: externglib.Type(C.pango_color_get_type()), F: marshalColor},
		// Skipped ContextClass.
		// Skipped FontClass.
		{T: externglib.Type(C.pango_font_description_get_type()), F: marshalFontDescription},
		// Skipped FontFaceClass.
		// Skipped FontFamilyClass.
		// Skipped FontMapClass.
		{T: externglib.Type(C.pango_font_metrics_get_type()), F: marshalFontMetrics},
		// Skipped FontsetClass.
		// Skipped FontsetSimpleClass.
		// Skipped GlyphGeometry.
		// Skipped GlyphInfo.
		{T: externglib.Type(C.pango_glyph_item_get_type()), F: marshalGlyphItem},
		{T: externglib.Type(C.pango_glyph_item_iter_get_type()), F: marshalGlyphItemIter},
		{T: externglib.Type(C.pango_glyph_string_get_type()), F: marshalGlyphString},
		// Skipped GlyphVisAttr.
		{T: externglib.Type(C.pango_item_get_type()), F: marshalItem},
		{T: externglib.Type(C.pango_language_get_type()), F: marshalLanguage},
		// Skipped LayoutClass.
		{T: externglib.Type(C.pango_layout_iter_get_type()), F: marshalLayoutIter},
		{T: externglib.Type(C.pango_layout_line_get_type()), F: marshalLayoutLine},
		// Skipped LogAttr.
		{T: externglib.Type(C.pango_matrix_get_type()), F: marshalMatrix},
		// Skipped Rectangle.
		// Skipped RendererClass.
		// Skipped RendererPrivate.
		{T: externglib.Type(C.pango_script_iter_get_type()), F: marshalScriptIter},
		{T: externglib.Type(C.pango_tab_array_get_type()), F: marshalTabArray},

		// Classes
		{T: externglib.Type(C.pango_context_get_type()), F: marshalContext},
		{T: externglib.Type(C.pango_coverage_get_type()), F: marshalCoverage},
		{T: externglib.Type(C.pango_font_get_type()), F: marshalFont},
		{T: externglib.Type(C.pango_font_face_get_type()), F: marshalFontFace},
		{T: externglib.Type(C.pango_font_family_get_type()), F: marshalFontFamily},
		{T: externglib.Type(C.pango_font_map_get_type()), F: marshalFontMap},
		{T: externglib.Type(C.pango_fontset_get_type()), F: marshalFontset},
		{T: externglib.Type(C.pango_fontset_simple_get_type()), F: marshalFontsetSimple},
		{T: externglib.Type(C.pango_layout_get_type()), F: marshalLayout},
		{T: externglib.Type(C.pango_renderer_get_type()), F: marshalRenderer},
	})
}

// Glyph: a `PangoGlyph` represents a single glyph in the output form of a
// string.
type Glyph uint32

// GlyphUnit: the `PangoGlyphUnit` type is used to store dimensions within
// Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit. (A device unit might
// be a pixel for screen display, or a point on a printer.) PANGO_SCALE is
// currently 1024, and may change in the future (unlikely though), but you
// should not depend on its exact value. The PANGO_PIXELS() macro can be used to
// convert from glyph units into device units with correct rounding.
type GlyphUnit int32

// LayoutRun: a `PangoLayoutRun` represents a single run within a
// `PangoLayoutLine`.
//
// It is simply an alternate name for [struct@Pango.GlyphItem]. See the
// [struct@Pango.GlyphItem] docs for details on the fields.
type LayoutRun GlyphItem

// Alignment: `PangoAlignment` describes how to align the lines of a
// `PangoLayout` within the available space.
//
// If the `PangoLayout` is set to justify using
// [method@Pango.Layout.set_justify], this only has effect for partial lines.
type Alignment int

const (
	// AlignmentLeft: put all available space on the right
	AlignmentLeft Alignment = 0
	// AlignmentCenter: center the line within the available space
	AlignmentCenter Alignment = 1
	// AlignmentRight: put all available space on the left
	AlignmentRight Alignment = 2
)

func marshalAlignment(p uintptr) (interface{}, error) {
	return Alignment(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttrType: the `PangoAttrType` distinguishes between different types of
// attributes.
//
// Along with the predefined values, it is possible to allocate additional
// values for custom attributes using [type_func@attr_type_register]. The
// predefined values are given below. The type of structure used to store the
// attribute is listed in parentheses after the description.
type AttrType int

const (
	// AttrTypeInvalid does not happen
	AttrTypeInvalid AttrType = 0
	// AttrTypeLanguage: language ([struct@Pango.AttrLanguage])
	AttrTypeLanguage AttrType = 1
	// AttrTypeFamily: font family name list ([struct@Pango.AttrString])
	AttrTypeFamily AttrType = 2
	// AttrTypeStyle: font slant style ([struct@Pango.AttrInt])
	AttrTypeStyle AttrType = 3
	// AttrTypeWeight: font weight ([struct@Pango.AttrInt])
	AttrTypeWeight AttrType = 4
	// AttrTypeVariant: font variant (normal or small caps)
	// ([struct@Pango.AttrInt])
	AttrTypeVariant AttrType = 5
	// AttrTypeStretch: font stretch ([struct@Pango.AttrInt])
	AttrTypeStretch AttrType = 6
	// AttrTypeSize: font size in points scaled by PANGO_SCALE
	// ([struct@Pango.AttrInt])
	AttrTypeSize AttrType = 7
	// AttrTypeFontDesc: font description ([struct@Pango.AttrFontDesc])
	AttrTypeFontDesc AttrType = 8
	// AttrTypeForeground: foreground color ([struct@Pango.AttrColor])
	AttrTypeForeground AttrType = 9
	// AttrTypeBackground: background color ([struct@Pango.AttrColor])
	AttrTypeBackground AttrType = 10
	// AttrTypeUnderline: whether the text has an underline
	// ([struct@Pango.AttrInt])
	AttrTypeUnderline AttrType = 11
	// AttrTypeStrikethrough: whether the text is struck-through
	// ([struct@Pango.AttrInt])
	AttrTypeStrikethrough AttrType = 12
	// AttrTypeRise: baseline displacement ([struct@Pango.AttrInt])
	AttrTypeRise AttrType = 13
	// AttrTypeShape: shape ([struct@Pango.AttrShape])
	AttrTypeShape AttrType = 14
	// AttrTypeScale: font size scale factor ([struct@Pango.AttrFloat])
	AttrTypeScale AttrType = 15
	// AttrTypeFallback: whether fallback is enabled ([struct@Pango.AttrInt])
	AttrTypeFallback AttrType = 16
	// AttrTypeLetterSpacing: letter spacing ([struct@PangoAttrInt])
	AttrTypeLetterSpacing AttrType = 17
	// AttrTypeUnderlineColor: underline color ([struct@Pango.AttrColor])
	AttrTypeUnderlineColor AttrType = 18
	// AttrTypeStrikethroughColor: strikethrough color
	// ([struct@Pango.AttrColor])
	AttrTypeStrikethroughColor AttrType = 19
	// AttrTypeAbsoluteSize: font size in pixels scaled by PANGO_SCALE
	// ([struct@Pango.AttrInt])
	AttrTypeAbsoluteSize AttrType = 20
	// AttrTypeGravity: base text gravity ([struct@Pango.AttrInt])
	AttrTypeGravity AttrType = 21
	// AttrTypeGravityHint: gravity hint ([struct@Pango.AttrInt])
	AttrTypeGravityHint AttrType = 22
	// AttrTypeFontFeatures: openType font features ([struct@Pango.AttrString]).
	// Since 1.38
	AttrTypeFontFeatures AttrType = 23
	// AttrTypeForegroundAlpha: foreground alpha ([struct@Pango.AttrInt]). Since
	// 1.38
	AttrTypeForegroundAlpha AttrType = 24
	// AttrTypeBackgroundAlpha: background alpha ([struct@Pango.AttrInt]). Since
	// 1.38
	AttrTypeBackgroundAlpha AttrType = 25
	// AttrTypeAllowBreaks: whether breaks are allowed ([struct@Pango.AttrInt]).
	// Since 1.44
	AttrTypeAllowBreaks AttrType = 26
	// AttrTypeShow: how to render invisible characters
	// ([struct@Pango.AttrInt]). Since 1.44
	AttrTypeShow AttrType = 27
	// AttrTypeInsertHyphens: whether to insert hyphens at intra-word line
	// breaks ([struct@Pango.AttrInt]). Since 1.44
	AttrTypeInsertHyphens AttrType = 28
	// AttrTypeOverline: whether the text has an overline
	// ([struct@Pango.AttrInt]). Since 1.46
	AttrTypeOverline AttrType = 29
	// AttrTypeOverlineColor: overline color ([struct@Pango.AttrColor]). Since
	// 1.46
	AttrTypeOverlineColor AttrType = 30
)

func marshalAttrType(p uintptr) (interface{}, error) {
	return AttrType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BidiType: `PangoBidiType` represents the bidirectional character type of a
// Unicode character as specified by the <ulink
// url="http://www.unicode.org/reports/tr9/">Unicode bidirectional
// algorithm</ulink>.
type BidiType int

const (
	// BidiTypeL: left-to-Right
	BidiTypeL BidiType = 0
	// BidiTypeLre: left-to-Right Embedding
	BidiTypeLre BidiType = 1
	// BidiTypeLro: left-to-Right Override
	BidiTypeLro BidiType = 2
	// BidiTypeR: right-to-Left
	BidiTypeR BidiType = 3
	// BidiTypeAl: right-to-Left Arabic
	BidiTypeAl BidiType = 4
	// BidiTypeRle: right-to-Left Embedding
	BidiTypeRle BidiType = 5
	// BidiTypeRlo: right-to-Left Override
	BidiTypeRlo BidiType = 6
	// BidiTypePdf: pop Directional Format
	BidiTypePdf BidiType = 7
	// BidiTypeEn: european Number
	BidiTypeEn BidiType = 8
	// BidiTypeES: european Number Separator
	BidiTypeES BidiType = 9
	// BidiTypeEt: european Number Terminator
	BidiTypeEt BidiType = 10
	// BidiTypeAn: arabic Number
	BidiTypeAn BidiType = 11
	// BidiTypeCs: common Number Separator
	BidiTypeCs BidiType = 12
	// BidiTypeNsm: nonspacing Mark
	BidiTypeNsm BidiType = 13
	// BidiTypeBn: boundary Neutral
	BidiTypeBn BidiType = 14
	// BidiTypeB: paragraph Separator
	BidiTypeB BidiType = 15
	// BidiTypeS: segment Separator
	BidiTypeS BidiType = 16
	// BidiTypeWs: whitespace
	BidiTypeWs BidiType = 17
	// BidiTypeOn: other Neutrals
	BidiTypeOn BidiType = 18
)

func marshalBidiType(p uintptr) (interface{}, error) {
	return BidiType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CoverageLevel: `PangoCoverageLevel` is used to indicate how well a font can
// represent a particular Unicode character for a particular script.
//
// Since 1.44, only PANGO_COVERAGE_NONE and PANGO_COVERAGE_EXACT will be
// returned.
type CoverageLevel int

const (
	// CoverageLevelNone: the character is not representable with the font.
	CoverageLevelNone CoverageLevel = 0
	// CoverageLevelFallback: the character is represented in a way that may be
	// comprehensible but is not the correct graphical form. For instance, a
	// Hangul character represented as a a sequence of Jamos, or a Latin
	// transliteration of a Cyrillic word.
	CoverageLevelFallback CoverageLevel = 1
	// CoverageLevelApproximate: the character is represented as basically the
	// correct graphical form, but with a stylistic variant inappropriate for
	// the current script.
	CoverageLevelApproximate CoverageLevel = 2
	// CoverageLevelExact: the character is represented as the correct graphical
	// form.
	CoverageLevelExact CoverageLevel = 3
)

func marshalCoverageLevel(p uintptr) (interface{}, error) {
	return CoverageLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Direction: `PangoDirection` represents a direction in the Unicode
// bidirectional algorithm.
//
// Not every value in this enumeration makes sense for every usage of
// `PangoDirection`; for example, the return value of [func@unichar_direction]
// and [func@find_base_dir] cannot be PANGO_DIRECTION_WEAK_LTR or
// PANGO_DIRECTION_WEAK_RTL, since every character is either neutral or has a
// strong direction; on the other hand PANGO_DIRECTION_NEUTRAL doesn't make
// sense to pass to [func@itemize_with_base_dir].
//
// The PANGO_DIRECTION_TTB_LTR, PANGO_DIRECTION_TTB_RTL values come from an
// earlier interpretation of this enumeration as the writing direction of a
// block of text and are no longer used; See `PangoGravity` for how vertical
// text is handled in Pango.
//
// If you are interested in text direction, you should really use fribidi
// directly. `PangoDirection` is only retained because it is used in some public
// apis.
type Direction int

const (
	// DirectionLTR: a strong left-to-right direction
	DirectionLTR Direction = 0
	// DirectionRTL: a strong right-to-left direction
	DirectionRTL Direction = 1
	// DirectionTtbLTR: deprecated value; treated the same as
	// PANGO_DIRECTION_RTL.
	DirectionTtbLTR Direction = 2
	// DirectionTtbRTL: deprecated value; treated the same as
	// PANGO_DIRECTION_LTR
	DirectionTtbRTL Direction = 3
	// DirectionWeakLTR: a weak left-to-right direction
	DirectionWeakLTR Direction = 4
	// DirectionWeakRTL: a weak right-to-left direction
	DirectionWeakRTL Direction = 5
	// DirectionNeutral: no direction specified
	DirectionNeutral Direction = 6
)

func marshalDirection(p uintptr) (interface{}, error) {
	return Direction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EllipsizeMode: `PangoEllipsizeMode` describes what sort of ellipsization
// should be applied to text.
//
// In the ellipsization process characters are removed from the text in order to
// make it fit to a given width and replaced with an ellipsis.
type EllipsizeMode int

const (
	// EllipsizeModeNone: no ellipsization
	EllipsizeModeNone EllipsizeMode = 0
	// EllipsizeModeStart: omit characters at the start of the text
	EllipsizeModeStart EllipsizeMode = 1
	// EllipsizeModeMiddle: omit characters in the middle of the text
	EllipsizeModeMiddle EllipsizeMode = 2
	// EllipsizeModeEnd: omit characters at the end of the text
	EllipsizeModeEnd EllipsizeMode = 3
)

func marshalEllipsizeMode(p uintptr) (interface{}, error) {
	return EllipsizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity: `PangoGravity` represents the orientation of glyphs in a segment of
// text.
//
// This is useful when rendering vertical text layouts. In those situations, the
// layout is rotated using a non-identity [struct@Pango.Matrix], and then glyph
// orientation is controlled using `PangoGravity`.
//
// Not every value in this enumeration makes sense for every usage of
// `PangoGravity`; for example, PANGO_GRAVITY_AUTO only can be passed to
// [method@Pango.Context.set_base_gravity] and can only be returned by
// [method@Pango.Context.get_base_gravity].
//
// See also: [enum@Pango.GravityHint]
type Gravity int

const (
	// GravitySouth glyphs stand upright (default)
	GravitySouth Gravity = 0
	// GravityEast glyphs are rotated 90 degrees clockwise
	GravityEast Gravity = 1
	// GravityNorth glyphs are upside-down
	GravityNorth Gravity = 2
	// GravityWest glyphs are rotated 90 degrees counter-clockwise
	GravityWest Gravity = 3
	// GravityAuto: gravity is resolved from the context matrix
	GravityAuto Gravity = 4
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GravityHint: `PangoGravityHint` defines how horizontal scripts should behave
// in a vertical context.
//
// That is, English excerpts in a vertical paragraph for example.
//
// See also [enum@Pango.Gravity]
type GravityHint int

const (
	// GravityHintNatural scripts will take their natural gravity based on the
	// base gravity and the script. This is the default.
	GravityHintNatural GravityHint = 0
	// GravityHintStrong always use the base gravity set, regardless of the
	// script.
	GravityHintStrong GravityHint = 1
	// GravityHintLine: for scripts not in their natural direction (eg. Latin in
	// East gravity), choose per-script gravity such that every script respects
	// the line progression. This means, Latin and Arabic will take opposite
	// gravities and both flow top-to-bottom for example.
	GravityHintLine GravityHint = 2
)

func marshalGravityHint(p uintptr) (interface{}, error) {
	return GravityHint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overline: the `PangoOverline` enumeration is used to specify whether text
// should be overlined, and if so, the type of line.
type Overline int

const (
	// OverlineNone: no overline should be drawn
	OverlineNone Overline = 0
	// OverlineSingle: draw a single line above the ink extents of the text
	// being underlined.
	OverlineSingle Overline = 1
)

func marshalOverline(p uintptr) (interface{}, error) {
	return Overline(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderPart defines different items to render for such purposes as setting
// colors.
type RenderPart int

const (
	// RenderPartForeground: the text itself
	RenderPartForeground RenderPart = 0
	// RenderPartBackground: the area behind the text
	RenderPartBackground RenderPart = 1
	// RenderPartUnderline: underlines
	RenderPartUnderline RenderPart = 2
	// RenderPartStrikethrough: strikethrough lines
	RenderPartStrikethrough RenderPart = 3
	// RenderPartOverline: overlines
	RenderPartOverline RenderPart = 4
)

func marshalRenderPart(p uintptr) (interface{}, error) {
	return RenderPart(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Script: the `PangoScript` enumeration identifies different writing systems.
//
// The values correspond to the names as defined in the Unicode standard. See
// Unicode Standard Annex 24: Script names
// (http://www.unicode.org/reports/tr24/)
//
// Note that this enumeration is deprecated and will not be updated to include
// values in newer versions of the Unicode standard. Applications should use the
// `GUnicodeScript` enumeration instead, whose values are interchangeable with
// `PangoScript`.
type Script int

const (
	// ScriptInvalidCode: a value never returned from pango_script_for_unichar()
	ScriptInvalidCode Script = -1
	// ScriptCommon: a character used by multiple different scripts
	ScriptCommon Script = 0
	// ScriptInherited: a mark glyph that takes its script from the base glyph
	// to which it is attached
	ScriptInherited Script = 1
	// ScriptArabic: arabic
	ScriptArabic Script = 2
	// ScriptArmenian: armenian
	ScriptArmenian Script = 3
	// ScriptBengali: bengali
	ScriptBengali Script = 4
	// ScriptBopomofo: bopomofo
	ScriptBopomofo Script = 5
	// ScriptCherokee: cherokee
	ScriptCherokee Script = 6
	// ScriptCoptic: coptic
	ScriptCoptic Script = 7
	// ScriptCyrillic: cyrillic
	ScriptCyrillic Script = 8
	// ScriptDeseret: deseret
	ScriptDeseret Script = 9
	// ScriptDevanagari: devanagari
	ScriptDevanagari Script = 10
	// ScriptEthiopic: ethiopic
	ScriptEthiopic Script = 11
	// ScriptGeorgian: georgian
	ScriptGeorgian Script = 12
	// ScriptGothic: gothic
	ScriptGothic Script = 13
	// ScriptGreek: greek
	ScriptGreek Script = 14
	// ScriptGujarati: gujarati
	ScriptGujarati Script = 15
	// ScriptGurmukhi: gurmukhi
	ScriptGurmukhi Script = 16
	// ScriptHan: han
	ScriptHan Script = 17
	// ScriptHangul: hangul
	ScriptHangul Script = 18
	// ScriptHebrew: hebrew
	ScriptHebrew Script = 19
	// ScriptHiragana: hiragana
	ScriptHiragana Script = 20
	// ScriptKannada: kannada
	ScriptKannada Script = 21
	// ScriptKatakana: katakana
	ScriptKatakana Script = 22
	// ScriptKhmer: khmer
	ScriptKhmer Script = 23
	// ScriptLao: lao
	ScriptLao Script = 24
	// ScriptLatin: latin
	ScriptLatin Script = 25
	// ScriptMalayalam: malayalam
	ScriptMalayalam Script = 26
	// ScriptMongolian: mongolian
	ScriptMongolian Script = 27
	// ScriptMyanmar: myanmar
	ScriptMyanmar Script = 28
	// ScriptOgham: ogham
	ScriptOgham Script = 29
	// ScriptOldItalic: old Italic
	ScriptOldItalic Script = 30
	// ScriptOriya: oriya
	ScriptOriya Script = 31
	// ScriptRunic: runic
	ScriptRunic Script = 32
	// ScriptSinhala: sinhala
	ScriptSinhala Script = 33
	// ScriptSyriac: syriac
	ScriptSyriac Script = 34
	// ScriptTamil: tamil
	ScriptTamil Script = 35
	// ScriptTelugu: telugu
	ScriptTelugu Script = 36
	// ScriptThaana: thaana
	ScriptThaana Script = 37
	// ScriptThai: thai
	ScriptThai Script = 38
	// ScriptTibetan: tibetan
	ScriptTibetan Script = 39
	// ScriptCanadianAboriginal: canadian Aboriginal
	ScriptCanadianAboriginal Script = 40
	// ScriptYi: yi
	ScriptYi Script = 41
	// ScriptTagalog: tagalog
	ScriptTagalog Script = 42
	// ScriptHanunoo: hanunoo
	ScriptHanunoo Script = 43
	// ScriptBuhid: buhid
	ScriptBuhid Script = 44
	// ScriptTagbanwa: tagbanwa
	ScriptTagbanwa Script = 45
	// ScriptBraille: braille
	ScriptBraille Script = 46
	// ScriptCypriot: cypriot
	ScriptCypriot Script = 47
	// ScriptLimbu: limbu
	ScriptLimbu Script = 48
	// ScriptOsmanya: osmanya
	ScriptOsmanya Script = 49
	// ScriptShavian: shavian
	ScriptShavian Script = 50
	// ScriptLinearB: linear B
	ScriptLinearB Script = 51
	// ScriptTaiLe: tai Le
	ScriptTaiLe Script = 52
	// ScriptUgaritic: ugaritic
	ScriptUgaritic Script = 53
	// ScriptNewTaiLue: new Tai Lue. Since 1.10
	ScriptNewTaiLue Script = 54
	// ScriptBuginese: buginese. Since 1.10
	ScriptBuginese Script = 55
	// ScriptGlagolitic: glagolitic. Since 1.10
	ScriptGlagolitic Script = 56
	// ScriptTifinagh: tifinagh. Since 1.10
	ScriptTifinagh Script = 57
	// ScriptSylotiNagri: syloti Nagri. Since 1.10
	ScriptSylotiNagri Script = 58
	// ScriptOldPersian: old Persian. Since 1.10
	ScriptOldPersian Script = 59
	// ScriptKharoshthi: kharoshthi. Since 1.10
	ScriptKharoshthi Script = 60
	// ScriptUnknown: an unassigned code point. Since 1.14
	ScriptUnknown Script = 61
	// ScriptBalinese: balinese. Since 1.14
	ScriptBalinese Script = 62
	// ScriptCuneiform: cuneiform. Since 1.14
	ScriptCuneiform Script = 63
	// ScriptPhoenician: phoenician. Since 1.14
	ScriptPhoenician Script = 64
	// ScriptPhagsPa: phags-pa. Since 1.14
	ScriptPhagsPa Script = 65
	// ScriptNko: n'Ko. Since 1.14
	ScriptNko Script = 66
	// ScriptKayahLi: kayah Li. Since 1.20.1
	ScriptKayahLi Script = 67
	// ScriptLepcha: lepcha. Since 1.20.1
	ScriptLepcha Script = 68
	// ScriptRejang: rejang. Since 1.20.1
	ScriptRejang Script = 69
	// ScriptSundanese: sundanese. Since 1.20.1
	ScriptSundanese Script = 70
	// ScriptSaurashtra: saurashtra. Since 1.20.1
	ScriptSaurashtra Script = 71
	// ScriptCham: cham. Since 1.20.1
	ScriptCham Script = 72
	// ScriptOlChiki: ol Chiki. Since 1.20.1
	ScriptOlChiki Script = 73
	// ScriptVai: vai. Since 1.20.1
	ScriptVai Script = 74
	// ScriptCarian: carian. Since 1.20.1
	ScriptCarian Script = 75
	// ScriptLycian: lycian. Since 1.20.1
	ScriptLycian Script = 76
	// ScriptLydian: lydian. Since 1.20.1
	ScriptLydian Script = 77
	// ScriptBatak: batak. Since 1.32
	ScriptBatak Script = 78
	// ScriptBrahmi: brahmi. Since 1.32
	ScriptBrahmi Script = 79
	// ScriptMandaic: mandaic. Since 1.32
	ScriptMandaic Script = 80
	// ScriptChakma: chakma. Since: 1.32
	ScriptChakma Script = 81
	// ScriptMeroiticCursive: meroitic Cursive. Since: 1.32
	ScriptMeroiticCursive Script = 82
	// ScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 1.32
	ScriptMeroiticHieroglyphs Script = 83
	// ScriptMiao: miao. Since: 1.32
	ScriptMiao Script = 84
	// ScriptSharada: sharada. Since: 1.32
	ScriptSharada Script = 85
	// ScriptSoraSompeng: sora Sompeng. Since: 1.32
	ScriptSoraSompeng Script = 86
	// ScriptTakri: takri. Since: 1.32
	ScriptTakri Script = 87
	// ScriptBassaVah: bassa. Since: 1.40
	ScriptBassaVah Script = 88
	// ScriptCaucasianAlbanian: caucasian Albanian. Since: 1.40
	ScriptCaucasianAlbanian Script = 89
	// ScriptDuployan: duployan. Since: 1.40
	ScriptDuployan Script = 90
	// ScriptElbasan: elbasan. Since: 1.40
	ScriptElbasan Script = 91
	// ScriptGrantha: grantha. Since: 1.40
	ScriptGrantha Script = 92
	// ScriptKhojki: kjohki. Since: 1.40
	ScriptKhojki Script = 93
	// ScriptKhudawadi: khudawadi, Sindhi. Since: 1.40
	ScriptKhudawadi Script = 94
	// ScriptLinearA: linear A. Since: 1.40
	ScriptLinearA Script = 95
	// ScriptMahajani: mahajani. Since: 1.40
	ScriptMahajani Script = 96
	// ScriptManichaean: manichaean. Since: 1.40
	ScriptManichaean Script = 97
	// ScriptMendeKikakui: mende Kikakui. Since: 1.40
	ScriptMendeKikakui Script = 98
	// ScriptModi: modi. Since: 1.40
	ScriptModi Script = 99
	// ScriptMro: mro. Since: 1.40
	ScriptMro Script = 100
	// ScriptNabataean: nabataean. Since: 1.40
	ScriptNabataean Script = 101
	// ScriptOldNorthArabian: old North Arabian. Since: 1.40
	ScriptOldNorthArabian Script = 102
	// ScriptOldPermic: old Permic. Since: 1.40
	ScriptOldPermic Script = 103
	// ScriptPahawhHmong: pahawh Hmong. Since: 1.40
	ScriptPahawhHmong Script = 104
	// ScriptPalmyrene: palmyrene. Since: 1.40
	ScriptPalmyrene Script = 105
	// ScriptPauCinHau: pau Cin Hau. Since: 1.40
	ScriptPauCinHau Script = 106
	// ScriptPsalterPahlavi: psalter Pahlavi. Since: 1.40
	ScriptPsalterPahlavi Script = 107
	// ScriptSiddham: siddham. Since: 1.40
	ScriptSiddham Script = 108
	// ScriptTirhuta: tirhuta. Since: 1.40
	ScriptTirhuta Script = 109
	// ScriptWarangCiti: warang Citi. Since: 1.40
	ScriptWarangCiti Script = 110
	// ScriptAhom: ahom. Since: 1.40
	ScriptAhom Script = 111
	// ScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 1.40
	ScriptAnatolianHieroglyphs Script = 112
	// ScriptHatran: hatran. Since: 1.40
	ScriptHatran Script = 113
	// ScriptMultani: multani. Since: 1.40
	ScriptMultani Script = 114
	// ScriptOldHungarian: old Hungarian. Since: 1.40
	ScriptOldHungarian Script = 115
	// ScriptSignwriting: signwriting. Since: 1.40
	ScriptSignwriting Script = 116
)

func marshalScript(p uintptr) (interface{}, error) {
	return Script(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Stretch: an enumeration specifying the width of the font relative to other
// designs within a family.
type Stretch int

const (
	// StretchUltraCondensed: ultra condensed width
	StretchUltraCondensed Stretch = 0
	// StretchExtraCondensed: extra condensed width
	StretchExtraCondensed Stretch = 1
	// StretchCondensed: condensed width
	StretchCondensed Stretch = 2
	// StretchSemiCondensed: semi condensed width
	StretchSemiCondensed Stretch = 3
	// StretchNormal: the normal width
	StretchNormal Stretch = 4
	// StretchSemiExpanded: semi expanded width
	StretchSemiExpanded Stretch = 5
	// StretchExpanded: expanded width
	StretchExpanded Stretch = 6
	// StretchExtraExpanded: extra expanded width
	StretchExtraExpanded Stretch = 7
	// StretchUltraExpanded: ultra expanded width
	StretchUltraExpanded Stretch = 8
)

func marshalStretch(p uintptr) (interface{}, error) {
	return Stretch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Style: an enumeration specifying the various slant styles possible for a
// font.
type Style int

const (
	// StyleNormal: the font is upright.
	StyleNormal Style = 0
	// StyleOblique: the font is slanted, but in a roman style.
	StyleOblique Style = 1
	// StyleItalic: the font is slanted in an italic style.
	StyleItalic Style = 2
)

func marshalStyle(p uintptr) (interface{}, error) {
	return Style(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TabAlign: `PangoTabAlign` specifies where a tab stop appears relative to the
// text.
type TabAlign int

const (
	// TabAlignLeft: the tab stop appears to the left of the text.
	TabAlignLeft TabAlign = 0
)

func marshalTabAlign(p uintptr) (interface{}, error) {
	return TabAlign(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Underline: the `PangoUnderline` enumeration is used to specify whether text
// should be underlined, and if so, the type of underlining.
type Underline int

const (
	// UnderlineNone: no underline should be drawn
	UnderlineNone Underline = 0
	// UnderlineSingle: a single underline should be drawn
	UnderlineSingle Underline = 1
	// UnderlineDouble: a double underline should be drawn
	UnderlineDouble Underline = 2
	// UnderlineLow: a single underline should be drawn at a position beneath
	// the ink extents of the text being underlined. This should be used only
	// for underlining single characters, such as for keyboard accelerators.
	// PANGO_UNDERLINE_SINGLE should be used for extended portions of text.
	UnderlineLow Underline = 3
	// UnderlineError: a wavy underline should be drawn below. This underline is
	// typically used to indicate an error such as a possible mispelling; in
	// some cases a contrasting color may automatically be used. This type of
	// underlining is available since Pango 1.4.
	UnderlineError Underline = 4
	// UnderlineSingleLine: like @PANGO_UNDERLINE_SINGLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineSingleLine Underline = 5
	// UnderlineDoubleLine: like @PANGO_UNDERLINE_DOUBLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineDoubleLine Underline = 6
	// UnderlineErrorLine: like @PANGO_UNDERLINE_ERROR, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineErrorLine Underline = 7
)

func marshalUnderline(p uintptr) (interface{}, error) {
	return Underline(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Variant: an enumeration specifying capitalization variant of the font.
type Variant int

const (
	// VariantNormal: a normal font.
	VariantNormal Variant = 0
	// VariantSmallCaps: a font with the lower case characters replaced by
	// smaller variants of the capital characters.
	VariantSmallCaps Variant = 1
)

func marshalVariant(p uintptr) (interface{}, error) {
	return Variant(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Weight: an enumeration specifying the weight (boldness) of a font.
//
// This is a numerical value ranging from 100 to 1000, but there are some
// predefined values.
type Weight int

const (
	// WeightThin: the thin weight (= 100; Since: 1.24)
	WeightThin Weight = 100
	// WeightUltralight: the ultralight weight (= 200)
	WeightUltralight Weight = 200
	// WeightLight: the light weight (= 300)
	WeightLight Weight = 300
	// WeightSemilight: the semilight weight (= 350; Since: 1.36.7)
	WeightSemilight Weight = 350
	// WeightBook: the book weight (= 380; Since: 1.24)
	WeightBook Weight = 380
	// WeightNormal: the default weight (= 400)
	WeightNormal Weight = 400
	// WeightMedium: the normal weight (= 500; Since: 1.24)
	WeightMedium Weight = 500
	// WeightSemibold: the semibold weight (= 600)
	WeightSemibold Weight = 600
	// WeightBold: the bold weight (= 700)
	WeightBold Weight = 700
	// WeightUltrabold: the ultrabold weight (= 800)
	WeightUltrabold Weight = 800
	// WeightHeavy: the heavy weight (= 900)
	WeightHeavy Weight = 900
	// WeightUltraheavy: the ultraheavy weight (= 1000; Since: 1.24)
	WeightUltraheavy Weight = 1000
)

func marshalWeight(p uintptr) (interface{}, error) {
	return Weight(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode: `PangoWrapMode` describes how to wrap the lines of a `PangoLayout`
// to the desired width.
type WrapMode int

const (
	// WrapModeWord: wrap lines at word boundaries.
	WrapModeWord WrapMode = 0
	// WrapModeChar: wrap lines at character boundaries.
	WrapModeChar WrapMode = 1
	// WrapModeWordChar: wrap lines at word boundaries, but fall back to
	// character boundaries if there is not enough space for a full word.
	WrapModeWordChar WrapMode = 2
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontMask: the bits in a `PangoFontMask` correspond to the set fields in a
// `PangoFontDescription`.
type FontMask int

const (
	// FontMaskFamily: the font family is specified.
	FontMaskFamily FontMask = 0b1
	// FontMaskStyle: the font style is specified.
	FontMaskStyle FontMask = 0b10
	// FontMaskVariant: the font variant is specified.
	FontMaskVariant FontMask = 0b100
	// FontMaskWeight: the font weight is specified.
	FontMaskWeight FontMask = 0b1000
	// FontMaskStretch: the font stretch is specified.
	FontMaskStretch FontMask = 0b10000
	// FontMaskSize: the font size is specified.
	FontMaskSize FontMask = 0b100000
	// FontMaskGravity: the font gravity is specified (Since: 1.16.)
	FontMaskGravity FontMask = 0b1000000
	// FontMaskVariations: openType font variations are specified (Since: 1.42)
	FontMaskVariations FontMask = 0b10000000
)

func marshalFontMask(p uintptr) (interface{}, error) {
	return FontMask(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShapeFlags flags influencing the shaping process.
//
// `PangoShapeFlags` can be passed to pango_shape_with_flags().
type ShapeFlags int

const (
	// ShapeFlagsNone: default value.
	ShapeFlagsNone ShapeFlags = 0b0
	// ShapeFlagsRoundPositions: round glyph positions and widths to whole
	// device units. This option should be set if the target renderer can't do
	// subpixel positioning of glyphs.
	ShapeFlagsRoundPositions ShapeFlags = 0b1
)

func marshalShapeFlags(p uintptr) (interface{}, error) {
	return ShapeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShowFlags: these flags affect how Pango treats characters that are normally
// not visible in the output.
type ShowFlags int

const (
	// ShowFlagsNone: no special treatment for invisible characters
	ShowFlagsNone ShowFlags = 0b0
	// ShowFlagsSpaces: render spaces, tabs and newlines visibly
	ShowFlagsSpaces ShowFlags = 0b1
	// ShowFlagsLineBreaks: render line breaks visibly
	ShowFlagsLineBreaks ShowFlags = 0b10
	// ShowFlagsIgnorables: render default-ignorable Unicode characters visibly
	ShowFlagsIgnorables ShowFlags = 0b100
)

func marshalShowFlags(p uintptr) (interface{}, error) {
	return ShowFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttrDataCopyFunc: type of a function that can duplicate user data for an
// attribute.
type AttrDataCopyFunc func() interface{}

//export gotk4_AttrDataCopyFunc
func gotk4_AttrDataCopyFunc(arg0 C.gpointer) C.gpointer {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	gpointer := v.(AttrDataCopyFunc)()
}

// AttrFilterFunc: type of a function filtering a list of attributes.
type AttrFilterFunc func(attribute *Attribute) bool

//export gotk4_AttrFilterFunc
func gotk4_AttrFilterFunc(arg0 *C.PangoAttribute, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var attribute *Attribute

	{
		attribute = WrapAttribute(arg0)
		runtime.SetFinalizer(&attribute, func(v **Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ok := v.(AttrFilterFunc)(attribute)
}

// FontsetForeachFunc: callback used by pango_fontset_foreach() when enumerating
// fonts in a fontset.
type FontsetForeachFunc func(fontset Fontset, font Font) bool

//export gotk4_FontsetForeachFunc
func gotk4_FontsetForeachFunc(arg0 *C.PangoFontset, arg1 *C.PangoFont, arg2 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var fontset Fontset
	var font Font

	fontset = WrapFontset(externglib.Take(unsafe.Pointer(arg0.Native())))

	font = WrapFont(externglib.Take(unsafe.Pointer(arg1.Native())))

	ok := v.(FontsetForeachFunc)(fontset, font)
}

// NewAttrAllowBreaks: create a new allow-breaks attribute.
//
// If breaks are disabled, the range will be kept in a single run, as far as
// possible.
func NewAttrAllowBreaks(allowBreaks bool) *Attribute {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(allowBreaks)

	ret := C.pango_attr_allow_breaks_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrBackgroundAlpha: create a new background alpha attribute.
func NewAttrBackgroundAlpha(alpha uint16) *Attribute {
	var arg1 C.guint16

	arg1 = C.guint16(alpha)

	ret := C.pango_attr_background_alpha_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrBackground: create a new background color attribute.
func NewAttrBackground(red uint16, green uint16, blue uint16) *Attribute {
	var arg1 C.guint16
	var arg2 C.guint16
	var arg3 C.guint16

	arg1 = C.guint16(red)
	arg2 = C.guint16(green)
	arg3 = C.guint16(blue)

	ret := C.pango_attr_background_new(arg1, arg2, arg3)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrFallback: create a new font fallback attribute.
//
// If fallback is disabled, characters will only be used from the closest
// matching font on the system. No fallback will be done to other fonts on the
// system that might contain the characters in the text.
func NewAttrFallback(enableFallback bool) *Attribute {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(enableFallback)

	ret := C.pango_attr_fallback_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrFamily: create a new font family attribute.
func NewAttrFamily(family string) *Attribute {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(family))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_attr_family_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrFontDesc: create a new font description attribute.
//
// This attribute allows setting family, style, weight, variant, stretch, and
// size simultaneously.
func NewAttrFontDesc(desc *FontDescription) *Attribute {
	var arg1 *C.PangoFontDescription

	arg1 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_attr_font_desc_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrFontFeatures: create a new font features tag attribute.
func NewAttrFontFeatures(features string) *Attribute {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(features))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_attr_font_features_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrForegroundAlpha: create a new foreground alpha attribute.
func NewAttrForegroundAlpha(alpha uint16) *Attribute {
	var arg1 C.guint16

	arg1 = C.guint16(alpha)

	ret := C.pango_attr_foreground_alpha_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrForeground: create a new foreground color attribute.
func NewAttrForeground(red uint16, green uint16, blue uint16) *Attribute {
	var arg1 C.guint16
	var arg2 C.guint16
	var arg3 C.guint16

	arg1 = C.guint16(red)
	arg2 = C.guint16(green)
	arg3 = C.guint16(blue)

	ret := C.pango_attr_foreground_new(arg1, arg2, arg3)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrGravityHint: create a new gravity hint attribute.
func NewAttrGravityHint(hint GravityHint) *Attribute {
	var arg1 C.PangoGravityHint

	arg1 = (C.PangoGravityHint)(hint)

	ret := C.pango_attr_gravity_hint_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrGravity: create a new gravity attribute.
func NewAttrGravity(gravity Gravity) *Attribute {
	var arg1 C.PangoGravity

	arg1 = (C.PangoGravity)(gravity)

	ret := C.pango_attr_gravity_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrInsertHyphens: create a new insert-hyphens attribute.
//
// Pango will insert hyphens when breaking lines in the middle of a word. This
// attribute can be used to suppress the hyphen.
func NewAttrInsertHyphens(insertHyphens bool) *Attribute {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(insertHyphens)

	ret := C.pango_attr_insert_hyphens_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrLanguage: create a new language tag attribute.
func NewAttrLanguage(language *Language) *Attribute {
	var arg1 *C.PangoLanguage

	arg1 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_attr_language_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrLetterSpacing: create a new letter-spacing attribute.
func NewAttrLetterSpacing(letterSpacing int) *Attribute {
	var arg1 C.int

	arg1 = C.int(letterSpacing)

	ret := C.pango_attr_letter_spacing_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrOverlineColor: create a new overline color attribute.
//
// This attribute modifies the color of overlines. If not set, overlines will
// use the foreground color.
func NewAttrOverlineColor(red uint16, green uint16, blue uint16) *Attribute {
	var arg1 C.guint16
	var arg2 C.guint16
	var arg3 C.guint16

	arg1 = C.guint16(red)
	arg2 = C.guint16(green)
	arg3 = C.guint16(blue)

	ret := C.pango_attr_overline_color_new(arg1, arg2, arg3)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrOverline: create a new overline-style attribute.
func NewAttrOverline(overline Overline) *Attribute {
	var arg1 C.PangoOverline

	arg1 = (C.PangoOverline)(overline)

	ret := C.pango_attr_overline_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrRise: create a new baseline displacement attribute.
func NewAttrRise(rise int) *Attribute {
	var arg1 C.int

	arg1 = C.int(rise)

	ret := C.pango_attr_rise_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrScale: create a new font size scale attribute.
//
// The base font for the affected text will have its size multiplied by
// @scale_factor.
func NewAttrScale(scaleFactor float64) *Attribute {
	var arg1 C.double

	arg1 = C.double(scaleFactor)

	ret := C.pango_attr_scale_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrShape: create a new shape attribute.
//
// A shape is used to impose a particular ink and logical rectangle on the
// result of shaping a particular glyph. This might be used, for instance, for
// embedding a picture or a widget inside a `PangoLayout`.
func NewAttrShape(inkRect *Rectangle, logicalRect *Rectangle) *Attribute {
	var arg1 *C.PangoRectangle
	var arg2 *C.PangoRectangle

	arg1 = (*C.PangoRectangle)(inkRect.Native())
	arg2 = (*C.PangoRectangle)(logicalRect.Native())

	ret := C.pango_attr_shape_new(arg1, arg2)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// AttrShapeNewWithData creates a new shape attribute.
//
// Like pango_attr_shape_new(), but a user data pointer is also provided; this
// pointer can be accessed when later rendering the glyph.
func AttrShapeNewWithData(inkRect *Rectangle, logicalRect *Rectangle, data interface{}, copyFunc AttrDataCopyFunc) *Attribute {
	var arg1 *C.PangoRectangle
	var arg2 *C.PangoRectangle
	var arg3 C.gpointer
	var arg4 C.PangoAttrDataCopyFunc
	var arg5 C.GDestroyNotify

	arg1 = (*C.PangoRectangle)(inkRect.Native())
	arg2 = (*C.PangoRectangle)(logicalRect.Native())
	arg3 = C.gpointer(box.Assign(data))

	ret := C.pango_attr_shape_new_with_data(arg1, arg2, arg3, arg4, arg5)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrShow: create a new attribute that influences how invisible characters
// are rendered.
func NewAttrShow(flags ShowFlags) *Attribute {
	var arg1 C.PangoShowFlags

	arg1 = (C.PangoShowFlags)(flags)

	ret := C.pango_attr_show_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrSize: create a new font-size attribute in fractional points.
func NewAttrSize(size int) *Attribute {
	var arg1 C.int

	arg1 = C.int(size)

	ret := C.pango_attr_size_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// AttrSizeNewAbsolute: create a new font-size attribute in device units.
func AttrSizeNewAbsolute(size int) *Attribute {
	var arg1 C.int

	arg1 = C.int(size)

	ret := C.pango_attr_size_new_absolute(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrStretch: create a new font stretch attribute.
func NewAttrStretch(stretch Stretch) *Attribute {
	var arg1 C.PangoStretch

	arg1 = (C.PangoStretch)(stretch)

	ret := C.pango_attr_stretch_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrStrikethroughColor: create a new strikethrough color attribute.
//
// This attribute modifies the color of strikethrough lines. If not set,
// strikethrough lines will use the foreground color.
func NewAttrStrikethroughColor(red uint16, green uint16, blue uint16) *Attribute {
	var arg1 C.guint16
	var arg2 C.guint16
	var arg3 C.guint16

	arg1 = C.guint16(red)
	arg2 = C.guint16(green)
	arg3 = C.guint16(blue)

	ret := C.pango_attr_strikethrough_color_new(arg1, arg2, arg3)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrStrikethrough: create a new strike-through attribute.
func NewAttrStrikethrough(strikethrough bool) *Attribute {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(strikethrough)

	ret := C.pango_attr_strikethrough_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrStyle: create a new font slant style attribute.
func NewAttrStyle(style Style) *Attribute {
	var arg1 C.PangoStyle

	arg1 = (C.PangoStyle)(style)

	ret := C.pango_attr_style_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// AttrTypeGetName fetches the attribute type name.
//
// The attribute type name is the string passed in when registering the type
// using [type_func@attr_type_register].
//
// The returned value is an interned string (see g_intern_string() for what that
// means) that should not be modified or freed.
func AttrTypeGetName(_type AttrType) string {
	var arg1 C.PangoAttrType

	arg1 = (C.PangoAttrType)(_type)

	ret := C.pango_attr_type_get_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// AttrTypeRegister: allocate a new attribute type ID.
//
// The attribute type name can be accessed later by using
// [type_func@Pango.AttrType.get_name].
func AttrTypeRegister(name string) AttrType {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_attr_type_register(arg1)

	var ret0 AttrType

	ret0 = AttrType(ret)

	return ret0
}

// NewAttrUnderlineColor: create a new underline color attribute.
//
// This attribute modifies the color of underlines. If not set, underlines will
// use the foreground color.
func NewAttrUnderlineColor(red uint16, green uint16, blue uint16) *Attribute {
	var arg1 C.guint16
	var arg2 C.guint16
	var arg3 C.guint16

	arg1 = C.guint16(red)
	arg2 = C.guint16(green)
	arg3 = C.guint16(blue)

	ret := C.pango_attr_underline_color_new(arg1, arg2, arg3)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrUnderline: create a new underline-style attribute.
func NewAttrUnderline(underline Underline) *Attribute {
	var arg1 C.PangoUnderline

	arg1 = (C.PangoUnderline)(underline)

	ret := C.pango_attr_underline_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrVariant: create a new font variant attribute (normal or small caps).
func NewAttrVariant(variant Variant) *Attribute {
	var arg1 C.PangoVariant

	arg1 = (C.PangoVariant)(variant)

	ret := C.pango_attr_variant_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// NewAttrWeight: create a new font weight attribute.
func NewAttrWeight(weight Weight) *Attribute {
	var arg1 C.PangoWeight

	arg1 = (C.PangoWeight)(weight)

	ret := C.pango_attr_weight_new(arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// BidiTypeForUnichar determines the bidirectional type of a character.
//
// The bidirectional type is specified in the Unicode Character Database.
//
// A simplified version of this function is available as
// [func@unichar_direction].
func BidiTypeForUnichar(ch uint32) BidiType {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_bidi_type_for_unichar(arg1)

	var ret0 BidiType

	ret0 = BidiType(ret)

	return ret0
}

// DefaultBreak: this is the default break algorithm.
//
// It applies Unicode rules without language-specific tailoring, therefore the
// @analyis argument is unused and can be nil.
//
// See pango_tailor_break() for language-specific breaks.
func DefaultBreak(text string, length int, analysis *Analysis, attrs *LogAttr, attrsLen int) {
	var arg1 *C.gchar
	var arg2 C.int
	var arg3 *C.PangoAnalysis
	var arg4 *C.PangoLogAttr
	var arg5 C.int

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoAnalysis)(analysis.Native())
	arg4 = (*C.PangoLogAttr)(attrs.Native())
	arg5 = C.int(attrsLen)

	C.pango_default_break(arg1, arg2, arg3, arg4, arg5)
}

// ExtentsToPixels converts extents from Pango units to device units.
//
// The conversion is done by dividing by the PANGO_SCALE factor and performing
// rounding.
//
// The @inclusive rectangle is converted by flooring the x/y coordinates and
// extending width/height, such that the final rectangle completely includes the
// original rectangle.
//
// The @nearest rectangle is converted by rounding the coordinates of the
// rectangle to the nearest device unit (pixel).
//
// The rule to which argument to use is: if you want the resulting device-space
// rectangle to completely contain the original rectangle, pass it in as
// @inclusive. If you want two touching-but-not-overlapping rectangles stay
// touching-but-not-overlapping after rounding to device units, pass them in as
// @nearest.
func ExtentsToPixels(inclusive *Rectangle, nearest *Rectangle) {
	var arg1 *C.PangoRectangle
	var arg2 *C.PangoRectangle

	arg1 = (*C.PangoRectangle)(inclusive.Native())
	arg2 = (*C.PangoRectangle)(nearest.Native())

	C.pango_extents_to_pixels(arg1, arg2)
}

// FindBaseDir searches a string the first character that has a strong
// direction, according to the Unicode bidirectional algorithm.
func FindBaseDir(text string, length int) Direction {
	var arg1 *C.gchar
	var arg2 C.gint

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(length)

	ret := C.pango_find_base_dir(arg1, arg2)

	var ret0 Direction

	ret0 = Direction(ret)

	return ret0
}

// FindParagraphBoundary locates a paragraph boundary in @text.
//
// A boundary is caused by delimiter characters, such as a newline, carriage
// return, carriage return-newline pair, or Unicode paragraph separator
// character. The index of the run of delimiters is returned in
// @paragraph_delimiter_index. The index of the start of the paragrap (index
// after all delimiters) is stored in @next_paragraph_start.
//
// If no delimiters are found, both @paragraph_delimiter_index and
// @next_paragraph_start are filled with the length of @text (an index one off
// the end).
func FindParagraphBoundary(text string, length int) (paragraphDelimiterIndex int, nextParagraphStart int) {
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 *C.gint // out
	var arg4 *C.gint // out

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(length)

	ret := C.pango_find_paragraph_boundary(arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// FontDescriptionFromString creates a new font description from a string
// representation.
//
// The string must have the form
//
//    "\[FAMILY-LIST] \[STYLE-OPTIONS] \[SIZE] \[VARIATIONS]",
//
// where FAMILY-LIST is a comma-separated list of families optionally terminated
// by a comma, STYLE_OPTIONS is a whitespace-separated list of words where each
// word describes one of style, variant, weight, stretch, or gravity, and SIZE
// is a decimal number (size in points) or optionally followed by the unit
// modifier "px" for absolute size. VARIATIONS is a comma-separated list of font
// variation specifications of the form "\@axis=value" (the = sign is optional).
//
// The following words are understood as styles: "Normal", "Roman", "Oblique",
// "Italic".
//
// The following words are understood as variants: "Small-Caps".
//
// The following words are understood as weights: "Thin", "Ultra-Light",
// "Extra-Light", "Light", "Semi-Light", "Demi-Light", "Book", "Regular",
// "Medium", "Semi-Bold", "Demi-Bold", "Bold", "Ultra-Bold", "Extra-Bold",
// "Heavy", "Black", "Ultra-Black", "Extra-Black".
//
// The following words are understood as stretch values: "Ultra-Condensed",
// "Extra-Condensed", "Condensed", "Semi-Condensed", "Semi-Expanded",
// "Expanded", "Extra-Expanded", "Ultra-Expanded".
//
// The following words are understood as gravity values: "Not-Rotated", "South",
// "Upside-Down", "North", "Rotated-Left", "East", "Rotated-Right", "West".
//
// Any one of the options may be absent. If FAMILY-LIST is absent, then the
// family_name field of the resulting font description will be initialized to
// nil. If STYLE-OPTIONS is missing, then all style options will be set to the
// default values. If SIZE is missing, the size in the resulting font
// description will be set to 0.
//
// A typical example:
//
//    "Cantarell Italic Light 15 \@wght=200"
func FontDescriptionFromString(str string) *FontDescription {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_font_description_from_string(arg1)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// GetMirrorChar returns the mirrored character of a Unicode character.
//
// Mirror characters are determined by the Unicode mirrored property.
//
// Use g_unichar_get_mirror_char() instead; the docs for that function provide
// full details.
func GetMirrorChar(ch uint32, mirroredCh uint32) bool {
	var arg1 C.gunichar
	var arg2 *C.gunichar

	arg1 = C.gunichar(ch)
	arg2 = (*C.gunichar)(mirroredCh)

	ret := C.pango_get_mirror_char(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GravityGetForMatrix finds the gravity that best matches the rotation
// component in a `PangoMatrix`.
func GravityGetForMatrix(matrix *Matrix) Gravity {
	var arg1 *C.PangoMatrix

	arg1 = (*C.PangoMatrix)(matrix.Native())

	ret := C.pango_gravity_get_for_matrix(arg1)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// GravityGetForScript returns the gravity to use in laying out a `PangoItem`.
//
// The gravity is determined based on the script, base gravity, and hint.
//
// If @base_gravity is PANGO_GRAVITY_AUTO, it is first replaced with the
// preferred gravity of @script. To get the preferred gravity of a script, pass
// PANGO_GRAVITY_AUTO and PANGO_GRAVITY_HINT_STRONG in.
func GravityGetForScript(script Script, baseGravity Gravity, hint GravityHint) Gravity {
	var arg1 C.PangoScript
	var arg2 C.PangoGravity
	var arg3 C.PangoGravityHint

	arg1 = (C.PangoScript)(script)
	arg2 = (C.PangoGravity)(baseGravity)
	arg3 = (C.PangoGravityHint)(hint)

	ret := C.pango_gravity_get_for_script(arg1, arg2, arg3)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// GravityGetForScriptAndWidth returns the gravity to use in laying out a single
// character or `PangoItem`.
//
// The gravity is determined based on the script, East Asian width, base
// gravity, and hint,
//
// This function is similar to [type_func@Pango.Gravity.get_for_script] except
// that this function makes a distinction between narrow/half-width and
// wide/full-width characters also. Wide/full-width characters always stand
// *upright*, that is, they always take the base gravity, whereas
// narrow/full-width characters are always rotated in vertical context.
//
// If @base_gravity is PANGO_GRAVITY_AUTO, it is first replaced with the
// preferred gravity of @script.
func GravityGetForScriptAndWidth(script Script, wide bool, baseGravity Gravity, hint GravityHint) Gravity {
	var arg1 C.PangoScript
	var arg2 C.gboolean
	var arg3 C.PangoGravity
	var arg4 C.PangoGravityHint

	arg1 = (C.PangoScript)(script)
	arg2 = gextras.Cbool(wide)
	arg3 = (C.PangoGravity)(baseGravity)
	arg4 = (C.PangoGravityHint)(hint)

	ret := C.pango_gravity_get_for_script_and_width(arg1, arg2, arg3, arg4)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// GravityToRotation converts a Gravity value to its natural rotation in
// radians.
//
// Note that [method@Pango.Matrix.rotate] takes angle in degrees, not radians.
// So, to call [method@Pango.Matrix,rotate] with the output of this function you
// should multiply it by (180. / G_PI).
func GravityToRotation(gravity Gravity) float64 {
	var arg1 C.PangoGravity

	arg1 = (C.PangoGravity)(gravity)

	ret := C.pango_gravity_to_rotation(arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// IsZeroWidth checks if a character that should not be normally rendered.
//
// This includes all Unicode characters with "ZERO WIDTH" in their name, as well
// as *bidi* formatting characters, and a few other ones. This is totally
// different from g_unichar_iszerowidth() and is at best misnamed.
func IsZeroWidth(ch uint32) bool {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_is_zero_width(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Itemize breaks a piece of text into segments with consistent directional
// level and font.
//
// Each byte of @text will be contained in exactly one of the items in the
// returned list; the generated list of items will be in logical order (the
// start offsets of the items are ascending).
//
// @cached_iter should be an iterator over @attrs currently positioned at a
// range before or containing @start_index; @cached_iter will be advanced to the
// range covering the position just after @start_index + @length. (i.e. if
// itemizing in a loop, just keep passing in the same @cached_iter).
func Itemize(context Context, text string, startIndex int, length int, attrs *AttrList, cachedIter *AttrIterator) *glib.List {
	var arg1 *C.PangoContext
	var arg2 *C.char
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.PangoAttrList
	var arg6 *C.PangoAttrIterator

	arg1 = (*C.PangoContext)(context.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = C.int(startIndex)
	arg4 = C.int(length)
	arg5 = (*C.PangoAttrList)(attrs.Native())
	arg6 = (*C.PangoAttrIterator)(cachedIter.Native())

	ret := C.pango_itemize(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(ret)
	}

	return ret0
}

// ItemizeWithBaseDir: like `pango_itemize()`, but with an explicitly specified
// base direction.
//
// The base direction is used when computing bidirectional levels. (see
// [method@Pango.Context.set_base_dir]). [func@itemize] gets the base direction
// from the `PangoContext`.
func ItemizeWithBaseDir(context Context, baseDir Direction, text string, startIndex int, length int, attrs *AttrList, cachedIter *AttrIterator) *glib.List {
	var arg1 *C.PangoContext
	var arg2 C.PangoDirection
	var arg3 *C.char
	var arg4 C.int
	var arg5 C.int
	var arg6 *C.PangoAttrList
	var arg7 *C.PangoAttrIterator

	arg1 = (*C.PangoContext)(context.Native())
	arg2 = (C.PangoDirection)(baseDir)
	arg3 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.int(startIndex)
	arg5 = C.int(length)
	arg6 = (*C.PangoAttrList)(attrs.Native())
	arg7 = (*C.PangoAttrIterator)(cachedIter.Native())

	ret := C.pango_itemize_with_base_dir(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(ret)
	}

	return ret0
}

// LanguageFromString: convert a language tag to a `PangoLanguage`.
//
// The language tag must be in a RFC-3066 format. `PangoLanguage` pointers can
// be efficiently copied (copy the pointer) and compared with other language
// tags (compare the pointer.)
//
// This function first canonicalizes the string by converting it to lowercase,
// mapping '_' to '-', and stripping all characters other than letters and '-'.
//
// Use [type_func@Pango.Language.get_default] if you want to get the
// `PangoLanguage` for the current locale of the process.
func LanguageFromString(language string) *Language {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(language))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_language_from_string(arg1)

	var ret0 *Language

	{
		ret0 = WrapLanguage(ret)
		runtime.SetFinalizer(&ret0, func(v **Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LanguageGetDefault returns the `PangoLanguage` for the current locale of the
// process.
//
// On Unix systems, this is the return value is derived from `setlocale
// (LC_CTYPE, NULL)`, and the user can affect this through the environment
// variables LC_ALL, LC_CTYPE or LANG (checked in that order). The locale string
// typically is in the form lang_COUNTRY, where lang is an ISO-639 language
// code, and COUNTRY is an ISO-3166 country code. For instance, sv_FI for
// Swedish as written in Finland or pt_BR for Portuguese as written in Brazil.
//
// On Windows, the C library does not use any such environment variables, and
// setting them won't affect the behavior of functions like ctime(). The user
// sets the locale through the Regional Options in the Control Panel. The C
// library (in the setlocale() function) does not use country and language
// codes, but country and language names spelled out in English. However, this
// function does check the above environment variables, and does return a
// Unix-style locale string based on either said environment variables or the
// thread's current locale.
//
// Your application should call `setlocale(LC_ALL, "")` for the user settings to
// take effect. GTK does this in its initialization functions automatically (by
// calling gtk_set_locale()). See the setlocale() manpage for more details.
//
// Note that the default language can change over the life of an application.
func LanguageGetDefault() *Language {

	ret := C.pango_language_get_default()

	var ret0 *Language

	{
		ret0 = WrapLanguage(ret)
		runtime.SetFinalizer(&ret0, func(v **Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LanguageGetPreferred returns the list of languages that the user prefers.
//
// The list is specified by the `PANGO_LANGUAGE` or `LANGUAGE` environment
// variables, in order of preference. Note that this list does not necessarily
// include the language returned by [type_func@Pango.Language.get_default].
//
// When choosing language-specific resources, such as the sample text returned
// by [method@Pango.Language.get_sample_string], you should first try the
// default language, followed by the languages returned by this function.
func LanguageGetPreferred() **Language {

	ret := C.pango_language_get_preferred()

	var ret0 **Language

	{
		ret0 = WrapLanguage(ret)
		runtime.SetFinalizer(&ret0, func(v ***Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Log2VisGetEmbeddingLevels: return the bidirectional embedding levels of the
// input paragraph.
//
// The bidirectional embedding levels are defined by the Unicode Bidirectional
// Algorithm available at:
//
//    http://www.unicode.org/reports/tr9/
//
// If the input base direction is a weak direction, the direction of the
// characters in the text will determine the final resolved direction.
func Log2VisGetEmbeddingLevels(text string, length int, pbaseDir *Direction) byte {
	var arg1 *C.gchar
	var arg2 C.int
	var arg3 *C.PangoDirection

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoDirection)(pbaseDir)

	ret := C.pango_log2vis_get_embedding_levels(arg1, arg2, arg3)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// MarkupParserFinish finishes parsing markup.
//
// After feeding a Pango markup parser some data with
// g_markup_parse_context_parse(), use this function to get the list of
// attributes and text out of the markup. This function will not free @context,
// use g_markup_parse_context_free() to do so.
func MarkupParserFinish(context *glib.MarkupParseContext) (attrList *AttrList, text string, accelChar uint32, ok bool) {
	var arg1 *C.GMarkupParseContext
	var arg2 **C.PangoAttrList // out
	var arg3 **C.char          // out
	var arg4 *C.gunichar       // out

	arg1 = (*C.GMarkupParseContext)(context.Native())

	ret := C.pango_markup_parser_finish(arg1, &arg2, &arg3, &arg4)

	var ret0 **AttrList
	var ret1 string
	var ret2 uint32
	var ret3 bool

	{
		ret0 = WrapAttrList(arg2)
	}

	ret1 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret2 = uint32(arg4)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// NewMarkupParser: incrementally parses marked-up text to create a plain-text
// string and an attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in @accel_char, when calling [func@markup_parser_finish]. Two
// @accel_marker characters following each other produce a single literal
// @accel_marker character.
//
// To feed markup to the parser, use g_markup_parse_context_parse() on the
// returned `GMarkupParseContext`. When done with feeding markup to the parser,
// use [func@markup_parser_finish] to get the data out of it, and then use
// g_markup_parse_context_free() to free it.
//
// This function is designed for applications that read Pango markup from
// streams. To simply parse a string containing Pango markup, the
// [func@parse_markup] API is recommended instead.
func NewMarkupParser(accelMarker uint32) *glib.MarkupParseContext {
	var arg1 C.gunichar

	arg1 = C.gunichar(accelMarker)

	ret := C.pango_markup_parser_new(arg1)

	var ret0 *glib.MarkupParseContext

	{
		ret0 = glib.WrapMarkupParseContext(ret)
		runtime.SetFinalizer(&ret0, func(v **glib.MarkupParseContext) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ParseEnum parses an enum type and stores the result in @value.
//
// If @str does not match the nick name of any of the possible values for the
// enum and is not an integer, false is returned, a warning is issued if @warn
// is true, and a string representing the list of possible values is stored in
// @possible_values. The list is slash-separated, eg. "none/start/middle/end".
// If failed and @possible_values is not nil, returned string should be freed
// using g_free().
func ParseEnum(_type externglib.Type, str string, warn bool) (value int, possibleValues string, ok bool) {
	var arg1 C.GType
	var arg2 *C.char
	var arg3 *C.int // out
	var arg4 C.gboolean
	var arg5 **C.char // out

	arg1 = C.GType(_type)
	arg2 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg2))
	arg4 = gextras.Cbool(warn)

	ret := C.pango_parse_enum(arg1, arg2, &arg3, arg4, &arg5)

	var ret0 int
	var ret1 string
	var ret2 bool

	ret0 = int(arg3)

	ret1 = C.GoString(arg5)
	C.free(unsafe.Pointer(arg5))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ParseMarkup parses marked-up text to create a plain-text string and an
// attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in @accel_char. Two @accel_marker characters following each other
// produce a single literal @accel_marker character.
//
// To parse a stream of pango markup incrementally, use
// [func@markup_parser_new].
//
// If any error happens, none of the output arguments are touched except for
// @error.
func ParseMarkup(markupText string, length int, accelMarker uint32) (attrList *AttrList, text string, accelChar uint32, ok bool) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.gunichar
	var arg4 **C.PangoAttrList // out
	var arg5 **C.char          // out
	var arg6 *C.gunichar       // out

	arg1 = (*C.gchar)(C.CString(markupText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = C.gunichar(accelMarker)

	ret := C.pango_parse_markup(arg1, arg2, arg3, &arg4, &arg5, &arg6)

	var ret0 **AttrList
	var ret1 string
	var ret2 uint32
	var ret3 bool

	{
		ret0 = WrapAttrList(arg4)
	}

	ret1 = C.GoString(arg5)
	C.free(unsafe.Pointer(arg5))

	ret2 = uint32(arg6)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// ParseStretch parses a font stretch.
//
// The allowed values are "ultra_condensed", "extra_condensed", "condensed",
// "semi_condensed", "normal", "semi_expanded", "expanded", "extra_expanded" and
// "ultra_expanded". Case variations are ignored and the '_' characters may be
// omitted.
func ParseStretch(str string, warn bool) (stretch Stretch, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoStretch // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = gextras.Cbool(warn)

	ret := C.pango_parse_stretch(arg1, &arg2, arg3)

	var ret0 *Stretch
	var ret1 bool

	ret0 = (*Stretch)(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ParseStyle parses a font style.
//
// The allowed values are "normal", "italic" and "oblique", case variations
// being ignored.
func ParseStyle(str string, warn bool) (style Style, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoStyle // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = gextras.Cbool(warn)

	ret := C.pango_parse_style(arg1, &arg2, arg3)

	var ret0 *Style
	var ret1 bool

	ret0 = (*Style)(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ParseVariant parses a font variant.
//
// The allowed values are "normal" and "smallcaps" or "small_caps", case
// variations being ignored.
func ParseVariant(str string, warn bool) (variant Variant, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoVariant // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = gextras.Cbool(warn)

	ret := C.pango_parse_variant(arg1, &arg2, arg3)

	var ret0 *Variant
	var ret1 bool

	ret0 = (*Variant)(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ParseWeight parses a font weight.
//
// The allowed values are "heavy", "ultrabold", "bold", "normal", "light",
// "ultraleight" and integers. Case variations are ignored.
func ParseWeight(str string, warn bool) (weight Weight, ok bool) {
	var arg1 *C.char
	var arg2 *C.PangoWeight // out
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = gextras.Cbool(warn)

	ret := C.pango_parse_weight(arg1, &arg2, arg3)

	var ret0 *Weight
	var ret1 bool

	ret0 = (*Weight)(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// QuantizeLineGeometry quantizes the thickness and position of a line to whole
// device pixels.
//
// This is typically used for underline or strikethrough. The purpose of this
// function is to avoid such lines looking blurry.
//
// Care is taken to make sure @thickness is at least one pixel when this
// function returns, but returned @position may become zero as a result of
// rounding.
func QuantizeLineGeometry(thickness int, position int) {
	var arg1 *C.int
	var arg2 *C.int

	arg1 = (*C.int)(thickness)
	arg2 = (*C.int)(position)

	C.pango_quantize_line_geometry(arg1, arg2)
}

// ReadLine reads an entire line from a file into a buffer.
//
// Lines may be delimited with '\n', '\r', '\n\r', or '\r\n'. The delimiter is
// not written into the buffer. Text after a '#' character is treated as a
// comment and skipped. '\' can be used to escape a
//
// character.
//
// '\' proceeding a line delimiter combines adjacent lines. A '\' proceeding any
// other character is ignored and written into the output buffer unmodified.
func ReadLine(stream interface{}, str *glib.String) int {
	var arg1 *C.FILE
	var arg2 *C.GString

	arg1 = C.gpointer(box.Assign(stream))
	arg2 = (*C.GString)(str.Native())

	ret := C.pango_read_line(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ReorderItems: reorder items from logical order to visual order.
//
// The visual order is determined from the associated directional levels of the
// items. The original list is unmodified.
func ReorderItems(logicalItems *glib.List) *glib.List {
	var arg1 *C.GList

	arg1 = (*C.GList)(logicalItems.Native())

	ret := C.pango_reorder_items(arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(ret)
	}

	return ret0
}

// ScanInt scans an integer.
//
// Leading white space is skipped.
func ScanInt(pos string) (out int, ok bool) {
	var arg1 **C.char
	var arg2 *C.int // out

	arg1 = (*C.gchar)(C.CString(pos))

	ret := C.pango_scan_int(arg1, &arg2)

	var ret0 int
	var ret1 bool

	ret0 = int(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ScanString scans a string into a #GString buffer.
//
// The string may either be a sequence of non-white-space characters, or a
// quoted string with '"'. Instead a quoted string, '\"' represents a literal
// quote. Leading white space outside of quotes is skipped.
func ScanString(pos string, out *glib.String) bool {
	var arg1 **C.char
	var arg2 *C.GString

	arg1 = (*C.gchar)(C.CString(pos))
	arg2 = (*C.GString)(out.Native())

	ret := C.pango_scan_string(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ScanWord scans a word into a #GString buffer.
//
// A word consists of [A-Za-z_] followed by zero or more [A-Za-z_0-9]. Leading
// white space is skipped.
func ScanWord(pos string, out *glib.String) bool {
	var arg1 **C.char
	var arg2 *C.GString

	arg1 = (*C.gchar)(C.CString(pos))
	arg2 = (*C.GString)(out.Native())

	ret := C.pango_scan_word(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ScriptForUnichar looks up the script for a particular character.
//
// The script of a character is defined by Unicode Standard Annex \#24. No check
// is made for @ch being a valid Unicode character; if you pass in invalid
// character, the result is undefined.
//
// Note that while the return type of this function is declared as
// `PangoScript`, as of Pango 1.18, this function simply returns the return
// value of g_unichar_get_script(). Callers must be prepared to handle unknown
// values.
func ScriptForUnichar(ch uint32) Script {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_script_for_unichar(arg1)

	var ret0 Script

	ret0 = Script(ret)

	return ret0
}

// ScriptGetSampleLanguage finds a language tag that is reasonably
// representative of @script.
//
// The language will usually be the most widely spoken or used language written
// in that script: for instance, the sample language for PANGO_SCRIPT_CYRILLIC
// is ru (Russian), the sample language for PANGO_SCRIPT_ARABIC is ar.
//
// For some scripts, no sample language will be returned because there is no
// language that is sufficiently representative. The best example of this is
// PANGO_SCRIPT_HAN, where various different variants of written Chinese,
// Japanese, and Korean all use significantly different sets of Han characters
// and forms of shared characters. No sample language can be provided for many
// historical scripts as well.
//
// As of 1.18, this function checks the environment variables `PANGO_LANGUAGE`
// and `LANGUAGE` (checked in that order) first. If one of them is set, it is
// parsed as a list of language tags separated by colons or other separators.
// This function will return the first language in the parsed list that Pango
// believes may use @script for writing. This last predicate is tested using
// [method@Pango.Language.includes_script]. This can be used to control Pango's
// font selection for non-primary languages. For example, a `PANGO_LANGUAGE`
// enviroment variable set to "en:fa" makes Pango choose fonts suitable for
// Persian (fa) instead of Arabic (ar) when a segment of Arabic text is found in
// an otherwise non-Arabic text. The same trick can be used to choose a default
// language for PANGO_SCRIPT_HAN when setting context language is not feasible.
func ScriptGetSampleLanguage(script Script) *Language {
	var arg1 C.PangoScript

	arg1 = (C.PangoScript)(script)

	ret := C.pango_script_get_sample_language(arg1)

	var ret0 *Language

	{
		ret0 = WrapLanguage(ret)
	}

	return ret0
}

// Shape: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// It is recommended that you use [func@shape_full] instead, since that API
// allows for shaping interaction happening across text item boundaries.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// need to subtract the item offset from their indices before calling
// [func@shape].
func Shape(text string, length int, analysis *Analysis, glyphs *GlyphString) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.PangoAnalysis
	var arg4 *C.PangoGlyphString

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoAnalysis)(analysis.Native())
	arg4 = (*C.PangoGlyphString)(glyphs.Native())

	C.pango_shape(arg1, arg2, arg3, arg4)
}

// ShapeFull: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// This is similar to [func@shape], except it also can optionally take the full
// paragraph text as input, which will then be used to perform certain
// cross-item shaping interactions. If you have access to the broader text of
// which @item_text is part of, provide the broader text as @paragraph_text. If
// @paragraph_text is nil, item text is used instead.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// do not pass the full paragraph text as @paragraph_text, you need to subtract
// the item offset from their indices before calling [func@shape_full].
func ShapeFull(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.char
	var arg4 C.int
	var arg5 *C.PangoAnalysis
	var arg6 *C.PangoGlyphString

	arg1 = (*C.gchar)(C.CString(itemText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(itemLength)
	arg3 = (*C.gchar)(C.CString(paragraphText))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.int(paragraphLength)
	arg5 = (*C.PangoAnalysis)(analysis.Native())
	arg6 = (*C.PangoGlyphString)(glyphs.Native())

	C.pango_shape_full(arg1, arg2, arg3, arg4, arg5, arg6)
}

// ShapeWithFlags: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// This is similar to [func@shape_full], except it also takes flags that can
// influence the shaping process.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// do not pass the full paragraph text as @paragraph_text, you need to subtract
// the item offset from their indices before calling [func@shape_with_flags].
func ShapeWithFlags(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString, flags ShapeFlags) {
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.char
	var arg4 C.int
	var arg5 *C.PangoAnalysis
	var arg6 *C.PangoGlyphString
	var arg7 C.PangoShapeFlags

	arg1 = (*C.gchar)(C.CString(itemText))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(itemLength)
	arg3 = (*C.gchar)(C.CString(paragraphText))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.int(paragraphLength)
	arg5 = (*C.PangoAnalysis)(analysis.Native())
	arg6 = (*C.PangoGlyphString)(glyphs.Native())
	arg7 = (C.PangoShapeFlags)(flags)

	C.pango_shape_with_flags(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// SkipSpace skips 0 or more characters of white space.
func SkipSpace(pos string) bool {
	var arg1 **C.char

	arg1 = (*C.gchar)(C.CString(pos))

	ret := C.pango_skip_space(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SplitFileList splits a G_SEARCHPATH_SEPARATOR-separated list of files,
// stripping white space and substituting ~/ with $HOME/.
func SplitFileList(str string) []string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_split_file_list(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// TrimString trims leading and trailing whitespace from a string.
func TrimString(str string) string {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_trim_string(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UnicharDirection determines the inherent direction of a character.
//
// The inherent direction is either PANGO_DIRECTION_LTR, PANGO_DIRECTION_RTL, or
// PANGO_DIRECTION_NEUTRAL.
//
// This function is useful to categorize characters into left-to-right letters,
// right-to-left letters, and everything else. If full Unicode bidirectional
// type of a character is needed, [type_func@Pango.BidiType.for_unichar] can be
// used instead.
func UnicharDirection(ch uint32) Direction {
	var arg1 C.gunichar

	arg1 = C.gunichar(ch)

	ret := C.pango_unichar_direction(arg1)

	var ret0 Direction

	ret0 = Direction(ret)

	return ret0
}

// UnitsFromDouble converts a floating-point number to Pango units.
//
// The conversion is done by multiplying @d by PANGO_SCALE and rounding the
// result to nearest integer.
func UnitsFromDouble(d float64) int {
	var arg1 C.double

	arg1 = C.double(d)

	ret := C.pango_units_from_double(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnitsToDouble converts a number in Pango units to floating-point.
//
// The conversion is done by dividing @i by PANGO_SCALE.
func UnitsToDouble(i int) float64 {
	var arg1 C.int

	arg1 = C.int(i)

	ret := C.pango_units_to_double(arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
func Version() int {

	ret := C.pango_version()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
func VersionCheck(requiredMajor int, requiredMinor int, requiredMicro int) string {
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int

	arg1 = C.int(requiredMajor)
	arg2 = C.int(requiredMinor)
	arg3 = C.int(requiredMicro)

	ret := C.pango_version_check(arg1, arg2, arg3)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
func VersionString() string {

	ret := C.pango_version_string()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Analysis: the `PangoAnalysis` structure stores information about the
// properties of a segment of text.
type Analysis struct {
	native C.PangoAnalysis
}

// WrapAnalysis wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAnalysis(ptr unsafe.Pointer) *Analysis {
	if ptr == nil {
		return nil
	}

	return (*Analysis)(ptr)
}

func marshalAnalysis(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAnalysis(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *Analysis) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// ShapeEngine gets the field inside the struct.
func (s *Analysis) ShapeEngine() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(a.native.shape_engine))
	return ret
}

// LangEngine gets the field inside the struct.
func (l *Analysis) LangEngine() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(a.native.lang_engine))
	return ret
}

// Font gets the field inside the struct.
func (f *Analysis) Font() Font {
	var ret Font
	ret = WrapFont(externglib.Take(unsafe.Pointer(a.native.font.Native())))
	return ret
}

// Level gets the field inside the struct.
func (l *Analysis) Level() byte {
	var ret byte
	ret = byte(a.native.level)
	return ret
}

// Gravity gets the field inside the struct.
func (g *Analysis) Gravity() byte {
	var ret byte
	ret = byte(a.native.gravity)
	return ret
}

// Flags gets the field inside the struct.
func (f *Analysis) Flags() byte {
	var ret byte
	ret = byte(a.native.flags)
	return ret
}

// Script gets the field inside the struct.
func (s *Analysis) Script() byte {
	var ret byte
	ret = byte(a.native.script)
	return ret
}

// Language gets the field inside the struct.
func (l *Analysis) Language() *Language {
	var ret *Language
	{
		ret = WrapLanguage(a.native.language)
		runtime.SetFinalizer(&ret, func(v **Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// ExtraAttrs gets the field inside the struct.
func (e *Analysis) ExtraAttrs() *glib.SList {
	var ret *glib.SList
	{
		ret = glib.WrapSList(a.native.extra_attrs)
		runtime.SetFinalizer(&ret, func(v **glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// AttrColor: the `PangoAttrColor` structure is used to represent attributes
// that are colors.
type AttrColor struct {
	native C.PangoAttrColor
}

// WrapAttrColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrColor(ptr unsafe.Pointer) *AttrColor {
	if ptr == nil {
		return nil
	}

	return (*AttrColor)(ptr)
}

func marshalAttrColor(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrColor(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrColor) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrColor) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Color gets the field inside the struct.
func (c *AttrColor) Color() Color {
	var ret Color
	{
		ret = WrapColor(a.native.color)
		runtime.SetFinalizer(&ret, func(v *Color) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// AttrFloat: the `PangoAttrFloat` structure is used to represent attributes
// with a float or double value.
type AttrFloat struct {
	native C.PangoAttrFloat
}

// WrapAttrFloat wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFloat(ptr unsafe.Pointer) *AttrFloat {
	if ptr == nil {
		return nil
	}

	return (*AttrFloat)(ptr)
}

func marshalAttrFloat(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrFloat(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrFloat) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrFloat) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Value gets the field inside the struct.
func (v *AttrFloat) Value() float64 {
	var ret float64
	ret = float64(a.native.value)
	return ret
}

// AttrFontDesc: the `PangoAttrFontDesc` structure is used to store an attribute
// that sets all aspects of the font description at once.
type AttrFontDesc struct {
	native C.PangoAttrFontDesc
}

// WrapAttrFontDesc wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFontDesc(ptr unsafe.Pointer) *AttrFontDesc {
	if ptr == nil {
		return nil
	}

	return (*AttrFontDesc)(ptr)
}

func marshalAttrFontDesc(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrFontDesc(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrFontDesc) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrFontDesc) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Desc gets the field inside the struct.
func (d *AttrFontDesc) Desc() *FontDescription {
	var ret *FontDescription
	{
		ret = WrapFontDescription(a.native.desc)
		runtime.SetFinalizer(&ret, func(v **FontDescription) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// AttrFontFeatures: the `PangoAttrFontFeatures` structure is used to represent
// OpenType font features as an attribute.
type AttrFontFeatures struct {
	native C.PangoAttrFontFeatures
}

// WrapAttrFontFeatures wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFontFeatures(ptr unsafe.Pointer) *AttrFontFeatures {
	if ptr == nil {
		return nil
	}

	return (*AttrFontFeatures)(ptr)
}

func marshalAttrFontFeatures(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrFontFeatures(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrFontFeatures) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrFontFeatures) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Features gets the field inside the struct.
func (f *AttrFontFeatures) Features() string {
	var ret string
	ret = C.GoString(a.native.features)
	return ret
}

// AttrInt: the `PangoAttrInt` structure is used to represent attributes with an
// integer or enumeration value.
type AttrInt struct {
	native C.PangoAttrInt
}

// WrapAttrInt wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrInt(ptr unsafe.Pointer) *AttrInt {
	if ptr == nil {
		return nil
	}

	return (*AttrInt)(ptr)
}

func marshalAttrInt(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrInt(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrInt) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrInt) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Value gets the field inside the struct.
func (v *AttrInt) Value() int {
	var ret int
	ret = int(a.native.value)
	return ret
}

// AttrIterator: a `PangoAttrIterator` is used to iterate through a
// `PangoAttrList`.
//
// A new iterator is created with [method@Pango.AttrList.get_iterator]. Once the
// iterator is created, it can be advanced through the style changes in the text
// using [method@Pango.AttrIterator.next]. At each style change, the range of
// the current style segment and the attributes currently in effect can be
// queried.
type AttrIterator struct {
	native C.PangoAttrIterator
}

// WrapAttrIterator wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrIterator(ptr unsafe.Pointer) *AttrIterator {
	if ptr == nil {
		return nil
	}

	return (*AttrIterator)(ptr)
}

func marshalAttrIterator(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrIterator(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrIterator) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Copy: copy a `PangoAttrIterator`.
func (iterator *AttrIterator) Copy() *AttrIterator {
	var arg0 *C.PangoAttrIterator

	arg0 = (*C.PangoAttrIterator)(iterator.Native())

	ret := C.pango_attr_iterator_copy(arg0)

	var ret0 *AttrIterator

	{
		ret0 = WrapAttrIterator(ret)
	}

	return ret0
}

// Destroy: destroy a `PangoAttrIterator` and free all associated memory.
func (iterator *AttrIterator) Destroy() {
	var arg0 *C.PangoAttrIterator

	arg0 = (*C.PangoAttrIterator)(iterator.Native())

	C.pango_attr_iterator_destroy(arg0)
}

// Get: find the current attribute of a particular type at the iterator
// location. When multiple attributes of the same type overlap, the attribute
// whose range starts closest to the current location is used.
func (iterator *AttrIterator) Get(_type AttrType) *Attribute {
	var arg0 *C.PangoAttrIterator
	var arg1 C.PangoAttrType

	arg0 = (*C.PangoAttrIterator)(iterator.Native())
	arg1 = (C.PangoAttrType)(_type)

	ret := C.pango_attr_iterator_get(arg0, arg1)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
		runtime.SetFinalizer(&ret0, func(v **Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Attrs gets a list of all attributes at the current position of the iterator.
func (iterator *AttrIterator) Attrs() *glib.SList {
	var arg0 *C.PangoAttrIterator

	arg0 = (*C.PangoAttrIterator)(iterator.Native())

	ret := C.pango_attr_iterator_get_attrs(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(ret)
	}

	return ret0
}

// Font: get the font and other attributes at the current iterator position.
func (iterator *AttrIterator) Font(desc *FontDescription, language **Language, extraAttrs **glib.SList) {
	var arg0 *C.PangoAttrIterator
	var arg1 *C.PangoFontDescription
	var arg2 **C.PangoLanguage
	var arg3 **C.GSList

	arg0 = (*C.PangoAttrIterator)(iterator.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())
	arg2 = (**C.PangoLanguage)(language.Native())
	arg3 = (**C.GSList)(extraAttrs.Native())

	C.pango_attr_iterator_get_font(arg0, arg1, arg2, arg3)
}

// Next: advance the iterator until the next change of style.
func (iterator *AttrIterator) Next() bool {
	var arg0 *C.PangoAttrIterator

	arg0 = (*C.PangoAttrIterator)(iterator.Native())

	ret := C.pango_attr_iterator_next(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Range: get the range of the current segment. Note that the stored return
// values are signed, not unsigned like the values in `PangoAttribute`. To deal
// with this API oversight, stored return values that wouldn't fit into a signed
// integer are clamped to G_MAXINT.
func (iterator *AttrIterator) Range() (start int, end int) {
	var arg0 *C.PangoAttrIterator
	var arg1 *C.gint // out
	var arg2 *C.gint // out

	arg0 = (*C.PangoAttrIterator)(iterator.Native())

	ret := C.pango_attr_iterator_range(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// AttrLanguage: the `PangoAttrLanguage` structure is used to represent
// attributes that are languages.
type AttrLanguage struct {
	native C.PangoAttrLanguage
}

// WrapAttrLanguage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrLanguage(ptr unsafe.Pointer) *AttrLanguage {
	if ptr == nil {
		return nil
	}

	return (*AttrLanguage)(ptr)
}

func marshalAttrLanguage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrLanguage(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrLanguage) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrLanguage) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Value gets the field inside the struct.
func (v *AttrLanguage) Value() *Language {
	var ret *Language
	{
		ret = WrapLanguage(a.native.value)
		runtime.SetFinalizer(&ret, func(v **Language) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// AttrList: a `PangoAttrList` represents a list of attributes that apply to a
// section of text.
//
// The attributes in a `PangoAttrList` are, in general, allowed to overlap in an
// arbitrary fashion. However, if the attributes are manipulated only through
// [method@Pango.AttrList.change], the overlap between properties will meet
// stricter criteria.
//
// Since the `PangoAttrList` structure is stored as a linear list, it is not
// suitable for storing attributes for large amounts of text. In general, you
// should not use a single `PangoAttrList` for more than one paragraph of text.
type AttrList struct {
	native C.PangoAttrList
}

// WrapAttrList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrList(ptr unsafe.Pointer) *AttrList {
	if ptr == nil {
		return nil
	}

	return (*AttrList)(ptr)
}

func marshalAttrList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrList(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrList) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// NewAttrList constructs a struct AttrList.
func NewAttrList() *AttrList {

	ret := C.pango_attr_list_new()

	var ret0 *AttrList

	{
		ret0 = WrapAttrList(ret)
	}

	return ret0
}

// Change: insert the given attribute into the `PangoAttrList`.
//
// It will replace any attributes of the same type on that segment and be merged
// with any adjoining attributes that are identical.
//
// This function is slower than [method@Pango.AttrList.insert] for creating an
// attribute list in order (potentially much slower for large lists). However,
// [method@Pango.AttrList.insert] is not suitable for continually changing a set
// of attributes since it never removes or combines existing attributes.
func (list *AttrList) Change(attr *Attribute) {
	var arg0 *C.PangoAttrList
	var arg1 *C.PangoAttribute

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*C.PangoAttribute)(attr.Native())

	C.pango_attr_list_change(arg0, arg1)
}

// Copy: copy @list and return an identical new list.
func (list *AttrList) Copy() *AttrList {
	var arg0 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_attr_list_copy(arg0)

	var ret0 *AttrList

	{
		ret0 = WrapAttrList(ret)
	}

	return ret0
}

// Equal checks whether @list and @other_list contain the same attributes and
// whether those attributes apply to the same ranges. Beware that this will
// return wrong values if any list contains duplicates.
func (list *AttrList) Equal(otherList *AttrList) bool {
	var arg0 *C.PangoAttrList
	var arg1 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*C.PangoAttrList)(otherList.Native())

	ret := C.pango_attr_list_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Filter: given a `PangoAttrList` and callback function, removes any elements
// of @list for which @func returns true and inserts them into a new list.
func (list *AttrList) Filter(_func AttrFilterFunc) *AttrList {
	var arg0 *C.PangoAttrList
	var arg1 C.PangoAttrFilterFunc
	var arg2 C.gpointer

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*[0]byte)(C.gotk4_AttrFilterFunc)
	arg2 = C.gpointer(box.Assign(_func))

	ret := C.pango_attr_list_filter(arg0, arg1, arg2)

	var ret0 *AttrList

	{
		ret0 = WrapAttrList(ret)
	}

	return ret0
}

// Attributes gets a list of all attributes in @list.
func (list *AttrList) Attributes() *glib.SList {
	var arg0 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_attr_list_get_attributes(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(ret)
	}

	return ret0
}

// Iterator: create a iterator initialized to the beginning of the list. @list
// must not be modified until this iterator is freed.
func (list *AttrList) Iterator() *AttrIterator {
	var arg0 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_attr_list_get_iterator(arg0)

	var ret0 *AttrIterator

	{
		ret0 = WrapAttrIterator(ret)
	}

	return ret0
}

// Insert: insert the given attribute into the `PangoAttrList`.
//
// It will be inserted after all other attributes with a matching @start_index.
func (list *AttrList) Insert(attr *Attribute) {
	var arg0 *C.PangoAttrList
	var arg1 *C.PangoAttribute

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*C.PangoAttribute)(attr.Native())

	C.pango_attr_list_insert(arg0, arg1)
}

// InsertBefore: insert the given attribute into the `PangoAttrList`.
//
// It will be inserted before all other attributes with a matching @start_index.
func (list *AttrList) InsertBefore(attr *Attribute) {
	var arg0 *C.PangoAttrList
	var arg1 *C.PangoAttribute

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*C.PangoAttribute)(attr.Native())

	C.pango_attr_list_insert_before(arg0, arg1)
}

// Ref: increase the reference count of the given attribute list by one.
func (list *AttrList) Ref() *AttrList {
	var arg0 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_attr_list_ref(arg0)

	var ret0 *AttrList

	{
		ret0 = WrapAttrList(ret)
	}

	return ret0
}

// Splice: this function opens up a hole in @list, fills it in with attributes
// from the left, and then merges @other on top of the hole.
//
// This operation is equivalent to stretching every attribute that applies at
// position @pos in @list by an amount @len, and then calling
// [method@Pango.AttrList.change] with a copy of each attribute in @other in
// sequence (offset in position by @pos).
//
// This operation proves useful for, for instance, inserting a pre-edit string
// in the middle of an edit buffer.
func (list *AttrList) Splice(other *AttrList, pos int, len int) {
	var arg0 *C.PangoAttrList
	var arg1 *C.PangoAttrList
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = (*C.PangoAttrList)(other.Native())
	arg2 = C.gint(pos)
	arg3 = C.gint(len)

	C.pango_attr_list_splice(arg0, arg1, arg2, arg3)
}

// Unref: decrease the reference count of the given attribute list by one. If
// the result is zero, free the attribute list and the attributes it contains.
func (list *AttrList) Unref() {
	var arg0 *C.PangoAttrList

	arg0 = (*C.PangoAttrList)(list.Native())

	C.pango_attr_list_unref(arg0)
}

// Update: update indices of attributes in @list for a change in the text they
// refer to.
//
// The change that this function applies is removing @remove bytes at position
// @pos and inserting @add bytes instead.
//
// Attributes that fall entirely in the (@pos, @pos + @remove) range are
// removed.
//
// Attributes that start or end inside the (@pos, @pos + @remove) range are
// shortened to reflect the removal.
//
// Attributes start and end positions are updated if they are behind @pos +
// @remove.
func (list *AttrList) Update(pos int, remove int, add int) {
	var arg0 *C.PangoAttrList
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.PangoAttrList)(list.Native())
	arg1 = C.int(pos)
	arg2 = C.int(remove)
	arg3 = C.int(add)

	C.pango_attr_list_update(arg0, arg1, arg2, arg3)
}

// AttrShape: the `PangoAttrShape` structure is used to represent attributes
// which impose shape restrictions.
type AttrShape struct {
	native C.PangoAttrShape
}

// WrapAttrShape wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrShape(ptr unsafe.Pointer) *AttrShape {
	if ptr == nil {
		return nil
	}

	return (*AttrShape)(ptr)
}

func marshalAttrShape(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrShape(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrShape) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrShape) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// InkRect gets the field inside the struct.
func (i *AttrShape) InkRect() Rectangle {
	var ret Rectangle
	{
		ret = WrapRectangle(a.native.ink_rect)
		runtime.SetFinalizer(&ret, func(v *Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// LogicalRect gets the field inside the struct.
func (l *AttrShape) LogicalRect() Rectangle {
	var ret Rectangle
	{
		ret = WrapRectangle(a.native.logical_rect)
		runtime.SetFinalizer(&ret, func(v *Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Data gets the field inside the struct.
func (d *AttrShape) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(a.native.data))
	return ret
}

// AttrSize: the `PangoAttrSize` structure is used to represent attributes which
// set font size.
type AttrSize struct {
	native C.PangoAttrSize
}

// WrapAttrSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrSize(ptr unsafe.Pointer) *AttrSize {
	if ptr == nil {
		return nil
	}

	return (*AttrSize)(ptr)
}

func marshalAttrSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrSize(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrSize) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Size gets the field inside the struct.
func (s *AttrSize) Size() int {
	var ret int
	ret = int(a.native.size)
	return ret
}

// Absolute gets the field inside the struct.
func (a *AttrSize) Absolute() uint {
	var ret uint
	ret = uint(a.native.absolute)
	return ret
}

// AttrString: the `PangoAttrString` structure is used to represent attributes
// with a string value.
type AttrString struct {
	native C.PangoAttrString
}

// WrapAttrString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrString(ptr unsafe.Pointer) *AttrString {
	if ptr == nil {
		return nil
	}

	return (*AttrString)(ptr)
}

func marshalAttrString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrString(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *AttrString) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attr gets the field inside the struct.
func (a *AttrString) Attr() Attribute {
	var ret Attribute
	{
		ret = WrapAttribute(a.native.attr)
		runtime.SetFinalizer(&ret, func(v *Attribute) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Value gets the field inside the struct.
func (v *AttrString) Value() string {
	var ret string
	ret = C.GoString(a.native.value)
	return ret
}

// Attribute: the `PangoAttribute` structure represents the common portions of
// all attributes.
//
// Particular types of attributes include this structure as their initial
// portion. The common portion of the attribute holds the range to which the
// value in the type-specific part of the attribute applies and should be
// initialized using [method@Pango.Attribute.init]. By default, an attribute
// will have an all-inclusive range of [0,G_MAXUINT].
type Attribute struct {
	native C.PangoAttribute
}

// WrapAttribute wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttribute(ptr unsafe.Pointer) *Attribute {
	if ptr == nil {
		return nil
	}

	return (*Attribute)(ptr)
}

func marshalAttribute(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttribute(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (a *Attribute) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Klass gets the field inside the struct.
func (k *Attribute) Klass() *AttrClass {
	var ret *AttrClass
	{
		ret = WrapAttrClass(a.native.klass)
		runtime.SetFinalizer(&ret, func(v **AttrClass) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// StartIndex gets the field inside the struct.
func (s *Attribute) StartIndex() uint {
	var ret uint
	ret = uint(a.native.start_index)
	return ret
}

// EndIndex gets the field inside the struct.
func (e *Attribute) EndIndex() uint {
	var ret uint
	ret = uint(a.native.end_index)
	return ret
}

// Copy: make a copy of an attribute.
func (attr *Attribute) Copy() *Attribute {
	var arg0 *C.PangoAttribute

	arg0 = (*C.PangoAttribute)(attr.Native())

	ret := C.pango_attribute_copy(arg0)

	var ret0 *Attribute

	{
		ret0 = WrapAttribute(ret)
	}

	return ret0
}

// Destroy: destroy a `PangoAttribute` and free all associated memory.
func (attr *Attribute) Destroy() {
	var arg0 *C.PangoAttribute

	arg0 = (*C.PangoAttribute)(attr.Native())

	C.pango_attribute_destroy(arg0)
}

// Equal: compare two attributes for equality. This compares only the actual
// value of the two attributes and not the ranges that the attributes apply to.
func (attr1 *Attribute) Equal(attr2 *Attribute) bool {
	var arg0 *C.PangoAttribute
	var arg1 *C.PangoAttribute

	arg0 = (*C.PangoAttribute)(attr1.Native())
	arg1 = (*C.PangoAttribute)(attr2.Native())

	ret := C.pango_attribute_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Init initializes @attr's klass to @klass, it's start_index to
// PANGO_ATTR_INDEX_FROM_TEXT_BEGINNING and end_index to
// PANGO_ATTR_INDEX_TO_TEXT_END such that the attribute applies to the entire
// text by default.
func (attr *Attribute) Init(klass *AttrClass) {
	var arg0 *C.PangoAttribute
	var arg1 *C.PangoAttrClass

	arg0 = (*C.PangoAttribute)(attr.Native())
	arg1 = (*C.PangoAttrClass)(klass.Native())

	C.pango_attribute_init(arg0, arg1)
}

// Color: the `PangoColor` structure is used to represent a color in an
// uncalibrated RGB color-space.
type Color struct {
	native C.PangoColor
}

// WrapColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColor(ptr unsafe.Pointer) *Color {
	if ptr == nil {
		return nil
	}

	return (*Color)(ptr)
}

func marshalColor(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColor(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (c *Color) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Red gets the field inside the struct.
func (r *Color) Red() uint16 {
	var ret uint16
	ret = uint16(c.native.red)
	return ret
}

// Green gets the field inside the struct.
func (g *Color) Green() uint16 {
	var ret uint16
	ret = uint16(c.native.green)
	return ret
}

// Blue gets the field inside the struct.
func (b *Color) Blue() uint16 {
	var ret uint16
	ret = uint16(c.native.blue)
	return ret
}

// Copy creates a copy of @src.
//
// The copy should be freed with pango_color_free(). Primarily used by language
// bindings, not that useful otherwise (since colors can just be copied by
// assignment in C).
func (src *Color) Copy() *Color {
	var arg0 *C.PangoColor

	arg0 = (*C.PangoColor)(src.Native())

	ret := C.pango_color_copy(arg0)

	var ret0 *Color

	{
		ret0 = WrapColor(ret)
	}

	return ret0
}

// Free frees a color allocated by pango_color_copy().
func (color *Color) Free() {
	var arg0 *C.PangoColor

	arg0 = (*C.PangoColor)(color.Native())

	C.pango_color_free(arg0)
}

// Parse: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a value in the form `#rgb`, `#rrggbb`, `#rrrgggbbb` or
// `#rrrrggggbbbb`, where `r`, `g` and `b` are hex digits of the red, green, and
// blue components of the color, respectively. (White in the four forms is
// `#fff`, `#ffffff`, `#fffffffff` and `#ffffffffffff`.)
func (color *Color) Parse(spec string) bool {
	var arg0 *C.PangoColor
	var arg1 *C.char

	arg0 = (*C.PangoColor)(color.Native())
	arg1 = (*C.gchar)(C.CString(spec))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_color_parse(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ParseWithAlpha: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a hexadecimal value in the form `#rgb`, `#rrggbb`, `#rrrgggbbb` or
// `#rrrrggggbbbb` where `r`, `g` and `b` are hex digits of the red, green, and
// blue components of the color, respectively. (White in the four forms is
// `#fff`, `#ffffff`, `#fffffffff` and `#ffffffffffff`.)
//
// Additionally, parse strings of the form `#rgba`, `#rrggbbaa`,
// `#rrrrggggbbbbaaaa`, if @alpha is not nil, and set @alpha to the value
// specified by the hex digits for `a`. If no alpha component is found in @spec,
// @alpha is set to 0xffff (for a solid color).
func (color *Color) ParseWithAlpha(spec string) (alpha uint16, ok bool) {
	var arg0 *C.PangoColor
	var arg1 *C.guint16 // out
	var arg2 *C.char

	arg0 = (*C.PangoColor)(color.Native())
	arg2 = (*C.gchar)(C.CString(spec))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.pango_color_parse_with_alpha(arg0, &arg1, arg2)

	var ret0 uint16
	var ret1 bool

	ret0 = uint16(arg1)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// String returns a textual specification of @color.
//
// The string is in the hexadecimal form `#rrrrggggbbbb`, where `r`, `g` and `b`
// are hex digits representing the red, green, and blue components respectively.
func (color *Color) String() string {
	var arg0 *C.PangoColor

	arg0 = (*C.PangoColor)(color.Native())

	ret := C.pango_color_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FontDescription: a `PangoFontDescription` describes a font in an
// implementation-independent manner.
//
// `PangoFontDescription` structures are used both to list what fonts are
// available on the system and also for specifying the characteristics of a font
// to load.
type FontDescription struct {
	native C.PangoFontDescription
}

// WrapFontDescription wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontDescription(ptr unsafe.Pointer) *FontDescription {
	if ptr == nil {
		return nil
	}

	return (*FontDescription)(ptr)
}

func marshalFontDescription(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontDescription(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FontDescription) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// NewFontDescription constructs a struct FontDescription.
func NewFontDescription() *FontDescription {

	ret := C.pango_font_description_new()

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// BetterMatch determines if the style attributes of @new_match are a closer
// match for @desc than those of @old_match are, or if @old_match is nil,
// determines if @new_match is a match at all.
//
// Approximate matching is done for weight and style; other style attributes
// must match exactly. Style attributes are all attributes other than family and
// size-related attributes. Approximate matching for style considers
// PANGO_STYLE_OBLIQUE and PANGO_STYLE_ITALIC as matches, but not as good a
// match as when the styles are equal.
//
// Note that @old_match must match @desc.
func (desc *FontDescription) BetterMatch(oldMatch *FontDescription, newMatch *FontDescription) bool {
	var arg0 *C.PangoFontDescription
	var arg1 *C.PangoFontDescription
	var arg2 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.PangoFontDescription)(oldMatch.Native())
	arg2 = (*C.PangoFontDescription)(newMatch.Native())

	ret := C.pango_font_description_better_match(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Copy: make a copy of a `PangoFontDescription`.
func (desc *FontDescription) Copy() *FontDescription {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_copy(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// CopyStatic: make a copy of a `PangoFontDescription`, but don't duplicate
// allocated fields.
//
// This is like [method@Pango.FontDescription.copy], but only a shallow copy is
// made of the family name and other allocated fields. The result can only be
// used until @desc is modified or freed. This is meant to be used when the copy
// is only needed temporarily.
func (desc *FontDescription) CopyStatic() *FontDescription {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_copy_static(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// Equal compares two font descriptions for equality.
//
// Two font descriptions are considered equal if the fonts they describe are
// provably identical. This means that their masks do not have to match, as long
// as other fields are all the same. (Two font descriptions may result in
// identical fonts being loaded, but still compare false.)
func (desc1 *FontDescription) Equal(desc2 *FontDescription) bool {
	var arg0 *C.PangoFontDescription
	var arg1 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc1.Native())
	arg1 = (*C.PangoFontDescription)(desc2.Native())

	ret := C.pango_font_description_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Free frees a font description.
func (desc *FontDescription) Free() {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	C.pango_font_description_free(arg0)
}

// Family gets the family name field of a font description.
//
// See [method@Pango.FontDescription.set_family].
func (desc *FontDescription) Family() string {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_family(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Gravity gets the gravity field of a font description.
//
// See [method@Pango.FontDescription.set_gravity].
func (desc *FontDescription) Gravity() Gravity {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_gravity(arg0)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// SetFields determines which fields in a font description have been set.
func (desc *FontDescription) SetFields() FontMask {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_set_fields(arg0)

	var ret0 FontMask

	ret0 = FontMask(ret)

	return ret0
}

// Size gets the size field of a font description.
//
// See [method@Pango.FontDescription.set_size].
func (desc *FontDescription) Size() int {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SizeIsAbsolute determines whether the size of the font is in points (not
// absolute) or device units (absolute).
//
// See [method@Pango.FontDescription.set_size] and
// [method@Pango.FontDescription.set_absolute_size].
func (desc *FontDescription) SizeIsAbsolute() bool {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_size_is_absolute(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Stretch gets the stretch field of a font description.
//
// See [method@Pango.FontDescription.set_stretch].
func (desc *FontDescription) Stretch() Stretch {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_stretch(arg0)

	var ret0 Stretch

	ret0 = Stretch(ret)

	return ret0
}

// Style gets the style field of a `PangoFontDescription`.
//
// See [method@Pango.FontDescription.set_style].
func (desc *FontDescription) Style() Style {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_style(arg0)

	var ret0 Style

	ret0 = Style(ret)

	return ret0
}

// Variant gets the variant field of a `PangoFontDescription`.
//
// See [method@Pango.FontDescription.set_variant].
func (desc *FontDescription) Variant() Variant {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_variant(arg0)

	var ret0 Variant

	ret0 = Variant(ret)

	return ret0
}

// Variations gets the variations field of a font description.
//
// See [method@Pango.FontDescription.set_variations].
func (desc *FontDescription) Variations() string {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_variations(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Weight gets the weight field of a font description.
//
// See [method@Pango.FontDescription.set_weight].
func (desc *FontDescription) Weight() Weight {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_get_weight(arg0)

	var ret0 Weight

	ret0 = Weight(ret)

	return ret0
}

// Hash computes a hash of a `PangoFontDescription` structure.
//
// This is suitable to be used, for example, as an argument to
// g_hash_table_new(). The hash value is independent of @desc->mask.
func (desc *FontDescription) Hash() uint {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Merge merges the fields that are set in @desc_to_merge into the fields in
// @desc.
//
// If @replace_existing is false, only fields in @desc that are not already set
// are affected. If true, then fields that are already set will be replaced as
// well.
//
// If @desc_to_merge is nil, this function performs nothing.
func (desc *FontDescription) Merge(descToMerge *FontDescription, replaceExisting bool) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.PangoFontDescription
	var arg2 C.gboolean

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.PangoFontDescription)(descToMerge.Native())
	arg2 = gextras.Cbool(replaceExisting)

	C.pango_font_description_merge(arg0, arg1, arg2)
}

// MergeStatic merges the fields that are set in @desc_to_merge into the fields
// in @desc, without copying allocated fields.
//
// This is like [method@Pango.FontDescription.merge], but only a shallow copy is
// made of the family name and other allocated fields. @desc can only be used
// until @desc_to_merge is modified or freed. This is meant to be used when the
// merged font description is only needed temporarily.
func (desc *FontDescription) MergeStatic(descToMerge *FontDescription, replaceExisting bool) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.PangoFontDescription
	var arg2 C.gboolean

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.PangoFontDescription)(descToMerge.Native())
	arg2 = gextras.Cbool(replaceExisting)

	C.pango_font_description_merge_static(arg0, arg1, arg2)
}

// SetAbsoluteSize sets the size field of a font description, in device units.
//
// This is mutually exclusive with [method@Pango.FontDescription.set_size] which
// sets the font size in points.
func (desc *FontDescription) SetAbsoluteSize(size float64) {
	var arg0 *C.PangoFontDescription
	var arg1 C.double

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = C.double(size)

	C.pango_font_description_set_absolute_size(arg0, arg1)
}

// SetFamily sets the family name field of a font description.
//
// The family name represents a family of related font styles, and will resolve
// to a particular `PangoFontFamily`. In some uses of `PangoFontDescription`, it
// is also possible to use a comma separated list of family names for this
// field.
func (desc *FontDescription) SetFamily(family string) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.char

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.gchar)(C.CString(family))
	defer C.free(unsafe.Pointer(arg1))

	C.pango_font_description_set_family(arg0, arg1)
}

// SetFamilyStatic sets the family name field of a font description, without
// copying the string.
//
// This is like [method@Pango.FontDescription.set_family], except that no copy
// of @family is made. The caller must make sure that the string passed in stays
// around until @desc has been freed or the name is set again. This function can
// be used if @family is a static string such as a C string literal, or if @desc
// is only needed temporarily.
func (desc *FontDescription) SetFamilyStatic(family string) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.char

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.gchar)(C.CString(family))
	defer C.free(unsafe.Pointer(arg1))

	C.pango_font_description_set_family_static(arg0, arg1)
}

// SetGravity sets the gravity field of a font description.
//
// The gravity field specifies how the glyphs should be rotated. If @gravity is
// PANGO_GRAVITY_AUTO, this actually unsets the gravity mask on the font
// description.
//
// This function is seldom useful to the user. Gravity should normally be set on
// a `PangoContext`.
func (desc *FontDescription) SetGravity(gravity Gravity) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoGravity

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoGravity)(gravity)

	C.pango_font_description_set_gravity(arg0, arg1)
}

// SetSize sets the size field of a font description in fractional points.
//
// This is mutually exclusive with
// [method@Pango.FontDescription.set_absolute_size].
func (desc *FontDescription) SetSize(size int) {
	var arg0 *C.PangoFontDescription
	var arg1 C.gint

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = C.gint(size)

	C.pango_font_description_set_size(arg0, arg1)
}

// SetStretch sets the stretch field of a font description.
//
// The [enum@Pango.Stretch] field specifies how narrow or wide the font should
// be.
func (desc *FontDescription) SetStretch(stretch Stretch) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoStretch

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoStretch)(stretch)

	C.pango_font_description_set_stretch(arg0, arg1)
}

// SetStyle sets the style field of a `PangoFontDescription`.
//
// The [enum@Pango.Style] enumeration describes whether the font is slanted and
// the manner in which it is slanted; it can be either NGO_STYLE_NORMAL,
// NGO_STYLE_ITALIC, or NGO_STYLE_OBLIQUE.
//
// Most fonts will either have a italic style or an oblique style, but not both,
// and font matching in Pango will match italic specifications with oblique
// fonts and vice-versa if an exact match is not found.
func (desc *FontDescription) SetStyle(style Style) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoStyle

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoStyle)(style)

	C.pango_font_description_set_style(arg0, arg1)
}

// SetVariant sets the variant field of a font description.
//
// The [enum@Pango.Variant] can either be PANGO_VARIANT_NORMAL or
// PANGO_VARIANT_SMALL_CAPS.
func (desc *FontDescription) SetVariant(variant Variant) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoVariant

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoVariant)(variant)

	C.pango_font_description_set_variant(arg0, arg1)
}

// SetVariations sets the variations field of a font description.
//
// OpenType font variations allow to select a font instance by specifying values
// for a number of axes, such as width or weight.
//
// The format of the variations string is
//
//    AXIS1=VALUE,AXIS2=VALUE...
//
// with each AXIS a 4 character tag that identifies a font axis, and each VALUE
// a floating point number. Unknown axes are ignored, and values are clamped to
// their allowed range.
//
// Pango does not currently have a way to find supported axes of a font. Both
// harfbuzz or freetype have API for this.
func (desc *FontDescription) SetVariations(variations string) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.char

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.gchar)(C.CString(variations))
	defer C.free(unsafe.Pointer(arg1))

	C.pango_font_description_set_variations(arg0, arg1)
}

// SetVariationsStatic sets the variations field of a font description.
//
// This is like [method@Pango.FontDescription.set_variations], except that no
// copy of @variations is made. The caller must make sure that the string passed
// in stays around until @desc has been freed or the name is set again. This
// function can be used if @variations is a static string such as a C string
// literal, or if @desc is only needed temporarily.
func (desc *FontDescription) SetVariationsStatic(variations string) {
	var arg0 *C.PangoFontDescription
	var arg1 *C.char

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (*C.gchar)(C.CString(variations))
	defer C.free(unsafe.Pointer(arg1))

	C.pango_font_description_set_variations_static(arg0, arg1)
}

// SetWeight sets the weight field of a font description.
//
// The weight field specifies how bold or light the font should be. In addition
// to the values of the [enum@Pango.Weight] enumeration, other intermediate
// numeric values are possible.
func (desc *FontDescription) SetWeight(weight Weight) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoWeight

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoWeight)(weight)

	C.pango_font_description_set_weight(arg0, arg1)
}

// ToFilename creates a filename representation of a font description.
//
// The filename is identical to the result from calling
// [method@Pango.FontDescription.to_string], but with underscores instead of
// characters that are untypical in filenames, and in lower case only.
func (desc *FontDescription) ToFilename() string {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_to_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// String creates a string representation of a font description.
//
// See [type_func@Pango.FontDescription.from_string] for a description of the
// format of the string representation. The family list in the string
// description will only have a terminating comma if the last word of the list
// is a valid style option.
func (desc *FontDescription) String() string {
	var arg0 *C.PangoFontDescription

	arg0 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_description_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UnsetFields unsets some of the fields in a `PangoFontDescription`.
//
// The unset fields will get back to their default values.
func (desc *FontDescription) UnsetFields(toUnset FontMask) {
	var arg0 *C.PangoFontDescription
	var arg1 C.PangoFontMask

	arg0 = (*C.PangoFontDescription)(desc.Native())
	arg1 = (C.PangoFontMask)(toUnset)

	C.pango_font_description_unset_fields(arg0, arg1)
}

// FontMetrics: a `PangoFontMetrics` structure holds the overall metric
// information for a font.
//
// The information in a `PangoFontMetrics` structure may be restricted to a
// script. The fields of this structure are private to implementations of a font
// backend. See the documentation of the corresponding getters for documentation
// of their meaning.
type FontMetrics struct {
	native C.PangoFontMetrics
}

// WrapFontMetrics wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontMetrics(ptr unsafe.Pointer) *FontMetrics {
	if ptr == nil {
		return nil
	}

	return (*FontMetrics)(ptr)
}

func marshalFontMetrics(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontMetrics(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FontMetrics) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// ApproximateCharWidth gets the approximate character width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual characters in text will be wider and
// narrower than this.
func (metrics *FontMetrics) ApproximateCharWidth() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_approximate_char_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ApproximateDigitWidth gets the approximate digit width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual digits in text can be wider or narrower
// than this, though this value is generally somewhat more accurate than the
// result of pango_font_metrics_get_approximate_char_width() for digits.
func (metrics *FontMetrics) ApproximateDigitWidth() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_approximate_digit_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Ascent gets the ascent from a font metrics structure.
//
// The ascent is the distance from the baseline to the logical top of a line of
// text. (The logical top may be above or below the top of the actual drawn ink.
// It is necessary to lay out the text to figure where the ink will be.)
func (metrics *FontMetrics) Ascent() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_ascent(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Descent gets the descent from a font metrics structure.
//
// The descent is the distance from the baseline to the logical bottom of a line
// of text. (The logical bottom may be above or below the bottom of the actual
// drawn ink. It is necessary to lay out the text to figure where the ink will
// be.)
func (metrics *FontMetrics) Descent() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_descent(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Height gets the line height from a font metrics structure.
//
// The line height is the distance between successive baselines in wrapped text.
//
// If the line height is not available, 0 is returned.
func (metrics *FontMetrics) Height() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// StrikethroughPosition gets the suggested position to draw the strikethrough.
//
// The value returned is the distance *above* the baseline of the top of the
// strikethrough.
func (metrics *FontMetrics) StrikethroughPosition() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_strikethrough_position(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// StrikethroughThickness gets the suggested thickness to draw for the
// strikethrough.
func (metrics *FontMetrics) StrikethroughThickness() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_strikethrough_thickness(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnderlinePosition gets the suggested position to draw the underline.
//
// The value returned is the distance *above* the baseline of the top of the
// underline. Since most fonts have underline positions beneath the baseline,
// this value is typically negative.
func (metrics *FontMetrics) UnderlinePosition() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_underline_position(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnderlineThickness gets the suggested thickness to draw for the underline.
func (metrics *FontMetrics) UnderlineThickness() int {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_get_underline_thickness(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Ref: increase the reference count of a font metrics structure by one.
func (metrics *FontMetrics) Ref() *FontMetrics {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	ret := C.pango_font_metrics_ref(arg0)

	var ret0 *FontMetrics

	{
		ret0 = WrapFontMetrics(ret)
	}

	return ret0
}

// Unref: decrease the reference count of a font metrics structure by one. If
// the result is zero, frees the structure and any associated memory.
func (metrics *FontMetrics) Unref() {
	var arg0 *C.PangoFontMetrics

	arg0 = (*C.PangoFontMetrics)(metrics.Native())

	C.pango_font_metrics_unref(arg0)
}

// GlyphGeometry: the `PangoGlyphGeometry` structure contains width and
// positioning information for a single glyph.
type GlyphGeometry struct {
	native C.PangoGlyphGeometry
}

// WrapGlyphGeometry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphGeometry(ptr unsafe.Pointer) *GlyphGeometry {
	if ptr == nil {
		return nil
	}

	return (*GlyphGeometry)(ptr)
}

func marshalGlyphGeometry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphGeometry(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphGeometry) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Width gets the field inside the struct.
func (w *GlyphGeometry) Width() GlyphUnit {
	var ret GlyphUnit
	{
		var tmp int32
		tmp = int32(g.native.width)
		ret = GlyphUnit(tmp)
	}
	return ret
}

// XOffset gets the field inside the struct.
func (x *GlyphGeometry) XOffset() GlyphUnit {
	var ret GlyphUnit
	{
		var tmp int32
		tmp = int32(g.native.x_offset)
		ret = GlyphUnit(tmp)
	}
	return ret
}

// YOffset gets the field inside the struct.
func (y *GlyphGeometry) YOffset() GlyphUnit {
	var ret GlyphUnit
	{
		var tmp int32
		tmp = int32(g.native.y_offset)
		ret = GlyphUnit(tmp)
	}
	return ret
}

// GlyphInfo: a `PangoGlyphInfo` structure represents a single glyph with
// positioning information and visual attributes.
type GlyphInfo struct {
	native C.PangoGlyphInfo
}

// WrapGlyphInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphInfo(ptr unsafe.Pointer) *GlyphInfo {
	if ptr == nil {
		return nil
	}

	return (*GlyphInfo)(ptr)
}

func marshalGlyphInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Glyph gets the field inside the struct.
func (g *GlyphInfo) Glyph() Glyph {
	var ret Glyph
	{
		var tmp uint32
		tmp = uint32(g.native.glyph)
		ret = Glyph(tmp)
	}
	return ret
}

// Geometry gets the field inside the struct.
func (g *GlyphInfo) Geometry() GlyphGeometry {
	var ret GlyphGeometry
	{
		ret = WrapGlyphGeometry(g.native.geometry)
		runtime.SetFinalizer(&ret, func(v *GlyphGeometry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Attr gets the field inside the struct.
func (a *GlyphInfo) Attr() GlyphVisAttr {
	var ret GlyphVisAttr
	{
		ret = WrapGlyphVisAttr(g.native.attr)
		runtime.SetFinalizer(&ret, func(v *GlyphVisAttr) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// GlyphItem: a `PangoGlyphItem` is a pair of a `PangoItem` and the glyphs
// resulting from shaping the items text.
//
// As an example of the usage of `PangoGlyphItem`, the results of shaping text
// with `PangoLayout` is a list of `PangoLayoutLine`, each of which contains a
// list of `PangoGlyphItem`.
type GlyphItem struct {
	native C.PangoGlyphItem
}

// WrapGlyphItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItem(ptr unsafe.Pointer) *GlyphItem {
	if ptr == nil {
		return nil
	}

	return (*GlyphItem)(ptr)
}

func marshalGlyphItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItem(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Item gets the field inside the struct.
func (i *GlyphItem) Item() *Item {
	var ret *Item
	{
		ret = WrapItem(g.native.item)
		runtime.SetFinalizer(&ret, func(v **Item) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Glyphs gets the field inside the struct.
func (g *GlyphItem) Glyphs() *GlyphString {
	var ret *GlyphString
	{
		ret = WrapGlyphString(g.native.glyphs)
		runtime.SetFinalizer(&ret, func(v **GlyphString) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// ApplyAttrs splits a shaped item (`PangoGlyphItem`) into multiple items based
// on an attribute list.
//
// The idea is that if you have attributes that don't affect shaping, such as
// color or underline, to avoid affecting shaping, you filter them out
// ([method@Pango.AttrList.filter]), apply the shaping process and then reapply
// them to the result using this function.
//
// All attributes that start or end inside a cluster are applied to that
// cluster; for instance, if half of a cluster is underlined and the other-half
// strikethrough, then the cluster will end up with both underline and
// strikethrough attributes. In these cases, it may happen that
// @item->extra_attrs for some of the result items can have multiple attributes
// of the same type.
//
// This function takes ownership of @glyph_item; it will be reused as one of the
// elements in the list.
func (glyphItem *GlyphItem) ApplyAttrs(text string, list *AttrList) *glib.SList {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 *C.PangoAttrList

	arg0 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.PangoAttrList)(list.Native())

	ret := C.pango_glyph_item_apply_attrs(arg0, arg1, arg2)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(ret)
	}

	return ret0
}

// Copy: make a deep copy of an existing `PangoGlyphItem` structure.
func (orig *GlyphItem) Copy() *GlyphItem {
	var arg0 *C.PangoGlyphItem

	arg0 = (*C.PangoGlyphItem)(orig.Native())

	ret := C.pango_glyph_item_copy(arg0)

	var ret0 *GlyphItem

	{
		ret0 = WrapGlyphItem(ret)
	}

	return ret0
}

// Free frees a `PangoGlyphItem` and resources to which it points.
func (glyphItem *GlyphItem) Free() {
	var arg0 *C.PangoGlyphItem

	arg0 = (*C.PangoGlyphItem)(glyphItem.Native())

	C.pango_glyph_item_free(arg0)
}

// LogicalWidths: given a `PangoGlyphItem` and the corresponding text, determine
// the width corresponding to each character.
//
// When multiple characters compose a single cluster, the width of the entire
// cluster is divided equally among the characters.
//
// See also [method@Pango.GlyphString.get_logical_widths].
func (glyphItem *GlyphItem) LogicalWidths(text string, logicalWidths []int) {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 *C.int

	arg0 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	C.pango_glyph_item_get_logical_widths(arg0, arg1, arg2)
}

// LetterSpace adds spacing between the graphemes of @glyph_item to give the
// effect of typographic letter spacing.
func (glyphItem *GlyphItem) LetterSpace(text string, logAttrs []LogAttr, letterSpacing int) {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 *C.PangoLogAttr
	var arg3 C.int

	arg0 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	{

	}
	arg3 = C.int(letterSpacing)

	C.pango_glyph_item_letter_space(arg0, arg1, arg2, arg3)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item).
//
// This function is similar in function to pango_item_split() (and uses it
// internally.)
func (orig *GlyphItem) Split(text string, splitIndex int) *GlyphItem {
	var arg0 *C.PangoGlyphItem
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoGlyphItem)(orig.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(splitIndex)

	ret := C.pango_glyph_item_split(arg0, arg1, arg2)

	var ret0 *GlyphItem

	{
		ret0 = WrapGlyphItem(ret)
	}

	return ret0
}

// GlyphItemIter: a `PangoGlyphItemIter` is an iterator over the clusters in a
// `PangoGlyphItem`.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing @start_index and @start_char values. If @glyph_item
// is right-to-left (that is, if `glyph_item->item->analysis.level` is odd),
// then @start_glyph decreases as the iterator moves forward. Moreover, in
// right-to-left cases, @start_glyph is greater than @end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or pango_glyph_item_iter_init_end(), for
// forward and backward iteration respectively, and walked over using any
// desired mixture of pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
// “` PangoGlyphItemIter cluster_iter; gboolean have_cluster;
//
// for (have_cluster = pango_glyph_item_iter_init_start (&cluster_iter,
// glyph_item, text); have_cluster; have_cluster =
// pango_glyph_item_iter_next_cluster (&cluster_iter)) { ... } “`
//
// Note that @text is the start of the text for layout, which is then indexed by
// `glyph_item->item->offset` to get to the text of @glyph_item. The
// @start_index and @end_index values can directly index into @text. The
// @start_glyph, @end_glyph, @start_char, and @end_char values however are
// zero-based for the @glyph_item. For each cluster, the item pointed at by the
// start variables is included in the cluster while the one pointed at by end
// variables is not.
//
// None of the members of a `PangoGlyphItemIter` should be modified manually.
type GlyphItemIter struct {
	native C.PangoGlyphItemIter
}

// WrapGlyphItemIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItemIter(ptr unsafe.Pointer) *GlyphItemIter {
	if ptr == nil {
		return nil
	}

	return (*GlyphItemIter)(ptr)
}

func marshalGlyphItemIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItemIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphItemIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphItem gets the field inside the struct.
func (g *GlyphItemIter) GlyphItem() *GlyphItem {
	var ret *GlyphItem
	{
		ret = WrapGlyphItem(g.native.glyph_item)
		runtime.SetFinalizer(&ret, func(v **GlyphItem) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// Text gets the field inside the struct.
func (t *GlyphItemIter) Text() string {
	var ret string
	ret = C.GoString(g.native.text)
	return ret
}

// StartGlyph gets the field inside the struct.
func (s *GlyphItemIter) StartGlyph() int {
	var ret int
	ret = int(g.native.start_glyph)
	return ret
}

// StartIndex gets the field inside the struct.
func (s *GlyphItemIter) StartIndex() int {
	var ret int
	ret = int(g.native.start_index)
	return ret
}

// StartChar gets the field inside the struct.
func (s *GlyphItemIter) StartChar() int {
	var ret int
	ret = int(g.native.start_char)
	return ret
}

// EndGlyph gets the field inside the struct.
func (e *GlyphItemIter) EndGlyph() int {
	var ret int
	ret = int(g.native.end_glyph)
	return ret
}

// EndIndex gets the field inside the struct.
func (e *GlyphItemIter) EndIndex() int {
	var ret int
	ret = int(g.native.end_index)
	return ret
}

// EndChar gets the field inside the struct.
func (e *GlyphItemIter) EndChar() int {
	var ret int
	ret = int(g.native.end_char)
	return ret
}

// Copy: make a shallow copy of an existing `PangoGlyphItemIter` structure.
func (orig *GlyphItemIter) Copy() *GlyphItemIter {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(orig.Native())

	ret := C.pango_glyph_item_iter_copy(arg0)

	var ret0 *GlyphItemIter

	{
		ret0 = WrapGlyphItemIter(ret)
	}

	return ret0
}

// Free frees a `PangoGlyphItem`Iter.
func (iter *GlyphItemIter) Free() {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(iter.Native())

	C.pango_glyph_item_iter_free(arg0)
}

// InitEnd initializes a `PangoGlyphItemIter` structure to point to the last
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (iter *GlyphItemIter) InitEnd(glyphItem *GlyphItem, text string) bool {
	var arg0 *C.PangoGlyphItemIter
	var arg1 *C.PangoGlyphItem
	var arg2 *C.char

	arg0 = (*C.PangoGlyphItemIter)(iter.Native())
	arg1 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.pango_glyph_item_iter_init_end(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// InitStart initializes a `PangoGlyphItemIter` structure to point to the first
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (iter *GlyphItemIter) InitStart(glyphItem *GlyphItem, text string) bool {
	var arg0 *C.PangoGlyphItemIter
	var arg1 *C.PangoGlyphItem
	var arg2 *C.char

	arg0 = (*C.PangoGlyphItemIter)(iter.Native())
	arg1 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg2 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.pango_glyph_item_iter_init_start(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NextCluster advances the iterator to the next cluster in the glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (iter *GlyphItemIter) NextCluster() bool {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(iter.Native())

	ret := C.pango_glyph_item_iter_next_cluster(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PrevCluster moves the iterator to the preceding cluster in the glyph item.
// See `PangoGlyphItemIter` for details of cluster orders.
func (iter *GlyphItemIter) PrevCluster() bool {
	var arg0 *C.PangoGlyphItemIter

	arg0 = (*C.PangoGlyphItemIter)(iter.Native())

	ret := C.pango_glyph_item_iter_prev_cluster(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GlyphString: a `PangoGlyphString` is used to store strings of glyphs with
// geometry and visual attribute information.
//
// The storage for the glyph information is owned by the structure which
// simplifies memory management.
type GlyphString struct {
	native C.PangoGlyphString
}

// WrapGlyphString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphString(ptr unsafe.Pointer) *GlyphString {
	if ptr == nil {
		return nil
	}

	return (*GlyphString)(ptr)
}

func marshalGlyphString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphString(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphString) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// NewGlyphString constructs a struct GlyphString.
func NewGlyphString() *GlyphString {

	ret := C.pango_glyph_string_new()

	var ret0 *GlyphString

	{
		ret0 = WrapGlyphString(ret)
	}

	return ret0
}

// NumGlyphs gets the field inside the struct.
func (n *GlyphString) NumGlyphs() int {
	var ret int
	ret = int(g.native.num_glyphs)
	return ret
}

// Glyphs gets the field inside the struct.
func (g *GlyphString) Glyphs() []GlyphInfo {
	var ret []GlyphInfo
	{
		ret = make([]GlyphInfo, g.native.num_glyphs)
		for i := 0; i < uintptr(g.native.num_glyphs); i++ {
			src := (C.PangoGlyphInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret[i] = WrapGlyphInfo(src)
				runtime.SetFinalizer(&ret[i], func(v *GlyphInfo) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}
	return ret
}

// LogClusters gets the field inside the struct.
func (l *GlyphString) LogClusters() int {
	var ret int
	ret = int(g.native.log_clusters)
	return ret
}

// Copy: copy a glyph string and associated storage.
func (string *GlyphString) Copy() *GlyphString {
	var arg0 *C.PangoGlyphString

	arg0 = (*C.PangoGlyphString)(string.Native())

	ret := C.pango_glyph_string_copy(arg0)

	var ret0 *GlyphString

	{
		ret0 = WrapGlyphString(ret)
	}

	return ret0
}

// Extents: compute the logical and ink extents of a glyph string.
//
// See the documentation for [method@Pango.Font.get_glyph_extents] for details
// about the interpretation of the rectangles.
//
// Examples of logical (red) and ink (green) rects:
//
// ! (rects1.png) ! (rects2.png)
func (glyphs *GlyphString) Extents(font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoGlyphString
	var arg1 *C.PangoFont
	var arg2 *C.PangoRectangle // out
	var arg3 *C.PangoRectangle // out

	arg0 = (*C.PangoGlyphString)(glyphs.Native())
	arg1 = (*C.PangoFont)(font.Native())

	ret := C.pango_glyph_string_extents(arg0, arg1, &arg2, &arg3)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg3)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// ExtentsRange computes the extents of a sub-portion of a glyph string.
//
// The extents are relative to the start of the glyph string range (the origin
// of their coordinate system is at the start of the range, not at the start of
// the entire glyph string).
func (glyphs *GlyphString) ExtentsRange(start int, end int, font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoGlyphString
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.PangoFont
	var arg4 *C.PangoRectangle // out
	var arg5 *C.PangoRectangle // out

	arg0 = (*C.PangoGlyphString)(glyphs.Native())
	arg1 = C.int(start)
	arg2 = C.int(end)
	arg3 = (*C.PangoFont)(font.Native())

	ret := C.pango_glyph_string_extents_range(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg4)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg5)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// Free: free a glyph string and associated storage.
func (string *GlyphString) Free() {
	var arg0 *C.PangoGlyphString

	arg0 = (*C.PangoGlyphString)(string.Native())

	C.pango_glyph_string_free(arg0)
}

// LogicalWidths: given a `PangoGlyphString` and corresponding text, determine
// the width corresponding to each character.
//
// When multiple characters compose a single cluster, the width of the entire
// cluster is divided equally among the characters.
//
// See also [method@Pango.GlyphItem.get_logical_widths].
func (glyphs *GlyphString) LogicalWidths(text string, length int, embeddingLevel int, logicalWidths []int) {
	var arg0 *C.PangoGlyphString
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.int

	arg0 = (*C.PangoGlyphString)(glyphs.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = C.int(embeddingLevel)
	{

	}

	C.pango_glyph_string_get_logical_widths(arg0, arg1, arg2, arg3, arg4)
}

// Width computes the logical width of the glyph string.
//
// This can also be computed using [method@Pango.GlyphString.extents]. However,
// since this only computes the width, it's much faster. This is in fact only a
// convenience function that computes the sum of @geometry.width for each glyph
// in the @glyphs.
func (glyphs *GlyphString) Width() int {
	var arg0 *C.PangoGlyphString

	arg0 = (*C.PangoGlyphString)(glyphs.Native())

	ret := C.pango_glyph_string_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IndexToX converts from character position to x position.
//
// The X position is measured from the left edge of the run. Character positions
// are computed by dividing up each cluster into equal portions.
func (glyphs *GlyphString) IndexToX(text string, length int, analysis *Analysis, index_ int, trailing bool) int {
	var arg0 *C.PangoGlyphString
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.PangoAnalysis
	var arg4 C.int
	var arg5 C.gboolean
	var arg6 *C.int // out

	arg0 = (*C.PangoGlyphString)(glyphs.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoAnalysis)(analysis.Native())
	arg4 = C.int(index_)
	arg5 = gextras.Cbool(trailing)

	ret := C.pango_glyph_string_index_to_x(arg0, arg1, arg2, arg3, arg4, arg5, &arg6)

	var ret0 int

	ret0 = int(arg6)

	return ret0
}

// SetSize: resize a glyph string to the given length.
func (string *GlyphString) SetSize(newLen int) {
	var arg0 *C.PangoGlyphString
	var arg1 C.gint

	arg0 = (*C.PangoGlyphString)(string.Native())
	arg1 = C.gint(newLen)

	C.pango_glyph_string_set_size(arg0, arg1)
}

// XToIndex: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (glyphs *GlyphString) XToIndex(text string, length int, analysis *Analysis, xPos int) (index_ int, trailing int) {
	var arg0 *C.PangoGlyphString
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.PangoAnalysis
	var arg4 C.int
	var arg5 *C.int // out
	var arg6 *C.int // out

	arg0 = (*C.PangoGlyphString)(glyphs.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = (*C.PangoAnalysis)(analysis.Native())
	arg4 = C.int(xPos)

	ret := C.pango_glyph_string_x_to_index(arg0, arg1, arg2, arg3, arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int

	ret0 = int(arg5)

	ret1 = int(arg6)

	return ret0, ret1
}

// GlyphVisAttr: a `PangoGlyphVisAttr` structure communicates information
// between the shaping and rendering phases.
//
// Currently, it contains only cluster start information. yMore attributes may
// be added in the future.
type GlyphVisAttr struct {
	native C.PangoGlyphVisAttr
}

// WrapGlyphVisAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphVisAttr(ptr unsafe.Pointer) *GlyphVisAttr {
	if ptr == nil {
		return nil
	}

	return (*GlyphVisAttr)(ptr)
}

func marshalGlyphVisAttr(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphVisAttr(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *GlyphVisAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// IsClusterStart gets the field inside the struct.
func (i *GlyphVisAttr) IsClusterStart() uint {
	var ret uint
	ret = uint(g.native.is_cluster_start)
	return ret
}

// Item: the `PangoItem` structure stores information about a segment of text.
//
// You typically obtain `PangoItems` by itemizing a piece of text with
// [func@itemize].
type Item struct {
	native C.PangoItem
}

// WrapItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapItem(ptr unsafe.Pointer) *Item {
	if ptr == nil {
		return nil
	}

	return (*Item)(ptr)
}

func marshalItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapItem(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (i *Item) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// NewItem constructs a struct Item.
func NewItem() *Item {

	ret := C.pango_item_new()

	var ret0 *Item

	{
		ret0 = WrapItem(ret)
	}

	return ret0
}

// Offset gets the field inside the struct.
func (o *Item) Offset() int {
	var ret int
	ret = int(i.native.offset)
	return ret
}

// Length gets the field inside the struct.
func (l *Item) Length() int {
	var ret int
	ret = int(i.native.length)
	return ret
}

// NumChars gets the field inside the struct.
func (n *Item) NumChars() int {
	var ret int
	ret = int(i.native.num_chars)
	return ret
}

// Analysis gets the field inside the struct.
func (a *Item) Analysis() Analysis {
	var ret Analysis
	{
		ret = WrapAnalysis(i.native.analysis)
		runtime.SetFinalizer(&ret, func(v *Analysis) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// ApplyAttrs: add attributes to a `PangoItem`.
//
// The idea is that you have attributes that don't affect itemization, such as
// font features, so you filter them out using [method@Pango.AttrList.filter],
// itemize your text, then reapply the attributes to the resulting items using
// this function.
//
// The @iter should be positioned before the range of the item, and will be
// advanced past it. This function is meant to be called in a loop over the
// items resulting from itemization, while passing the iter to each call.
func (item *Item) ApplyAttrs(iter *AttrIterator) {
	var arg0 *C.PangoItem
	var arg1 *C.PangoAttrIterator

	arg0 = (*C.PangoItem)(item.Native())
	arg1 = (*C.PangoAttrIterator)(iter.Native())

	C.pango_item_apply_attrs(arg0, arg1)
}

// Copy: copy an existing `PangoItem` structure.
func (item *Item) Copy() *Item {
	var arg0 *C.PangoItem

	arg0 = (*C.PangoItem)(item.Native())

	ret := C.pango_item_copy(arg0)

	var ret0 *Item

	{
		ret0 = WrapItem(ret)
	}

	return ret0
}

// Free: free a `PangoItem` and all associated memory.
func (item *Item) Free() {
	var arg0 *C.PangoItem

	arg0 = (*C.PangoItem)(item.Native())

	C.pango_item_free(arg0)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (orig *Item) Split(splitIndex int, splitOffset int) *Item {
	var arg0 *C.PangoItem
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.PangoItem)(orig.Native())
	arg1 = C.int(splitIndex)
	arg2 = C.int(splitOffset)

	ret := C.pango_item_split(arg0, arg1, arg2)

	var ret0 *Item

	{
		ret0 = WrapItem(ret)
	}

	return ret0
}

// Language: the `PangoLanguage` structure is used to represent a language.
//
// `PangoLanguage` pointers can be efficiently copied and compared with each
// other.
type Language struct {
	native C.PangoLanguage
}

// WrapLanguage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLanguage(ptr unsafe.Pointer) *Language {
	if ptr == nil {
		return nil
	}

	return (*Language)(ptr)
}

func marshalLanguage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLanguage(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (l *Language) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// SampleString: get a string that is representative of the characters needed to
// render a particular language.
//
// The sample text may be a pangram, but is not necessarily. It is chosen to be
// demonstrative of normal text in the language, as well as exposing font
// feature requirements unique to the language. It is suitable for use as sample
// text in a font selection dialog.
//
// If @language is nil, the default language as found by
// [type_func@Pango.Language.get_default] is used.
//
// If Pango does not have a sample string for @language, the classic "The quick
// brown fox..." is returned. This can be detected by comparing the returned
// pointer value to that returned for (non-existent) language code "xx". That
// is, compare to:
//
// “` pango_language_get_sample_string (pango_language_from_string ("xx")) “`
func (language *Language) SampleString() string {
	var arg0 *C.PangoLanguage

	arg0 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_language_get_sample_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Scripts determines the scripts used to to write @language.
//
// If nothing is known about the language tag @language, or if @language is nil,
// then nil is returned. The list of scripts returned starts with the script
// that the language uses most and continues to the one it uses least.
//
// The value @num_script points at will be set to the number of scripts in the
// returned array (or zero if nil is returned).
//
// Most languages use only one script for writing, but there are some that use
// two (Latin and Cyrillic for example), and a few use three (Japanese for
// example). Applications should not make any assumptions on the maximum number
// of scripts returned though, except that it is positive if the return value is
// not nil, and it is a small number.
//
// The [method@Pango.Language.includes_script] function uses this function
// internally.
//
// Note: while the return value is declared as `PangoScript`, the returned
// values are from the `GUnicodeScript` enumeration, which may have more values.
// Callers need to handle unknown values.
func (language *Language) Scripts() (numScripts int, scripts []Script) {
	var arg0 *C.PangoLanguage
	var arg1 *C.int // out

	arg0 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_language_get_scripts(arg0, &arg1)

	var ret0 int
	var ret1 []Script

	ret0 = int(arg1)

	{
		ret1 = make([]Script, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.PangoScript)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = Script(src)
		}
	}

	return ret0, ret1
}

// IncludesScript determines if @script is one of the scripts used to write
// @language. The returned value is conservative; if nothing is known about the
// language tag @language, true will be returned, since, as far as Pango knows,
// @script might be used to write @language.
//
// This routine is used in Pango's itemization process when determining if a
// supplied language tag is relevant to a particular section of text. It
// probably is not useful for applications in most circumstances.
//
// This function uses [method@Pango.Language.get_scripts] internally.
func (language *Language) IncludesScript(script Script) bool {
	var arg0 *C.PangoLanguage
	var arg1 C.PangoScript

	arg0 = (*C.PangoLanguage)(language.Native())
	arg1 = (C.PangoScript)(script)

	ret := C.pango_language_includes_script(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Matches checks if a language tag matches one of the elements in a list of
// language ranges.
//
// A language tag is considered to match a range in the list if the range is
// '*', the range is exactly the tag, or the range is a prefix of the tag, and
// the character after it in the tag is '-'.
func (language *Language) Matches(rangeList string) bool {
	var arg0 *C.PangoLanguage
	var arg1 *C.char

	arg0 = (*C.PangoLanguage)(language.Native())
	arg1 = (*C.gchar)(C.CString(rangeList))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_language_matches(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// String gets the RFC-3066 format string representing the given language tag.
func (language *Language) String() string {
	var arg0 *C.PangoLanguage

	arg0 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_language_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// LayoutIter: a `PangoLayoutIter` can be used to iterate over the visual
// extents of a `PangoLayout`.
//
// To obtain a `PangoLayoutIter`, use [method@Pango.Layout.get_iter].
//
// The `PangoLayoutIter` structure is opaque, and has no user-visible fields.
type LayoutIter struct {
	native C.PangoLayoutIter
}

// WrapLayoutIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutIter(ptr unsafe.Pointer) *LayoutIter {
	if ptr == nil {
		return nil
	}

	return (*LayoutIter)(ptr)
}

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (l *LayoutIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// AtLastLine determines whether @iter is on the last line of the layout.
func (iter *LayoutIter) AtLastLine() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_at_last_line(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Copy copies a `PangoLayoutIter`.
func (iter *LayoutIter) Copy() *LayoutIter {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_copy(arg0)

	var ret0 *LayoutIter

	{
		ret0 = WrapLayoutIter(ret)
	}

	return ret0
}

// Free frees an iterator that's no longer in use.
func (iter *LayoutIter) Free() {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	C.pango_layout_iter_free(arg0)
}

// Baseline gets the Y position of the current line's baseline, in layout
// coordinates (origin at top left of the entire layout).
func (iter *LayoutIter) Baseline() int {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_baseline(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CharExtents gets the extents of the current character, in layout coordinates
// (origin is the top left of the entire layout). Only logical extents can
// sensibly be obtained for characters; ink extents make sense only down to the
// level of clusters.
func (iter *LayoutIter) CharExtents() Rectangle {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_char_extents(arg0, &arg1)

	var ret0 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ClusterExtents gets the extents of the current cluster, in layout coordinates
// (origin is the top left of the entire layout).
func (iter *LayoutIter) ClusterExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_cluster_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// Index gets the current byte index. Note that iterating forward by char moves
// in visual order, not logical order, so indexes may not be sequential. Also,
// the index may be equal to the length of the text in the layout, if on the nil
// run (see [method@Pango.LayoutIter.get_run]).
func (iter *LayoutIter) Index() int {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_index(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Layout gets the layout associated with a `PangoLayoutIter`.
func (iter *LayoutIter) Layout() Layout {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_layout(arg0)

	var ret0 Layout

	ret0 = WrapLayout(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutExtents obtains the extents of the `PangoLayout` being iterated over.
// @ink_rect or @logical_rect can be nil if you aren't interested in them.
func (iter *LayoutIter) LayoutExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_layout_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// Line gets the current line.
//
// Use the faster [method@Pango.LayoutIter.get_line_readonly] if you do not plan
// to modify the contents of the line (glyphs, glyph widths, etc.).
func (iter *LayoutIter) Line() *LayoutLine {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_line(arg0)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
		runtime.SetFinalizer(&ret0, func(v **LayoutLine) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LineExtents obtains the extents of the current line. @ink_rect or
// @logical_rect can be nil if you aren't interested in them. Extents are in
// layout coordinates (origin is the top-left corner of the entire
// `PangoLayout`). Thus the extents returned by this function will be the same
// width/height but not at the same x/y as the extents returned from
// [method@Pango.LayoutLine.get_extents].
func (iter *LayoutIter) LineExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_line_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// LineReadonly gets the current line for read-only access.
//
// This is a faster alternative to [method@Pango.LayoutIter.get_line], but the
// user is not expected to modify the contents of the line (glyphs, glyph
// widths, etc.).
func (iter *LayoutIter) LineReadonly() *LayoutLine {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_line_readonly(arg0)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
		runtime.SetFinalizer(&ret0, func(v **LayoutLine) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LineYrange divides the vertical space in the `PangoLayout` being iterated
// over between the lines in the layout, and returns the space belonging to the
// current line. A line's range includes the line's logical extents, plus half
// of the spacing above and below the line, if [method@Pango.Layout.set_spacing]
// has been called to set layout spacing. The Y positions are in layout
// coordinates (origin at top left of the entire layout).
//
// Note: Since 1.44, Pango uses line heights for placing lines, and there may be
// gaps between the ranges returned by this function.
func (iter *LayoutIter) LineYrange() (y0 int, y1 int) {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_line_yrange(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Run gets the current run. When iterating by run, at the end of each line,
// there's a position with a nil run, so this function can return nil. The nil
// run at the end of each line ensures that all lines have at least one run,
// even lines consisting of only a newline.
//
// Use the faster [method@Pango.LayoutIter.get_run_readonly] if you do not plan
// to modify the contents of the run (glyphs, glyph widths, etc.).
func (iter *LayoutIter) Run() *LayoutRun {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_run(arg0)

	var ret0 *LayoutRun

	{
		var tmp GlyphItem
		{
			tmp = WrapGlyphItem(ret)
			runtime.SetFinalizer(&tmp, func(v *GlyphItem) {
				C.free(unsafe.Pointer(v.Native()))
			})
		}
		ret0 = *LayoutRun(tmp)
	}

	return ret0
}

// RunExtents gets the extents of the current run in layout coordinates (origin
// is the top left of the entire layout).
func (iter *LayoutIter) RunExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutIter
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_run_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// RunReadonly gets the current run. When iterating by run, at the end of each
// line, there's a position with a nil run, so this function can return nil. The
// nil run at the end of each line ensures that all lines have at least one run,
// even lines consisting of only a newline.
//
// This is a faster alternative to [method@Pango.LayoutIter.get_run], but the
// user is not expected to modify the contents of the run (glyphs, glyph widths,
// etc.).
func (iter *LayoutIter) RunReadonly() *LayoutRun {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_get_run_readonly(arg0)

	var ret0 *LayoutRun

	{
		var tmp GlyphItem
		{
			tmp = WrapGlyphItem(ret)
			runtime.SetFinalizer(&tmp, func(v *GlyphItem) {
				C.free(unsafe.Pointer(v.Native()))
			})
		}
		ret0 = *LayoutRun(tmp)
	}

	return ret0
}

// NextChar moves @iter forward to the next character in visual order. If @iter
// was already at the end of the layout, returns false.
func (iter *LayoutIter) NextChar() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_next_char(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NextCluster moves @iter forward to the next cluster in visual order. If @iter
// was already at the end of the layout, returns false.
func (iter *LayoutIter) NextCluster() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_next_cluster(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NextLine moves @iter forward to the start of the next line. If @iter is
// already on the last line, returns false.
func (iter *LayoutIter) NextLine() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_next_line(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NextRun moves @iter forward to the next run in visual order. If @iter was
// already at the end of the layout, returns false.
func (iter *LayoutIter) NextRun() bool {
	var arg0 *C.PangoLayoutIter

	arg0 = (*C.PangoLayoutIter)(iter.Native())

	ret := C.pango_layout_iter_next_run(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LayoutLine: a `PangoLayoutLine` represents one of the lines resulting from
// laying out a paragraph via `PangoLayout`.
//
// `PangoLayoutLine` structures are obtained by calling
// [method@Pango.Layout.get_line] and are only valid until the text, attributes,
// or settings of the parent `PangoLayout` are modified.
type LayoutLine struct {
	native C.PangoLayoutLine
}

// WrapLayoutLine wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutLine(ptr unsafe.Pointer) *LayoutLine {
	if ptr == nil {
		return nil
	}

	return (*LayoutLine)(ptr)
}

func marshalLayoutLine(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutLine(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (l *LayoutLine) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// Layout gets the field inside the struct.
func (l *LayoutLine) Layout() Layout {
	var ret Layout
	ret = WrapLayout(externglib.Take(unsafe.Pointer(l.native.layout.Native())))
	return ret
}

// StartIndex gets the field inside the struct.
func (s *LayoutLine) StartIndex() int {
	var ret int
	ret = int(l.native.start_index)
	return ret
}

// Length gets the field inside the struct.
func (l *LayoutLine) Length() int {
	var ret int
	ret = int(l.native.length)
	return ret
}

// Runs gets the field inside the struct.
func (r *LayoutLine) Runs() *glib.SList {
	var ret *glib.SList
	{
		ret = glib.WrapSList(l.native.runs)
		runtime.SetFinalizer(&ret, func(v **glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}
	return ret
}

// IsParagraphStart gets the field inside the struct.
func (i *LayoutLine) IsParagraphStart() uint {
	var ret uint
	ret = uint(l.native.is_paragraph_start)
	return ret
}

// ResolvedDir gets the field inside the struct.
func (r *LayoutLine) ResolvedDir() uint {
	var ret uint
	ret = uint(l.native.resolved_dir)
	return ret
}

// Extents computes the logical and ink extents of a layout line. See
// [method@Pango.Font.get_glyph_extents] for details about the interpretation of
// the rectangles.
func (line *LayoutLine) Extents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutLine
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutLine)(line.Native())

	ret := C.pango_layout_line_get_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// Height computes the height of the line, i.e. the distance between this and
// the previous lines baseline.
func (line *LayoutLine) Height() int {
	var arg0 *C.PangoLayoutLine
	var arg1 *C.int // out

	arg0 = (*C.PangoLayoutLine)(line.Native())

	ret := C.pango_layout_line_get_height(arg0, &arg1)

	var ret0 int

	ret0 = int(arg1)

	return ret0
}

// PixelExtents computes the logical and ink extents of @layout_line in device
// units.
//
// This function just calls [method@Pango.LayoutLine.get_extents] followed by
// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect such
// that the rounded rectangles fully contain the unrounded one (that is, passes
// them as first argument to [func@extents_to_pixels]).
func (layoutLine *LayoutLine) PixelExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayoutLine
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayoutLine)(layoutLine.Native())

	ret := C.pango_layout_line_get_pixel_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// XRanges gets a list of visual ranges corresponding to a given logical range.
// This list is not necessarily minimal - there may be consecutive ranges which
// are adjacent. The ranges will be sorted from left to right. The ranges are
// with respect to the left edge of the entire layout, not with respect to the
// line.
func (line *LayoutLine) XRanges(startIndex int, endIndex int) (ranges []int, nRanges int) {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int
	var arg2 C.int
	var arg3 **C.int // out
	var arg4 *C.int  // out

	arg0 = (*C.PangoLayoutLine)(line.Native())
	arg1 = C.int(startIndex)
	arg2 = C.int(endIndex)

	ret := C.pango_layout_line_get_x_ranges(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 []int
	var ret1 int

	{
		ret0 = make([]int, arg4)
		for i := 0; i < uintptr(arg4); i++ {
			src := (*C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = int(src)
		}
	}

	ret1 = int(arg4)

	return ret0, ret1
}

// IndexToX converts an index within a line to a X position.
func (line *LayoutLine) IndexToX(index_ int, trailing bool) int {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int
	var arg2 C.gboolean
	var arg3 *C.int // out

	arg0 = (*C.PangoLayoutLine)(line.Native())
	arg1 = C.int(index_)
	arg2 = gextras.Cbool(trailing)

	ret := C.pango_layout_line_index_to_x(arg0, arg1, arg2, &arg3)

	var ret0 int

	ret0 = int(arg3)

	return ret0
}

// Ref: increase the reference count of a `PangoLayoutLine` by one.
func (line *LayoutLine) Ref() *LayoutLine {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(line.Native())

	ret := C.pango_layout_line_ref(arg0)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
	}

	return ret0
}

// Unref: decrease the reference count of a `PangoLayoutLine` by one. If the
// result is zero, the line and all associated memory will be freed.
func (line *LayoutLine) Unref() {
	var arg0 *C.PangoLayoutLine

	arg0 = (*C.PangoLayoutLine)(line.Native())

	C.pango_layout_line_unref(arg0)
}

// XToIndex converts from x offset to the byte index of the corresponding
// character within the text of the layout. If @x_pos is outside the line,
// @index_ and @trailing will point to the very first or very last position in
// the line. This determination is based on the resolved direction of the
// paragraph; for example, if the resolved direction is right-to-left, then an X
// position to the right of the line (after it) results in 0 being stored in
// @index_ and @trailing. An X position to the left of the line results in
// @index_ pointing to the (logical) last grapheme in the line and @trailing
// being set to the number of characters in that grapheme. The reverse is true
// for a left-to-right line.
func (line *LayoutLine) XToIndex(xPos int) (index_ int, trailing int, ok bool) {
	var arg0 *C.PangoLayoutLine
	var arg1 C.int
	var arg2 *C.int // out
	var arg3 *C.int // out

	arg0 = (*C.PangoLayoutLine)(line.Native())
	arg1 = C.int(xPos)

	ret := C.pango_layout_line_x_to_index(arg0, arg1, &arg2, &arg3)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg2)

	ret1 = int(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// LogAttr: the `PangoLogAttr` structure stores information about the attributes
// of a single character.
type LogAttr struct {
	native C.PangoLogAttr
}

// WrapLogAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLogAttr(ptr unsafe.Pointer) *LogAttr {
	if ptr == nil {
		return nil
	}

	return (*LogAttr)(ptr)
}

func marshalLogAttr(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLogAttr(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (l *LogAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// IsLineBreak gets the field inside the struct.
func (i *LogAttr) IsLineBreak() uint {
	var ret uint
	ret = uint(l.native.is_line_break)
	return ret
}

// IsMandatoryBreak gets the field inside the struct.
func (i *LogAttr) IsMandatoryBreak() uint {
	var ret uint
	ret = uint(l.native.is_mandatory_break)
	return ret
}

// IsCharBreak gets the field inside the struct.
func (i *LogAttr) IsCharBreak() uint {
	var ret uint
	ret = uint(l.native.is_char_break)
	return ret
}

// IsWhite gets the field inside the struct.
func (i *LogAttr) IsWhite() uint {
	var ret uint
	ret = uint(l.native.is_white)
	return ret
}

// IsCursorPosition gets the field inside the struct.
func (i *LogAttr) IsCursorPosition() uint {
	var ret uint
	ret = uint(l.native.is_cursor_position)
	return ret
}

// IsWordStart gets the field inside the struct.
func (i *LogAttr) IsWordStart() uint {
	var ret uint
	ret = uint(l.native.is_word_start)
	return ret
}

// IsWordEnd gets the field inside the struct.
func (i *LogAttr) IsWordEnd() uint {
	var ret uint
	ret = uint(l.native.is_word_end)
	return ret
}

// IsSentenceBoundary gets the field inside the struct.
func (i *LogAttr) IsSentenceBoundary() uint {
	var ret uint
	ret = uint(l.native.is_sentence_boundary)
	return ret
}

// IsSentenceStart gets the field inside the struct.
func (i *LogAttr) IsSentenceStart() uint {
	var ret uint
	ret = uint(l.native.is_sentence_start)
	return ret
}

// IsSentenceEnd gets the field inside the struct.
func (i *LogAttr) IsSentenceEnd() uint {
	var ret uint
	ret = uint(l.native.is_sentence_end)
	return ret
}

// BackspaceDeletesCharacter gets the field inside the struct.
func (b *LogAttr) BackspaceDeletesCharacter() uint {
	var ret uint
	ret = uint(l.native.backspace_deletes_character)
	return ret
}

// IsExpandableSpace gets the field inside the struct.
func (i *LogAttr) IsExpandableSpace() uint {
	var ret uint
	ret = uint(l.native.is_expandable_space)
	return ret
}

// IsWordBoundary gets the field inside the struct.
func (i *LogAttr) IsWordBoundary() uint {
	var ret uint
	ret = uint(l.native.is_word_boundary)
	return ret
}

// Matrix: a `PangoMatrix` specifies a transformation between user-space and
// device coordinates.
//
//
// The transformation is given by
//
// “` x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
// y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0; “`
type Matrix struct {
	native C.PangoMatrix
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// XX gets the field inside the struct.
func (x *Matrix) XX() float64 {
	var ret float64
	ret = float64(m.native.xx)
	return ret
}

// XY gets the field inside the struct.
func (x *Matrix) XY() float64 {
	var ret float64
	ret = float64(m.native.xy)
	return ret
}

// YX gets the field inside the struct.
func (y *Matrix) YX() float64 {
	var ret float64
	ret = float64(m.native.yx)
	return ret
}

// YY gets the field inside the struct.
func (y *Matrix) YY() float64 {
	var ret float64
	ret = float64(m.native.yy)
	return ret
}

// X0 gets the field inside the struct.
func (x *Matrix) X0() float64 {
	var ret float64
	ret = float64(m.native.x0)
	return ret
}

// Y0 gets the field inside the struct.
func (y *Matrix) Y0() float64 {
	var ret float64
	ret = float64(m.native.y0)
	return ret
}

// Concat changes the transformation represented by @matrix to be the
// transformation given by first applying transformation given by @new_matrix
// then applying the original transformation.
func (matrix *Matrix) Concat(newMatrix *Matrix) {
	var arg0 *C.PangoMatrix
	var arg1 *C.PangoMatrix

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = (*C.PangoMatrix)(newMatrix.Native())

	C.pango_matrix_concat(arg0, arg1)
}

// Copy copies a `PangoMatrix`.
func (matrix *Matrix) Copy() *Matrix {
	var arg0 *C.PangoMatrix

	arg0 = (*C.PangoMatrix)(matrix.Native())

	ret := C.pango_matrix_copy(arg0)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(ret)
	}

	return ret0
}

// Free: free a `PangoMatrix`.
func (matrix *Matrix) Free() {
	var arg0 *C.PangoMatrix

	arg0 = (*C.PangoMatrix)(matrix.Native())

	C.pango_matrix_free(arg0)
}

// FontScaleFactor returns the scale factor of a matrix on the height of the
// font.
//
// That is, the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to. If the scale in the X coordinate is needed as
// well, use [method@Pango.Matrix.get_font_scale_factors].
func (matrix *Matrix) FontScaleFactor() float64 {
	var arg0 *C.PangoMatrix

	arg0 = (*C.PangoMatrix)(matrix.Native())

	ret := C.pango_matrix_get_font_scale_factor(arg0)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// FontScaleFactors calculates the scale factor of a matrix on the width and
// height of the font.
//
// That is, @xscale is the scale factor in the direction of the X coordinate,
// and @yscale is the scale factor in the direction perpendicular to the vector
// that the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
func (matrix *Matrix) FontScaleFactors() (xscale float64, yscale float64) {
	var arg0 *C.PangoMatrix
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.PangoMatrix)(matrix.Native())

	ret := C.pango_matrix_get_font_scale_factors(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	return ret0, ret1
}

// Rotate changes the transformation represented by @matrix to be the
// transformation given by first rotating by @degrees degrees counter-clockwise
// then applying the original transformation.
func (matrix *Matrix) Rotate(degrees float64) {
	var arg0 *C.PangoMatrix
	var arg1 C.double

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = C.double(degrees)

	C.pango_matrix_rotate(arg0, arg1)
}

// Scale changes the transformation represented by @matrix to be the
// transformation given by first scaling by @sx in the X direction and @sy in
// the Y direction then applying the original transformation.
func (matrix *Matrix) Scale(scaleX float64, scaleY float64) {
	var arg0 *C.PangoMatrix
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = C.double(scaleX)
	arg2 = C.double(scaleY)

	C.pango_matrix_scale(arg0, arg1, arg2)
}

// TransformDistance transforms the distance vector (@dx,@dy) by @matrix.
//
// This is similar to [method@Pango.Matrix.transform_point], except that the
// translation components of the transformation are ignored. The calculation of
// the returned vector is as follows:
//
// “` dx2 = dx1 * xx + dy1 * xy; dy2 = dx1 * yx + dy1 * yy; “`
//
// Affine transformations are position invariant, so the same vector always
// transforms to the same vector. If (@x1,@y1) transforms to (@x2,@y2) then
// (@x1+@dx1,@y1+@dy1) will transform to (@x1+@dx2,@y1+@dy2) for all values of
// @x1 and @x2.
func (matrix *Matrix) TransformDistance(dx float64, dy float64) {
	var arg0 *C.PangoMatrix
	var arg1 *C.double
	var arg2 *C.double

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = (*C.double)(dx)
	arg2 = (*C.double)(dy)

	C.pango_matrix_transform_distance(arg0, arg1, arg2)
}

// TransformPixelRectangle: first transforms the @rect using @matrix, then
// calculates the bounding box of the transformed rectangle.
//
// This function is useful for example when you want to draw a rotated
// @PangoLayout to an image buffer, and want to know how large the image should
// be and how much you should shift the layout when rendering.
//
// For better accuracy, you should use [method@Pango.Matrix.transform_rectangle]
// on original rectangle in Pango units and convert to pixels afterward using
// [func@extents_to_pixels]'s first argument.
func (matrix *Matrix) TransformPixelRectangle(rect *Rectangle) {
	var arg0 *C.PangoMatrix
	var arg1 *C.PangoRectangle

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = (*C.PangoRectangle)(rect.Native())

	C.pango_matrix_transform_pixel_rectangle(arg0, arg1)
}

// TransformPoint transforms the point (@x, @y) by @matrix.
func (matrix *Matrix) TransformPoint(x float64, y float64) {
	var arg0 *C.PangoMatrix
	var arg1 *C.double
	var arg2 *C.double

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = (*C.double)(x)
	arg2 = (*C.double)(y)

	C.pango_matrix_transform_point(arg0, arg1, arg2)
}

// TransformRectangle: first transforms @rect using @matrix, then calculates the
// bounding box of the transformed rectangle.
//
// This function is useful for example when you want to draw a rotated
// @PangoLayout to an image buffer, and want to know how large the image should
// be and how much you should shift the layout when rendering.
//
// If you have a rectangle in device units (pixels), use
// [method@Pango.Matrix.transform_pixel_rectangle].
//
// If you have the rectangle in Pango units and want to convert to transformed
// pixel bounding box, it is more accurate to transform it first (using this
// function) and pass the result to pango_extents_to_pixels(), first argument,
// for an inclusive rounded rectangle. However, there are valid reasons that you
// may want to convert to pixels first and then transform, for example when the
// transformed coordinates may overflow in Pango units (large matrix translation
// for example).
func (matrix *Matrix) TransformRectangle(rect *Rectangle) {
	var arg0 *C.PangoMatrix
	var arg1 *C.PangoRectangle

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = (*C.PangoRectangle)(rect.Native())

	C.pango_matrix_transform_rectangle(arg0, arg1)
}

// Translate changes the transformation represented by @matrix to be the
// transformation given by first translating by (@tx, @ty) then applying the
// original transformation.
func (matrix *Matrix) Translate(tx float64, ty float64) {
	var arg0 *C.PangoMatrix
	var arg1 C.double
	var arg2 C.double

	arg0 = (*C.PangoMatrix)(matrix.Native())
	arg1 = C.double(tx)
	arg2 = C.double(ty)

	C.pango_matrix_translate(arg0, arg1, arg2)
}

// Rectangle: the `PangoRectangle` structure represents a rectangle.
//
// `PangoRectangle` is frequently used to represent the logical or ink extents
// of a single glyph or section of text. (See, for instance,
// [method@Pango.Font.get_glyph_extents].)
type Rectangle struct {
	native C.PangoRectangle
}

// WrapRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRectangle(ptr unsafe.Pointer) *Rectangle {
	if ptr == nil {
		return nil
	}

	return (*Rectangle)(ptr)
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRectangle(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// X gets the field inside the struct.
func (x *Rectangle) X() int {
	var ret int
	ret = int(r.native.x)
	return ret
}

// Y gets the field inside the struct.
func (y *Rectangle) Y() int {
	var ret int
	ret = int(r.native.y)
	return ret
}

// Width gets the field inside the struct.
func (w *Rectangle) Width() int {
	var ret int
	ret = int(r.native.width)
	return ret
}

// Height gets the field inside the struct.
func (h *Rectangle) Height() int {
	var ret int
	ret = int(r.native.height)
	return ret
}

// ScriptIter: a `PangoScriptIter` is used to iterate through a string and
// identify ranges in different scripts.
type ScriptIter struct {
	native C.PangoScriptIter
}

// WrapScriptIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScriptIter(ptr unsafe.Pointer) *ScriptIter {
	if ptr == nil {
		return nil
	}

	return (*ScriptIter)(ptr)
}

func marshalScriptIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScriptIter(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *ScriptIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewScriptIter constructs a struct ScriptIter.
func NewScriptIter(text string, length int) *ScriptIter {
	var arg1 *C.char
	var arg2 C.int

	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	ret := C.pango_script_iter_new(arg1, arg2)

	var ret0 *ScriptIter

	{
		ret0 = WrapScriptIter(ret)
	}

	return ret0
}

// Free frees a ScriptIter created with pango_script_iter_new().
func (iter *ScriptIter) Free() {
	var arg0 *C.PangoScriptIter

	arg0 = (*C.PangoScriptIter)(iter.Native())

	C.pango_script_iter_free(arg0)
}

// Range gets information about the range to which @iter currently points. The
// range is the set of locations p where *start <= p < *end. (That is, it
// doesn't include the character stored at *end)
//
// Note that while the type of the @script argument is declared as PangoScript,
// as of Pango 1.18, this function simply returns GUnicodeScript values. Callers
// must be prepared to handle unknown values.
func (iter *ScriptIter) Range() (start string, end string, script Script) {
	var arg0 *C.PangoScriptIter
	var arg1 **C.char       // out
	var arg2 **C.char       // out
	var arg3 *C.PangoScript // out

	arg0 = (*C.PangoScriptIter)(iter.Native())

	ret := C.pango_script_iter_get_range(arg0, &arg1, &arg2, &arg3)

	var ret0 string
	var ret1 string
	var ret2 *Script

	ret0 = C.GoString(arg1)
	C.free(unsafe.Pointer(arg1))

	ret1 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret2 = (*Script)(arg3)

	return ret0, ret1, ret2
}

// Next advances a ScriptIter to the next range. If @iter is already at the end,
// it is left unchanged and false is returned.
func (iter *ScriptIter) Next() bool {
	var arg0 *C.PangoScriptIter

	arg0 = (*C.PangoScriptIter)(iter.Native())

	ret := C.pango_script_iter_next(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TabArray: a `PangoTabArray` contains an array of tab stops.
//
// `PangoTabArray` can be used to set tab stops in a `PangoLayout`. Each tab
// stop has an alignment and a position.
type TabArray struct {
	native C.PangoTabArray
}

// WrapTabArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTabArray(ptr unsafe.Pointer) *TabArray {
	if ptr == nil {
		return nil
	}

	return (*TabArray)(ptr)
}

func marshalTabArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTabArray(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *TabArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// NewTabArray constructs a struct TabArray.
func NewTabArray(initialSize int, positionsInPixels bool) *TabArray {
	var arg1 C.gint
	var arg2 C.gboolean

	arg1 = C.gint(initialSize)
	arg2 = gextras.Cbool(positionsInPixels)

	ret := C.pango_tab_array_new(arg1, arg2)

	var ret0 *TabArray

	{
		ret0 = WrapTabArray(ret)
	}

	return ret0
}

// Copy copies a `PangoTabArray`.
func (src *TabArray) Copy() *TabArray {
	var arg0 *C.PangoTabArray

	arg0 = (*C.PangoTabArray)(src.Native())

	ret := C.pango_tab_array_copy(arg0)

	var ret0 *TabArray

	{
		ret0 = WrapTabArray(ret)
	}

	return ret0
}

// Free frees a tab array and associated resources.
func (tabArray *TabArray) Free() {
	var arg0 *C.PangoTabArray

	arg0 = (*C.PangoTabArray)(tabArray.Native())

	C.pango_tab_array_free(arg0)
}

// PositionsInPixels returns true if the tab positions are in pixels, false if
// they are in Pango units.
func (tabArray *TabArray) PositionsInPixels() bool {
	var arg0 *C.PangoTabArray

	arg0 = (*C.PangoTabArray)(tabArray.Native())

	ret := C.pango_tab_array_get_positions_in_pixels(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Size gets the number of tab stops in @tab_array.
func (tabArray *TabArray) Size() int {
	var arg0 *C.PangoTabArray

	arg0 = (*C.PangoTabArray)(tabArray.Native())

	ret := C.pango_tab_array_get_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Tab gets the alignment and position of a tab stop.
func (tabArray *TabArray) Tab(tabIndex int) (alignment TabAlign, location int) {
	var arg0 *C.PangoTabArray
	var arg1 C.gint
	var arg2 *C.PangoTabAlign // out
	var arg3 *C.gint          // out

	arg0 = (*C.PangoTabArray)(tabArray.Native())
	arg1 = C.gint(tabIndex)

	ret := C.pango_tab_array_get_tab(arg0, arg1, &arg2, &arg3)

	var ret0 *TabAlign
	var ret1 int

	ret0 = (*TabAlign)(arg2)

	ret1 = int(arg3)

	return ret0, ret1
}

// Tabs: if non-nil, @alignments and @locations are filled with allocated
// arrays.
//
// The arrays are of length [method@Pango.TabArray.get_size]. You must free the
// returned array.
func (tabArray *TabArray) Tabs() (alignments *TabAlign, locations []int) {
	var arg0 *C.PangoTabArray
	var arg1 **C.PangoTabAlign // out
	var arg2 **C.gint          // out

	arg0 = (*C.PangoTabArray)(tabArray.Native())

	ret := C.pango_tab_array_get_tabs(arg0, &arg1, &arg2)

	var ret0 **TabAlign
	var ret1 []int

	ret0 = (**TabAlign)(arg1)

	return ret0, ret1
}

// Resize resizes a tab array.
//
// You must subsequently initialize any tabs that were added as a result of
// growing the array.
func (tabArray *TabArray) Resize(newSize int) {
	var arg0 *C.PangoTabArray
	var arg1 C.gint

	arg0 = (*C.PangoTabArray)(tabArray.Native())
	arg1 = C.gint(newSize)

	C.pango_tab_array_resize(arg0, arg1)
}

// SetTab sets the alignment and location of a tab stop.
//
// @alignment must always be PANGO_TAB_LEFT in the current implementation.
func (tabArray *TabArray) SetTab(tabIndex int, alignment TabAlign, location int) {
	var arg0 *C.PangoTabArray
	var arg1 C.gint
	var arg2 C.PangoTabAlign
	var arg3 C.gint

	arg0 = (*C.PangoTabArray)(tabArray.Native())
	arg1 = C.gint(tabIndex)
	arg2 = (C.PangoTabAlign)(alignment)
	arg3 = C.gint(location)

	C.pango_tab_array_set_tab(arg0, arg1, arg2, arg3)
}

// Context: a `PangoContext` stores global information used to control the
// itemization process.
//
// The information stored by `PangoContext includes the fontmap used to look up
// fonts, and default values such as the default language, default gravity, or
// default font.
//
// To obtain a `PangoContext`, use [method@Pango.FontMap.create_context].
type Context interface {
	gextras.Objector

	// Changed forces a change in the context, which will cause any
	// `PangoLayout` using this context to re-layout.
	//
	// This function is only useful when implementing a new backend for Pango,
	// something applications won't do. Backends should call this function if
	// they have attached extra data to the context and such data is changed.
	Changed()
	// BaseDir retrieves the base direction for the context.
	//
	// See [method@Pango.Context.set_base_dir].
	BaseDir() Direction
	// BaseGravity retrieves the base gravity for the context.
	//
	// See [method@Pango.Context.set_base_gravity].
	BaseGravity() Gravity
	// FontDescription: retrieve the default font description for the context.
	FontDescription() *FontDescription
	// FontMap gets the `PangoFontMap` used to look up fonts for this context.
	FontMap() FontMap
	// Gravity retrieves the gravity for the context.
	//
	// This is similar to [method@Pango.Context.get_base_gravity], except for
	// when the base gravity is PANGO_GRAVITY_AUTO for which
	// [type_func@Pango.Gravity.get_for_matrix] is used to return the gravity
	// from the current context matrix.
	Gravity() Gravity
	// GravityHint retrieves the gravity hint for the context.
	//
	// See [method@Pango.Context.set_gravity_hint] for details.
	GravityHint() GravityHint
	// Language retrieves the global language tag for the context.
	Language() *Language
	// Matrix gets the transformation matrix that will be applied when rendering
	// with this context.
	//
	// See [method@Pango.Context.set_matrix].
	Matrix() *Matrix
	// Metrics: get overall metric information for a particular font
	// description.
	//
	// Since the metrics may be substantially different for different scripts, a
	// language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// The `PangoFontDescription` is interpreted in the same way as by
	// [func@itemize], and the family name may be a comma separated list of
	// names. If characters from multiple of these families would be used to
	// render the string, then the returned fonts would be a composite of the
	// metrics for the fonts loaded for the individual families.
	Metrics(desc *FontDescription, language *Language) *FontMetrics
	// RoundGlyphPositions returns whether font rendering with this context
	// should round glyph positions and widths.
	RoundGlyphPositions() bool
	// Serial returns the current serial number of @context.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new context is created and is increased whenever the context is changed
	// using any of the setter functions, or the `PangoFontMap` it uses to find
	// fonts has changed. The serial may wrap, but will never have the value 0.
	// Since it can wrap, never compare it with "less than", always use "not
	// equals".
	//
	// This can be used to automatically detect changes to a `PangoContext`, and
	// is only useful when implementing objects that need update when their
	// `PangoContext` changes, like `PangoLayout`.
	Serial() uint
	// ListFamilies: list all families for a context.
	ListFamilies() (families []FontFamily, nFamilies int)
	// LoadFont loads the font in one of the fontmaps in the context that is the
	// closest match for @desc.
	LoadFont(desc *FontDescription) Font
	// LoadFontset: load a set of fonts in the context that can be used to
	// render a font matching @desc.
	LoadFontset(desc *FontDescription, language *Language) Fontset
	// SetBaseDir sets the base direction for the context.
	//
	// The base direction is used in applying the Unicode bidirectional
	// algorithm; if the @direction is PANGO_DIRECTION_LTR or
	// PANGO_DIRECTION_RTL, then the value will be used as the paragraph
	// direction in the Unicode bidirectional algorithm. A value of
	// PANGO_DIRECTION_WEAK_LTR or PANGO_DIRECTION_WEAK_RTL is used only for
	// paragraphs that do not contain any strong characters themselves.
	SetBaseDir(direction Direction)
	// SetBaseGravity sets the base gravity for the context.
	//
	// The base gravity is used in laying vertical text out.
	SetBaseGravity(gravity Gravity)
	// SetFontDescription: set the default font description for the context
	SetFontDescription(desc *FontDescription)
	// SetFontMap sets the font map to be searched when fonts are looked-up in
	// this context.
	//
	// This is only for internal use by Pango backends, a `PangoContext`
	// obtained via one of the recommended methods should already have a
	// suitable font map.
	SetFontMap(fontMap FontMap)
	// SetGravityHint sets the gravity hint for the context.
	//
	// The gravity hint is used in laying vertical text out, and is only
	// relevant if gravity of the context as returned by
	// [method@Pango.Context.get_gravity] is set to PANGO_GRAVITY_EAST or
	// PANGO_GRAVITY_WEST.
	SetGravityHint(hint GravityHint)
	// SetLanguage sets the global language tag for the context.
	//
	// The default language for the locale of the running process can be found
	// using [type_func@Pango.Language.get_default].
	SetLanguage(language *Language)
	// SetMatrix sets the transformation matrix that will be applied when
	// rendering with this context.
	//
	// Note that reported metrics are in the user space coordinates before the
	// application of the matrix, not device-space coordinates after the
	// application of the matrix. So, they don't scale with the matrix, though
	// they may change slightly for different matrices, depending on how the
	// text is fit to the pixel grid.
	SetMatrix(matrix *Matrix)
	// SetRoundGlyphPositions sets whether font rendering with this context
	// should round glyph positions and widths to integral positions, in device
	// units.
	//
	// This is useful when the renderer can't handle subpixel positioning of
	// glyphs.
	//
	// The default value is to round glyph positions, to remain compatible with
	// previous Pango behavior.
	SetRoundGlyphPositions(roundPositions bool)
}

// context implements the Context interface.
type context struct {
	gextras.Objector
}

var _ Context = (*context)(nil)

// WrapContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapContext(obj *externglib.Object) Context {
	return Context{
		Objector: obj,
	}
}

func marshalContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContext(obj), nil
}

// NewContext constructs a class Context.
func NewContext() Context {

	ret := C.pango_context_new()

	var ret0 Context

	ret0 = WrapContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Changed forces a change in the context, which will cause any
// `PangoLayout` using this context to re-layout.
//
// This function is only useful when implementing a new backend for Pango,
// something applications won't do. Backends should call this function if
// they have attached extra data to the context and such data is changed.
func (context context) Changed() {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	C.pango_context_changed(arg0)
}

// BaseDir retrieves the base direction for the context.
//
// See [method@Pango.Context.set_base_dir].
func (context context) BaseDir() Direction {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_base_dir(arg0)

	var ret0 Direction

	ret0 = Direction(ret)

	return ret0
}

// BaseGravity retrieves the base gravity for the context.
//
// See [method@Pango.Context.set_base_gravity].
func (context context) BaseGravity() Gravity {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_base_gravity(arg0)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// FontDescription: retrieve the default font description for the context.
func (context context) FontDescription() *FontDescription {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_font_description(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
		runtime.SetFinalizer(&ret0, func(v **FontDescription) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FontMap gets the `PangoFontMap` used to look up fonts for this context.
func (context context) FontMap() FontMap {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_font_map(arg0)

	var ret0 FontMap

	ret0 = WrapFontMap(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Gravity retrieves the gravity for the context.
//
// This is similar to [method@Pango.Context.get_base_gravity], except for
// when the base gravity is PANGO_GRAVITY_AUTO for which
// [type_func@Pango.Gravity.get_for_matrix] is used to return the gravity
// from the current context matrix.
func (context context) Gravity() Gravity {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_gravity(arg0)

	var ret0 Gravity

	ret0 = Gravity(ret)

	return ret0
}

// GravityHint retrieves the gravity hint for the context.
//
// See [method@Pango.Context.set_gravity_hint] for details.
func (context context) GravityHint() GravityHint {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_gravity_hint(arg0)

	var ret0 GravityHint

	ret0 = GravityHint(ret)

	return ret0
}

// Language retrieves the global language tag for the context.
func (context context) Language() *Language {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_language(arg0)

	var ret0 *Language

	{
		ret0 = WrapLanguage(ret)
	}

	return ret0
}

// Matrix gets the transformation matrix that will be applied when rendering
// with this context.
//
// See [method@Pango.Context.set_matrix].
func (context context) Matrix() *Matrix {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_matrix(arg0)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(ret)
		runtime.SetFinalizer(&ret0, func(v **Matrix) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Metrics: get overall metric information for a particular font
// description.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be
// retrieved that correspond to the script(s) used by that language.
//
// The `PangoFontDescription` is interpreted in the same way as by
// [func@itemize], and the family name may be a comma separated list of
// names. If characters from multiple of these families would be used to
// render the string, then the returned fonts would be a composite of the
// metrics for the fonts loaded for the individual families.
func (context context) Metrics(desc *FontDescription, language *Language) *FontMetrics {
	var arg0 *C.PangoContext
	var arg1 *C.PangoFontDescription
	var arg2 *C.PangoLanguage

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())
	arg2 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_context_get_metrics(arg0, arg1, arg2)

	var ret0 *FontMetrics

	{
		ret0 = WrapFontMetrics(ret)
	}

	return ret0
}

// RoundGlyphPositions returns whether font rendering with this context
// should round glyph positions and widths.
func (context context) RoundGlyphPositions() bool {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_round_glyph_positions(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Serial returns the current serial number of @context.
//
// The serial number is initialized to an small number larger than zero when
// a new context is created and is increased whenever the context is changed
// using any of the setter functions, or the `PangoFontMap` it uses to find
// fonts has changed. The serial may wrap, but will never have the value 0.
// Since it can wrap, never compare it with "less than", always use "not
// equals".
//
// This can be used to automatically detect changes to a `PangoContext`, and
// is only useful when implementing objects that need update when their
// `PangoContext` changes, like `PangoLayout`.
func (context context) Serial() uint {
	var arg0 *C.PangoContext

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_get_serial(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ListFamilies: list all families for a context.
func (context context) ListFamilies() (families []FontFamily, nFamilies int) {
	var arg0 *C.PangoContext
	var arg1 ***C.PangoFontFamily // out
	var arg2 *C.int               // out

	arg0 = (*C.PangoContext)(context.Native())

	ret := C.pango_context_list_families(arg0, &arg1, &arg2)

	var ret0 []FontFamily
	var ret1 int

	{
		ret0 = make([]FontFamily, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (**C.PangoFontFamily)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = WrapFontFamily(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// LoadFont loads the font in one of the fontmaps in the context that is the
// closest match for @desc.
func (context context) LoadFont(desc *FontDescription) Font {
	var arg0 *C.PangoContext
	var arg1 *C.PangoFontDescription

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_context_load_font(arg0, arg1)

	var ret0 Font

	ret0 = WrapFont(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LoadFontset: load a set of fonts in the context that can be used to
// render a font matching @desc.
func (context context) LoadFontset(desc *FontDescription, language *Language) Fontset {
	var arg0 *C.PangoContext
	var arg1 *C.PangoFontDescription
	var arg2 *C.PangoLanguage

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())
	arg2 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_context_load_fontset(arg0, arg1, arg2)

	var ret0 Fontset

	ret0 = WrapFontset(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetBaseDir sets the base direction for the context.
//
// The base direction is used in applying the Unicode bidirectional
// algorithm; if the @direction is PANGO_DIRECTION_LTR or
// PANGO_DIRECTION_RTL, then the value will be used as the paragraph
// direction in the Unicode bidirectional algorithm. A value of
// PANGO_DIRECTION_WEAK_LTR or PANGO_DIRECTION_WEAK_RTL is used only for
// paragraphs that do not contain any strong characters themselves.
func (context context) SetBaseDir(direction Direction) {
	var arg0 *C.PangoContext
	var arg1 C.PangoDirection

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (C.PangoDirection)(direction)

	C.pango_context_set_base_dir(arg0, arg1)
}

// SetBaseGravity sets the base gravity for the context.
//
// The base gravity is used in laying vertical text out.
func (context context) SetBaseGravity(gravity Gravity) {
	var arg0 *C.PangoContext
	var arg1 C.PangoGravity

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (C.PangoGravity)(gravity)

	C.pango_context_set_base_gravity(arg0, arg1)
}

// SetFontDescription: set the default font description for the context
func (context context) SetFontDescription(desc *FontDescription) {
	var arg0 *C.PangoContext
	var arg1 *C.PangoFontDescription

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())

	C.pango_context_set_font_description(arg0, arg1)
}

// SetFontMap sets the font map to be searched when fonts are looked-up in
// this context.
//
// This is only for internal use by Pango backends, a `PangoContext`
// obtained via one of the recommended methods should already have a
// suitable font map.
func (context context) SetFontMap(fontMap FontMap) {
	var arg0 *C.PangoContext
	var arg1 *C.PangoFontMap

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoFontMap)(fontMap.Native())

	C.pango_context_set_font_map(arg0, arg1)
}

// SetGravityHint sets the gravity hint for the context.
//
// The gravity hint is used in laying vertical text out, and is only
// relevant if gravity of the context as returned by
// [method@Pango.Context.get_gravity] is set to PANGO_GRAVITY_EAST or
// PANGO_GRAVITY_WEST.
func (context context) SetGravityHint(hint GravityHint) {
	var arg0 *C.PangoContext
	var arg1 C.PangoGravityHint

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (C.PangoGravityHint)(hint)

	C.pango_context_set_gravity_hint(arg0, arg1)
}

// SetLanguage sets the global language tag for the context.
//
// The default language for the locale of the running process can be found
// using [type_func@Pango.Language.get_default].
func (context context) SetLanguage(language *Language) {
	var arg0 *C.PangoContext
	var arg1 *C.PangoLanguage

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoLanguage)(language.Native())

	C.pango_context_set_language(arg0, arg1)
}

// SetMatrix sets the transformation matrix that will be applied when
// rendering with this context.
//
// Note that reported metrics are in the user space coordinates before the
// application of the matrix, not device-space coordinates after the
// application of the matrix. So, they don't scale with the matrix, though
// they may change slightly for different matrices, depending on how the
// text is fit to the pixel grid.
func (context context) SetMatrix(matrix *Matrix) {
	var arg0 *C.PangoContext
	var arg1 *C.PangoMatrix

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = (*C.PangoMatrix)(matrix.Native())

	C.pango_context_set_matrix(arg0, arg1)
}

// SetRoundGlyphPositions sets whether font rendering with this context
// should round glyph positions and widths to integral positions, in device
// units.
//
// This is useful when the renderer can't handle subpixel positioning of
// glyphs.
//
// The default value is to round glyph positions, to remain compatible with
// previous Pango behavior.
func (context context) SetRoundGlyphPositions(roundPositions bool) {
	var arg0 *C.PangoContext
	var arg1 C.gboolean

	arg0 = (*C.PangoContext)(context.Native())
	arg1 = gextras.Cbool(roundPositions)

	C.pango_context_set_round_glyph_positions(arg0, arg1)
}

// Coverage: a Coverage structure is a map from Unicode characters to
// CoverageLevel values.
//
// It is often necessary in Pango to determine if a particular font can
// represent a particular character, and also how well it can represent that
// character. The Coverage is a data structure that is used to represent that
// information. It is an opaque structure with no public fields.
type Coverage interface {
	gextras.Objector

	// Copy: copy an existing `PangoCoverage`.
	Copy() Coverage
	// Get: determine whether a particular index is covered by @coverage.
	Get(index_ int) CoverageLevel
	// Max: set the coverage for each index in @coverage to be the max (better)
	// value of the current coverage for the index and the coverage for the
	// corresponding index in @other.
	Max(other Coverage)
	// Ref: increase the reference count on the `PangoCoverage` by one.
	Ref() Coverage
	// Set: modify a particular index within @coverage
	Set(index_ int, level CoverageLevel)
	// ToBytes: convert a `PangoCoverage` structure into a flat binary format.
	ToBytes() (bytes []byte, nBytes int)
	// Unref: decrease the reference count on the `PangoCoverage` by one.
	//
	// If the result is zero, free the coverage and all associated memory.
	Unref()
}

// coverage implements the Coverage interface.
type coverage struct {
	gextras.Objector
}

var _ Coverage = (*coverage)(nil)

// WrapCoverage wraps a GObject to the right type. It is
// primarily used internally.
func WrapCoverage(obj *externglib.Object) Coverage {
	return Coverage{
		Objector: obj,
	}
}

func marshalCoverage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCoverage(obj), nil
}

// NewCoverage constructs a class Coverage.
func NewCoverage() Coverage {

	ret := C.pango_coverage_new()

	var ret0 Coverage

	ret0 = WrapCoverage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Copy: copy an existing `PangoCoverage`.
func (coverage coverage) Copy() Coverage {
	var arg0 *C.PangoCoverage

	arg0 = (*C.PangoCoverage)(coverage.Native())

	ret := C.pango_coverage_copy(arg0)

	var ret0 Coverage

	ret0 = WrapCoverage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Get: determine whether a particular index is covered by @coverage.
func (coverage coverage) Get(index_ int) CoverageLevel {
	var arg0 *C.PangoCoverage
	var arg1 C.int

	arg0 = (*C.PangoCoverage)(coverage.Native())
	arg1 = C.int(index_)

	ret := C.pango_coverage_get(arg0, arg1)

	var ret0 CoverageLevel

	ret0 = CoverageLevel(ret)

	return ret0
}

// Max: set the coverage for each index in @coverage to be the max (better)
// value of the current coverage for the index and the coverage for the
// corresponding index in @other.
func (coverage coverage) Max(other Coverage) {
	var arg0 *C.PangoCoverage
	var arg1 *C.PangoCoverage

	arg0 = (*C.PangoCoverage)(coverage.Native())
	arg1 = (*C.PangoCoverage)(other.Native())

	C.pango_coverage_max(arg0, arg1)
}

// Ref: increase the reference count on the `PangoCoverage` by one.
func (coverage coverage) Ref() Coverage {
	var arg0 *C.PangoCoverage

	arg0 = (*C.PangoCoverage)(coverage.Native())

	ret := C.pango_coverage_ref(arg0)

	var ret0 Coverage

	ret0 = WrapCoverage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Set: modify a particular index within @coverage
func (coverage coverage) Set(index_ int, level CoverageLevel) {
	var arg0 *C.PangoCoverage
	var arg1 C.int
	var arg2 C.PangoCoverageLevel

	arg0 = (*C.PangoCoverage)(coverage.Native())
	arg1 = C.int(index_)
	arg2 = (C.PangoCoverageLevel)(level)

	C.pango_coverage_set(arg0, arg1, arg2)
}

// ToBytes: convert a `PangoCoverage` structure into a flat binary format.
func (coverage coverage) ToBytes() (bytes []byte, nBytes int) {
	var arg0 *C.PangoCoverage
	var arg1 **C.guchar // out
	var arg2 *C.int     // out

	arg0 = (*C.PangoCoverage)(coverage.Native())

	ret := C.pango_coverage_to_bytes(arg0, &arg1, &arg2)

	var ret0 []byte
	var ret1 int

	{
		ret0 = make([]byte, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// Unref: decrease the reference count on the `PangoCoverage` by one.
//
// If the result is zero, free the coverage and all associated memory.
func (coverage coverage) Unref() {
	var arg0 *C.PangoCoverage

	arg0 = (*C.PangoCoverage)(coverage.Native())

	C.pango_coverage_unref(arg0)
}

// Font: a `PangoFont` is used to represent a font in a
// rendering-system-independent manner.
type Font interface {
	gextras.Objector

	// Describe returns a description of the font, with font size set in points.
	//
	// Use [method@Pango.Font.describe_with_absolute_size] if you want the font
	// size in device units.
	Describe() *FontDescription
	// DescribeWithAbsoluteSize returns a description of the font, with absolute
	// font size set in device units.
	//
	// Use [method@Pango.Font.describe] if you want the font size in points.
	DescribeWithAbsoluteSize() *FontDescription
	// Coverage computes the coverage map for a given font and language tag.
	Coverage(language *Language) Coverage
	// Face gets the `PangoFontFace` to which @font belongs.
	Face() FontFace
	// FontMap gets the font map for which the font was created.
	//
	// Note that the font maintains a *weak* reference to the font map, so if
	// all references to font map are dropped, the font map will be finalized
	// even if there are fonts created with the font map that are still alive.
	// In that case this function will return nil.
	//
	// It is the responsibility of the user to ensure that the font map is kept
	// alive. In most uses this is not an issue as a Context holds a reference
	// to the font map.
	FontMap() FontMap
	// Metrics gets overall metric information for a font.
	//
	// Since the metrics may be substantially different for different scripts, a
	// language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// If @font is nil, this function gracefully sets some sane values in the
	// output variables and returns.
	Metrics(language *Language) *FontMetrics
	// HasChar returns whether the font provides a glyph for this character.
	//
	// Returns true if @font can render @wc
	HasChar(wc uint32) bool
}

// font implements the Font interface.
type font struct {
	gextras.Objector
}

var _ Font = (*font)(nil)

// WrapFont wraps a GObject to the right type. It is
// primarily used internally.
func WrapFont(obj *externglib.Object) Font {
	return Font{
		Objector: obj,
	}
}

func marshalFont(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFont(obj), nil
}

// Describe returns a description of the font, with font size set in points.
//
// Use [method@Pango.Font.describe_with_absolute_size] if you want the font
// size in device units.
func (font font) Describe() *FontDescription {
	var arg0 *C.PangoFont

	arg0 = (*C.PangoFont)(font.Native())

	ret := C.pango_font_describe(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// DescribeWithAbsoluteSize returns a description of the font, with absolute
// font size set in device units.
//
// Use [method@Pango.Font.describe] if you want the font size in points.
func (font font) DescribeWithAbsoluteSize() *FontDescription {
	var arg0 *C.PangoFont

	arg0 = (*C.PangoFont)(font.Native())

	ret := C.pango_font_describe_with_absolute_size(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// Coverage computes the coverage map for a given font and language tag.
func (font font) Coverage(language *Language) Coverage {
	var arg0 *C.PangoFont
	var arg1 *C.PangoLanguage

	arg0 = (*C.PangoFont)(font.Native())
	arg1 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_font_get_coverage(arg0, arg1)

	var ret0 Coverage

	ret0 = WrapCoverage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Face gets the `PangoFontFace` to which @font belongs.
func (font font) Face() FontFace {
	var arg0 *C.PangoFont

	arg0 = (*C.PangoFont)(font.Native())

	ret := C.pango_font_get_face(arg0)

	var ret0 FontFace

	ret0 = WrapFontFace(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// FontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if
// all references to font map are dropped, the font map will be finalized
// even if there are fonts created with the font map that are still alive.
// In that case this function will return nil.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a Context holds a reference
// to the font map.
func (font font) FontMap() FontMap {
	var arg0 *C.PangoFont

	arg0 = (*C.PangoFont)(font.Native())

	ret := C.pango_font_get_font_map(arg0)

	var ret0 FontMap

	ret0 = WrapFontMap(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Metrics gets overall metric information for a font.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be
// retrieved that correspond to the script(s) used by that language.
//
// If @font is nil, this function gracefully sets some sane values in the
// output variables and returns.
func (font font) Metrics(language *Language) *FontMetrics {
	var arg0 *C.PangoFont
	var arg1 *C.PangoLanguage

	arg0 = (*C.PangoFont)(font.Native())
	arg1 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_font_get_metrics(arg0, arg1)

	var ret0 *FontMetrics

	{
		ret0 = WrapFontMetrics(ret)
	}

	return ret0
}

// HasChar returns whether the font provides a glyph for this character.
//
// Returns true if @font can render @wc
func (font font) HasChar(wc uint32) bool {
	var arg0 *C.PangoFont
	var arg1 C.gunichar

	arg0 = (*C.PangoFont)(font.Native())
	arg1 = C.gunichar(wc)

	ret := C.pango_font_has_char(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FontFace: a `PangoFontFace` is used to represent a group of fonts with the
// same family, slant, weight, and width, but varying sizes.
type FontFace interface {
	gextras.Objector

	// Describe returns the family, style, variant, weight and stretch of a
	// `PangoFontFace`. The size field of the resulting font description will be
	// unset.
	Describe() *FontDescription
	// FaceName gets a name representing the style of this face among the
	// different faces in the `PangoFontFamily` for the face. The name is
	// suitable for displaying to users.
	FaceName() string
	// Family gets the `PangoFontFamily` that @face belongs to.
	Family() FontFamily
	// IsSynthesized returns whether a `PangoFontFace` is synthesized by the
	// underlying font rendering engine from another face, perhaps by shearing,
	// emboldening, or lightening it.
	IsSynthesized() bool
	// ListSizes: list the available sizes for a font.
	//
	// This is only applicable to bitmap fonts. For scalable fonts, stores nil
	// at the location pointed to by @sizes and 0 at the location pointed to by
	// @n_sizes. The sizes returned are in Pango units and are sorted in
	// ascending order.
	ListSizes() (sizes []int, nSizes int)
}

// fontFace implements the FontFace interface.
type fontFace struct {
	gextras.Objector
}

var _ FontFace = (*fontFace)(nil)

// WrapFontFace wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontFace(obj *externglib.Object) FontFace {
	return FontFace{
		Objector: obj,
	}
}

func marshalFontFace(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontFace(obj), nil
}

// Describe returns the family, style, variant, weight and stretch of a
// `PangoFontFace`. The size field of the resulting font description will be
// unset.
func (face fontFace) Describe() *FontDescription {
	var arg0 *C.PangoFontFace

	arg0 = (*C.PangoFontFace)(face.Native())

	ret := C.pango_font_face_describe(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
	}

	return ret0
}

// FaceName gets a name representing the style of this face among the
// different faces in the `PangoFontFamily` for the face. The name is
// suitable for displaying to users.
func (face fontFace) FaceName() string {
	var arg0 *C.PangoFontFace

	arg0 = (*C.PangoFontFace)(face.Native())

	ret := C.pango_font_face_get_face_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Family gets the `PangoFontFamily` that @face belongs to.
func (face fontFace) Family() FontFamily {
	var arg0 *C.PangoFontFace

	arg0 = (*C.PangoFontFace)(face.Native())

	ret := C.pango_font_face_get_family(arg0)

	var ret0 FontFamily

	ret0 = WrapFontFamily(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsSynthesized returns whether a `PangoFontFace` is synthesized by the
// underlying font rendering engine from another face, perhaps by shearing,
// emboldening, or lightening it.
func (face fontFace) IsSynthesized() bool {
	var arg0 *C.PangoFontFace

	arg0 = (*C.PangoFontFace)(face.Native())

	ret := C.pango_font_face_is_synthesized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListSizes: list the available sizes for a font.
//
// This is only applicable to bitmap fonts. For scalable fonts, stores nil
// at the location pointed to by @sizes and 0 at the location pointed to by
// @n_sizes. The sizes returned are in Pango units and are sorted in
// ascending order.
func (face fontFace) ListSizes() (sizes []int, nSizes int) {
	var arg0 *C.PangoFontFace
	var arg1 **C.int // out
	var arg2 *C.int  // out

	arg0 = (*C.PangoFontFace)(face.Native())

	ret := C.pango_font_face_list_sizes(arg0, &arg1, &arg2)

	var ret0 []int
	var ret1 int

	{
		ret0 = make([]int, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = int(src)
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// FontFamily: a `PangoFontFamily` is used to represent a family of related font
// faces.
//
// The font faces in a family share a common design, but differ in slant,
// weight, width or other aspects.
type FontFamily interface {
	gextras.Objector

	// Face gets the `PangoFontFace` of @family with the given name.
	Face(name string) FontFace
	// Name gets the name of the family.
	//
	// The name is unique among all fonts for the font backend and can be used
	// in a `PangoFontDescription` to specify that a face from this family is
	// desired.
	Name() string
	// IsMonospace: a monospace font is a font designed for text display where
	// the the characters form a regular grid.
	//
	// For Western languages this would mean that the advance width of all
	// characters are the same, but this categorization also includes Asian
	// fonts which include double-width characters: characters that occupy two
	// grid cells. g_unichar_iswide() returns a result that indicates whether a
	// character is typically double-width in a monospace font.
	//
	// The best way to find out the grid-cell size is to call
	// [method@Pango.FontMetrics.get_approximate_digit_width], since the results
	// of [method@Pango.FontMetrics.get_approximate_char_width] may be affected
	// by double-width characters.
	IsMonospace() bool
	// IsVariable: a variable font is a font which has axes that can be modified
	// to produce different faces.
	IsVariable() bool
	// ListFaces lists the different font faces that make up @family.
	//
	// The faces in a family share a common design, but differ in slant, weight,
	// width and other aspects.
	ListFaces() (faces []FontFace, nFaces int)
}

// fontFamily implements the FontFamily interface.
type fontFamily struct {
	gextras.Objector
}

var _ FontFamily = (*fontFamily)(nil)

// WrapFontFamily wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontFamily(obj *externglib.Object) FontFamily {
	return FontFamily{
		Objector: obj,
	}
}

func marshalFontFamily(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontFamily(obj), nil
}

// Face gets the `PangoFontFace` of @family with the given name.
func (family fontFamily) Face(name string) FontFace {
	var arg0 *C.PangoFontFamily
	var arg1 *C.char

	arg0 = (*C.PangoFontFamily)(family.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_font_family_get_face(arg0, arg1)

	var ret0 FontFace

	ret0 = WrapFontFace(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Name gets the name of the family.
//
// The name is unique among all fonts for the font backend and can be used
// in a `PangoFontDescription` to specify that a face from this family is
// desired.
func (family fontFamily) Name() string {
	var arg0 *C.PangoFontFamily

	arg0 = (*C.PangoFontFamily)(family.Native())

	ret := C.pango_font_family_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsMonospace: a monospace font is a font designed for text display where
// the the characters form a regular grid.
//
// For Western languages this would mean that the advance width of all
// characters are the same, but this categorization also includes Asian
// fonts which include double-width characters: characters that occupy two
// grid cells. g_unichar_iswide() returns a result that indicates whether a
// character is typically double-width in a monospace font.
//
// The best way to find out the grid-cell size is to call
// [method@Pango.FontMetrics.get_approximate_digit_width], since the results
// of [method@Pango.FontMetrics.get_approximate_char_width] may be affected
// by double-width characters.
func (family fontFamily) IsMonospace() bool {
	var arg0 *C.PangoFontFamily

	arg0 = (*C.PangoFontFamily)(family.Native())

	ret := C.pango_font_family_is_monospace(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsVariable: a variable font is a font which has axes that can be modified
// to produce different faces.
func (family fontFamily) IsVariable() bool {
	var arg0 *C.PangoFontFamily

	arg0 = (*C.PangoFontFamily)(family.Native())

	ret := C.pango_font_family_is_variable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListFaces lists the different font faces that make up @family.
//
// The faces in a family share a common design, but differ in slant, weight,
// width and other aspects.
func (family fontFamily) ListFaces() (faces []FontFace, nFaces int) {
	var arg0 *C.PangoFontFamily
	var arg1 ***C.PangoFontFace // out
	var arg2 *C.int             // out

	arg0 = (*C.PangoFontFamily)(family.Native())

	ret := C.pango_font_family_list_faces(arg0, &arg1, &arg2)

	var ret0 []FontFace
	var ret1 int

	{
		ret0 = make([]FontFace, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (**C.PangoFontFace)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = WrapFontFace(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// FontMap: a `PangoFontMap` represents the set of fonts available for a
// particular rendering system.
//
// This is a virtual object with implementations being specific to particular
// rendering systems.
type FontMap interface {
	gextras.Objector

	// Changed forces a change in the context, which will cause any
	// `PangoContext` using this fontmap to change.
	//
	// This function is only useful when implementing a new backend for Pango,
	// something applications won't do. Backends should call this function if
	// they have attached extra data to the context and such data is changed.
	Changed()
	// CreateContext creates a `PangoContext` connected to @fontmap.
	//
	// This is equivalent to [ctor@Pango.Context.new] followed by
	// [method@Pango.Context.set_font_map].
	//
	// If you are using Pango as part of a higher-level system, that system may
	// have it's own way of create a `PangoContext`. For instance, the GTK
	// toolkit has, among others, gtk_widget_get_pango_context(). Use those
	// instead.
	CreateContext() Context
	// Family gets a font family by name.
	Family(name string) FontFamily
	// Serial returns the current serial number of @fontmap.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new fontmap is created and is increased whenever the fontmap is
	// changed. It may wrap, but will never have the value 0. Since it can wrap,
	// never compare it with "less than", always use "not equals".
	//
	// The fontmap can only be changed using backend-specific API, like changing
	// fontmap resolution.
	//
	// This can be used to automatically detect changes to a `PangoFontMap`,
	// like in `PangoContext`.
	Serial() uint
	// ListFamilies: list all families for a fontmap.
	ListFamilies() (families []FontFamily, nFamilies int)
	// LoadFont: load the font in the fontmap that is the closest match for
	// @desc.
	LoadFont(context Context, desc *FontDescription) Font
	// LoadFontset: load a set of fonts in the fontmap that can be used to
	// render a font matching @desc.
	LoadFontset(context Context, desc *FontDescription, language *Language) Fontset
}

// fontMap implements the FontMap interface.
type fontMap struct {
	gextras.Objector
}

var _ FontMap = (*fontMap)(nil)

// WrapFontMap wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontMap(obj *externglib.Object) FontMap {
	return FontMap{
		Objector: obj,
	}
}

func marshalFontMap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontMap(obj), nil
}

// Changed forces a change in the context, which will cause any
// `PangoContext` using this fontmap to change.
//
// This function is only useful when implementing a new backend for Pango,
// something applications won't do. Backends should call this function if
// they have attached extra data to the context and such data is changed.
func (fontmap fontMap) Changed() {
	var arg0 *C.PangoFontMap

	arg0 = (*C.PangoFontMap)(fontmap.Native())

	C.pango_font_map_changed(arg0)
}

// CreateContext creates a `PangoContext` connected to @fontmap.
//
// This is equivalent to [ctor@Pango.Context.new] followed by
// [method@Pango.Context.set_font_map].
//
// If you are using Pango as part of a higher-level system, that system may
// have it's own way of create a `PangoContext`. For instance, the GTK
// toolkit has, among others, gtk_widget_get_pango_context(). Use those
// instead.
func (fontmap fontMap) CreateContext() Context {
	var arg0 *C.PangoFontMap

	arg0 = (*C.PangoFontMap)(fontmap.Native())

	ret := C.pango_font_map_create_context(arg0)

	var ret0 Context

	ret0 = WrapContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Family gets a font family by name.
func (fontmap fontMap) Family(name string) FontFamily {
	var arg0 *C.PangoFontMap
	var arg1 *C.char

	arg0 = (*C.PangoFontMap)(fontmap.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.pango_font_map_get_family(arg0, arg1)

	var ret0 FontFamily

	ret0 = WrapFontFamily(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Serial returns the current serial number of @fontmap.
//
// The serial number is initialized to an small number larger than zero when
// a new fontmap is created and is increased whenever the fontmap is
// changed. It may wrap, but will never have the value 0. Since it can wrap,
// never compare it with "less than", always use "not equals".
//
// The fontmap can only be changed using backend-specific API, like changing
// fontmap resolution.
//
// This can be used to automatically detect changes to a `PangoFontMap`,
// like in `PangoContext`.
func (fontmap fontMap) Serial() uint {
	var arg0 *C.PangoFontMap

	arg0 = (*C.PangoFontMap)(fontmap.Native())

	ret := C.pango_font_map_get_serial(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ListFamilies: list all families for a fontmap.
func (fontmap fontMap) ListFamilies() (families []FontFamily, nFamilies int) {
	var arg0 *C.PangoFontMap
	var arg1 ***C.PangoFontFamily // out
	var arg2 *C.int               // out

	arg0 = (*C.PangoFontMap)(fontmap.Native())

	ret := C.pango_font_map_list_families(arg0, &arg1, &arg2)

	var ret0 []FontFamily
	var ret1 int

	{
		ret0 = make([]FontFamily, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (**C.PangoFontFamily)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret0[i] = WrapFontFamily(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// LoadFont: load the font in the fontmap that is the closest match for
// @desc.
func (fontmap fontMap) LoadFont(context Context, desc *FontDescription) Font {
	var arg0 *C.PangoFontMap
	var arg1 *C.PangoContext
	var arg2 *C.PangoFontDescription

	arg0 = (*C.PangoFontMap)(fontmap.Native())
	arg1 = (*C.PangoContext)(context.Native())
	arg2 = (*C.PangoFontDescription)(desc.Native())

	ret := C.pango_font_map_load_font(arg0, arg1, arg2)

	var ret0 Font

	ret0 = WrapFont(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LoadFontset: load a set of fonts in the fontmap that can be used to
// render a font matching @desc.
func (fontmap fontMap) LoadFontset(context Context, desc *FontDescription, language *Language) Fontset {
	var arg0 *C.PangoFontMap
	var arg1 *C.PangoContext
	var arg2 *C.PangoFontDescription
	var arg3 *C.PangoLanguage

	arg0 = (*C.PangoFontMap)(fontmap.Native())
	arg1 = (*C.PangoContext)(context.Native())
	arg2 = (*C.PangoFontDescription)(desc.Native())
	arg3 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_font_map_load_fontset(arg0, arg1, arg2, arg3)

	var ret0 Fontset

	ret0 = WrapFontset(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Fontset: a `PangoFontset` represents a set of `PangoFont` to use when
// rendering text.
//
// A `PAngoFontset` is the result of resolving a `PangoFontDescription` against
// a particular `PangoContext`. It has operations for finding the component font
// for a particular Unicode character, and for finding a composite set of
// metrics for the entire fontset.
type Fontset interface {
	gextras.Objector

	// Foreach iterates through all the fonts in a fontset, calling @func for
	// each one.
	//
	// If @func returns true, that stops the iteration.
	Foreach(_func FontsetForeachFunc)
	// Font returns the font in the fontset that contains the best glyph for a
	// Unicode character.
	Font(wc uint) Font
	// Metrics: get overall metric information for the fonts in the fontset.
	Metrics() *FontMetrics
}

// fontset implements the Fontset interface.
type fontset struct {
	gextras.Objector
}

var _ Fontset = (*fontset)(nil)

// WrapFontset wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontset(obj *externglib.Object) Fontset {
	return Fontset{
		Objector: obj,
	}
}

func marshalFontset(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontset(obj), nil
}

// Foreach iterates through all the fonts in a fontset, calling @func for
// each one.
//
// If @func returns true, that stops the iteration.
func (fontset fontset) Foreach(_func FontsetForeachFunc) {
	var arg0 *C.PangoFontset
	var arg1 C.PangoFontsetForeachFunc
	var arg2 C.gpointer

	arg0 = (*C.PangoFontset)(fontset.Native())
	arg1 = (*[0]byte)(C.gotk4_FontsetForeachFunc)
	arg2 = C.gpointer(box.Assign(_func))

	C.pango_fontset_foreach(arg0, arg1, arg2)
}

// Font returns the font in the fontset that contains the best glyph for a
// Unicode character.
func (fontset fontset) Font(wc uint) Font {
	var arg0 *C.PangoFontset
	var arg1 C.guint

	arg0 = (*C.PangoFontset)(fontset.Native())
	arg1 = C.guint(wc)

	ret := C.pango_fontset_get_font(arg0, arg1)

	var ret0 Font

	ret0 = WrapFont(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Metrics: get overall metric information for the fonts in the fontset.
func (fontset fontset) Metrics() *FontMetrics {
	var arg0 *C.PangoFontset

	arg0 = (*C.PangoFontset)(fontset.Native())

	ret := C.pango_fontset_get_metrics(arg0)

	var ret0 *FontMetrics

	{
		ret0 = WrapFontMetrics(ret)
	}

	return ret0
}

// FontsetSimple: `PangoFontsetSimple` is a implementation of the abstract
// `PangoFontset` base class as an array of fonts.
//
// When creating a `PangoFontsetSimple`, you have to provide the array of fonts
// that make up the fontset.
type FontsetSimple interface {
	Fontset

	// Append adds a font to the fontset.
	Append(font Font)
	// Size returns the number of fonts in the fontset.
	Size() int
}

// fontsetSimple implements the FontsetSimple interface.
type fontsetSimple struct {
	Fontset
}

var _ FontsetSimple = (*fontsetSimple)(nil)

// WrapFontsetSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontsetSimple(obj *externglib.Object) FontsetSimple {
	return FontsetSimple{
		Fontset: WrapFontset(obj),
	}
}

func marshalFontsetSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontsetSimple(obj), nil
}

// NewFontsetSimple constructs a class FontsetSimple.
func NewFontsetSimple(language *Language) FontsetSimple {
	var arg1 *C.PangoLanguage

	arg1 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_fontset_simple_new(arg1)

	var ret0 FontsetSimple

	ret0 = WrapFontsetSimple(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append adds a font to the fontset.
func (fontset fontsetSimple) Append(font Font) {
	var arg0 *C.PangoFontsetSimple
	var arg1 *C.PangoFont

	arg0 = (*C.PangoFontsetSimple)(fontset.Native())
	arg1 = (*C.PangoFont)(font.Native())

	C.pango_fontset_simple_append(arg0, arg1)
}

// Size returns the number of fonts in the fontset.
func (fontset fontsetSimple) Size() int {
	var arg0 *C.PangoFontsetSimple

	arg0 = (*C.PangoFontsetSimple)(fontset.Native())

	ret := C.pango_fontset_simple_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Layout: a `PangoLayout` structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. `PangoLayout`
// provides a high-level driver for formatting entire paragraphs of text at
// once. This includes paragraph-level functionality such as line breaking,
// justification, alignment and ellipsization.
//
// A `PangoLayout is initialized with a `PangoContext`, UTF-8 string and set of
// attributes for that string. Once that is done, the set of formatted lines can
// be extracted from the object, the layout can be rendered, and conversion
// between logical character positions within the layout's text, and the
// physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a `PangoLayout`.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// !Pango Layout Parameters (layout.png)
//
// It is possible, as well, to ignore the 2-D setup, and simply treat the
// results of a `PangoLayout` as a list of lines.
type Layout interface {
	gextras.Objector

	// ContextChanged forces recomputation of any state in the `PangoLayout`
	// that might depend on the layout's context.
	//
	// This function should be called if you make changes to the context
	// subsequent to creating the layout.
	ContextChanged()
	// Copy creates a deep copy-by-value of the layout.
	//
	// The attribute list, tab array, and text from the original layout are all
	// copied by value.
	Copy() Layout
	// Alignment gets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	Alignment() Alignment
	// Attributes gets the attribute list for the layout, if any.
	Attributes() *AttrList
	// AutoDir gets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// See [method@Pango.Layout.set_auto_dir].
	AutoDir() bool
	// Baseline gets the Y position of baseline of the first line in @layout.
	Baseline() int
	// CharacterCount returns the number of Unicode characters in the the text
	// of @layout.
	CharacterCount() int
	// Context retrieves the `PangoContext` used for this layout.
	Context() Context
	// CursorPos: given an index within a layout, determines the positions that
	// of the strong and weak cursors if the insertion point is at that index.
	//
	// The position of each cursor is stored as a zero-width rectangle. The
	// strong cursor location is the location where characters of the
	// directionality equal to the base direction of the layout are inserted.
	// The weak cursor location is the location where characters of the
	// directionality opposite to the base direction of the layout are inserted.
	CursorPos(index_ int) (strongPos Rectangle, weakPos Rectangle)
	// Direction gets the text direction at the given character position in
	// @layout.
	Direction(index int) Direction
	// Ellipsize gets the type of ellipsization being performed for @layout.
	//
	// See [method@Pango.Layout.set_ellipsize].
	//
	// Use [method@Pango.Layout.is_ellipsized] to query whether any paragraphs
	// were actually ellipsized.
	Ellipsize() EllipsizeMode
	// Extents computes the logical and ink extents of @layout.
	//
	// Logical extents are usually what you want for positioning things. Note
	// that both extents may have non-zero x and y. You may want to use those to
	// offset where you render the layout. Not doing that is a very typical bug
	// that shows up as right-to-left layouts not being correctly positioned in
	// a layout with a set width.
	//
	// The extents are given in layout coordinates and in Pango units; layout
	// coordinates begin at the top left corner of the layout.
	Extents() (inkRect Rectangle, logicalRect Rectangle)
	// FontDescription gets the font description for the layout, if any.
	FontDescription() *FontDescription
	// Height gets the height of layout used for ellipsization.
	//
	// See [method@Pango.Layout.set_height] for details.
	Height() int
	// Indent gets the paragraph indent width in Pango units.
	//
	// A negative value indicates a hanging indentation.
	Indent() int
	// Iter returns an iterator to iterate over the visual extents of the
	// layout.
	Iter() *LayoutIter
	// Justify gets whether each complete line should be stretched to fill the
	// entire width of the layout.
	Justify() bool
	// Line retrieves a particular line from a `PangoLayout`.
	//
	// Use the faster [method@Pango.Layout.get_line_readonly] if you do not plan
	// to modify the contents of the line (glyphs, glyph widths, etc.).
	Line(line int) *LayoutLine
	// LineCount retrieves the count of lines for the @layout.
	LineCount() int
	// LineReadonly retrieves a particular line from a `PangoLayout`.
	//
	// This is a faster alternative to [method@Pango.Layout.get_line], but the
	// user is not expected to modify the contents of the line (glyphs, glyph
	// widths, etc.).
	LineReadonly(line int) *LayoutLine
	// LineSpacing gets the line spacing factor of @layout.
	//
	// See [method@Pango.Layout.set_line_spacing].
	LineSpacing() float32
	// Lines returns the lines of the @layout as a list.
	//
	// Use the faster [method@Pango.Layout.get_lines_readonly] if you do not
	// plan to modify the contents of the lines (glyphs, glyph widths, etc.).
	Lines() *glib.SList
	// LinesReadonly returns the lines of the @layout as a list.
	//
	// This is a faster alternative to [method@Pango.Layout.get_lines], but the
	// user is not expected to modify the contents of the lines (glyphs, glyph
	// widths, etc.).
	LinesReadonly() *glib.SList
	// LogAttrs retrieves an array of logical attributes for each character in
	// the @layout.
	LogAttrs() (attrs []*LogAttr, nAttrs int)
	// LogAttrsReadonly retrieves an array of logical attributes for each
	// character in the @layout.
	//
	// This is a faster alternative to [method@Pango.Layout.get_log_attrs]. The
	// returned array is part of @layout and must not be modified. Modifying the
	// layout will invalidate the returned array.
	//
	// The number of attributes returned in @n_attrs will be one more than the
	// total number of characters in the layout, since there need to be
	// attributes corresponding to both the position before the first character
	// and the position after the last character.
	LogAttrsReadonly() (nAttrs int, logAttrs []LogAttr)
	// PixelExtents computes the logical and ink extents of @layout in device
	// units.
	//
	// This function just calls [method@Pango.Layout.get_extents] followed by
	// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
	// such that the rounded rectangles fully contain the unrounded one (that
	// is, passes them as first argument to `pango_extents_to_pixels()`).
	PixelExtents() (inkRect Rectangle, logicalRect Rectangle)
	// PixelSize determines the logical width and height of a `PangoLayout` in
	// device units.
	//
	// [method@Pango.Layout.get_size] returns the width and height scaled by
	// PANGO_SCALE. This is simply a convenience function around
	// [method@Pango.Layout.get_pixel_extents].
	PixelSize() (width int, height int)
	// Serial returns the current serial number of @layout.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new layout is created and is increased whenever the layout is changed
	// using any of the setter functions, or the `PangoContext` it uses has
	// changed. The serial may wrap, but will never have the value 0. Since it
	// can wrap, never compare it with "less than", always use "not equals".
	//
	// This can be used to automatically detect changes to a `PangoLayout`, and
	// is useful for example to decide whether a layout needs redrawing. To
	// force the serial to be increased, use
	// [method@Pango.Layout.context_changed].
	Serial() uint
	// SingleParagraphMode obtains whether @layout is in single paragraph mode.
	//
	// See [method@Pango.Layout.set_single_paragraph_mode].
	SingleParagraphMode() bool
	// Size determines the logical width and height of a `PangoLayout` in Pango
	// units.
	//
	// This is simply a convenience function around
	// [method@Pango.Layout.get_extents].
	Size() (width int, height int)
	// Spacing gets the amount of spacing between the lines of the layout.
	Spacing() int
	// Tabs gets the current `PangoTabArray` used by this layout.
	//
	// If no `PangoTabArray` has been set, then the default tabs are in use and
	// nil is returned. Default tabs are every 8 spaces.
	//
	// The return value should be freed with [method@Pango.TabArray.free].
	Tabs() *TabArray
	// Text gets the text in the layout. The returned text should not be freed
	// or modified.
	Text() string
	// UnknownGlyphsCount counts the number of unknown glyphs in @layout.
	//
	// This function can be used to determine if there are any fonts available
	// to render all characters in a certain string, or when used in combination
	// with PANGO_ATTR_FALLBACK, to check if a certain font supports all the
	// characters in the string.
	UnknownGlyphsCount() int
	// Width gets the width to which the lines of the `PangoLayout` should wrap.
	Width() int
	// Wrap gets the wrap mode for the layout.
	//
	// Use [method@Pango.Layout.is_wrapped] to query whether any paragraphs were
	// actually wrapped.
	Wrap() WrapMode
	// IndexToLineX converts from byte @index_ within the @layout to line and X
	// position.
	//
	// The X position is measured from the left edge of the line.
	IndexToLineX(index_ int, trailing bool) (line int, xPos int)
	// IndexToPos converts from an index within a `PangoLayout` to the onscreen
	// position corresponding to the grapheme at that index.
	//
	// The return value is represented as rectangle. Note that `pos->x` is
	// always the leading edge of the grapheme and `pos->x + pos->width` the
	// trailing edge of the grapheme. If the directionality of the grapheme is
	// right-to-left, then `pos->width` will be negative.
	IndexToPos(index_ int) Rectangle
	// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
	//
	// This returns true if the ellipsization mode for @layout is not
	// PANGO_ELLIPSIZE_NONE, a positive width is set on @layout, and there are
	// paragraphs exceeding that width that have to be ellipsized.
	IsEllipsized() bool
	// IsWrapped queries whether the layout had to wrap any paragraphs.
	//
	// This returns true if a positive width is set on @layout, ellipsization
	// mode of @layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs
	// exceeding the layout width that have to be wrapped.
	IsWrapped() bool
	// MoveCursorVisually computes a new cursor position from an old position
	// and a count of positions to move visually.
	//
	// If @direction is positive, then the new strong cursor position will be
	// one position to the right of the old cursor position. If @direction is
	// negative, then the new strong cursor position will be one position to the
	// left of the old cursor position.
	//
	// In the presence of bidirectional text, the correspondence between logical
	// and visual order will depend on the direction of the current run, and
	// there may be jumps when the cursor is moved off of the end of a run.
	//
	// Motion here is in cursor positions, not in characters, so a single call
	// to [method@Pango.Layout.move_cursor_visually] may move the cursor over
	// multiple characters when multiple characters combine to form a single
	// grapheme.
	MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int)
	// SetAlignment sets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	SetAlignment(alignment Alignment)
	// SetAttributes sets the text attributes for a layout object. References
	// @attrs, so the caller can unref its reference.
	SetAttributes(attrs *AttrList)
	// SetAutoDir sets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// When this flag is on (the default), then paragraphs in @layout that begin
	// with strong right-to-left characters (Arabic and Hebrew principally),
	// will have right-to-left layout, paragraphs with letters from other
	// scripts will have left-to-right layout. Paragraphs with only neutral
	// characters get their direction from the surrounding paragraphs.
	//
	// When false, the choice between left-to-right and right-to-left layout is
	// done according to the base direction of the layout's `PangoContext`. (See
	// [method@Pango.Context.set_base_dir]).
	//
	// When the auto-computed direction of a paragraph differs from the base
	// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
	// PANGO_ALIGN_RIGHT are swapped.
	SetAutoDir(autoDir bool)
	// SetEllipsize sets the type of ellipsization being performed for @layout.
	//
	// Depending on the ellipsization mode @ellipsize text is removed from the
	// start, middle, or end of text so they fit within the width and height of
	// layout set with [method@Pango.Layout.set_width] and
	// [method@Pango.Layout.set_height].
	//
	// If the layout contains characters such as newlines that force it to be
	// layed out in multiple paragraphs, then whether each paragraph is
	// ellipsized separately or the entire layout is ellipsized as a whole
	// depends on the set height of the layout. See
	// [method@Pango.Layout.set_height] for details.
	SetEllipsize(ellipsize EllipsizeMode)
	// SetFontDescription sets the default font description for the layout.
	//
	// If no font description is set on the layout, the font description from
	// the layout's context is used.
	SetFontDescription(desc *FontDescription)
	// SetHeight sets the height to which the `PangoLayout` should be ellipsized
	// at.
	//
	// There are two different behaviors, based on whether @height is positive
	// or negative.
	//
	// If @height is positive, it will be the maximum height of the layout. Only
	// lines would be shown that would fit, and if there is any text omitted, an
	// ellipsis added. At least one line is included in each paragraph
	// regardless of how small the height value is. A value of zero will render
	// exactly one line for the entire layout.
	//
	// If @height is negative, it will be the (negative of) maximum number of
	// lines per paragraph. That is, the total number of lines shown may well be
	// more than this value if the layout contains multiple paragraphs of text.
	// The default value of -1 means that first line of each paragraph is
	// ellipsized. This behavior may be changed in the future to act per layout
	// instead of per paragraph. File a bug against pango at
	// https://gitlab.gnome.org/gnome/pango
	// (https://gitlab.gnome.org/gnome/pango) if your code relies on this
	// behavior.
	//
	// Height setting only has effect if a positive width is set on @layout and
	// ellipsization mode of @layout is not PANGO_ELLIPSIZE_NONE. The behavior
	// is undefined if a height other than -1 is set and ellipsization mode is
	// set to PANGO_ELLIPSIZE_NONE, and may change in the future.
	SetHeight(height int)
	// SetIndent sets the width in Pango units to indent each paragraph.
	//
	// A negative value of @indent will produce a hanging indentation. That is,
	// the first line will have the full width, and subsequent lines will be
	// indented by the absolute value of @indent.
	//
	// The indent setting is ignored if layout alignment is set to
	// PANGO_ALIGN_CENTER.
	SetIndent(indent int)
	// SetJustify sets whether each complete line should be stretched to fill
	// the entire width of the layout.
	//
	// Stretching is typically done by adding whitespace, but for some scripts
	// (such as Arabic), the justification may be done in more complex ways,
	// like extending the characters.
	//
	// Note that this setting is not implemented and so is ignored in Pango
	// older than 1.18.
	SetJustify(justify bool)
	// SetLineSpacing sets a factor for line spacing.
	//
	// Typical values are: 0, 1, 1.5, 2. The default values is 0.
	//
	// If @factor is non-zero, lines are placed so that
	//
	//    baseline2 = baseline1 + factor * height2
	//
	// where height2 is the line height of the second line (as determined by the
	// font(s)). In this case, the spacing set with
	// [method@Pango.Layout.set_spacing] is ignored.
	//
	// If @factor is zero, spacing is applied as before.
	SetLineSpacing(factor float32)
	// SetMarkup sets the layout text and attribute list from marked-up text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// This is the Same as [method@Pango.Layout.set_markup_with_accel], but the
	// markup text isn't scanned for accelerators.
	SetMarkup(markup string, length int)
	// SetMarkupWithAccel sets the layout text and attribute list from marked-up
	// text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// If @accel_marker is nonzero, the given character will mark the character
	// following it as an accelerator. For example, @accel_marker might be an
	// ampersand or underscore. All characters marked as an accelerator will
	// receive a PANGO_UNDERLINE_LOW attribute, and the first character so
	// marked will be returned in @accel_char. Two @accel_marker characters
	// following each other produce a single literal @accel_marker character.
	SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32
	// SetSingleParagraphMode sets the single paragraph mode of @layout.
	//
	// If @setting is true, do not treat newlines and similar characters as
	// paragraph separators; instead, keep all text in a single paragraph, and
	// display a glyph for paragraph separator characters. Used when you want to
	// allow editing of newlines on a single text line.
	SetSingleParagraphMode(setting bool)
	// SetSpacing sets the amount of spacing in Pango unit between the lines of
	// the layout.
	//
	//
	// When placing lines with spacing, Pango arranges things so that
	//
	// line2.top = line1.bottom + spacing
	//
	// Note: Since 1.44, Pango defaults to using the line height (as determined
	// by the font) for placing lines. The @spacing set with this function is
	// only taken into account when the line height factor is set to zero with
	// [method@Pango.Layout.set_line_spacing].
	SetSpacing(spacing int)
	// SetTabs sets the tabs to use for @layout, overriding the default tabs.
	//
	// By default, tabs are every 8 spaces. If @tabs is nil, the default tabs
	// are reinstated. @tabs is copied into the layout; you must free your copy
	// of @tabs yourself.
	SetTabs(tabs *TabArray)
	// SetText sets the text of the layout.
	//
	// This function validates @text and renders invalid UTF-8 with a
	// placeholder glyph.
	//
	// Note that if you have used [method@Pango.Layout.set_markup] or
	// [method@Pango.Layout.set_markup_with_accel] on @layout before, you may
	// want to call [method@Pango.Layout.set_attributes] to clear the attributes
	// set on the layout from the markup as this function does not clear
	// attributes.
	SetText(text string, length int)
	// SetWidth sets the width to which the lines of the `PangoLayout` should
	// wrap or ellipsized.
	//
	// The default value is -1: no width set.
	SetWidth(width int)
	// SetWrap sets the wrap mode.
	//
	// The wrap mode only has effect if a width is set on the layout with
	// [method@Pango.Layout.set_width]. To turn off wrapping, set the width to
	// -1.
	SetWrap(wrap WrapMode)
	// XYToIndex converts from X and Y position within a layout to the byte
	// index to the character at that logical position.
	//
	// If the Y position is not inside the layout, the closest position is
	// chosen (the position will be clamped inside the layout). If the X
	// position is not within the layout, then the start or the end of the line
	// is chosen as described for [method@Pango.LayoutLine.x_to_index]. If
	// either the X or Y positions were not inside the layout, then the function
	// returns false; on an exact hit, it returns true.
	XYToIndex(x int, y int) (index_ int, trailing int, ok bool)
}

// layout implements the Layout interface.
type layout struct {
	gextras.Objector
}

var _ Layout = (*layout)(nil)

// WrapLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayout(obj *externglib.Object) Layout {
	return Layout{
		Objector: obj,
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayout(obj), nil
}

// NewLayout constructs a class Layout.
func NewLayout(context Context) Layout {
	var arg1 *C.PangoContext

	arg1 = (*C.PangoContext)(context.Native())

	ret := C.pango_layout_new(arg1)

	var ret0 Layout

	ret0 = WrapLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ContextChanged forces recomputation of any state in the `PangoLayout`
// that might depend on the layout's context.
//
// This function should be called if you make changes to the context
// subsequent to creating the layout.
func (layout layout) ContextChanged() {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	C.pango_layout_context_changed(arg0)
}

// Copy creates a deep copy-by-value of the layout.
//
// The attribute list, tab array, and text from the original layout are all
// copied by value.
func (src layout) Copy() Layout {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(src.Native())

	ret := C.pango_layout_copy(arg0)

	var ret0 Layout

	ret0 = WrapLayout(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Alignment gets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
func (layout layout) Alignment() Alignment {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_alignment(arg0)

	var ret0 Alignment

	ret0 = Alignment(ret)

	return ret0
}

// Attributes gets the attribute list for the layout, if any.
func (layout layout) Attributes() *AttrList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_attributes(arg0)

	var ret0 *AttrList

	{
		ret0 = WrapAttrList(ret)
		runtime.SetFinalizer(&ret0, func(v **AttrList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// AutoDir gets whether to calculate the base direction for the layout
// according to its contents.
//
// See [method@Pango.Layout.set_auto_dir].
func (layout layout) AutoDir() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_auto_dir(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Baseline gets the Y position of baseline of the first line in @layout.
func (layout layout) Baseline() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_baseline(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// CharacterCount returns the number of Unicode characters in the the text
// of @layout.
func (layout layout) CharacterCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_character_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Context retrieves the `PangoContext` used for this layout.
func (layout layout) Context() Context {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_context(arg0)

	var ret0 Context

	ret0 = WrapContext(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CursorPos: given an index within a layout, determines the positions that
// of the strong and weak cursors if the insertion point is at that index.
//
// The position of each cursor is stored as a zero-width rectangle. The
// strong cursor location is the location where characters of the
// directionality equal to the base direction of the layout are inserted.
// The weak cursor location is the location where characters of the
// directionality opposite to the base direction of the layout are inserted.
func (layout layout) CursorPos(index_ int) (strongPos Rectangle, weakPos Rectangle) {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 *C.PangoRectangle // out
	var arg3 *C.PangoRectangle // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(index_)

	ret := C.pango_layout_get_cursor_pos(arg0, arg1, &arg2, &arg3)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg3)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// Direction gets the text direction at the given character position in
// @layout.
func (layout layout) Direction(index int) Direction {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(index)

	ret := C.pango_layout_get_direction(arg0, arg1)

	var ret0 Direction

	ret0 = Direction(ret)

	return ret0
}

// Ellipsize gets the type of ellipsization being performed for @layout.
//
// See [method@Pango.Layout.set_ellipsize].
//
// Use [method@Pango.Layout.is_ellipsized] to query whether any paragraphs
// were actually ellipsized.
func (layout layout) Ellipsize() EllipsizeMode {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_ellipsize(arg0)

	var ret0 EllipsizeMode

	ret0 = EllipsizeMode(ret)

	return ret0
}

// Extents computes the logical and ink extents of @layout.
//
// Logical extents are usually what you want for positioning things. Note
// that both extents may have non-zero x and y. You may want to use those to
// offset where you render the layout. Not doing that is a very typical bug
// that shows up as right-to-left layouts not being correctly positioned in
// a layout with a set width.
//
// The extents are given in layout coordinates and in Pango units; layout
// coordinates begin at the top left corner of the layout.
func (layout layout) Extents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// FontDescription gets the font description for the layout, if any.
func (layout layout) FontDescription() *FontDescription {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_font_description(arg0)

	var ret0 *FontDescription

	{
		ret0 = WrapFontDescription(ret)
		runtime.SetFinalizer(&ret0, func(v **FontDescription) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Height gets the height of layout used for ellipsization.
//
// See [method@Pango.Layout.set_height] for details.
func (layout layout) Height() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_height(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Indent gets the paragraph indent width in Pango units.
//
// A negative value indicates a hanging indentation.
func (layout layout) Indent() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_indent(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Iter returns an iterator to iterate over the visual extents of the
// layout.
func (layout layout) Iter() *LayoutIter {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_iter(arg0)

	var ret0 *LayoutIter

	{
		ret0 = WrapLayoutIter(ret)
	}

	return ret0
}

// Justify gets whether each complete line should be stretched to fill the
// entire width of the layout.
func (layout layout) Justify() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_justify(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Line retrieves a particular line from a `PangoLayout`.
//
// Use the faster [method@Pango.Layout.get_line_readonly] if you do not plan
// to modify the contents of the line (glyphs, glyph widths, etc.).
func (layout layout) Line(line int) *LayoutLine {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(line)

	ret := C.pango_layout_get_line(arg0, arg1)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
		runtime.SetFinalizer(&ret0, func(v **LayoutLine) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LineCount retrieves the count of lines for the @layout.
func (layout layout) LineCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_line_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LineReadonly retrieves a particular line from a `PangoLayout`.
//
// This is a faster alternative to [method@Pango.Layout.get_line], but the
// user is not expected to modify the contents of the line (glyphs, glyph
// widths, etc.).
func (layout layout) LineReadonly(line int) *LayoutLine {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(line)

	ret := C.pango_layout_get_line_readonly(arg0, arg1)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
		runtime.SetFinalizer(&ret0, func(v **LayoutLine) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LineSpacing gets the line spacing factor of @layout.
//
// See [method@Pango.Layout.set_line_spacing].
func (layout layout) LineSpacing() float32 {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_line_spacing(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Lines returns the lines of the @layout as a list.
//
// Use the faster [method@Pango.Layout.get_lines_readonly] if you do not
// plan to modify the contents of the lines (glyphs, glyph widths, etc.).
func (layout layout) Lines() *glib.SList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_lines(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(ret)
		runtime.SetFinalizer(&ret0, func(v **glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LinesReadonly returns the lines of the @layout as a list.
//
// This is a faster alternative to [method@Pango.Layout.get_lines], but the
// user is not expected to modify the contents of the lines (glyphs, glyph
// widths, etc.).
func (layout layout) LinesReadonly() *glib.SList {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_lines_readonly(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(ret)
		runtime.SetFinalizer(&ret0, func(v **glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// LogAttrs retrieves an array of logical attributes for each character in
// the @layout.
func (layout layout) LogAttrs() (attrs []*LogAttr, nAttrs int) {
	var arg0 *C.PangoLayout
	var arg1 **C.PangoLogAttr // out
	var arg2 *C.gint          // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_log_attrs(arg0, &arg1, &arg2)

	var ret0 []*LogAttr
	var ret1 int

	{
		ret0 = make([]*LogAttr, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.PangoLogAttr)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = WrapLogAttr(src)
				runtime.SetFinalizer(&ret0[i], func(v **LogAttr) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	ret1 = int(arg2)

	return ret0, ret1
}

// LogAttrsReadonly retrieves an array of logical attributes for each
// character in the @layout.
//
// This is a faster alternative to [method@Pango.Layout.get_log_attrs]. The
// returned array is part of @layout and must not be modified. Modifying the
// layout will invalidate the returned array.
//
// The number of attributes returned in @n_attrs will be one more than the
// total number of characters in the layout, since there need to be
// attributes corresponding to both the position before the first character
// and the position after the last character.
func (layout layout) LogAttrsReadonly() (nAttrs int, logAttrs []LogAttr) {
	var arg0 *C.PangoLayout
	var arg1 *C.gint // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_log_attrs_readonly(arg0, &arg1)

	var ret0 int
	var ret1 []LogAttr

	ret0 = int(arg1)

	{
		ret1 = make([]LogAttr, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.PangoLogAttr)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret1[i] = WrapLogAttr(src)
				runtime.SetFinalizer(&ret1[i], func(v *LogAttr) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	return ret0, ret1
}

// PixelExtents computes the logical and ink extents of @layout in device
// units.
//
// This function just calls [method@Pango.Layout.get_extents] followed by
// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
// such that the rounded rectangles fully contain the unrounded one (that
// is, passes them as first argument to `pango_extents_to_pixels()`).
func (layout layout) PixelExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoRectangle // out
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_pixel_extents(arg0, &arg1, &arg2)

	var ret0 *Rectangle
	var ret1 *Rectangle

	{
		ret0 = WrapRectangle(arg1)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret1 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret1, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// PixelSize determines the logical width and height of a `PangoLayout` in
// device units.
//
// [method@Pango.Layout.get_size] returns the width and height scaled by
// PANGO_SCALE. This is simply a convenience function around
// [method@Pango.Layout.get_pixel_extents].
func (layout layout) PixelSize() (width int, height int) {
	var arg0 *C.PangoLayout
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_pixel_size(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Serial returns the current serial number of @layout.
//
// The serial number is initialized to an small number larger than zero when
// a new layout is created and is increased whenever the layout is changed
// using any of the setter functions, or the `PangoContext` it uses has
// changed. The serial may wrap, but will never have the value 0. Since it
// can wrap, never compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a `PangoLayout`, and
// is useful for example to decide whether a layout needs redrawing. To
// force the serial to be increased, use
// [method@Pango.Layout.context_changed].
func (layout layout) Serial() uint {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_serial(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SingleParagraphMode obtains whether @layout is in single paragraph mode.
//
// See [method@Pango.Layout.set_single_paragraph_mode].
func (layout layout) SingleParagraphMode() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_single_paragraph_mode(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Size determines the logical width and height of a `PangoLayout` in Pango
// units.
//
// This is simply a convenience function around
// [method@Pango.Layout.get_extents].
func (layout layout) Size() (width int, height int) {
	var arg0 *C.PangoLayout
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_size(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// Spacing gets the amount of spacing between the lines of the layout.
func (layout layout) Spacing() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_spacing(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Tabs gets the current `PangoTabArray` used by this layout.
//
// If no `PangoTabArray` has been set, then the default tabs are in use and
// nil is returned. Default tabs are every 8 spaces.
//
// The return value should be freed with [method@Pango.TabArray.free].
func (layout layout) Tabs() *TabArray {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_tabs(arg0)

	var ret0 *TabArray

	{
		ret0 = WrapTabArray(ret)
	}

	return ret0
}

// Text gets the text in the layout. The returned text should not be freed
// or modified.
func (layout layout) Text() string {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_text(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnknownGlyphsCount counts the number of unknown glyphs in @layout.
//
// This function can be used to determine if there are any fonts available
// to render all characters in a certain string, or when used in combination
// with PANGO_ATTR_FALLBACK, to check if a certain font supports all the
// characters in the string.
func (layout layout) UnknownGlyphsCount() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_unknown_glyphs_count(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Width gets the width to which the lines of the `PangoLayout` should wrap.
func (layout layout) Width() int {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_width(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Wrap gets the wrap mode for the layout.
//
// Use [method@Pango.Layout.is_wrapped] to query whether any paragraphs were
// actually wrapped.
func (layout layout) Wrap() WrapMode {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_get_wrap(arg0)

	var ret0 WrapMode

	ret0 = WrapMode(ret)

	return ret0
}

// IndexToLineX converts from byte @index_ within the @layout to line and X
// position.
//
// The X position is measured from the left edge of the line.
func (layout layout) IndexToLineX(index_ int, trailing bool) (line int, xPos int) {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 C.gboolean
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(index_)
	arg2 = gextras.Cbool(trailing)

	ret := C.pango_layout_index_to_line_x(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int

	ret0 = int(arg3)

	ret1 = int(arg4)

	return ret0, ret1
}

// IndexToPos converts from an index within a `PangoLayout` to the onscreen
// position corresponding to the grapheme at that index.
//
// The return value is represented as rectangle. Note that `pos->x` is
// always the leading edge of the grapheme and `pos->x + pos->width` the
// trailing edge of the grapheme. If the directionality of the grapheme is
// right-to-left, then `pos->width` will be negative.
func (layout layout) IndexToPos(index_ int) Rectangle {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 *C.PangoRectangle // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(index_)

	ret := C.pango_layout_index_to_pos(arg0, arg1, &arg2)

	var ret0 *Rectangle

	{
		ret0 = WrapRectangle(arg2)
		runtime.SetFinalizer(&ret0, func(v **Rectangle) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
//
// This returns true if the ellipsization mode for @layout is not
// PANGO_ELLIPSIZE_NONE, a positive width is set on @layout, and there are
// paragraphs exceeding that width that have to be ellipsized.
func (layout layout) IsEllipsized() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_is_ellipsized(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsWrapped queries whether the layout had to wrap any paragraphs.
//
// This returns true if a positive width is set on @layout, ellipsization
// mode of @layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs
// exceeding the layout width that have to be wrapped.
func (layout layout) IsWrapped() bool {
	var arg0 *C.PangoLayout

	arg0 = (*C.PangoLayout)(layout.Native())

	ret := C.pango_layout_is_wrapped(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MoveCursorVisually computes a new cursor position from an old position
// and a count of positions to move visually.
//
// If @direction is positive, then the new strong cursor position will be
// one position to the right of the old cursor position. If @direction is
// negative, then the new strong cursor position will be one position to the
// left of the old cursor position.
//
// In the presence of bidirectional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and
// there may be jumps when the cursor is moved off of the end of a run.
//
// Motion here is in cursor positions, not in characters, so a single call
// to [method@Pango.Layout.move_cursor_visually] may move the cursor over
// multiple characters when multiple characters combine to form a single
// grapheme.
func (layout layout) MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.int // out
	var arg6 *C.int // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = gextras.Cbool(strong)
	arg2 = C.int(oldIndex)
	arg3 = C.int(oldTrailing)
	arg4 = C.int(direction)

	ret := C.pango_layout_move_cursor_visually(arg0, arg1, arg2, arg3, arg4, &arg5, &arg6)

	var ret0 int
	var ret1 int

	ret0 = int(arg5)

	ret1 = int(arg6)

	return ret0, ret1
}

// SetAlignment sets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
func (layout layout) SetAlignment(alignment Alignment) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoAlignment

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (C.PangoAlignment)(alignment)

	C.pango_layout_set_alignment(arg0, arg1)
}

// SetAttributes sets the text attributes for a layout object. References
// @attrs, so the caller can unref its reference.
func (layout layout) SetAttributes(attrs *AttrList) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoAttrList

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.PangoAttrList)(attrs.Native())

	C.pango_layout_set_attributes(arg0, arg1)
}

// SetAutoDir sets whether to calculate the base direction for the layout
// according to its contents.
//
// When this flag is on (the default), then paragraphs in @layout that begin
// with strong right-to-left characters (Arabic and Hebrew principally),
// will have right-to-left layout, paragraphs with letters from other
// scripts will have left-to-right layout. Paragraphs with only neutral
// characters get their direction from the surrounding paragraphs.
//
// When false, the choice between left-to-right and right-to-left layout is
// done according to the base direction of the layout's `PangoContext`. (See
// [method@Pango.Context.set_base_dir]).
//
// When the auto-computed direction of a paragraph differs from the base
// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
// PANGO_ALIGN_RIGHT are swapped.
func (layout layout) SetAutoDir(autoDir bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = gextras.Cbool(autoDir)

	C.pango_layout_set_auto_dir(arg0, arg1)
}

// SetEllipsize sets the type of ellipsization being performed for @layout.
//
// Depending on the ellipsization mode @ellipsize text is removed from the
// start, middle, or end of text so they fit within the width and height of
// layout set with [method@Pango.Layout.set_width] and
// [method@Pango.Layout.set_height].
//
// If the layout contains characters such as newlines that force it to be
// layed out in multiple paragraphs, then whether each paragraph is
// ellipsized separately or the entire layout is ellipsized as a whole
// depends on the set height of the layout. See
// [method@Pango.Layout.set_height] for details.
func (layout layout) SetEllipsize(ellipsize EllipsizeMode) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoEllipsizeMode

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (C.PangoEllipsizeMode)(ellipsize)

	C.pango_layout_set_ellipsize(arg0, arg1)
}

// SetFontDescription sets the default font description for the layout.
//
// If no font description is set on the layout, the font description from
// the layout's context is used.
func (layout layout) SetFontDescription(desc *FontDescription) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoFontDescription

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.PangoFontDescription)(desc.Native())

	C.pango_layout_set_font_description(arg0, arg1)
}

// SetHeight sets the height to which the `PangoLayout` should be ellipsized
// at.
//
// There are two different behaviors, based on whether @height is positive
// or negative.
//
// If @height is positive, it will be the maximum height of the layout. Only
// lines would be shown that would fit, and if there is any text omitted, an
// ellipsis added. At least one line is included in each paragraph
// regardless of how small the height value is. A value of zero will render
// exactly one line for the entire layout.
//
// If @height is negative, it will be the (negative of) maximum number of
// lines per paragraph. That is, the total number of lines shown may well be
// more than this value if the layout contains multiple paragraphs of text.
// The default value of -1 means that first line of each paragraph is
// ellipsized. This behavior may be changed in the future to act per layout
// instead of per paragraph. File a bug against pango at
// https://gitlab.gnome.org/gnome/pango
// (https://gitlab.gnome.org/gnome/pango) if your code relies on this
// behavior.
//
// Height setting only has effect if a positive width is set on @layout and
// ellipsization mode of @layout is not PANGO_ELLIPSIZE_NONE. The behavior
// is undefined if a height other than -1 is set and ellipsization mode is
// set to PANGO_ELLIPSIZE_NONE, and may change in the future.
func (layout layout) SetHeight(height int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(height)

	C.pango_layout_set_height(arg0, arg1)
}

// SetIndent sets the width in Pango units to indent each paragraph.
//
// A negative value of @indent will produce a hanging indentation. That is,
// the first line will have the full width, and subsequent lines will be
// indented by the absolute value of @indent.
//
// The indent setting is ignored if layout alignment is set to
// PANGO_ALIGN_CENTER.
func (layout layout) SetIndent(indent int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(indent)

	C.pango_layout_set_indent(arg0, arg1)
}

// SetJustify sets whether each complete line should be stretched to fill
// the entire width of the layout.
//
// Stretching is typically done by adding whitespace, but for some scripts
// (such as Arabic), the justification may be done in more complex ways,
// like extending the characters.
//
// Note that this setting is not implemented and so is ignored in Pango
// older than 1.18.
func (layout layout) SetJustify(justify bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = gextras.Cbool(justify)

	C.pango_layout_set_justify(arg0, arg1)
}

// SetLineSpacing sets a factor for line spacing.
//
// Typical values are: 0, 1, 1.5, 2. The default values is 0.
//
// If @factor is non-zero, lines are placed so that
//
//    baseline2 = baseline1 + factor * height2
//
// where height2 is the line height of the second line (as determined by the
// font(s)). In this case, the spacing set with
// [method@Pango.Layout.set_spacing] is ignored.
//
// If @factor is zero, spacing is applied as before.
func (layout layout) SetLineSpacing(factor float32) {
	var arg0 *C.PangoLayout
	var arg1 C.float

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.float(factor)

	C.pango_layout_set_line_spacing(arg0, arg1)
}

// SetMarkup sets the layout text and attribute list from marked-up text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// This is the Same as [method@Pango.Layout.set_markup_with_accel], but the
// markup text isn't scanned for accelerators.
func (layout layout) SetMarkup(markup string, length int) {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	C.pango_layout_set_markup(arg0, arg1, arg2)
}

// SetMarkupWithAccel sets the layout text and attribute list from marked-up
// text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will
// receive a PANGO_UNDERLINE_LOW attribute, and the first character so
// marked will be returned in @accel_char. Two @accel_marker characters
// following each other produce a single literal @accel_marker character.
func (layout layout) SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32 {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int
	var arg3 C.gunichar
	var arg4 *C.gunichar // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.gchar)(C.CString(markup))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)
	arg3 = C.gunichar(accelMarker)

	ret := C.pango_layout_set_markup_with_accel(arg0, arg1, arg2, arg3, &arg4)

	var ret0 uint32

	ret0 = uint32(arg4)

	return ret0
}

// SetSingleParagraphMode sets the single paragraph mode of @layout.
//
// If @setting is true, do not treat newlines and similar characters as
// paragraph separators; instead, keep all text in a single paragraph, and
// display a glyph for paragraph separator characters. Used when you want to
// allow editing of newlines on a single text line.
func (layout layout) SetSingleParagraphMode(setting bool) {
	var arg0 *C.PangoLayout
	var arg1 C.gboolean

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = gextras.Cbool(setting)

	C.pango_layout_set_single_paragraph_mode(arg0, arg1)
}

// SetSpacing sets the amount of spacing in Pango unit between the lines of
// the layout.
//
//
// When placing lines with spacing, Pango arranges things so that
//
// line2.top = line1.bottom + spacing
//
// Note: Since 1.44, Pango defaults to using the line height (as determined
// by the font) for placing lines. The @spacing set with this function is
// only taken into account when the line height factor is set to zero with
// [method@Pango.Layout.set_line_spacing].
func (layout layout) SetSpacing(spacing int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(spacing)

	C.pango_layout_set_spacing(arg0, arg1)
}

// SetTabs sets the tabs to use for @layout, overriding the default tabs.
//
// By default, tabs are every 8 spaces. If @tabs is nil, the default tabs
// are reinstated. @tabs is copied into the layout; you must free your copy
// of @tabs yourself.
func (layout layout) SetTabs(tabs *TabArray) {
	var arg0 *C.PangoLayout
	var arg1 *C.PangoTabArray

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.PangoTabArray)(tabs.Native())

	C.pango_layout_set_tabs(arg0, arg1)
}

// SetText sets the text of the layout.
//
// This function validates @text and renders invalid UTF-8 with a
// placeholder glyph.
//
// Note that if you have used [method@Pango.Layout.set_markup] or
// [method@Pango.Layout.set_markup_with_accel] on @layout before, you may
// want to call [method@Pango.Layout.set_attributes] to clear the attributes
// set on the layout from the markup as this function does not clear
// attributes.
func (layout layout) SetText(text string, length int) {
	var arg0 *C.PangoLayout
	var arg1 *C.char
	var arg2 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(length)

	C.pango_layout_set_text(arg0, arg1, arg2)
}

// SetWidth sets the width to which the lines of the `PangoLayout` should
// wrap or ellipsized.
//
// The default value is -1: no width set.
func (layout layout) SetWidth(width int) {
	var arg0 *C.PangoLayout
	var arg1 C.int

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(width)

	C.pango_layout_set_width(arg0, arg1)
}

// SetWrap sets the wrap mode.
//
// The wrap mode only has effect if a width is set on the layout with
// [method@Pango.Layout.set_width]. To turn off wrapping, set the width to
// -1.
func (layout layout) SetWrap(wrap WrapMode) {
	var arg0 *C.PangoLayout
	var arg1 C.PangoWrapMode

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = (C.PangoWrapMode)(wrap)

	C.pango_layout_set_wrap(arg0, arg1)
}

// XYToIndex converts from X and Y position within a layout to the byte
// index to the character at that logical position.
//
// If the Y position is not inside the layout, the closest position is
// chosen (the position will be clamped inside the layout). If the X
// position is not within the layout, then the start or the end of the line
// is chosen as described for [method@Pango.LayoutLine.x_to_index]. If
// either the X or Y positions were not inside the layout, then the function
// returns false; on an exact hit, it returns true.
func (layout layout) XYToIndex(x int, y int) (index_ int, trailing int, ok bool) {
	var arg0 *C.PangoLayout
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.int // out
	var arg4 *C.int // out

	arg0 = (*C.PangoLayout)(layout.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)

	ret := C.pango_layout_xy_to_index(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 int
	var ret1 int
	var ret2 bool

	ret0 = int(arg3)

	ret1 = int(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// Renderer: `PangoRenderer` is a base class for objects that can render text
// provided as `PangoGlyphString` or `PangoLayout`.
//
// By subclassing `PangoRenderer` and overriding operations such as @draw_glyphs
// and @draw_rectangle, renderers for particular font backends and destinations
// can be created.
type Renderer interface {
	gextras.Objector

	// Activate does initial setup before rendering operations on @renderer.
	//
	// [method@Pango.Renderer.deactivate] should be called when done drawing.
	// Calls such as [method@Pango.Renderer.draw_layout] automatically activate
	// the layout before drawing on it. Calls to `pango_renderer_activate()` and
	// `pango_renderer_deactivate()` can be nested and the renderer will only be
	// initialized and deinitialized once.
	Activate()
	// Deactivate cleans up after rendering operations on @renderer.
	//
	// See docs for [method@Pango.Renderer.activate].
	Deactivate()
	// DrawErrorUnderline: draw a squiggly line that approximately covers the
	// given rectangle in the style of an underline used to indicate a spelling
	// error.
	//
	// The width of the underline is rounded to an integer number of up/down
	// segments and the resulting rectangle is centered in the original
	// rectangle.
	//
	// This should be called while @renderer is already active. Use
	// [method@Pango.Renderer.activate] to activate a renderer.
	DrawErrorUnderline(x int, y int, width int, height int)
	// DrawGlyphItem draws the glyphs in @glyph_item with the specified
	// `PangoRenderer`, embedding the text associated with the glyphs in the
	// output if the output format supports it.
	//
	// This is useful for rendering text in PDF.
	//
	// Note that @text is the start of the text for layout, which is then
	// indexed by `glyph_item->item->offset`.
	//
	// If @text is nil, this simply calls [method@Pango.Renderer.draw_glyphs].
	//
	// The default implementation of this method simply falls back to
	// [method@Pango.Renderer.draw_glyphs].
	DrawGlyphItem(text string, glyphItem *GlyphItem, x int, y int)
	// DrawGlyphs draws the glyphs in @glyphs with the specified
	// `PangoRenderer`.
	DrawGlyphs(font Font, glyphs *GlyphString, x int, y int)
	// DrawLayout draws @layout with the specified `PangoRenderer`.
	DrawLayout(layout Layout, x int, y int)
	// DrawLayoutLine draws @line with the specified `PangoRenderer`.
	DrawLayoutLine(line *LayoutLine, x int, y int)
	// DrawRectangle draws an axis-aligned rectangle in user space coordinates
	// with the specified `PangoRenderer`.
	//
	// This should be called while @renderer is already active. Use
	// [method@Pango.Renderer.activate] to activate a renderer.
	DrawRectangle(part RenderPart, x int, y int, width int, height int)
	// DrawTrapezoid draws a trapezoid with the parallel sides aligned with the
	// X axis using the given `PangoRenderer`; coordinates are in device space.
	DrawTrapezoid(part RenderPart, y1 float64, x11 float64, x21 float64, y2 float64, x12 float64, x22 float64)
	// Alpha gets the current alpha for the specified part.
	Alpha(part RenderPart) uint16
	// Color gets the current rendering color for the specified part.
	Color(part RenderPart) *Color
	// Layout gets the layout currently being rendered using @renderer.
	//
	// Calling this function only makes sense from inside a subclass's methods,
	// like in its draw_shape vfunc, for example.
	//
	// The returned layout should not be modified while still being rendered.
	Layout() Layout
	// LayoutLine gets the layout line currently being rendered using @renderer.
	//
	// Calling this function only makes sense from inside a subclass's methods,
	// like in its draw_shape vfunc, for example.
	//
	// The returned layout line should not be modified while still being
	// rendered.
	LayoutLine() *LayoutLine
	// Matrix gets the transformation matrix that will be applied when
	// rendering.
	//
	// See [method@Pango.Renderer.set_matrix].
	Matrix() *Matrix
	// PartChanged informs Pango that the way that the rendering is done for
	// @part has changed.
	//
	// This should be called if the rendering changes in a way that would
	// prevent multiple pieces being joined together into one drawing call. For
	// instance, if a subclass of `PangoRenderer` was to add a stipple option
	// for drawing underlines, it needs to call
	//
	// “` pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE); “`
	//
	// When the stipple changes or underlines with different stipples might be
	// joined together. Pango automatically calls this for changes to colors.
	// (See [method@Pango.Renderer.set_color])
	PartChanged(part RenderPart)
	// SetAlpha sets the alpha for part of the rendering.
	//
	// Note that the alpha may only be used if a color is specified for @part as
	// well.
	SetAlpha(part RenderPart, alpha uint16)
	// SetColor sets the color for part of the rendering.
	//
	// Also see [method@Pango.Renderer.set_alpha].
	SetColor(part RenderPart, color *Color)
	// SetMatrix sets the transformation matrix that will be applied when
	// rendering.
	SetMatrix(matrix *Matrix)
}

// renderer implements the Renderer interface.
type renderer struct {
	gextras.Objector
}

var _ Renderer = (*renderer)(nil)

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return Renderer{
		Objector: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

// Activate does initial setup before rendering operations on @renderer.
//
// [method@Pango.Renderer.deactivate] should be called when done drawing.
// Calls such as [method@Pango.Renderer.draw_layout] automatically activate
// the layout before drawing on it. Calls to `pango_renderer_activate()` and
// `pango_renderer_deactivate()` can be nested and the renderer will only be
// initialized and deinitialized once.
func (renderer renderer) Activate() {
	var arg0 *C.PangoRenderer

	arg0 = (*C.PangoRenderer)(renderer.Native())

	C.pango_renderer_activate(arg0)
}

// Deactivate cleans up after rendering operations on @renderer.
//
// See docs for [method@Pango.Renderer.activate].
func (renderer renderer) Deactivate() {
	var arg0 *C.PangoRenderer

	arg0 = (*C.PangoRenderer)(renderer.Native())

	C.pango_renderer_deactivate(arg0)
}

// DrawErrorUnderline: draw a squiggly line that approximately covers the
// given rectangle in the style of an underline used to indicate a spelling
// error.
//
// The width of the underline is rounded to an integer number of up/down
// segments and the resulting rectangle is centered in the original
// rectangle.
//
// This should be called while @renderer is already active. Use
// [method@Pango.Renderer.activate] to activate a renderer.
func (renderer renderer) DrawErrorUnderline(x int, y int, width int, height int) {
	var arg0 *C.PangoRenderer
	var arg1 C.int
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = C.int(x)
	arg2 = C.int(y)
	arg3 = C.int(width)
	arg4 = C.int(height)

	C.pango_renderer_draw_error_underline(arg0, arg1, arg2, arg3, arg4)
}

// DrawGlyphItem draws the glyphs in @glyph_item with the specified
// `PangoRenderer`, embedding the text associated with the glyphs in the
// output if the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that @text is the start of the text for layout, which is then
// indexed by `glyph_item->item->offset`.
//
// If @text is nil, this simply calls [method@Pango.Renderer.draw_glyphs].
//
// The default implementation of this method simply falls back to
// [method@Pango.Renderer.draw_glyphs].
func (renderer renderer) DrawGlyphItem(text string, glyphItem *GlyphItem, x int, y int) {
	var arg0 *C.PangoRenderer
	var arg1 *C.char
	var arg2 *C.PangoGlyphItem
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.PangoGlyphItem)(glyphItem.Native())
	arg3 = C.int(x)
	arg4 = C.int(y)

	C.pango_renderer_draw_glyph_item(arg0, arg1, arg2, arg3, arg4)
}

// DrawGlyphs draws the glyphs in @glyphs with the specified
// `PangoRenderer`.
func (renderer renderer) DrawGlyphs(font Font, glyphs *GlyphString, x int, y int) {
	var arg0 *C.PangoRenderer
	var arg1 *C.PangoFont
	var arg2 *C.PangoGlyphString
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (*C.PangoFont)(font.Native())
	arg2 = (*C.PangoGlyphString)(glyphs.Native())
	arg3 = C.int(x)
	arg4 = C.int(y)

	C.pango_renderer_draw_glyphs(arg0, arg1, arg2, arg3, arg4)
}

// DrawLayout draws @layout with the specified `PangoRenderer`.
func (renderer renderer) DrawLayout(layout Layout, x int, y int) {
	var arg0 *C.PangoRenderer
	var arg1 *C.PangoLayout
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (*C.PangoLayout)(layout.Native())
	arg2 = C.int(x)
	arg3 = C.int(y)

	C.pango_renderer_draw_layout(arg0, arg1, arg2, arg3)
}

// DrawLayoutLine draws @line with the specified `PangoRenderer`.
func (renderer renderer) DrawLayoutLine(line *LayoutLine, x int, y int) {
	var arg0 *C.PangoRenderer
	var arg1 *C.PangoLayoutLine
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (*C.PangoLayoutLine)(line.Native())
	arg2 = C.int(x)
	arg3 = C.int(y)

	C.pango_renderer_draw_layout_line(arg0, arg1, arg2, arg3)
}

// DrawRectangle draws an axis-aligned rectangle in user space coordinates
// with the specified `PangoRenderer`.
//
// This should be called while @renderer is already active. Use
// [method@Pango.Renderer.activate] to activate a renderer.
func (renderer renderer) DrawRectangle(part RenderPart, x int, y int, width int, height int) {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int
	var arg5 C.int

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)
	arg2 = C.int(x)
	arg3 = C.int(y)
	arg4 = C.int(width)
	arg5 = C.int(height)

	C.pango_renderer_draw_rectangle(arg0, arg1, arg2, arg3, arg4, arg5)
}

// DrawTrapezoid draws a trapezoid with the parallel sides aligned with the
// X axis using the given `PangoRenderer`; coordinates are in device space.
func (renderer renderer) DrawTrapezoid(part RenderPart, y1 float64, x11 float64, x21 float64, y2 float64, x12 float64, x22 float64) {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double
	var arg7 C.double

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)
	arg2 = C.double(y1)
	arg3 = C.double(x11)
	arg4 = C.double(x21)
	arg5 = C.double(y2)
	arg6 = C.double(x12)
	arg7 = C.double(x22)

	C.pango_renderer_draw_trapezoid(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// Alpha gets the current alpha for the specified part.
func (renderer renderer) Alpha(part RenderPart) uint16 {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)

	ret := C.pango_renderer_get_alpha(arg0, arg1)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Color gets the current rendering color for the specified part.
func (renderer renderer) Color(part RenderPart) *Color {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)

	ret := C.pango_renderer_get_color(arg0, arg1)

	var ret0 *Color

	{
		ret0 = WrapColor(ret)
		runtime.SetFinalizer(&ret0, func(v **Color) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Layout gets the layout currently being rendered using @renderer.
//
// Calling this function only makes sense from inside a subclass's methods,
// like in its draw_shape vfunc, for example.
//
// The returned layout should not be modified while still being rendered.
func (renderer renderer) Layout() Layout {
	var arg0 *C.PangoRenderer

	arg0 = (*C.PangoRenderer)(renderer.Native())

	ret := C.pango_renderer_get_layout(arg0)

	var ret0 Layout

	ret0 = WrapLayout(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// LayoutLine gets the layout line currently being rendered using @renderer.
//
// Calling this function only makes sense from inside a subclass's methods,
// like in its draw_shape vfunc, for example.
//
// The returned layout line should not be modified while still being
// rendered.
func (renderer renderer) LayoutLine() *LayoutLine {
	var arg0 *C.PangoRenderer

	arg0 = (*C.PangoRenderer)(renderer.Native())

	ret := C.pango_renderer_get_layout_line(arg0)

	var ret0 *LayoutLine

	{
		ret0 = WrapLayoutLine(ret)
		runtime.SetFinalizer(&ret0, func(v **LayoutLine) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Matrix gets the transformation matrix that will be applied when
// rendering.
//
// See [method@Pango.Renderer.set_matrix].
func (renderer renderer) Matrix() *Matrix {
	var arg0 *C.PangoRenderer

	arg0 = (*C.PangoRenderer)(renderer.Native())

	ret := C.pango_renderer_get_matrix(arg0)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(ret)
		runtime.SetFinalizer(&ret0, func(v **Matrix) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// PartChanged informs Pango that the way that the rendering is done for
// @part has changed.
//
// This should be called if the rendering changes in a way that would
// prevent multiple pieces being joined together into one drawing call. For
// instance, if a subclass of `PangoRenderer` was to add a stipple option
// for drawing underlines, it needs to call
//
// “` pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE); “`
//
// When the stipple changes or underlines with different stipples might be
// joined together. Pango automatically calls this for changes to colors.
// (See [method@Pango.Renderer.set_color])
func (renderer renderer) PartChanged(part RenderPart) {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)

	C.pango_renderer_part_changed(arg0, arg1)
}

// SetAlpha sets the alpha for part of the rendering.
//
// Note that the alpha may only be used if a color is specified for @part as
// well.
func (renderer renderer) SetAlpha(part RenderPart, alpha uint16) {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart
	var arg2 C.guint16

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)
	arg2 = C.guint16(alpha)

	C.pango_renderer_set_alpha(arg0, arg1, arg2)
}

// SetColor sets the color for part of the rendering.
//
// Also see [method@Pango.Renderer.set_alpha].
func (renderer renderer) SetColor(part RenderPart, color *Color) {
	var arg0 *C.PangoRenderer
	var arg1 C.PangoRenderPart
	var arg2 *C.PangoColor

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (C.PangoRenderPart)(part)
	arg2 = (*C.PangoColor)(color.Native())

	C.pango_renderer_set_color(arg0, arg1, arg2)
}

// SetMatrix sets the transformation matrix that will be applied when
// rendering.
func (renderer renderer) SetMatrix(matrix *Matrix) {
	var arg0 *C.PangoRenderer
	var arg1 *C.PangoMatrix

	arg0 = (*C.PangoRenderer)(renderer.Native())
	arg1 = (*C.PangoMatrix)(matrix.Native())

	C.pango_renderer_set_matrix(arg0, arg1)
}
