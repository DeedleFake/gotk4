// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_shape_flags_get_type()), F: marshalShapeFlags},
		{T: externglib.Type(C.pango_glyph_string_get_type()), F: marshalGlyphString},
	})
}

// GlyphUnit: the `PangoGlyphUnit` type is used to store dimensions within
// Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit. (A device unit might
// be a pixel for screen display, or a point on a printer.) PANGO_SCALE is
// currently 1024, and may change in the future (unlikely though), but you
// should not depend on its exact value. The PANGO_PIXELS() macro can be used to
// convert from glyph units into device units with correct rounding.
type GlyphUnit int32

// ShapeFlags flags influencing the shaping process.
//
// `PangoShapeFlags` can be passed to pango_shape_with_flags().
type ShapeFlags int

const (
	// ShapeFlagsNone: default value.
	ShapeFlagsNone ShapeFlags = 0
	// ShapeFlagsRoundPositions: round glyph positions and widths to whole
	// device units. This option should be set if the target renderer can't do
	// subpixel positioning of glyphs.
	ShapeFlagsRoundPositions ShapeFlags = 1
)

func marshalShapeFlags(p uintptr) (interface{}, error) {
	return ShapeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GlyphGeometry: the `PangoGlyphGeometry` structure contains width and
// positioning information for a single glyph.
type GlyphGeometry struct {
	native C.PangoGlyphGeometry
}

// WrapGlyphGeometry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphGeometry(ptr unsafe.Pointer) *GlyphGeometry {
	if ptr == nil {
		return nil
	}

	return (*GlyphGeometry)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphGeometry) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphInfo: a `PangoGlyphInfo` structure represents a single glyph with
// positioning information and visual attributes.
type GlyphInfo struct {
	native C.PangoGlyphInfo
}

// WrapGlyphInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphInfo(ptr unsafe.Pointer) *GlyphInfo {
	if ptr == nil {
		return nil
	}

	return (*GlyphInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphString: a `PangoGlyphString` is used to store strings of glyphs with
// geometry and visual attribute information.
//
// The storage for the glyph information is owned by the structure which
// simplifies memory management.
type GlyphString struct {
	native C.PangoGlyphString
}

// WrapGlyphString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphString(ptr unsafe.Pointer) *GlyphString {
	if ptr == nil {
		return nil
	}

	return (*GlyphString)(ptr)
}

func marshalGlyphString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphString(unsafe.Pointer(b)), nil
}

// NewGlyphString constructs a struct GlyphString.
func NewGlyphString() *GlyphString {
	var _cret *C.PangoGlyphString // in

	_cret = C.pango_glyph_string_new()

	var _glyphString *GlyphString // out

	_glyphString = WrapGlyphString(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphString, func(v *GlyphString) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphString
}

// Native returns the underlying C source pointer.
func (g *GlyphString) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Copy: copy a glyph string and associated storage.
func (s *GlyphString) Copy() *GlyphString {
	var _arg0 *C.PangoGlyphString // out
	var _cret *C.PangoGlyphString // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	_cret = C.pango_glyph_string_copy(_arg0)

	var _glyphString *GlyphString // out

	_glyphString = WrapGlyphString(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphString, func(v *GlyphString) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphString
}

// Extents: compute the logical and ink extents of a glyph string.
//
// See the documentation for [method@Pango.Font.get_glyph_extents] for details
// about the interpretation of the rectangles.
//
// Examples of logical (red) and ink (green) rects:
//
// ! (rects1.png) ! (rects2.png)
func (g *GlyphString) Extents(font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.PangoFont        // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents(_arg0, _arg1, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// ExtentsRange computes the extents of a sub-portion of a glyph string.
//
// The extents are relative to the start of the glyph string range (the origin
// of their coordinate system is at the start of the range, not at the start of
// the entire glyph string).
func (g *GlyphString) ExtentsRange(start int, end int, font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoFont        // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(start)
	_arg2 = (C.int)(end)
	_arg3 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents_range(_arg0, _arg1, _arg2, _arg3, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// Free: free a glyph string and associated storage.
func (s *GlyphString) Free() {
	var _arg0 *C.PangoGlyphString // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	C.pango_glyph_string_free(_arg0)
}

// Width computes the logical width of the glyph string.
//
// This can also be computed using [method@Pango.GlyphString.extents]. However,
// since this only computes the width, it's much faster. This is in fact only a
// convenience function that computes the sum of @geometry.width for each glyph
// in the @glyphs.
func (g *GlyphString) Width() int {
	var _arg0 *C.PangoGlyphString // out
	var _cret C.int               // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))

	_cret = C.pango_glyph_string_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetSize: resize a glyph string to the given length.
func (s *GlyphString) SetSize(newLen int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.gint              // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(newLen)

	C.pango_glyph_string_set_size(_arg0, _arg1)
}

// GlyphVisAttr: a `PangoGlyphVisAttr` structure communicates information
// between the shaping and rendering phases.
//
// Currently, it contains only cluster start information. yMore attributes may
// be added in the future.
type GlyphVisAttr struct {
	native C.PangoGlyphVisAttr
}

// WrapGlyphVisAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphVisAttr(ptr unsafe.Pointer) *GlyphVisAttr {
	if ptr == nil {
		return nil
	}

	return (*GlyphVisAttr)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphVisAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}
