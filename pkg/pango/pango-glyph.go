// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_shape_flags_get_type()), F: marshalShapeFlags},
		{T: externglib.Type(C.pango_glyph_string_get_type()), F: marshalGlyphString},
	})
}

// GlyphUnit: the `PangoGlyphUnit` type is used to store dimensions within
// Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit. (A device unit might
// be a pixel for screen display, or a point on a printer.) PANGO_SCALE is
// currently 1024, and may change in the future (unlikely though), but you
// should not depend on its exact value. The PANGO_PIXELS() macro can be used to
// convert from glyph units into device units with correct rounding.
type GlyphUnit = int32

// ShapeFlags flags influencing the shaping process.
//
// `PangoShapeFlags` can be passed to pango_shape_with_flags().
type ShapeFlags int

const (
	// ShapeFlagsNone: default value.
	ShapeFlagsNone ShapeFlags = 0b0
	// ShapeFlagsRoundPositions: round glyph positions and widths to whole
	// device units. This option should be set if the target renderer can't do
	// subpixel positioning of glyphs.
	ShapeFlagsRoundPositions ShapeFlags = 0b1
)

func marshalShapeFlags(p uintptr) (interface{}, error) {
	return ShapeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Shape: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// It is recommended that you use [func@shape_full] instead, since that API
// allows for shaping interaction happening across text item boundaries.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// need to subtract the item offset from their indices before calling
// [func@shape].
func Shape(text string, length int, analysis *Analysis, glyphs *GlyphString) {
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoAnalysis    // out
	var _arg4 *C.PangoGlyphString // out

	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)
	_arg3 = (*C.PangoAnalysis)(unsafe.Pointer(analysis.Native()))
	_arg4 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs.Native()))

	C.pango_shape(_arg1, _arg2, _arg3, _arg4)
}

// ShapeFull: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// This is similar to [func@shape], except it also can optionally take the full
// paragraph text as input, which will then be used to perform certain
// cross-item shaping interactions. If you have access to the broader text of
// which @item_text is part of, provide the broader text as @paragraph_text. If
// @paragraph_text is nil, item text is used instead.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// do not pass the full paragraph text as @paragraph_text, you need to subtract
// the item offset from their indices before calling [func@shape_full].
func ShapeFull(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString) {
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.char             // out
	var _arg4 C.int               // out
	var _arg5 *C.PangoAnalysis    // out
	var _arg6 *C.PangoGlyphString // out

	_arg1 = (*C.char)(C.CString(itemText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(itemLength)
	_arg3 = (*C.char)(C.CString(paragraphText))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.int(paragraphLength)
	_arg5 = (*C.PangoAnalysis)(unsafe.Pointer(analysis.Native()))
	_arg6 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs.Native()))

	C.pango_shape_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// ShapeWithFlags: convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@itemize], convert the characters into glyphs. You may
// also pass in only a substring of the item from [func@itemize].
//
// This is similar to [func@shape_full], except it also takes flags that can
// influence the shaping process.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@itemize] have indices that are relative to the entire paragraph, so you
// do not pass the full paragraph text as @paragraph_text, you need to subtract
// the item offset from their indices before calling [func@shape_with_flags].
func ShapeWithFlags(itemText string, itemLength int, paragraphText string, paragraphLength int, analysis *Analysis, glyphs *GlyphString, flags ShapeFlags) {
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.char             // out
	var _arg4 C.int               // out
	var _arg5 *C.PangoAnalysis    // out
	var _arg6 *C.PangoGlyphString // out
	var _arg7 C.PangoShapeFlags   // out

	_arg1 = (*C.char)(C.CString(itemText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(itemLength)
	_arg3 = (*C.char)(C.CString(paragraphText))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.int(paragraphLength)
	_arg5 = (*C.PangoAnalysis)(unsafe.Pointer(analysis.Native()))
	_arg6 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs.Native()))
	_arg7 = C.PangoShapeFlags(flags)

	C.pango_shape_with_flags(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

// GlyphGeometry: the `PangoGlyphGeometry` structure contains width and
// positioning information for a single glyph.
type GlyphGeometry C.PangoGlyphGeometry

// WrapGlyphGeometry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphGeometry(ptr unsafe.Pointer) *GlyphGeometry {
	return (*GlyphGeometry)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphGeometry) Native() unsafe.Pointer {
	return unsafe.Pointer(g)
}

// GlyphInfo: a `PangoGlyphInfo` structure represents a single glyph with
// positioning information and visual attributes.
type GlyphInfo C.PangoGlyphInfo

// WrapGlyphInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphInfo(ptr unsafe.Pointer) *GlyphInfo {
	return (*GlyphInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(g)
}

// GlyphString: a `PangoGlyphString` is used to store strings of glyphs with
// geometry and visual attribute information.
//
// The storage for the glyph information is owned by the structure which
// simplifies memory management.
type GlyphString C.PangoGlyphString

// WrapGlyphString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphString(ptr unsafe.Pointer) *GlyphString {
	return (*GlyphString)(ptr)
}

func marshalGlyphString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*GlyphString)(unsafe.Pointer(b)), nil
}

// NewGlyphString constructs a struct GlyphString.
func NewGlyphString() *GlyphString {
	var _cret *C.PangoGlyphString // in

	_cret = C.pango_glyph_string_new()

	var _glyphString *GlyphString // out

	_glyphString = (*GlyphString)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_glyphString, func(v **GlyphString) {
		C.free(unsafe.Pointer(v))
	})

	return _glyphString
}

// Native returns the underlying C source pointer.
func (g *GlyphString) Native() unsafe.Pointer {
	return unsafe.Pointer(g)
}

// Copy: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) Copy() *GlyphString {
	var _arg0 *C.PangoGlyphString // out
	var _cret *C.PangoGlyphString // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	_cret = C.pango_glyph_string_copy(_arg0)

	var _glyphString *GlyphString // out

	_glyphString = (*GlyphString)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_glyphString, func(v **GlyphString) {
		C.free(unsafe.Pointer(v))
	})

	return _glyphString
}

// Extents: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) Extents(font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.PangoFont        // out
	var _arg2 C.PangoRectangle    // in
	var _arg3 C.PangoRectangle    // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents(_arg0, _arg1, &_arg2, &_arg3)

	var _inkRect Rectangle     // out
	var _logicalRect Rectangle // out

	{
		var refTmpIn *C.PangoRectangle
		var refTmpOut *Rectangle

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_inkRect = *refTmpOut
	}
	{
		var refTmpIn *C.PangoRectangle
		var refTmpOut *Rectangle

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_logicalRect = *refTmpOut
	}

	return _inkRect, _logicalRect
}

// ExtentsRange: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) ExtentsRange(start int, end int, font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoFont        // out
	var _arg4 C.PangoRectangle    // in
	var _arg5 C.PangoRectangle    // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = C.int(start)
	_arg2 = C.int(end)
	_arg3 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents_range(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

	var _inkRect Rectangle     // out
	var _logicalRect Rectangle // out

	{
		var refTmpIn *C.PangoRectangle
		var refTmpOut *Rectangle

		in0 := &_arg4
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_inkRect = *refTmpOut
	}
	{
		var refTmpIn *C.PangoRectangle
		var refTmpOut *Rectangle

		in0 := &_arg5
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_logicalRect = *refTmpOut
	}

	return _inkRect, _logicalRect
}

// Free: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) Free() {
	var _arg0 *C.PangoGlyphString // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	C.pango_glyph_string_free(_arg0)
}

// Width: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) Width() int {
	var _arg0 *C.PangoGlyphString // out
	var _cret C.int               // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))

	_cret = C.pango_glyph_string_get_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IndexToX: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) IndexToX(text string, length int, analysis *Analysis, index_ int, trailing bool) int {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoAnalysis    // out
	var _arg4 C.int               // out
	var _arg5 C.gboolean          // out
	var _arg6 C.int               // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)
	_arg3 = (*C.PangoAnalysis)(unsafe.Pointer(analysis.Native()))
	_arg4 = C.int(index_)
	if trailing {
		_arg5 = C.TRUE
	}

	C.pango_glyph_string_index_to_x(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)

	var _xPos int // out

	_xPos = int(_arg6)

	return _xPos
}

// SetSize: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) SetSize(newLen int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.gint              // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(newLen)

	C.pango_glyph_string_set_size(_arg0, _arg1)
}

// XToIndex: convert from x offset to character position.
//
// Character positions are computed by dividing up each cluster into equal
// portions. In scripts where positioning within a cluster is not allowed (such
// as Thai), the returned value may not be a valid cursor position; the caller
// must combine the result with the logical attributes for the text to compute
// the valid cursor position.
func (g *GlyphString) XToIndex(text string, length int, analysis *Analysis, xPos int) (index_ int, trailing int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoAnalysis    // out
	var _arg4 C.int               // out
	var _arg5 C.int               // in
	var _arg6 C.int               // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)
	_arg3 = (*C.PangoAnalysis)(unsafe.Pointer(analysis.Native()))
	_arg4 = C.int(xPos)

	C.pango_glyph_string_x_to_index(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

	var _index_ int   // out
	var _trailing int // out

	_index_ = int(_arg5)
	_trailing = int(_arg6)

	return _index_, _trailing
}

// GlyphVisAttr: a `PangoGlyphVisAttr` structure communicates information
// between the shaping and rendering phases.
//
// Currently, it contains only cluster start information. yMore attributes may
// be added in the future.
type GlyphVisAttr C.PangoGlyphVisAttr

// WrapGlyphVisAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphVisAttr(ptr unsafe.Pointer) *GlyphVisAttr {
	return (*GlyphVisAttr)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphVisAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(g)
}
