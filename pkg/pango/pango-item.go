// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_item_get_type()), F: marshalItem},
	})
}

// Item: the `PangoItem` structure stores information about a segment of text.
//
// You typically obtain `PangoItems` by itemizing a piece of text with
// [func@itemize].
type Item C.PangoItem

// WrapItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapItem(ptr unsafe.Pointer) *Item {
	return (*Item)(ptr)
}

func marshalItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Item)(unsafe.Pointer(b)), nil
}

// NewItem constructs a struct Item.
func NewItem() *Item {
	var _cret *C.PangoItem // in

	_cret = C.pango_item_new()

	var _item *Item // out

	_item = (*Item)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_item, func(v **Item) {
		C.free(unsafe.Pointer(v))
	})

	return _item
}

// Native returns the underlying C source pointer.
func (i *Item) Native() unsafe.Pointer {
	return unsafe.Pointer(i)
}

// ApplyAttrs modifies @orig to cover only the text after @split_index, and
// returns a new item that covers the text before @split_index that used to be
// in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (o *Item) ApplyAttrs(iter *AttrIterator) {
	var _arg0 *C.PangoItem         // out
	var _arg1 *C.PangoAttrIterator // out

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.PangoAttrIterator)(unsafe.Pointer(iter.Native()))

	C.pango_item_apply_attrs(_arg0, _arg1)
}

// Copy modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (o *Item) Copy() *Item {
	var _arg0 *C.PangoItem // out
	var _cret *C.PangoItem // in

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))

	_cret = C.pango_item_copy(_arg0)

	var _ret *Item // out

	_ret = (*Item)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_ret, func(v **Item) {
		C.free(unsafe.Pointer(v))
	})

	return _ret
}

// Free modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (o *Item) Free() {
	var _arg0 *C.PangoItem // out

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))

	C.pango_item_free(_arg0)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (o *Item) Split(splitIndex int, splitOffset int) *Item {
	var _arg0 *C.PangoItem // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _cret *C.PangoItem // in

	_arg0 = (*C.PangoItem)(unsafe.Pointer(o.Native()))
	_arg1 = C.int(splitIndex)
	_arg2 = C.int(splitOffset)

	_cret = C.pango_item_split(_arg0, _arg1, _arg2)

	var _item *Item // out

	_item = (*Item)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_item, func(v **Item) {
		C.free(unsafe.Pointer(v))
	})

	return _item
}
