// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_euler_get_type()), F: marshalEuler},
	})
}

// EulerOrder: specify the order of the rotations on each axis.
//
// The GRAPHENE_EULER_ORDER_DEFAULT value is special, and is used as an alias
// for one of the other orders.
type EulerOrder int

const (
	// default: rotate in the default order; the default order is one of the
	// following enumeration values
	EulerOrderDefault EulerOrder = -1
	// XYZ: rotate in the X, Y, and Z order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SXYZ
	EulerOrderXYZ EulerOrder = 0
	// YZX: rotate in the Y, Z, and X order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SYZX
	EulerOrderYZX EulerOrder = 1
	// ZXY: rotate in the Z, X, and Y order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SZXY
	EulerOrderZXY EulerOrder = 2
	// XZY: rotate in the X, Z, and Y order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SXZY
	EulerOrderXZY EulerOrder = 3
	// YXZ: rotate in the Y, X, and Z order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SYXZ
	EulerOrderYXZ EulerOrder = 4
	// ZYX: rotate in the Z, Y, and X order. Deprecated in Graphene 1.10, it's
	// an alias for GRAPHENE_EULER_ORDER_SZYX
	EulerOrderZYX EulerOrder = 5
	// sXYZ defines a static rotation along the X, Y, and Z axes (Since: 1.10)
	EulerOrderSXYZ EulerOrder = 6
	// sXYX defines a static rotation along the X, Y, and X axes (Since: 1.10)
	EulerOrderSXYX EulerOrder = 7
	// sXZY defines a static rotation along the X, Z, and Y axes (Since: 1.10)
	EulerOrderSXZY EulerOrder = 8
	// sXZX defines a static rotation along the X, Z, and X axes (Since: 1.10)
	EulerOrderSXZX EulerOrder = 9
	// sYZX defines a static rotation along the Y, Z, and X axes (Since: 1.10)
	EulerOrderSYZX EulerOrder = 10
	// sYZY defines a static rotation along the Y, Z, and Y axes (Since: 1.10)
	EulerOrderSYZY EulerOrder = 11
	// sYXZ defines a static rotation along the Y, X, and Z axes (Since: 1.10)
	EulerOrderSYXZ EulerOrder = 12
	// sYXY defines a static rotation along the Y, X, and Y axes (Since: 1.10)
	EulerOrderSYXY EulerOrder = 13
	// sZXY defines a static rotation along the Z, X, and Y axes (Since: 1.10)
	EulerOrderSZXY EulerOrder = 14
	// sZXZ defines a static rotation along the Z, X, and Z axes (Since: 1.10)
	EulerOrderSZXZ EulerOrder = 15
	// sZYX defines a static rotation along the Z, Y, and X axes (Since: 1.10)
	EulerOrderSZYX EulerOrder = 16
	// sZYZ defines a static rotation along the Z, Y, and Z axes (Since: 1.10)
	EulerOrderSZYZ EulerOrder = 17
	// rZYX defines a relative rotation along the Z, Y, and X axes (Since: 1.10)
	EulerOrderRZYX EulerOrder = 18
	// rXYX defines a relative rotation along the X, Y, and X axes (Since: 1.10)
	EulerOrderRXYX EulerOrder = 19
	// rYZX defines a relative rotation along the Y, Z, and X axes (Since: 1.10)
	EulerOrderRYZX EulerOrder = 20
	// rXZX defines a relative rotation along the X, Z, and X axes (Since: 1.10)
	EulerOrderRXZX EulerOrder = 21
	// rXZY defines a relative rotation along the X, Z, and Y axes (Since: 1.10)
	EulerOrderRXZY EulerOrder = 22
	// rYZY defines a relative rotation along the Y, Z, and Y axes (Since: 1.10)
	EulerOrderRYZY EulerOrder = 23
	// rZXY defines a relative rotation along the Z, X, and Y axes (Since: 1.10)
	EulerOrderRZXY EulerOrder = 24
	// rYXY defines a relative rotation along the Y, X, and Y axes (Since: 1.10)
	EulerOrderRYXY EulerOrder = 25
	// rYXZ defines a relative rotation along the Y, X, and Z axes (Since: 1.10)
	EulerOrderRYXZ EulerOrder = 26
	// rZXZ defines a relative rotation along the Z, X, and Z axes (Since: 1.10)
	EulerOrderRZXZ EulerOrder = 27
	// rXYZ defines a relative rotation along the X, Y, and Z axes (Since: 1.10)
	EulerOrderRXYZ EulerOrder = 28
	// rZYZ defines a relative rotation along the Z, Y, and Z axes (Since: 1.10)
	EulerOrderRZYZ EulerOrder = 29
)

// Euler: describe a rotation using Euler angles.
//
// The contents of the #graphene_euler_t structure are private and should never
// be accessed directly.
type Euler C.graphene_euler_t

// WrapEuler wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEuler(ptr unsafe.Pointer) *Euler {
	return (*Euler)(ptr)
}

func marshalEuler(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Euler)(unsafe.Pointer(b)), nil
}

// NewEulerAlloc constructs a struct Euler.
func NewEulerAlloc() *Euler {
	var _cret *C.graphene_euler_t // in

	_cret = C.graphene_euler_alloc()

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_euler, func(v **Euler) {
		C.free(unsafe.Pointer(v))
	})

	return _euler
}

// Native returns the underlying C source pointer.
func (e *Euler) Native() unsafe.Pointer {
	return unsafe.Pointer(e)
}

// Equal retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Equal(b *Euler) bool {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 *C.graphene_euler_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_euler_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Free() {
	var _arg0 *C.graphene_euler_t // out

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_free(_arg0)
}

// Alpha retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Alpha() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_alpha(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Beta retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Beta() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_beta(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Gamma retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Gamma() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_gamma(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Order retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Order() EulerOrder {
	var _arg0 *C.graphene_euler_t      // out
	var _cret C.graphene_euler_order_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_order(_arg0)

	var _eulerOrder EulerOrder // out

	_eulerOrder = EulerOrder(_cret)

	return _eulerOrder
}

// X retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) X() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Y retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Y() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Z retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Z() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_z(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Init retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Init(x float32, y float32, z float32) *Euler {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 C.float             // out
	var _arg2 C.float             // out
	var _arg3 C.float             // out
	var _cret *C.graphene_euler_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = C.float(x)
	_arg2 = C.float(y)
	_arg3 = C.float(z)

	_cret = C.graphene_euler_init(_arg0, _arg1, _arg2, _arg3)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitFromEuler retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) InitFromEuler(src *Euler) *Euler {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 *C.graphene_euler_t // out
	var _cret *C.graphene_euler_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_euler_init_from_euler(_arg0, _arg1)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitFromMatrix retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) InitFromMatrix(m *Matrix, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_matrix_t     // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg2 = C.graphene_euler_order_t(order)

	_cret = C.graphene_euler_init_from_matrix(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitFromQuaternion retrieves the angles of a #graphene_euler_t and
// initializes a #graphene_vec3_t with them.
func (e *Euler) InitFromQuaternion(q *Quaternion, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_quaternion_t // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg2 = C.graphene_euler_order_t(order)

	_cret = C.graphene_euler_init_from_quaternion(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitFromRadians retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) InitFromRadians(x float32, y float32, z float32, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _arg4 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = C.float(x)
	_arg2 = C.float(y)
	_arg3 = C.float(z)
	_arg4 = C.graphene_euler_order_t(order)

	_cret = C.graphene_euler_init_from_radians(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitFromVec3 retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) InitFromVec3(v *Vec3, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_vec3_t       // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg2 = C.graphene_euler_order_t(order)

	_cret = C.graphene_euler_init_from_vec3(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// InitWithOrder retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) InitWithOrder(x float32, y float32, z float32, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _arg4 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = C.float(x)
	_arg2 = C.float(y)
	_arg3 = C.float(z)
	_arg4 = C.graphene_euler_order_t(order)

	_cret = C.graphene_euler_init_with_order(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _euler *Euler // out

	_euler = (*Euler)(unsafe.Pointer(_cret))

	return _euler
}

// Reorder retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) Reorder(order EulerOrder) Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.graphene_euler_order_t // out
	var _arg2 C.graphene_euler_t       // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = C.graphene_euler_order_t(order)

	C.graphene_euler_reorder(_arg0, _arg1, &_arg2)

	var _res Euler // out

	{
		var refTmpIn *C.graphene_euler_t
		var refTmpOut *Euler

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Euler)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// ToMatrix retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) ToMatrix() Matrix {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 C.graphene_matrix_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_matrix(_arg0, &_arg1)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// ToQuaternion retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) ToQuaternion() Quaternion {
	var _arg0 *C.graphene_euler_t     // out
	var _arg1 C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_quaternion(_arg0, &_arg1)

	var _res Quaternion // out

	{
		var refTmpIn *C.graphene_quaternion_t
		var refTmpOut *Quaternion

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Quaternion)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// ToVec3 retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) ToVec3() Vec3 {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 C.graphene_vec3_t   // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_vec3(_arg0, &_arg1)

	var _res Vec3 // out

	{
		var refTmpIn *C.graphene_vec3_t
		var refTmpOut *Vec3

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Vec3)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}
