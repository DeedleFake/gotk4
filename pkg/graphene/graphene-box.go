// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_box_get_type()), F: marshalBox},
	})
}

// Box: 3D box, described as the volume between a minimum and a maximum
// vertices.
type Box struct {
	native C.graphene_box_t
}

// WrapBox wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBox(ptr unsafe.Pointer) *Box {
	return (*Box)(ptr)
}

func marshalBox(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Box)(unsafe.Pointer(b)), nil
}

// NewBoxAlloc constructs a struct Box.
func NewBoxAlloc() *Box {
	var _cret *C.graphene_box_t // in

	_cret = C.graphene_box_alloc()

	var _box *Box // out

	_box = (*Box)(unsafe.Pointer(*C.graphene_box_t))
	runtime.SetFinalizer(_box, func(v *Box) {
		C.free(unsafe.Pointer(v))
	})

	return _box
}

// Native returns the underlying C source pointer.
func (b *Box) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// ContainsBox checks whether the #graphene_box_t @a contains the given
// #graphene_box_t @b.
func (a *Box) ContainsBox(b *Box) bool {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_contains_box(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainsPoint checks whether @box contains the given @point.
func (b *Box) ContainsPoint(point *Point3D) bool {
	var _arg0 *C.graphene_box_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(*Point3D))

	_cret = C.graphene_box_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given boxes are equal.
func (a *Box) Equal(b *Box) bool {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_box_alloc().
func (b *Box) free() {
	var _arg0 *C.graphene_box_t // out

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	C.graphene_box_free(_arg0)
}

// Depth retrieves the size of the @box on the Z axis.
func (b *Box) Depth() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_get_depth(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Height retrieves the size of the @box on the Y axis.
func (b *Box) Height() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_get_height(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Width retrieves the size of the @box on the X axis.
func (b *Box) Width() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_get_width(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Init initializes the given #graphene_box_t with two vertices.
func (b *Box) Init(min *Point3D, max *Point3D) *Box {
	var _arg0 *C.graphene_box_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 *C.graphene_point3d_t // out
	var _cret *C.graphene_box_t     // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(*Point3D))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(*Point3D))

	_cret = C.graphene_box_init(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = (*Box)(unsafe.Pointer(*C.graphene_box_t))

	return _ret
}

// InitFromBox initializes the given #graphene_box_t with the vertices of
// another #graphene_box_t.
func (b *Box) InitFromBox(src *Box) *Box {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret *C.graphene_box_t // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(*Box))

	_cret = C.graphene_box_init_from_box(_arg0, _arg1)

	var _ret *Box // out

	_ret = (*Box)(unsafe.Pointer(*C.graphene_box_t))

	return _ret
}

// InitFromVec3 initializes the given #graphene_box_t with two vertices stored
// inside #graphene_vec3_t.
func (b *Box) InitFromVec3(min *Vec3, max *Vec3) *Box {
	var _arg0 *C.graphene_box_t  // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.graphene_box_t  // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(*Box))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(*Vec3))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(*Vec3))

	_cret = C.graphene_box_init_from_vec3(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = (*Box)(unsafe.Pointer(*C.graphene_box_t))

	return _ret
}
