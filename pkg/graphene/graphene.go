// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.graphene_euler_get_type()), F: marshalEuler},
		{T: externglib.Type(C.graphene_frustum_get_type()), F: marshalFrustum},
		{T: externglib.Type(C.graphene_matrix_get_type()), F: marshalMatrix},
		{T: externglib.Type(C.graphene_plane_get_type()), F: marshalPlane},
		{T: externglib.Type(C.graphene_point_get_type()), F: marshalPoint},
		{T: externglib.Type(C.graphene_point3d_get_type()), F: marshalPoint3D},
		{T: externglib.Type(C.graphene_quad_get_type()), F: marshalQuad},
		{T: externglib.Type(C.graphene_quaternion_get_type()), F: marshalQuaternion},
		{T: externglib.Type(C.graphene_ray_get_type()), F: marshalRay},
		{T: externglib.Type(C.graphene_rect_get_type()), F: marshalRect},
		{T: externglib.Type(C.graphene_size_get_type()), F: marshalSize},
		{T: externglib.Type(C.graphene_sphere_get_type()), F: marshalSphere},
		{T: externglib.Type(C.graphene_triangle_get_type()), F: marshalTriangle},
		{T: externglib.Type(C.graphene_vec2_get_type()), F: marshalVec2},
		{T: externglib.Type(C.graphene_vec3_get_type()), F: marshalVec3},
		{T: externglib.Type(C.graphene_vec4_get_type()), F: marshalVec4},
	})
}

// EulerOrder: specify the order of the rotations on each axis.
//
// The GRAPHENE_EULER_ORDER_DEFAULT value is special, and is used as an alias
// for one of the other orders.
type EulerOrder int

const (
	// EulerOrderDefault: rotate in the default order; the default order is one
	// of the following enumeration values
	EulerOrderDefault EulerOrder = -1
	// EulerOrderXYZ: rotate in the X, Y, and Z order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SXYZ
	EulerOrderXYZ EulerOrder = 0
	// EulerOrderYZX: rotate in the Y, Z, and X order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SYZX
	EulerOrderYZX EulerOrder = 1
	// EulerOrderZXY: rotate in the Z, X, and Y order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SZXY
	EulerOrderZXY EulerOrder = 2
	// EulerOrderXZY: rotate in the X, Z, and Y order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SXZY
	EulerOrderXZY EulerOrder = 3
	// EulerOrderYXZ: rotate in the Y, X, and Z order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SYXZ
	EulerOrderYXZ EulerOrder = 4
	// EulerOrderZYX: rotate in the Z, Y, and X order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SZYX
	EulerOrderZYX EulerOrder = 5
	// EulerOrderSXYZ defines a static rotation along the X, Y, and Z axes
	// (Since: 1.10)
	EulerOrderSXYZ EulerOrder = 6
	// EulerOrderSXYX defines a static rotation along the X, Y, and X axes
	// (Since: 1.10)
	EulerOrderSXYX EulerOrder = 7
	// EulerOrderSXZY defines a static rotation along the X, Z, and Y axes
	// (Since: 1.10)
	EulerOrderSXZY EulerOrder = 8
	// EulerOrderSXZX defines a static rotation along the X, Z, and X axes
	// (Since: 1.10)
	EulerOrderSXZX EulerOrder = 9
	// EulerOrderSYZX defines a static rotation along the Y, Z, and X axes
	// (Since: 1.10)
	EulerOrderSYZX EulerOrder = 10
	// EulerOrderSYZY defines a static rotation along the Y, Z, and Y axes
	// (Since: 1.10)
	EulerOrderSYZY EulerOrder = 11
	// EulerOrderSYXZ defines a static rotation along the Y, X, and Z axes
	// (Since: 1.10)
	EulerOrderSYXZ EulerOrder = 12
	// EulerOrderSYXY defines a static rotation along the Y, X, and Y axes
	// (Since: 1.10)
	EulerOrderSYXY EulerOrder = 13
	// EulerOrderSZXY defines a static rotation along the Z, X, and Y axes
	// (Since: 1.10)
	EulerOrderSZXY EulerOrder = 14
	// EulerOrderSZXZ defines a static rotation along the Z, X, and Z axes
	// (Since: 1.10)
	EulerOrderSZXZ EulerOrder = 15
	// EulerOrderSZYX defines a static rotation along the Z, Y, and X axes
	// (Since: 1.10)
	EulerOrderSZYX EulerOrder = 16
	// EulerOrderSZYZ defines a static rotation along the Z, Y, and Z axes
	// (Since: 1.10)
	EulerOrderSZYZ EulerOrder = 17
	// EulerOrderRZYX defines a relative rotation along the Z, Y, and X axes
	// (Since: 1.10)
	EulerOrderRZYX EulerOrder = 18
	// EulerOrderRXYX defines a relative rotation along the X, Y, and X axes
	// (Since: 1.10)
	EulerOrderRXYX EulerOrder = 19
	// EulerOrderRYZX defines a relative rotation along the Y, Z, and X axes
	// (Since: 1.10)
	EulerOrderRYZX EulerOrder = 20
	// EulerOrderRXZX defines a relative rotation along the X, Z, and X axes
	// (Since: 1.10)
	EulerOrderRXZX EulerOrder = 21
	// EulerOrderRXZY defines a relative rotation along the X, Z, and Y axes
	// (Since: 1.10)
	EulerOrderRXZY EulerOrder = 22
	// EulerOrderRYZY defines a relative rotation along the Y, Z, and Y axes
	// (Since: 1.10)
	EulerOrderRYZY EulerOrder = 23
	// EulerOrderRZXY defines a relative rotation along the Z, X, and Y axes
	// (Since: 1.10)
	EulerOrderRZXY EulerOrder = 24
	// EulerOrderRYXY defines a relative rotation along the Y, X, and Y axes
	// (Since: 1.10)
	EulerOrderRYXY EulerOrder = 25
	// EulerOrderRYXZ defines a relative rotation along the Y, X, and Z axes
	// (Since: 1.10)
	EulerOrderRYXZ EulerOrder = 26
	// EulerOrderRZXZ defines a relative rotation along the Z, X, and Z axes
	// (Since: 1.10)
	EulerOrderRZXZ EulerOrder = 27
	// EulerOrderRXYZ defines a relative rotation along the X, Y, and Z axes
	// (Since: 1.10)
	EulerOrderRXYZ EulerOrder = 28
	// EulerOrderRZYZ defines a relative rotation along the Z, Y, and Z axes
	// (Since: 1.10)
	EulerOrderRZYZ EulerOrder = 29
)

// RayIntersectionKind: the type of intersection.
type RayIntersectionKind int

const (
	// RayIntersectionKindNone: no intersection
	RayIntersectionKindNone RayIntersectionKind = 0
	// RayIntersectionKindEnter: the ray is entering the intersected object
	RayIntersectionKindEnter RayIntersectionKind = 1
	// RayIntersectionKindLeave: the ray is leaving the intersected object
	RayIntersectionKindLeave RayIntersectionKind = 2
)

// Box: a 3D box, described as the volume between a minimum and a maximum
// vertices.
type Box struct {
	native C.graphene_box_t
}

// WrapBox wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBox(ptr unsafe.Pointer) *Box {
	if ptr == nil {
		return nil
	}

	return (*Box)(ptr)
}

func marshalBox(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBox(unsafe.Pointer(b)), nil
}

// NewBoxAlloc constructs a struct Box.
func NewBoxAlloc() *Box {
	var _cret *C.graphene_box_t // in

	_cret = C.graphene_box_alloc()

	var _box *Box // out

	_box = WrapBox(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_box, func(v *Box) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _box
}

// Native returns the underlying C source pointer.
func (b *Box) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// ContainsBox checks whether the #graphene_box_t @a contains the given
// #graphene_box_t @b.
func (a *Box) ContainsBox(b *Box) bool {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_contains_box(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainsPoint checks whether @box contains the given @point.
func (b *Box) ContainsPoint(point *Point3D) bool {
	var _arg0 *C.graphene_box_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_box_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given boxes are equal.
func (a *Box) Equal(b *Box) bool {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Expand expands the dimensions of @box to include the coordinates at @point.
func (b *Box) Expand(point *Point3D) Box {
	var _arg0 *C.graphene_box_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _res Box

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.graphene_box_expand(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// ExpandScalar expands the dimensions of @box by the given @scalar value.
//
// If @scalar is positive, the #graphene_box_t will grow; if @scalar is
// negative, the #graphene_box_t will shrink.
func (b *Box) ExpandScalar(scalar float32) Box {
	var _arg0 *C.graphene_box_t // out
	var _arg1 C.float           // out
	var _res Box

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (C.float)(scalar)

	C.graphene_box_expand_scalar(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// ExpandVec3 expands the dimensions of @box to include the coordinates of the
// given vector.
func (b *Box) ExpandVec3(vec *Vec3) Box {
	var _arg0 *C.graphene_box_t  // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Box

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(vec.Native()))

	C.graphene_box_expand_vec3(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// Free frees the resources allocated by graphene_box_alloc().
func (b *Box) Free() {
	var _arg0 *C.graphene_box_t // out

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_free(_arg0)
}

// BoundingSphere computes the bounding #graphene_sphere_t capable of containing
// the given #graphene_box_t.
func (b *Box) BoundingSphere() Sphere {
	var _arg0 *C.graphene_box_t // out
	var _sphere Sphere

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_bounding_sphere(_arg0, (*C.graphene_sphere_t)(unsafe.Pointer(&_sphere)))

	return _sphere
}

// Center retrieves the coordinates of the center of a #graphene_box_t.
func (b *Box) Center() Point3D {
	var _arg0 *C.graphene_box_t // out
	var _center Point3D

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_center(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_center)))

	return _center
}

// Depth retrieves the size of the @box on the Z axis.
func (b *Box) Depth() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_get_depth(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Height retrieves the size of the @box on the Y axis.
func (b *Box) Height() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_get_height(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Max retrieves the coordinates of the maximum point of the given
// #graphene_box_t.
func (b *Box) Max() Point3D {
	var _arg0 *C.graphene_box_t // out
	var _max Point3D

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_max(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_max)))

	return _max
}

// Min retrieves the coordinates of the minimum point of the given
// #graphene_box_t.
func (b *Box) Min() Point3D {
	var _arg0 *C.graphene_box_t // out
	var _min Point3D

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_min(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_min)))

	return _min
}

// Size retrieves the size of the box on all three axes, and stores it into the
// given @size vector.
func (b *Box) Size() Vec3 {
	var _arg0 *C.graphene_box_t // out
	var _size Vec3

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_size(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_size)))

	return _size
}

// Vertices computes the vertices of the given #graphene_box_t.
func (b *Box) Vertices() [8]Vec3 {
	var _arg0 *C.graphene_box_t // out
	var _arg1 [8]C.graphene_vec3_t

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_get_vertices(_arg0, &_arg1[0])

	var _vertices [8]Vec3

	_vertices = *(*[8]Vec3)(unsafe.Pointer(&_arg1))

	return _vertices
}

// Width retrieves the size of the @box on the X axis.
func (b *Box) Width() float32 {
	var _arg0 *C.graphene_box_t // out
	var _cret C.float           // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_get_width(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes the given #graphene_box_t with two vertices.
func (b *Box) Init(min *Point3D, max *Point3D) *Box {
	var _arg0 *C.graphene_box_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 *C.graphene_point3d_t // out
	var _cret *C.graphene_box_t     // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(min.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(max.Native()))

	_cret = C.graphene_box_init(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = WrapBox(unsafe.Pointer(_cret))

	return _ret
}

// InitFromBox initializes the given #graphene_box_t with the vertices of
// another #graphene_box_t.
func (b *Box) InitFromBox(src *Box) *Box {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret *C.graphene_box_t // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_box_init_from_box(_arg0, _arg1)

	var _ret *Box // out

	_ret = WrapBox(unsafe.Pointer(_cret))

	return _ret
}

// InitFromPoints initializes the given #graphene_box_t with the given array of
// vertices.
//
// If @n_points is 0, the returned box is initialized with graphene_box_empty().
func (b *Box) InitFromPoints(points []Point3D) *Box {
	var _arg0 *C.graphene_box_t // out
	var _arg2 *C.graphene_point3d_t
	var _arg1 C.uint
	var _cret *C.graphene_box_t // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = C.uint(len(points))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(&points[0]))

	_cret = C.graphene_box_init_from_points(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = WrapBox(unsafe.Pointer(_cret))

	return _ret
}

// InitFromVec3 initializes the given #graphene_box_t with two vertices stored
// inside #graphene_vec3_t.
func (b *Box) InitFromVec3(min *Vec3, max *Vec3) *Box {
	var _arg0 *C.graphene_box_t  // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.graphene_box_t  // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(min.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(max.Native()))

	_cret = C.graphene_box_init_from_vec3(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = WrapBox(unsafe.Pointer(_cret))

	return _ret
}

// InitFromVectors initializes the given #graphene_box_t with the given array of
// vertices.
//
// If @n_vectors is 0, the returned box is initialized with
// graphene_box_empty().
func (b *Box) InitFromVectors(vectors []Vec3) *Box {
	var _arg0 *C.graphene_box_t // out
	var _arg2 *C.graphene_vec3_t
	var _arg1 C.uint
	var _cret *C.graphene_box_t // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))
	_arg1 = C.uint(len(vectors))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(&vectors[0]))

	_cret = C.graphene_box_init_from_vectors(_arg0, _arg1, _arg2)

	var _ret *Box // out

	_ret = WrapBox(unsafe.Pointer(_cret))

	return _ret
}

// Intersection intersects the two given #graphene_box_t.
//
// If the two boxes do not intersect, @res will contain a degenerate box
// initialized with graphene_box_empty().
func (a *Box) Intersection(b *Box) (Box, bool) {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _res Box
	var _cret C._Bool // in

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_box_intersection(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Union unions the two given #graphene_box_t.
func (a *Box) Union(b *Box) Box {
	var _arg0 *C.graphene_box_t // out
	var _arg1 *C.graphene_box_t // out
	var _res Box

	_arg0 = (*C.graphene_box_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_box_union(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// Euler: describe a rotation using Euler angles.
//
// The contents of the #graphene_euler_t structure are private and should never
// be accessed directly.
type Euler struct {
	native C.graphene_euler_t
}

// WrapEuler wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEuler(ptr unsafe.Pointer) *Euler {
	if ptr == nil {
		return nil
	}

	return (*Euler)(ptr)
}

func marshalEuler(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEuler(unsafe.Pointer(b)), nil
}

// NewEulerAlloc constructs a struct Euler.
func NewEulerAlloc() *Euler {
	var _cret *C.graphene_euler_t // in

	_cret = C.graphene_euler_alloc()

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_euler, func(v *Euler) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _euler
}

// Native returns the underlying C source pointer.
func (e *Euler) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// Equal checks if two #graphene_euler_t are equal.
func (a *Euler) Equal(b *Euler) bool {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 *C.graphene_euler_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_euler_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_euler_alloc().
func (e *Euler) Free() {
	var _arg0 *C.graphene_euler_t // out

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_free(_arg0)
}

// Alpha retrieves the first component of the Euler angle vector, depending on
// the order of rotation.
//
// See also: graphene_euler_get_x()
func (e *Euler) Alpha() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_alpha(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Beta retrieves the second component of the Euler angle vector, depending on
// the order of rotation.
//
// See also: graphene_euler_get_y()
func (e *Euler) Beta() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_beta(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Gamma retrieves the third component of the Euler angle vector, depending on
// the order of rotation.
//
// See also: graphene_euler_get_z()
func (e *Euler) Gamma() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_gamma(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Order retrieves the order used to apply the rotations described in the
// #graphene_euler_t structure, when converting to and from other structures,
// like #graphene_quaternion_t and #graphene_matrix_t.
//
// This function does not return the GRAPHENE_EULER_ORDER_DEFAULT enumeration
// value; it will return the effective order of rotation instead.
func (e *Euler) Order() EulerOrder {
	var _arg0 *C.graphene_euler_t      // out
	var _cret C.graphene_euler_order_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_order(_arg0)

	var _eulerOrder EulerOrder // out

	_eulerOrder = EulerOrder(_cret)

	return _eulerOrder
}

// X retrieves the rotation angle on the X axis, in degrees.
func (e *Euler) X() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Y retrieves the rotation angle on the Y axis, in degrees.
func (e *Euler) Y() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Z retrieves the rotation angle on the Z axis, in degrees.
func (e *Euler) Z() float32 {
	var _arg0 *C.graphene_euler_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_euler_get_z(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes a #graphene_euler_t using the given angles.
//
// The order of the rotations is GRAPHENE_EULER_ORDER_DEFAULT.
func (e *Euler) Init(x float32, y float32, z float32) *Euler {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 C.float             // out
	var _arg2 C.float             // out
	var _arg3 C.float             // out
	var _cret *C.graphene_euler_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)

	_cret = C.graphene_euler_init(_arg0, _arg1, _arg2, _arg3)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitFromEuler initializes a #graphene_euler_t using the angles and order of
// another #graphene_euler_t.
//
// If the #graphene_euler_t @src is nil, this function is equivalent to calling
// graphene_euler_init() with all angles set to 0.
func (e *Euler) InitFromEuler(src *Euler) *Euler {
	var _arg0 *C.graphene_euler_t // out
	var _arg1 *C.graphene_euler_t // out
	var _cret *C.graphene_euler_t // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_euler_init_from_euler(_arg0, _arg1)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitFromMatrix initializes a #graphene_euler_t using the given rotation
// matrix.
//
// If the #graphene_matrix_t @m is nil, the #graphene_euler_t will be
// initialized with all angles set to 0.
func (e *Euler) InitFromMatrix(m *Matrix, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_matrix_t     // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg2 = (C.graphene_euler_order_t)(order)

	_cret = C.graphene_euler_init_from_matrix(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitFromQuaternion initializes a #graphene_euler_t using the given normalized
// quaternion.
//
// If the #graphene_quaternion_t @q is nil, the #graphene_euler_t will be
// initialized with all angles set to 0.
func (e *Euler) InitFromQuaternion(q *Quaternion, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_quaternion_t // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg2 = (C.graphene_euler_order_t)(order)

	_cret = C.graphene_euler_init_from_quaternion(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitFromRadians initializes a #graphene_euler_t using the given angles and
// order of rotation.
func (e *Euler) InitFromRadians(x float32, y float32, z float32, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _arg4 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)
	_arg4 = (C.graphene_euler_order_t)(order)

	_cret = C.graphene_euler_init_from_radians(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitFromVec3 initializes a #graphene_euler_t using the angles contained in a
// #graphene_vec3_t.
//
// If the #graphene_vec3_t @v is nil, the #graphene_euler_t will be initialized
// with all angles set to 0.
func (e *Euler) InitFromVec3(v *Vec3, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 *C.graphene_vec3_t       // out
	var _arg2 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg2 = (C.graphene_euler_order_t)(order)

	_cret = C.graphene_euler_init_from_vec3(_arg0, _arg1, _arg2)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// InitWithOrder initializes a #graphene_euler_t with the given angles and
// @order.
func (e *Euler) InitWithOrder(x float32, y float32, z float32, order EulerOrder) *Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _arg4 C.graphene_euler_order_t // out
	var _cret *C.graphene_euler_t      // in

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)
	_arg4 = (C.graphene_euler_order_t)(order)

	_cret = C.graphene_euler_init_with_order(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _euler *Euler // out

	_euler = WrapEuler(unsafe.Pointer(_cret))

	return _euler
}

// Reorder reorders a #graphene_euler_t using @order.
//
// This function is equivalent to creating a #graphene_quaternion_t from the
// given #graphene_euler_t, and then converting the quaternion into another
// #graphene_euler_t.
func (e *Euler) Reorder(order EulerOrder) Euler {
	var _arg0 *C.graphene_euler_t      // out
	var _arg1 C.graphene_euler_order_t // out
	var _res Euler

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))
	_arg1 = (C.graphene_euler_order_t)(order)

	C.graphene_euler_reorder(_arg0, _arg1, (*C.graphene_euler_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToMatrix converts a #graphene_euler_t into a transformation matrix expressing
// the extrinsic composition of rotations described by the Euler angles.
//
// The rotations are applied over the reference frame axes in the order
// associated with the #graphene_euler_t; for instance, if the order used to
// initialize @e is GRAPHENE_EULER_ORDER_XYZ:
//
//    * the first rotation moves the body around the X axis with
//      an angle φ
//    * the second rotation moves the body around the Y axis with
//      an angle of ϑ
//    * the third rotation moves the body around the Z axis with
//      an angle of ψ
//
// The rotation sign convention is right-handed, to preserve compatibility
// between Euler-based, quaternion-based, and angle-axis-based rotations.
func (e *Euler) ToMatrix() Matrix {
	var _arg0 *C.graphene_euler_t // out
	var _res Matrix

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_matrix(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToQuaternion converts a #graphene_euler_t into a #graphene_quaternion_t.
func (e *Euler) ToQuaternion() Quaternion {
	var _arg0 *C.graphene_euler_t // out
	var _res Quaternion

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_quaternion(_arg0, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToVec3 retrieves the angles of a #graphene_euler_t and initializes a
// #graphene_vec3_t with them.
func (e *Euler) ToVec3() Vec3 {
	var _arg0 *C.graphene_euler_t // out
	var _res Vec3

	_arg0 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_euler_to_vec3(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Frustum: a 3D volume delimited by 2D clip planes.
//
// The contents of the `graphene_frustum_t` are private, and should not be
// modified directly.
type Frustum struct {
	native C.graphene_frustum_t
}

// WrapFrustum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrustum(ptr unsafe.Pointer) *Frustum {
	if ptr == nil {
		return nil
	}

	return (*Frustum)(ptr)
}

func marshalFrustum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFrustum(unsafe.Pointer(b)), nil
}

// NewFrustumAlloc constructs a struct Frustum.
func NewFrustumAlloc() *Frustum {
	var _cret *C.graphene_frustum_t // in

	_cret = C.graphene_frustum_alloc()

	var _frustum *Frustum // out

	_frustum = WrapFrustum(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_frustum, func(v *Frustum) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _frustum
}

// Native returns the underlying C source pointer.
func (f *Frustum) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// ContainsPoint checks whether a point is inside the volume defined by the
// given #graphene_frustum_t.
func (f *Frustum) ContainsPoint(point *Point3D) bool {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_frustum_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given #graphene_frustum_t are equal.
func (a *Frustum) Equal(b *Frustum) bool {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_frustum_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_frustum_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_frustum_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_frustum_alloc().
func (f *Frustum) Free() {
	var _arg0 *C.graphene_frustum_t // out

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))

	C.graphene_frustum_free(_arg0)
}

// Planes retrieves the planes that define the given #graphene_frustum_t.
func (f *Frustum) Planes() [6]Plane {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 [6]C.graphene_plane_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))

	C.graphene_frustum_get_planes(_arg0, &_arg1[0])

	var _planes [6]Plane

	_planes = *(*[6]Plane)(unsafe.Pointer(&_arg1))

	return _planes
}

// Init initializes the given #graphene_frustum_t using the provided clipping
// planes.
func (f *Frustum) Init(p0 *Plane, p1 *Plane, p2 *Plane, p3 *Plane, p4 *Plane, p5 *Plane) *Frustum {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_plane_t   // out
	var _arg2 *C.graphene_plane_t   // out
	var _arg3 *C.graphene_plane_t   // out
	var _arg4 *C.graphene_plane_t   // out
	var _arg5 *C.graphene_plane_t   // out
	var _arg6 *C.graphene_plane_t   // out
	var _cret *C.graphene_frustum_t // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_plane_t)(unsafe.Pointer(p0.Native()))
	_arg2 = (*C.graphene_plane_t)(unsafe.Pointer(p1.Native()))
	_arg3 = (*C.graphene_plane_t)(unsafe.Pointer(p2.Native()))
	_arg4 = (*C.graphene_plane_t)(unsafe.Pointer(p3.Native()))
	_arg5 = (*C.graphene_plane_t)(unsafe.Pointer(p4.Native()))
	_arg6 = (*C.graphene_plane_t)(unsafe.Pointer(p5.Native()))

	_cret = C.graphene_frustum_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _frustum *Frustum // out

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// InitFromFrustum initializes the given #graphene_frustum_t using the clipping
// planes of another #graphene_frustum_t.
func (f *Frustum) InitFromFrustum(src *Frustum) *Frustum {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_frustum_t // out
	var _cret *C.graphene_frustum_t // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_frustum_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_frustum_init_from_frustum(_arg0, _arg1)

	var _frustum *Frustum // out

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// InitFromMatrix initializes a #graphene_frustum_t using the given @matrix.
func (f *Frustum) InitFromMatrix(matrix *Matrix) *Frustum {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_matrix_t  // out
	var _cret *C.graphene_frustum_t // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	_cret = C.graphene_frustum_init_from_matrix(_arg0, _arg1)

	var _frustum *Frustum // out

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// IntersectsBox checks whether the given @box intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsBox(box *Box) bool {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_box_t     // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(box.Native()))

	_cret = C.graphene_frustum_intersects_box(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IntersectsSphere checks whether the given @sphere intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsSphere(sphere *Sphere) bool {
	var _arg0 *C.graphene_frustum_t // out
	var _arg1 *C.graphene_sphere_t  // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(sphere.Native()))

	_cret = C.graphene_frustum_intersects_sphere(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Matrix: a structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and should never
// be accessed directly.
type Matrix struct {
	native C.graphene_matrix_t
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b)), nil
}

// NewMatrixAlloc constructs a struct Matrix.
func NewMatrixAlloc() *Matrix {
	var _cret *C.graphene_matrix_t // in

	_cret = C.graphene_matrix_alloc()

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_matrix, func(v *Matrix) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _matrix
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Decompose decomposes a transformation matrix into its component
// transformations.
//
// The algorithm for decomposing a matrix is taken from the CSS3 Transforms
// specification (http://dev.w3.org/csswg/css-transforms/); specifically, the
// decomposition code is based on the equivalent code published in "Graphics
// Gems II", edited by Jim Arvo, and available online
// (http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c).
func (m *Matrix) Decompose() (translate Vec3, scale Vec3, rotate Quaternion, shear Vec3, perspective Vec4, ok bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _translate Vec3
	var _scale Vec3
	var _rotate Quaternion
	var _shear Vec3
	var _perspective Vec4
	var _cret C._Bool // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_decompose(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_translate)), (*C.graphene_vec3_t)(unsafe.Pointer(&_scale)), (*C.graphene_quaternion_t)(unsafe.Pointer(&_rotate)), (*C.graphene_vec3_t)(unsafe.Pointer(&_shear)), (*C.graphene_vec4_t)(unsafe.Pointer(&_perspective)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _translate, _scale, _rotate, _shear, _perspective, _ok
}

// Determinant computes the determinant of the given matrix.
func (m *Matrix) Determinant() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_determinant(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the two given #graphene_matrix_t matrices are equal.
func (a *Matrix) Equal(b *Matrix) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_matrix_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// EqualFast checks whether the two given #graphene_matrix_t matrices are
// byte-by-byte equal.
//
// While this function is faster than graphene_matrix_equal(), it can also
// return false negatives, so it should be used in conjuction with either
// graphene_matrix_equal() or graphene_matrix_near(). For instance:
//
//    if (graphene_matrix_equal_fast (a, b))
//      {
//        // matrices are definitely the same
//      }
//    else
//      {
//        if (graphene_matrix_equal (a, b))
//          // matrices contain the same values within an epsilon of FLT_EPSILON
//        else if (graphene_matrix_near (a, b, 0.0001))
//          // matrices contain the same values within an epsilon of 0.0001
//        else
//          // matrices are not equal
//      }
func (a *Matrix) EqualFast(b *Matrix) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_matrix_equal_fast(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_matrix_alloc().
func (m *Matrix) Free() {
	var _arg0 *C.graphene_matrix_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_free(_arg0)
}

// Row retrieves the given row vector at @index_ inside a matrix.
func (m *Matrix) Row(index_ uint) Vec4 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.uint               // out
	var _res Vec4

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.uint)(index_)

	C.graphene_matrix_get_row(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Value retrieves the value at the given @row and @col index.
func (m *Matrix) Value(row uint, col uint) float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.uint               // out
	var _arg2 C.uint               // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.uint)(row)
	_arg2 = (C.uint)(col)

	_cret = C.graphene_matrix_get_value(_arg0, _arg1, _arg2)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// XScale retrieves the scaling factor on the X axis in @m.
func (m *Matrix) XScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_x_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// XTranslation retrieves the translation component on the X axis from @m.
func (m *Matrix) XTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_x_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// YScale retrieves the scaling factor on the Y axis in @m.
func (m *Matrix) YScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_y_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// YTranslation retrieves the translation component on the Y axis from @m.
func (m *Matrix) YTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_y_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// ZScale retrieves the scaling factor on the Z axis in @m.
func (m *Matrix) ZScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_z_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// ZTranslation retrieves the translation component on the Z axis from @m.
func (m *Matrix) ZTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_z_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// InitFrom2D initializes a #graphene_matrix_t from the values of an affine
// transformation matrix.
//
// The arguments map to the following matrix layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between an affine matrix type from other
// libraries and a #graphene_matrix_t.
func (m *Matrix) InitFrom2D(xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.double             // out
	var _arg2 C.double             // out
	var _arg3 C.double             // out
	var _arg4 C.double             // out
	var _arg5 C.double             // out
	var _arg6 C.double             // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.double)(xx)
	_arg2 = (C.double)(yx)
	_arg3 = (C.double)(xy)
	_arg4 = (C.double)(yy)
	_arg5 = (C.double)(x0)
	_arg6 = (C.double)(y0)

	_cret = C.graphene_matrix_init_from_2d(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromFloat initializes a #graphene_matrix_t with the given array of
// floating point values.
func (m *Matrix) InitFromFloat(v [16]float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.float
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&v))

	_cret = C.graphene_matrix_init_from_float(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromMatrix initializes a #graphene_matrix_t using the values of the given
// matrix.
func (m *Matrix) InitFromMatrix(src *Matrix) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_matrix_init_from_matrix(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromVec4 initializes a #graphene_matrix_t with the given four row
// vectors.
func (m *Matrix) InitFromVec4(v0 *Vec4, v1 *Vec4, v2 *Vec4, v3 *Vec4) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec4_t   // out
	var _arg2 *C.graphene_vec4_t   // out
	var _arg3 *C.graphene_vec4_t   // out
	var _arg4 *C.graphene_vec4_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v0.Native()))
	_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(v1.Native()))
	_arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))
	_arg4 = (*C.graphene_vec4_t)(unsafe.Pointer(v3.Native()))

	_cret = C.graphene_matrix_init_from_vec4(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitFrustum initializes a #graphene_matrix_t compatible with
// #graphene_frustum_t.
//
// See also: graphene_frustum_init_from_matrix()
func (m *Matrix) InitFrustum(left float32, right float32, bottom float32, top float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out
	var _arg6 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(left)
	_arg2 = (C.float)(right)
	_arg3 = (C.float)(bottom)
	_arg4 = (C.float)(top)
	_arg5 = (C.float)(zNear)
	_arg6 = (C.float)(zFar)

	_cret = C.graphene_matrix_init_frustum(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitIdentity initializes a #graphene_matrix_t with the identity matrix.
func (m *Matrix) InitIdentity() *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_init_identity(_arg0)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitLookAt initializes a #graphene_matrix_t so that it positions the "camera"
// at the given @eye coordinates towards an object at the @center coordinates.
// The top of the camera is aligned to the direction of the @up vector.
//
// Before the transform, the camera is assumed to be placed at the origin,
// looking towards the negative Z axis, with the top side of the camera facing
// in the direction of the Y axis and the right side in the direction of the X
// axis.
//
// In theory, one could use @m to transform a model of such a camera into
// world-space. However, it is more common to use the inverse of @m to transform
// another object from world coordinates to the view coordinates of the camera.
// Typically you would then apply the camera projection transform to get from
// view to screen coordinates.
func (m *Matrix) InitLookAt(eye *Vec3, center *Vec3, up *Vec3) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec3_t   // out
	var _arg2 *C.graphene_vec3_t   // out
	var _arg3 *C.graphene_vec3_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(eye.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(center.Native()))
	_arg3 = (*C.graphene_vec3_t)(unsafe.Pointer(up.Native()))

	_cret = C.graphene_matrix_init_look_at(_arg0, _arg1, _arg2, _arg3)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitOrtho initializes a #graphene_matrix_t with an orthographic projection.
func (m *Matrix) InitOrtho(left float32, right float32, top float32, bottom float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out
	var _arg6 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(left)
	_arg2 = (C.float)(right)
	_arg3 = (C.float)(top)
	_arg4 = (C.float)(bottom)
	_arg5 = (C.float)(zNear)
	_arg6 = (C.float)(zFar)

	_cret = C.graphene_matrix_init_ortho(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitPerspective initializes a #graphene_matrix_t with a perspective
// projection.
func (m *Matrix) InitPerspective(fovy float32, aspect float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(fovy)
	_arg2 = (C.float)(aspect)
	_arg3 = (C.float)(zNear)
	_arg4 = (C.float)(zFar)

	_cret = C.graphene_matrix_init_perspective(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitRotate initializes @m to represent a rotation of @angle degrees on the
// axis represented by the @axis vector.
func (m *Matrix) InitRotate(angle float32, axis *Vec3) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 *C.graphene_vec3_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	_cret = C.graphene_matrix_init_rotate(_arg0, _arg1, _arg2)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitScale initializes a #graphene_matrix_t with the given scaling factors.
func (m *Matrix) InitScale(x float32, y float32, z float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)

	_cret = C.graphene_matrix_init_scale(_arg0, _arg1, _arg2, _arg3)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitSkew initializes a #graphene_matrix_t with a skew transformation with the
// given factors.
func (m *Matrix) InitSkew(xSkew float32, ySkew float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(xSkew)
	_arg2 = (C.float)(ySkew)

	_cret = C.graphene_matrix_init_skew(_arg0, _arg1, _arg2)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// InitTranslate initializes a #graphene_matrix_t with a translation to the
// given coordinates.
func (m *Matrix) InitTranslate(p *Point3D) *Matrix {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_matrix_init_translate(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

// Interpolate: linearly interpolates the two given #graphene_matrix_t by
// interpolating the decomposed transformations separately.
//
// If either matrix cannot be reduced to their transformations then the
// interpolation cannot be performed, and this function will return an identity
// matrix.
func (a *Matrix) Interpolate(b *Matrix, factor float64) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 C.double             // out
	var _res Matrix

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_matrix_interpolate(_arg0, _arg1, _arg2, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// Inverse inverts the given matrix.
func (m *Matrix) Inverse() (Matrix, bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _res Matrix
	var _cret C._Bool // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_inverse(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Is2D checks whether the given #graphene_matrix_t is compatible with an a 2D
// affine transformation matrix.
func (m *Matrix) Is2D() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_2d(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsBackfaceVisible checks whether a #graphene_matrix_t has a visible back
// face.
func (m *Matrix) IsBackfaceVisible() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_backface_visible(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsIdentity checks whether the given #graphene_matrix_t is the identity
// matrix.
func (m *Matrix) IsIdentity() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_identity(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsSingular checks whether a matrix is singular.
func (m *Matrix) IsSingular() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_singular(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Multiply multiplies two #graphene_matrix_t.
//
// Matrix multiplication is not commutative in general; the order of the factors
// matters. The product of this multiplication is (@a × @b)
func (a *Matrix) Multiply(b *Matrix) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _res Matrix

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	C.graphene_matrix_multiply(_arg0, _arg1, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// Near compares the two given #graphene_matrix_t matrices and checks whether
// their values are within the given @epsilon of each other.
func (a *Matrix) Near(b *Matrix, epsilon float32) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 C.float              // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_matrix_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Normalize normalizes the given #graphene_matrix_t.
func (m *Matrix) Normalize() Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _res Matrix

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_normalize(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// Perspective applies a perspective of @depth to the matrix.
func (m *Matrix) Perspective(depth float32) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _res Matrix

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(depth)

	C.graphene_matrix_perspective(_arg0, _arg1, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// Print prints the contents of a matrix to the standard error stream.
//
// This function is only useful for debugging; there are no guarantees made on
// the format of the output.
func (m *Matrix) Print() {
	var _arg0 *C.graphene_matrix_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_print(_arg0)
}

// ProjectPoint projects a #graphene_point_t using the matrix @m.
func (m *Matrix) ProjectPoint(p *Point) Point {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _res Point

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_project_point(_arg0, _arg1, (*C.graphene_point_t)(unsafe.Pointer(&_res)))

	return _res
}

// ProjectRect projects all corners of a #graphene_rect_t using the given
// matrix.
//
// See also: graphene_matrix_project_point()
func (m *Matrix) ProjectRect(r *Rect) Quad {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _res Quad

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_project_rect(_arg0, _arg1, (*C.graphene_quad_t)(unsafe.Pointer(&_res)))

	return _res
}

// ProjectRectBounds projects a #graphene_rect_t using the given matrix.
//
// The resulting rectangle is the axis aligned bounding rectangle capable of
// fully containing the projected rectangle.
func (m *Matrix) ProjectRectBounds(r *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _res Rect

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_project_rect_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Rotate adds a rotation transformation to @m, using the given @angle and @axis
// vector.
//
// This is the equivalent of calling graphene_matrix_init_rotate() and then
// multiplying the matrix @m with the rotation matrix.
func (m *Matrix) Rotate(angle float32, axis *Vec3) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 *C.graphene_vec3_t   // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.graphene_matrix_rotate(_arg0, _arg1, _arg2)
}

// RotateEuler adds a rotation transformation to @m, using the given
// #graphene_euler_t.
func (m *Matrix) RotateEuler(e *Euler) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_euler_t  // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_matrix_rotate_euler(_arg0, _arg1)
}

// RotateQuaternion adds a rotation transformation to @m, using the given
// #graphene_quaternion_t.
//
// This is the equivalent of calling graphene_quaternion_to_matrix() and then
// multiplying @m with the rotation matrix.
func (m *Matrix) RotateQuaternion(q *Quaternion) {
	var _arg0 *C.graphene_matrix_t     // out
	var _arg1 *C.graphene_quaternion_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_matrix_rotate_quaternion(_arg0, _arg1)
}

// RotateX adds a rotation transformation around the X axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateX(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(angle)

	C.graphene_matrix_rotate_x(_arg0, _arg1)
}

// RotateY adds a rotation transformation around the Y axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateY(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(angle)

	C.graphene_matrix_rotate_y(_arg0, _arg1)
}

// RotateZ adds a rotation transformation around the Z axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateZ(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(angle)

	C.graphene_matrix_rotate_z(_arg0, _arg1)
}

// Scale adds a scaling transformation to @m, using the three given factors.
//
// This is the equivalent of calling graphene_matrix_init_scale() and then
// multiplying the matrix @m with the scale matrix.
func (m *Matrix) Scale(factorX float32, factorY float32, factorZ float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(factorX)
	_arg2 = (C.float)(factorY)
	_arg3 = (C.float)(factorZ)

	C.graphene_matrix_scale(_arg0, _arg1, _arg2, _arg3)
}

// SkewXY adds a skew of @factor on the X and Y axis to the given matrix.
func (m *Matrix) SkewXY(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_matrix_skew_xy(_arg0, _arg1)
}

// SkewXZ adds a skew of @factor on the X and Z axis to the given matrix.
func (m *Matrix) SkewXZ(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_matrix_skew_xz(_arg0, _arg1)
}

// SkewYZ adds a skew of @factor on the Y and Z axis to the given matrix.
func (m *Matrix) SkewYZ(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_matrix_skew_yz(_arg0, _arg1)
}

// To2D converts a #graphene_matrix_t to an affine transformation matrix, if the
// given matrix is compatible.
//
// The returned values have the following layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between a #graphene_matrix_t and an
// affine matrix type from other libraries.
func (m *Matrix) To2D() (xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64, ok bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.double             // in
	var _arg2 C.double             // in
	var _arg3 C.double             // in
	var _arg4 C.double             // in
	var _arg5 C.double             // in
	var _arg6 C.double             // in
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _xx float64 // out
	var _yx float64 // out
	var _xy float64 // out
	var _yy float64 // out
	var _x0 float64 // out
	var _y0 float64 // out
	var _ok bool    // out

	_xx = (float64)(_arg1)
	_yx = (float64)(_arg2)
	_xy = (float64)(_arg3)
	_yy = (float64)(_arg4)
	_x0 = (float64)(_arg5)
	_y0 = (float64)(_arg6)
	if _cret {
		_ok = true
	}

	return _xx, _yx, _xy, _yy, _x0, _y0, _ok
}

// ToFloat converts a #graphene_matrix_t to an array of floating point values.
func (m *Matrix) ToFloat() [16]float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 [16]C.float

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_to_float(_arg0, &_arg1[0])

	var _v [16]float32

	_v = *(*[16]float32)(unsafe.Pointer(&_arg1))

	return _v
}

// TransformBounds transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is the axis aligned bounding rectangle containing the coplanar
// quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformBounds(r *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _res Rect

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformBox transforms the vertices of a #graphene_box_t using the given
// matrix @m.
//
// The result is the axis aligned bounding box containing the transformed
// vertices.
func (m *Matrix) TransformBox(b *Box) Box {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_box_t    // out
	var _res Box

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_matrix_transform_box(_arg0, _arg1, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformPoint transforms the given #graphene_point_t using the matrix @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint(p *Point) Point {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _res Point

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_transform_point(_arg0, _arg1, (*C.graphene_point_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformPoint3D transforms the given #graphene_point3d_t using the matrix
// @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint3D(p *Point3D) Point3D {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _res Point3D

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_transform_point3d(_arg0, _arg1, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformRay: transform a #graphene_ray_t using the given matrix @m.
func (m *Matrix) TransformRay(r *Ray) Ray {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_ray_t    // out
	var _res Ray

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_ray(_arg0, _arg1, (*C.graphene_ray_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformRect transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is a coplanar quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformRect(r *Rect) Quad {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _res Quad

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_rect(_arg0, _arg1, (*C.graphene_quad_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformSphere transforms a #graphene_sphere_t using the given matrix @m.
// The result is the bounding sphere containing the transformed sphere.
func (m *Matrix) TransformSphere(s *Sphere) Sphere {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_sphere_t // out
	var _res Sphere

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	C.graphene_matrix_transform_sphere(_arg0, _arg1, (*C.graphene_sphere_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformVec3 transforms the given #graphene_vec3_t using the matrix @m.
//
// This function will multiply the X, Y, and Z row vectors of the matrix @m with
// the corresponding components of the vector @v. The W row vector will be
// ignored.
//
// See also: graphene_simd4x4f_vec3_mul()
func (m *Matrix) TransformVec3(v *Vec3) Vec3 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec3_t   // out
	var _res Vec3

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_matrix_transform_vec3(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// TransformVec4 transforms the given #graphene_vec4_t using the matrix @m.
//
// See also: graphene_simd4x4f_vec4_mul()
func (m *Matrix) TransformVec4(v *Vec4) Vec4 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec4_t   // out
	var _res Vec4

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_matrix_transform_vec4(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Translate adds a translation transformation to @m using the coordinates of
// the given #graphene_point3d_t.
//
// This is the equivalent of calling graphene_matrix_init_translate() and then
// multiplying @m with the translation matrix.
func (m *Matrix) Translate(pos *Point3D) {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(pos.Native()))

	C.graphene_matrix_translate(_arg0, _arg1)
}

// Transpose transposes the given matrix.
func (m *Matrix) Transpose() Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _res Matrix

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_transpose(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_res)))

	return _res
}

// UnprojectPoint3D unprojects the given @point using the @projection matrix and
// a @modelview matrix.
func (p *Matrix) UnprojectPoint3D(modelview *Matrix, point *Point3D) Point3D {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_matrix_t  // out
	var _arg2 *C.graphene_point3d_t // out
	var _res Point3D

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(modelview.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.graphene_matrix_unproject_point3d(_arg0, _arg1, _arg2, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// UntransformBounds undoes the transformation on the corners of a
// #graphene_rect_t using the given matrix, within the given axis aligned
// rectangular @bounds.
func (m *Matrix) UntransformBounds(r *Rect, bounds *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 *C.graphene_rect_t   // out
	var _res Rect

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.graphene_matrix_untransform_bounds(_arg0, _arg1, _arg2, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// UntransformPoint undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UntransformPoint(p *Point, bounds *Rect) (Point, bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _arg2 *C.graphene_rect_t   // out
	var _res Point
	var _cret C._Bool // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.graphene_matrix_untransform_point(_arg0, _arg1, _arg2, (*C.graphene_point_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Plane: a 2D plane that extends infinitely in a 3D volume.
//
// The contents of the `graphene_plane_t` are private, and should not be
// modified directly.
type Plane struct {
	native C.graphene_plane_t
}

// WrapPlane wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPlane(ptr unsafe.Pointer) *Plane {
	if ptr == nil {
		return nil
	}

	return (*Plane)(ptr)
}

func marshalPlane(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPlane(unsafe.Pointer(b)), nil
}

// NewPlaneAlloc constructs a struct Plane.
func NewPlaneAlloc() *Plane {
	var _cret *C.graphene_plane_t // in

	_cret = C.graphene_plane_alloc()

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_plane, func(v *Plane) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _plane
}

// Native returns the underlying C source pointer.
func (p *Plane) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Distance computes the distance of @point from a #graphene_plane_t.
func (p *Plane) Distance(point *Point3D) float32 {
	var _arg0 *C.graphene_plane_t   // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C.float               // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_plane_distance(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the two given #graphene_plane_t are equal.
func (a *Plane) Equal(b *Plane) bool {
	var _arg0 *C.graphene_plane_t // out
	var _arg1 *C.graphene_plane_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_plane_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_plane_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_plane_alloc().
func (p *Plane) Free() {
	var _arg0 *C.graphene_plane_t // out

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	C.graphene_plane_free(_arg0)
}

// Constant retrieves the distance along the normal vector of the given
// #graphene_plane_t from the origin.
func (p *Plane) Constant() float32 {
	var _arg0 *C.graphene_plane_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_plane_get_constant(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Normal retrieves the normal vector pointing towards the origin of the given
// #graphene_plane_t.
func (p *Plane) Normal() Vec3 {
	var _arg0 *C.graphene_plane_t // out
	var _normal Vec3

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	C.graphene_plane_get_normal(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_normal)))

	return _normal
}

// Init initializes the given #graphene_plane_t using the given @normal vector
// and @constant values.
func (p *Plane) Init(normal *Vec3, constant float32) *Plane {
	var _arg0 *C.graphene_plane_t // out
	var _arg1 *C.graphene_vec3_t  // out
	var _arg2 C.float             // out
	var _cret *C.graphene_plane_t // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(normal.Native()))
	_arg2 = (C.float)(constant)

	_cret = C.graphene_plane_init(_arg0, _arg1, _arg2)

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))

	return _plane
}

// InitFromPlane initializes the given #graphene_plane_t using the normal vector
// and constant of another #graphene_plane_t.
func (p *Plane) InitFromPlane(src *Plane) *Plane {
	var _arg0 *C.graphene_plane_t // out
	var _arg1 *C.graphene_plane_t // out
	var _cret *C.graphene_plane_t // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_plane_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_plane_init_from_plane(_arg0, _arg1)

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))

	return _plane
}

// InitFromPoint initializes the given #graphene_plane_t using the given normal
// vector and an arbitrary co-planar point.
func (p *Plane) InitFromPoint(normal *Vec3, point *Point3D) *Plane {
	var _arg0 *C.graphene_plane_t   // out
	var _arg1 *C.graphene_vec3_t    // out
	var _arg2 *C.graphene_point3d_t // out
	var _cret *C.graphene_plane_t   // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(normal.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_plane_init_from_point(_arg0, _arg1, _arg2)

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))

	return _plane
}

// InitFromPoints initializes the given #graphene_plane_t using the 3 provided
// co-planar points.
//
// The winding order is counter-clockwise, and determines which direction the
// normal vector will point.
func (p *Plane) InitFromPoints(a *Point3D, b *Point3D, c *Point3D) *Plane {
	var _arg0 *C.graphene_plane_t   // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 *C.graphene_point3d_t // out
	var _arg3 *C.graphene_point3d_t // out
	var _cret *C.graphene_plane_t   // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))
	_arg3 = (*C.graphene_point3d_t)(unsafe.Pointer(c.Native()))

	_cret = C.graphene_plane_init_from_points(_arg0, _arg1, _arg2, _arg3)

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))

	return _plane
}

// InitFromVec4 initializes the given #graphene_plane_t using the components of
// the given #graphene_vec4_t vector.
func (p *Plane) InitFromVec4(src *Vec4) *Plane {
	var _arg0 *C.graphene_plane_t // out
	var _arg1 *C.graphene_vec4_t  // out
	var _cret *C.graphene_plane_t // in

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_plane_init_from_vec4(_arg0, _arg1)

	var _plane *Plane // out

	_plane = WrapPlane(unsafe.Pointer(_cret))

	return _plane
}

// Negate negates the normal vector and constant of a #graphene_plane_t,
// effectively mirroring the plane across the origin.
func (p *Plane) Negate() Plane {
	var _arg0 *C.graphene_plane_t // out
	var _res Plane

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	C.graphene_plane_negate(_arg0, (*C.graphene_plane_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normalize normalizes the vector of the given #graphene_plane_t, and adjusts
// the constant accordingly.
func (p *Plane) Normalize() Plane {
	var _arg0 *C.graphene_plane_t // out
	var _res Plane

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	C.graphene_plane_normalize(_arg0, (*C.graphene_plane_t)(unsafe.Pointer(&_res)))

	return _res
}

// Transform transforms a #graphene_plane_t @p using the given @matrix and
// @normal_matrix.
//
// If @normal_matrix is nil, a transformation matrix for the plane normal will
// be computed from @matrix. If you are transforming multiple planes using the
// same @matrix it's recommended to compute the normal matrix beforehand to
// avoid incurring in the cost of recomputing it every time.
func (p *Plane) Transform(matrix *Matrix, normalMatrix *Matrix) Plane {
	var _arg0 *C.graphene_plane_t  // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 *C.graphene_matrix_t // out
	var _res Plane

	_arg0 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))
	_arg2 = (*C.graphene_matrix_t)(unsafe.Pointer(normalMatrix.Native()))

	C.graphene_plane_transform(_arg0, _arg1, _arg2, (*C.graphene_plane_t)(unsafe.Pointer(&_res)))

	return _res
}

// Point: a point with two coordinates.
type Point struct {
	native C.graphene_point_t
}

// WrapPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPoint(ptr unsafe.Pointer) *Point {
	if ptr == nil {
		return nil
	}

	return (*Point)(ptr)
}

func marshalPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPoint(unsafe.Pointer(b)), nil
}

// NewPointAlloc constructs a struct Point.
func NewPointAlloc() *Point {
	var _cret *C.graphene_point_t // in

	_cret = C.graphene_point_alloc()

	var _point *Point // out

	_point = WrapPoint(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_point, func(v *Point) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _point
}

// Native returns the underlying C source pointer.
func (p *Point) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Distance computes the distance between @a and @b.
func (a *Point) Distance(b *Point) (dX float32, dY float32, gfloat float32) {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 C.float             // in
	var _arg3 C.float             // in
	var _cret C.float             // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_point_distance(_arg0, _arg1, &_arg2, &_arg3)

	var _dX float32     // out
	var _dY float32     // out
	var _gfloat float32 // out

	_dX = (float32)(_arg2)
	_dY = (float32)(_arg3)
	_gfloat = (float32)(_cret)

	return _dX, _dY, _gfloat
}

// Equal checks if the two points @a and @b point to the same coordinates.
//
// This function accounts for floating point fluctuations; if you want to
// control the fuzziness of the match, you can use graphene_point_near()
// instead.
func (a *Point) Equal(b *Point) bool {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_point_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_point_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_point_alloc().
func (p *Point) Free() {
	var _arg0 *C.graphene_point_t // out

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_point_free(_arg0)
}

// Init initializes @p to the given @x and @y coordinates.
//
// It's safe to call this function multiple times.
func (p *Point) Init(x float32, y float32) *Point {
	var _arg0 *C.graphene_point_t // out
	var _arg1 C.float             // out
	var _arg2 C.float             // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)

	_cret = C.graphene_point_init(_arg0, _arg1, _arg2)

	var _point *Point // out

	_point = WrapPoint(unsafe.Pointer(_cret))

	return _point
}

// InitFromPoint initializes @p with the same coordinates of @src.
func (p *Point) InitFromPoint(src *Point) *Point {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_point_t // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_point_init_from_point(_arg0, _arg1)

	var _point *Point // out

	_point = WrapPoint(unsafe.Pointer(_cret))

	return _point
}

// InitFromVec2 initializes @p with the coordinates inside the given
// #graphene_vec2_t.
func (p *Point) InitFromVec2(src *Vec2) *Point {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_vec2_t  // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_point_init_from_vec2(_arg0, _arg1)

	var _point *Point // out

	_point = WrapPoint(unsafe.Pointer(_cret))

	return _point
}

// Interpolate: linearly interpolates the coordinates of @a and @b using the
// given @factor.
func (a *Point) Interpolate(b *Point, factor float64) Point {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 C.double            // out
	var _res Point

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_point_interpolate(_arg0, _arg1, _arg2, (*C.graphene_point_t)(unsafe.Pointer(&_res)))

	return _res
}

// Near checks whether the two points @a and @b are within the threshold of
// @epsilon.
func (a *Point) Near(b *Point, epsilon float32) bool {
	var _arg0 *C.graphene_point_t // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 C.float             // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_point_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// ToVec2 stores the coordinates of the given #graphene_point_t into a
// #graphene_vec2_t.
func (p *Point) ToVec2() Vec2 {
	var _arg0 *C.graphene_point_t // out
	var _v Vec2

	_arg0 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_point_to_vec2(_arg0, (*C.graphene_vec2_t)(unsafe.Pointer(&_v)))

	return _v
}

// Point3D: a point with three components: X, Y, and Z.
type Point3D struct {
	native C.graphene_point3d_t
}

// WrapPoint3D wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPoint3D(ptr unsafe.Pointer) *Point3D {
	if ptr == nil {
		return nil
	}

	return (*Point3D)(ptr)
}

func marshalPoint3D(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPoint3D(unsafe.Pointer(b)), nil
}

// NewPoint3DAlloc constructs a struct Point3D.
func NewPoint3DAlloc() *Point3D {
	var _cret *C.graphene_point3d_t // in

	_cret = C.graphene_point3d_alloc()

	var _point3D *Point3D // out

	_point3D = WrapPoint3D(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_point3D, func(v *Point3D) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _point3D
}

// Native returns the underlying C source pointer.
func (p *Point3D) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Cross computes the cross product of the two given #graphene_point3d_t.
func (a *Point3D) Cross(b *Point3D) Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _res Point3D

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))

	C.graphene_point3d_cross(_arg0, _arg1, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// Distance computes the distance between the two given #graphene_point3d_t.
func (a *Point3D) Distance(b *Point3D) (Vec3, float32) {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _delta Vec3
	var _cret C.float // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_point3d_distance(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_delta)))

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _delta, _gfloat
}

// Dot computes the dot product of the two given #graphene_point3d_t.
func (a *Point3D) Dot(b *Point3D) float32 {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C.float               // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_point3d_dot(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether two given points are equal.
func (a *Point3D) Equal(b *Point3D) bool {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_point3d_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated via graphene_point3d_alloc().
func (p *Point3D) Free() {
	var _arg0 *C.graphene_point3d_t // out

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_point3d_free(_arg0)
}

// Init initializes a #graphene_point3d_t with the given coordinates.
func (p *Point3D) Init(x float32, y float32, z float32) *Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 C.float               // out
	var _arg2 C.float               // out
	var _arg3 C.float               // out
	var _cret *C.graphene_point3d_t // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)

	_cret = C.graphene_point3d_init(_arg0, _arg1, _arg2, _arg3)

	var _point3D *Point3D // out

	_point3D = WrapPoint3D(unsafe.Pointer(_cret))

	return _point3D
}

// InitFromPoint initializes a #graphene_point3d_t using the coordinates of
// another #graphene_point3d_t.
func (p *Point3D) InitFromPoint(src *Point3D) *Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.graphene_point3d_t // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_point3d_init_from_point(_arg0, _arg1)

	var _point3D *Point3D // out

	_point3D = WrapPoint3D(unsafe.Pointer(_cret))

	return _point3D
}

// InitFromVec3 initializes a #graphene_point3d_t using the components of a
// #graphene_vec3_t.
func (p *Point3D) InitFromVec3(v *Vec3) *Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_vec3_t    // out
	var _cret *C.graphene_point3d_t // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_point3d_init_from_vec3(_arg0, _arg1)

	var _point3D *Point3D // out

	_point3D = WrapPoint3D(unsafe.Pointer(_cret))

	return _point3D
}

// Interpolate: linearly interpolates each component of @a and @b using the
// provided @factor, and places the result in @res.
func (a *Point3D) Interpolate(b *Point3D, factor float64) Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 C.double              // out
	var _res Point3D

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_point3d_interpolate(_arg0, _arg1, _arg2, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// Length computes the length of the vector represented by the coordinates of
// the given #graphene_point3d_t.
func (p *Point3D) Length() float32 {
	var _arg0 *C.graphene_point3d_t // out
	var _cret C.float               // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_point3d_length(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Near checks whether the two points are near each other, within an @epsilon
// factor.
func (a *Point3D) Near(b *Point3D, epsilon float32) bool {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 C.float               // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_point3d_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Normalize computes the normalization of the vector represented by the
// coordinates of the given #graphene_point3d_t.
func (p *Point3D) Normalize() Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _res Point3D

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_point3d_normalize(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// NormalizeViewport normalizes the coordinates of a #graphene_point3d_t using
// the given viewport and clipping planes.
//
// The coordinates of the resulting #graphene_point3d_t will be in the [ -1, 1 ]
// range.
func (p *Point3D) NormalizeViewport(viewport *Rect, zNear float32, zFar float32) Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 *C.graphene_rect_t    // out
	var _arg2 C.float               // out
	var _arg3 C.float               // out
	var _res Point3D

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(viewport.Native()))
	_arg2 = (C.float)(zNear)
	_arg3 = (C.float)(zFar)

	C.graphene_point3d_normalize_viewport(_arg0, _arg1, _arg2, _arg3, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale scales the coordinates of the given #graphene_point3d_t by the given
// @factor.
func (p *Point3D) Scale(factor float32) Point3D {
	var _arg0 *C.graphene_point3d_t // out
	var _arg1 C.float               // out
	var _res Point3D

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_point3d_scale(_arg0, _arg1, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToVec3 stores the coordinates of a #graphene_point3d_t into a
// #graphene_vec3_t.
func (p *Point3D) ToVec3() Vec3 {
	var _arg0 *C.graphene_point3d_t // out
	var _v Vec3

	_arg0 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_point3d_to_vec3(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_v)))

	return _v
}

// Quad: a 4 vertex quadrilateral, as represented by four #graphene_point_t.
//
// The contents of a #graphene_quad_t are private and should never be accessed
// directly.
type Quad struct {
	native C.graphene_quad_t
}

// WrapQuad wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQuad(ptr unsafe.Pointer) *Quad {
	if ptr == nil {
		return nil
	}

	return (*Quad)(ptr)
}

func marshalQuad(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQuad(unsafe.Pointer(b)), nil
}

// NewQuadAlloc constructs a struct Quad.
func NewQuadAlloc() *Quad {
	var _cret *C.graphene_quad_t // in

	_cret = C.graphene_quad_alloc()

	var _quad *Quad // out

	_quad = WrapQuad(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_quad, func(v *Quad) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _quad
}

// Native returns the underlying C source pointer.
func (q *Quad) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Bounds computes the bounding rectangle of @q and places it into @r.
func (q *Quad) Bounds() Rect {
	var _arg0 *C.graphene_quad_t // out
	var _r Rect

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))

	C.graphene_quad_bounds(_arg0, (*C.graphene_rect_t)(unsafe.Pointer(&_r)))

	return _r
}

// Contains checks if the given #graphene_quad_t contains the given
// #graphene_point_t.
func (q *Quad) Contains(p *Point) bool {
	var _arg0 *C.graphene_quad_t  // out
	var _arg1 *C.graphene_point_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_quad_contains(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_quad_alloc()
func (q *Quad) Free() {
	var _arg0 *C.graphene_quad_t // out

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))

	C.graphene_quad_free(_arg0)
}

// Point retrieves the point of a #graphene_quad_t at the given index.
func (q *Quad) Point(index_ uint) *Point {
	var _arg0 *C.graphene_quad_t  // out
	var _arg1 C.uint              // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.uint)(index_)

	_cret = C.graphene_quad_get_point(_arg0, _arg1)

	var _point *Point // out

	_point = WrapPoint(unsafe.Pointer(_cret))

	return _point
}

// Init initializes a #graphene_quad_t with the given points.
func (q *Quad) Init(p1 *Point, p2 *Point, p3 *Point, p4 *Point) *Quad {
	var _arg0 *C.graphene_quad_t  // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.graphene_quad_t  // in

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p1.Native()))
	_arg2 = (*C.graphene_point_t)(unsafe.Pointer(p2.Native()))
	_arg3 = (*C.graphene_point_t)(unsafe.Pointer(p3.Native()))
	_arg4 = (*C.graphene_point_t)(unsafe.Pointer(p4.Native()))

	_cret = C.graphene_quad_init(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _quad *Quad // out

	_quad = WrapQuad(unsafe.Pointer(_cret))

	return _quad
}

// InitFromPoints initializes a #graphene_quad_t using an array of points.
func (q *Quad) InitFromPoints(points [4]Point) *Quad {
	var _arg0 *C.graphene_quad_t // out
	var _arg1 *C.graphene_point_t
	var _cret *C.graphene_quad_t // in

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(&points))

	_cret = C.graphene_quad_init_from_points(_arg0, _arg1)

	var _quad *Quad // out

	_quad = WrapQuad(unsafe.Pointer(_cret))

	return _quad
}

// InitFromRect initializes a #graphene_quad_t using the four corners of the
// given #graphene_rect_t.
func (q *Quad) InitFromRect(r *Rect) *Quad {
	var _arg0 *C.graphene_quad_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.graphene_quad_t // in

	_arg0 = (*C.graphene_quad_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_quad_init_from_rect(_arg0, _arg1)

	var _quad *Quad // out

	_quad = WrapQuad(unsafe.Pointer(_cret))

	return _quad
}

// Quaternion: a quaternion.
//
// The contents of the #graphene_quaternion_t structure are private and should
// never be accessed directly.
type Quaternion struct {
	native C.graphene_quaternion_t
}

// WrapQuaternion wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQuaternion(ptr unsafe.Pointer) *Quaternion {
	if ptr == nil {
		return nil
	}

	return (*Quaternion)(ptr)
}

func marshalQuaternion(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQuaternion(unsafe.Pointer(b)), nil
}

// NewQuaternionAlloc constructs a struct Quaternion.
func NewQuaternionAlloc() *Quaternion {
	var _cret *C.graphene_quaternion_t // in

	_cret = C.graphene_quaternion_alloc()

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_quaternion, func(v *Quaternion) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _quaternion
}

// Native returns the underlying C source pointer.
func (q *Quaternion) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Add adds two #graphene_quaternion_t @a and @b.
func (a *Quaternion) Add(b *Quaternion) Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	C.graphene_quaternion_add(_arg0, _arg1, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// Dot computes the dot product of two #graphene_quaternion_t.
func (a *Quaternion) Dot(b *Quaternion) float32 {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _cret C.float                  // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_quaternion_dot(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the given quaternions are equal.
func (a *Quaternion) Equal(b *Quaternion) bool {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _cret C._Bool                  // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_quaternion_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free releases the resources allocated by graphene_quaternion_alloc().
func (q *Quaternion) Free() {
	var _arg0 *C.graphene_quaternion_t // out

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_free(_arg0)
}

// Init initializes a #graphene_quaternion_t using the given four values.
func (q *Quaternion) Init(x float32, y float32, z float32, w float32) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _arg4 C.float                  // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)
	_arg4 = (C.float)(w)

	_cret = C.graphene_quaternion_init(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromAngleVec3 initializes a #graphene_quaternion_t using an @angle on a
// specific @axis.
func (q *Quaternion) InitFromAngleVec3(angle float32, axis *Vec3) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // out
	var _arg2 *C.graphene_vec3_t       // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.float)(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	_cret = C.graphene_quaternion_init_from_angle_vec3(_arg0, _arg1, _arg2)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromAngles initializes a #graphene_quaternion_t using the values of the
// Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
//
// See also: graphene_quaternion_init_from_euler()
func (q *Quaternion) InitFromAngles(degX float32, degY float32, degZ float32) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.float)(degX)
	_arg2 = (C.float)(degY)
	_arg3 = (C.float)(degZ)

	_cret = C.graphene_quaternion_init_from_angles(_arg0, _arg1, _arg2, _arg3)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromEuler initializes a #graphene_quaternion_t using the given
// #graphene_euler_t.
func (q *Quaternion) InitFromEuler(e *Euler) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_euler_t      // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	_cret = C.graphene_quaternion_init_from_euler(_arg0, _arg1)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromMatrix initializes a #graphene_quaternion_t using the rotation
// components of a transformation matrix.
func (q *Quaternion) InitFromMatrix(m *Matrix) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_matrix_t     // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_quaternion_init_from_matrix(_arg0, _arg1)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromQuaternion initializes a #graphene_quaternion_t with the values from
// @src.
func (q *Quaternion) InitFromQuaternion(src *Quaternion) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_quaternion_init_from_quaternion(_arg0, _arg1)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromRadians initializes a #graphene_quaternion_t using the values of the
// Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
//
// See also: graphene_quaternion_init_from_euler()
func (q *Quaternion) InitFromRadians(radX float32, radY float32, radZ float32) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // out
	var _arg2 C.float                  // out
	var _arg3 C.float                  // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.float)(radX)
	_arg2 = (C.float)(radY)
	_arg3 = (C.float)(radZ)

	_cret = C.graphene_quaternion_init_from_radians(_arg0, _arg1, _arg2, _arg3)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitFromVec4 initializes a #graphene_quaternion_t with the values from @src.
func (q *Quaternion) InitFromVec4(src *Vec4) *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_vec4_t       // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_quaternion_init_from_vec4(_arg0, _arg1)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// InitIdentity initializes a #graphene_quaternion_t using the identity
// transformation.
func (q *Quaternion) InitIdentity() *Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _cret *C.graphene_quaternion_t // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	_cret = C.graphene_quaternion_init_identity(_arg0)

	var _quaternion *Quaternion // out

	_quaternion = WrapQuaternion(unsafe.Pointer(_cret))

	return _quaternion
}

// Invert inverts a #graphene_quaternion_t, and returns the conjugate quaternion
// of @q.
func (q *Quaternion) Invert() Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_invert(_arg0, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// Multiply multiplies two #graphene_quaternion_t @a and @b.
func (a *Quaternion) Multiply(b *Quaternion) Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	C.graphene_quaternion_multiply(_arg0, _arg1, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normalize normalizes a #graphene_quaternion_t.
func (q *Quaternion) Normalize() Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_normalize(_arg0, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale scales all the elements of a #graphene_quaternion_t @q using the given
// scalar factor.
func (q *Quaternion) Scale(factor float32) Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_quaternion_scale(_arg0, _arg1, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// Slerp interpolates between the two given quaternions using a spherical linear
// interpolation, or SLERP (http://en.wikipedia.org/wiki/Slerp), using the given
// interpolation @factor.
func (a *Quaternion) Slerp(b *Quaternion, factor float32) Quaternion {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 *C.graphene_quaternion_t // out
	var _arg2 C.float                  // out
	var _res Quaternion

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.float)(factor)

	C.graphene_quaternion_slerp(_arg0, _arg1, _arg2, (*C.graphene_quaternion_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToAngleVec3 converts a quaternion into an @angle, @axis pair.
func (q *Quaternion) ToAngleVec3() (float32, Vec3) {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // in
	var _axis Vec3

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_to_angle_vec3(_arg0, &_arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_axis)))

	var _angle float32 // out

	_angle = (float32)(_arg1)

	return _angle, _axis
}

// ToAngles converts a #graphene_quaternion_t to its corresponding rotations on
// the Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
func (q *Quaternion) ToAngles() (degX float32, degY float32, degZ float32) {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // in
	var _arg2 C.float                  // in
	var _arg3 C.float                  // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_to_angles(_arg0, &_arg1, &_arg2, &_arg3)

	var _degX float32 // out
	var _degY float32 // out
	var _degZ float32 // out

	_degX = (float32)(_arg1)
	_degY = (float32)(_arg2)
	_degZ = (float32)(_arg3)

	return _degX, _degY, _degZ
}

// ToMatrix converts a quaternion into a transformation matrix expressing the
// rotation defined by the #graphene_quaternion_t.
func (q *Quaternion) ToMatrix() Matrix {
	var _arg0 *C.graphene_quaternion_t // out
	var _m Matrix

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_to_matrix(_arg0, (*C.graphene_matrix_t)(unsafe.Pointer(&_m)))

	return _m
}

// ToRadians converts a #graphene_quaternion_t to its corresponding rotations on
// the Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
func (q *Quaternion) ToRadians() (radX float32, radY float32, radZ float32) {
	var _arg0 *C.graphene_quaternion_t // out
	var _arg1 C.float                  // in
	var _arg2 C.float                  // in
	var _arg3 C.float                  // in

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_to_radians(_arg0, &_arg1, &_arg2, &_arg3)

	var _radX float32 // out
	var _radY float32 // out
	var _radZ float32 // out

	_radX = (float32)(_arg1)
	_radY = (float32)(_arg2)
	_radZ = (float32)(_arg3)

	return _radX, _radY, _radZ
}

// ToVec4 copies the components of a #graphene_quaternion_t into a
// #graphene_vec4_t.
func (q *Quaternion) ToVec4() Vec4 {
	var _arg0 *C.graphene_quaternion_t // out
	var _res Vec4

	_arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_to_vec4(_arg0, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Ray: a ray emitted from an origin in a given direction.
//
// The contents of the `graphene_ray_t` structure are private, and should not be
// modified directly.
type Ray struct {
	native C.graphene_ray_t
}

// WrapRay wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRay(ptr unsafe.Pointer) *Ray {
	if ptr == nil {
		return nil
	}

	return (*Ray)(ptr)
}

func marshalRay(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRay(unsafe.Pointer(b)), nil
}

// NewRayAlloc constructs a struct Ray.
func NewRayAlloc() *Ray {
	var _cret *C.graphene_ray_t // in

	_cret = C.graphene_ray_alloc()

	var _ray *Ray // out

	_ray = WrapRay(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ray, func(v *Ray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ray
}

// Native returns the underlying C source pointer.
func (r *Ray) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Equal checks whether the two given #graphene_ray_t are equal.
func (a *Ray) Equal(b *Ray) bool {
	var _arg0 *C.graphene_ray_t // out
	var _arg1 *C.graphene_ray_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_ray_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_ray_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_ray_alloc().
func (r *Ray) Free() {
	var _arg0 *C.graphene_ray_t // out

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	C.graphene_ray_free(_arg0)
}

// ClosestPointToPoint computes the point on the given #graphene_ray_t that is
// closest to the given point @p.
func (r *Ray) ClosestPointToPoint(p *Point3D) Point3D {
	var _arg0 *C.graphene_ray_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _res Point3D

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_ray_get_closest_point_to_point(_arg0, _arg1, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// Direction retrieves the direction of the given #graphene_ray_t.
func (r *Ray) Direction() Vec3 {
	var _arg0 *C.graphene_ray_t // out
	var _direction Vec3

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	C.graphene_ray_get_direction(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_direction)))

	return _direction
}

// DistanceToPlane computes the distance of the origin of the given
// #graphene_ray_t from the given plane.
//
// If the ray does not intersect the plane, this function returns `INFINITY`.
func (r *Ray) DistanceToPlane(p *Plane) float32 {
	var _arg0 *C.graphene_ray_t   // out
	var _arg1 *C.graphene_plane_t // out
	var _cret C.float             // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_plane_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_ray_get_distance_to_plane(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// DistanceToPoint computes the distance of the closest approach between the
// given #graphene_ray_t @r and the point @p.
//
// The closest approach to a ray from a point is the distance between the point
// and the projection of the point on the ray itself.
func (r *Ray) DistanceToPoint(p *Point3D) float32 {
	var _arg0 *C.graphene_ray_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C.float               // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_ray_get_distance_to_point(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Origin retrieves the origin of the given #graphene_ray_t.
func (r *Ray) Origin() Point3D {
	var _arg0 *C.graphene_ray_t // out
	var _origin Point3D

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	C.graphene_ray_get_origin(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_origin)))

	return _origin
}

// PositionAt retrieves the coordinates of a point at the distance @t along the
// given #graphene_ray_t.
func (r *Ray) PositionAt(t float32) Point3D {
	var _arg0 *C.graphene_ray_t // out
	var _arg1 C.float           // out
	var _position Point3D

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(t)

	C.graphene_ray_get_position_at(_arg0, _arg1, (*C.graphene_point3d_t)(unsafe.Pointer(&_position)))

	return _position
}

// Init initializes the given #graphene_ray_t using the given @origin and
// @direction values.
func (r *Ray) Init(origin *Point3D, direction *Vec3) *Ray {
	var _arg0 *C.graphene_ray_t     // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 *C.graphene_vec3_t    // out
	var _cret *C.graphene_ray_t     // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(origin.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(direction.Native()))

	_cret = C.graphene_ray_init(_arg0, _arg1, _arg2)

	var _ray *Ray // out

	_ray = WrapRay(unsafe.Pointer(_cret))

	return _ray
}

// InitFromRay initializes the given #graphene_ray_t using the origin and
// direction values of another #graphene_ray_t.
func (r *Ray) InitFromRay(src *Ray) *Ray {
	var _arg0 *C.graphene_ray_t // out
	var _arg1 *C.graphene_ray_t // out
	var _cret *C.graphene_ray_t // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_ray_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_ray_init_from_ray(_arg0, _arg1)

	var _ray *Ray // out

	_ray = WrapRay(unsafe.Pointer(_cret))

	return _ray
}

// InitFromVec3 initializes the given #graphene_ray_t using the given vectors.
func (r *Ray) InitFromVec3(origin *Vec3, direction *Vec3) *Ray {
	var _arg0 *C.graphene_ray_t  // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 *C.graphene_vec3_t // out
	var _cret *C.graphene_ray_t  // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(origin.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(direction.Native()))

	_cret = C.graphene_ray_init_from_vec3(_arg0, _arg1, _arg2)

	var _ray *Ray // out

	_ray = WrapRay(unsafe.Pointer(_cret))

	return _ray
}

// IntersectBox intersects the given #graphene_ray_t @r with the given
// #graphene_box_t @b.
func (r *Ray) IntersectBox(b *Box) (float32, RayIntersectionKind) {
	var _arg0 *C.graphene_ray_t                  // out
	var _arg1 *C.graphene_box_t                  // out
	var _arg2 C.float                            // in
	var _cret C.graphene_ray_intersection_kind_t // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_ray_intersect_box(_arg0, _arg1, &_arg2)

	var _tOut float32                            // out
	var _rayIntersectionKind RayIntersectionKind // out

	_tOut = (float32)(_arg2)
	_rayIntersectionKind = RayIntersectionKind(_cret)

	return _tOut, _rayIntersectionKind
}

// IntersectSphere intersects the given #graphene_ray_t @r with the given
// #graphene_sphere_t @s.
func (r *Ray) IntersectSphere(s *Sphere) (float32, RayIntersectionKind) {
	var _arg0 *C.graphene_ray_t                  // out
	var _arg1 *C.graphene_sphere_t               // out
	var _arg2 C.float                            // in
	var _cret C.graphene_ray_intersection_kind_t // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	_cret = C.graphene_ray_intersect_sphere(_arg0, _arg1, &_arg2)

	var _tOut float32                            // out
	var _rayIntersectionKind RayIntersectionKind // out

	_tOut = (float32)(_arg2)
	_rayIntersectionKind = RayIntersectionKind(_cret)

	return _tOut, _rayIntersectionKind
}

// IntersectTriangle intersects the given #graphene_ray_t @r with the given
// #graphene_triangle_t @t.
func (r *Ray) IntersectTriangle(t *Triangle) (float32, RayIntersectionKind) {
	var _arg0 *C.graphene_ray_t                  // out
	var _arg1 *C.graphene_triangle_t             // out
	var _arg2 C.float                            // in
	var _cret C.graphene_ray_intersection_kind_t // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	_cret = C.graphene_ray_intersect_triangle(_arg0, _arg1, &_arg2)

	var _tOut float32                            // out
	var _rayIntersectionKind RayIntersectionKind // out

	_tOut = (float32)(_arg2)
	_rayIntersectionKind = RayIntersectionKind(_cret)

	return _tOut, _rayIntersectionKind
}

// IntersectsBox checks whether the given #graphene_ray_t @r intersects the
// given #graphene_box_t @b.
//
// See also: graphene_ray_intersect_box()
func (r *Ray) IntersectsBox(b *Box) bool {
	var _arg0 *C.graphene_ray_t // out
	var _arg1 *C.graphene_box_t // out
	var _cret C._Bool           // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_ray_intersects_box(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IntersectsSphere checks if the given #graphene_ray_t @r intersects the given
// #graphene_sphere_t @s.
//
// See also: graphene_ray_intersect_sphere()
func (r *Ray) IntersectsSphere(s *Sphere) bool {
	var _arg0 *C.graphene_ray_t    // out
	var _arg1 *C.graphene_sphere_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	_cret = C.graphene_ray_intersects_sphere(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IntersectsTriangle checks whether the given #graphene_ray_t @r intersects the
// given #graphene_triangle_t @b.
//
// See also: graphene_ray_intersect_triangle()
func (r *Ray) IntersectsTriangle(t *Triangle) bool {
	var _arg0 *C.graphene_ray_t      // out
	var _arg1 *C.graphene_triangle_t // out
	var _cret C._Bool                // in

	_arg0 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	_cret = C.graphene_ray_intersects_triangle(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Rect: the location and size of a rectangle region.
//
// The width and height of a #graphene_rect_t can be negative; for instance, a
// #graphene_rect_t with an origin of [ 0, 0 ] and a size of [ 10, 10 ] is
// equivalent to a #graphene_rect_t with an origin of [ 10, 10 ] and a size of [
// -10, -10 ].
//
// Application code can normalize rectangles using graphene_rect_normalize();
// this function will ensure that the width and height of a rectangle are
// positive values. All functions taking a #graphene_rect_t as an argument will
// internally operate on a normalized copy; all functions returning a
// #graphene_rect_t will always return a normalized rectangle.
type Rect struct {
	native C.graphene_rect_t
}

// WrapRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRect(ptr unsafe.Pointer) *Rect {
	if ptr == nil {
		return nil
	}

	return (*Rect)(ptr)
}

func marshalRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRect(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// ContainsPoint checks whether a #graphene_rect_t contains the given
// coordinates.
func (r *Rect) ContainsPoint(p *Point) bool {
	var _arg0 *C.graphene_rect_t  // out
	var _arg1 *C.graphene_point_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_rect_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainsRect checks whether a #graphene_rect_t fully contains the given
// rectangle.
func (a *Rect) ContainsRect(b *Rect) bool {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_contains_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given rectangle are equal.
func (a *Rect) Equal(b *Rect) bool {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Expand expands a #graphene_rect_t to contain the given #graphene_point_t.
func (r *Rect) Expand(p *Point) Rect {
	var _arg0 *C.graphene_rect_t  // out
	var _arg1 *C.graphene_point_t // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_rect_expand(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Free frees the resources allocated by graphene_rect_alloc().
func (r *Rect) Free() {
	var _arg0 *C.graphene_rect_t // out

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_free(_arg0)
}

// Area: compute the area of given normalized rectangle.
func (r *Rect) Area() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_area(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// BottomLeft retrieves the coordinates of the bottom-left corner of the given
// rectangle.
func (r *Rect) BottomLeft() Point {
	var _arg0 *C.graphene_rect_t // out
	var _p Point

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_bottom_left(_arg0, (*C.graphene_point_t)(unsafe.Pointer(&_p)))

	return _p
}

// BottomRight retrieves the coordinates of the bottom-right corner of the given
// rectangle.
func (r *Rect) BottomRight() Point {
	var _arg0 *C.graphene_rect_t // out
	var _p Point

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_bottom_right(_arg0, (*C.graphene_point_t)(unsafe.Pointer(&_p)))

	return _p
}

// Center retrieves the coordinates of the center of the given rectangle.
func (r *Rect) Center() Point {
	var _arg0 *C.graphene_rect_t // out
	var _p Point

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_center(_arg0, (*C.graphene_point_t)(unsafe.Pointer(&_p)))

	return _p
}

// Height retrieves the normalized height of the given rectangle.
func (r *Rect) Height() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_height(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// TopLeft retrieves the coordinates of the top-left corner of the given
// rectangle.
func (r *Rect) TopLeft() Point {
	var _arg0 *C.graphene_rect_t // out
	var _p Point

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_top_left(_arg0, (*C.graphene_point_t)(unsafe.Pointer(&_p)))

	return _p
}

// TopRight retrieves the coordinates of the top-right corner of the given
// rectangle.
func (r *Rect) TopRight() Point {
	var _arg0 *C.graphene_rect_t // out
	var _p Point

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_top_right(_arg0, (*C.graphene_point_t)(unsafe.Pointer(&_p)))

	return _p
}

// Vertices computes the four vertices of a #graphene_rect_t.
func (r *Rect) Vertices() [4]Vec2 {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 [4]C.graphene_vec2_t

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_vertices(_arg0, &_arg1[0])

	var _vertices [4]Vec2

	_vertices = *(*[4]Vec2)(unsafe.Pointer(&_arg1))

	return _vertices
}

// Width retrieves the normalized width of the given rectangle.
func (r *Rect) Width() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_width(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// X retrieves the normalized X coordinate of the origin of the given rectangle.
func (r *Rect) X() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Y retrieves the normalized Y coordinate of the origin of the given rectangle.
func (r *Rect) Y() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes the given #graphene_rect_t with the given values.
//
// This function will implicitly normalize the #graphene_rect_t before
// returning.
func (r *Rect) Init(x float32, y float32, width float32, height float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.float            // out
	var _arg4 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(width)
	_arg4 = (C.float)(height)

	_cret = C.graphene_rect_init(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// InitFromRect initializes @r using the given @src rectangle.
//
// This function will implicitly normalize the #graphene_rect_t before
// returning.
func (r *Rect) InitFromRect(src *Rect) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_rect_init_from_rect(_arg0, _arg1)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// Inset changes the given rectangle to be smaller, or larger depending on the
// given inset parameters.
//
// To create an inset rectangle, use positive @d_x or @d_y values; to create a
// larger, encompassing rectangle, use negative @d_x or @d_y values.
//
// The origin of the rectangle is offset by @d_x and @d_y, while the size is
// adjusted by `(2 * @d_x, 2 * @d_y)`. If @d_x and @d_y are positive values, the
// size of the rectangle is decreased; if @d_x and @d_y are negative values, the
// size of the rectangle is increased.
//
// If the size of the resulting inset rectangle has a negative width or height
// then the size will be set to zero.
func (r *Rect) Inset(dX float32, dY float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(dX)
	_arg2 = (C.float)(dY)

	_cret = C.graphene_rect_inset(_arg0, _arg1, _arg2)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// InsetR changes the given rectangle to be smaller, or larger depending on the
// given inset parameters.
//
// To create an inset rectangle, use positive @d_x or @d_y values; to create a
// larger, encompassing rectangle, use negative @d_x or @d_y values.
//
// The origin of the rectangle is offset by @d_x and @d_y, while the size is
// adjusted by `(2 * @d_x, 2 * @d_y)`. If @d_x and @d_y are positive values, the
// size of the rectangle is decreased; if @d_x and @d_y are negative values, the
// size of the rectangle is increased.
//
// If the size of the resulting inset rectangle has a negative width or height
// then the size will be set to zero.
func (r *Rect) InsetR(dX float32, dY float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(dX)
	_arg2 = (C.float)(dY)

	C.graphene_rect_inset_r(_arg0, _arg1, _arg2, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Interpolate: linearly interpolates the origin and size of the two given
// rectangles.
func (a *Rect) Interpolate(b *Rect, factor float64) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.double           // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_rect_interpolate(_arg0, _arg1, _arg2, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Intersection computes the intersection of the two given rectangles.
//
// ! (rectangle-intersection.png)
//
// The intersection in the image above is the blue outline.
//
// If the two rectangles do not intersect, @res will contain a degenerate
// rectangle with origin in (0, 0) and a size of 0.
func (a *Rect) Intersection(b *Rect) (Rect, bool) {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _res Rect
	var _cret C._Bool // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_intersection(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Normalize normalizes the passed rectangle.
//
// This function ensures that the size of the rectangle is made of positive
// values, and that the origin is the top-left corner of the rectangle.
func (r *Rect) Normalize() *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_normalize(_arg0)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// NormalizeR normalizes the passed rectangle.
//
// This function ensures that the size of the rectangle is made of positive
// values, and that the origin is in the top-left corner of the rectangle.
func (r *Rect) NormalizeR() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_normalize_r(_arg0, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Offset offsets the origin by @d_x and @d_y.
//
// The size of the rectangle is unchanged.
func (r *Rect) Offset(dX float32, dY float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(dX)
	_arg2 = (C.float)(dY)

	_cret = C.graphene_rect_offset(_arg0, _arg1, _arg2)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// OffsetR offsets the origin of the given rectangle by @d_x and @d_y.
//
// The size of the rectangle is left unchanged.
func (r *Rect) OffsetR(dX float32, dY float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(dX)
	_arg2 = (C.float)(dY)

	C.graphene_rect_offset_r(_arg0, _arg1, _arg2, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Round rounds the origin and size of the given rectangle to their nearest
// integer values; the rounding is guaranteed to be large enough to have an area
// bigger or equal to the original rectangle, but might not fully contain its
// extents. Use graphene_rect_round_extents() in case you need to round to a
// rectangle that covers fully the original one.
//
// This function is the equivalent of calling `floor` on the coordinates of the
// origin, and `ceil` on the size.
func (r *Rect) Round() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_round(_arg0, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// RoundExtents rounds the origin of the given rectangle to its nearest integer
// value and and recompute the size so that the rectangle is large enough to
// contain all the conrners of the original rectangle.
//
// This function is the equivalent of calling `floor` on the coordinates of the
// origin, and recomputing the size calling `ceil` on the bottom-right
// coordinates.
//
// If you want to be sure that the rounded rectangle completely covers the area
// that was covered by the original rectangle — i.e. you want to cover the area
// including all its corners — this function will make sure that the size is
// recomputed taking into account the ceiling of the coordinates of the
// bottom-right corner. If the difference between the original coordinates and
// the coordinates of the rounded rectangle is greater than the difference
// between the original size and and the rounded size, then the move of the
// origin would not be compensated by a move in the anti-origin, leaving the
// corners of the original rectangle outside the rounded one.
func (r *Rect) RoundExtents() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_round_extents(_arg0, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// RoundToPixel rounds the origin and the size of the given rectangle to their
// nearest integer values; the rounding is guaranteed to be large enough to
// contain the original rectangle.
func (r *Rect) RoundToPixel() *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_round_to_pixel(_arg0)

	var _rect *Rect // out

	_rect = WrapRect(unsafe.Pointer(_cret))

	return _rect
}

// Scale scales the size and origin of a rectangle horizontaly by @s_h, and
// vertically by @s_v. The result @res is normalized.
func (r *Rect) Scale(sH float32, sV float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (C.float)(sH)
	_arg2 = (C.float)(sV)

	C.graphene_rect_scale(_arg0, _arg1, _arg2, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

// Union computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Union(b *Rect) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _res Rect

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	C.graphene_rect_union(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_res)))

	return _res
}

type SIMD4F struct {
	native C.graphene_simd4f_t
}

// WrapSIMD4F wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSIMD4F(ptr unsafe.Pointer) *SIMD4F {
	if ptr == nil {
		return nil
	}

	return (*SIMD4F)(ptr)
}

// Native returns the underlying C source pointer.
func (s *SIMD4F) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SIMD4X4F struct {
	native C.graphene_simd4x4f_t
}

// WrapSIMD4X4F wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSIMD4X4F(ptr unsafe.Pointer) *SIMD4X4F {
	if ptr == nil {
		return nil
	}

	return (*SIMD4X4F)(ptr)
}

// Native returns the underlying C source pointer.
func (s *SIMD4X4F) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Size: a size.
type Size struct {
	native C.graphene_size_t
}

// WrapSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSize(ptr unsafe.Pointer) *Size {
	if ptr == nil {
		return nil
	}

	return (*Size)(ptr)
}

func marshalSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSize(unsafe.Pointer(b)), nil
}

// NewSizeAlloc constructs a struct Size.
func NewSizeAlloc() *Size {
	var _cret *C.graphene_size_t // in

	_cret = C.graphene_size_alloc()

	var _size *Size // out

	_size = WrapSize(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_size, func(v *Size) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _size
}

// Native returns the underlying C source pointer.
func (s *Size) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Equal checks whether the two give #graphene_size_t are equal.
func (a *Size) Equal(b *Size) bool {
	var _arg0 *C.graphene_size_t // out
	var _arg1 *C.graphene_size_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_size_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_size_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_size_alloc().
func (s *Size) Free() {
	var _arg0 *C.graphene_size_t // out

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(s.Native()))

	C.graphene_size_free(_arg0)
}

// Init initializes a #graphene_size_t using the given @width and @height.
func (s *Size) Init(width float32, height float32) *Size {
	var _arg0 *C.graphene_size_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_size_t // in

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(width)
	_arg2 = (C.float)(height)

	_cret = C.graphene_size_init(_arg0, _arg1, _arg2)

	var _size *Size // out

	_size = WrapSize(unsafe.Pointer(_cret))

	return _size
}

// InitFromSize initializes a #graphene_size_t using the width and height of the
// given @src.
func (s *Size) InitFromSize(src *Size) *Size {
	var _arg0 *C.graphene_size_t // out
	var _arg1 *C.graphene_size_t // out
	var _cret *C.graphene_size_t // in

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_size_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_size_init_from_size(_arg0, _arg1)

	var _size *Size // out

	_size = WrapSize(unsafe.Pointer(_cret))

	return _size
}

// Interpolate: linearly interpolates the two given #graphene_size_t using the
// given interpolation @factor.
func (a *Size) Interpolate(b *Size, factor float64) Size {
	var _arg0 *C.graphene_size_t // out
	var _arg1 *C.graphene_size_t // out
	var _arg2 C.double           // out
	var _res Size

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_size_t)(unsafe.Pointer(b.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_size_interpolate(_arg0, _arg1, _arg2, (*C.graphene_size_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale scales the components of a #graphene_size_t using the given @factor.
func (s *Size) Scale(factor float32) Size {
	var _arg0 *C.graphene_size_t // out
	var _arg1 C.float            // out
	var _res Size

	_arg0 = (*C.graphene_size_t)(unsafe.Pointer(s.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_size_scale(_arg0, _arg1, (*C.graphene_size_t)(unsafe.Pointer(&_res)))

	return _res
}

// Sphere: a sphere, represented by its center and radius.
type Sphere struct {
	native C.graphene_sphere_t
}

// WrapSphere wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSphere(ptr unsafe.Pointer) *Sphere {
	if ptr == nil {
		return nil
	}

	return (*Sphere)(ptr)
}

func marshalSphere(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSphere(unsafe.Pointer(b)), nil
}

// NewSphereAlloc constructs a struct Sphere.
func NewSphereAlloc() *Sphere {
	var _cret *C.graphene_sphere_t // in

	_cret = C.graphene_sphere_alloc()

	var _sphere *Sphere // out

	_sphere = WrapSphere(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_sphere, func(v *Sphere) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _sphere
}

// Native returns the underlying C source pointer.
func (s *Sphere) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// ContainsPoint checks whether the given @point is contained in the volume of a
// #graphene_sphere_t.
func (s *Sphere) ContainsPoint(point *Point3D) bool {
	var _arg0 *C.graphene_sphere_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C._Bool               // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_sphere_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Distance computes the distance of the given @point from the surface of a
// #graphene_sphere_t.
func (s *Sphere) Distance(point *Point3D) float32 {
	var _arg0 *C.graphene_sphere_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret C.float               // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	_cret = C.graphene_sphere_distance(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether two #graphene_sphere_t are equal.
func (a *Sphere) Equal(b *Sphere) bool {
	var _arg0 *C.graphene_sphere_t // out
	var _arg1 *C.graphene_sphere_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_sphere_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_sphere_alloc().
func (s *Sphere) Free() {
	var _arg0 *C.graphene_sphere_t // out

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	C.graphene_sphere_free(_arg0)
}

// BoundingBox computes the bounding box capable of containing the given
// #graphene_sphere_t.
func (s *Sphere) BoundingBox() Box {
	var _arg0 *C.graphene_sphere_t // out
	var _box Box

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	C.graphene_sphere_get_bounding_box(_arg0, (*C.graphene_box_t)(unsafe.Pointer(&_box)))

	return _box
}

// Center retrieves the coordinates of the center of a #graphene_sphere_t.
func (s *Sphere) Center() Point3D {
	var _arg0 *C.graphene_sphere_t // out
	var _center Point3D

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	C.graphene_sphere_get_center(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_center)))

	return _center
}

// Radius retrieves the radius of a #graphene_sphere_t.
func (s *Sphere) Radius() float32 {
	var _arg0 *C.graphene_sphere_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	_cret = C.graphene_sphere_get_radius(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes the given #graphene_sphere_t with the given @center and
// @radius.
func (s *Sphere) Init(center *Point3D, radius float32) *Sphere {
	var _arg0 *C.graphene_sphere_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 C.float               // out
	var _cret *C.graphene_sphere_t  // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(center.Native()))
	_arg2 = (C.float)(radius)

	_cret = C.graphene_sphere_init(_arg0, _arg1, _arg2)

	var _sphere *Sphere // out

	_sphere = WrapSphere(unsafe.Pointer(_cret))

	return _sphere
}

// InitFromPoints initializes the given #graphene_sphere_t using the given array
// of 3D coordinates so that the sphere includes them.
//
// The center of the sphere can either be specified, or will be center of the 3D
// volume that encompasses all @points.
func (s *Sphere) InitFromPoints(points []Point3D, center *Point3D) *Sphere {
	var _arg0 *C.graphene_sphere_t // out
	var _arg2 *C.graphene_point3d_t
	var _arg1 C.uint
	var _arg3 *C.graphene_point3d_t // out
	var _cret *C.graphene_sphere_t  // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = C.uint(len(points))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(&points[0]))
	_arg3 = (*C.graphene_point3d_t)(unsafe.Pointer(center.Native()))

	_cret = C.graphene_sphere_init_from_points(_arg0, _arg1, _arg2, _arg3)

	var _sphere *Sphere // out

	_sphere = WrapSphere(unsafe.Pointer(_cret))

	return _sphere
}

// InitFromVectors initializes the given #graphene_sphere_t using the given
// array of 3D coordinates so that the sphere includes them.
//
// The center of the sphere can either be specified, or will be center of the 3D
// volume that encompasses all @vectors.
func (s *Sphere) InitFromVectors(vectors []Vec3, center *Point3D) *Sphere {
	var _arg0 *C.graphene_sphere_t // out
	var _arg2 *C.graphene_vec3_t
	var _arg1 C.uint
	var _arg3 *C.graphene_point3d_t // out
	var _cret *C.graphene_sphere_t  // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = C.uint(len(vectors))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(&vectors[0]))
	_arg3 = (*C.graphene_point3d_t)(unsafe.Pointer(center.Native()))

	_cret = C.graphene_sphere_init_from_vectors(_arg0, _arg1, _arg2, _arg3)

	var _sphere *Sphere // out

	_sphere = WrapSphere(unsafe.Pointer(_cret))

	return _sphere
}

// IsEmpty checks whether the sphere has a zero radius.
func (s *Sphere) IsEmpty() bool {
	var _arg0 *C.graphene_sphere_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	_cret = C.graphene_sphere_is_empty(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Translate translates the center of the given #graphene_sphere_t using the
// @point coordinates as the delta of the translation.
func (s *Sphere) Translate(point *Point3D) Sphere {
	var _arg0 *C.graphene_sphere_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _res Sphere

	_arg0 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.graphene_sphere_translate(_arg0, _arg1, (*C.graphene_sphere_t)(unsafe.Pointer(&_res)))

	return _res
}

// Triangle: a triangle.
type Triangle struct {
	native C.graphene_triangle_t
}

// WrapTriangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTriangle(ptr unsafe.Pointer) *Triangle {
	if ptr == nil {
		return nil
	}

	return (*Triangle)(ptr)
}

func marshalTriangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTriangle(unsafe.Pointer(b)), nil
}

// NewTriangleAlloc constructs a struct Triangle.
func NewTriangleAlloc() *Triangle {
	var _cret *C.graphene_triangle_t // in

	_cret = C.graphene_triangle_alloc()

	var _triangle *Triangle // out

	_triangle = WrapTriangle(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_triangle, func(v *Triangle) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _triangle
}

// Native returns the underlying C source pointer.
func (t *Triangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// ContainsPoint checks whether the given triangle @t contains the point @p.
func (t *Triangle) ContainsPoint(p *Point3D) bool {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_point3d_t  // out
	var _cret C._Bool                // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_triangle_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given #graphene_triangle_t are equal.
func (a *Triangle) Equal(b *Triangle) bool {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_triangle_t // out
	var _cret C._Bool                // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_triangle_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_triangle_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_triangle_alloc().
func (t *Triangle) Free() {
	var _arg0 *C.graphene_triangle_t // out

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_free(_arg0)
}

// Area computes the area of the given #graphene_triangle_t.
func (t *Triangle) Area() float32 {
	var _arg0 *C.graphene_triangle_t // out
	var _cret C.float                // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	_cret = C.graphene_triangle_get_area(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Barycoords computes the barycentric coordinates
// (http://en.wikipedia.org/wiki/Barycentric_coordinate_system) of the given
// point @p.
//
// The point @p must lie on the same plane as the triangle @t; if the point is
// not coplanar, the result of this function is undefined.
//
// If we place the origin in the coordinates of the triangle's A point, the
// barycentric coordinates are `u`, which is on the AC vector; and `v` which is
// on the AB vector:
//
// ! (triangle-barycentric.png)
//
// The returned #graphene_vec2_t contains the following values, in order:
//
//    - `res.x = u`
//    - `res.y = v`
func (t *Triangle) Barycoords(p *Point3D) (Vec2, bool) {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_point3d_t  // out
	var _res Vec2
	var _cret C._Bool // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_triangle_get_barycoords(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// BoundingBox computes the bounding box of the given #graphene_triangle_t.
func (t *Triangle) BoundingBox() Box {
	var _arg0 *C.graphene_triangle_t // out
	var _res Box

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_bounding_box(_arg0, (*C.graphene_box_t)(unsafe.Pointer(&_res)))

	return _res
}

// Midpoint computes the coordinates of the midpoint of the given
// #graphene_triangle_t.
//
// The midpoint G is the centroid
// (https://en.wikipedia.org/wiki/Centroid#Triangle_centroid) of the triangle,
// i.e. the intersection of its medians.
func (t *Triangle) Midpoint() Point3D {
	var _arg0 *C.graphene_triangle_t // out
	var _res Point3D

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_midpoint(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normal computes the normal vector of the given #graphene_triangle_t.
func (t *Triangle) Normal() Vec3 {
	var _arg0 *C.graphene_triangle_t // out
	var _res Vec3

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_normal(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Plane computes the plane based on the vertices of the given
// #graphene_triangle_t.
func (t *Triangle) Plane() Plane {
	var _arg0 *C.graphene_triangle_t // out
	var _res Plane

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_plane(_arg0, (*C.graphene_plane_t)(unsafe.Pointer(&_res)))

	return _res
}

// Points retrieves the three vertices of the given #graphene_triangle_t and
// returns their coordinates as #graphene_point3d_t.
func (t *Triangle) Points() (a Point3D, b Point3D, c Point3D) {
	var _arg0 *C.graphene_triangle_t // out
	var _a Point3D
	var _b Point3D
	var _c Point3D

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_points(_arg0, (*C.graphene_point3d_t)(unsafe.Pointer(&_a)), (*C.graphene_point3d_t)(unsafe.Pointer(&_b)), (*C.graphene_point3d_t)(unsafe.Pointer(&_c)))

	return _a, _b, _c
}

// Uv computes the UV coordinates of the given point @p.
//
// The point @p must lie on the same plane as the triangle @t; if the point is
// not coplanar, the result of this function is undefined. If @p is nil, the
// point will be set in (0, 0, 0).
//
// The UV coordinates will be placed in the @res vector:
//
//    - `res.x = u`
//    - `res.y = v`
//
// See also: graphene_triangle_get_barycoords()
func (t *Triangle) Uv(p *Point3D, uvA *Vec2, uvB *Vec2, uvC *Vec2) (Vec2, bool) {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_point3d_t  // out
	var _arg2 *C.graphene_vec2_t     // out
	var _arg3 *C.graphene_vec2_t     // out
	var _arg4 *C.graphene_vec2_t     // out
	var _res Vec2
	var _cret C._Bool // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))
	_arg2 = (*C.graphene_vec2_t)(unsafe.Pointer(uvA.Native()))
	_arg3 = (*C.graphene_vec2_t)(unsafe.Pointer(uvB.Native()))
	_arg4 = (*C.graphene_vec2_t)(unsafe.Pointer(uvC.Native()))

	_cret = C.graphene_triangle_get_uv(_arg0, _arg1, _arg2, _arg3, _arg4, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Vertices retrieves the three vertices of the given #graphene_triangle_t.
func (t *Triangle) Vertices() (a Vec3, b Vec3, c Vec3) {
	var _arg0 *C.graphene_triangle_t // out
	var _a Vec3
	var _b Vec3
	var _c Vec3

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))

	C.graphene_triangle_get_vertices(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_a)), (*C.graphene_vec3_t)(unsafe.Pointer(&_b)), (*C.graphene_vec3_t)(unsafe.Pointer(&_c)))

	return _a, _b, _c
}

// InitFromFloat initializes a #graphene_triangle_t using the three given arrays
// of floating point values, each representing the coordinates of a point in 3D
// space.
func (t *Triangle) InitFromFloat(a [3]float32, b [3]float32, c [3]float32) *Triangle {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.float
	var _arg2 *C.float
	var _arg3 *C.float
	var _cret *C.graphene_triangle_t // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&a))
	_arg2 = (*C.float)(unsafe.Pointer(&b))
	_arg3 = (*C.float)(unsafe.Pointer(&c))

	_cret = C.graphene_triangle_init_from_float(_arg0, _arg1, _arg2, _arg3)

	var _triangle *Triangle // out

	_triangle = WrapTriangle(unsafe.Pointer(_cret))

	return _triangle
}

// InitFromPoint3D initializes a #graphene_triangle_t using the three given 3D
// points.
func (t *Triangle) InitFromPoint3D(a *Point3D, b *Point3D, c *Point3D) *Triangle {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_point3d_t  // out
	var _arg2 *C.graphene_point3d_t  // out
	var _arg3 *C.graphene_point3d_t  // out
	var _cret *C.graphene_triangle_t // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(b.Native()))
	_arg3 = (*C.graphene_point3d_t)(unsafe.Pointer(c.Native()))

	_cret = C.graphene_triangle_init_from_point3d(_arg0, _arg1, _arg2, _arg3)

	var _triangle *Triangle // out

	_triangle = WrapTriangle(unsafe.Pointer(_cret))

	return _triangle
}

// InitFromVec3 initializes a #graphene_triangle_t using the three given
// vectors.
func (t *Triangle) InitFromVec3(a *Vec3, b *Vec3, c *Vec3) *Triangle {
	var _arg0 *C.graphene_triangle_t // out
	var _arg1 *C.graphene_vec3_t     // out
	var _arg2 *C.graphene_vec3_t     // out
	var _arg3 *C.graphene_vec3_t     // out
	var _cret *C.graphene_triangle_t // in

	_arg0 = (*C.graphene_triangle_t)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))
	_arg3 = (*C.graphene_vec3_t)(unsafe.Pointer(c.Native()))

	_cret = C.graphene_triangle_init_from_vec3(_arg0, _arg1, _arg2, _arg3)

	var _triangle *Triangle // out

	_triangle = WrapTriangle(unsafe.Pointer(_cret))

	return _triangle
}

// Vec2: a structure capable of holding a vector with two dimensions, x and y.
//
// The contents of the #graphene_vec2_t structure are private and should never
// be accessed directly.
type Vec2 struct {
	native C.graphene_vec2_t
}

// WrapVec2 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec2(ptr unsafe.Pointer) *Vec2 {
	if ptr == nil {
		return nil
	}

	return (*Vec2)(ptr)
}

func marshalVec2(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec2(unsafe.Pointer(b)), nil
}

// NewVec2Alloc constructs a struct Vec2.
func NewVec2Alloc() *Vec2 {
	var _cret *C.graphene_vec2_t // in

	_cret = C.graphene_vec2_alloc()

	var _vec2 *Vec2 // out

	_vec2 = WrapVec2(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_vec2, func(v *Vec2) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _vec2
}

// Native returns the underlying C source pointer.
func (v *Vec2) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Add adds each component of the two passed vectors and places each result into
// the components of @res.
func (a *Vec2) Add(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_add(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Divide divides each component of the first operand @a by the corresponding
// component of the second operand @b, and places the results into the vector
// @res.
func (a *Vec2) Divide(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_divide(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Dot computes the dot product of the two given vectors.
func (a *Vec2) Dot(b *Vec2) float32 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_vec2_dot(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the two given #graphene_vec2_t are equal.
func (v *Vec2) Equal(v2 *Vec2) bool {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(v2.Native()))

	_cret = C.graphene_vec2_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by @v
func (v *Vec2) Free() {
	var _arg0 *C.graphene_vec2_t // out

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec2_free(_arg0)
}

// X retrieves the X component of the #graphene_vec2_t.
func (v *Vec2) X() float32 {
	var _arg0 *C.graphene_vec2_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec2_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Y retrieves the Y component of the #graphene_vec2_t.
func (v *Vec2) Y() float32 {
	var _arg0 *C.graphene_vec2_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec2_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes a #graphene_vec2_t using the given values.
//
// This function can be called multiple times.
func (v *Vec2) Init(x float32, y float32) *Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_vec2_t // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)

	_cret = C.graphene_vec2_init(_arg0, _arg1, _arg2)

	var _vec2 *Vec2 // out

	_vec2 = WrapVec2(unsafe.Pointer(_cret))

	return _vec2
}

// InitFromFloat initializes @v with the contents of the given array.
func (v *Vec2) InitFromFloat(src [2]float32) *Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.float
	var _cret *C.graphene_vec2_t // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&src))

	_cret = C.graphene_vec2_init_from_float(_arg0, _arg1)

	var _vec2 *Vec2 // out

	_vec2 = WrapVec2(unsafe.Pointer(_cret))

	return _vec2
}

// InitFromVec2 copies the contents of @src into @v.
func (v *Vec2) InitFromVec2(src *Vec2) *Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _cret *C.graphene_vec2_t // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_vec2_init_from_vec2(_arg0, _arg1)

	var _vec2 *Vec2 // out

	_vec2 = WrapVec2(unsafe.Pointer(_cret))

	return _vec2
}

// Interpolate: linearly interpolates @v1 and @v2 using the given @factor.
func (v *Vec2) Interpolate(v2 *Vec2, factor float64) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _arg2 C.double           // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_vec2_interpolate(_arg0, _arg1, _arg2, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Length computes the length of the given vector.
func (v *Vec2) Length() float32 {
	var _arg0 *C.graphene_vec2_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec2_length(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Max compares the two given vectors and places the maximum values of each
// component into @res.
func (a *Vec2) Max(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_max(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Min compares the two given vectors and places the minimum values of each
// component into @res.
func (a *Vec2) Min(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_min(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Multiply multiplies each component of the two passed vectors and places each
// result into the components of @res.
func (a *Vec2) Multiply(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_multiply(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Near compares the two given #graphene_vec2_t vectors and checks whether their
// values are within the given @epsilon.
func (v *Vec2) Near(v2 *Vec2, epsilon float32) bool {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _arg2 C.float            // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_vec2_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Negate negates the given #graphene_vec2_t.
func (v *Vec2) Negate() Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec2_negate(_arg0, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normalize computes the normalized vector for the given vector @v.
func (v *Vec2) Normalize() Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec2_normalize(_arg0, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale multiplies all components of the given vector with the given scalar
// @factor.
func (v *Vec2) Scale(factor float32) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 C.float            // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_vec2_scale(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// Subtract subtracts from each component of the first operand @a the
// corresponding component of the second operand @b and places each result into
// the components of @res.
func (a *Vec2) Subtract(b *Vec2) Vec2 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec2_subtract(_arg0, _arg1, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToFloat stores the components of @v into an array.
func (v *Vec2) ToFloat() [2]float32 {
	var _arg0 *C.graphene_vec2_t // out
	var _arg1 [2]C.float

	_arg0 = (*C.graphene_vec2_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec2_to_float(_arg0, &_arg1[0])

	var _dest [2]float32

	_dest = *(*[2]float32)(unsafe.Pointer(&_arg1))

	return _dest
}

// Vec3: a structure capable of holding a vector with three dimensions: x, y,
// and z.
//
// The contents of the #graphene_vec3_t structure are private and should never
// be accessed directly.
type Vec3 struct {
	native C.graphene_vec3_t
}

// WrapVec3 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec3(ptr unsafe.Pointer) *Vec3 {
	if ptr == nil {
		return nil
	}

	return (*Vec3)(ptr)
}

func marshalVec3(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec3(unsafe.Pointer(b)), nil
}

// NewVec3Alloc constructs a struct Vec3.
func NewVec3Alloc() *Vec3 {
	var _cret *C.graphene_vec3_t // in

	_cret = C.graphene_vec3_alloc()

	var _vec3 *Vec3 // out

	_vec3 = WrapVec3(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_vec3, func(v *Vec3) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _vec3
}

// Native returns the underlying C source pointer.
func (v *Vec3) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Add adds each component of the two given vectors.
func (a *Vec3) Add(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_add(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Cross computes the cross product of the two given vectors.
func (a *Vec3) Cross(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_cross(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Divide divides each component of the first operand @a by the corresponding
// component of the second operand @b, and places the results into the vector
// @res.
func (a *Vec3) Divide(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_divide(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Dot computes the dot product of the two given vectors.
func (a *Vec3) Dot(b *Vec3) float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_vec3_dot(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the two given #graphene_vec3_t are equal.
func (v *Vec3) Equal(v2 *Vec3) bool {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v2.Native()))

	_cret = C.graphene_vec3_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by @v
func (v *Vec3) Free() {
	var _arg0 *C.graphene_vec3_t // out

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_free(_arg0)
}

// X retrieves the first component of the given vector @v.
func (v *Vec3) X() float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec3_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// XY creates a #graphene_vec2_t that contains the first and second components
// of the given #graphene_vec3_t.
func (v *Vec3) XY() Vec2 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_get_xy(_arg0, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// XY0 creates a #graphene_vec3_t that contains the first two components of the
// given #graphene_vec3_t, and the third component set to 0.
func (v *Vec3) XY0() Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_get_xy0(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// XYZ0 converts a #graphene_vec3_t in a #graphene_vec4_t using 0.0 as the value
// for the fourth component of the resulting vector.
func (v *Vec3) XYZ0() Vec4 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_get_xyz0(_arg0, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// XYZ1 converts a #graphene_vec3_t in a #graphene_vec4_t using 1.0 as the value
// for the fourth component of the resulting vector.
func (v *Vec3) XYZ1() Vec4 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_get_xyz1(_arg0, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Xyzw converts a #graphene_vec3_t in a #graphene_vec4_t using @w as the value
// of the fourth component of the resulting vector.
func (v *Vec3) Xyzw(w float32) Vec4 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 C.float            // out
	var _res Vec4

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(w)

	C.graphene_vec3_get_xyzw(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Y retrieves the second component of the given vector @v.
func (v *Vec3) Y() float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec3_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Z retrieves the third component of the given vector @v.
func (v *Vec3) Z() float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec3_get_z(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes a #graphene_vec3_t using the given values.
//
// This function can be called multiple times.
func (v *Vec3) Init(x float32, y float32, z float32) *Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.float            // out
	var _cret *C.graphene_vec3_t // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)

	_cret = C.graphene_vec3_init(_arg0, _arg1, _arg2, _arg3)

	var _vec3 *Vec3 // out

	_vec3 = WrapVec3(unsafe.Pointer(_cret))

	return _vec3
}

// InitFromFloat initializes a #graphene_vec3_t with the values from an array.
func (v *Vec3) InitFromFloat(src [3]float32) *Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.float
	var _cret *C.graphene_vec3_t // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&src))

	_cret = C.graphene_vec3_init_from_float(_arg0, _arg1)

	var _vec3 *Vec3 // out

	_vec3 = WrapVec3(unsafe.Pointer(_cret))

	return _vec3
}

// InitFromVec3 initializes a #graphene_vec3_t with the values of another
// #graphene_vec3_t.
func (v *Vec3) InitFromVec3(src *Vec3) *Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _cret *C.graphene_vec3_t // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_vec3_init_from_vec3(_arg0, _arg1)

	var _vec3 *Vec3 // out

	_vec3 = WrapVec3(unsafe.Pointer(_cret))

	return _vec3
}

// Interpolate: linearly interpolates @v1 and @v2 using the given @factor.
func (v *Vec3) Interpolate(v2 *Vec3, factor float64) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 C.double           // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_vec3_interpolate(_arg0, _arg1, _arg2, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Length retrieves the length of the given vector @v.
func (v *Vec3) Length() float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec3_length(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Max compares each component of the two given vectors and creates a vector
// that contains the maximum values.
func (a *Vec3) Max(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_max(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Min compares each component of the two given vectors and creates a vector
// that contains the minimum values.
func (a *Vec3) Min(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_min(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Multiply multiplies each component of the two given vectors.
func (a *Vec3) Multiply(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_multiply(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Near compares the two given #graphene_vec3_t vectors and checks whether their
// values are within the given @epsilon.
func (v *Vec3) Near(v2 *Vec3, epsilon float32) bool {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 C.float            // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_vec3_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Negate negates the given #graphene_vec3_t.
func (v *Vec3) Negate() Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_negate(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normalize normalizes the given #graphene_vec3_t.
func (v *Vec3) Normalize() Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_normalize(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale multiplies all components of the given vector with the given scalar
// @factor.
func (v *Vec3) Scale(factor float32) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 C.float            // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_vec3_scale(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Subtract subtracts from each component of the first operand @a the
// corresponding component of the second operand @b and places each result into
// the components of @res.
func (a *Vec3) Subtract(b *Vec3) Vec3 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec3_subtract(_arg0, _arg1, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToFloat copies the components of a #graphene_vec3_t into the given array.
func (v *Vec3) ToFloat() [3]float32 {
	var _arg0 *C.graphene_vec3_t // out
	var _arg1 [3]C.float

	_arg0 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec3_to_float(_arg0, &_arg1[0])

	var _dest [3]float32

	_dest = *(*[3]float32)(unsafe.Pointer(&_arg1))

	return _dest
}

// Vec4: a structure capable of holding a vector with four dimensions: x, y, z,
// and w.
//
// The contents of the #graphene_vec4_t structure are private and should never
// be accessed directly.
type Vec4 struct {
	native C.graphene_vec4_t
}

// WrapVec4 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec4(ptr unsafe.Pointer) *Vec4 {
	if ptr == nil {
		return nil
	}

	return (*Vec4)(ptr)
}

func marshalVec4(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec4(unsafe.Pointer(b)), nil
}

// NewVec4Alloc constructs a struct Vec4.
func NewVec4Alloc() *Vec4 {
	var _cret *C.graphene_vec4_t // in

	_cret = C.graphene_vec4_alloc()

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_vec4, func(v *Vec4) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _vec4
}

// Native returns the underlying C source pointer.
func (v *Vec4) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// Add adds each component of the two given vectors.
func (a *Vec4) Add(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_add(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Divide divides each component of the first operand @a by the corresponding
// component of the second operand @b, and places the results into the vector
// @res.
func (a *Vec4) Divide(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_divide(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Dot computes the dot product of the two given vectors.
func (a *Vec4) Dot(b *Vec4) float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_vec4_dot(_arg0, _arg1)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Equal checks whether the two given #graphene_vec4_t are equal.
func (v *Vec4) Equal(v2 *Vec4) bool {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))

	_cret = C.graphene_vec4_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by @v
func (v *Vec4) Free() {
	var _arg0 *C.graphene_vec4_t // out

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_free(_arg0)
}

// W retrieves the value of the fourth component of the given #graphene_vec4_t.
func (v *Vec4) W() float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec4_get_w(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// X retrieves the value of the first component of the given #graphene_vec4_t.
func (v *Vec4) X() float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec4_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// XY creates a #graphene_vec2_t that contains the first two components of the
// given #graphene_vec4_t.
func (v *Vec4) XY() Vec2 {
	var _arg0 *C.graphene_vec4_t // out
	var _res Vec2

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_get_xy(_arg0, (*C.graphene_vec2_t)(unsafe.Pointer(&_res)))

	return _res
}

// XYZ creates a #graphene_vec3_t that contains the first three components of
// the given #graphene_vec4_t.
func (v *Vec4) XYZ() Vec3 {
	var _arg0 *C.graphene_vec4_t // out
	var _res Vec3

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_get_xyz(_arg0, (*C.graphene_vec3_t)(unsafe.Pointer(&_res)))

	return _res
}

// Y retrieves the value of the second component of the given #graphene_vec4_t.
func (v *Vec4) Y() float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec4_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Z retrieves the value of the third component of the given #graphene_vec4_t.
func (v *Vec4) Z() float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec4_get_z(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Init initializes a #graphene_vec4_t using the given values.
//
// This function can be called multiple times.
func (v *Vec4) Init(x float32, y float32, z float32, w float32) *Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.float            // out
	var _arg4 C.float            // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(x)
	_arg2 = (C.float)(y)
	_arg3 = (C.float)(z)
	_arg4 = (C.float)(w)

	_cret = C.graphene_vec4_init(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// InitFromFloat initializes a #graphene_vec4_t with the values inside the given
// array.
func (v *Vec4) InitFromFloat(src [4]float32) *Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.float
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&src))

	_cret = C.graphene_vec4_init_from_float(_arg0, _arg1)

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// InitFromVec2 initializes a #graphene_vec4_t using the components of a
// #graphene_vec2_t and the values of @z and @w.
func (v *Vec4) InitFromVec2(src *Vec2, z float32, w float32) *Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec2_t // out
	var _arg2 C.float            // out
	var _arg3 C.float            // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec2_t)(unsafe.Pointer(src.Native()))
	_arg2 = (C.float)(z)
	_arg3 = (C.float)(w)

	_cret = C.graphene_vec4_init_from_vec2(_arg0, _arg1, _arg2, _arg3)

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// InitFromVec3 initializes a #graphene_vec4_t using the components of a
// #graphene_vec3_t and the value of @w.
func (v *Vec4) InitFromVec3(src *Vec3, w float32) *Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec3_t // out
	var _arg2 C.float            // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(src.Native()))
	_arg2 = (C.float)(w)

	_cret = C.graphene_vec4_init_from_vec3(_arg0, _arg1, _arg2)

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// InitFromVec4 initializes a #graphene_vec4_t using the components of another
// #graphene_vec4_t.
func (v *Vec4) InitFromVec4(src *Vec4) *Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_vec4_init_from_vec4(_arg0, _arg1)

	var _vec4 *Vec4 // out

	_vec4 = WrapVec4(unsafe.Pointer(_cret))

	return _vec4
}

// Interpolate: linearly interpolates @v1 and @v2 using the given @factor.
func (v *Vec4) Interpolate(v2 *Vec4, factor float64) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _arg2 C.double           // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.double)(factor)

	C.graphene_vec4_interpolate(_arg0, _arg1, _arg2, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Length computes the length of the given #graphene_vec4_t.
func (v *Vec4) Length() float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	_cret = C.graphene_vec4_length(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

// Max compares each component of the two given vectors and creates a vector
// that contains the maximum values.
func (a *Vec4) Max(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_max(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Min compares each component of the two given vectors and creates a vector
// that contains the minimum values.
func (a *Vec4) Min(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_min(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Multiply multiplies each component of the two given vectors.
func (a *Vec4) Multiply(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_multiply(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Near compares the two given #graphene_vec4_t vectors and checks whether their
// values are within the given @epsilon.
func (v *Vec4) Near(v2 *Vec4, epsilon float32) bool {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _arg2 C.float            // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))
	_arg2 = (C.float)(epsilon)

	_cret = C.graphene_vec4_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Negate negates the given #graphene_vec4_t.
func (v *Vec4) Negate() Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_negate(_arg0, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Normalize normalizes the given #graphene_vec4_t.
func (v *Vec4) Normalize() Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_normalize(_arg0, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Scale multiplies all components of the given vector with the given scalar
// @factor.
func (v *Vec4) Scale(factor float32) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 C.float            // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))
	_arg1 = (C.float)(factor)

	C.graphene_vec4_scale(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// Subtract subtracts from each component of the first operand @a the
// corresponding component of the second operand @b and places each result into
// the components of @res.
func (a *Vec4) Subtract(b *Vec4) Vec4 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 *C.graphene_vec4_t // out
	var _res Vec4

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(b.Native()))

	C.graphene_vec4_subtract(_arg0, _arg1, (*C.graphene_vec4_t)(unsafe.Pointer(&_res)))

	return _res
}

// ToFloat stores the components of the given #graphene_vec4_t into an array of
// floating point values.
func (v *Vec4) ToFloat() [4]float32 {
	var _arg0 *C.graphene_vec4_t // out
	var _arg1 [4]C.float

	_arg0 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_vec4_to_float(_arg0, &_arg1[0])

	var _dest [4]float32

	_dest = *(*[4]float32)(unsafe.Pointer(&_arg1))

	return _dest
}
