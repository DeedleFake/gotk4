// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <graphene-gobject.h>
//
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		// Skipped EulerOrder.
		// Skipped RayIntersectionKind.

		// Records
		{T: externglib.Type(C.graphene_box_get_type()), F: marshalBox},
		{T: externglib.Type(C.graphene_euler_get_type()), F: marshalEuler},
		{T: externglib.Type(C.graphene_frustum_get_type()), F: marshalFrustum},
		{T: externglib.Type(C.graphene_matrix_get_type()), F: marshalMatrix},
		{T: externglib.Type(C.graphene_plane_get_type()), F: marshalPlane},
		{T: externglib.Type(C.graphene_point_get_type()), F: marshalPoint},
		{T: externglib.Type(C.graphene_point3d_get_type()), F: marshalPoint3D},
		{T: externglib.Type(C.graphene_quad_get_type()), F: marshalQuad},
		{T: externglib.Type(C.graphene_quaternion_get_type()), F: marshalQuaternion},
		{T: externglib.Type(C.graphene_ray_get_type()), F: marshalRay},
		{T: externglib.Type(C.graphene_rect_get_type()), F: marshalRect},
		// Skipped Simd4F.
		// Skipped Simd4X4F.
		{T: externglib.Type(C.graphene_size_get_type()), F: marshalSize},
		{T: externglib.Type(C.graphene_sphere_get_type()), F: marshalSphere},
		{T: externglib.Type(C.graphene_triangle_get_type()), F: marshalTriangle},
		{T: externglib.Type(C.graphene_vec2_get_type()), F: marshalVec2},
		{T: externglib.Type(C.graphene_vec3_get_type()), F: marshalVec3},
		{T: externglib.Type(C.graphene_vec4_get_type()), F: marshalVec4},
	})
}

// EulerOrder: specify the order of the rotations on each axis.
//
// The GRAPHENE_EULER_ORDER_DEFAULT value is special, and is used as an alias
// for one of the other orders.
type EulerOrder int

const (
	// EulerOrderDefault: rotate in the default order; the default order is one
	// of the following enumeration values
	EulerOrderDefault EulerOrder = -1
	// EulerOrderXYZ: rotate in the X, Y, and Z order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SXYZ
	EulerOrderXYZ EulerOrder = 0
	// EulerOrderYZX: rotate in the Y, Z, and X order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SYZX
	EulerOrderYZX EulerOrder = 1
	// EulerOrderZXY: rotate in the Z, X, and Y order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SZXY
	EulerOrderZXY EulerOrder = 2
	// EulerOrderXZY: rotate in the X, Z, and Y order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SXZY
	EulerOrderXZY EulerOrder = 3
	// EulerOrderYXZ: rotate in the Y, X, and Z order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SYXZ
	EulerOrderYXZ EulerOrder = 4
	// EulerOrderZYX: rotate in the Z, Y, and X order. Deprecated in Graphene
	// 1.10, it's an alias for GRAPHENE_EULER_ORDER_SZYX
	EulerOrderZYX EulerOrder = 5
	// EulerOrderSXYZ defines a static rotation along the X, Y, and Z axes
	// (Since: 1.10)
	EulerOrderSXYZ EulerOrder = 6
	// EulerOrderSXYX defines a static rotation along the X, Y, and X axes
	// (Since: 1.10)
	EulerOrderSXYX EulerOrder = 7
	// EulerOrderSXZY defines a static rotation along the X, Z, and Y axes
	// (Since: 1.10)
	EulerOrderSXZY EulerOrder = 8
	// EulerOrderSXZX defines a static rotation along the X, Z, and X axes
	// (Since: 1.10)
	EulerOrderSXZX EulerOrder = 9
	// EulerOrderSYZX defines a static rotation along the Y, Z, and X axes
	// (Since: 1.10)
	EulerOrderSYZX EulerOrder = 10
	// EulerOrderSYZY defines a static rotation along the Y, Z, and Y axes
	// (Since: 1.10)
	EulerOrderSYZY EulerOrder = 11
	// EulerOrderSYXZ defines a static rotation along the Y, X, and Z axes
	// (Since: 1.10)
	EulerOrderSYXZ EulerOrder = 12
	// EulerOrderSYXY defines a static rotation along the Y, X, and Y axes
	// (Since: 1.10)
	EulerOrderSYXY EulerOrder = 13
	// EulerOrderSZXY defines a static rotation along the Z, X, and Y axes
	// (Since: 1.10)
	EulerOrderSZXY EulerOrder = 14
	// EulerOrderSZXZ defines a static rotation along the Z, X, and Z axes
	// (Since: 1.10)
	EulerOrderSZXZ EulerOrder = 15
	// EulerOrderSZYX defines a static rotation along the Z, Y, and X axes
	// (Since: 1.10)
	EulerOrderSZYX EulerOrder = 16
	// EulerOrderSZYZ defines a static rotation along the Z, Y, and Z axes
	// (Since: 1.10)
	EulerOrderSZYZ EulerOrder = 17
	// EulerOrderRZYX defines a relative rotation along the Z, Y, and X axes
	// (Since: 1.10)
	EulerOrderRZYX EulerOrder = 18
	// EulerOrderRXYX defines a relative rotation along the X, Y, and X axes
	// (Since: 1.10)
	EulerOrderRXYX EulerOrder = 19
	// EulerOrderRYZX defines a relative rotation along the Y, Z, and X axes
	// (Since: 1.10)
	EulerOrderRYZX EulerOrder = 20
	// EulerOrderRXZX defines a relative rotation along the X, Z, and X axes
	// (Since: 1.10)
	EulerOrderRXZX EulerOrder = 21
	// EulerOrderRXZY defines a relative rotation along the X, Z, and Y axes
	// (Since: 1.10)
	EulerOrderRXZY EulerOrder = 22
	// EulerOrderRYZY defines a relative rotation along the Y, Z, and Y axes
	// (Since: 1.10)
	EulerOrderRYZY EulerOrder = 23
	// EulerOrderRZXY defines a relative rotation along the Z, X, and Y axes
	// (Since: 1.10)
	EulerOrderRZXY EulerOrder = 24
	// EulerOrderRYXY defines a relative rotation along the Y, X, and Y axes
	// (Since: 1.10)
	EulerOrderRYXY EulerOrder = 25
	// EulerOrderRYXZ defines a relative rotation along the Y, X, and Z axes
	// (Since: 1.10)
	EulerOrderRYXZ EulerOrder = 26
	// EulerOrderRZXZ defines a relative rotation along the Z, X, and Z axes
	// (Since: 1.10)
	EulerOrderRZXZ EulerOrder = 27
	// EulerOrderRXYZ defines a relative rotation along the X, Y, and Z axes
	// (Since: 1.10)
	EulerOrderRXYZ EulerOrder = 28
	// EulerOrderRZYZ defines a relative rotation along the Z, Y, and Z axes
	// (Since: 1.10)
	EulerOrderRZYZ EulerOrder = 29
)

// RayIntersectionKind: the type of intersection.
type RayIntersectionKind int

const (
	// RayIntersectionKindNone: no intersection
	RayIntersectionKindNone RayIntersectionKind = 0
	// RayIntersectionKindEnter: the ray is entering the intersected object
	RayIntersectionKindEnter RayIntersectionKind = 1
	// RayIntersectionKindLeave: the ray is leaving the intersected object
	RayIntersectionKindLeave RayIntersectionKind = 2
)

// BoxEmpty: a degenerate #graphene_box_t that can only be expanded.
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxEmpty() *Box {

	ret := C.graphene_box_empty()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// BoxInfinite: a degenerate #graphene_box_t that cannot be expanded.
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxInfinite() *Box {

	ret := C.graphene_box_infinite()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// BoxMinusOne: a #graphene_box_t with the minimum vertex set at (-1, -1, -1)
// and the maximum vertex set at (0, 0, 0).
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxMinusOne() *Box {

	ret := C.graphene_box_minus_one()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// BoxOne: a #graphene_box_t with the minimum vertex set at (0, 0, 0) and the
// maximum vertex set at (1, 1, 1).
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxOne() *Box {

	ret := C.graphene_box_one()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// BoxOneMinusOne: a #graphene_box_t with the minimum vertex set at (-1, -1, -1)
// and the maximum vertex set at (1, 1, 1).
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxOneMinusOne() *Box {

	ret := C.graphene_box_one_minus_one()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// BoxZero: a #graphene_box_t with both the minimum and maximum vertices set at
// (0, 0, 0).
//
// The returned value is owned by Graphene and should not be modified or freed.
func BoxZero() *Box {

	ret := C.graphene_box_zero()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// Point3DZero retrieves a constant point with all three coordinates set to 0.
func Point3DZero() *Point3D {

	ret := C.graphene_point3d_zero()

	var ret0 *Point3D

	ret0 = WrapPoint3D(ret)

	return ret0
}

// PointZero returns a point fixed at (0, 0).
func PointZero() *Point {

	ret := C.graphene_point_zero()

	var ret0 *Point

	ret0 = WrapPoint(ret)

	return ret0
}

// RectAlloc allocates a new #graphene_rect_t.
//
// The contents of the returned rectangle are undefined.
func RectAlloc() *Rect {

	ret := C.graphene_rect_alloc()

	var ret0 *Rect

	ret0 = WrapRect(ret)

	return ret0
}

// RectZero returns a degenerate rectangle with origin fixed at (0, 0) and a
// size of 0, 0.
func RectZero() *Rect {

	ret := C.graphene_rect_zero()

	var ret0 *Rect

	ret0 = WrapRect(ret)

	return ret0
}

// SizeZero: a constant pointer to a zero #graphene_size_t, useful for equality
// checks and interpolations.
func SizeZero() *Size {

	ret := C.graphene_size_zero()

	var ret0 *Size

	ret0 = WrapSize(ret)

	return ret0
}

// Vec2One retrieves a constant vector with (1, 1) components.
func Vec2One() *Vec2 {

	ret := C.graphene_vec2_one()

	var ret0 *Vec2

	ret0 = WrapVec2(ret)

	return ret0
}

// Vec2XAxis retrieves a constant vector with (1, 0) components.
func Vec2XAxis() *Vec2 {

	ret := C.graphene_vec2_x_axis()

	var ret0 *Vec2

	ret0 = WrapVec2(ret)

	return ret0
}

// Vec2YAxis retrieves a constant vector with (0, 1) components.
func Vec2YAxis() *Vec2 {

	ret := C.graphene_vec2_y_axis()

	var ret0 *Vec2

	ret0 = WrapVec2(ret)

	return ret0
}

// Vec2Zero retrieves a constant vector with (0, 0) components.
func Vec2Zero() *Vec2 {

	ret := C.graphene_vec2_zero()

	var ret0 *Vec2

	ret0 = WrapVec2(ret)

	return ret0
}

// Vec3One provides a constant pointer to a vector with three components, all
// sets to 1.
func Vec3One() *Vec3 {

	ret := C.graphene_vec3_one()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec3XAxis provides a constant pointer to a vector with three components with
// values set to (1, 0, 0).
func Vec3XAxis() *Vec3 {

	ret := C.graphene_vec3_x_axis()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec3YAxis provides a constant pointer to a vector with three components with
// values set to (0, 1, 0).
func Vec3YAxis() *Vec3 {

	ret := C.graphene_vec3_y_axis()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec3ZAxis provides a constant pointer to a vector with three components with
// values set to (0, 0, 1).
func Vec3ZAxis() *Vec3 {

	ret := C.graphene_vec3_z_axis()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec3Zero provides a constant pointer to a vector with three components, all
// sets to 0.
func Vec3Zero() *Vec3 {

	ret := C.graphene_vec3_zero()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec4One retrieves a pointer to a #graphene_vec4_t with all its components set
// to 1.
func Vec4One() *Vec4 {

	ret := C.graphene_vec4_one()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Vec4WAxis retrieves a pointer to a #graphene_vec4_t with its components set
// to (0, 0, 0, 1).
func Vec4WAxis() *Vec4 {

	ret := C.graphene_vec4_w_axis()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Vec4XAxis retrieves a pointer to a #graphene_vec4_t with its components set
// to (1, 0, 0, 0).
func Vec4XAxis() *Vec4 {

	ret := C.graphene_vec4_x_axis()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Vec4YAxis retrieves a pointer to a #graphene_vec4_t with its components set
// to (0, 1, 0, 0).
func Vec4YAxis() *Vec4 {

	ret := C.graphene_vec4_y_axis()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Vec4ZAxis retrieves a pointer to a #graphene_vec4_t with its components set
// to (0, 0, 1, 0).
func Vec4ZAxis() *Vec4 {

	ret := C.graphene_vec4_z_axis()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Vec4Zero retrieves a pointer to a #graphene_vec4_t with all its components
// set to 0.
func Vec4Zero() *Vec4 {

	ret := C.graphene_vec4_zero()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}

// Box: a 3D box, described as the volume between a minimum and a maximum
// vertices.
type Box struct {
	native C.graphene_box_t
}

// WrapBox wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBox(ptr unsafe.Pointer) *Box {
	if ptr == nil {
		return nil
	}

	return (*Box)(ptr)
}

func marshalBox(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBox(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (b *Box) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// New_Alloc constructs a struct Box.
func New_Alloc() *Box {

	ret := C.graphene_box_alloc()

	var ret0 *Box

	ret0 = WrapBox(ret)

	return ret0
}

// Euler: describe a rotation using Euler angles.
//
// The contents of the #graphene_euler_t structure are private and should never
// be accessed directly.
type Euler struct {
	native C.graphene_euler_t
}

// WrapEuler wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEuler(ptr unsafe.Pointer) *Euler {
	if ptr == nil {
		return nil
	}

	return (*Euler)(ptr)
}

func marshalEuler(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEuler(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (e *Euler) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// New_Alloc constructs a struct Euler.
func New_Alloc() *Euler {

	ret := C.graphene_euler_alloc()

	var ret0 *Euler

	ret0 = WrapEuler(ret)

	return ret0
}

// Frustum: a 3D volume delimited by 2D clip planes.
//
// The contents of the `graphene_frustum_t` are private, and should not be
// modified directly.
type Frustum struct {
	native C.graphene_frustum_t
}

// WrapFrustum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrustum(ptr unsafe.Pointer) *Frustum {
	if ptr == nil {
		return nil
	}

	return (*Frustum)(ptr)
}

func marshalFrustum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFrustum(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *Frustum) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// New_Alloc constructs a struct Frustum.
func New_Alloc() *Frustum {

	ret := C.graphene_frustum_alloc()

	var ret0 *Frustum

	ret0 = WrapFrustum(ret)

	return ret0
}

// Matrix: a structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and should never
// be accessed directly.
type Matrix struct {
	native C.graphene_matrix_t
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// New_Alloc constructs a struct Matrix.
func New_Alloc() *Matrix {

	ret := C.graphene_matrix_alloc()

	var ret0 *Matrix

	ret0 = WrapMatrix(ret)

	return ret0
}

// Plane: a 2D plane that extends infinitely in a 3D volume.
//
// The contents of the `graphene_plane_t` are private, and should not be
// modified directly.
type Plane struct {
	native C.graphene_plane_t
}

// WrapPlane wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPlane(ptr unsafe.Pointer) *Plane {
	if ptr == nil {
		return nil
	}

	return (*Plane)(ptr)
}

func marshalPlane(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPlane(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *Plane) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// New_Alloc constructs a struct Plane.
func New_Alloc() *Plane {

	ret := C.graphene_plane_alloc()

	var ret0 *Plane

	ret0 = WrapPlane(ret)

	return ret0
}

// Point: a point with two coordinates.
type Point struct {
	native C.graphene_point_t
}

// WrapPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPoint(ptr unsafe.Pointer) *Point {
	if ptr == nil {
		return nil
	}

	return (*Point)(ptr)
}

func marshalPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPoint(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *Point) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// New_Alloc constructs a struct Point.
func New_Alloc() *Point {

	ret := C.graphene_point_alloc()

	var ret0 *Point

	ret0 = WrapPoint(ret)

	return ret0
}

// X gets the field inside the struct.
func (x *Point) X() float32 {
	var ret float32
	ret = float32(p.native.x)
	return ret
}

// Y gets the field inside the struct.
func (y *Point) Y() float32 {
	var ret float32
	ret = float32(p.native.y)
	return ret
}

// Point3D: a point with three components: X, Y, and Z.
type Point3D struct {
	native C.graphene_point3d_t
}

// WrapPoint3D wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPoint3D(ptr unsafe.Pointer) *Point3D {
	if ptr == nil {
		return nil
	}

	return (*Point3D)(ptr)
}

func marshalPoint3D(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPoint3D(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (p *Point3D) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// New_Alloc constructs a struct Point3D.
func New_Alloc() *Point3D {

	ret := C.graphene_point3d_alloc()

	var ret0 *Point3D

	ret0 = WrapPoint3D(ret)

	return ret0
}

// X gets the field inside the struct.
func (x *Point3D) X() float32 {
	var ret float32
	ret = float32(p.native.x)
	return ret
}

// Y gets the field inside the struct.
func (y *Point3D) Y() float32 {
	var ret float32
	ret = float32(p.native.y)
	return ret
}

// Z gets the field inside the struct.
func (z *Point3D) Z() float32 {
	var ret float32
	ret = float32(p.native.z)
	return ret
}

// Quad: a 4 vertex quadrilateral, as represented by four #graphene_point_t.
//
// The contents of a #graphene_quad_t are private and should never be accessed
// directly.
type Quad struct {
	native C.graphene_quad_t
}

// WrapQuad wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQuad(ptr unsafe.Pointer) *Quad {
	if ptr == nil {
		return nil
	}

	return (*Quad)(ptr)
}

func marshalQuad(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQuad(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (q *Quad) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// New_Alloc constructs a struct Quad.
func New_Alloc() *Quad {

	ret := C.graphene_quad_alloc()

	var ret0 *Quad

	ret0 = WrapQuad(ret)

	return ret0
}

// Quaternion: a quaternion.
//
// The contents of the #graphene_quaternion_t structure are private and should
// never be accessed directly.
type Quaternion struct {
	native C.graphene_quaternion_t
}

// WrapQuaternion wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQuaternion(ptr unsafe.Pointer) *Quaternion {
	if ptr == nil {
		return nil
	}

	return (*Quaternion)(ptr)
}

func marshalQuaternion(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQuaternion(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (q *Quaternion) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// New_Alloc constructs a struct Quaternion.
func New_Alloc() *Quaternion {

	ret := C.graphene_quaternion_alloc()

	var ret0 *Quaternion

	ret0 = WrapQuaternion(ret)

	return ret0
}

// Ray: a ray emitted from an origin in a given direction.
//
// The contents of the `graphene_ray_t` structure are private, and should not be
// modified directly.
type Ray struct {
	native C.graphene_ray_t
}

// WrapRay wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRay(ptr unsafe.Pointer) *Ray {
	if ptr == nil {
		return nil
	}

	return (*Ray)(ptr)
}

func marshalRay(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRay(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *Ray) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// New_Alloc constructs a struct Ray.
func New_Alloc() *Ray {

	ret := C.graphene_ray_alloc()

	var ret0 *Ray

	ret0 = WrapRay(ret)

	return ret0
}

// Rect: the location and size of a rectangle region.
//
// The width and height of a #graphene_rect_t can be negative; for instance, a
// #graphene_rect_t with an origin of [ 0, 0 ] and a size of [ 10, 10 ] is
// equivalent to a #graphene_rect_t with an origin of [ 10, 10 ] and a size of [
// -10, -10 ].
//
// Application code can normalize rectangles using graphene_rect_normalize();
// this function will ensure that the width and height of a rectangle are
// positive values. All functions taking a #graphene_rect_t as an argument will
// internally operate on a normalized copy; all functions returning a
// #graphene_rect_t will always return a normalized rectangle.
type Rect struct {
	native C.graphene_rect_t
}

// WrapRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRect(ptr unsafe.Pointer) *Rect {
	if ptr == nil {
		return nil
	}

	return (*Rect)(ptr)
}

func marshalRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRect(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *Rect) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Origin gets the field inside the struct.
func (o *Rect) Origin() Point {
	var ret Point
	ret = WrapPoint(r.native.origin)
	return ret
}

// Size gets the field inside the struct.
func (s *Rect) Size() Size {
	var ret Size
	ret = WrapSize(r.native.size)
	return ret
}

type SIMD4F struct {
	native C.graphene_simd4f_t
}

// WrapSIMD4F wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSIMD4F(ptr unsafe.Pointer) *SIMD4F {
	if ptr == nil {
		return nil
	}

	return (*SIMD4F)(ptr)
}

func marshalSIMD4F(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSIMD4F(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SIMD4F) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

type SIMD4X4F struct {
	native C.graphene_simd4x4f_t
}

// WrapSIMD4X4F wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSIMD4X4F(ptr unsafe.Pointer) *SIMD4X4F {
	if ptr == nil {
		return nil
	}

	return (*SIMD4X4F)(ptr)
}

func marshalSIMD4X4F(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSIMD4X4F(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SIMD4X4F) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Size: a size.
type Size struct {
	native C.graphene_size_t
}

// WrapSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSize(ptr unsafe.Pointer) *Size {
	if ptr == nil {
		return nil
	}

	return (*Size)(ptr)
}

func marshalSize(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSize(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *Size) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// New_Alloc constructs a struct Size.
func New_Alloc() *Size {

	ret := C.graphene_size_alloc()

	var ret0 *Size

	ret0 = WrapSize(ret)

	return ret0
}

// Width gets the field inside the struct.
func (w *Size) Width() float32 {
	var ret float32
	ret = float32(s.native.width)
	return ret
}

// Height gets the field inside the struct.
func (h *Size) Height() float32 {
	var ret float32
	ret = float32(s.native.height)
	return ret
}

// Sphere: a sphere, represented by its center and radius.
type Sphere struct {
	native C.graphene_sphere_t
}

// WrapSphere wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSphere(ptr unsafe.Pointer) *Sphere {
	if ptr == nil {
		return nil
	}

	return (*Sphere)(ptr)
}

func marshalSphere(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSphere(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *Sphere) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// New_Alloc constructs a struct Sphere.
func New_Alloc() *Sphere {

	ret := C.graphene_sphere_alloc()

	var ret0 *Sphere

	ret0 = WrapSphere(ret)

	return ret0
}

// Triangle: a triangle.
type Triangle struct {
	native C.graphene_triangle_t
}

// WrapTriangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTriangle(ptr unsafe.Pointer) *Triangle {
	if ptr == nil {
		return nil
	}

	return (*Triangle)(ptr)
}

func marshalTriangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTriangle(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (t *Triangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// New_Alloc constructs a struct Triangle.
func New_Alloc() *Triangle {

	ret := C.graphene_triangle_alloc()

	var ret0 *Triangle

	ret0 = WrapTriangle(ret)

	return ret0
}

// Vec2: a structure capable of holding a vector with two dimensions, x and y.
//
// The contents of the #graphene_vec2_t structure are private and should never
// be accessed directly.
type Vec2 struct {
	native C.graphene_vec2_t
}

// WrapVec2 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec2(ptr unsafe.Pointer) *Vec2 {
	if ptr == nil {
		return nil
	}

	return (*Vec2)(ptr)
}

func marshalVec2(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec2(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (v *Vec2) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// New_Alloc constructs a struct Vec2.
func New_Alloc() *Vec2 {

	ret := C.graphene_vec2_alloc()

	var ret0 *Vec2

	ret0 = WrapVec2(ret)

	return ret0
}

// Vec3: a structure capable of holding a vector with three dimensions: x, y,
// and z.
//
// The contents of the #graphene_vec3_t structure are private and should never
// be accessed directly.
type Vec3 struct {
	native C.graphene_vec3_t
}

// WrapVec3 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec3(ptr unsafe.Pointer) *Vec3 {
	if ptr == nil {
		return nil
	}

	return (*Vec3)(ptr)
}

func marshalVec3(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec3(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (v *Vec3) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// New_Alloc constructs a struct Vec3.
func New_Alloc() *Vec3 {

	ret := C.graphene_vec3_alloc()

	var ret0 *Vec3

	ret0 = WrapVec3(ret)

	return ret0
}

// Vec4: a structure capable of holding a vector with four dimensions: x, y, z,
// and w.
//
// The contents of the #graphene_vec4_t structure are private and should never
// be accessed directly.
type Vec4 struct {
	native C.graphene_vec4_t
}

// WrapVec4 wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapVec4(ptr unsafe.Pointer) *Vec4 {
	if ptr == nil {
		return nil
	}

	return (*Vec4)(ptr)
}

func marshalVec4(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapVec4(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (v *Vec4) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// New_Alloc constructs a struct Vec4.
func New_Alloc() *Vec4 {

	ret := C.graphene_vec4_alloc()

	var ret0 *Vec4

	ret0 = WrapVec4(ret)

	return ret0
}
