// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_rect_get_type()), F: marshalRect},
	})
}

// Rect: the location and size of a rectangle region.
//
// The width and height of a #graphene_rect_t can be negative; for instance, a
// #graphene_rect_t with an origin of [ 0, 0 ] and a size of [ 10, 10 ] is
// equivalent to a #graphene_rect_t with an origin of [ 10, 10 ] and a size of [
// -10, -10 ].
//
// Application code can normalize rectangles using graphene_rect_normalize();
// this function will ensure that the width and height of a rectangle are
// positive values. All functions taking a #graphene_rect_t as an argument will
// internally operate on a normalized copy; all functions returning a
// #graphene_rect_t will always return a normalized rectangle.
type Rect C.graphene_rect_t

// WrapRect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRect(ptr unsafe.Pointer) *Rect {
	return (*Rect)(ptr)
}

func marshalRect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Rect)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rect) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// ContainsPoint computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) ContainsPoint(p *Point) bool {
	var _arg0 *C.graphene_rect_t  // out
	var _arg1 *C.graphene_point_t // out
	var _cret C._Bool             // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_rect_contains_point(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainsRect computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) ContainsRect(b *Rect) bool {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_contains_rect(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Equal(b *Rect) bool {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Expand computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Expand(p *Point) Rect {
	var _arg0 *C.graphene_rect_t  // out
	var _arg1 *C.graphene_point_t // out
	var _arg2 C.graphene_rect_t   // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_rect_expand(_arg0, _arg1, &_arg2)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Free computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Free() {
	var _arg0 *C.graphene_rect_t // out

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_free(_arg0)
}

// Area computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Area() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_area(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BottomLeft computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) BottomLeft() Point {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_point_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_bottom_left(_arg0, &_arg1)

	var _p Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_p = *refTmpOut
	}

	return _p
}

// BottomRight computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) BottomRight() Point {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_point_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_bottom_right(_arg0, &_arg1)

	var _p Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_p = *refTmpOut
	}

	return _p
}

// Center computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Center() Point {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_point_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_center(_arg0, &_arg1)

	var _p Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_p = *refTmpOut
	}

	return _p
}

// Height computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Height() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_height(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// TopLeft computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) TopLeft() Point {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_point_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_top_left(_arg0, &_arg1)

	var _p Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_p = *refTmpOut
	}

	return _p
}

// TopRight computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) TopRight() Point {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_point_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_top_right(_arg0, &_arg1)

	var _p Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_p = *refTmpOut
	}

	return _p
}

// Vertices computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Vertices() [4]Vec2 {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 [4]C.graphene_vec2_t

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_get_vertices(_arg0, &_arg1[0])

	var _vertices [4]Vec2

	_vertices = *(*[4]Vec2)(unsafe.Pointer(&_arg1))

	return _vertices
}

// Width computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Width() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_width(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// X computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) X() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_x(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Y computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Y() float32 {
	var _arg0 *C.graphene_rect_t // out
	var _cret C.float            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_get_y(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Init computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Init(x float32, y float32, width float32, height float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.float            // out
	var _arg4 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(x)
	_arg2 = C.float(y)
	_arg3 = C.float(width)
	_arg4 = C.float(height)

	_cret = C.graphene_rect_init(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// InitFromRect computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) InitFromRect(src *Rect) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_rect_init_from_rect(_arg0, _arg1)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// Inset computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Inset(dX float32, dY float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(dX)
	_arg2 = C.float(dY)

	_cret = C.graphene_rect_inset(_arg0, _arg1, _arg2)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// InsetR computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) InsetR(dX float32, dY float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(dX)
	_arg2 = C.float(dY)

	C.graphene_rect_inset_r(_arg0, _arg1, _arg2, &_arg3)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Interpolate computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Interpolate(b *Rect, factor float64) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.double           // out
	var _arg3 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))
	_arg2 = C.double(factor)

	C.graphene_rect_interpolate(_arg0, _arg1, _arg2, &_arg3)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Intersection computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Intersection(b *Rect) (Rect, bool) {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.graphene_rect_t  // in
	var _cret C._Bool            // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_rect_intersection(_arg0, _arg1, &_arg2)

	var _res Rect // out
	var _ok bool  // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}
	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Normalize computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Normalize() *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_normalize(_arg0)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// NormalizeR computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) NormalizeR() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_normalize_r(_arg0, &_arg1)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Offset computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Offset(dX float32, dY float32) *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(dX)
	_arg2 = C.float(dY)

	_cret = C.graphene_rect_offset(_arg0, _arg1, _arg2)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// OffsetR computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) OffsetR(dX float32, dY float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(dX)
	_arg2 = C.float(dY)

	C.graphene_rect_offset_r(_arg0, _arg1, _arg2, &_arg3)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Round computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Round() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_round(_arg0, &_arg1)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// RoundExtents computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) RoundExtents() Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_rect_round_extents(_arg0, &_arg1)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// RoundToPixel computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) RoundToPixel() *Rect {
	var _arg0 *C.graphene_rect_t // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	_cret = C.graphene_rect_round_to_pixel(_arg0)

	var _rect *Rect // out

	_rect = (*Rect)(unsafe.Pointer(_cret))

	return _rect
}

// Scale computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Scale(sH float32, sV float32) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out
	var _arg3 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg1 = C.float(sH)
	_arg2 = C.float(sV)

	C.graphene_rect_scale(_arg0, _arg1, _arg2, &_arg3)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Union computes the union of the two given rectangles.
//
// ! (rectangle-union.png)
//
// The union in the image above is the blue outline.
func (a *Rect) Union(b *Rect) Rect {
	var _arg0 *C.graphene_rect_t // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 C.graphene_rect_t  // in

	_arg0 = (*C.graphene_rect_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(b.Native()))

	C.graphene_rect_union(_arg0, _arg1, &_arg2)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}
