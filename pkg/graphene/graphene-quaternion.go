// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_quaternion_get_type()), F: marshalQuaternion},
	})
}

// Quaternion: a quaternion.
//
// The contents of the #graphene_quaternion_t structure are private and should
// never be accessed directly.
type Quaternion struct {
	native C.graphene_quaternion_t
}

// WrapQuaternion wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapQuaternion(ptr unsafe.Pointer) *Quaternion {
	if ptr == nil {
		return nil
	}

	return (*Quaternion)(ptr)
}

func marshalQuaternion(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapQuaternion(unsafe.Pointer(b)), nil
}

// NewQuaternionAlloc constructs a struct Quaternion.
func NewQuaternionAlloc() {
	C.graphene_quaternion_alloc()
}

// Native returns the underlying C source pointer.
func (q *Quaternion) Native() unsafe.Pointer {
	return unsafe.Pointer(&q.native)
}

// Add adds two #graphene_quaternion_t @a and @b.
func (a *Quaternion) Add(a *Quaternion, b *Quaternion) *Quaternion {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	var arg2 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_add(arg0, arg1, &arg2)

	res = WrapQuaternion(unsafe.Pointer(&arg2))

	return res
}

// Dot computes the dot product of two #graphene_quaternion_t.
func (a *Quaternion) Dot(a *Quaternion, b *Quaternion) {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	C.graphene_quaternion_dot(arg0, arg1)
}

// Equal checks whether the given quaternions are equal.
func (a *Quaternion) Equal(a *Quaternion, b *Quaternion) bool {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_quaternion_equal(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Free releases the resources allocated by graphene_quaternion_alloc().
func (q *Quaternion) Free(q *Quaternion) {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_free(arg0)
}

// Init initializes a #graphene_quaternion_t using the given four values.
func (q *Quaternion) Init(q *Quaternion, x float32, y float32, z float32, w float32) {
	var arg0 *C.graphene_quaternion_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = C.float(x)
	arg2 = C.float(y)
	arg3 = C.float(z)
	arg4 = C.float(w)

	C.graphene_quaternion_init(arg0, arg1, arg2, arg3, arg4)
}

// InitFromAngleVec3 initializes a #graphene_quaternion_t using an @angle on a
// specific @axis.
func (q *Quaternion) InitFromAngleVec3(q *Quaternion, angle float32, axis *Vec3) {
	var arg0 *C.graphene_quaternion_t
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.graphene_quaternion_init_from_angle_vec3(arg0, arg1, arg2)
}

// InitFromAngles initializes a #graphene_quaternion_t using the values of the
// Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
//
// See also: graphene_quaternion_init_from_euler()
func (q *Quaternion) InitFromAngles(q *Quaternion, degX float32, degY float32, degZ float32) {
	var arg0 *C.graphene_quaternion_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = C.float(degX)
	arg2 = C.float(degY)
	arg3 = C.float(degZ)

	C.graphene_quaternion_init_from_angles(arg0, arg1, arg2, arg3)
}

// InitFromEuler initializes a #graphene_quaternion_t using the given
// #graphene_euler_t.
func (q *Quaternion) InitFromEuler(q *Quaternion, e *Euler) {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_euler_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_quaternion_init_from_euler(arg0, arg1)
}

// InitFromMatrix initializes a #graphene_quaternion_t using the rotation
// components of a transformation matrix.
func (q *Quaternion) InitFromMatrix(q *Quaternion, m *Matrix) {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_quaternion_init_from_matrix(arg0, arg1)
}

// InitFromQuaternion initializes a #graphene_quaternion_t with the values from
// @src.
func (q *Quaternion) InitFromQuaternion(q *Quaternion, src *Quaternion) {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(src.Native()))

	C.graphene_quaternion_init_from_quaternion(arg0, arg1)
}

// InitFromRadians initializes a #graphene_quaternion_t using the values of the
// Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
//
// See also: graphene_quaternion_init_from_euler()
func (q *Quaternion) InitFromRadians(q *Quaternion, radX float32, radY float32, radZ float32) {
	var arg0 *C.graphene_quaternion_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = C.float(radX)
	arg2 = C.float(radY)
	arg3 = C.float(radZ)

	C.graphene_quaternion_init_from_radians(arg0, arg1, arg2, arg3)
}

// InitFromVec4 initializes a #graphene_quaternion_t with the values from @src.
func (q *Quaternion) InitFromVec4(q *Quaternion, src *Vec4) {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_vec4_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(src.Native()))

	C.graphene_quaternion_init_from_vec4(arg0, arg1)
}

// InitIdentity initializes a #graphene_quaternion_t using the identity
// transformation.
func (q *Quaternion) InitIdentity(q *Quaternion) {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_quaternion_init_identity(arg0)
}

// Invert inverts a #graphene_quaternion_t, and returns the conjugate quaternion
// of @q.
func (q *Quaternion) Invert(q *Quaternion) *Quaternion {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_invert(arg0, &arg1)

	res = WrapQuaternion(unsafe.Pointer(&arg1))

	return res
}

// Multiply multiplies two #graphene_quaternion_t @a and @b.
func (a *Quaternion) Multiply(a *Quaternion, b *Quaternion) *Quaternion {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))

	var arg2 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_multiply(arg0, arg1, &arg2)

	res = WrapQuaternion(unsafe.Pointer(&arg2))

	return res
}

// Normalize normalizes a #graphene_quaternion_t.
func (q *Quaternion) Normalize(q *Quaternion) *Quaternion {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_normalize(arg0, &arg1)

	res = WrapQuaternion(unsafe.Pointer(&arg1))

	return res
}

// Scale scales all the elements of a #graphene_quaternion_t @q using the given
// scalar factor.
func (q *Quaternion) Scale(q *Quaternion, factor float32) *Quaternion {
	var arg0 *C.graphene_quaternion_t
	var arg1 C.float

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))
	arg1 = C.float(factor)

	var arg2 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_scale(arg0, arg1, &arg2)

	res = WrapQuaternion(unsafe.Pointer(&arg2))

	return res
}

// Slerp interpolates between the two given quaternions using a spherical linear
// interpolation, or SLERP (http://en.wikipedia.org/wiki/Slerp), using the given
// interpolation @factor.
func (a *Quaternion) Slerp(a *Quaternion, b *Quaternion, factor float32) *Quaternion {
	var arg0 *C.graphene_quaternion_t
	var arg1 *C.graphene_quaternion_t
	var arg2 C.float

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(b.Native()))
	arg2 = C.float(factor)

	var arg3 C.graphene_quaternion_t
	var res *Quaternion

	C.graphene_quaternion_slerp(arg0, arg1, arg2, &arg3)

	res = WrapQuaternion(unsafe.Pointer(&arg3))

	return res
}

// ToAngleVec3 converts a quaternion into an @angle, @axis pair.
func (q *Quaternion) ToAngleVec3(q *Quaternion) (angle float32, axis *Vec3) {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.float
	var angle float32
	var arg2 C.graphene_vec3_t
	var axis *Vec3

	C.graphene_quaternion_to_angle_vec3(arg0, &arg1, &arg2)

	angle = float32(&arg1)
	axis = WrapVec3(unsafe.Pointer(&arg2))

	return angle, axis
}

// ToAngles converts a #graphene_quaternion_t to its corresponding rotations on
// the Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
func (q *Quaternion) ToAngles(q *Quaternion) (degX float32, degY float32, degZ float32) {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.float
	var degX float32
	var arg2 C.float
	var degY float32
	var arg3 C.float
	var degZ float32

	C.graphene_quaternion_to_angles(arg0, &arg1, &arg2, &arg3)

	degX = float32(&arg1)
	degY = float32(&arg2)
	degZ = float32(&arg3)

	return degX, degY, degZ
}

// ToMatrix converts a quaternion into a transformation matrix expressing the
// rotation defined by the #graphene_quaternion_t.
func (q *Quaternion) ToMatrix(q *Quaternion) *Matrix {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.graphene_matrix_t
	var m *Matrix

	C.graphene_quaternion_to_matrix(arg0, &arg1)

	m = WrapMatrix(unsafe.Pointer(&arg1))

	return m
}

// ToRadians converts a #graphene_quaternion_t to its corresponding rotations on
// the Euler angles (http://en.wikipedia.org/wiki/Euler_angles) on each axis.
func (q *Quaternion) ToRadians(q *Quaternion) (radX float32, radY float32, radZ float32) {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.float
	var radX float32
	var arg2 C.float
	var radY float32
	var arg3 C.float
	var radZ float32

	C.graphene_quaternion_to_radians(arg0, &arg1, &arg2, &arg3)

	radX = float32(&arg1)
	radY = float32(&arg2)
	radZ = float32(&arg3)

	return radX, radY, radZ
}

// ToVec4 copies the components of a #graphene_quaternion_t into a
// #graphene_vec4_t.
func (q *Quaternion) ToVec4(q *Quaternion) *Vec4 {
	var arg0 *C.graphene_quaternion_t

	arg0 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	var arg1 C.graphene_vec4_t
	var res *Vec4

	C.graphene_quaternion_to_vec4(arg0, &arg1)

	res = WrapVec4(unsafe.Pointer(&arg1))

	return res
}
