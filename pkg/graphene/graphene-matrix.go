// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_matrix_get_type()), F: marshalMatrix},
	})
}

// Matrix: a structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and should never
// be accessed directly.
type Matrix C.graphene_matrix_t

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Matrix)(unsafe.Pointer(b)), nil
}

// NewMatrixAlloc constructs a struct Matrix.
func NewMatrixAlloc() *Matrix {
	var _cret *C.graphene_matrix_t // in

	_cret = C.graphene_matrix_alloc()

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_matrix, func(v **Matrix) {
		C.free(unsafe.Pointer(v))
	})

	return _matrix
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(m)
}

// Decompose undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Decompose() (translate Vec3, scale Vec3, rotate Quaternion, shear Vec3, perspective Vec4, ok bool) {
	var _arg0 *C.graphene_matrix_t    // out
	var _arg1 C.graphene_vec3_t       // in
	var _arg2 C.graphene_vec3_t       // in
	var _arg3 C.graphene_quaternion_t // in
	var _arg4 C.graphene_vec3_t       // in
	var _arg5 C.graphene_vec4_t       // in
	var _cret C._Bool                 // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_decompose(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)

	var _translate Vec3    // out
	var _scale Vec3        // out
	var _rotate Quaternion // out
	var _shear Vec3        // out
	var _perspective Vec4  // out
	var _ok bool           // out

	{
		var refTmpIn *C.graphene_vec3_t
		var refTmpOut *Vec3

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Vec3)(unsafe.Pointer(refTmpIn))

		_translate = *refTmpOut
	}
	{
		var refTmpIn *C.graphene_vec3_t
		var refTmpOut *Vec3

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Vec3)(unsafe.Pointer(refTmpIn))

		_scale = *refTmpOut
	}
	{
		var refTmpIn *C.graphene_quaternion_t
		var refTmpOut *Quaternion

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Quaternion)(unsafe.Pointer(refTmpIn))

		_rotate = *refTmpOut
	}
	{
		var refTmpIn *C.graphene_vec3_t
		var refTmpOut *Vec3

		in0 := &_arg4
		refTmpIn = in0

		refTmpOut = (*Vec3)(unsafe.Pointer(refTmpIn))

		_shear = *refTmpOut
	}
	{
		var refTmpIn *C.graphene_vec4_t
		var refTmpOut *Vec4

		in0 := &_arg5
		refTmpIn = in0

		refTmpOut = (*Vec4)(unsafe.Pointer(refTmpIn))

		_perspective = *refTmpOut
	}
	if _cret {
		_ok = true
	}

	return _translate, _scale, _rotate, _shear, _perspective, _ok
}

// Determinant undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Determinant() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_determinant(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Equal undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Equal(b *Matrix) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_matrix_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// EqualFast undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) EqualFast(b *Matrix) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	_cret = C.graphene_matrix_equal_fast(_arg0, _arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Free undoes the transformation of a #graphene_point_t using the given matrix,
// within the given axis aligned rectangular @bounds.
func (m *Matrix) Free() {
	var _arg0 *C.graphene_matrix_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_free(_arg0)
}

// Row undoes the transformation of a #graphene_point_t using the given matrix,
// within the given axis aligned rectangular @bounds.
func (m *Matrix) Row(index_ uint) Vec4 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.uint               // out
	var _arg2 C.graphene_vec4_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.uint(index_)

	C.graphene_matrix_get_row(_arg0, _arg1, &_arg2)

	var _res Vec4 // out

	{
		var refTmpIn *C.graphene_vec4_t
		var refTmpOut *Vec4

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Vec4)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Value undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Value(row uint, col uint) float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.uint               // out
	var _arg2 C.uint               // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.uint(row)
	_arg2 = C.uint(col)

	_cret = C.graphene_matrix_get_value(_arg0, _arg1, _arg2)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// XScale undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) XScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_x_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// XTranslation undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) XTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_x_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YScale undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) YScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_y_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YTranslation undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) YTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_y_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ZScale undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ZScale() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_z_scale(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ZTranslation undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ZTranslation() float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C.float              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_get_z_translation(_arg0)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// InitFrom2D undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitFrom2D(xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.double             // out
	var _arg2 C.double             // out
	var _arg3 C.double             // out
	var _arg4 C.double             // out
	var _arg5 C.double             // out
	var _arg6 C.double             // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.double(xx)
	_arg2 = C.double(yx)
	_arg3 = C.double(xy)
	_arg4 = C.double(yy)
	_arg5 = C.double(x0)
	_arg6 = C.double(y0)

	_cret = C.graphene_matrix_init_from_2d(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromFloat undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitFromFloat(v [16]float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.float
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.float)(unsafe.Pointer(&v))

	_cret = C.graphene_matrix_init_from_float(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromMatrix undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitFromMatrix(src *Matrix) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(src.Native()))

	_cret = C.graphene_matrix_init_from_matrix(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitFromVec4 undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitFromVec4(v0 *Vec4, v1 *Vec4, v2 *Vec4, v3 *Vec4) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec4_t   // out
	var _arg2 *C.graphene_vec4_t   // out
	var _arg3 *C.graphene_vec4_t   // out
	var _arg4 *C.graphene_vec4_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v0.Native()))
	_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(v1.Native()))
	_arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))
	_arg4 = (*C.graphene_vec4_t)(unsafe.Pointer(v3.Native()))

	_cret = C.graphene_matrix_init_from_vec4(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitFrustum undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitFrustum(left float32, right float32, bottom float32, top float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out
	var _arg6 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(left)
	_arg2 = C.float(right)
	_arg3 = C.float(bottom)
	_arg4 = C.float(top)
	_arg5 = C.float(zNear)
	_arg6 = C.float(zFar)

	_cret = C.graphene_matrix_init_frustum(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitIdentity undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitIdentity() *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_init_identity(_arg0)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitLookAt undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitLookAt(eye *Vec3, center *Vec3, up *Vec3) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec3_t   // out
	var _arg2 *C.graphene_vec3_t   // out
	var _arg3 *C.graphene_vec3_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(eye.Native()))
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(center.Native()))
	_arg3 = (*C.graphene_vec3_t)(unsafe.Pointer(up.Native()))

	_cret = C.graphene_matrix_init_look_at(_arg0, _arg1, _arg2, _arg3)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitOrtho undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitOrtho(left float32, right float32, top float32, bottom float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out
	var _arg6 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(left)
	_arg2 = C.float(right)
	_arg3 = C.float(top)
	_arg4 = C.float(bottom)
	_arg5 = C.float(zNear)
	_arg6 = C.float(zFar)

	_cret = C.graphene_matrix_init_ortho(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitPerspective undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitPerspective(fovy float32, aspect float32, zNear float32, zFar float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _arg4 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(fovy)
	_arg2 = C.float(aspect)
	_arg3 = C.float(zNear)
	_arg4 = C.float(zFar)

	_cret = C.graphene_matrix_init_perspective(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitRotate undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitRotate(angle float32, axis *Vec3) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 *C.graphene_vec3_t   // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	_cret = C.graphene_matrix_init_rotate(_arg0, _arg1, _arg2)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitScale undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitScale(x float32, y float32, z float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(x)
	_arg2 = C.float(y)
	_arg3 = C.float(z)

	_cret = C.graphene_matrix_init_scale(_arg0, _arg1, _arg2, _arg3)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitSkew undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitSkew(xSkew float32, ySkew float32) *Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(xSkew)
	_arg2 = C.float(ySkew)

	_cret = C.graphene_matrix_init_skew(_arg0, _arg1, _arg2)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// InitTranslate undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) InitTranslate(p *Point3D) *Matrix {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _cret *C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	_cret = C.graphene_matrix_init_translate(_arg0, _arg1)

	var _matrix *Matrix // out

	_matrix = (*Matrix)(unsafe.Pointer(_cret))

	return _matrix
}

// Interpolate undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Interpolate(b *Matrix, factor float64) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 C.double             // out
	var _arg3 C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	_arg2 = C.double(factor)

	C.graphene_matrix_interpolate(_arg0, _arg1, _arg2, &_arg3)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Inverse undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Inverse() (Matrix, bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.graphene_matrix_t  // in
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_inverse(_arg0, &_arg1)

	var _res Matrix // out
	var _ok bool    // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}
	if _cret {
		_ok = true
	}

	return _res, _ok
}

// Is2D undoes the transformation of a #graphene_point_t using the given matrix,
// within the given axis aligned rectangular @bounds.
func (m *Matrix) Is2D() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_2d(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsBackfaceVisible undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) IsBackfaceVisible() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_backface_visible(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsIdentity undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) IsIdentity() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_identity(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// IsSingular undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) IsSingular() bool {
	var _arg0 *C.graphene_matrix_t // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_is_singular(_arg0)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Multiply undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Multiply(b *Matrix) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	C.graphene_matrix_multiply(_arg0, _arg1, &_arg2)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Near undoes the transformation of a #graphene_point_t using the given matrix,
// within the given axis aligned rectangular @bounds.
func (m *Matrix) Near(b *Matrix, epsilon float32) bool {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 C.float              // out
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	_arg2 = C.float(epsilon)

	_cret = C.graphene_matrix_near(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// Normalize undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Normalize() Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_normalize(_arg0, &_arg1)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Perspective undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Perspective(depth float32) Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(depth)

	C.graphene_matrix_perspective(_arg0, _arg1, &_arg2)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Print undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Print() {
	var _arg0 *C.graphene_matrix_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_print(_arg0)
}

// ProjectPoint undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ProjectPoint(p *Point) Point {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _arg2 C.graphene_point_t   // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_project_point(_arg0, _arg1, &_arg2)

	var _res Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// ProjectRect undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ProjectRect(r *Rect) Quad {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 C.graphene_quad_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_project_rect(_arg0, _arg1, &_arg2)

	var _res Quad // out

	{
		var refTmpIn *C.graphene_quad_t
		var refTmpOut *Quad

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Quad)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// ProjectRectBounds undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ProjectRectBounds(r *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 C.graphene_rect_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_project_rect_bounds(_arg0, _arg1, &_arg2)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Rotate undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Rotate(angle float32, axis *Vec3) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 *C.graphene_vec3_t   // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.graphene_matrix_rotate(_arg0, _arg1, _arg2)
}

// RotateEuler undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) RotateEuler(e *Euler) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_euler_t  // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_matrix_rotate_euler(_arg0, _arg1)
}

// RotateQuaternion undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) RotateQuaternion(q *Quaternion) {
	var _arg0 *C.graphene_matrix_t     // out
	var _arg1 *C.graphene_quaternion_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_matrix_rotate_quaternion(_arg0, _arg1)
}

// RotateX undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) RotateX(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(angle)

	C.graphene_matrix_rotate_x(_arg0, _arg1)
}

// RotateY undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) RotateY(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(angle)

	C.graphene_matrix_rotate_y(_arg0, _arg1)
}

// RotateZ undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) RotateZ(angle float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(angle)

	C.graphene_matrix_rotate_z(_arg0, _arg1)
}

// Scale undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Scale(factorX float32, factorY float32, factorZ float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out
	var _arg2 C.float              // out
	var _arg3 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)
	_arg3 = C.float(factorZ)

	C.graphene_matrix_scale(_arg0, _arg1, _arg2, _arg3)
}

// SkewXY undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) SkewXY(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(factor)

	C.graphene_matrix_skew_xy(_arg0, _arg1)
}

// SkewXZ undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) SkewXZ(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(factor)

	C.graphene_matrix_skew_xz(_arg0, _arg1)
}

// SkewYZ undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) SkewYZ(factor float32) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.float              // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = C.float(factor)

	C.graphene_matrix_skew_yz(_arg0, _arg1)
}

// To2D undoes the transformation of a #graphene_point_t using the given matrix,
// within the given axis aligned rectangular @bounds.
func (m *Matrix) To2D() (xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64, ok bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.double             // in
	var _arg2 C.double             // in
	var _arg3 C.double             // in
	var _arg4 C.double             // in
	var _arg5 C.double             // in
	var _arg6 C.double             // in
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	_cret = C.graphene_matrix_to_2d(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _xx float64 // out
	var _yx float64 // out
	var _xy float64 // out
	var _yy float64 // out
	var _x0 float64 // out
	var _y0 float64 // out
	var _ok bool    // out

	_xx = float64(_arg1)
	_yx = float64(_arg2)
	_xy = float64(_arg3)
	_yy = float64(_arg4)
	_x0 = float64(_arg5)
	_y0 = float64(_arg6)
	if _cret {
		_ok = true
	}

	return _xx, _yx, _xy, _yy, _x0, _y0, _ok
}

// ToFloat undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) ToFloat() [16]float32 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 [16]C.float

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_to_float(_arg0, &_arg1[0])

	var _v [16]float32

	_v = *(*[16]float32)(unsafe.Pointer(&_arg1))

	return _v
}

// TransformBounds undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformBounds(r *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 C.graphene_rect_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_bounds(_arg0, _arg1, &_arg2)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformBox undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformBox(b *Box) Box {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_box_t    // out
	var _arg2 C.graphene_box_t     // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	C.graphene_matrix_transform_box(_arg0, _arg1, &_arg2)

	var _res Box // out

	{
		var refTmpIn *C.graphene_box_t
		var refTmpOut *Box

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Box)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformPoint undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformPoint(p *Point) Point {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _arg2 C.graphene_point_t   // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_transform_point(_arg0, _arg1, &_arg2)

	var _res Point // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformPoint3D undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformPoint3D(p *Point3D) Point3D {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out
	var _arg2 C.graphene_point3d_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_transform_point3d(_arg0, _arg1, &_arg2)

	var _res Point3D // out

	{
		var refTmpIn *C.graphene_point3d_t
		var refTmpOut *Point3D

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Point3D)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformRay undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformRay(r *Ray) Ray {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_ray_t    // out
	var _arg2 C.graphene_ray_t     // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_ray(_arg0, _arg1, &_arg2)

	var _res Ray // out

	{
		var refTmpIn *C.graphene_ray_t
		var refTmpOut *Ray

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Ray)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformRect undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformRect(r *Rect) Quad {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 C.graphene_quad_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	C.graphene_matrix_transform_rect(_arg0, _arg1, &_arg2)

	var _res Quad // out

	{
		var refTmpIn *C.graphene_quad_t
		var refTmpOut *Quad

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Quad)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformSphere undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformSphere(s *Sphere) Sphere {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_sphere_t // out
	var _arg2 C.graphene_sphere_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	C.graphene_matrix_transform_sphere(_arg0, _arg1, &_arg2)

	var _res Sphere // out

	{
		var refTmpIn *C.graphene_sphere_t
		var refTmpOut *Sphere

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Sphere)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformVec3 undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformVec3(v *Vec3) Vec3 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec3_t   // out
	var _arg2 C.graphene_vec3_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	C.graphene_matrix_transform_vec3(_arg0, _arg1, &_arg2)

	var _res Vec3 // out

	{
		var refTmpIn *C.graphene_vec3_t
		var refTmpOut *Vec3

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Vec3)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// TransformVec4 undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) TransformVec4(v *Vec4) Vec4 {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_vec4_t   // out
	var _arg2 C.graphene_vec4_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	C.graphene_matrix_transform_vec4(_arg0, _arg1, &_arg2)

	var _res Vec4 // out

	{
		var refTmpIn *C.graphene_vec4_t
		var refTmpOut *Vec4

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Vec4)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// Translate undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Translate(pos *Point3D) {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_point3d_t // out

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(pos.Native()))

	C.graphene_matrix_translate(_arg0, _arg1)
}

// Transpose undoes the transformation of a #graphene_point_t using the given
// matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) Transpose() Matrix {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 C.graphene_matrix_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_transpose(_arg0, &_arg1)

	var _res Matrix // out

	{
		var refTmpIn *C.graphene_matrix_t
		var refTmpOut *Matrix

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Matrix)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// UnprojectPoint3D undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UnprojectPoint3D(modelview *Matrix, point *Point3D) Point3D {
	var _arg0 *C.graphene_matrix_t  // out
	var _arg1 *C.graphene_matrix_t  // out
	var _arg2 *C.graphene_point3d_t // out
	var _arg3 C.graphene_point3d_t  // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(modelview.Native()))
	_arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	C.graphene_matrix_unproject_point3d(_arg0, _arg1, _arg2, &_arg3)

	var _res Point3D // out

	{
		var refTmpIn *C.graphene_point3d_t
		var refTmpOut *Point3D

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Point3D)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// UntransformBounds undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UntransformBounds(r *Rect, bounds *Rect) Rect {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_rect_t   // out
	var _arg2 *C.graphene_rect_t   // out
	var _arg3 C.graphene_rect_t    // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	C.graphene_matrix_untransform_bounds(_arg0, _arg1, _arg2, &_arg3)

	var _res Rect // out

	{
		var refTmpIn *C.graphene_rect_t
		var refTmpOut *Rect

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Rect)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}

	return _res
}

// UntransformPoint undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UntransformPoint(p *Point, bounds *Rect) (Point, bool) {
	var _arg0 *C.graphene_matrix_t // out
	var _arg1 *C.graphene_point_t  // out
	var _arg2 *C.graphene_rect_t   // out
	var _arg3 C.graphene_point_t   // in
	var _cret C._Bool              // in

	_arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	_cret = C.graphene_matrix_untransform_point(_arg0, _arg1, _arg2, &_arg3)

	var _res Point // out
	var _ok bool   // out

	{
		var refTmpIn *C.graphene_point_t
		var refTmpOut *Point

		in0 := &_arg3
		refTmpIn = in0

		refTmpOut = (*Point)(unsafe.Pointer(refTmpIn))

		_res = *refTmpOut
	}
	if _cret {
		_ok = true
	}

	return _res, _ok
}
