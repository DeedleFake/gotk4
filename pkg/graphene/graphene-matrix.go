// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_matrix_get_type()), F: marshalMatrix},
	})
}

// Matrix: a structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and should never
// be accessed directly.
type Matrix struct {
	native C.graphene_matrix_t
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b)), nil
}

// NewMatrixAlloc constructs a struct Matrix.
func NewMatrixAlloc() {
	C.graphene_matrix_alloc()
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Decompose decomposes a transformation matrix into its component
// transformations.
//
// The algorithm for decomposing a matrix is taken from the CSS3 Transforms
// specification (http://dev.w3.org/csswg/css-transforms/); specifically, the
// decomposition code is based on the equivalent code published in "Graphics
// Gems II", edited by Jim Arvo, and available online
// (http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c).
func (m *Matrix) Decompose(m *Matrix) (translate *Vec3, scale *Vec3, rotate *Quaternion, shear *Vec3, perspective *Vec4, ok bool) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 C.graphene_vec3_t
	var translate *Vec3
	var arg2 C.graphene_vec3_t
	var scale *Vec3
	var arg3 C.graphene_quaternion_t
	var rotate *Quaternion
	var arg4 C.graphene_vec3_t
	var shear *Vec3
	var arg5 C.graphene_vec4_t
	var perspective *Vec4
	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_decompose(arg0, &arg1, &arg2, &arg3, &arg4, &arg5)

	translate = WrapVec3(unsafe.Pointer(&arg1))
	scale = WrapVec3(unsafe.Pointer(&arg2))
	rotate = WrapQuaternion(unsafe.Pointer(&arg3))
	shear = WrapVec3(unsafe.Pointer(&arg4))
	perspective = WrapVec4(unsafe.Pointer(&arg5))
	if cret {
		ok = true
	}

	return translate, scale, rotate, shear, perspective, ok
}

// Determinant computes the determinant of the given matrix.
func (m *Matrix) Determinant(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_determinant(arg0)
}

// Equal checks whether the two given #graphene_matrix_t matrices are equal.
func (a *Matrix) Equal(a *Matrix, b *Matrix) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_equal(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// EqualFast checks whether the two given #graphene_matrix_t matrices are
// byte-by-byte equal.
//
// While this function is faster than graphene_matrix_equal(), it can also
// return false negatives, so it should be used in conjuction with either
// graphene_matrix_equal() or graphene_matrix_near(). For instance:
//
//    if (graphene_matrix_equal_fast (a, b))
//      {
//        // matrices are definitely the same
//      }
//    else
//      {
//        if (graphene_matrix_equal (a, b))
//          // matrices contain the same values within an epsilon of FLT_EPSILON
//        else if (graphene_matrix_near (a, b, 0.0001))
//          // matrices contain the same values within an epsilon of 0.0001
//        else
//          // matrices are not equal
//      }
func (a *Matrix) EqualFast(a *Matrix, b *Matrix) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_equal_fast(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// Free frees the resources allocated by graphene_matrix_alloc().
func (m *Matrix) Free(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_free(arg0)
}

// Row retrieves the given row vector at @index_ inside a matrix.
func (m *Matrix) Row(m *Matrix, index_ uint) *Vec4 {
	var arg0 *C.graphene_matrix_t
	var arg1 C.uint

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.uint(index_)

	var arg2 C.graphene_vec4_t
	var res *Vec4

	C.graphene_matrix_get_row(arg0, arg1, &arg2)

	res = WrapVec4(unsafe.Pointer(&arg2))

	return res
}

// Value retrieves the value at the given @row and @col index.
func (m *Matrix) Value(m *Matrix, row uint, col uint) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.uint
	var arg2 C.uint

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.uint(row)
	arg2 = C.uint(col)

	C.graphene_matrix_get_value(arg0, arg1, arg2)
}

// XScale retrieves the scaling factor on the X axis in @m.
func (m *Matrix) XScale(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_x_scale(arg0)
}

// XTranslation retrieves the translation component on the X axis from @m.
func (m *Matrix) XTranslation(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_x_translation(arg0)
}

// YScale retrieves the scaling factor on the Y axis in @m.
func (m *Matrix) YScale(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_y_scale(arg0)
}

// YTranslation retrieves the translation component on the Y axis from @m.
func (m *Matrix) YTranslation(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_y_translation(arg0)
}

// ZScale retrieves the scaling factor on the Z axis in @m.
func (m *Matrix) ZScale(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_z_scale(arg0)
}

// ZTranslation retrieves the translation component on the Z axis from @m.
func (m *Matrix) ZTranslation(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_get_z_translation(arg0)
}

// InitFrom2D initializes a #graphene_matrix_t from the values of an affine
// transformation matrix.
//
// The arguments map to the following matrix layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between an affine matrix type from other
// libraries and a #graphene_matrix_t.
func (m *Matrix) InitFrom2D(m *Matrix, xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.double(xx)
	arg2 = C.double(yx)
	arg3 = C.double(xy)
	arg4 = C.double(yy)
	arg5 = C.double(x0)
	arg6 = C.double(y0)

	C.graphene_matrix_init_from_2d(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// InitFromFloat initializes a #graphene_matrix_t with the given array of
// floating point values.
func (m *Matrix) InitFromFloat(m *Matrix, v [16]float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.float)(&v)
	defer runtime.KeepAlive(&arg1)

	C.graphene_matrix_init_from_float(arg0, arg1)
}

// InitFromMatrix initializes a #graphene_matrix_t using the values of the given
// matrix.
func (m *Matrix) InitFromMatrix(m *Matrix, src *Matrix) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(src.Native()))

	C.graphene_matrix_init_from_matrix(arg0, arg1)
}

// InitFromVec4 initializes a #graphene_matrix_t with the given four row
// vectors.
func (m *Matrix) InitFromVec4(m *Matrix, v0 *Vec4, v1 *Vec4, v2 *Vec4, v3 *Vec4) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec4_t
	var arg2 *C.graphene_vec4_t
	var arg3 *C.graphene_vec4_t
	var arg4 *C.graphene_vec4_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v0.Native()))
	arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(v1.Native()))
	arg3 = (*C.graphene_vec4_t)(unsafe.Pointer(v2.Native()))
	arg4 = (*C.graphene_vec4_t)(unsafe.Pointer(v3.Native()))

	C.graphene_matrix_init_from_vec4(arg0, arg1, arg2, arg3, arg4)
}

// InitFrustum initializes a #graphene_matrix_t compatible with
// #graphene_frustum_t.
//
// See also: graphene_frustum_init_from_matrix()
func (m *Matrix) InitFrustum(m *Matrix, left float32, right float32, bottom float32, top float32, zNear float32, zFar float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(left)
	arg2 = C.float(right)
	arg3 = C.float(bottom)
	arg4 = C.float(top)
	arg5 = C.float(zNear)
	arg6 = C.float(zFar)

	C.graphene_matrix_init_frustum(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// InitIdentity initializes a #graphene_matrix_t with the identity matrix.
func (m *Matrix) InitIdentity(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_init_identity(arg0)
}

// InitLookAt initializes a #graphene_matrix_t so that it positions the "camera"
// at the given @eye coordinates towards an object at the @center coordinates.
// The top of the camera is aligned to the direction of the @up vector.
//
// Before the transform, the camera is assumed to be placed at the origin,
// looking towards the negative Z axis, with the top side of the camera facing
// in the direction of the Y axis and the right side in the direction of the X
// axis.
//
// In theory, one could use @m to transform a model of such a camera into
// world-space. However, it is more common to use the inverse of @m to transform
// another object from world coordinates to the view coordinates of the camera.
// Typically you would then apply the camera projection transform to get from
// view to screen coordinates.
func (m *Matrix) InitLookAt(m *Matrix, eye *Vec3, center *Vec3, up *Vec3) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec3_t
	var arg2 *C.graphene_vec3_t
	var arg3 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(eye.Native()))
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(center.Native()))
	arg3 = (*C.graphene_vec3_t)(unsafe.Pointer(up.Native()))

	C.graphene_matrix_init_look_at(arg0, arg1, arg2, arg3)
}

// InitOrtho initializes a #graphene_matrix_t with an orthographic projection.
func (m *Matrix) InitOrtho(m *Matrix, left float32, right float32, top float32, bottom float32, zNear float32, zFar float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(left)
	arg2 = C.float(right)
	arg3 = C.float(top)
	arg4 = C.float(bottom)
	arg5 = C.float(zNear)
	arg6 = C.float(zFar)

	C.graphene_matrix_init_ortho(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// InitPerspective initializes a #graphene_matrix_t with a perspective
// projection.
func (m *Matrix) InitPerspective(m *Matrix, fovy float32, aspect float32, zNear float32, zFar float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(fovy)
	arg2 = C.float(aspect)
	arg3 = C.float(zNear)
	arg4 = C.float(zFar)

	C.graphene_matrix_init_perspective(arg0, arg1, arg2, arg3, arg4)
}

// InitRotate initializes @m to represent a rotation of @angle degrees on the
// axis represented by the @axis vector.
func (m *Matrix) InitRotate(m *Matrix, angle float32, axis *Vec3) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.graphene_matrix_init_rotate(arg0, arg1, arg2)
}

// InitScale initializes a #graphene_matrix_t with the given scaling factors.
func (m *Matrix) InitScale(m *Matrix, x float32, y float32, z float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(x)
	arg2 = C.float(y)
	arg3 = C.float(z)

	C.graphene_matrix_init_scale(arg0, arg1, arg2, arg3)
}

// InitSkew initializes a #graphene_matrix_t with a skew transformation with the
// given factors.
func (m *Matrix) InitSkew(m *Matrix, xSkew float32, ySkew float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(xSkew)
	arg2 = C.float(ySkew)

	C.graphene_matrix_init_skew(arg0, arg1, arg2)
}

// InitTranslate initializes a #graphene_matrix_t with a translation to the
// given coordinates.
func (m *Matrix) InitTranslate(m *Matrix, p *Point3D) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	C.graphene_matrix_init_translate(arg0, arg1)
}

// Interpolate: linearly interpolates the two given #graphene_matrix_t by
// interpolating the decomposed transformations separately.
//
// If either matrix cannot be reduced to their transformations then the
// interpolation cannot be performed, and this function will return an identity
// matrix.
func (a *Matrix) Interpolate(a *Matrix, b *Matrix, factor float64) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 C.double

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	arg2 = C.double(factor)

	var arg3 C.graphene_matrix_t
	var res *Matrix

	C.graphene_matrix_interpolate(arg0, arg1, arg2, &arg3)

	res = WrapMatrix(unsafe.Pointer(&arg3))

	return res
}

// Inverse inverts the given matrix.
func (m *Matrix) Inverse(m *Matrix) (res *Matrix, ok bool) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 C.graphene_matrix_t
	var res *Matrix
	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_inverse(arg0, &arg1)

	res = WrapMatrix(unsafe.Pointer(&arg1))
	if cret {
		ok = true
	}

	return res, ok
}

// Is2D checks whether the given #graphene_matrix_t is compatible with an a 2D
// affine transformation matrix.
func (m *Matrix) Is2D(m *Matrix) bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_is_2d(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsBackfaceVisible checks whether a #graphene_matrix_t has a visible back
// face.
func (m *Matrix) IsBackfaceVisible(m *Matrix) bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_is_backface_visible(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsIdentity checks whether the given #graphene_matrix_t is the identity
// matrix.
func (m *Matrix) IsIdentity(m *Matrix) bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_is_identity(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsSingular checks whether a matrix is singular.
func (m *Matrix) IsSingular(m *Matrix) bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_is_singular(arg0)

	if cret {
		ok = true
	}

	return ok
}

// Multiply multiplies two #graphene_matrix_t.
//
// Matrix multiplication is not commutative in general; the order of the factors
// matters. The product of this multiplication is (@a × @b)
func (a *Matrix) Multiply(a *Matrix, b *Matrix) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))

	var arg2 C.graphene_matrix_t
	var res *Matrix

	C.graphene_matrix_multiply(arg0, arg1, &arg2)

	res = WrapMatrix(unsafe.Pointer(&arg2))

	return res
}

// Near compares the two given #graphene_matrix_t matrices and checks whether
// their values are within the given @epsilon of each other.
func (a *Matrix) Near(a *Matrix, b *Matrix, epsilon float32) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(a.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(b.Native()))
	arg2 = C.float(epsilon)

	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_near(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// Normalize normalizes the given #graphene_matrix_t.
func (m *Matrix) Normalize(m *Matrix) *Matrix {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 C.graphene_matrix_t
	var res *Matrix

	C.graphene_matrix_normalize(arg0, &arg1)

	res = WrapMatrix(unsafe.Pointer(&arg1))

	return res
}

// Perspective applies a perspective of @depth to the matrix.
func (m *Matrix) Perspective(m *Matrix, depth float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(depth)

	var arg2 C.graphene_matrix_t
	var res *Matrix

	C.graphene_matrix_perspective(arg0, arg1, &arg2)

	res = WrapMatrix(unsafe.Pointer(&arg2))

	return res
}

// Print prints the contents of a matrix to the standard error stream.
//
// This function is only useful for debugging; there are no guarantees made on
// the format of the output.
func (m *Matrix) Print(m *Matrix) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	C.graphene_matrix_print(arg0)
}

// ProjectPoint projects a #graphene_point_t using the matrix @m.
func (m *Matrix) ProjectPoint(m *Matrix, p *Point) *Point {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	var arg2 C.graphene_point_t
	var res *Point

	C.graphene_matrix_project_point(arg0, arg1, &arg2)

	res = WrapPoint(unsafe.Pointer(&arg2))

	return res
}

// ProjectRect projects all corners of a #graphene_rect_t using the given
// matrix.
//
// See also: graphene_matrix_project_point()
func (m *Matrix) ProjectRect(m *Matrix, r *Rect) *Quad {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	var arg2 C.graphene_quad_t
	var res *Quad

	C.graphene_matrix_project_rect(arg0, arg1, &arg2)

	res = WrapQuad(unsafe.Pointer(&arg2))

	return res
}

// ProjectRectBounds projects a #graphene_rect_t using the given matrix.
//
// The resulting rectangle is the axis aligned bounding rectangle capable of
// fully containing the projected rectangle.
func (m *Matrix) ProjectRectBounds(m *Matrix, r *Rect) *Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	var arg2 C.graphene_rect_t
	var res *Rect

	C.graphene_matrix_project_rect_bounds(arg0, arg1, &arg2)

	res = WrapRect(unsafe.Pointer(&arg2))

	return res
}

// Rotate adds a rotation transformation to @m, using the given @angle and @axis
// vector.
//
// This is the equivalent of calling graphene_matrix_init_rotate() and then
// multiplying the matrix @m with the rotation matrix.
func (m *Matrix) Rotate(m *Matrix, angle float32, axis *Vec3) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

	C.graphene_matrix_rotate(arg0, arg1, arg2)
}

// RotateEuler adds a rotation transformation to @m, using the given
// #graphene_euler_t.
func (m *Matrix) RotateEuler(m *Matrix, e *Euler) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_euler_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_euler_t)(unsafe.Pointer(e.Native()))

	C.graphene_matrix_rotate_euler(arg0, arg1)
}

// RotateQuaternion adds a rotation transformation to @m, using the given
// #graphene_quaternion_t.
//
// This is the equivalent of calling graphene_quaternion_to_matrix() and then
// multiplying @m with the rotation matrix.
func (m *Matrix) RotateQuaternion(m *Matrix, q *Quaternion) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_quaternion_t)(unsafe.Pointer(q.Native()))

	C.graphene_matrix_rotate_quaternion(arg0, arg1)
}

// RotateX adds a rotation transformation around the X axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateX(m *Matrix, angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_x(arg0, arg1)
}

// RotateY adds a rotation transformation around the Y axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateY(m *Matrix, angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_y(arg0, arg1)
}

// RotateZ adds a rotation transformation around the Z axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateZ(m *Matrix, angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_z(arg0, arg1)
}

// Scale adds a scaling transformation to @m, using the three given factors.
//
// This is the equivalent of calling graphene_matrix_init_scale() and then
// multiplying the matrix @m with the scale matrix.
func (m *Matrix) Scale(m *Matrix, factorX float32, factorY float32, factorZ float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	C.graphene_matrix_scale(arg0, arg1, arg2, arg3)
}

// SkewXY adds a skew of @factor on the X and Y axis to the given matrix.
func (m *Matrix) SkewXY(m *Matrix, factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(factor)

	C.graphene_matrix_skew_xy(arg0, arg1)
}

// SkewXZ adds a skew of @factor on the X and Z axis to the given matrix.
func (m *Matrix) SkewXZ(m *Matrix, factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(factor)

	C.graphene_matrix_skew_xz(arg0, arg1)
}

// SkewYZ adds a skew of @factor on the Y and Z axis to the given matrix.
func (m *Matrix) SkewYZ(m *Matrix, factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = C.float(factor)

	C.graphene_matrix_skew_yz(arg0, arg1)
}

// To2D converts a #graphene_matrix_t to an affine transformation matrix, if the
// given matrix is compatible.
//
// The returned values have the following layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between a #graphene_matrix_t and an
// affine matrix type from other libraries.
func (m *Matrix) To2D(m *Matrix) (xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64, ok bool) {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 C.double
	var xx float64
	var arg2 C.double
	var yx float64
	var arg3 C.double
	var xy float64
	var arg4 C.double
	var yy float64
	var arg5 C.double
	var x0 float64
	var arg6 C.double
	var y0 float64
	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_to_2d(arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)

	xx = float64(&arg1)
	yx = float64(&arg2)
	xy = float64(&arg3)
	yy = float64(&arg4)
	x0 = float64(&arg5)
	y0 = float64(&arg6)
	if cret {
		ok = true
	}

	return xx, yx, xy, yy, x0, y0, ok
}

// ToFloat converts a #graphene_matrix_t to an array of floating point values.
func (m *Matrix) ToFloat(m *Matrix) [16]float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 [16]C.float
	var v [16]float32

	C.graphene_matrix_to_float(arg0, &arg1)

	v = ([16]float32)(arg1)

	return v
}

// TransformBounds transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is the axis aligned bounding rectangle containing the coplanar
// quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformBounds(m *Matrix, r *Rect) *Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	var arg2 C.graphene_rect_t
	var res *Rect

	C.graphene_matrix_transform_bounds(arg0, arg1, &arg2)

	res = WrapRect(unsafe.Pointer(&arg2))

	return res
}

// TransformBox transforms the vertices of a #graphene_box_t using the given
// matrix @m.
//
// The result is the axis aligned bounding box containing the transformed
// vertices.
func (m *Matrix) TransformBox(m *Matrix, b *Box) *Box {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_box_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_box_t)(unsafe.Pointer(b.Native()))

	var arg2 C.graphene_box_t
	var res *Box

	C.graphene_matrix_transform_box(arg0, arg1, &arg2)

	res = WrapBox(unsafe.Pointer(&arg2))

	return res
}

// TransformPoint transforms the given #graphene_point_t using the matrix @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint(m *Matrix, p *Point) *Point {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))

	var arg2 C.graphene_point_t
	var res *Point

	C.graphene_matrix_transform_point(arg0, arg1, &arg2)

	res = WrapPoint(unsafe.Pointer(&arg2))

	return res
}

// TransformPoint3D transforms the given #graphene_point3d_t using the matrix
// @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint3D(m *Matrix, p *Point3D) *Point3D {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(p.Native()))

	var arg2 C.graphene_point3d_t
	var res *Point3D

	C.graphene_matrix_transform_point3d(arg0, arg1, &arg2)

	res = WrapPoint3D(unsafe.Pointer(&arg2))

	return res
}

// TransformRay: transform a #graphene_ray_t using the given matrix @m.
func (m *Matrix) TransformRay(m *Matrix, r *Ray) *Ray {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_ray_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_ray_t)(unsafe.Pointer(r.Native()))

	var arg2 C.graphene_ray_t
	var res *Ray

	C.graphene_matrix_transform_ray(arg0, arg1, &arg2)

	res = WrapRay(unsafe.Pointer(&arg2))

	return res
}

// TransformRect transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is a coplanar quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformRect(m *Matrix, r *Rect) *Quad {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))

	var arg2 C.graphene_quad_t
	var res *Quad

	C.graphene_matrix_transform_rect(arg0, arg1, &arg2)

	res = WrapQuad(unsafe.Pointer(&arg2))

	return res
}

// TransformSphere transforms a #graphene_sphere_t using the given matrix @m.
// The result is the bounding sphere containing the transformed sphere.
func (m *Matrix) TransformSphere(m *Matrix, s *Sphere) *Sphere {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_sphere_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(s.Native()))

	var arg2 C.graphene_sphere_t
	var res *Sphere

	C.graphene_matrix_transform_sphere(arg0, arg1, &arg2)

	res = WrapSphere(unsafe.Pointer(&arg2))

	return res
}

// TransformVec3 transforms the given #graphene_vec3_t using the matrix @m.
//
// This function will multiply the X, Y, and Z row vectors of the matrix @m with
// the corresponding components of the vector @v. The W row vector will be
// ignored.
//
// See also: graphene_simd4x4f_vec3_mul()
func (m *Matrix) TransformVec3(m *Matrix, v *Vec3) *Vec3 {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_vec3_t)(unsafe.Pointer(v.Native()))

	var arg2 C.graphene_vec3_t
	var res *Vec3

	C.graphene_matrix_transform_vec3(arg0, arg1, &arg2)

	res = WrapVec3(unsafe.Pointer(&arg2))

	return res
}

// TransformVec4 transforms the given #graphene_vec4_t using the matrix @m.
//
// See also: graphene_simd4x4f_vec4_mul()
func (m *Matrix) TransformVec4(m *Matrix, v *Vec4) *Vec4 {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec4_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_vec4_t)(unsafe.Pointer(v.Native()))

	var arg2 C.graphene_vec4_t
	var res *Vec4

	C.graphene_matrix_transform_vec4(arg0, arg1, &arg2)

	res = WrapVec4(unsafe.Pointer(&arg2))

	return res
}

// Translate adds a translation transformation to @m using the coordinates of
// the given #graphene_point3d_t.
//
// This is the equivalent of calling graphene_matrix_init_translate() and then
// multiplying @m with the translation matrix.
func (m *Matrix) Translate(m *Matrix, pos *Point3D) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(pos.Native()))

	C.graphene_matrix_translate(arg0, arg1)
}

// Transpose transposes the given matrix.
func (m *Matrix) Transpose(m *Matrix) *Matrix {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))

	var arg1 C.graphene_matrix_t
	var res *Matrix

	C.graphene_matrix_transpose(arg0, &arg1)

	res = WrapMatrix(unsafe.Pointer(&arg1))

	return res
}

// UnprojectPoint3D unprojects the given @point using the @projection matrix and
// a @modelview matrix.
func (p *Matrix) UnprojectPoint3D(p *Matrix, modelview *Matrix, point *Point3D) *Point3D {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(p.Native()))
	arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(modelview.Native()))
	arg2 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	var arg3 C.graphene_point3d_t
	var res *Point3D

	C.graphene_matrix_unproject_point3d(arg0, arg1, arg2, &arg3)

	res = WrapPoint3D(unsafe.Pointer(&arg3))

	return res
}

// UntransformBounds undoes the transformation on the corners of a
// #graphene_rect_t using the given matrix, within the given axis aligned
// rectangular @bounds.
func (m *Matrix) UntransformBounds(m *Matrix, r *Rect, bounds *Rect) *Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_rect_t)(unsafe.Pointer(r.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	var arg3 C.graphene_rect_t
	var res *Rect

	C.graphene_matrix_untransform_bounds(arg0, arg1, arg2, &arg3)

	res = WrapRect(unsafe.Pointer(&arg3))

	return res
}

// UntransformPoint undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UntransformPoint(m *Matrix, p *Point, bounds *Rect) (res *Point, ok bool) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_rect_t

	arg0 = (*C.graphene_matrix_t)(unsafe.Pointer(m.Native()))
	arg1 = (*C.graphene_point_t)(unsafe.Pointer(p.Native()))
	arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

	var arg3 C.graphene_point_t
	var res *Point
	var cret C._Bool
	var ok bool

	cret = C.graphene_matrix_untransform_point(arg0, arg1, arg2, &arg3)

	res = WrapPoint(unsafe.Pointer(&arg3))
	if cret {
		ok = true
	}

	return res, ok
}
