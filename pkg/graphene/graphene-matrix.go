// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_matrix_get_type()), F: marshalMatrix},
	})
}

// Matrix: a structure capable of holding a 4x4 matrix.
//
// The contents of the #graphene_matrix_t structure are private and should never
// be accessed directly.
type Matrix struct {
	native C.graphene_matrix_t
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// NewMatrixAlloc constructs a struct Matrix.
func NewMatrixAlloc() *Matrix {
	ret := C.graphene_matrix_alloc()

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Matrix) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Decompose decomposes a transformation matrix into its component
// transformations.
//
// The algorithm for decomposing a matrix is taken from the CSS3 Transforms
// specification (http://dev.w3.org/csswg/css-transforms/); specifically, the
// decomposition code is based on the equivalent code published in "Graphics
// Gems II", edited by Jim Arvo, and available online
// (http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c).
func (m *Matrix) Decompose() (translate Vec3, scale Vec3, rotate Quaternion, shear Vec3, perspective Vec4, ok bool) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec3_t       // out
	var arg2 *C.graphene_vec3_t       // out
	var arg3 *C.graphene_quaternion_t // out
	var arg4 *C.graphene_vec3_t       // out
	var arg5 *C.graphene_vec4_t       // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_decompose(arg0, &arg1, &arg2, &arg3, &arg4, &arg5)

	var ret0 *Vec3
	var ret1 *Vec3
	var ret2 *Quaternion
	var ret3 *Vec3
	var ret4 *Vec4
	var ret5 bool

	{
		ret0 = WrapVec3(unsafe.Pointer(arg1))
	}

	{
		ret1 = WrapVec3(unsafe.Pointer(arg2))
	}

	{
		ret2 = WrapQuaternion(unsafe.Pointer(arg3))
	}

	{
		ret3 = WrapVec3(unsafe.Pointer(arg4))
	}

	{
		ret4 = WrapVec4(unsafe.Pointer(arg5))
	}

	ret5 = C.bool(ret) != 0

	return ret0, ret1, ret2, ret3, ret4, ret5
}

// Determinant computes the determinant of the given matrix.
func (m *Matrix) Determinant() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_determinant(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// Equal checks whether the two given #graphene_matrix_t matrices are equal.
func (a *Matrix) Equal(b *Matrix) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(a.Native())
	arg1 = (*C.graphene_matrix_t)(b.Native())

	ret := C.graphene_matrix_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// EqualFast checks whether the two given #graphene_matrix_t matrices are
// byte-by-byte equal.
//
// While this function is faster than graphene_matrix_equal(), it can also
// return false negatives, so it should be used in conjuction with either
// graphene_matrix_equal() or graphene_matrix_near(). For instance:
//
//    if (graphene_matrix_equal_fast (a, b))
//      {
//        // matrices are definitely the same
//      }
//    else
//      {
//        if (graphene_matrix_equal (a, b))
//          // matrices contain the same values within an epsilon of FLT_EPSILON
//        else if (graphene_matrix_near (a, b, 0.0001))
//          // matrices contain the same values within an epsilon of 0.0001
//        else
//          // matrices are not equal
//      }
func (a *Matrix) EqualFast(b *Matrix) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(a.Native())
	arg1 = (*C.graphene_matrix_t)(b.Native())

	ret := C.graphene_matrix_equal_fast(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Free frees the resources allocated by graphene_matrix_alloc().
func (m *Matrix) Free() {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	C.graphene_matrix_free(arg0)
}

// Row retrieves the given row vector at @index_ inside a matrix.
func (m *Matrix) Row(index_ uint) Vec4 {
	var arg0 *C.graphene_matrix_t
	var arg1 C.uint
	var arg2 *C.graphene_vec4_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.uint(index_)

	C.graphene_matrix_get_row(arg0, arg1, &arg2)

	var ret0 *Vec4

	{
		ret0 = WrapVec4(unsafe.Pointer(arg2))
	}

	return ret0
}

// Value retrieves the value at the given @row and @col index.
func (m *Matrix) Value(row uint, col uint) float32 {
	var arg0 *C.graphene_matrix_t
	var arg1 C.uint
	var arg2 C.uint

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.uint(row)
	arg2 = C.uint(col)

	ret := C.graphene_matrix_get_value(arg0, arg1, arg2)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// XScale retrieves the scaling factor on the X axis in @m.
func (m *Matrix) XScale() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_x_scale(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// XTranslation retrieves the translation component on the X axis from @m.
func (m *Matrix) XTranslation() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_x_translation(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// YScale retrieves the scaling factor on the Y axis in @m.
func (m *Matrix) YScale() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_y_scale(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// YTranslation retrieves the translation component on the Y axis from @m.
func (m *Matrix) YTranslation() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_y_translation(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ZScale retrieves the scaling factor on the Z axis in @m.
func (m *Matrix) ZScale() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_z_scale(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// ZTranslation retrieves the translation component on the Z axis from @m.
func (m *Matrix) ZTranslation() float32 {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_get_z_translation(arg0)

	var ret0 float32

	ret0 = float32(ret)

	return ret0
}

// InitFrom2D initializes a #graphene_matrix_t from the values of an affine
// transformation matrix.
//
// The arguments map to the following matrix layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between an affine matrix type from other
// libraries and a #graphene_matrix_t.
func (m *Matrix) InitFrom2D(xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.double
	var arg2 C.double
	var arg3 C.double
	var arg4 C.double
	var arg5 C.double
	var arg6 C.double

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.double(xx)
	arg2 = C.double(yx)
	arg3 = C.double(xy)
	arg4 = C.double(yy)
	arg5 = C.double(x0)
	arg6 = C.double(y0)

	ret := C.graphene_matrix_init_from_2d(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromFloat initializes a #graphene_matrix_t with the given array of
// floating point values.
func (m *Matrix) InitFromFloat(v [16]float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.float)(&v)
	defer runtime.KeepAlive(&v)

	ret := C.graphene_matrix_init_from_float(arg0, arg1)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromMatrix initializes a #graphene_matrix_t using the values of the given
// matrix.
func (m *Matrix) InitFromMatrix(src *Matrix) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_matrix_t)(src.Native())

	ret := C.graphene_matrix_init_from_matrix(arg0, arg1)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromVec4 initializes a #graphene_matrix_t with the given four row
// vectors.
func (m *Matrix) InitFromVec4(v0 *Vec4, v1 *Vec4, v2 *Vec4, v3 *Vec4) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec4_t
	var arg2 *C.graphene_vec4_t
	var arg3 *C.graphene_vec4_t
	var arg4 *C.graphene_vec4_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_vec4_t)(v0.Native())
	arg2 = (*C.graphene_vec4_t)(v1.Native())
	arg3 = (*C.graphene_vec4_t)(v2.Native())
	arg4 = (*C.graphene_vec4_t)(v3.Native())

	ret := C.graphene_matrix_init_from_vec4(arg0, arg1, arg2, arg3, arg4)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFrustum initializes a #graphene_matrix_t compatible with
// #graphene_frustum_t.
//
// See also: graphene_frustum_init_from_matrix()
func (m *Matrix) InitFrustum(left float32, right float32, bottom float32, top float32, zNear float32, zFar float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(left)
	arg2 = C.float(right)
	arg3 = C.float(bottom)
	arg4 = C.float(top)
	arg5 = C.float(zNear)
	arg6 = C.float(zFar)

	ret := C.graphene_matrix_init_frustum(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitIdentity initializes a #graphene_matrix_t with the identity matrix.
func (m *Matrix) InitIdentity() *Matrix {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_init_identity(arg0)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitLookAt initializes a #graphene_matrix_t so that it positions the "camera"
// at the given @eye coordinates towards an object at the @center coordinates.
// The top of the camera is aligned to the direction of the @up vector.
//
// Before the transform, the camera is assumed to be placed at the origin,
// looking towards the negative Z axis, with the top side of the camera facing
// in the direction of the Y axis and the right side in the direction of the X
// axis.
//
// In theory, one could use @m to transform a model of such a camera into
// world-space. However, it is more common to use the inverse of @m to transform
// another object from world coordinates to the view coordinates of the camera.
// Typically you would then apply the camera projection transform to get from
// view to screen coordinates.
func (m *Matrix) InitLookAt(eye *Vec3, center *Vec3, up *Vec3) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec3_t
	var arg2 *C.graphene_vec3_t
	var arg3 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_vec3_t)(eye.Native())
	arg2 = (*C.graphene_vec3_t)(center.Native())
	arg3 = (*C.graphene_vec3_t)(up.Native())

	ret := C.graphene_matrix_init_look_at(arg0, arg1, arg2, arg3)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitOrtho initializes a #graphene_matrix_t with an orthographic projection.
func (m *Matrix) InitOrtho(left float32, right float32, top float32, bottom float32, zNear float32, zFar float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float
	var arg5 C.float
	var arg6 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(left)
	arg2 = C.float(right)
	arg3 = C.float(top)
	arg4 = C.float(bottom)
	arg5 = C.float(zNear)
	arg6 = C.float(zFar)

	ret := C.graphene_matrix_init_ortho(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitPerspective initializes a #graphene_matrix_t with a perspective
// projection.
func (m *Matrix) InitPerspective(fovy float32, aspect float32, zNear float32, zFar float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float
	var arg4 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(fovy)
	arg2 = C.float(aspect)
	arg3 = C.float(zNear)
	arg4 = C.float(zFar)

	ret := C.graphene_matrix_init_perspective(arg0, arg1, arg2, arg3, arg4)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitRotate initializes @m to represent a rotation of @angle degrees on the
// axis represented by the @axis vector.
func (m *Matrix) InitRotate(angle float32, axis *Vec3) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(axis.Native())

	ret := C.graphene_matrix_init_rotate(arg0, arg1, arg2)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitScale initializes a #graphene_matrix_t with the given scaling factors.
func (m *Matrix) InitScale(x float32, y float32, z float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(x)
	arg2 = C.float(y)
	arg3 = C.float(z)

	ret := C.graphene_matrix_init_scale(arg0, arg1, arg2, arg3)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitSkew initializes a #graphene_matrix_t with a skew transformation with the
// given factors.
func (m *Matrix) InitSkew(xSkew float32, ySkew float32) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(xSkew)
	arg2 = C.float(ySkew)

	ret := C.graphene_matrix_init_skew(arg0, arg1, arg2)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// InitTranslate initializes a #graphene_matrix_t with a translation to the
// given coordinates.
func (m *Matrix) InitTranslate(p *Point3D) *Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point3d_t)(p.Native())

	ret := C.graphene_matrix_init_translate(arg0, arg1)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(ret))
	}

	return ret0
}

// Interpolate: linearly interpolates the two given #graphene_matrix_t by
// interpolating the decomposed transformations separately.
//
// If either matrix cannot be reduced to their transformations then the
// interpolation cannot be performed, and this function will return an identity
// matrix.
func (a *Matrix) Interpolate(b *Matrix, factor float64) Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 C.double
	var arg3 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(a.Native())
	arg1 = (*C.graphene_matrix_t)(b.Native())
	arg2 = C.double(factor)

	C.graphene_matrix_interpolate(arg0, arg1, arg2, &arg3)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg3))
	}

	return ret0
}

// Inverse inverts the given matrix.
func (m *Matrix) Inverse() (res Matrix, ok bool) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_inverse(arg0, &arg1)

	var ret0 *Matrix
	var ret1 bool

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg1))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}

// Is2D checks whether the given #graphene_matrix_t is compatible with an a 2D
// affine transformation matrix.
func (m *Matrix) Is2D() bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_is_2d(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsBackfaceVisible checks whether a #graphene_matrix_t has a visible back
// face.
func (m *Matrix) IsBackfaceVisible() bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_is_backface_visible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsIdentity checks whether the given #graphene_matrix_t is the identity
// matrix.
func (m *Matrix) IsIdentity() bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_is_identity(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IsSingular checks whether a matrix is singular.
func (m *Matrix) IsSingular() bool {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_is_singular(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Multiply multiplies two #graphene_matrix_t.
//
// Matrix multiplication is not commutative in general; the order of the factors
// matters. The product of this multiplication is (@a × @b)
func (a *Matrix) Multiply(b *Matrix) Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(a.Native())
	arg1 = (*C.graphene_matrix_t)(b.Native())

	C.graphene_matrix_multiply(arg0, arg1, &arg2)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg2))
	}

	return ret0
}

// Near compares the two given #graphene_matrix_t matrices and checks whether
// their values are within the given @epsilon of each other.
func (a *Matrix) Near(b *Matrix, epsilon float32) bool {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 C.float

	arg0 = (*C.graphene_matrix_t)(a.Native())
	arg1 = (*C.graphene_matrix_t)(b.Native())
	arg2 = C.float(epsilon)

	ret := C.graphene_matrix_near(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Normalize normalizes the given #graphene_matrix_t.
func (m *Matrix) Normalize() Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	C.graphene_matrix_normalize(arg0, &arg1)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg1))
	}

	return ret0
}

// Perspective applies a perspective of @depth to the matrix.
func (m *Matrix) Perspective(depth float32) Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(depth)

	C.graphene_matrix_perspective(arg0, arg1, &arg2)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg2))
	}

	return ret0
}

// Print prints the contents of a matrix to the standard error stream.
//
// This function is only useful for debugging; there are no guarantees made on
// the format of the output.
func (m *Matrix) Print() {
	var arg0 *C.graphene_matrix_t

	arg0 = (*C.graphene_matrix_t)(m.Native())

	C.graphene_matrix_print(arg0)
}

// ProjectPoint projects a #graphene_point_t using the matrix @m.
func (m *Matrix) ProjectPoint(p *Point) Point {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_point_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point_t)(p.Native())

	C.graphene_matrix_project_point(arg0, arg1, &arg2)

	var ret0 *Point

	{
		ret0 = WrapPoint(unsafe.Pointer(arg2))
	}

	return ret0
}

// ProjectRect projects all corners of a #graphene_rect_t using the given
// matrix.
//
// See also: graphene_matrix_project_point()
func (m *Matrix) ProjectRect(r *Rect) Quad {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_quad_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_rect_t)(r.Native())

	C.graphene_matrix_project_rect(arg0, arg1, &arg2)

	var ret0 *Quad

	{
		ret0 = WrapQuad(unsafe.Pointer(arg2))
	}

	return ret0
}

// ProjectRectBounds projects a #graphene_rect_t using the given matrix.
//
// The resulting rectangle is the axis aligned bounding rectangle capable of
// fully containing the projected rectangle.
func (m *Matrix) ProjectRectBounds(r *Rect) Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_rect_t)(r.Native())

	C.graphene_matrix_project_rect_bounds(arg0, arg1, &arg2)

	var ret0 *Rect

	{
		ret0 = WrapRect(unsafe.Pointer(arg2))
	}

	return ret0
}

// Rotate adds a rotation transformation to @m, using the given @angle and @axis
// vector.
//
// This is the equivalent of calling graphene_matrix_init_rotate() and then
// multiplying the matrix @m with the rotation matrix.
func (m *Matrix) Rotate(angle float32, axis *Vec3) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 *C.graphene_vec3_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(angle)
	arg2 = (*C.graphene_vec3_t)(axis.Native())

	C.graphene_matrix_rotate(arg0, arg1, arg2)
}

// RotateEuler adds a rotation transformation to @m, using the given
// #graphene_euler_t.
func (m *Matrix) RotateEuler(e *Euler) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_euler_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_euler_t)(e.Native())

	C.graphene_matrix_rotate_euler(arg0, arg1)
}

// RotateQuaternion adds a rotation transformation to @m, using the given
// #graphene_quaternion_t.
//
// This is the equivalent of calling graphene_quaternion_to_matrix() and then
// multiplying @m with the rotation matrix.
func (m *Matrix) RotateQuaternion(q *Quaternion) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_quaternion_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_quaternion_t)(q.Native())

	C.graphene_matrix_rotate_quaternion(arg0, arg1)
}

// RotateX adds a rotation transformation around the X axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateX(angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_x(arg0, arg1)
}

// RotateY adds a rotation transformation around the Y axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateY(angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_y(arg0, arg1)
}

// RotateZ adds a rotation transformation around the Z axis to @m, using the
// given @angle.
//
// See also: graphene_matrix_rotate()
func (m *Matrix) RotateZ(angle float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(angle)

	C.graphene_matrix_rotate_z(arg0, arg1)
}

// Scale adds a scaling transformation to @m, using the three given factors.
//
// This is the equivalent of calling graphene_matrix_init_scale() and then
// multiplying the matrix @m with the scale matrix.
func (m *Matrix) Scale(factorX float32, factorY float32, factorZ float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float
	var arg2 C.float
	var arg3 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(factorX)
	arg2 = C.float(factorY)
	arg3 = C.float(factorZ)

	C.graphene_matrix_scale(arg0, arg1, arg2, arg3)
}

// SkewXY adds a skew of @factor on the X and Y axis to the given matrix.
func (m *Matrix) SkewXY(factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(factor)

	C.graphene_matrix_skew_xy(arg0, arg1)
}

// SkewXZ adds a skew of @factor on the X and Z axis to the given matrix.
func (m *Matrix) SkewXZ(factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(factor)

	C.graphene_matrix_skew_xz(arg0, arg1)
}

// SkewYZ adds a skew of @factor on the Y and Z axis to the given matrix.
func (m *Matrix) SkewYZ(factor float32) {
	var arg0 *C.graphene_matrix_t
	var arg1 C.float

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = C.float(factor)

	C.graphene_matrix_skew_yz(arg0, arg1)
}

// To2D converts a #graphene_matrix_t to an affine transformation matrix, if the
// given matrix is compatible.
//
// The returned values have the following layout:
//
//    ⎛ xx  yx ⎞   ⎛  a   b  0 ⎞
//    ⎜ xy  yy ⎟ = ⎜  c   d  0 ⎟
//    ⎝ x0  y0 ⎠   ⎝ tx  ty  1 ⎠
//
// This function can be used to convert between a #graphene_matrix_t and an
// affine matrix type from other libraries.
func (m *Matrix) To2D() (xx float64, yx float64, xy float64, yy float64, x0 float64, y0 float64, ok bool) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.double // out
	var arg2 *C.double // out
	var arg3 *C.double // out
	var arg4 *C.double // out
	var arg5 *C.double // out
	var arg6 *C.double // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	ret := C.graphene_matrix_to_2d(arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 float64
	var ret1 float64
	var ret2 float64
	var ret3 float64
	var ret4 float64
	var ret5 float64
	var ret6 bool

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = float64(arg3)

	ret3 = float64(arg4)

	ret4 = float64(arg5)

	ret5 = float64(arg6)

	ret6 = C.bool(ret) != 0

	return ret0, ret1, ret2, ret3, ret4, ret5, ret6
}

// ToFloat converts a #graphene_matrix_t to an array of floating point values.
func (m *Matrix) ToFloat() [16]float32 {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.float // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	C.graphene_matrix_to_float(arg0, &arg1)

	var ret0 [16]float32

	ret0 = [16]float32(arg1)

	return ret0
}

// TransformBounds transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is the axis aligned bounding rectangle containing the coplanar
// quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformBounds(r *Rect) Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_rect_t)(r.Native())

	C.graphene_matrix_transform_bounds(arg0, arg1, &arg2)

	var ret0 *Rect

	{
		ret0 = WrapRect(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformBox transforms the vertices of a #graphene_box_t using the given
// matrix @m.
//
// The result is the axis aligned bounding box containing the transformed
// vertices.
func (m *Matrix) TransformBox(b *Box) Box {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_box_t
	var arg2 *C.graphene_box_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_box_t)(b.Native())

	C.graphene_matrix_transform_box(arg0, arg1, &arg2)

	var ret0 *Box

	{
		ret0 = WrapBox(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformPoint transforms the given #graphene_point_t using the matrix @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint(p *Point) Point {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_point_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point_t)(p.Native())

	C.graphene_matrix_transform_point(arg0, arg1, &arg2)

	var ret0 *Point

	{
		ret0 = WrapPoint(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformPoint3D transforms the given #graphene_point3d_t using the matrix
// @m.
//
// Unlike graphene_matrix_transform_vec3(), this function will take into account
// the fourth row vector of the #graphene_matrix_t when computing the dot
// product of each row vector of the matrix.
//
// See also: graphene_simd4x4f_point3_mul()
func (m *Matrix) TransformPoint3D(p *Point3D) Point3D {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t
	var arg2 *C.graphene_point3d_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point3d_t)(p.Native())

	C.graphene_matrix_transform_point3d(arg0, arg1, &arg2)

	var ret0 *Point3D

	{
		ret0 = WrapPoint3D(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformRay: transform a #graphene_ray_t using the given matrix @m.
func (m *Matrix) TransformRay(r *Ray) Ray {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_ray_t
	var arg2 *C.graphene_ray_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_ray_t)(r.Native())

	C.graphene_matrix_transform_ray(arg0, arg1, &arg2)

	var ret0 *Ray

	{
		ret0 = WrapRay(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformRect transforms each corner of a #graphene_rect_t using the given
// matrix @m.
//
// The result is a coplanar quadrilateral.
//
// See also: graphene_matrix_transform_point()
func (m *Matrix) TransformRect(r *Rect) Quad {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_quad_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_rect_t)(r.Native())

	C.graphene_matrix_transform_rect(arg0, arg1, &arg2)

	var ret0 *Quad

	{
		ret0 = WrapQuad(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformSphere transforms a #graphene_sphere_t using the given matrix @m.
// The result is the bounding sphere containing the transformed sphere.
func (m *Matrix) TransformSphere(s *Sphere) Sphere {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_sphere_t
	var arg2 *C.graphene_sphere_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_sphere_t)(s.Native())

	C.graphene_matrix_transform_sphere(arg0, arg1, &arg2)

	var ret0 *Sphere

	{
		ret0 = WrapSphere(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformVec3 transforms the given #graphene_vec3_t using the matrix @m.
//
// This function will multiply the X, Y, and Z row vectors of the matrix @m with
// the corresponding components of the vector @v. The W row vector will be
// ignored.
//
// See also: graphene_simd4x4f_vec3_mul()
func (m *Matrix) TransformVec3(v *Vec3) Vec3 {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec3_t
	var arg2 *C.graphene_vec3_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_vec3_t)(v.Native())

	C.graphene_matrix_transform_vec3(arg0, arg1, &arg2)

	var ret0 *Vec3

	{
		ret0 = WrapVec3(unsafe.Pointer(arg2))
	}

	return ret0
}

// TransformVec4 transforms the given #graphene_vec4_t using the matrix @m.
//
// See also: graphene_simd4x4f_vec4_mul()
func (m *Matrix) TransformVec4(v *Vec4) Vec4 {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_vec4_t
	var arg2 *C.graphene_vec4_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_vec4_t)(v.Native())

	C.graphene_matrix_transform_vec4(arg0, arg1, &arg2)

	var ret0 *Vec4

	{
		ret0 = WrapVec4(unsafe.Pointer(arg2))
	}

	return ret0
}

// Translate adds a translation transformation to @m using the coordinates of
// the given #graphene_point3d_t.
//
// This is the equivalent of calling graphene_matrix_init_translate() and then
// multiplying @m with the translation matrix.
func (m *Matrix) Translate(pos *Point3D) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point3d_t)(pos.Native())

	C.graphene_matrix_translate(arg0, arg1)
}

// Transpose transposes the given matrix.
func (m *Matrix) Transpose() Matrix {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())

	C.graphene_matrix_transpose(arg0, &arg1)

	var ret0 *Matrix

	{
		ret0 = WrapMatrix(unsafe.Pointer(arg1))
	}

	return ret0
}

// UnprojectPoint3D unprojects the given @point using the @projection matrix and
// a @modelview matrix.
func (p *Matrix) UnprojectPoint3D(modelview *Matrix, point *Point3D) Point3D {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_matrix_t
	var arg2 *C.graphene_point3d_t
	var arg3 *C.graphene_point3d_t // out

	arg0 = (*C.graphene_matrix_t)(p.Native())
	arg1 = (*C.graphene_matrix_t)(modelview.Native())
	arg2 = (*C.graphene_point3d_t)(point.Native())

	C.graphene_matrix_unproject_point3d(arg0, arg1, arg2, &arg3)

	var ret0 *Point3D

	{
		ret0 = WrapPoint3D(unsafe.Pointer(arg3))
	}

	return ret0
}

// UntransformBounds undoes the transformation on the corners of a
// #graphene_rect_t using the given matrix, within the given axis aligned
// rectangular @bounds.
func (m *Matrix) UntransformBounds(r *Rect, bounds *Rect) Rect {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_rect_t
	var arg2 *C.graphene_rect_t
	var arg3 *C.graphene_rect_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_rect_t)(r.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	C.graphene_matrix_untransform_bounds(arg0, arg1, arg2, &arg3)

	var ret0 *Rect

	{
		ret0 = WrapRect(unsafe.Pointer(arg3))
	}

	return ret0
}

// UntransformPoint undoes the transformation of a #graphene_point_t using the
// given matrix, within the given axis aligned rectangular @bounds.
func (m *Matrix) UntransformPoint(p *Point, bounds *Rect) (res Point, ok bool) {
	var arg0 *C.graphene_matrix_t
	var arg1 *C.graphene_point_t
	var arg2 *C.graphene_rect_t
	var arg3 *C.graphene_point_t // out

	arg0 = (*C.graphene_matrix_t)(m.Native())
	arg1 = (*C.graphene_point_t)(p.Native())
	arg2 = (*C.graphene_rect_t)(bounds.Native())

	ret := C.graphene_matrix_untransform_point(arg0, arg1, arg2, &arg3)

	var ret0 *Point
	var ret1 bool

	{
		ret0 = WrapPoint(unsafe.Pointer(arg3))
	}

	ret1 = C.bool(ret) != 0

	return ret0, ret1
}
