// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_frustum_get_type()), F: marshalFrustum},
	})
}

// Frustum: a 3D volume delimited by 2D clip planes.
//
// The contents of the `graphene_frustum_t` are private, and should not be
// modified directly.
type Frustum struct {
	native C.graphene_frustum_t
}

// WrapFrustum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrustum(ptr unsafe.Pointer) *Frustum {
	if ptr == nil {
		return nil
	}

	return (*Frustum)(ptr)
}

func marshalFrustum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFrustum(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *Frustum) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// NewFrustumAlloc constructs a struct Frustum.
func NewFrustumAlloc() *Frustum {
	ret := C.graphene_frustum_alloc()

	var ret0 *Frustum

	{
		ret0 = WrapFrustum(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *Frustum) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ContainsPoint checks whether a point is inside the volume defined by the
// given #graphene_frustum_t.
func (f *Frustum) ContainsPoint(point *Point3D) bool {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_point3d_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_point3d_t)(point.Native())

	ret := C.graphene_frustum_contains_point(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Equal checks whether the two given #graphene_frustum_t are equal.
func (a *Frustum) Equal(b *Frustum) bool {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_frustum_t

	arg0 = (*C.graphene_frustum_t)(a.Native())
	arg1 = (*C.graphene_frustum_t)(b.Native())

	ret := C.graphene_frustum_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// Free frees the resources allocated by graphene_frustum_alloc().
func (f *Frustum) Free() {
	var arg0 *C.graphene_frustum_t

	arg0 = (*C.graphene_frustum_t)(f.Native())

	C.graphene_frustum_free(arg0)
}

// Planes retrieves the planes that define the given #graphene_frustum_t.
func (f *Frustum) Planes() [6]Plane {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_plane_t // out

	arg0 = (*C.graphene_frustum_t)(f.Native())

	C.graphene_frustum_get_planes(arg0, &arg1)

	var ret0 [6]Plane

	{
		cArray := ([6]graphene_plane_t)(arg1)

		for i := 0; i < 6; i++ {
			src := cArray[i]
			{
				ret0[i] = WrapPlane(unsafe.Pointer(src))
			}
		}
	}

	return ret0
}

// Init initializes the given #graphene_frustum_t using the provided clipping
// planes.
func (f *Frustum) Init(p0 *Plane, p1 *Plane, p2 *Plane, p3 *Plane, p4 *Plane, p5 *Plane) *Frustum {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_plane_t
	var arg2 *C.graphene_plane_t
	var arg3 *C.graphene_plane_t
	var arg4 *C.graphene_plane_t
	var arg5 *C.graphene_plane_t
	var arg6 *C.graphene_plane_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_plane_t)(p0.Native())
	arg2 = (*C.graphene_plane_t)(p1.Native())
	arg3 = (*C.graphene_plane_t)(p2.Native())
	arg4 = (*C.graphene_plane_t)(p3.Native())
	arg5 = (*C.graphene_plane_t)(p4.Native())
	arg6 = (*C.graphene_plane_t)(p5.Native())

	ret := C.graphene_frustum_init(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 *Frustum

	{
		ret0 = WrapFrustum(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromFrustum initializes the given #graphene_frustum_t using the clipping
// planes of another #graphene_frustum_t.
func (f *Frustum) InitFromFrustum(src *Frustum) *Frustum {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_frustum_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_frustum_t)(src.Native())

	ret := C.graphene_frustum_init_from_frustum(arg0, arg1)

	var ret0 *Frustum

	{
		ret0 = WrapFrustum(unsafe.Pointer(ret))
	}

	return ret0
}

// InitFromMatrix initializes a #graphene_frustum_t using the given @matrix.
func (f *Frustum) InitFromMatrix(matrix *Matrix) *Frustum {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_matrix_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_matrix_t)(matrix.Native())

	ret := C.graphene_frustum_init_from_matrix(arg0, arg1)

	var ret0 *Frustum

	{
		ret0 = WrapFrustum(unsafe.Pointer(ret))
	}

	return ret0
}

// IntersectsBox checks whether the given @box intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsBox(box *Box) bool {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_box_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_box_t)(box.Native())

	ret := C.graphene_frustum_intersects_box(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// IntersectsSphere checks whether the given @sphere intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsSphere(sphere *Sphere) bool {
	var arg0 *C.graphene_frustum_t
	var arg1 *C.graphene_sphere_t

	arg0 = (*C.graphene_frustum_t)(f.Native())
	arg1 = (*C.graphene_sphere_t)(sphere.Native())

	ret := C.graphene_frustum_intersects_sphere(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}
