// Code generated by girgen. DO NOT EDIT.

package graphene

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: graphene-gobject-1.0 graphene-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <graphene-gobject.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.graphene_frustum_get_type()), F: marshalFrustum},
	})
}

// Frustum: a 3D volume delimited by 2D clip planes.
//
// The contents of the `graphene_frustum_t` are private, and should not be
// modified directly.
type Frustum struct {
	native C.graphene_frustum_t
}

// WrapFrustum wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrustum(ptr unsafe.Pointer) *Frustum {
	if ptr == nil {
		return nil
	}

	return (*Frustum)(ptr)
}

func marshalFrustum(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFrustum(unsafe.Pointer(b)), nil
}

// NewFrustumAlloc constructs a struct Frustum.
func NewFrustumAlloc() *Frustum {
	var _cret *C.graphene_frustum_t

	cret = C.graphene_frustum_alloc()

	var _frustum *Frustum

	_frustum = WrapFrustum(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_frustum, func(v *Frustum) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _frustum
}

// Native returns the underlying C source pointer.
func (f *Frustum) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// ContainsPoint checks whether a point is inside the volume defined by the
// given #graphene_frustum_t.
func (f *Frustum) ContainsPoint(point *Point3D) bool {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_point3d_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

	var _cret C._Bool

	cret = C.graphene_frustum_contains_point(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks whether the two given #graphene_frustum_t are equal.
func (a *Frustum) Equal(b *Frustum) bool {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_frustum_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.graphene_frustum_t)(unsafe.Pointer(b.Native()))

	var _cret C._Bool

	cret = C.graphene_frustum_equal(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Free frees the resources allocated by graphene_frustum_alloc().
func (f *Frustum) Free() {
	var _arg0 *C.graphene_frustum_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))

	C.graphene_frustum_free(_arg0)
}

// Planes retrieves the planes that define the given #graphene_frustum_t.
func (f *Frustum) Planes() [6]Plane {
	var _arg0 *C.graphene_frustum_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))

	var _arg1 [6]C.graphene_plane_t

	C.graphene_frustum_get_planes(_arg0, &_arg1[0])

	var _planes [6]Plane

	_planes = *(*[6]Plane)(unsafe.Pointer(_arg1))

	return _planes
}

// Init initializes the given #graphene_frustum_t using the provided clipping
// planes.
func (f *Frustum) Init(p0 *Plane, p1 *Plane, p2 *Plane, p3 *Plane, p4 *Plane, p5 *Plane) *Frustum {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_plane_t
	var _arg2 *C.graphene_plane_t
	var _arg3 *C.graphene_plane_t
	var _arg4 *C.graphene_plane_t
	var _arg5 *C.graphene_plane_t
	var _arg6 *C.graphene_plane_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_plane_t)(unsafe.Pointer(p0.Native()))
	_arg2 = (*C.graphene_plane_t)(unsafe.Pointer(p1.Native()))
	_arg3 = (*C.graphene_plane_t)(unsafe.Pointer(p2.Native()))
	_arg4 = (*C.graphene_plane_t)(unsafe.Pointer(p3.Native()))
	_arg5 = (*C.graphene_plane_t)(unsafe.Pointer(p4.Native()))
	_arg6 = (*C.graphene_plane_t)(unsafe.Pointer(p5.Native()))

	var _cret *C.graphene_frustum_t

	cret = C.graphene_frustum_init(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)

	var _frustum *Frustum

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// InitFromFrustum initializes the given #graphene_frustum_t using the clipping
// planes of another #graphene_frustum_t.
func (f *Frustum) InitFromFrustum(src *Frustum) *Frustum {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_frustum_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_frustum_t)(unsafe.Pointer(src.Native()))

	var _cret *C.graphene_frustum_t

	cret = C.graphene_frustum_init_from_frustum(_arg0, _arg1)

	var _frustum *Frustum

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// InitFromMatrix initializes a #graphene_frustum_t using the given @matrix.
func (f *Frustum) InitFromMatrix(matrix *Matrix) *Frustum {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_matrix_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

	var _cret *C.graphene_frustum_t

	cret = C.graphene_frustum_init_from_matrix(_arg0, _arg1)

	var _frustum *Frustum

	_frustum = WrapFrustum(unsafe.Pointer(_cret))

	return _frustum
}

// IntersectsBox checks whether the given @box intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsBox(box *Box) bool {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_box_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_box_t)(unsafe.Pointer(box.Native()))

	var _cret C._Bool

	cret = C.graphene_frustum_intersects_box(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// IntersectsSphere checks whether the given @sphere intersects a plane of a
// #graphene_frustum_t.
func (f *Frustum) IntersectsSphere(sphere *Sphere) bool {
	var _arg0 *C.graphene_frustum_t
	var _arg1 *C.graphene_sphere_t

	_arg0 = (*C.graphene_frustum_t)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.graphene_sphere_t)(unsafe.Pointer(sphere.Native()))

	var _cret C._Bool

	cret = C.graphene_frustum_intersects_sphere(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}
