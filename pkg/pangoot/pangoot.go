// Code generated by girgen. DO NOT EDIT.

package pangoot

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/pango"
	"github.com/diamondburned/gotk4/pkg/pangofc"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pangoot
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <pango/pango-ot.h>
//
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		// Skipped TableType.

		// Records
		{T: externglib.Type(C.pango_ot_buffer_get_type()), F: marshalBuffer},
		// Skipped FeatureMap.
		// Skipped Glyph.
		{T: externglib.Type(C.pango_ot_ruleset_description_get_type()), F: marshalRulesetDescription},

		// Classes
		{T: externglib.Type(C.pango_ot_info_get_type()), F: marshalInfo},
		{T: externglib.Type(C.pango_ot_ruleset_get_type()), F: marshalRuleset},
	})
}

// Tag: the OTTag typedef is used to represent TrueType and OpenType four letter
// tags inside Pango. Use PANGO_OT_TAG_MAKE() or PANGO_OT_TAG_MAKE_FROM_STRING()
// macros to create PangoOTTags manually.
type Tag uint32

// TableType: the PangoOTTableType enumeration values are used to identify the
// various OpenType tables in the pango_ot_info_â€¦ functions.
type TableType int

const (
	// TableTypeGsub: the GSUB table.
	TableTypeGsub TableType = 0
	// TableTypeGpos: the GPOS table.
	TableTypeGpos TableType = 1
)

// TagFromLanguage finds the OpenType language-system tag best describing
// @language.
func TagFromLanguage(language *pango.Language) Tag {
	var arg1 *C.PangoLanguage

	arg1 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_ot_tag_from_language(arg1)

	var ret0 Tag

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Tag(tmp)
	}

	return ret0
}

// TagFromScript finds the OpenType script tag corresponding to @script.
//
// The PANGO_SCRIPT_COMMON, PANGO_SCRIPT_INHERITED, and PANGO_SCRIPT_UNKNOWN
// scripts are mapped to the OpenType 'DFLT' script tag that is also defined as
// PANGO_OT_TAG_DEFAULT_SCRIPT.
//
// Note that multiple Script values may map to the same OpenType script tag. In
// particular, PANGO_SCRIPT_HIRAGANA and PANGO_SCRIPT_KATAKANA both map to the
// OT tag 'kana'.
func TagFromScript(script pango.Script) Tag {
	var arg1 C.PangoScript

	arg1 = (C.PangoScript)(script)

	ret := C.pango_ot_tag_from_script(arg1)

	var ret0 Tag

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = Tag(tmp)
	}

	return ret0
}

// TagToLanguage finds a Language corresponding to @language_tag.
func TagToLanguage(languageTag Tag) *pango.Language {
	var arg1 C.PangoOTTag

	ret := C.pango_ot_tag_to_language(arg1)

	var ret0 *pango.Language

	ret0 = pango.WrapLanguage(ret)

	return ret0
}

// TagToScript finds the Script corresponding to @script_tag.
//
// The 'DFLT' script tag is mapped to PANGO_SCRIPT_COMMON.
//
// Note that an OpenType script tag may correspond to multiple Script values. In
// such cases, the Script value with the smallest value is returned. In
// particular, PANGO_SCRIPT_HIRAGANA and PANGO_SCRIPT_KATAKANA both map to the
// OT tag 'kana'. This function will return PANGO_SCRIPT_HIRAGANA for 'kana'.
func TagToScript(scriptTag Tag) pango.Script {
	var arg1 C.PangoOTTag

	ret := C.pango_ot_tag_to_script(arg1)

	var ret0 pango.Script

	ret0 = pango.Script(ret)

	return ret0
}

type Buffer struct {
	native C.PangoOTBuffer
}

// WrapBuffer wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapBuffer(ptr unsafe.Pointer) *Buffer {
	if ptr == nil {
		return nil
	}

	return (*Buffer)(ptr)
}

func marshalBuffer(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapBuffer(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (b *Buffer) Native() unsafe.Pointer {
	return unsafe.Pointer(&b.native)
}

// NewBuffer constructs a struct Buffer.
func NewBuffer(font pangofc.Font) *Buffer {
	var arg1 *C.PangoFcFont

	arg1 = (*C.PangoFcFont)(font.Native())

	ret := C.pango_ot_buffer_new(arg1)

	var ret0 *Buffer

	ret0 = WrapBuffer(ret)

	return ret0
}

// FeatureMap: the OTFeatureMap typedef is used to represent an OpenType feature
// with the property bit associated with it. The feature tag is represented as a
// char array instead of a OTTag for convenience.
type FeatureMap struct {
	native C.PangoOTFeatureMap
}

// WrapFeatureMap wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFeatureMap(ptr unsafe.Pointer) *FeatureMap {
	if ptr == nil {
		return nil
	}

	return (*FeatureMap)(ptr)
}

func marshalFeatureMap(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFeatureMap(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FeatureMap) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// FeatureName gets the field inside the struct.
func (f *FeatureMap) FeatureName() [5]byte {
	var ret [5]byte
	ret = [5]byte(f.native.feature_name)
	return ret
}

// PropertyBit gets the field inside the struct.
func (p *FeatureMap) PropertyBit() uint32 {
	var ret uint32
	ret = uint32(f.native.property_bit)
	return ret
}

// Glyph: the OTGlyph structure represents a single glyph together with
// information used for OpenType layout processing of the glyph. It contains the
// following fields.
type Glyph struct {
	native C.PangoOTGlyph
}

// WrapGlyph wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyph(ptr unsafe.Pointer) *Glyph {
	if ptr == nil {
		return nil
	}

	return (*Glyph)(ptr)
}

func marshalGlyph(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyph(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (g *Glyph) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Glyph gets the field inside the struct.
func (g *Glyph) Glyph() uint32 {
	var ret uint32
	ret = uint32(g.native.glyph)
	return ret
}

// Properties gets the field inside the struct.
func (p *Glyph) Properties() uint {
	var ret uint
	ret = uint(g.native.properties)
	return ret
}

// Cluster gets the field inside the struct.
func (c *Glyph) Cluster() uint {
	var ret uint
	ret = uint(g.native.cluster)
	return ret
}

// Component gets the field inside the struct.
func (c *Glyph) Component() uint16 {
	var ret uint16
	ret = uint16(g.native.component)
	return ret
}

// LigID gets the field inside the struct.
func (l *Glyph) LigID() uint16 {
	var ret uint16
	ret = uint16(g.native.ligID)
	return ret
}

// Internal gets the field inside the struct.
func (i *Glyph) Internal() uint {
	var ret uint
	ret = uint(g.native.internal)
	return ret
}

// RulesetDescription: the OTRuleset structure holds all the information needed
// to build a complete OTRuleset from an OpenType font. The main use of this
// struct is to act as the key for a per-font hash of rulesets. The user
// populates a ruleset description and gets the ruleset using
// pango_ot_ruleset_get_for_description() or create a new one using
// pango_ot_ruleset_new_from_description().
type RulesetDescription struct {
	native C.PangoOTRulesetDescription
}

// WrapRulesetDescription wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRulesetDescription(ptr unsafe.Pointer) *RulesetDescription {
	if ptr == nil {
		return nil
	}

	return (*RulesetDescription)(ptr)
}

func marshalRulesetDescription(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRulesetDescription(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *RulesetDescription) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// Script gets the field inside the struct.
func (s *RulesetDescription) Script() pango.Script {
	var ret pango.Script
	ret = pango.Script(r.native.script)
	return ret
}

// Language gets the field inside the struct.
func (l *RulesetDescription) Language() *pango.Language {
	var ret *pango.Language
	ret = pango.WrapLanguage(r.native.language)
	return ret
}

// StaticGsubFeatures gets the field inside the struct.
func (s *RulesetDescription) StaticGsubFeatures() *FeatureMap {
	var ret *FeatureMap
	ret = WrapFeatureMap(r.native.static_gsub_features)
	return ret
}

// NStaticGsubFeatures gets the field inside the struct.
func (n *RulesetDescription) NStaticGsubFeatures() uint {
	var ret uint
	ret = uint(r.native.n_static_gsub_features)
	return ret
}

// StaticGposFeatures gets the field inside the struct.
func (s *RulesetDescription) StaticGposFeatures() *FeatureMap {
	var ret *FeatureMap
	ret = WrapFeatureMap(r.native.static_gpos_features)
	return ret
}

// NStaticGposFeatures gets the field inside the struct.
func (n *RulesetDescription) NStaticGposFeatures() uint {
	var ret uint
	ret = uint(r.native.n_static_gpos_features)
	return ret
}

// OtherFeatures gets the field inside the struct.
func (o *RulesetDescription) OtherFeatures() *FeatureMap {
	var ret *FeatureMap
	ret = WrapFeatureMap(r.native.other_features)
	return ret
}

// NOtherFeatures gets the field inside the struct.
func (n *RulesetDescription) NOtherFeatures() uint {
	var ret uint
	ret = uint(r.native.n_other_features)
	return ret
}

type Info interface {
	gextras.Objector

	// FindFeature finds the index of a feature. If the feature is not found,
	// sets @feature_index to PANGO_OT_NO_FEATURE, which is safe to pass to
	// pango_ot_ruleset_add_feature() and similar functions.
	//
	// In the future, this may set @feature_index to an special value that if
	// used in pango_ot_ruleset_add_feature() will ask Pango to synthesize the
	// requested feature based on Unicode properties and data. However, this
	// function will still return false in those cases. So, users may want to
	// ignore the return value of this function in certain cases.
	FindFeature(tableType TableType, featureTag Tag, scriptIndex uint, languageIndex uint) (featureIndex uint, ok bool)
	// FindLanguage finds the index of a language and its required feature
	// index. If the language is not found, sets @language_index to
	// PANGO_OT_DEFAULT_LANGUAGE and the required feature of the default
	// language system is returned in required_feature_index. For best
	// compatibility with some fonts, also searches the language system tag
	// 'dflt' before falling back to the default language system, but that is
	// transparent to the user. The user can simply ignore the return value of
	// this function to automatically fall back to the default language system.
	FindLanguage(tableType TableType, scriptIndex uint, languageTag Tag) (languageIndex uint, requiredFeatureIndex uint, ok bool)
	// FindScript finds the index of a script. If not found, tries to find the
	// 'DFLT' and then 'dflt' scripts and return the index of that in
	// @script_index. If none of those is found either, PANGO_OT_NO_SCRIPT is
	// placed in @script_index.
	//
	// All other functions taking an input script_index parameter know how to
	// handle PANGO_OT_NO_SCRIPT, so one can ignore the return value of this
	// function completely and proceed, to enjoy the automatic fallback to the
	// 'DFLT'/'dflt' script.
	FindScript(tableType TableType, scriptTag Tag) (scriptIndex uint, ok bool)
	// ListFeatures obtains the list of features for the given language of the
	// given script.
	ListFeatures(tableType TableType, tag Tag, scriptIndex uint, languageIndex uint) *Tag
	// ListLanguages obtains the list of available languages for a given script.
	ListLanguages(tableType TableType, scriptIndex uint, languageTag Tag) *Tag
	// ListScripts obtains the list of available scripts.
	ListScripts(tableType TableType) *Tag
}

type info struct {
	*externglib.Object
}

// WrapInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapInfo(obj *externglib.Object) Info {
	return info{*externglib.Object{obj}}
}

func marshalInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInfo(obj), nil
}

// FindFeature finds the index of a feature. If the feature is not found,
// sets @feature_index to PANGO_OT_NO_FEATURE, which is safe to pass to
// pango_ot_ruleset_add_feature() and similar functions.
//
// In the future, this may set @feature_index to an special value that if
// used in pango_ot_ruleset_add_feature() will ask Pango to synthesize the
// requested feature based on Unicode properties and data. However, this
// function will still return false in those cases. So, users may want to
// ignore the return value of this function in certain cases.
func (info info) FindFeature(tableType TableType, featureTag Tag, scriptIndex uint, languageIndex uint) (featureIndex uint, ok bool) {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType
	var arg2 C.PangoOTTag
	var arg3 C.guint
	var arg4 C.guint
	var arg5 *C.guint // out

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg3 = C.guint(scriptIndex)
	arg4 = C.guint(languageIndex)

	ret := C.pango_ot_info_find_feature(arg0, arg1, arg2, arg3, arg4, &arg5)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg5)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// FindLanguage finds the index of a language and its required feature
// index. If the language is not found, sets @language_index to
// PANGO_OT_DEFAULT_LANGUAGE and the required feature of the default
// language system is returned in required_feature_index. For best
// compatibility with some fonts, also searches the language system tag
// 'dflt' before falling back to the default language system, but that is
// transparent to the user. The user can simply ignore the return value of
// this function to automatically fall back to the default language system.
func (info info) FindLanguage(tableType TableType, scriptIndex uint, languageTag Tag) (languageIndex uint, requiredFeatureIndex uint, ok bool) {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType
	var arg2 C.guint
	var arg3 C.PangoOTTag
	var arg4 *C.guint // out
	var arg5 *C.guint // out

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg2 = C.guint(scriptIndex)

	ret := C.pango_ot_info_find_language(arg0, arg1, arg2, arg3, &arg4, &arg5)

	var ret0 uint
	var ret1 uint
	var ret2 bool

	ret0 = uint(arg4)

	ret1 = uint(arg5)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// FindScript finds the index of a script. If not found, tries to find the
// 'DFLT' and then 'dflt' scripts and return the index of that in
// @script_index. If none of those is found either, PANGO_OT_NO_SCRIPT is
// placed in @script_index.
//
// All other functions taking an input script_index parameter know how to
// handle PANGO_OT_NO_SCRIPT, so one can ignore the return value of this
// function completely and proceed, to enjoy the automatic fallback to the
// 'DFLT'/'dflt' script.
func (info info) FindScript(tableType TableType, scriptTag Tag) (scriptIndex uint, ok bool) {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType
	var arg2 C.PangoOTTag
	var arg3 *C.guint // out

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)

	ret := C.pango_ot_info_find_script(arg0, arg1, arg2, &arg3)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ListFeatures obtains the list of features for the given language of the
// given script.
func (info info) ListFeatures(tableType TableType, tag Tag, scriptIndex uint, languageIndex uint) *Tag {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType
	var arg2 C.PangoOTTag
	var arg3 C.guint
	var arg4 C.guint

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg3 = C.guint(scriptIndex)
	arg4 = C.guint(languageIndex)

	ret := C.pango_ot_info_list_features(arg0, arg1, arg2, arg3, arg4)

	var ret0 *Tag

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = *Tag(tmp)
	}

	return ret0
}

// ListLanguages obtains the list of available languages for a given script.
func (info info) ListLanguages(tableType TableType, scriptIndex uint, languageTag Tag) *Tag {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType
	var arg2 C.guint
	var arg3 C.PangoOTTag

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg2 = C.guint(scriptIndex)

	ret := C.pango_ot_info_list_languages(arg0, arg1, arg2, arg3)

	var ret0 *Tag

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = *Tag(tmp)
	}

	return ret0
}

// ListScripts obtains the list of available scripts.
func (info info) ListScripts(tableType TableType) *Tag {
	var arg0 *C.PangoOTInfo
	var arg1 C.PangoOTTableType

	arg0 = (*C.PangoOTInfo)(info.Native())
	arg1 = (C.PangoOTTableType)(tableType)

	ret := C.pango_ot_info_list_scripts(arg0, arg1)

	var ret0 *Tag

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = *Tag(tmp)
	}

	return ret0
}

// Ruleset: the OTRuleset structure holds a set of features selected from the
// tables in an OpenType font. (A feature is an operation such as adjusting
// glyph positioning that should be applied to a text feature such as a certain
// type of accent.) A OTRuleset is created with pango_ot_ruleset_new(), features
// are added to it with pango_ot_ruleset_add_feature(), then it is applied to a
// GlyphString with pango_ot_ruleset_shape().
type Ruleset interface {
	gextras.Objector

	// AddFeature adds a feature to the ruleset.
	AddFeature(tableType TableType, featureIndex uint, propertyBit uint32)
	// FeatureCount gets the number of GSUB and GPOS features in the ruleset.
	FeatureCount() (nGsubFeatures uint, nGposFeatures uint, guint uint)
	// MaybeAddFeature: this is a convenience function that first tries to find
	// the feature using pango_ot_info_find_feature() and the ruleset script and
	// language passed to pango_ot_ruleset_new_for(), and if the feature is
	// found, adds it to the ruleset.
	//
	// If @ruleset was not created using pango_ot_ruleset_new_for(), this
	// function does nothing.
	MaybeAddFeature(tableType TableType, featureTag Tag, propertyBit uint32) bool
	// MaybeAddFeatures: this is a convenience function that for each feature in
	// the feature map array @features converts the feature name to a OTTag
	// feature tag using PANGO_OT_TAG_MAKE() and calls
	// pango_ot_ruleset_maybe_add_feature() on it.
	MaybeAddFeatures(tableType TableType, features *FeatureMap, nFeatures uint) uint
	// Position performs the OpenType GPOS positioning on @buffer using the
	// features in @ruleset
	Position(buffer *Buffer)
	// Substitute performs the OpenType GSUB substitution on @buffer using the
	// features in @ruleset
	Substitute(buffer *Buffer)
}

type ruleset struct {
	*externglib.Object
}

// WrapRuleset wraps a GObject to the right type. It is
// primarily used internally.
func WrapRuleset(obj *externglib.Object) Ruleset {
	return ruleset{*externglib.Object{obj}}
}

func marshalRuleset(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRuleset(obj), nil
}

// NewRuleset constructs a class Ruleset.
func NewRuleset(info Info) Ruleset {
	var arg1 *C.PangoOTInfo

	arg1 = (*C.PangoOTInfo)(info.Native())

	ret := C.pango_ot_ruleset_new(arg1)

	var ret0 Ruleset

	ret0 = WrapRuleset(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewRulesetFor constructs a class Ruleset.
func NewRulesetFor(info Info, script pango.Script, language *pango.Language) Ruleset {
	var arg1 *C.PangoOTInfo
	var arg2 C.PangoScript
	var arg3 *C.PangoLanguage

	arg1 = (*C.PangoOTInfo)(info.Native())
	arg2 = (C.PangoScript)(script)
	arg3 = (*C.PangoLanguage)(language.Native())

	ret := C.pango_ot_ruleset_new_for(arg1, arg2, arg3)

	var ret0 Ruleset

	ret0 = WrapRuleset(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewRulesetFromDescription constructs a class Ruleset.
func NewRulesetFromDescription(info Info, desc *RulesetDescription) Ruleset {
	var arg1 *C.PangoOTInfo
	var arg2 *C.PangoOTRulesetDescription

	arg1 = (*C.PangoOTInfo)(info.Native())
	arg2 = (*C.PangoOTRulesetDescription)(desc.Native())

	ret := C.pango_ot_ruleset_new_from_description(arg1, arg2)

	var ret0 Ruleset

	ret0 = WrapRuleset(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddFeature adds a feature to the ruleset.
func (ruleset ruleset) AddFeature(tableType TableType, featureIndex uint, propertyBit uint32) {
	var arg0 *C.PangoOTRuleset
	var arg1 C.PangoOTTableType
	var arg2 C.guint
	var arg3 C.gulong

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg2 = C.guint(featureIndex)
	arg3 = C.gulong(propertyBit)

	C.pango_ot_ruleset_add_feature(arg0, arg1, arg2, arg3)
}

// FeatureCount gets the number of GSUB and GPOS features in the ruleset.
func (ruleset ruleset) FeatureCount() (nGsubFeatures uint, nGposFeatures uint, guint uint) {
	var arg0 *C.PangoOTRuleset
	var arg1 *C.guint // out
	var arg2 *C.guint // out

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())

	ret := C.pango_ot_ruleset_get_feature_count(arg0, &arg1, &arg2)

	var ret0 uint
	var ret1 uint
	var ret2 uint

	ret0 = uint(arg1)

	ret1 = uint(arg2)

	ret2 = uint(ret)

	return ret0, ret1, ret2
}

// MaybeAddFeature: this is a convenience function that first tries to find
// the feature using pango_ot_info_find_feature() and the ruleset script and
// language passed to pango_ot_ruleset_new_for(), and if the feature is
// found, adds it to the ruleset.
//
// If @ruleset was not created using pango_ot_ruleset_new_for(), this
// function does nothing.
func (ruleset ruleset) MaybeAddFeature(tableType TableType, featureTag Tag, propertyBit uint32) bool {
	var arg0 *C.PangoOTRuleset
	var arg1 C.PangoOTTableType
	var arg2 C.PangoOTTag
	var arg3 C.gulong

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg3 = C.gulong(propertyBit)

	ret := C.pango_ot_ruleset_maybe_add_feature(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MaybeAddFeatures: this is a convenience function that for each feature in
// the feature map array @features converts the feature name to a OTTag
// feature tag using PANGO_OT_TAG_MAKE() and calls
// pango_ot_ruleset_maybe_add_feature() on it.
func (ruleset ruleset) MaybeAddFeatures(tableType TableType, features *FeatureMap, nFeatures uint) uint {
	var arg0 *C.PangoOTRuleset
	var arg1 C.PangoOTTableType
	var arg2 *C.PangoOTFeatureMap
	var arg3 C.guint

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())
	arg1 = (C.PangoOTTableType)(tableType)
	arg2 = (*C.PangoOTFeatureMap)(features.Native())
	arg3 = C.guint(nFeatures)

	ret := C.pango_ot_ruleset_maybe_add_features(arg0, arg1, arg2, arg3)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Position performs the OpenType GPOS positioning on @buffer using the
// features in @ruleset
func (ruleset ruleset) Position(buffer *Buffer) {
	var arg0 *C.PangoOTRuleset
	var arg1 *C.PangoOTBuffer

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())
	arg1 = (*C.PangoOTBuffer)(buffer.Native())

	C.pango_ot_ruleset_position(arg0, arg1)
}

// Substitute performs the OpenType GSUB substitution on @buffer using the
// features in @ruleset
func (ruleset ruleset) Substitute(buffer *Buffer) {
	var arg0 *C.PangoOTRuleset
	var arg1 *C.PangoOTBuffer

	arg0 = (*C.PangoOTRuleset)(ruleset.Native())
	arg1 = (*C.PangoOTBuffer)(buffer.Native())

	C.pango_ot_ruleset_substitute(arg0, arg1)
}
