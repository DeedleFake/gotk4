// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
//
// extern void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer)
// extern void gotk4_BusAcquiredCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameAcquiredCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameAppearedCallback(GDBusConnection*, const gchar*, const gchar*, gpointer)
// extern void gotk4_BusNameLostCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameVanishedCallback(GDBusConnection*, const gchar*, gpointer)
// extern gboolean gotk4_CancellableSourceFunc(GCancellable*, gpointer)
// extern GVariant* gotk4_DBusInterfaceGetPropertyFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GError**, gpointer)
// extern void gotk4_DBusInterfaceMethodCallFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, GDBusMethodInvocation*, gpointer)
// extern gboolean gotk4_DBusInterfaceSetPropertyFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, GError**, gpointer)
// extern GDBusMessage* gotk4_DBusMessageFilterFunction(GDBusConnection*, GDBusMessage*, gboolean, gpointer)
// extern GType gotk4_DBusProxyTypeFunc(GDBusObjectManagerClient*, const gchar*, const gchar*, gpointer)
// extern void gotk4_DBusSignalCallback(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, gpointer)
// extern const GDBusInterfaceVTable* gotk4_DBusSubtreeDispatchFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, gpointer*, gpointer)
// extern gchar** gotk4_DBusSubtreeEnumerateFunc(GDBusConnection*, const gchar*, const gchar*, gpointer)
// extern GDBusInterfaceInfo** gotk4_DBusSubtreeIntrospectFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, gpointer)
// extern gboolean gotk4_DatagramBasedSourceFunc(GDatagramBased*, GIOCondition, gpointer)
// extern void gotk4_DesktopAppLaunchCallback(GDesktopAppInfo*, GPid, gpointer)
// extern void gotk4_FileMeasureProgressCallback(gboolean, guint64, guint64, guint64, gpointer)
// extern void gotk4_FileProgressCallback(goffset, goffset, gpointer)
// extern gboolean gotk4_FileReadMoreCallback(const char*, goffset, gpointer)
// extern gboolean gotk4_IOSchedulerJobFunc(GIOSchedulerJob*, GCancellable*, gpointer)
// extern gboolean gotk4_PollableSourceFunc(GObject*, gpointer)
// extern gboolean gotk4_SettingsBindGetMapping(GValue*, GVariant*, gpointer)
// extern GVariant* gotk4_SettingsBindSetMapping(const GValue*, const GVariantType*, gpointer)
// extern gboolean gotk4_SettingsGetMapping(GVariant*, gpointer*, gpointer)
// extern gboolean gotk4_SocketSourceFunc(GSocket*, GIOCondition, gpointer)
// extern GFile* gotk4_VfsFileLookupFunc(GVfs*, const char*, gpointer)
// // extern void callbackDelete(gpointer);
import "C"

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTlsAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTlsCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTlsChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTlsChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTlsDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTlsError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTlsInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTlsRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},

		// Records
		// Skipped ActionEntry.
		// Skipped ActionGroupInterface.
		// Skipped ActionInterface.
		// Skipped ActionMapInterface.
		// Skipped AppInfoIface.
		// Skipped AppLaunchContextClass.
		// Skipped AppLaunchContextPrivate.
		// Skipped ApplicationClass.
		// Skipped ApplicationCommandLineClass.
		// Skipped ApplicationCommandLinePrivate.
		// Skipped ApplicationPrivate.
		// Skipped AsyncInitableIface.
		// Skipped AsyncResultIface.
		// Skipped BufferedInputStreamClass.
		// Skipped BufferedInputStreamPrivate.
		// Skipped BufferedOutputStreamClass.
		// Skipped BufferedOutputStreamPrivate.
		// Skipped CancellableClass.
		// Skipped CancellablePrivate.
		// Skipped CharsetConverterClass.
		// Skipped ConverterIface.
		// Skipped ConverterInputStreamClass.
		// Skipped ConverterInputStreamPrivate.
		// Skipped ConverterOutputStreamClass.
		// Skipped ConverterOutputStreamPrivate.
		// Skipped CredentialsClass.
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		// Skipped DBusErrorEntry.
		// Skipped DBusInterfaceIface.
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		// Skipped DBusInterfaceSkeletonClass.
		// Skipped DBusInterfaceSkeletonPrivate.
		// Skipped DBusInterfaceVTable.
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		// Skipped DBusObjectIface.
		// Skipped DBusObjectManagerClientClass.
		// Skipped DBusObjectManagerClientPrivate.
		// Skipped DBusObjectManagerIface.
		// Skipped DBusObjectManagerServerClass.
		// Skipped DBusObjectManagerServerPrivate.
		// Skipped DBusObjectProxyClass.
		// Skipped DBusObjectProxyPrivate.
		// Skipped DBusObjectSkeletonClass.
		// Skipped DBusObjectSkeletonPrivate.
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		// Skipped DBusProxyClass.
		// Skipped DBusProxyPrivate.
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
		// Skipped DBusSubtreeVTable.
		// Skipped DataInputStreamClass.
		// Skipped DataInputStreamPrivate.
		// Skipped DataOutputStreamClass.
		// Skipped DataOutputStreamPrivate.
		// Skipped DatagramBasedInterface.
		// Skipped DesktopAppInfoClass.
		// Skipped DesktopAppInfoLookupIface.
		// Skipped DriveIface.
		// Skipped DtlsClientConnectionInterface.
		// Skipped DtlsConnectionInterface.
		// Skipped DtlsServerConnectionInterface.
		// Skipped EmblemClass.
		// Skipped EmblemedIconClass.
		// Skipped EmblemedIconPrivate.
		// Skipped FileAttributeInfo.
		{T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
		{T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
		// Skipped FileDescriptorBasedIface.
		// Skipped FileEnumeratorClass.
		// Skipped FileEnumeratorPrivate.
		// Skipped FileIOStreamClass.
		// Skipped FileIOStreamPrivate.
		// Skipped FileIconClass.
		// Skipped FileIface.
		// Skipped FileInfoClass.
		// Skipped FileInputStreamClass.
		// Skipped FileInputStreamPrivate.
		// Skipped FileMonitorClass.
		// Skipped FileMonitorPrivate.
		// Skipped FileOutputStreamClass.
		// Skipped FileOutputStreamPrivate.
		// Skipped FilenameCompleterClass.
		// Skipped FilterInputStreamClass.
		// Skipped FilterOutputStreamClass.
		// Skipped IOExtension.
		// Skipped IOExtensionPoint.
		// Skipped IOModuleClass.
		// Skipped IOModuleScope.
		// Skipped IOSchedulerJob.
		// Skipped IOStreamAdapter.
		// Skipped IOStreamClass.
		// Skipped IOStreamPrivate.
		// Skipped IconIface.
		// Skipped InetAddressClass.
		// Skipped InetAddressMaskClass.
		// Skipped InetAddressMaskPrivate.
		// Skipped InetAddressPrivate.
		// Skipped InetSocketAddressClass.
		// Skipped InetSocketAddressPrivate.
		// Skipped InitableIface.
		// Skipped InputMessage.
		// Skipped InputStreamClass.
		// Skipped InputStreamPrivate.
		// Skipped InputVector.
		// Skipped ListModelInterface.
		// Skipped ListStoreClass.
		// Skipped LoadableIconIface.
		// Skipped MemoryInputStreamClass.
		// Skipped MemoryInputStreamPrivate.
		// Skipped MemoryMonitorInterface.
		// Skipped MemoryOutputStreamClass.
		// Skipped MemoryOutputStreamPrivate.
		// Skipped MenuAttributeIterClass.
		// Skipped MenuAttributeIterPrivate.
		// Skipped MenuLinkIterClass.
		// Skipped MenuLinkIterPrivate.
		// Skipped MenuModelClass.
		// Skipped MenuModelPrivate.
		// Skipped MountIface.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped NativeSocketAddressClass.
		// Skipped NativeSocketAddressPrivate.
		// Skipped NativeVolumeMonitorClass.
		// Skipped NetworkAddressClass.
		// Skipped NetworkAddressPrivate.
		// Skipped NetworkMonitorInterface.
		// Skipped NetworkServiceClass.
		// Skipped NetworkServicePrivate.
		// Skipped OutputMessage.
		// Skipped OutputStreamClass.
		// Skipped OutputStreamPrivate.
		// Skipped OutputVector.
		// Skipped PermissionClass.
		// Skipped PermissionPrivate.
		// Skipped PollableInputStreamInterface.
		// Skipped PollableOutputStreamInterface.
		// Skipped ProxyAddressClass.
		// Skipped ProxyAddressEnumeratorClass.
		// Skipped ProxyAddressEnumeratorPrivate.
		// Skipped ProxyAddressPrivate.
		// Skipped ProxyInterface.
		// Skipped ProxyResolverInterface.
		// Skipped RemoteActionGroupInterface.
		// Skipped ResolverClass.
		// Skipped ResolverPrivate.
		{T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
		// Skipped SeekableIface.
		// Skipped SettingsBackendClass.
		// Skipped SettingsBackendPrivate.
		// Skipped SettingsClass.
		// Skipped SettingsPrivate.
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
		// Skipped SimpleActionGroupClass.
		// Skipped SimpleActionGroupPrivate.
		// Skipped SimpleAsyncResultClass.
		// Skipped SimpleProxyResolverClass.
		// Skipped SimpleProxyResolverPrivate.
		// Skipped SocketAddressClass.
		// Skipped SocketAddressEnumeratorClass.
		// Skipped SocketClass.
		// Skipped SocketClientClass.
		// Skipped SocketClientPrivate.
		// Skipped SocketConnectableIface.
		// Skipped SocketConnectionClass.
		// Skipped SocketConnectionPrivate.
		// Skipped SocketControlMessageClass.
		// Skipped SocketControlMessagePrivate.
		// Skipped SocketListenerClass.
		// Skipped SocketListenerPrivate.
		// Skipped SocketPrivate.
		// Skipped SocketServiceClass.
		// Skipped SocketServicePrivate.
		{T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
		// Skipped StaticResource.
		// Skipped TaskClass.
		// Skipped TcpConnectionClass.
		// Skipped TcpConnectionPrivate.
		// Skipped TcpWrapperConnectionClass.
		// Skipped TcpWrapperConnectionPrivate.
		// Skipped ThemedIconClass.
		// Skipped ThreadedSocketServiceClass.
		// Skipped ThreadedSocketServicePrivate.
		// Skipped TlsBackendInterface.
		// Skipped TlsCertificateClass.
		// Skipped TlsCertificatePrivate.
		// Skipped TlsClientConnectionInterface.
		// Skipped TlsConnectionClass.
		// Skipped TlsConnectionPrivate.
		// Skipped TlsDatabaseClass.
		// Skipped TlsDatabasePrivate.
		// Skipped TlsFileDatabaseInterface.
		// Skipped TlsInteractionClass.
		// Skipped TlsInteractionPrivate.
		// Skipped TlsPasswordClass.
		// Skipped TlsPasswordPrivate.
		// Skipped TlsServerConnectionInterface.
		// Skipped UnixConnectionClass.
		// Skipped UnixConnectionPrivate.
		// Skipped UnixCredentialsMessageClass.
		// Skipped UnixCredentialsMessagePrivate.
		// Skipped UnixFDListClass.
		// Skipped UnixFDListPrivate.
		// Skipped UnixFDMessageClass.
		// Skipped UnixFDMessagePrivate.
		// Skipped UnixInputStreamClass.
		// Skipped UnixInputStreamPrivate.
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		// Skipped UnixMountMonitorClass.
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
		// Skipped UnixOutputStreamClass.
		// Skipped UnixOutputStreamPrivate.
		// Skipped UnixSocketAddressClass.
		// Skipped UnixSocketAddressPrivate.
		// Skipped VfsClass.
		// Skipped VolumeIface.
		// Skipped VolumeMonitorClass.
		// Skipped ZlibCompressorClass.
		// Skipped ZlibDecompressorClass.

		// Classes
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
		{T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
		{T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
		{T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
		{T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
		{T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
		{T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
		{T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
		{T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProxy},
		{T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProxy},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
		{T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
		{T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
		{T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
		{T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
		{T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
		{T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
		{T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
		{T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
		{T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
		{T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
		{T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
		{T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
		{T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
		// Skipped IOModule.
		{T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
		{T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
		{T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
		{T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
		{T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
		{T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
		{T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
		{T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
		{T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
		{T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProxyAddress},
		{T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProxyAddressEnumerator},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
		{T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProxyResolver},
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
		{T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
		{T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
		{T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
		{T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTcpConnection},
		{T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTcpWrapperConnection},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
		{T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
		{T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTlsCertificate},
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTlsConnection},
		{T: externglib.Type(C.g_tls_database_get_type()), F: marshalTlsDatabase},
		{T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTlsInteraction},
		{T: externglib.Type(C.g_tls_password_get_type()), F: marshalTlsPassword},
		{T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
		{T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
		{T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
		{T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
		{T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
		{T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
		{T: externglib.Type(C.g_vfs_get_type()), F: marshalVfs},
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
		{T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDbusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDbusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProxyFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProxyFailed IOErrorEnum = 40
	// IOErrorEnumProxyAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProxyAuthFailed IOErrorEnum = 41
	// IOErrorEnumProxyNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProxyNeedAuth IOErrorEnum = 42
	// IOErrorEnumProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProxyNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
//
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProxyNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProxyNegotiating SocketClientEvent = 4
	// SocketClientEventProxyNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProxyNegotiated SocketClientEvent = 5
	// SocketClientEventTlsHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTlsHandshaking SocketClientEvent = 6
	// SocketClientEventTlsHandshaked: the client has performed a TLS handshake.
	SocketClientEventTlsHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIpv4: the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6: the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp: TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp: UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp: SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsAuthenticationMode: the client authentication mode for a ServerConnection.
type TlsAuthenticationMode int

const (
	// TlsAuthenticationModeNone: client authentication not required
	TlsAuthenticationModeNone TlsAuthenticationMode = 0
	// TlsAuthenticationModeRequested: client authentication is requested
	TlsAuthenticationModeRequested TlsAuthenticationMode = 1
	// TlsAuthenticationModeRequired: client authentication is required
	TlsAuthenticationModeRequired TlsAuthenticationMode = 2
)

func marshalTlsAuthenticationMode(p uintptr) (interface{}, error) {
	return TlsAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TlsCertificateRequestFlags int

const (
	// TlsCertificateRequestFlagsNone: no flags
	TlsCertificateRequestFlagsNone TlsCertificateRequestFlags = 0
)

func marshalTlsCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TlsCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TlsChannelBindingError int

const (
	// TlsChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TlsChannelBindingErrorNotImplemented TlsChannelBindingError = 0
	// TlsChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TlsChannelBindingErrorInvalidState TlsChannelBindingError = 1
	// TlsChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TlsChannelBindingErrorNotAvailable TlsChannelBindingError = 2
	// TlsChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TlsChannelBindingErrorNotSupported TlsChannelBindingError = 3
	// TlsChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TlsChannelBindingErrorGeneralError TlsChannelBindingError = 4
)

func marshalTlsChannelBindingError(p uintptr) (interface{}, error) {
	return TlsChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// `tls-unique-for-telnet` (https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TlsChannelBindingType int

const (
	// TlsChannelBindingTypeUnique: `tls-unique`
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type
	TlsChannelBindingTypeUnique TlsChannelBindingType = 0
	// TlsChannelBindingTypeServerEndPoint: `tls-server-end-point`
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type
	TlsChannelBindingTypeServerEndPoint TlsChannelBindingType = 1
)

func marshalTlsChannelBindingType(p uintptr) (interface{}, error) {
	return TlsChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TlsDatabaseLookupFlags int

const (
	// TlsDatabaseLookupFlagsNone: no lookup flags
	TlsDatabaseLookupFlagsNone TlsDatabaseLookupFlags = 0
	// TlsDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TlsDatabaseLookupFlagsKeypair TlsDatabaseLookupFlags = 1
)

func marshalTlsDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TlsError int

const (
	// TlsErrorUnavailable: no TLS provider is available
	TlsErrorUnavailable TlsError = 0
	// TlsErrorMisc miscellaneous TLS error
	TlsErrorMisc TlsError = 1
	// TlsErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TlsErrorBadCertificate TlsError = 2
	// TlsErrorNotTls: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TlsErrorNotTls TlsError = 3
	// TlsErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TlsErrorHandshake TlsError = 4
	// TlsErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TlsErrorCertificateRequired TlsError = 5
	// TlsErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TlsErrorEOF TlsError = 6
	// TlsErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TlsErrorInappropriateFallback TlsError = 7
)

func marshalTlsError(p uintptr) (interface{}, error) {
	return TlsError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TlsInteractionResult int

const (
	// TlsInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TlsInteractionResultUnhandled TlsInteractionResult = 0
	// TlsInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TlsInteractionResultHandled TlsInteractionResult = 1
	// TlsInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TlsInteractionResultFailed TlsInteractionResult = 2
)

func marshalTlsInteractionResult(p uintptr) (interface{}, error) {
	return TlsInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TlsRehandshakeMode int

const (
	// TlsRehandshakeModeNever: never allow rehandshaking
	TlsRehandshakeModeNever TlsRehandshakeMode = 0
	// TlsRehandshakeModeSafely: allow safe rehandshaking only
	TlsRehandshakeModeSafely TlsRehandshakeMode = 1
	// TlsRehandshakeModeUnsafely: allow unsafe rehandshaking
	TlsRehandshakeModeUnsafely TlsRehandshakeMode = 2
)

func marshalTlsRehandshakeMode(p uintptr) (interface{}, error) {
	return TlsRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0b0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 0b10
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0b0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 0b1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 0b10
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 0b100
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 0b10000
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 0b100000
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags PasswordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 0b1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 0b10
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 0b100
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0b0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 0b1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags int

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the `PropertiesChanged`
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0b0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 0b1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 0b10
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 0b1000
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyFlagsTargetDefaultPerms leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0b0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 0b1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0b0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 0b10
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 0b100
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0b0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 0b1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 0b10
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0b0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags gIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0b0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags gOutputStreamSpliceFlags determine how streams should
// be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIpv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIpv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags gResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags gResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0b0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 0b1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 0b10
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0b0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 0b1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 0b10
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TlsCertificateFlags int

const (
	// TlsCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TlsCertificateFlagsUnknownCa TlsCertificateFlags = 0b1
	// TlsCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TlsCertificateFlagsBadIdentity TlsCertificateFlags = 0b10
	// TlsCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TlsCertificateFlagsNotActivated TlsCertificateFlags = 0b100
	// TlsCertificateFlagsExpired: the certificate has expired
	TlsCertificateFlagsExpired TlsCertificateFlags = 0b1000
	// TlsCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TlsCertificateFlagsRevoked TlsCertificateFlags = 0b10000
	// TlsCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TlsCertificateFlagsInsecure TlsCertificateFlags = 0b100000
	// TlsCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TlsCertificateFlagsGenericError TlsCertificateFlags = 0b1000000
	// TlsCertificateFlagsValidateAll: the combination of all of the above flags
	TlsCertificateFlagsValidateAll TlsCertificateFlags = 0b1111111
)

func marshalTlsCertificateFlags(p uintptr) (interface{}, error) {
	return TlsCertificateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TlsDatabaseVerifyFlags int

const (
	// TlsDatabaseVerifyFlagsNone: no verification flags
	TlsDatabaseVerifyFlagsNone TlsDatabaseVerifyFlags = 0b0
)

func marshalTlsDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TlsDatabaseVerifyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TlsPasswordFlags various flags for the password.
type TlsPasswordFlags int

const (
	// TlsPasswordFlagsNone: no flags
	TlsPasswordFlagsNone TlsPasswordFlags = 0b0
	// TlsPasswordFlagsRetry: the password was wrong, and the user should retry.
	TlsPasswordFlagsRetry TlsPasswordFlags = 0b10
	// TlsPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TlsPasswordFlagsManyTries TlsPasswordFlags = 0b100
	// TlsPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TlsPasswordFlagsFinalTry TlsPasswordFlags = 0b1000
)

func marshalTlsPasswordFlags(p uintptr) (interface{}, error) {
	return TlsPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
type AsyncReadyCallback func(sourceObject gextras.Objector, res AsyncResult)

//export gotk4_AsyncReadyCallback
func gotk4_AsyncReadyCallback(arg0 *C.GObject, arg1 *C.GAsyncResult, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var sourceObject *externglib.Object
	sourceObject = externglib.Take(unsafe.Pointer(arg0.Native()))

	var res AsyncResult

	v.(AsyncReadyCallback)(sourceObject, res)
}

// BusAcquiredCallback: invoked when a connection to a message bus has been
// obtained.
type BusAcquiredCallback func(connection DBusConnection, name string)

//export gotk4_BusAcquiredCallback
func gotk4_BusAcquiredCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var name string
	arg1 = C.GoString(name)
	defer C.free(unsafe.Pointer(arg1))

	v.(BusAcquiredCallback)(connection, name)
}

// BusNameAcquiredCallback: invoked when the name is acquired.
type BusNameAcquiredCallback func(connection DBusConnection, name string)

//export gotk4_BusNameAcquiredCallback
func gotk4_BusNameAcquiredCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var name string
	arg1 = C.GoString(name)
	defer C.free(unsafe.Pointer(arg1))

	v.(BusNameAcquiredCallback)(connection, name)
}

// BusNameAppearedCallback: invoked when the name being watched is known to have
// to have an owner.
type BusNameAppearedCallback func(connection DBusConnection, name string, nameOwner string)

//export gotk4_BusNameAppearedCallback
func gotk4_BusNameAppearedCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var name string
	arg1 = C.GoString(name)
	defer C.free(unsafe.Pointer(arg1))

	var nameOwner string
	arg2 = C.GoString(nameOwner)
	defer C.free(unsafe.Pointer(arg2))

	v.(BusNameAppearedCallback)(connection, name, nameOwner)
}

// BusNameLostCallback: invoked when the name is lost or @connection has been
// closed.
type BusNameLostCallback func(connection DBusConnection, name string)

//export gotk4_BusNameLostCallback
func gotk4_BusNameLostCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var name string
	arg1 = C.GoString(name)
	defer C.free(unsafe.Pointer(arg1))

	v.(BusNameLostCallback)(connection, name)
}

// BusNameVanishedCallback: invoked when the name being watched is known not to
// have to have an owner.
//
// This is also invoked when the BusConnection on which the watch was
// established has been closed. In that case, @connection will be nil.
type BusNameVanishedCallback func(connection DBusConnection, name string)

//export gotk4_BusNameVanishedCallback
func gotk4_BusNameVanishedCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var name string
	arg1 = C.GoString(name)
	defer C.free(unsafe.Pointer(arg1))

	v.(BusNameVanishedCallback)(connection, name)
}

// CancellableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_cancellable_source_new().
type CancellableSourceFunc func(cancellable Cancellable) bool

//export gotk4_CancellableSourceFunc
func gotk4_CancellableSourceFunc(arg0 *C.GCancellable, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var cancellable cancellable
	cancellable = gio.WrapCancellable(externglib.Take(unsafe.Pointer(arg0.Native())))

	ok := v.(CancellableSourceFunc)(cancellable)
}

// DBusInterfaceGetPropertyFunc: the type of the @get_property function in
// BusInterfaceVTable.
type DBusInterfaceGetPropertyFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, propertyName string, error **glib.Error) *glib.Variant

//export gotk4_DBusInterfaceGetPropertyFunc
func gotk4_DBusInterfaceGetPropertyFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 **C.GError, arg6 C.gpointer) *C.GVariant {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var interfaceName string
	arg3 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg3))

	var propertyName string
	arg4 = C.GoString(propertyName)
	defer C.free(unsafe.Pointer(arg4))

	var error **glib.Error
	error = glib.WrapError(arg5)

	variant := v.(DBusInterfaceGetPropertyFunc)(connection, sender, objectPath, interfaceName, propertyName, error)
}

// DBusInterfaceMethodCallFunc: the type of the @method_call function in
// BusInterfaceVTable.
type DBusInterfaceMethodCallFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, invocation DBusMethodInvocation)

//export gotk4_DBusInterfaceMethodCallFunc
func gotk4_DBusInterfaceMethodCallFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 *C.GDBusMethodInvocation, arg7 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg7))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var interfaceName string
	arg3 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg3))

	var methodName string
	arg4 = C.GoString(methodName)
	defer C.free(unsafe.Pointer(arg4))

	var parameters *glib.Variant
	parameters = glib.WrapVariant(arg5)

	var invocation dBusMethodInvocation
	invocation = gio.WrapDBusMethodInvocation(externglib.Take(unsafe.Pointer(arg6.Native())))

	v.(DBusInterfaceMethodCallFunc)(connection, sender, objectPath, interfaceName, methodName, parameters, invocation)
}

// DBusInterfaceSetPropertyFunc: the type of the @set_property function in
// BusInterfaceVTable.
type DBusInterfaceSetPropertyFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, propertyName string, value *glib.Variant, error **glib.Error) bool

//export gotk4_DBusInterfaceSetPropertyFunc
func gotk4_DBusInterfaceSetPropertyFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 **C.GError, arg7 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg7))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var interfaceName string
	arg3 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg3))

	var propertyName string
	arg4 = C.GoString(propertyName)
	defer C.free(unsafe.Pointer(arg4))

	var value *glib.Variant
	value = glib.WrapVariant(arg5)

	var error **glib.Error
	error = glib.WrapError(arg6)

	ok := v.(DBusInterfaceSetPropertyFunc)(connection, sender, objectPath, interfaceName, propertyName, value, error)
}

// DBusMessageFilterFunction: signature for function used in
// g_dbus_connection_add_filter().
//
// A filter function is passed a BusMessage and expected to return a BusMessage
// too. Passive filter functions that don't modify the message can simply return
// the @message object:
//
//
//    static GDBusMessage *
//    passive_filter (GDBusConnection *connection
//                    GDBusMessage    *message,
//                    gboolean         incoming,
//                    gpointer         user_data)
//    {
//      // inspect @message
//      return message;
//    }
//    ]|
//    Filter functions that wants to drop a message can simply return nil:
//    |[
//    static GDBusMessage *
//    drop_filter (GDBusConnection *connection
//                 GDBusMessage    *message,
//                 gboolean         incoming,
//                 gpointer         user_data)
//    {
//      if (should_drop_message)
//        {
//          g_object_unref (message);
//          message = NULL;
//        }
//      return message;
//    }
//    ]|
//    Finally, a filter function may modify a message by copying it:
//    |[
//    static GDBusMessage *
//    modifying_filter (GDBusConnection *connection
//                      GDBusMessage    *message,
//                      gboolean         incoming,
//                      gpointer         user_data)
//    {
//      GDBusMessage *copy;
//      GError *error;
//
//      error = NULL;
//      copy = g_dbus_message_copy (message, &error);
//      // handle @error being set
//      g_object_unref (message);
//
//      // modify @copy
//
//      return copy;
//    }
//
//
// If the returned BusMessage is different from @message and cannot be sent on
// @connection (it could use features, such as file descriptors, not compatible
// with @connection), then a warning is logged to standard error. Applications
// can check this ahead of time using g_dbus_message_to_blob() passing a
// BusCapabilityFlags value obtained from @connection.
type DBusMessageFilterFunction func(connection DBusConnection, message DBusMessage, incoming bool) DBusMessage

//export gotk4_DBusMessageFilterFunction
func gotk4_DBusMessageFilterFunction(arg0 *C.GDBusConnection, arg1 *C.GDBusMessage, arg2 C.gboolean, arg3 C.gpointer) *C.GDBusMessage {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var message dBusMessage
	message = gio.WrapDBusMessage(externglib.Take(unsafe.Pointer(arg1.Native())))

	var incoming bool
	incoming = gextras.Gobool(arg2)

	dBusMessage := v.(DBusMessageFilterFunction)(connection, message, incoming)
}

// DBusProxyTypeFunc: function signature for a function used to determine the
// #GType to use for an interface proxy (if @interface_name is not nil) or
// object proxy (if @interface_name is nil).
//
// This function is called in the [thread-default main
// loop][g-main-context-push-thread-default] that @manager was constructed in.
type DBusProxyTypeFunc func(manager DBusObjectManagerClient, objectPath string, interfaceName string) externglib.Type

//export gotk4_DBusProxyTypeFunc
func gotk4_DBusProxyTypeFunc(arg0 *C.GDBusObjectManagerClient, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) C.GType {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var manager dBusObjectManagerClient
	manager = gio.WrapDBusObjectManagerClient(externglib.Take(unsafe.Pointer(arg0.Native())))

	var objectPath string
	arg1 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg1))

	var interfaceName string
	arg2 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg2))

	gType := v.(DBusProxyTypeFunc)(manager, objectPath, interfaceName)
}

// DBusSignalCallback: signature for callback function used in
// g_dbus_connection_signal_subscribe().
type DBusSignalCallback func(connection DBusConnection, senderName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant)

//export gotk4_DBusSignalCallback
func gotk4_DBusSignalCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var senderName string
	arg1 = C.GoString(senderName)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var interfaceName string
	arg3 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg3))

	var signalName string
	arg4 = C.GoString(signalName)
	defer C.free(unsafe.Pointer(arg4))

	var parameters *glib.Variant
	parameters = glib.WrapVariant(arg5)

	v.(DBusSignalCallback)(connection, senderName, objectPath, interfaceName, signalName, parameters)
}

// DBusSubtreeDispatchFunc: the type of the @dispatch function in
// BusSubtreeVTable.
//
// Subtrees are flat. @node, if non-nil, is always exactly one segment of the
// object path (ie: it never contains a slash).
type DBusSubtreeDispatchFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, node string, outUserData interface{}) *DBusInterfaceVTable

//export gotk4_DBusSubtreeDispatchFunc
func gotk4_DBusSubtreeDispatchFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.gpointer, arg6 C.gpointer) *C.GDBusInterfaceVTable {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var interfaceName string
	arg3 = C.GoString(interfaceName)
	defer C.free(unsafe.Pointer(arg3))

	var node string
	arg4 = C.GoString(node)
	defer C.free(unsafe.Pointer(arg4))

	var outUserData interface{}
	outUserData = box.Get(uintptr(arg5))

	dBusInterfaceVTable := v.(DBusSubtreeDispatchFunc)(connection, sender, objectPath, interfaceName, node, outUserData)
}

// DBusSubtreeEnumerateFunc: the type of the @enumerate function in
// BusSubtreeVTable.
//
// This function is called when generating introspection data and also when
// preparing to dispatch incoming messages in the event that the
// G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not specified
// (ie: to verify that the object path is valid).
//
// Hierarchies are not supported; the items that you return should not contain
// the '/' character.
//
// The return value will be freed with g_strfreev().
type DBusSubtreeEnumerateFunc func(connection DBusConnection, sender string, objectPath string) []string

//export gotk4_DBusSubtreeEnumerateFunc
func gotk4_DBusSubtreeEnumerateFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) **C.gchar {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	utf8s := v.(DBusSubtreeEnumerateFunc)(connection, sender, objectPath)
}

// DBusSubtreeIntrospectFunc: the type of the @introspect function in
// BusSubtreeVTable.
//
// Subtrees are flat. @node, if non-nil, is always exactly one segment of the
// object path (ie: it never contains a slash).
//
// This function should return nil to indicate that there is no object at this
// node.
//
// If this function returns non-nil, the return value is expected to be a
// nil-terminated array of pointers to BusInterfaceInfo structures describing
// the interfaces implemented by @node. This array will have
// g_dbus_interface_info_unref() called on each item before being freed with
// g_free().
//
// The difference between returning nil and an array containing zero items is
// that the standard DBus interfaces will returned to the remote introspector in
// the empty array case, but not in the nil case.
type DBusSubtreeIntrospectFunc func(connection DBusConnection, sender string, objectPath string, node string) **DBusInterfaceInfo

//export gotk4_DBusSubtreeIntrospectFunc
func gotk4_DBusSubtreeIntrospectFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 C.gpointer) **C.GDBusInterfaceInfo {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var connection dBusConnection
	connection = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	var sender string
	arg1 = C.GoString(sender)
	defer C.free(unsafe.Pointer(arg1))

	var objectPath string
	arg2 = C.GoString(objectPath)
	defer C.free(unsafe.Pointer(arg2))

	var node string
	arg3 = C.GoString(node)
	defer C.free(unsafe.Pointer(arg3))

	dBusInterfaceInfo := v.(DBusSubtreeIntrospectFunc)(connection, sender, objectPath, node)
}

// DatagramBasedSourceFunc: this is the function type of the callback used for
// the #GSource returned by g_datagram_based_create_source().
type DatagramBasedSourceFunc func(datagramBased DatagramBased, condition glib.IOCondition) bool

//export gotk4_DatagramBasedSourceFunc
func gotk4_DatagramBasedSourceFunc(arg0 *C.GDatagramBased, arg1 C.GIOCondition, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var datagramBased DatagramBased

	var condition glib.IOCondition
	condition = glib.IOCondition(arg1)

	ok := v.(DatagramBasedSourceFunc)(datagramBased, condition)
}

// DesktopAppLaunchCallback: during invocation,
// g_desktop_app_info_launch_uris_as_manager() may create one or more child
// processes. This callback is invoked once for each, providing the process ID.
type DesktopAppLaunchCallback func(appinfo DesktopAppInfo, pid glib.Pid)

//export gotk4_DesktopAppLaunchCallback
func gotk4_DesktopAppLaunchCallback(arg0 *C.GDesktopAppInfo, arg1 C.GPid, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var appinfo desktopAppInfo
	appinfo = gio.WrapDesktopAppInfo(externglib.Take(unsafe.Pointer(arg0.Native())))

	var pid glib.Pid
	{
		var tmp int
		tmp = int(arg1)
		pid = glib.Pid(tmp)
	}

	v.(DesktopAppLaunchCallback)(appinfo, pid)
}

// FileMeasureProgressCallback: this callback type is used by
// g_file_measure_disk_usage() to make periodic progress reports when measuring
// the amount of disk spaced used by a directory.
//
// These calls are made on a best-effort basis and not all types of #GFile will
// support them. At the minimum, however, one call will always be made
// immediately.
//
// In the case that there is no support, @reporting will be set to false (and
// the other values undefined) and no further calls will be made. Otherwise, the
// @reporting will be true and the other values all-zeros during the first
// (immediate) call. In this way, you can know which type of progress UI to show
// without a delay.
//
// For g_file_measure_disk_usage() the callback is made directly. For
// g_file_measure_disk_usage_async() the callback is made via the default main
// context of the calling thread (ie: the same way that the final async result
// would be reported).
//
// @current_size is in the same units as requested by the operation (see
// G_FILE_MEASURE_APPARENT_SIZE).
//
// The frequency of the updates is implementation defined, but is ideally about
// once every 200ms.
//
// The last progress callback may or may not be equal to the final result.
// Always check the async result to get the final value.
type FileMeasureProgressCallback func(reporting bool, currentSize uint64, numDirs uint64, numFiles uint64)

//export gotk4_FileMeasureProgressCallback
func gotk4_FileMeasureProgressCallback(arg0 C.gboolean, arg1 C.guint64, arg2 C.guint64, arg3 C.guint64, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var reporting bool
	reporting = gextras.Gobool(arg0)

	var currentSize uint64
	currentSize = uint64(arg1)

	var numDirs uint64
	numDirs = uint64(arg2)

	var numFiles uint64
	numFiles = uint64(arg3)

	v.(FileMeasureProgressCallback)(reporting, currentSize, numDirs, numFiles)
}

// FileProgressCallback: when doing file operations that may take a while, such
// as moving a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(currentNumBytes int64, totalNumBytes int64)

//export gotk4_FileProgressCallback
func gotk4_FileProgressCallback(arg0 C.goffset, arg1 C.goffset, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var currentNumBytes int64
	currentNumBytes = int64(arg0)

	var totalNumBytes int64
	totalNumBytes = int64(arg1)

	v.(FileProgressCallback)(currentNumBytes, totalNumBytes)
}

// FileReadMoreCallback: when loading the partial contents of a file with
// g_file_load_partial_contents_async(), it may become necessary to determine if
// any more data from the file should be loaded. A ReadMoreCallback function
// facilitates this by returning true if more data should be read, or false
// otherwise.
type FileReadMoreCallback func(fileContents string, fileSize int64) bool

//export gotk4_FileReadMoreCallback
func gotk4_FileReadMoreCallback(arg0 *C.char, arg1 C.goffset, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var fileContents string
	arg0 = C.GoString(fileContents)
	defer C.free(unsafe.Pointer(arg0))

	var fileSize int64
	fileSize = int64(arg1)

	ok := v.(FileReadMoreCallback)(fileContents, fileSize)
}

// IOSchedulerJobFunc: i/O Job function.
//
// Long-running jobs should periodically check the @cancellable to see if they
// have been cancelled.
type IOSchedulerJobFunc func(job *IOSchedulerJob, cancellable Cancellable) bool

//export gotk4_IOSchedulerJobFunc
func gotk4_IOSchedulerJobFunc(arg0 *C.GIOSchedulerJob, arg1 *C.GCancellable, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var job *IOSchedulerJob
	job = gio.WrapIOSchedulerJob(arg0)

	var cancellable cancellable
	cancellable = gio.WrapCancellable(externglib.Take(unsafe.Pointer(arg1.Native())))

	ok := v.(IOSchedulerJobFunc)(job, cancellable)
}

// PollableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_pollable_input_stream_create_source() and
// g_pollable_output_stream_create_source().
type PollableSourceFunc func(pollableStream gextras.Objector) bool

//export gotk4_PollableSourceFunc
func gotk4_PollableSourceFunc(arg0 *C.GObject, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var pollableStream *externglib.Object
	pollableStream = externglib.Take(unsafe.Pointer(arg0.Native()))

	ok := v.(PollableSourceFunc)(pollableStream)
}

// SettingsBindGetMapping: the type for the function that is used to convert
// from #GSettings to an object property. The @value is already initialized to
// hold values of the appropriate type.
type SettingsBindGetMapping func(value *externglib.Value, variant *glib.Variant) bool

//export gotk4_SettingsBindGetMapping
func gotk4_SettingsBindGetMapping(arg0 *C.GValue, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *externglib.Value

	var variant *glib.Variant
	variant = glib.WrapVariant(arg1)

	ok := v.(SettingsBindGetMapping)(value, variant)
}

// SettingsBindSetMapping: the type for the function that is used to convert an
// object property value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func(value *externglib.Value, expectedType *glib.VariantType) *glib.Variant

//export gotk4_SettingsBindSetMapping
func gotk4_SettingsBindSetMapping(arg0 *C.GValue, arg1 *C.GVariantType, arg2 C.gpointer) *C.GVariant {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *externglib.Value

	var expectedType *glib.VariantType
	expectedType = glib.WrapVariantType(arg1)

	variant := v.(SettingsBindSetMapping)(value, expectedType)
}

// SettingsGetMapping: the type of the function that is used to convert from a
// value stored in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at @result
// and true returned. If mapping fails (for example, if @value is not in the
// right format) then false should be returned.
//
// If @value is nil then it means that the mapping function is being given a
// "last chance" to successfully return a valid value. true must be returned in
// this case.
type SettingsGetMapping func(value *glib.Variant) (result interface{}, ok bool)

//export gotk4_SettingsGetMapping
func gotk4_SettingsGetMapping(arg0 *C.GVariant, arg1 *C.gpointer, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *glib.Variant
	value = glib.WrapVariant(arg0)

	result, ok := v.(SettingsGetMapping)(value)
}

// SocketSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_socket_create_source().
type SocketSourceFunc func(socket Socket, condition glib.IOCondition) bool

//export gotk4_SocketSourceFunc
func gotk4_SocketSourceFunc(arg0 *C.GSocket, arg1 C.GIOCondition, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var socket socket
	socket = gio.WrapSocket(externglib.Take(unsafe.Pointer(arg0.Native())))

	var condition glib.IOCondition
	condition = glib.IOCondition(arg1)

	ok := v.(SocketSourceFunc)(socket, condition)
}

// VfsFileLookupFunc: this function type is used by g_vfs_register_uri_scheme()
// to make it possible for a client to associate an URI scheme to a different
// #GFile implementation.
//
// The client should return a reference to the new file that has been created
// for @uri, or nil to continue with the default implementation.
type VfsFileLookupFunc func(vfs Vfs, identifier string) File

//export gotk4_VfsFileLookupFunc
func gotk4_VfsFileLookupFunc(arg0 *C.GVfs, arg1 *C.char, arg2 C.gpointer) *C.GFile {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var vfs vfs
	vfs = gio.WrapVfs(externglib.Take(unsafe.Pointer(arg0.Native())))

	var identifier string
	arg1 = C.GoString(identifier)
	defer C.free(unsafe.Pointer(arg1))

	file := v.(VfsFileLookupFunc)(vfs, identifier)
}

// ActionNameIsValid checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters, plus
// '-' and '.'. The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 @action_name.
// @action_name must not be nil.
func ActionNameIsValid(actionName string) bool {
	var arg0 string
	actionName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(actionName))

	ret := C.g_action_name_is_valid(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ActionParseDetailedName parses a detailed action name into its separate name
// and target components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target value and
// consists of just an action name containing no whitespace nor the characters
// ':', '(' or ')'. For example: "app.action".
//
// The second format is used to represent an action with a target value that is
// a non-empty string consisting only of alphanumerics, plus '-' and '.'. In
// that case, the action name and target value are separated by a double colon
// ("::"). For example: "app.action::target".
//
// The third format is used to represent an action with any type of target
// value, including strings. The target value follows the action name,
// surrounded in parens. For example: "app.action(42)". The target value is
// parsed using g_variant_parse(). If a tuple-typed value is desired, it must be
// specified in the same way, resulting in two sets of parens, for example:
// "app.action((1,2,3))". A string target can be specified this way as well:
// "app.action('target')". For strings, this third format must be used if *
// target value is empty or contains characters other than alphanumerics, '-'
// and '.'.
func ActionParseDetailedName(detailedName string) (actionName string, targetValue *glib.Variant, ok bool) {
	var arg0 string
	detailedName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(detailedName))

	var arg1 **C.gchar // out

	var arg2 **C.GVariant // out

	ret := C.g_action_parse_detailed_name(arg0, &arg1, &arg2)

	var ret0 string
	arg1 = C.GoString(ret0)
	defer C.free(unsafe.Pointer(arg1))

	var ret1 **glib.Variant
	ret1 = glib.WrapVariant(arg2)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ActionPrintDetailedName formats a detailed action name from @action_name and
// @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name(). It will
// produce a string that can be parsed back to the @action_name and
// @target_value by that function.
//
// See that function for the types of strings that will be printed by this
// function.
func ActionPrintDetailedName(actionName string, targetValue *glib.Variant) string {
	var arg0 string
	actionName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(actionName))

	var arg1 *glib.Variant
	arg1 = glib.WrapVariant(targetValue)

	ret := C.g_action_print_detailed_name(arg0, arg1)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// AppInfoCreateFromCommandline creates a new Info from the given information.
//
// Note that for @commandline, the quoting rules of the Exec key of the
// freedesktop.org Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec) are applied. For
// example, if the @commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) AppInfo {
	var arg0 string
	commandline = C.GoString(arg0)
	defer C.free(unsafe.Pointer(commandline))

	var arg1 string
	applicationName = C.GoString(arg1)
	defer C.free(unsafe.Pointer(applicationName))

	var arg2 AppInfoCreateFlags
	arg2 = AppInfoCreateFlags(flags)

	ret := C.g_app_info_create_from_commandline(arg0, arg1, arg2)

	var ret0 AppInfo

	return ret0
}

// AppInfoGetAll gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have `NoDisplay=true` set
// or are excluded from display by means of `OnlyShowIn` or `NotShowIn`. See
// g_app_info_should_show(). The returned list does not include applications
// which have the `Hidden` key set.
func AppInfoGetAll() *glib.List {
	ret := C.g_app_info_get_all()

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetAllForType gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
func AppInfoGetAllForType(contentType string) *glib.List {
	var arg0 string
	contentType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(contentType))

	ret := C.g_app_info_get_all_for_type(arg0)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetDefaultForType gets the default Info for a given content type.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfo {
	var arg0 string
	contentType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(contentType))

	var arg1 bool
	arg1 = gextras.Gobool(mustSupportUris)

	ret := C.g_app_info_get_default_for_type(arg0, arg1)

	var ret0 AppInfo

	return ret0
}

// AppInfoGetDefaultForURIScheme gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI, up to
// but not including the ':', e.g. "http", "ftp" or "sip".
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfo {
	var arg0 string
	uriScheme = C.GoString(arg0)
	defer C.free(unsafe.Pointer(uriScheme))

	ret := C.g_app_info_get_default_for_uri_scheme(arg0)

	var ret0 AppInfo

	return ret0
}

// AppInfoGetFallbackForType gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
func AppInfoGetFallbackForType(contentType string) *glib.List {
	var arg0 string
	contentType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(contentType))

	ret := C.g_app_info_get_fallback_for_type(arg0)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetRecommendedForType gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
func AppInfoGetRecommendedForType(contentType string) *glib.List {
	var arg0 string
	contentType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(contentType))

	ret := C.g_app_info_get_recommended_for_type(arg0)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Bus–activated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
func AppInfoLaunchDefaultForURI(uri string, context AppLaunchContext) bool {
	var arg0 string
	uri = C.GoString(arg0)
	defer C.free(unsafe.Pointer(uri))

	var arg1 AppLaunchContext
	arg1 = gio.WrapAppLaunchContext(externglib.Take(unsafe.Pointer(context.Native())))

	ret := C.g_app_info_launch_default_for_uri(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Bus–activated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForURIAsync(uri string, context AppLaunchContext, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 string
	uri = C.GoString(arg0)
	defer C.free(unsafe.Pointer(uri))

	var arg1 AppLaunchContext
	arg1 = gio.WrapAppLaunchContext(externglib.Take(unsafe.Pointer(context.Native())))

	var arg2 Cancellable
	arg2 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	arg4 := C.gpointer(box.Assign(box.Callback, userData))
	C.g_app_info_launch_default_for_uri_async(arg0, arg1, arg2)
}

// AppInfoLaunchDefaultForURIFinish finishes an asynchronous
// launch-default-for-uri operation.
func AppInfoLaunchDefaultForURIFinish(result AsyncResult) bool {
	ret := C.g_app_info_launch_default_for_uri_finish()

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// AppInfoResetTypeAssociations removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
func AppInfoResetTypeAssociations(contentType string) {
	var arg0 string
	contentType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(contentType))

	C.g_app_info_reset_type_associations(arg0)
}

// BusGet: asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can then call
// g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for the
// synchronous version.
func BusGet(busType BusType, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 Cancellable
	arg1 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	arg3 := C.gpointer(box.Assign(box.Callback, userData))
	C.g_bus_get(arg0, arg1)
}

// BusGetFinish finishes an operation started with g_bus_get().
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetFinish(res AsyncResult) DBusConnection {
	ret := C.g_bus_get_finish()

	var ret0 DBusConnection
	ret0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetSync(busType BusType, cancellable Cancellable) DBusConnection {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 Cancellable
	arg1 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_bus_get_sync(arg0, arg1)

	var ret0 DBusConnection
	ret0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// BusOwnName starts acquiring @name on the bus specified by @bus_type and calls
// @name_acquired_handler and @name_lost_handler when the name is acquired
// respectively lost. Callbacks will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the @name_acquired_handler and
// @name_lost_handler callbacks will be invoked after calling this function -
// there are three possible cases:
//
// - @name_lost_handler with a nil connection (if a connection to the bus can't
// be made).
//
// - @bus_acquired_handler then @name_lost_handler (if the name can't be
// obtained)
//
// - @bus_acquired_handler then @name_acquired_handler (if the name was
// obtained).
//
// When you are done owning the name, just call g_bus_unown_name() with the
// owner id this function returns.
//
// If the name is acquired or lost (for example another application could
// acquire the name if you allow replacement or the application currently owning
// the name exits), the handlers are also invoked. If the BusConnection that is
// used for attempting to own the name closes, then @name_lost_handler is
// invoked since it is no longer possible for other processes to access the
// process.
//
// You cannot use g_bus_own_name() several times for the same name (unless
// interleaved with calls to g_bus_unown_name()) - only the first call will
// work.
//
// Another guarantee is that invocations of @name_acquired_handler and
// @name_lost_handler are guaranteed to alternate; that is, if
// @name_acquired_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_lost_handler. The reverse is
// also true.
//
// If you plan on exporting objects (using e.g.
// g_dbus_connection_register_object()), note that it is generally too late to
// export the objects in @name_acquired_handler. Instead, you can do this in
// @bus_acquired_handler since you are guaranteed that this will run before
// @name is requested from the bus.
//
// This behavior makes it very simple to write applications that wants to [own
// names][gdbus-owning-names] and export objects. Simply register objects to be
// exported in @bus_acquired_handler and unregister the objects (if any) in
// @name_lost_handler.
func BusOwnName(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredHandler BusAcquiredCallback, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback) uint {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameOwnerFlags
	arg2 = BusNameOwnerFlags(flags)

	arg6 := C.gpointer(box.Assign(box.Callback, userData))
	ret := C.g_bus_own_name(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusOwnNameOnConnection: like g_bus_own_name() but takes a BusConnection
// instead of a Type.
func BusOwnNameOnConnection(connection DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredHandler BusNameAcquiredCallback, nameLostHandler BusNameLostCallback) uint {
	var arg0 DBusConnection
	arg0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(connection.Native())))

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameOwnerFlags
	arg2 = BusNameOwnerFlags(flags)

	arg5 := C.gpointer(box.Assign(box.Callback, userData))
	ret := C.g_bus_own_name_on_connection(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusOwnNameOnConnectionWithClosures: version of g_bus_own_name_on_connection()
// using closures instead of callbacks for easier binding in other languages.
func BusOwnNameOnConnectionWithClosures(connection DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint {
	var arg0 DBusConnection
	arg0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(connection.Native())))

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameOwnerFlags
	arg2 = BusNameOwnerFlags(flags)

	ret := C.g_bus_own_name_on_connection_with_closures(arg0, arg1, arg2)

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusOwnNameWithClosures: version of g_bus_own_name() using closures instead of
// callbacks for easier binding in other languages.
func BusOwnNameWithClosures(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredClosure *externglib.Closure, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameOwnerFlags
	arg2 = BusNameOwnerFlags(flags)

	ret := C.g_bus_own_name_with_closures(arg0, arg1, arg2)

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusUnownName stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after it’s stopped being iterated.
func BusUnownName(ownerID uint) {
	var arg0 uint
	arg0 = uint(ownerID)

	C.g_bus_unown_name(arg0)
}

// BusUnwatchName stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after it’s stopped being
// iterated.
func BusUnwatchName(watcherID uint) {
	var arg0 uint
	arg0 = uint(watcherID)

	C.g_bus_unwatch_name(arg0)
}

// BusWatchName starts watching @name on the bus specified by @bus_type and
// calls @name_appeared_handler and @name_vanished_handler when the name is
// known to have an owner respectively known to lose its owner. Callbacks will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this function from.
//
// You are guaranteed that one of the handlers will be invoked after calling
// this function. When you are done watching the name, just call
// g_bus_unwatch_name() with the watcher id this function returns.
//
// If the name vanishes or appears (for example the application owning the name
// could restart), the handlers are also invoked. If the BusConnection that is
// used for watching the name disconnects, then @name_vanished_handler is
// invoked since it is no longer possible to access the name.
//
// Another guarantee is that invocations of @name_appeared_handler and
// @name_vanished_handler are guaranteed to alternate; that is, if
// @name_appeared_handler is invoked then you are guaranteed that the next time
// one of the handlers is invoked, it will be @name_vanished_handler. The
// reverse is also true.
//
// This behavior makes it very simple to write applications that want to take
// action when a certain [name exists][gdbus-watching-names]. Basically, the
// application should create object proxies in @name_appeared_handler and
// destroy them again (if any) in @name_vanished_handler.
func BusWatchName(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback) uint {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameWatcherFlags
	arg2 = BusNameWatcherFlags(flags)

	arg5 := C.gpointer(box.Assign(box.Callback, userData))
	ret := C.g_bus_watch_name(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusWatchNameOnConnection: like g_bus_watch_name() but takes a BusConnection
// instead of a Type.
func BusWatchNameOnConnection(connection DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedHandler BusNameAppearedCallback, nameVanishedHandler BusNameVanishedCallback) uint {
	var arg0 DBusConnection
	arg0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(connection.Native())))

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameWatcherFlags
	arg2 = BusNameWatcherFlags(flags)

	arg5 := C.gpointer(box.Assign(box.Callback, userData))
	ret := C.g_bus_watch_name_on_connection(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete))

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusWatchNameOnConnectionWithClosures: version of
// g_bus_watch_name_on_connection() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameOnConnectionWithClosures(connection DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint {
	var arg0 DBusConnection
	arg0 = gio.WrapDBusConnection(externglib.Take(unsafe.Pointer(connection.Native())))

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameWatcherFlags
	arg2 = BusNameWatcherFlags(flags)

	ret := C.g_bus_watch_name_on_connection_with_closures(arg0, arg1, arg2)

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// BusWatchNameWithClosures: version of g_bus_watch_name() using closures
// instead of callbacks for easier binding in other languages.
func BusWatchNameWithClosures(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	var arg2 BusNameWatcherFlags
	arg2 = BusNameWatcherFlags(flags)

	ret := C.g_bus_watch_name_with_closures(arg0, arg1, arg2)

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// ContentTypeCanBeExecutable checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(_type string) bool {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_can_be_executable(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeEquals compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool {
	var arg0 string
	type1 = C.GoString(arg0)
	defer C.free(unsafe.Pointer(type1))

	var arg1 string
	type2 = C.GoString(arg1)
	defer C.free(unsafe.Pointer(type2))

	ret := C.g_content_type_equals(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
func ContentTypeFromMIMEType(mimeType string) string {
	var arg0 string
	mimeType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(mimeType))

	ret := C.g_content_type_from_mime_type(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetDescription gets the human readable description of the content
// type.
func ContentTypeGetDescription(_type string) string {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_get_description(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetGenericIconName gets the generic icon name for a content type.
//
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(_type string) string {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_get_generic_icon_name(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetIcon gets the icon for a content type.
func ContentTypeGetIcon(_type string) Icon {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_get_icon(arg0)

	var ret0 Icon

	return ret0
}

// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMIMEDirs() []string {
	ret := C.g_content_type_get_mime_dirs()

	var ret0 []string
	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			src = C.GoString(ret0[i])
			defer C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMIMEType(_type string) string {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_get_mime_type(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetSymbolicIcon gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(_type string) Icon {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_get_symbolic_icon(arg0)

	var ret0 Icon

	return ret0
}

// ContentTypeGuess guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []uint8) (resultUncertain bool, utf8 string) {
	var arg0 string
	filename = C.GoString(arg0)
	defer C.free(unsafe.Pointer(filename))

	var arg1 []uint8
	{
		arg1 = make([]uint8, a)
		for i := 0; i < uintptr(a); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			arg1[i] = uint8(src)
		}
	}

	var arg3 *C.gboolean // out

	ret := C.g_content_type_guess(arg0, arg1, &arg3)

	var ret0 bool
	ret0 = gextras.Gobool(arg3)

	var ret1 string
	ret = C.GoString(ret1)
	defer C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// ContentTypeGuessForTree tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string {
	ret := C.g_content_type_guess_for_tree()

	var ret0 []string
	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			src = C.GoString(ret0[i])
			defer C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ContentTypeIsA determines if @type is a subset of @supertype.
func ContentTypeIsA(_type string, supertype string) bool {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	var arg1 string
	supertype = C.GoString(arg1)
	defer C.free(unsafe.Pointer(supertype))

	ret := C.g_content_type_is_a(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeIsMIMEType determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMIMEType(_type string, mimeType string) bool {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	var arg1 string
	mimeType = C.GoString(arg1)
	defer C.free(unsafe.Pointer(mimeType))

	ret := C.g_content_type_is_mime_type(arg0, arg1)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(_type string) bool {
	var arg0 string
	_type = C.GoString(arg0)
	defer C.free(unsafe.Pointer(_type))

	ret := C.g_content_type_is_unknown(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
//    - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//    - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the system’s MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      …
//
//      return g_test_run ();
//
func ContentTypeSetMIMEDirs(dirs []string) {
	var arg0 []string
	{
		var length uint
		for p := unsafe.Pointer(dirs); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		arg0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(dirs)) + i))
			src = C.GoString(arg0[i])
			defer C.free(unsafe.Pointer(src))
		}
	}

	C.g_content_type_set_mime_dirs(arg0)
}

// ContentTypesGetRegistered gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() *glib.List {
	ret := C.g_content_types_get_registered()

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// DbusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
func DbusAddressEscapeValue(string string) string {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_address_escape_value(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
//
// The returned address will be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusAddressGetForBusSync(busType BusType, cancellable Cancellable) string {
	var arg0 BusType
	arg0 = BusType(busType)

	var arg1 Cancellable
	arg1 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_dbus_address_get_for_bus_sync(arg0, arg1)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusAddressGetStream: asynchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, @callback will be invoked. You can then call
// g_dbus_address_get_stream_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DbusAddressGetStream(address string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 string
	address = C.GoString(arg0)
	defer C.free(unsafe.Pointer(address))

	var arg1 Cancellable
	arg1 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	arg3 := C.gpointer(box.Assign(box.Callback, userData))
	C.g_dbus_address_get_stream(arg0, arg1)
}

// DbusAddressGetStreamFinish finishes an operation started with
// g_dbus_address_get_stream().
func DbusAddressGetStreamFinish(res AsyncResult) (outGuid string, ioStream IOStream) {
	var arg1 **C.gchar // out

	ret := C.g_dbus_address_get_stream_finish(&arg1)

	var ret0 string
	arg1 = C.GoString(ret0)
	defer C.free(unsafe.Pointer(arg1))

	var ret1 IOStream
	ret1 = gio.WrapIOStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// DbusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
func DbusAddressGetStreamSync(address string, cancellable Cancellable) (outGuid string, ioStream IOStream) {
	var arg0 string
	address = C.GoString(arg0)
	defer C.free(unsafe.Pointer(address))

	var arg1 **C.gchar // out

	var arg2 Cancellable
	arg2 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_dbus_address_get_stream_sync(arg0, &arg1, arg2)

	var ret0 string
	arg1 = C.GoString(ret0)
	defer C.free(unsafe.Pointer(arg1))

	var ret1 IOStream
	ret1 = gio.WrapIOStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// DbusAnnotationInfoLookup looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
func DbusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string {
	var arg0 []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		arg0 = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(annotations)) + i))
			arg0[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	var arg1 string
	name = C.GoString(arg1)
	defer C.free(unsafe.Pointer(name))

	ret := C.g_dbus_annotation_info_lookup(arg0, arg1)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusErrorEncodeGerror creates a D-Bus error name to use for @error. If @error
// matches a registered error (cf. g_dbus_error_register_error()), the
// corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE` will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
func DbusErrorEncodeGerror(error *glib.Error) string {
	var arg0 *glib.Error
	arg0 = glib.WrapError(error)

	ret := C.g_dbus_error_encode_gerror(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusErrorGetRemoteError gets the D-Bus error name used for @error, if any.
//
// This function is guaranteed to return a D-Bus error name for all #GErrors
// returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on @error.
func DbusErrorGetRemoteError(error *glib.Error) string {
	var arg0 *glib.Error
	arg0 = glib.WrapError(error)

	ret := C.g_dbus_error_get_remote_error(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusErrorIsRemoteError checks if @error represents an error received via
// D-Bus from a remote peer. If so, use g_dbus_error_get_remote_error() to get
// the name of the error.
func DbusErrorIsRemoteError(error *glib.Error) bool {
	var arg0 *glib.Error
	arg0 = glib.WrapError(error)

	ret := C.g_dbus_error_is_remote_error(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusErrorNewForDbusError creates a #GError based on the contents of
// @dbus_error_name and @dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up using
// @dbus_error_name and if a match is found, the error domain and code is used.
// Applications can use g_dbus_error_get_remote_error() to recover
// @dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error name
// is in a form as returned by g_dbus_error_encode_gerror() the error domain and
// code encoded in the name is used to create the #GError. Also,
// @dbus_error_name is added to the error message such that it can be recovered
// with g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in the
// IO_ERROR error domain is returned. Also, @dbus_error_name is added to the
// error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, @dbus_error_name can always be recovered from the
// returned #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
func DbusErrorNewForDbusError(dbusErrorName string, dbusErrorMessage string) *glib.Error {
	var arg0 string
	dbusErrorName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(dbusErrorName))

	var arg1 string
	dbusErrorMessage = C.GoString(arg1)
	defer C.free(unsafe.Pointer(dbusErrorMessage))

	ret := C.g_dbus_error_new_for_dbus_error(arg0, arg1)

	var ret0 *glib.Error
	ret0 = glib.WrapError(ret)

	return ret0
}

func DbusErrorQuark() glib.Quark {
	ret := C.g_dbus_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// DbusErrorRegisterError creates an association to map between @dbus_error_name
// and #GErrors specified by @error_domain and @error_code.
//
// This is typically done in the routine that returns the #GQuark for an error
// domain.
func DbusErrorRegisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool {
	var arg0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(errorDomain)
		arg0 = glib.Quark(tmp)
	}

	var arg1 int
	arg1 = int(errorCode)

	var arg2 string
	dbusErrorName = C.GoString(arg2)
	defer C.free(unsafe.Pointer(dbusErrorName))

	ret := C.g_dbus_error_register_error(arg0, arg1, arg2)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusErrorRegisterErrorDomain: helper function for associating a #GError error
// domain with D-Bus error names.
func DbusErrorRegisterErrorDomain(errorDomainQuarkName string, quarkVolatile uint, entries []DBusErrorEntry) {
	var arg0 string
	errorDomainQuarkName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(errorDomainQuarkName))

	var arg1 uint
	arg1 = uint(quarkVolatile)

	var arg2 []DBusErrorEntry
	{
		arg2 = make([]DBusErrorEntry, a)
		for i := 0; i < uintptr(a); i++ {
			src := (C.GDBusErrorEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			arg2[i] = gio.WrapDBusErrorEntry(src)
		}
	}

	C.g_dbus_error_register_error_domain(arg0, arg1, arg2)
}

// DbusErrorStripRemoteError looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped, the
// message field in @error will correspond exactly to what was received on the
// wire.
//
// This is typically used when presenting errors to the end user.
func DbusErrorStripRemoteError(error *glib.Error) bool {
	var arg0 *glib.Error
	arg0 = glib.WrapError(error)

	ret := C.g_dbus_error_strip_remote_error(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusErrorUnregisterError destroys an association previously set up with
// g_dbus_error_register_error().
func DbusErrorUnregisterError(errorDomain glib.Quark, errorCode int, dbusErrorName string) bool {
	var arg0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(errorDomain)
		arg0 = glib.Quark(tmp)
	}

	var arg1 int
	arg1 = int(errorCode)

	var arg2 string
	dbusErrorName = C.GoString(arg2)
	defer C.free(unsafe.Pointer(dbusErrorName))

	ret := C.g_dbus_error_unregister_error(arg0, arg1, arg2)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusGenerateGuid() string {
	ret := C.g_dbus_generate_guid()

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// DbusGValueToGvariant converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DbusGValueToGvariant(gvalue *externglib.Value, _type *glib.VariantType) *glib.Variant {
	var arg1 *glib.VariantType
	arg1 = glib.WrapVariantType(_type)

	ret := C.g_dbus_gvalue_to_gvariant(arg1)

	var ret0 *glib.Variant
	ret0 = glib.WrapVariant(ret)

	return ret0
}

// DbusGvariantToGValue converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DbusGvariantToGValue(value *glib.Variant) externglib.Value {
	var arg0 *glib.Variant
	arg0 = glib.WrapVariant(value)

	var arg1 *C.GValue // out

	ret := C.g_dbus_gvariant_to_gvalue(arg0, &arg1)

	var ret0 *externglib.Value

	return ret0
}

// DbusIsAddress checks if @string is a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
func DbusIsAddress(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_address(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsGuid checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DbusIsGuid(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_guid(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsInterfaceName checks if @string is a valid D-Bus interface name.
func DbusIsInterfaceName(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_interface_name(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DbusIsMemberName(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_member_name(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DbusIsName(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_name(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DbusIsSupportedAddress(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_supported_address(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// DbusIsUniqueName checks if @string is a valid D-Bus unique bus name.
func DbusIsUniqueName(string string) bool {
	var arg0 string
	string = C.GoString(arg0)
	defer C.free(unsafe.Pointer(string))

	ret := C.g_dbus_is_unique_name(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// NewDtlsClientConnection creates a new ClientConnection wrapping @base_socket
// which is assumed to communicate with the server identified by
// @server_identity.
func NewDtlsClientConnection(baseSocket DatagramBased, serverIdentity SocketConnectable) DtlsClientConnection {
	ret := C.g_dtls_client_connection_new()

	var ret0 DtlsClientConnection

	return ret0
}

// NewDtlsServerConnection creates a new ServerConnection wrapping @base_socket.
func NewDtlsServerConnection(baseSocket DatagramBased, certificate TlsCertificate) DtlsServerConnection {
	var arg1 TlsCertificate
	arg1 = gio.WrapTlsCertificate(externglib.Take(unsafe.Pointer(certificate.Native())))

	ret := C.g_dtls_server_connection_new(arg1)

	var ret0 DtlsServerConnection

	return ret0
}

// FileNewForCommandlineArg creates a #GFile with the given argument from the
// command line. The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory. This
// operation never fails, but the returned object might not support any I/O
// operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(arg string) File {
	var arg0 string
	arg = C.GoString(arg0)
	defer C.free(unsafe.Pointer(arg))

	ret := C.g_file_new_for_commandline_arg(arg0)

	var ret0 File

	return ret0
}

// FileNewForCommandlineArgAndCwd creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(arg string, cwd string) File {
	var arg0 string
	arg = C.GoString(arg0)
	defer C.free(unsafe.Pointer(arg))

	var arg1 string
	cwd = C.GoString(arg1)
	defer C.free(unsafe.Pointer(cwd))

	ret := C.g_file_new_for_commandline_arg_and_cwd(arg0, arg1)

	var ret0 File

	return ret0
}

// FileNewForPath constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if @path
// is malformed.
func FileNewForPath(path string) File {
	var arg0 string
	path = C.GoString(arg0)
	defer C.free(unsafe.Pointer(path))

	ret := C.g_file_new_for_path(arg0)

	var ret0 File

	return ret0
}

// FileNewForURI constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if @uri is
// malformed or if the uri type is not supported.
func FileNewForURI(uri string) File {
	var arg0 string
	uri = C.GoString(arg0)
	defer C.free(unsafe.Pointer(uri))

	ret := C.g_file_new_for_uri(arg0)

	var ret0 File

	return ret0
}

// FileNewTmp opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is nil,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return nil if a temporary
// file could not be created.
func FileNewTmp(tmpl string) (iostream FileIOStream, file File) {
	var arg0 string
	tmpl = C.GoString(arg0)
	defer C.free(unsafe.Pointer(tmpl))

	var arg1 **C.GFileIOStream // out

	ret := C.g_file_new_tmp(arg0, &arg1)

	var ret0 FileIOStream
	ret0 = gio.WrapFileIOStream(externglib.Take(unsafe.Pointer(arg1.Native())))

	var ret1 File

	return ret0, ret1
}

// FileParseName constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails, but the
// returned object might not support any I/O operation if the @parse_name cannot
// be parsed.
func FileParseName(parseName string) File {
	var arg0 string
	parseName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(parseName))

	ret := C.g_file_parse_name(arg0)

	var ret0 File

	return ret0
}

// IconDeserialize deserializes a #GIcon previously serialized using
// g_icon_serialize().
func IconDeserialize(value *glib.Variant) Icon {
	var arg0 *glib.Variant
	arg0 = glib.WrapVariant(value)

	ret := C.g_icon_deserialize(arg0)

	var ret0 Icon

	return ret0
}

// IconHash gets a hash for an icon.
func IconHash(icon interface{}) uint {
	var arg0 interface{}
	arg0 = box.Get(uintptr(icon))

	ret := C.g_icon_hash(arg0)

	var ret0 uint
	ret0 = uint(ret)

	return ret0
}

// IconNewForString: generate a #GIcon instance from @str. This function can
// fail if @str is not valid - see g_icon_to_string() for discussion.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that each #GType is registered with the type system prior
// to calling g_icon_new_for_string().
func IconNewForString(str string) Icon {
	var arg0 string
	str = C.GoString(arg0)
	defer C.free(unsafe.Pointer(str))

	ret := C.g_icon_new_for_string(arg0)

	var ret0 Icon

	return ret0
}

// IOErrorFromErrno converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
//
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
func IOErrorFromErrno(errNo int) IOErrorEnum {
	var arg0 int
	arg0 = int(errNo)

	ret := C.g_io_error_from_errno(arg0)

	var ret0 IOErrorEnum
	ret0 = IOErrorEnum(ret)

	return ret0
}

// IOErrorQuark gets the GIO Error Quark.
func IOErrorQuark() glib.Quark {
	ret := C.g_io_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// IOExtensionPointImplement registers @type as extension for the extension
// point with name @extension_point_name.
//
// If @type has already been registered as an extension for this extension
// point, the existing OExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, _type externglib.Type, extensionName string, priority int) *IOExtension {
	var arg0 string
	extensionPointName = C.GoString(arg0)
	defer C.free(unsafe.Pointer(extensionPointName))

	var arg2 string
	extensionName = C.GoString(arg2)
	defer C.free(unsafe.Pointer(extensionName))

	var arg3 int
	arg3 = int(priority)

	ret := C.g_io_extension_point_implement(arg0, arg2, arg3)

	var ret0 *IOExtension
	ret0 = gio.WrapIOExtension(ret)

	return ret0
}

// IOExtensionPointLookup looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	var arg0 string
	name = C.GoString(arg0)
	defer C.free(unsafe.Pointer(name))

	ret := C.g_io_extension_point_lookup(arg0)

	var ret0 *IOExtensionPoint
	ret0 = gio.WrapIOExtensionPoint(ret)

	return ret0
}

// IOExtensionPointRegister registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	var arg0 string
	name = C.GoString(arg0)
	defer C.free(unsafe.Pointer(name))

	ret := C.g_io_extension_point_register(arg0)

	var ret0 *IOExtensionPoint
	ret0 = gio.WrapIOExtensionPoint(ret)

	return ret0
}

// IOModulesLoadAllInDirectory loads all the modules in the specified directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectory(dirname string) *glib.List {
	var arg0 string
	dirname = C.GoString(arg0)
	defer C.free(unsafe.Pointer(dirname))

	ret := C.g_io_modules_load_all_in_directory(arg0)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// IOModulesLoadAllInDirectoryWithScope loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List {
	var arg0 string
	dirname = C.GoString(arg0)
	defer C.free(unsafe.Pointer(dirname))

	var arg1 *IOModuleScope
	arg1 = gio.WrapIOModuleScope(scope)

	ret := C.g_io_modules_load_all_in_directory_with_scope(arg0, arg1)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string) {
	var arg0 string
	dirname = C.GoString(arg0)
	defer C.free(unsafe.Pointer(dirname))

	C.g_io_modules_scan_all_in_directory(arg0)
}

// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var arg0 string
	dirname = C.GoString(arg0)
	defer C.free(unsafe.Pointer(dirname))

	var arg1 *IOModuleScope
	arg1 = gio.WrapIOModuleScope(scope)

	C.g_io_modules_scan_all_in_directory_with_scope(arg0, arg1)
}

// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs() {
	C.g_io_scheduler_cancel_all_jobs()
}

// IOSchedulerPushJob schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned, regardless
// whether the job was cancelled or has run to completion.
//
// If @cancellable is not nil, it can be used to cancel the I/O job by calling
// g_cancellable_cancel() or by calling g_io_scheduler_cancel_all_jobs().
func IOSchedulerPushJob(jobFunc IOSchedulerJobFunc, ioPriority int, cancellable Cancellable) {
	arg1 := C.gpointer(box.Assign(box.Callback, userData))
	var arg3 int
	arg3 = int(ioPriority)

	var arg4 Cancellable
	arg4 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	C.g_io_scheduler_push_job((*[0]byte)(C.callbackDelete), arg3, arg4)
}

// NewKeyfileSettingsBackend creates a keyfile-backed Backend.
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the path
// given in @root_path (which must start and end with a slash and not contain
// two consecutive slashes). @root_path may be "/".
//
// If @root_group is non-nil then it specifies the name of the keyfile group
// used for keys that are written directly below @root_path. For example, if
// @root_path is "/apps/example/" and @root_group is "toplevel", then settings
// the key "/apps/example/enabled" to a value of true will cause the following
// to appear in the keyfile:
//
//
//      [toplevel]
//      enabled=true
//    ]|
//
//    If @root_group is nil then it is not permitted to store keys
//    directly below the @root_path.
//
//    For keys not stored directly below @root_path (ie: in a sub-path),
//    the name of the subpath (with the final slash stripped) is used as
//    the name of the keyfile group.  To continue the example, if
//    "/apps/example/profiles/default/font-size" were set to
//    12 then the following would appear in the keyfile:
//
//    |[
//      [profiles/default]
//      font-size=12
//
//
// The backend will refuse writes (and return writability as being false) for
// keys outside of @root_path and, in the event that @root_group is nil, also
// for keys directly under @root_path. Writes will also be refused if the
// backend detects that it has the inability to rewrite the keyfile (ie: the
// containing directory is not writable).
//
// There is no checking done for your key namespace clashing with the syntax of
// the key file format. For example, if you have '[' or ']' characters in your
// path names or '=' in your key names you may be in trouble.
//
// The backend reads default values from a keyfile called `defaults` in the
// directory specified by the SettingsBackend:defaults-dir property, and a list
// of locked keys from a text file with the name `locks` in the same location.
func NewKeyfileSettingsBackend(filename string, rootPath string, rootGroup string) SettingsBackend {
	var arg0 string
	filename = C.GoString(arg0)
	defer C.free(unsafe.Pointer(filename))

	var arg1 string
	rootPath = C.GoString(arg1)
	defer C.free(unsafe.Pointer(rootPath))

	var arg2 string
	rootGroup = C.GoString(arg2)
	defer C.free(unsafe.Pointer(rootGroup))

	ret := C.g_keyfile_settings_backend_new(arg0, arg1, arg2)

	var ret0 SettingsBackend
	ret0 = gio.WrapSettingsBackend(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MemoryMonitorDupDefault gets a reference to the default Monitor for the
// system.
func MemoryMonitorDupDefault() MemoryMonitor {
	ret := C.g_memory_monitor_dup_default()

	var ret0 MemoryMonitor

	return ret0
}

// NewMemorySettingsBackend creates a memory-backed Backend.
//
// This backend allows changes to settings, but does not write them to any
// backing storage, so the next time you run your application, the memory
// backend will start out with the default values again.
func NewMemorySettingsBackend() SettingsBackend {
	ret := C.g_memory_settings_backend_new()

	var ret0 SettingsBackend
	ret0 = gio.WrapSettingsBackend(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NetworkMonitorGetDefault gets the default Monitor for the system.
func NetworkMonitorGetDefault() NetworkMonitor {
	ret := C.g_network_monitor_get_default()

	var ret0 NetworkMonitor

	return ret0
}

// NetworkingInit initializes the platform networking libraries (eg, on Windows,
// this calls WSAStartup()). GLib will call this itself if it is needed, so you
// only need to call it if you directly call system networking functions
// (without calling any GLib networking functions first).
func NetworkingInit() {
	C.g_networking_init()
}

// NewNullSettingsBackend creates a readonly Backend.
//
// This backend does not allow changes to settings, so all settings will always
// have their default values.
func NewNullSettingsBackend() SettingsBackend {
	ret := C.g_null_settings_backend_new()

	var ret0 SettingsBackend
	ret0 = gio.WrapSettingsBackend(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPollableSource: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource that expects a callback of type
// SourceFunc. The new source does not actually do anything on its own; use
// g_source_add_child_source() to add other sources to it to cause it to
// trigger.
func NewPollableSource(pollableStream gextras.Objector) *glib.Source {
	var arg0 gextras.Objector
	arg0 = externglib.Take(unsafe.Pointer(pollableStream.Native()))

	ret := C.g_pollable_source_new(arg0)

	var ret0 *glib.Source
	ret0 = glib.WrapSource(ret)

	return ret0
}

// PollableSourceNewFull: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource, as with g_pollable_source_new(), but
// also attaching @child_source (with a dummy callback), and @cancellable, if
// they are non-nil.
func PollableSourceNewFull(pollableStream gextras.Objector, childSource *glib.Source, cancellable Cancellable) *glib.Source {
	var arg0 gextras.Objector
	arg0 = externglib.Take(unsafe.Pointer(pollableStream.Native()))

	var arg1 *glib.Source
	arg1 = glib.WrapSource(childSource)

	var arg2 Cancellable
	arg2 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_pollable_source_new_full(arg0, arg1, arg2)

	var ret0 *glib.Source
	ret0 = glib.WrapSource(ret)

	return ret0
}

// PollableStreamRead tries to read from @stream, as with g_input_stream_read()
// (if @blocking is true) or g_pollable_input_stream_read_nonblocking() (if
// @blocking is false). This can be used to more easily share code between
// blocking and non-blocking implementations of a method.
//
// If @blocking is false, then @stream must be a InputStream for which
// g_pollable_input_stream_can_poll() returns true, or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// InputStream.
func PollableStreamRead(stream InputStream, buffer []uint8, blocking bool, cancellable Cancellable) int {
	var arg0 InputStream
	arg0 = gio.WrapInputStream(externglib.Take(unsafe.Pointer(stream.Native())))

	var arg1 []uint8
	{
		arg1 = make([]uint8, a)
		for i := 0; i < uintptr(a); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			arg1[i] = uint8(src)
		}
	}

	var arg3 bool
	arg3 = gextras.Gobool(blocking)

	var arg4 Cancellable
	arg4 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_pollable_stream_read(arg0, arg1, arg3, arg4)

	var ret0 int
	ret0 = int(ret)

	return ret0
}

// PollableStreamWrite tries to write to @stream, as with
// g_output_stream_write() (if @blocking is true) or
// g_pollable_output_stream_write_nonblocking() (if @blocking is false). This
// can be used to more easily share code between blocking and non-blocking
// implementations of a method.
//
// If @blocking is false, then @stream must be a OutputStream for which
// g_pollable_output_stream_can_poll() returns true or else the behavior is
// undefined. If @blocking is true, then @stream does not need to be a
// OutputStream.
func PollableStreamWrite(stream OutputStream, buffer []uint8, blocking bool, cancellable Cancellable) int {
	var arg0 OutputStream
	arg0 = gio.WrapOutputStream(externglib.Take(unsafe.Pointer(stream.Native())))

	var arg1 []uint8
	{
		arg1 = make([]uint8, a)
		for i := 0; i < uintptr(a); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			arg1[i] = uint8(src)
		}
	}

	var arg3 bool
	arg3 = gextras.Gobool(blocking)

	var arg4 Cancellable
	arg4 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_pollable_stream_write(arg0, arg1, arg3, arg4)

	var ret0 int
	ret0 = int(ret)

	return ret0
}

// PollableStreamWriteAll tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write() rather than
// g_output_stream_write().
//
// On a successful write of @count bytes, true is returned, and @bytes_written
// is set to @count.
//
// If there is an error during the operation (including G_IO_ERROR_WOULD_BLOCK
// in the non-blocking case), false is returned and @error is set to indicate
// the error status, @bytes_written is updated to contain the number of bytes
// written into the stream before the error occurred.
//
// As with g_pollable_stream_write(), if @blocking is false, then @stream must
// be a OutputStream for which g_pollable_output_stream_can_poll() returns true
// or else the behavior is undefined. If @blocking is true, then @stream does
// not need to be a OutputStream.
func PollableStreamWriteAll(stream OutputStream, buffer []uint8, blocking bool, cancellable Cancellable) (bytesWritten uint, ok bool) {
	var arg0 OutputStream
	arg0 = gio.WrapOutputStream(externglib.Take(unsafe.Pointer(stream.Native())))

	var arg1 []uint8
	{
		arg1 = make([]uint8, a)
		for i := 0; i < uintptr(a); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			arg1[i] = uint8(src)
		}
	}

	var arg3 bool
	arg3 = gextras.Gobool(blocking)

	var arg4 *C.gsize // out

	var arg5 Cancellable
	arg5 = gio.WrapCancellable(externglib.Take(unsafe.Pointer(cancellable.Native())))

	ret := C.g_pollable_stream_write_all(arg0, arg1, arg3, &arg4, arg5)

	var ret0 uint
	ret0 = uint(arg4)

	var ret1 bool
	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// ProxyGetDefaultForProtocol: find the `gio-proxy` extension point for a proxy
// implementation that supports the specified protocol.
func ProxyGetDefaultForProtocol(protocol string) Proxy {
	var arg0 string
	protocol = C.GoString(arg0)
	defer C.free(unsafe.Pointer(protocol))

	ret := C.g_proxy_get_default_for_protocol(arg0)

	var ret0 Proxy

	return ret0
}

// ProxyResolverGetDefault gets the default Resolver for the system.
func ProxyResolverGetDefault() ProxyResolver {
	ret := C.g_proxy_resolver_get_default()

	var ret0 ProxyResolver

	return ret0
}

// ResolverErrorQuark gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {
	ret := C.g_resolver_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// ResourceErrorQuark gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark {
	ret := C.g_resource_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// ResourceLoad loads a binary resource bundle and creates a #GResource
// representation of it, allowing you to query it for data.
//
// If you want to use this resource in the global resource namespace you need to
// register it with g_resources_register().
//
// If @filename is empty or the data in it is corrupt, G_RESOURCE_ERROR_INTERNAL
// will be returned. If @filename doesn’t exist, or there is an error in reading
// it, an error from g_mapped_file_new() will be returned.
func ResourceLoad(filename string) *Resource {
	var arg0 string
	filename = C.GoString(arg0)
	defer C.free(unsafe.Pointer(filename))

	ret := C.g_resource_load(arg0)

	var ret0 *Resource
	ret0 = gio.WrapResource(ret)

	return ret0
}

// ResourcesEnumerateChildren returns all the names of children at the specified
// @path in the set of globally registered resources. The return result is a nil
// terminated list of strings which should be released with g_strfreev().
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) []string {
	var arg0 string
	path = C.GoString(arg0)
	defer C.free(unsafe.Pointer(path))

	var arg1 ResourceLookupFlags
	arg1 = ResourceLookupFlags(lookupFlags)

	ret := C.g_resources_enumerate_children(arg0, arg1)

	var ret0 []string
	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			src = C.GoString(ret0[i])
			defer C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ResourcesGetInfo looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (size uint, flags uint32, ok bool) {
	var arg0 string
	path = C.GoString(arg0)
	defer C.free(unsafe.Pointer(path))

	var arg1 ResourceLookupFlags
	arg1 = ResourceLookupFlags(lookupFlags)

	var arg2 *C.gsize // out

	var arg3 *C.guint32 // out

	ret := C.g_resources_get_info(arg0, arg1, &arg2, &arg3)

	var ret0 uint
	ret0 = uint(arg2)

	var ret1 uint32
	ret1 = uint32(arg3)

	var ret2 bool
	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ResourcesLookupData looks for a file at the specified @path in the set of
// globally registered resources and returns a #GBytes that lets you directly
// access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) *glib.Bytes {
	var arg0 string
	path = C.GoString(arg0)
	defer C.free(unsafe.Pointer(path))

	var arg1 ResourceLookupFlags
	arg1 = ResourceLookupFlags(lookupFlags)

	ret := C.g_resources_lookup_data(arg0, arg1)

	var ret0 *glib.Bytes
	ret0 = glib.WrapBytes(ret)

	return ret0
}

// ResourcesOpenStream looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) InputStream {
	var arg0 string
	path = C.GoString(arg0)
	defer C.free(unsafe.Pointer(path))

	var arg1 ResourceLookupFlags
	arg1 = ResourceLookupFlags(lookupFlags)

	ret := C.g_resources_open_stream(arg0, arg1)

	var ret0 InputStream
	ret0 = gio.WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ResourcesRegister registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
func ResourcesRegister(resource *Resource) {
	var arg0 *Resource
	arg0 = gio.WrapResource(resource)

	C.g_resources_register(arg0)
}

// ResourcesUnregister unregisters the resource from the process-global set of
// resources.
func ResourcesUnregister(resource *Resource) {
	var arg0 *Resource
	arg0 = gio.WrapResource(resource)

	C.g_resources_unregister(arg0)
}

// SettingsSchemaSourceGetDefault gets the default system schema source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If no schemas are installed, nil will be returned.
//
// The returned source may actually consist of multiple schema sources from
// different directories, depending on which directories were given in
// `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all lookups
// performed against the default source should probably be done recursively.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {
	ret := C.g_settings_schema_source_get_default()

	var ret0 *SettingsSchemaSource
	ret0 = gio.WrapSettingsSchemaSource(ret)

	return ret0
}

// SimpleAsyncReportGerrorInIdle reports an error in an idle function. Similar
// to g_simple_async_report_error_in_idle(), but takes a #GError rather than
// building a new one.
func SimpleAsyncReportGerrorInIdle(object gextras.Objector, callback AsyncReadyCallback, error *glib.Error) {
	var arg0 gextras.Objector
	arg0 = externglib.Take(unsafe.Pointer(object.Native()))

	arg2 := C.gpointer(box.Assign(box.Callback, userData))
	var arg3 *glib.Error
	arg3 = glib.WrapError(error)

	C.g_simple_async_report_gerror_in_idle(arg0, arg3)
}

// SimpleAsyncReportTakeGerrorInIdle reports an error in an idle function.
// Similar to g_simple_async_report_gerror_in_idle(), but takes over the
// caller's ownership of @error, so the caller does not have to free it any
// more.
func SimpleAsyncReportTakeGerrorInIdle(object gextras.Objector, callback AsyncReadyCallback, error *glib.Error) {
	var arg0 gextras.Objector
	arg0 = externglib.Take(unsafe.Pointer(object.Native()))

	arg2 := C.gpointer(box.Assign(box.Callback, userData))
	var arg3 *glib.Error
	arg3 = glib.WrapError(error)

	C.g_simple_async_report_take_gerror_in_idle(arg0, arg3)
}

// SrvTargetListSort sorts @targets in place according to the algorithm in RFC
// 2782.
func SrvTargetListSort(targets *glib.List) *glib.List {
	var arg0 *glib.List
	arg0 = glib.WrapList(targets)

	ret := C.g_srv_target_list_sort(arg0)

	var ret0 *glib.List
	ret0 = glib.WrapList(ret)

	return ret0
}

// TlsBackendGetDefault gets the default Backend for the system.
func TlsBackendGetDefault() TlsBackend {
	ret := C.g_tls_backend_get_default()

	var ret0 TlsBackend

	return ret0
}

// TlsChannelBindingErrorQuark gets the TLS channel binding error quark.
func TlsChannelBindingErrorQuark() glib.Quark {
	ret := C.g_tls_channel_binding_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// NewTlsClientConnection creates a new ClientConnection wrapping
// @base_io_stream (which must have pollable input and output streams) which is
// assumed to communicate with the server identified by @server_identity.
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsClientConnection(baseIOStream IOStream, serverIdentity SocketConnectable) TlsClientConnection {
	var arg0 IOStream
	arg0 = gio.WrapIOStream(externglib.Take(unsafe.Pointer(baseIOStream.Native())))

	ret := C.g_tls_client_connection_new(arg0)

	var ret0 TlsClientConnection

	return ret0
}

// TlsErrorQuark gets the TLS error quark.
func TlsErrorQuark() glib.Quark {
	ret := C.g_tls_error_quark()

	var ret0 glib.Quark
	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// NewTlsFileDatabase creates a new FileDatabase which uses anchor certificate
// authorities in @anchors to verify certificate chains.
//
// The certificates in @anchors must be PEM encoded.
func NewTlsFileDatabase(anchors string) TlsFileDatabase {
	var arg0 string
	anchors = C.GoString(arg0)
	defer C.free(unsafe.Pointer(anchors))

	ret := C.g_tls_file_database_new(arg0)

	var ret0 TlsFileDatabase

	return ret0
}

// NewTlsServerConnection creates a new ServerConnection wrapping
// @base_io_stream (which must have pollable input and output streams).
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTlsServerConnection(baseIOStream IOStream, certificate TlsCertificate) TlsServerConnection {
	var arg0 IOStream
	arg0 = gio.WrapIOStream(externglib.Take(unsafe.Pointer(baseIOStream.Native())))

	var arg1 TlsCertificate
	arg1 = gio.WrapTlsCertificate(externglib.Take(unsafe.Pointer(certificate.Native())))

	ret := C.g_tls_server_connection_new(arg0, arg1)

	var ret0 TlsServerConnection

	return ret0
}

// UnixIsMountPathSystemInternal determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool {
	var arg0 string
	mountPath = C.GoString(arg0)
	defer C.free(unsafe.Pointer(mountPath))

	ret := C.g_unix_is_mount_path_system_internal(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixIsSystemDevicePath determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered ‘system’ ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool {
	var arg0 string
	devicePath = C.GoString(arg0)
	defer C.free(unsafe.Pointer(devicePath))

	ret := C.g_unix_is_system_device_path(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixIsSystemFSType determines if @fs_type is considered a type of file system
// which is only used in implementation of the OS. This is primarily used for
// hiding mounted volumes that are intended as APIs for programs to read, and
// system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered ‘system’ ones may change over time.
func UnixIsSystemFSType(fsType string) bool {
	var arg0 string
	fsType = C.GoString(arg0)
	defer C.free(unsafe.Pointer(fsType))

	ret := C.g_unix_is_system_fs_type(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountAt gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg0 string
	mountPath = C.GoString(arg0)
	defer C.free(unsafe.Pointer(mountPath))

	var arg1 *C.guint64 // out

	ret := C.g_unix_mount_at(arg0, &arg1)

	var ret0 uint64
	ret0 = uint64(arg1)

	var ret1 *UnixMountEntry
	ret1 = gio.WrapUnixMountEntry(ret)

	return ret0, ret1
}

// UnixMountCompare compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mount1)

	var arg1 *UnixMountEntry
	arg1 = gio.WrapUnixMountEntry(mount2)

	ret := C.g_unix_mount_compare(arg0, arg1)

	var ret0 int
	ret0 = int(ret)

	return ret0
}

// UnixMountCopy makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_copy(arg0)

	var ret0 *UnixMountEntry
	ret0 = gio.WrapUnixMountEntry(ret)

	return ret0
}

// UnixMountFor gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg0 string
	filePath = C.GoString(arg0)
	defer C.free(unsafe.Pointer(filePath))

	var arg1 *C.guint64 // out

	ret := C.g_unix_mount_for(arg0, &arg1)

	var ret0 uint64
	ret0 = uint64(arg1)

	var ret1 *UnixMountEntry
	ret1 = gio.WrapUnixMountEntry(ret)

	return ret0, ret1
}

// UnixMountFree frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry) {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	C.g_unix_mount_free(arg0)
}

// UnixMountGetDevicePath gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_get_device_path(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGetFSType gets the filesystem type for the unix mount.
func UnixMountGetFSType(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_get_fs_type(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGetMountPath gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_get_mount_path(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGetOptions gets a comma-separated list of mount options for the unix
// mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_get_options(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGetRootPath gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_get_root_path(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGuessCanEject guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_guess_can_eject(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountGuessIcon guesses the icon of a Unix mount.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_guess_icon(arg0)

	var ret0 Icon

	return ret0
}

// UnixMountGuessName guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_guess_name(arg0)

	var ret0 string
	ret = C.GoString(ret0)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGuessShouldDisplay guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_guess_should_display(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountGuessSymbolicIcon guesses the symbolic icon of a Unix mount.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_guess_symbolic_icon(arg0)

	var ret0 Icon

	return ret0
}

// UnixMountIsReadonly checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_is_readonly(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountIsSystemInternal checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entry’s properties.
//
// The definition of what a ‘system’ mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
	var arg0 *UnixMountEntry
	arg0 = gio.WrapUnixMountEntry(mountEntry)

	ret := C.g_unix_mount_is_system_internal(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountPointAt gets a MountPoint for a given mount path. If @time_read is
// set, it will be filled with a unix timestamp for checking if the mount points
// have changed since with g_unix_mount_points_changed_since().
//
// If more mount points have the same mount path, the last matching mount point
// is returned.
func UnixMountPointAt(mountPath string) (timeRead uint64, unixMountPoint *UnixMountPoint) {
	var arg0 string
	mountPath = C.GoString(arg0)
	defer C.free(unsafe.Pointer(mountPath))

	var arg1 *C.guint64 // out

	ret := C.g_unix_mount_point_at(arg0, &arg1)

	var ret0 uint64
	ret0 = uint64(arg1)

	var ret1 *UnixMountPoint
	ret1 = gio.WrapUnixMountPoint(ret)

	return ret0, ret1
}

// UnixMountPointsChangedSince checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool {
	var arg0 uint64
	arg0 = uint64(time)

	ret := C.g_unix_mount_points_changed_since(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountPointsGet gets a #GList of MountPoint containing the unix mount
// points. If @time_read is set, it will be filled with the mount timestamp,
// allowing for checking if the mounts have changed with
// g_unix_mount_points_changed_since().
func UnixMountPointsGet() (timeRead uint64, list *glib.List) {
	var arg0 *C.guint64 // out

	ret := C.g_unix_mount_points_get(&arg0)

	var ret0 uint64
	ret0 = uint64(arg0)

	var ret1 *glib.List
	ret1 = glib.WrapList(ret)

	return ret0, ret1
}

// UnixMountsChangedSince checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool {
	var arg0 uint64
	arg0 = uint64(time)

	ret := C.g_unix_mounts_changed_since(arg0)

	var ret0 bool
	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountsGet gets a #GList of MountEntry containing the unix mounts. If
// @time_read is set, it will be filled with the mount timestamp, allowing for
// checking if the mounts have changed with g_unix_mounts_changed_since().
func UnixMountsGet() (timeRead uint64, list *glib.List) {
	var arg0 *C.guint64 // out

	ret := C.g_unix_mounts_get(&arg0)

	var ret0 uint64
	ret0 = uint64(arg0)

	var ret1 *glib.List
	ret1 = glib.WrapList(ret)

	return ret0, ret1
}

// Action represents a single named action.
//
// The main interface to an action is that it can be activated with
// g_action_activate(). This results in the 'activate' signal being emitted. An
// activation has a #GVariant parameter (which may be nil). The correct type for
// the parameter is determined by a static parameter type (which is given at
// construction time).
//
// An action may optionally have a state, in which case the state may be set
// with g_action_change_state(). This call takes a #GVariant. The correct type
// for the state is determined by a static state type (which is given at
// construction time).
//
// The state may have a hint associated with it, specifying its valid range.
//
// #GAction is merely the interface to the concept of an action, as described
// above. Various implementations of actions exist, including Action.
//
// In all cases, the implementing class is responsible for storing the name of
// the action, the parameter type, the enabled state, the optional state type
// and the state and emitting the appropriate signals when these change. The
// implementor is responsible for filtering calls to g_action_activate() and
// g_action_change_state() for type safety and for the state being enabled.
//
// Probably the only useful thing to do with a #GAction is to put it inside of a
// ActionGroup.
type Action interface {
	Activate(parameter *glib.Variant)
	ChangeState(value *glib.Variant)
	GetEnabled() bool
	GetName() string
	GetParameterType() *glib.VariantType
	GetState() *glib.Variant
	GetStateHint() *glib.Variant
	GetStateType() *glib.VariantType
}

// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
type ActionGroup interface {
	ActionAdded(actionName string)
	ActionEnabledChanged(actionName string, enabled bool)
	ActionRemoved(actionName string)
	ActionStateChanged(actionName string, state *glib.Variant)
	ActivateAction(actionName string, parameter *glib.Variant)
	ChangeActionState(actionName string, value *glib.Variant)
	GetActionEnabled(actionName string) bool
	GetActionParameterType(actionName string) *glib.VariantType
	GetActionState(actionName string) *glib.Variant
	GetActionStateHint(actionName string) *glib.Variant
	GetActionStateType(actionName string) *glib.VariantType
	HasAction(actionName string) bool
	ListActions() []string
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// ActionMap: the GActionMap interface is implemented by Group implementations
// that operate by containing a number of named #GAction instances, such as
// ActionGroup.
//
// One useful application of this interface is to map the names of actions from
// various action groups to unique, prefixed names (e.g. by prepending "app." or
// "win."). This is the motivation for the 'Map' part of the interface name.
type ActionMap interface {
	AddAction(action Action)
	AddActionEntries(entries []ActionEntry, userData interface{})
	LookupAction(actionName string) Action
	RemoveAction(actionName string)
}

// AppInfo: Info and LaunchContext are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key `totem U` and a single URI, `sftp://foo/file.avi`,
// then `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only
// work if a set of suitable GIO extensions (such as gvfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
//
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
type AppInfo interface {
	AddSupportsType(contentType string) bool
	CanDelete() bool
	CanRemoveSupportsType() bool
	Delete() bool
	Dup() AppInfo
	Equal(appinfo2 AppInfo) bool
	GetCommandline() string
	GetDescription() string
	GetDisplayName() string
	GetExecutable() string
	GetIcon() Icon
	GetID() string
	GetName() string
	GetSupportedTypes() []string
	Launch(files *glib.List, context AppLaunchContext) bool
	LaunchUris(uris *glib.List, context AppLaunchContext) bool
	LaunchUrisAsync(uris *glib.List, context AppLaunchContext, cancellable Cancellable, callback AsyncReadyCallback)
	LaunchUrisFinish(result AsyncResult) bool
	RemoveSupportsType(contentType string) bool
	SetAsDefaultForExtension(extension string) bool
	SetAsDefaultForType(contentType string) bool
	SetAsLastUsedForType(contentType string) bool
	ShouldShow() bool
	SupportsFiles() bool
	SupportsUris() bool
}

// AsyncInitable: this is the asynchronous version of #GInitable; it behaves the
// same in all ways except that initialization is asynchronous. For more details
// see the descriptions on #GInitable.
//
// A class may implement both the #GInitable and Initable interfaces.
//
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways. For C
// applications you generally just call g_async_initable_new_async() directly,
// or indirectly via a foo_thing_new_async() wrapper. This will call
// g_async_initable_init_async() under the cover, calling back with nil and a
// set GError on failure.
//
// A typical implementation might look something like this:
//
//    enum {
//       NOT_INITIALIZED,
//       INITIALIZING,
//       INITIALIZED
//    };
//
//    static void
//    _foo_ready_cb (Foo *self)
//    {
//      GList *l;
//
//      self->priv->state = INITIALIZED;
//
//      for (l = self->priv->init_results; l != NULL; l = l->next)
//        {
//          GTask *task = l->data;
//
//          if (self->priv->success)
//            g_task_return_boolean (task, TRUE);
//          else
//            g_task_return_new_error (task, ...);
//          g_object_unref (task);
//        }
//
//      g_list_free (self->priv->init_results);
//      self->priv->init_results = NULL;
//    }
//
//    static void
//    foo_init_async (GAsyncInitable       *initable,
//                    int                   io_priority,
//                    GCancellable         *cancellable,
//                    GAsyncReadyCallback   callback,
//                    gpointer              user_data)
//    {
//      Foo *self = FOO (initable);
//      GTask *task;
//
//      task = g_task_new (initable, cancellable, callback, user_data);
//      g_task_set_name (task, G_STRFUNC);
//
//      switch (self->priv->state)
//        {
//          case NOT_INITIALIZED:
//            _foo_get_ready (self);
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            self->priv->state = INITIALIZING;
//            break;
//          case INITIALIZING:
//            self->priv->init_results = g_list_append (self->priv->init_results,
//                                                      task);
//            break;
//          case INITIALIZED:
//            if (!self->priv->success)
//              g_task_return_new_error (task, ...);
//            else
//              g_task_return_boolean (task, TRUE);
//            g_object_unref (task);
//            break;
//        }
//    }
//
//    static gboolean
//    foo_init_finish (GAsyncInitable       *initable,
//                     GAsyncResult         *result,
//                     GError              **error)
//    {
//      g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
//
//      return g_task_propagate_boolean (G_TASK (result), error);
//    }
//
//    static void
//    foo_async_initable_iface_init (gpointer g_iface,
//                                   gpointer data)
//    {
//      GAsyncInitableIface *iface = g_iface;
//
//      iface->init_async = foo_init_async;
//      iface->init_finish = foo_init_finish;
//    }
//
type AsyncInitable interface {
	InitAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	InitFinish(res AsyncResult) bool
	NewFinish(res AsyncResult) gextras.Objector
}

// AsyncResult provides a base class for implementing asynchronous function
// results.
//
// Asynchronous operations are broken up into two separate operations which are
// chained together by a ReadyCallback. To begin an asynchronous operation,
// provide a ReadyCallback to the asynchronous function. This callback will be
// triggered when the operation has completed, and must be run in a later
// iteration of the [thread-default main
// context][g-main-context-push-thread-default] from where the operation was
// initiated. It will be passed a Result instance filled with the details of the
// operation's success or failure, the object the asynchronous function was
// started for and any error codes returned. The asynchronous callback function
// is then expected to call the corresponding "_finish()" function, passing the
// object the function was called for, the Result instance, and (optionally) an
// @error to grab any error conditions that may have occurred.
//
// The "_finish()" function for an operation takes the generic result (of type
// Result) and returns the specific result that the operation in question yields
// (e.g. a Enumerator for a "enumerate children" operation). If the result or
// error status of the operation is not needed, there is no need to call the
// "_finish()" function; GIO will take care of cleaning up the result and error
// information after the ReadyCallback returns. You can pass nil for the
// ReadyCallback if you don't need to take any action at all after the operation
// completes. Applications may also take a reference to the Result and call
// "_finish()" later; however, the "_finish()" function may be called at most
// once.
//
// Example of a typical asynchronous operation flow:
//
//    void _theoretical_frobnitz_async (Theoretical         *t,
//                                      GCancellable        *c,
//                                      GAsyncReadyCallback  cb,
//                                      gpointer             u);
//
//    gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//                                           GAsyncResult  *res,
//                                           GError       **e);
//
//    static void
//    frobnitz_result_func (GObject      *source_object,
//    		 GAsyncResult *res,
//    		 gpointer      user_data)
//    {
//      gboolean success = FALSE;
//
//      success = _theoretical_frobnitz_finish (source_object, res, NULL);
//
//      if (success)
//        g_printf ("Hurray!\n");
//      else
//        g_printf ("Uh oh!\n");
//
//      ...
//
//    }
//
//    int main (int argc, void *argv[])
//    {
//       ...
//
//       _theoretical_frobnitz_async (theoretical_data,
//                                    NULL,
//                                    frobnitz_result_func,
//                                    NULL);
//
//       ...
//    }
//
//
// The callback for an asynchronous operation is called only once, and is always
// called, even in the case of a cancelled operation. On cancellation the result
// is a G_IO_ERROR_CANCELLED error.
//
// I/O Priority
//
// Many I/O-related asynchronous operations have a priority parameter, which is
// used in certain cases to determine the order in which operations are
// executed. They are not used to determine system-wide I/O scheduling.
// Priorities are integers, with lower numbers indicating higher priority. It is
// recommended to choose priorities between G_PRIORITY_LOW and G_PRIORITY_HIGH,
// with G_PRIORITY_DEFAULT as a default.
type AsyncResult interface {
	GetSourceObject() gextras.Objector
	GetUserData() interface{}
	IsTagged(sourceTag interface{}) bool
	LegacyPropagateError() bool
}

// Converter is implemented by objects that convert binary data in various ways.
// The conversion can be stateful and may fail at any place.
//
// Some example conversions are: character set conversion, compression,
// decompression and regular expression replace.
type Converter interface {
	Convert(inbuf []uint8, outbuf []uint8, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult)
	Reset()
}

// DBusInterface: the BusInterface type is the base type for D-Bus interfaces
// both on the service side (see BusInterfaceSkeleton) and client side (see
// BusProxy).
type DBusInterface interface {
	DupObject() DBusObject
	GetInfo() *DBusInterfaceInfo
	GetObject() DBusObject
	SetObject(object DBusObject)
}

// DBusObject: the BusObject type is the base type for D-Bus objects on both the
// service side (see BusObjectSkeleton) and the client side (see
// BusObjectProxy). It is essentially just a container of interfaces.
type DBusObject interface {
	GetInterface(interfaceName string) DBusInterface
	GetInterfaces() *glib.List
	GetObjectPath() string
}

// DBusObjectManager: the BusObjectManager type is the base type for service-
// and client-side implementations of the standardized
// org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface.
//
// See BusObjectManagerClient for the client-side implementation and
// BusObjectManagerServer for the service-side implementation.
type DBusObjectManager interface {
	GetInterface(objectPath string, interfaceName string) DBusInterface
	GetObject(objectPath string) DBusObject
	GetObjectPath() string
	GetObjects() *glib.List
}

// DatagramBased: a Based is a networking interface for representing
// datagram-based communications. It is a more or less direct mapping of the
// core parts of the BSD socket API in a portable GObject interface. It is
// implemented by #GSocket, which wraps the UNIX socket API on UNIX and winsock2
// on Windows.
//
// Based is entirely platform independent, and is intended to be used alongside
// higher-level networking APIs such as OStream.
//
// It uses vectored scatter/gather I/O by default, allowing for many messages to
// be sent or received in a single call. Where possible, implementations of the
// interface should take advantage of vectored I/O to minimise processing or
// system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
// possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
//
// Each Based operation has a timeout parameter which may be negative for
// blocking behaviour, zero for non-blocking behaviour, or positive for timeout
// behaviour. A blocking operation blocks until finished or there is an error. A
// non-blocking operation will return immediately with a G_IO_ERROR_WOULD_BLOCK
// error if it cannot make progress. A timeout operation will block until the
// operation is complete or the timeout expires; if the timeout expires it will
// return what progress it made, or G_IO_ERROR_TIMED_OUT if no progress was
// made. To know when a call would successfully run you can call
// g_datagram_based_condition_check() or g_datagram_based_condition_wait(). You
// can also use g_datagram_based_create_source() and attach it to a Context to
// get callbacks when I/O is possible.
//
// When running a non-blocking operation applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// As with #GSocket, Baseds can be either connection oriented (for example,
// SCTP) or connectionless (for example, UDP). Baseds must be datagram-based,
// not stream-based. The interface does not cover connection establishment — use
// methods on the underlying type to establish a connection before sending and
// receiving data through the Based API. For connectionless socket types the
// target/source address is specified or received in each I/O operation.
//
// Like most other APIs in GLib, Based is not inherently thread safe. To use a
// Based concurrently from multiple threads, you must implement your own
// locking.
type DatagramBased interface {
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) bool
	CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source
	ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable Cancellable) int
	SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable Cancellable) int
}

// DesktopAppInfoLookup is an opaque data structure and can only be accessed
// using the following functions.
type DesktopAppInfoLookup interface {
	GetDefaultForURIScheme(uriScheme string) AppInfo
}

// Drive: #GDrive - this represent a piece of hardware connected to the machine.
// It's generally only created for removable hardware or hardware with removable
// media.
//
// #GDrive is a container class for #GVolume objects that stem from the same
// piece of media. As such, #GDrive abstracts a drive with (or without)
// removable media and provides operations for querying whether media is
// available, determining whether media change is automatically detected and
// ejecting the media.
//
// If the #GDrive reports that media isn't automatically detected, one can poll
// for media; typically one should not do this periodically as a poll for media
// operation is potentially expensive and may spin up the drive creating noise.
//
// #GDrive supports starting and stopping drives with authentication support for
// the former. This can be used to support a diverse set of use cases including
// connecting/disconnecting iSCSI devices, powering down external disk
// enclosures and starting/stopping multi-disk devices such as RAID devices.
// Note that the actual semantics and side-effects of starting/stopping a
// #GDrive may vary according to implementation. To choose the correct verbs in
// e.g. a file manager, use g_drive_get_start_stop_type().
//
// For porting from GnomeVFS note that there is no equivalent of #GDrive in that
// API.
type Drive interface {
	CanEject() bool
	CanPollForMedia() bool
	CanStart() bool
	CanStartDegraded() bool
	CanStop() bool
	Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	EjectWithOperationFinish(result AsyncResult) bool
	EnumerateIdentifiers() []string
	GetIcon() Icon
	GetIdentifier(kind string) string
	GetName() string
	GetSortKey() string
	GetStartStopType() DriveStartStopType
	GetSymbolicIcon() Icon
	GetVolumes() *glib.List
	HasMedia() bool
	HasVolumes() bool
	IsMediaCheckAutomatic() bool
	IsMediaRemovable() bool
	IsRemovable() bool
	PollForMedia(cancellable Cancellable, callback AsyncReadyCallback)
	PollForMediaFinish(result AsyncResult) bool
	Start(flags DriveStartFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	StartFinish(result AsyncResult) bool
	Stop(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	StopFinish(result AsyncResult) bool
}

// DtlsClientConnection is the client-side subclass of Connection, representing
// a client-side DTLS connection.
type DtlsClientConnection interface {
	GetAcceptedCas() *glib.List
	GetServerIdentity() SocketConnectable
	GetValidationFlags() TlsCertificateFlags
	SetServerIdentity(identity SocketConnectable)
	SetValidationFlags(flags TlsCertificateFlags)
}

// DtlsConnection is the base DTLS connection class type, which wraps a Based
// and provides DTLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side DTLS,
// respectively.
//
// For TLS support, see Connection.
//
// As DTLS is datagram based, Connection implements Based, presenting a
// datagram-socket-like API for the encrypted connection. This operates over a
// base datagram connection, which is also a Based (Connection:base-socket).
//
// To close a DTLS connection, use g_dtls_connection_close().
//
// Neither ServerConnection or ClientConnection set the peer address on their
// base Based if it is a #GSocket — it is up to the caller to do that if they
// wish. If they do not, and g_socket_close() is called on the base socket, the
// Connection will not raise a G_IO_ERROR_NOT_CONNECTED error on further I/O.
type DtlsConnection interface {
	Close(cancellable Cancellable) bool
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	CloseFinish(result AsyncResult) bool
	EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool
	GetCertificate() TlsCertificate
	GetChannelBindingData(_type TlsChannelBindingType) (data []uint8, ok bool)
	GetDatabase() TlsDatabase
	GetInteraction() TlsInteraction
	GetNegotiatedProtocol() string
	GetPeerCertificate() TlsCertificate
	GetPeerCertificateErrors() TlsCertificateFlags
	GetRehandshakeMode() TlsRehandshakeMode
	GetRequireCloseNotify() bool
	Handshake(cancellable Cancellable) bool
	HandshakeAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	HandshakeFinish(result AsyncResult) bool
	SetAdvertisedProtocols(protocols []string)
	SetCertificate(certificate TlsCertificate)
	SetDatabase(database TlsDatabase)
	SetInteraction(interaction TlsInteraction)
	SetRehandshakeMode(mode TlsRehandshakeMode)
	SetRequireCloseNotify(requireCloseNotify bool)
	Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) bool
	ShutdownAsync(shutdownRead bool, shutdownWrite bool, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	ShutdownFinish(result AsyncResult) bool
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
//
//
// Entity Tags
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
type File interface {
	AppendTo(flags FileCreateFlags, cancellable Cancellable) FileOutputStream
	AppendToAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	AppendToFinish(res AsyncResult) FileOutputStream
	Copy(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) bool
	CopyAsync(destination File, flags FileCopyFlags, ioPriority int, cancellable Cancellable, progressCallback FileProgressCallback, callback AsyncReadyCallback)
	CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) bool
	CopyFinish(res AsyncResult) bool
	Create(flags FileCreateFlags, cancellable Cancellable) FileOutputStream
	CreateAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	CreateFinish(res AsyncResult) FileOutputStream
	CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) FileIOStream
	CreateReadwriteAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	CreateReadwriteFinish(res AsyncResult) FileIOStream
	Delete(cancellable Cancellable) bool
	DeleteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	DeleteFinish(result AsyncResult) bool
	Dup() File
	EjectMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	EjectMountableFinish(result AsyncResult) bool
	EjectMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	EjectMountableWithOperationFinish(result AsyncResult) bool
	EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) FileEnumerator
	EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	EnumerateChildrenFinish(res AsyncResult) FileEnumerator
	Equal(file2 File) bool
	FindEnclosingMount(cancellable Cancellable) Mount
	FindEnclosingMountAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	FindEnclosingMountFinish(res AsyncResult) Mount
	GetBasename() string
	GetChild(name string) File
	GetChildForDisplayName(displayName string) File
	GetParent() File
	GetParseName() string
	GetPath() string
	GetRelativePath(descendant File) string
	GetURI() string
	GetURIScheme() string
	HasParent(parent File) bool
	HasPrefix(prefix File) bool
	HasURIScheme(uriScheme string) bool
	Hash() uint
	IsNative() bool
	LoadBytes(cancellable Cancellable) (etagOut string, bytes *glib.Bytes)
	LoadBytesAsync(cancellable Cancellable, callback AsyncReadyCallback)
	LoadBytesFinish(result AsyncResult) (etagOut string, bytes *glib.Bytes)
	LoadContents(cancellable Cancellable) (contents []uint8, length uint, etagOut string, ok bool)
	LoadContentsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	LoadContentsFinish(res AsyncResult) (contents []uint8, length uint, etagOut string, ok bool)
	LoadPartialContentsAsync(cancellable Cancellable, readMoreCallback FileReadMoreCallback, callback AsyncReadyCallback)
	LoadPartialContentsFinish(res AsyncResult) (contents []uint8, length uint, etagOut string, ok bool)
	MakeDirectory(cancellable Cancellable) bool
	MakeDirectoryAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	MakeDirectoryFinish(result AsyncResult) bool
	MakeDirectoryWithParents(cancellable Cancellable) bool
	MakeSymbolicLink(symlinkValue string, cancellable Cancellable) bool
	MeasureDiskUsage(flags FileMeasureFlags, cancellable Cancellable, progressCallback FileMeasureProgressCallback) (diskUsage uint64, numDirs uint64, numFiles uint64, ok bool)
	MeasureDiskUsageAsync(flags FileMeasureFlags, ioPriority int, cancellable Cancellable, progressCallback FileMeasureProgressCallback, callback AsyncReadyCallback)
	MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, ok bool)
	Monitor(flags FileMonitorFlags, cancellable Cancellable) FileMonitor
	MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) FileMonitor
	MonitorFile(flags FileMonitorFlags, cancellable Cancellable) FileMonitor
	MountEnclosingVolume(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	MountEnclosingVolumeFinish(result AsyncResult) bool
	MountMountable(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	MountMountableFinish(result AsyncResult) File
	Move(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) bool
	OpenReadwrite(cancellable Cancellable) FileIOStream
	OpenReadwriteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	OpenReadwriteFinish(res AsyncResult) FileIOStream
	PeekPath() string
	PollMountable(cancellable Cancellable, callback AsyncReadyCallback)
	PollMountableFinish(result AsyncResult) bool
	QueryDefaultHandler(cancellable Cancellable) AppInfo
	QueryDefaultHandlerAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	QueryDefaultHandlerFinish(result AsyncResult) AppInfo
	QueryExists(cancellable Cancellable) bool
	QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType
	QueryFilesystemInfo(attributes string, cancellable Cancellable) FileInfo
	QueryFilesystemInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	QueryFilesystemInfoFinish(res AsyncResult) FileInfo
	QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) FileInfo
	QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	QueryInfoFinish(res AsyncResult) FileInfo
	QuerySettableAttributes(cancellable Cancellable) *FileAttributeInfoList
	QueryWritableNamespaces(cancellable Cancellable) *FileAttributeInfoList
	Read(cancellable Cancellable) FileInputStream
	ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	ReadFinish(res AsyncResult) FileInputStream
	Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) FileOutputStream
	ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	ReplaceContents(contents []uint8, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (newEtag string, ok bool)
	ReplaceContentsAsync(contents []uint8, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback)
	ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback)
	ReplaceContentsFinish(res AsyncResult) (newEtag string, ok bool)
	ReplaceFinish(res AsyncResult) FileOutputStream
	ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) FileIOStream
	ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	ReplaceReadwriteFinish(res AsyncResult) FileIOStream
	ResolveRelativePath(relativePath string) File
	SetAttribute(attribute string, _type FileAttributeType, valueP interface{}, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetAttributesAsync(info FileInfo, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	SetAttributesFinish(result AsyncResult) (info FileInfo, ok bool)
	SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) bool
	SetDisplayName(displayName string, cancellable Cancellable) File
	SetDisplayNameAsync(displayName string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	SetDisplayNameFinish(res AsyncResult) File
	StartMountable(flags DriveStartFlags, startOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	StartMountableFinish(result AsyncResult) bool
	StopMountable(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	StopMountableFinish(result AsyncResult) bool
	SupportsThreadContexts() bool
	Trash(cancellable Cancellable) bool
	TrashAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	TrashFinish(result AsyncResult) bool
	UnmountMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	UnmountMountableFinish(result AsyncResult) bool
	UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	UnmountMountableWithOperationFinish(result AsyncResult) bool
}

// FileDescriptorBased is implemented by streams (implementations of Stream or
// Stream) that are based on file descriptors.
//
// Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type FileDescriptorBased interface {
	GetFd() int
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
type Icon interface {
	Equal(icon2 Icon) bool
	Serialize() *glib.Variant
	ToString() string
}

// Initable is implemented by objects that can fail during initialization. If an
// object implements this interface then it must be initialized as the first
// thing after construction, either via g_initable_init() or
// g_async_initable_init_async() (the latter is only available if it also
// implements Initable).
//
// If the object is not initialized, or initialization returns with an error,
// then all operations on the object except g_object_ref() and g_object_unref()
// are considered to be invalid, and have undefined behaviour. They will often
// fail with g_critical() or g_warning(), but this must not be relied on.
//
// Users of objects implementing this are not intended to use the interface
// method directly, instead it will be used automatically in various ways. For C
// applications you generally just call g_initable_new() directly, or indirectly
// via a foo_thing_new() wrapper. This will call g_initable_init() under the
// cover, returning nil and setting a #GError on failure (at which point the
// instance is unreferenced).
//
// For bindings in languages where the native constructor supports exceptions
// the binding could check for objects implementing GInitable during normal
// construction and automatically initialize them, throwing an exception on
// failure.
type Initable interface {
	Init(cancellable Cancellable) bool
}

// ListModel is an interface that represents a mutable list of #GObjects. Its
// main intention is as a model for various widgets in user interfaces, such as
// list views, but it can also be used as a convenient method of returning lists
// of data, with support for updates.
//
// Each object in the list may also report changes in itself via some mechanism
// (normally the #GObject::notify signal). Taken together with the
// Model::items-changed signal, this provides for a list that can change its
// membership, and in which the members can change their individual properties.
//
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
//
// It is important to note that the Model itself does not report changes to the
// individual items. It only reports changes to the list membership. If you want
// to observe changes to the objects themselves then you need to connect signals
// to the objects that you are interested in.
//
// All items in a Model are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
//
// The semantics are close to that of an array: g_list_model_get_n_items()
// returns the number of items in the list and g_list_model_get_item() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call g_list_model_get_item() until it returns nil.
//
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
//
// On the other side, a consumer is expected only to hold references on objects
// that are currently "user visible", in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread. The thread
// in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// [thread-default main context][g-main-context-push-thread-default] in effect
// at the time that the model was created.
type ListModel interface {
	GetItem(position uint) interface{}
	GetItemType() externglib.Type
	GetNItems() uint
	GetObject(position uint) gextras.Objector
	ItemsChanged(position uint, removed uint, added uint)
}

// LoadableIcon extends the #GIcon interface and adds the ability to load icons
// from streams.
type LoadableIcon interface {
	Load(size int, cancellable Cancellable) (_type string, inputStream InputStream)
	LoadAsync(size int, cancellable Cancellable, callback AsyncReadyCallback)
	LoadFinish(res AsyncResult) (_type string, inputStream InputStream)
}

// Mount: the #GMount interface represents user-visible mounts. Note, when
// porting from GnomeVFS, #GMount is the moral equivalent of VFSVolume.
//
// #GMount is a "mounted" filesystem that you can access. Mounted is in quotes
// because it's not the same as a unix mount, it might be a gvfs mount, but you
// can still access the files on it if you use GIO. Might or might not be
// related to a volume object.
//
// Unmounting a #GMount instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To unmount
// a #GMount instance, first call g_mount_unmount_with_operation() with (at
// least) the #GMount instance and a ReadyCallback. The callback will be fired
// when the operation has resolved (either with success or failure), and a
// Result structure will be passed to the callback. That callback should then
// call g_mount_unmount_with_operation_finish() with the #GMount and the Result
// data to see if the operation was completed successfully. If an @error is
// present when g_mount_unmount_with_operation_finish() is called, then it will
// be filled with any error information.
type Mount interface {
	CanEject() bool
	CanUnmount() bool
	Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	EjectWithOperationFinish(result AsyncResult) bool
	GetDefaultLocation() File
	GetDrive() Drive
	GetIcon() Icon
	GetName() string
	GetRoot() File
	GetSortKey() string
	GetSymbolicIcon() Icon
	GetUuid() string
	GetVolume() Volume
	GuessContentType(forceRescan bool, cancellable Cancellable, callback AsyncReadyCallback)
	GuessContentTypeFinish(result AsyncResult) []string
	GuessContentTypeSync(forceRescan bool, cancellable Cancellable) []string
	IsShadowed() bool
	Remount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	RemountFinish(result AsyncResult) bool
	Shadow()
	Unmount(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	UnmountFinish(result AsyncResult) bool
	UnmountWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	UnmountWithOperationFinish(result AsyncResult) bool
	Unshadow()
}

// NetworkMonitor provides an easy-to-use cross-platform API for monitoring
// network connectivity. On Linux, the available implementations are based on
// the kernel's netlink interface and on NetworkManager.
//
// There is also an implementation for use inside Flatpak sandboxes.
type NetworkMonitor interface {
	CanReach(connectable SocketConnectable, cancellable Cancellable) bool
	CanReachAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback)
	CanReachFinish(result AsyncResult) bool
	GetConnectivity() NetworkConnectivity
	GetNetworkAvailable() bool
	GetNetworkMetered() bool
}

// PollableInputStream is implemented by Streams that can be polled for
// readiness to read. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableInputStream interface {
	CanPoll() bool
	CreateSource(cancellable Cancellable) *glib.Source
	IsReadable() bool
	ReadNonblocking(buffer []uint8, cancellable Cancellable) int
}

// PollableOutputStream is implemented by Streams that can be polled for
// readiness to write. This can be used when interfacing with a non-GIO API that
// expects UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
type PollableOutputStream interface {
	CanPoll() bool
	CreateSource(cancellable Cancellable) *glib.Source
	IsWritable() bool
	WriteNonblocking(buffer []uint8, cancellable Cancellable) int
	WritevNonblocking(vectors []OutputVector, cancellable Cancellable) (bytesWritten uint, pollableReturn PollableReturn)
}

// Proxy: a #GProxy handles connecting to a remote host via a given type of
// proxy server. It is implemented by the 'gio-proxy' extension point. The
// extensions are named after their proxy protocol name. As an example, a SOCKS5
// proxy implementation can be retrieved with the name 'socks5' using the
// function g_io_extension_point_get_extension_by_name().
type Proxy interface {
	Connect(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable) IOStream
	ConnectAsync(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable, callback AsyncReadyCallback)
	ConnectFinish(result AsyncResult) IOStream
	SupportsHostname() bool
}

// ProxyResolver provides synchronous and asynchronous network proxy resolution.
// Resolver is used within Client through the method
// g_socket_connectable_proxy_enumerate().
//
// Implementations of Resolver based on libproxy and GNOME settings can be found
// in glib-networking. GIO comes with an implementation for use inside Flatpak
// portals.
type ProxyResolver interface {
	IsSupported() bool
	Lookup(uri string, cancellable Cancellable) []string
	LookupAsync(uri string, cancellable Cancellable, callback AsyncReadyCallback)
	LookupFinish(result AsyncResult) []string
}

// RemoteActionGroup: the GRemoteActionGroup interface is implemented by Group
// instances that either transmit action invocations to other processes or
// receive action invocations in the local process from other processes.
//
// The interface has `_full` variants of the two methods on Group used to
// activate actions: g_action_group_activate_action() and
// g_action_group_change_action_state(). These variants allow a "platform data"
// #GVariant to be specified: a dictionary providing context for the action
// invocation (for example: timestamps, startup notification IDs, etc).
//
// BusActionGroup implements ActionGroup. This provides a mechanism to send
// platform data for action invocations over D-Bus.
//
// Additionally, g_dbus_connection_export_action_group() will check if the
// exported Group implements ActionGroup and use the `_full` variants of the
// calls if available. This provides a mechanism by which to receive platform
// data for action invocations that arrive by way of D-Bus.
type RemoteActionGroup interface {
	ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)
	ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)
}

// Seekable is implemented by streams (implementations of Stream or Stream) that
// support seeking.
//
// Seekable streams largely fall into two categories: resizable and fixed-size.
//
// #GSeekable on fixed-sized streams is approximately the same as POSIX lseek()
// on a block device (for example: attempting to seek past the end of the device
// is an error). Fixed streams typically cannot be truncated.
//
// #GSeekable on resizable streams is approximately the same as POSIX lseek() on
// a normal file. Seeking past the end and writing data will usually cause the
// stream to resize by introducing zero bytes.
type Seekable interface {
	CanSeek() bool
	CanTruncate() bool
	Seek(offset int64, _type glib.SeekType, cancellable Cancellable) bool
	Tell() int64
	Truncate(offset int64, cancellable Cancellable) bool
}

// SocketConnectable objects that describe one or more potential socket
// endpoints implement Connectable. Callers can then use
// g_socket_connectable_enumerate() to get a AddressEnumerator to try out each
// socket address in turn until one succeeds, as shown in the sample code below.
//
//    MyConnectionType *
//    connect_to_host (const char    *hostname,
//                     guint16        port,
//                     GCancellable  *cancellable,
//                     GError       **error)
//    {
//      MyConnection *conn = NULL;
//      GSocketConnectable *addr;
//      GSocketAddressEnumerator *enumerator;
//      GSocketAddress *sockaddr;
//      GError *conn_error = NULL;
//
//      addr = g_network_address_new (hostname, port);
//      enumerator = g_socket_connectable_enumerate (addr);
//      g_object_unref (addr);
//
//      // Try each sockaddr until we succeed. Record the first connection error,
//      // but not any further ones (since they'll probably be basically the same
//      // as the first).
//      while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//        {
//          conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
//          g_object_unref (sockaddr);
//        }
//      g_object_unref (enumerator);
//
//      if (conn)
//        {
//          if (conn_error)
//            {
//              // We couldn't connect to the first address, but we succeeded
//              // in connecting to a later address.
//              g_error_free (conn_error);
//            }
//          return conn;
//        }
//      else if (error)
//        {
//          /// Either initial lookup failed, or else the caller cancelled us.
//          if (conn_error)
//            g_error_free (conn_error);
//          return NULL;
//        }
//      else
//        {
//          g_error_propagate (error, conn_error);
//          return NULL;
//        }
//    }
//
type SocketConnectable interface {
	Enumerate() SocketAddressEnumerator
	ProxyEnumerate() SocketAddressEnumerator
	ToString() string
}

// TlsBackend: TLS (Transport Layer Security, aka SSL) and DTLS backend.
type TlsBackend interface {
	GetCertificateType() externglib.Type
	GetClientConnectionType() externglib.Type
	GetDefaultDatabase() TlsDatabase
	GetDtlsClientConnectionType() externglib.Type
	GetDtlsServerConnectionType() externglib.Type
	GetFileDatabaseType() externglib.Type
	GetServerConnectionType() externglib.Type
	SetDefaultDatabase(database TlsDatabase)
	SupportsDtls() bool
	SupportsTls() bool
}

// TlsClientConnection is the client-side subclass of Connection, representing a
// client-side TLS connection.
type TlsClientConnection interface {
	CopySessionState(source TlsClientConnection)
	GetAcceptedCas() *glib.List
	GetServerIdentity() SocketConnectable
	GetUseSsl3() bool
	GetValidationFlags() TlsCertificateFlags
	SetServerIdentity(identity SocketConnectable)
	SetUseSsl3(useSsl3 bool)
	SetValidationFlags(flags TlsCertificateFlags)
}

// Volume: the #GVolume interface represents user-visible objects that can be
// mounted. Note, when porting from GnomeVFS, #GVolume is the moral equivalent
// of VFSDrive.
//
// Mounting a #GVolume instance is an asynchronous operation. For more
// information about asynchronous operations, see Result and #GTask. To mount a
// #GVolume, first call g_volume_mount() with (at least) the #GVolume instance,
// optionally a Operation object and a ReadyCallback.
//
// Typically, one will only want to pass nil for the Operation if automounting
// all volumes when a desktop session starts since it's not desirable to put up
// a lot of dialogs asking for credentials.
//
// The callback will be fired when the operation has resolved (either with
// success or failure), and a Result instance will be passed to the callback.
// That callback should then call g_volume_mount_finish() with the #GVolume
// instance and the Result data to see if the operation was completed
// successfully. If an @error is present when g_volume_mount_finish() is called,
// then it will be filled with any error information.
//
//
// Volume Identifiers
//
// It is sometimes necessary to directly access the underlying operating system
// object behind a volume (e.g. for passing a volume to an application via the
// commandline). For this purpose, GIO allows to obtain an 'identifier' for the
// volume. There can be different kinds of identifiers, such as Hal UDIs,
// filesystem labels, traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO
// uses predefined strings as names for the different kinds of identifiers:
// VOLUME_IDENTIFIER_KIND_UUID, VOLUME_IDENTIFIER_KIND_LABEL, etc. Use
// g_volume_get_identifier() to obtain an identifier for a volume.
//
//    Note that VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available when the gvfs hal volume monitor is in use. Other volume monitors will generally be able to provide the VOLUME_IDENTIFIER_KIND_UNIX_DEVICE identifier, which can be used to obtain a hal device by means of libhal_manager_find_device_string_match().
type Volume interface {
	CanEject() bool
	CanMount() bool
	Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	EjectFinish(result AsyncResult) bool
	EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	EjectWithOperationFinish(result AsyncResult) bool
	EnumerateIdentifiers() []string
	GetActivationRoot() File
	GetDrive() Drive
	GetIcon() Icon
	GetIdentifier(kind string) string
	GetMount() Mount
	GetName() string
	GetSortKey() string
	GetSymbolicIcon() Icon
	GetUuid() string
	Mount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	MountFinish(result AsyncResult) bool
	ShouldAutomount() bool
}

// ActionEntry: this struct defines a single action. It is for use with
// g_action_map_add_action_entries().
//
// The order of the items in the structure are intended to reflect frequency of
// use. It is permissible to use an incomplete initialiser in order to leave
// some of the later values as nil. All values after @name are optional.
// Additional optional fields may be added in the future.
//
// See g_action_map_add_action_entries() for an example.
type ActionEntry struct {
	// Name: the name of the action
	Name string
	// ParameterType: the type of the parameter that must be passed to the
	// activate function for this action, given as a single GVariant type string
	// (or nil for no parameter)
	ParameterType string
	// State: the initial state for this action, given in [GVariant text
	// format][gvariant-text]. The state is parsed with no extra type
	// information, so type tags must be added to the string if they are
	// necessary. Stateless actions should give nil here.
	State string

	native *C.GActionEntry
}

// WrapActionEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapActionEntry(ptr unsafe.Pointer) *ActionEntry {
	p := (*C.GActionEntry)(ptr)
	v := ActionEntry{native: p}

	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	p.parameter_type = C.GoString(v.ParameterType)
	defer C.free(unsafe.Pointer(p.parameter_type))
	p.state = C.GoString(v.State)
	defer C.free(unsafe.Pointer(p.state))

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*ActionEntry).free)

	return &v
}

func marshalActionEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapActionEntry(unsafe.Pointer(b))
}

func (a *ActionEntry) free() {
	C.free(unsafe.Pointer(a.native))
}

// Native returns the pointer to *C.GActionEntry. The caller is expected to
// cast.
func (a *ActionEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(a.native)
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Key: the name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
	Key string
	// Value: the value of the annotation.
	Value string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusAnnotationInfo
}

// WrapDBusAnnotationInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusAnnotationInfo(ptr unsafe.Pointer) *DBusAnnotationInfo {
	p := (*C.GDBusAnnotationInfo)(ptr)
	var v DBusAnnotationInfo

	v.RefCount = int(p.ref_count)
	p.key = C.GoString(v.Key)
	defer C.free(unsafe.Pointer(p.key))
	p.value = C.GoString(v.Value)
	defer C.free(unsafe.Pointer(p.value))
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusAnnotationInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusAnnotationInfo. The caller is expected to
// cast.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: name of the argument, e.g. @unix_user_id.
	Name string
	// Signature d-Bus signature of the argument (a single complete type).
	Signature string
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusArgInfo
}

// WrapDBusArgInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusArgInfo(ptr unsafe.Pointer) *DBusArgInfo {
	p := (*C.GDBusArgInfo)(ptr)
	var v DBusArgInfo

	v.RefCount = int(p.ref_count)
	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	p.signature = C.GoString(v.Signature)
	defer C.free(unsafe.Pointer(p.signature))
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusArgInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusArgInfo. The caller is expected to
// cast.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
type DBusErrorEntry struct {
	// ErrorCode: an error code.
	ErrorCode int
	// DbusErrorName: the D-Bus error name to associate with @error_code.
	DbusErrorName string

	native *C.GDBusErrorEntry
}

// WrapDBusErrorEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusErrorEntry(ptr unsafe.Pointer) *DBusErrorEntry {
	p := (*C.GDBusErrorEntry)(ptr)
	var v DBusErrorEntry

	v.ErrorCode = int(p.error_code)
	p.dbus_error_name = C.GoString(v.DbusErrorName)
	defer C.free(unsafe.Pointer(p.dbus_error_name))

	return &v
}

func marshalDBusErrorEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusErrorEntry(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusErrorEntry. The caller is expected to
// cast.
func (d *DBusErrorEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus interface, e.g.
	// "org.freedesktop.DBus.Properties".
	Name string
	// Methods: a pointer to a nil-terminated array of pointers to BusMethodInfo
	// structures or nil if there are no methods.
	Methods []*DBusMethodInfo
	// Signals: a pointer to a nil-terminated array of pointers to BusSignalInfo
	// structures or nil if there are no signals.
	Signals []*DBusSignalInfo
	// Properties: a pointer to a nil-terminated array of pointers to
	// BusPropertyInfo structures or nil if there are no properties.
	Properties []*DBusPropertyInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusInterfaceInfo
}

// WrapDBusInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceInfo(ptr unsafe.Pointer) *DBusInterfaceInfo {
	p := (*C.GDBusInterfaceInfo)(ptr)
	var v DBusInterfaceInfo

	v.RefCount = int(p.ref_count)
	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	{
		var length uint
		for p := unsafe.Pointer(p.methods); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Methods = make([]*DBusMethodInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusMethodInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.methods)) + i))
			v.Methods[i] = gio.WrapDBusMethodInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.signals); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Signals = make([]*DBusSignalInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusSignalInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.signals)) + i))
			v.Signals[i] = gio.WrapDBusSignalInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.properties); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Properties = make([]*DBusPropertyInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusPropertyInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.properties)) + i))
			v.Properties[i] = gio.WrapDBusPropertyInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusInterfaceInfo. The caller is expected to
// cast.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
//
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	// MethodCall: function for handling incoming method calls.
	MethodCall DBusInterfaceMethodCallFunc
	// GetProperty: function for getting a property.
	GetProperty DBusInterfaceGetPropertyFunc
	// SetProperty: function for setting a property.
	SetProperty DBusInterfaceSetPropertyFunc

	native *C.GDBusInterfaceVTable
}

// WrapDBusInterfaceVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceVTable(ptr unsafe.Pointer) *DBusInterfaceVTable {
	p := (*C.GDBusInterfaceVTable)(ptr)
	v := DBusInterfaceVTable{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*DBusInterfaceVTable).free)

	return &v
}

func marshalDBusInterfaceVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceVTable(unsafe.Pointer(b))
}

func (d *DBusInterfaceVTable) free() {
	C.free(unsafe.Pointer(d.native))
}

// Native returns the pointer to *C.GDBusInterfaceVTable. The caller is expected to
// cast.
func (d *DBusInterfaceVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus method, e.g. @RequestName.
	Name string
	// InArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no in arguments.
	InArgs []*DBusArgInfo
	// OutArgs: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no out arguments.
	OutArgs []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusMethodInfo
}

// WrapDBusMethodInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusMethodInfo(ptr unsafe.Pointer) *DBusMethodInfo {
	p := (*C.GDBusMethodInfo)(ptr)
	var v DBusMethodInfo

	v.RefCount = int(p.ref_count)
	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	{
		var length uint
		for p := unsafe.Pointer(p.in_args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.InArgs = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.in_args)) + i))
			v.InArgs[i] = gio.WrapDBusArgInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.out_args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.OutArgs = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.out_args)) + i))
			v.OutArgs[i] = gio.WrapDBusArgInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusMethodInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusMethodInfo. The caller is expected to
// cast.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Path: the path of the node or nil if omitted. Note that this may be a
	// relative path. See the D-Bus specification for more details.
	Path string
	// Interfaces: a pointer to a nil-terminated array of pointers to
	// BusInterfaceInfo structures or nil if there are no interfaces.
	Interfaces []*DBusInterfaceInfo
	// Nodes: a pointer to a nil-terminated array of pointers to BusNodeInfo
	// structures or nil if there are no nodes.
	Nodes []*DBusNodeInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusNodeInfo
}

// WrapDBusNodeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusNodeInfo(ptr unsafe.Pointer) *DBusNodeInfo {
	p := (*C.GDBusNodeInfo)(ptr)
	var v DBusNodeInfo

	v.RefCount = int(p.ref_count)
	p.path = C.GoString(v.Path)
	defer C.free(unsafe.Pointer(p.path))
	{
		var length uint
		for p := unsafe.Pointer(p.interfaces); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Interfaces = make([]*DBusInterfaceInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusInterfaceInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.interfaces)) + i))
			v.Interfaces[i] = gio.WrapDBusInterfaceInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.nodes); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Nodes = make([]*DBusNodeInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusNodeInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.nodes)) + i))
			v.Nodes[i] = gio.WrapDBusNodeInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusNodeInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusNodeInfo. The caller is expected to
// cast.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

func NewDBusNodeInfo(xmlData string) *DBusNodeInfo

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus property, e.g. "SupportedFilesystems".
	Name string
	// Signature: the D-Bus signature of the property (a single complete type).
	Signature string
	// Flags access control flags for the property.
	Flags DBusPropertyInfoFlags
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusPropertyInfo
}

// WrapDBusPropertyInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusPropertyInfo(ptr unsafe.Pointer) *DBusPropertyInfo {
	p := (*C.GDBusPropertyInfo)(ptr)
	var v DBusPropertyInfo

	v.RefCount = int(p.ref_count)
	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	p.signature = C.GoString(v.Signature)
	defer C.free(unsafe.Pointer(p.signature))
	v.Flags = DBusPropertyInfoFlags(p.flags)
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusPropertyInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusPropertyInfo. The caller is expected to
// cast.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	// RefCount: the reference count or -1 if statically allocated.
	RefCount int
	// Name: the name of the D-Bus signal, e.g. "NameOwnerChanged".
	Name string
	// Args: a pointer to a nil-terminated array of pointers to BusArgInfo
	// structures or nil if there are no arguments.
	Args []*DBusArgInfo
	// Annotations: a pointer to a nil-terminated array of pointers to
	// BusAnnotationInfo structures or nil if there are no annotations.
	Annotations []*DBusAnnotationInfo

	native *C.GDBusSignalInfo
}

// WrapDBusSignalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSignalInfo(ptr unsafe.Pointer) *DBusSignalInfo {
	p := (*C.GDBusSignalInfo)(ptr)
	var v DBusSignalInfo

	v.RefCount = int(p.ref_count)
	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	{
		var length uint
		for p := unsafe.Pointer(p.args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Args = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.args)) + i))
			v.Args[i] = gio.WrapDBusArgInfo(src)
		}
	}
	{
		var length uint
		for p := unsafe.Pointer(p.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		v.Annotations = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p.annotations)) + i))
			v.Annotations[i] = gio.WrapDBusAnnotationInfo(src)
		}
	}

	return &v
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSignalInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GDBusSignalInfo. The caller is expected to
// cast.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	// Enumerate: function for enumerating child nodes.
	Enumerate DBusSubtreeEnumerateFunc
	// Introspect: function for introspecting a child node.
	Introspect DBusSubtreeIntrospectFunc
	// Dispatch: function for dispatching a remote call on a child node.
	Dispatch DBusSubtreeDispatchFunc

	native *C.GDBusSubtreeVTable
}

// WrapDBusSubtreeVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSubtreeVTable(ptr unsafe.Pointer) *DBusSubtreeVTable {
	p := (*C.GDBusSubtreeVTable)(ptr)
	v := DBusSubtreeVTable{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*DBusSubtreeVTable).free)

	return &v
}

func marshalDBusSubtreeVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSubtreeVTable(unsafe.Pointer(b))
}

func (d *DBusSubtreeVTable) free() {
	C.free(unsafe.Pointer(d.native))
}

// Native returns the pointer to *C.GDBusSubtreeVTable. The caller is expected to
// cast.
func (d *DBusSubtreeVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(d.native)
}

// FileAttributeInfo: information about a specific attribute.
type FileAttributeInfo struct {
	// Name: the name of the attribute.
	Name string
	// Type: the AttributeType type of the attribute.
	Type FileAttributeType
	// Flags: a set of AttributeInfoFlags.
	Flags FileAttributeInfoFlags

	native *C.GFileAttributeInfo
}

// WrapFileAttributeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfo(ptr unsafe.Pointer) *FileAttributeInfo {
	p := (*C.GFileAttributeInfo)(ptr)
	var v FileAttributeInfo

	p.name = C.GoString(v.Name)
	defer C.free(unsafe.Pointer(p.name))
	v.Type = FileAttributeType(p._type)
	v.Flags = FileAttributeInfoFlags(p.flags)

	return &v
}

func marshalFileAttributeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeInfo(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GFileAttributeInfo. The caller is expected to
// cast.
func (f *FileAttributeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

// FileAttributeInfoList acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
type FileAttributeInfoList struct {
	// Infos: an array of AttributeInfos.
	Infos *FileAttributeInfo
	// NInfos: the number of values in the array.
	NInfos int

	native *C.GFileAttributeInfoList
}

// WrapFileAttributeInfoList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfoList(ptr unsafe.Pointer) *FileAttributeInfoList {
	p := (*C.GFileAttributeInfoList)(ptr)
	var v FileAttributeInfoList

	v.Infos = gio.WrapFileAttributeInfo(p.infos)
	v.NInfos = int(p.n_infos)

	return &v
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeInfoList(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GFileAttributeInfoList. The caller is expected to
// cast.
func (f *FileAttributeInfoList) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeInfoList() *FileAttributeInfoList

// FileAttributeMatcher determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

// WrapFileAttributeMatcher wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeMatcher(ptr unsafe.Pointer) *FileAttributeMatcher {
	p := (*C.GFileAttributeMatcher)(ptr)
	v := FileAttributeMatcher{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*FileAttributeMatcher).free)

	return &v
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeMatcher(unsafe.Pointer(b))
}

func (f *FileAttributeMatcher) free() {
	C.free(unsafe.Pointer(f.native))
}

// Native returns the pointer to *C.GFileAttributeMatcher. The caller is expected to
// cast.
func (f *FileAttributeMatcher) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	// Address: return location for a Address, or nil
	Address SocketAddress
	// Vectors: pointer to an array of input vectors
	Vectors []InputVector
	// BytesReceived: will be set to the number of bytes that have been received
	BytesReceived uint
	// Flags: collection of MsgFlags for the received message, outputted by the
	// call
	Flags int
	// ControlMessages: return location for a caller-allocated array of
	// ControlMessages, or nil
	ControlMessages []SocketControlMessage

	native *C.GInputMessage
}

// WrapInputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputMessage(ptr unsafe.Pointer) *InputMessage {
	p := (*C.GInputMessage)(ptr)
	var v InputMessage

	v.Address = gio.WrapSocketAddress(externglib.Take(unsafe.Pointer(p.address.Native())))
	{
		v.Vectors = make([]InputVector, p.num_vectors)
		for i := 0; i < uintptr(p.num_vectors); i++ {
			src := (C.GInputVector)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			v.Vectors[i] = gio.WrapInputVector(src)
		}
	}
	v.BytesReceived = uint(p.bytes_received)
	v.Flags = int(p.flags)
	{
		v.ControlMessages = make([]SocketControlMessage, p.num_control_messages)
		for i := 0; i < uintptr(p.num_control_messages); i++ {
			src := (**C.GSocketControlMessage)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			v.ControlMessages[i] = gio.WrapSocketControlMessage(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	return &v
}

func marshalInputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInputMessage(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GInputMessage. The caller is expected to
// cast.
func (i *InputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
type InputVector struct {
	// Buffer: pointer to a buffer where data will be written.
	Buffer interface{}
	// Size: the available size in @buffer.
	Size uint

	native *C.GInputVector
}

// WrapInputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputVector(ptr unsafe.Pointer) *InputVector {
	p := (*C.GInputVector)(ptr)
	var v InputVector

	v.Buffer = box.Get(uintptr(p.buffer))
	v.Size = uint(p.size)

	return &v
}

func marshalInputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInputVector(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GInputVector. The caller is expected to
// cast.
func (i *InputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(i.native)
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
type OutputMessage struct {
	// Address: a Address, or nil
	Address SocketAddress
	// Vectors: pointer to an array of output vectors
	Vectors *OutputVector
	// NumVectors: the number of output vectors pointed to by @vectors.
	NumVectors uint
	// BytesSent: initialize to 0. Will be set to the number of bytes that have
	// been sent
	BytesSent uint
	// ControlMessages: a pointer to an array of ControlMessages, or nil.
	ControlMessages []SocketControlMessage

	native *C.GOutputMessage
}

// WrapOutputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputMessage(ptr unsafe.Pointer) *OutputMessage {
	p := (*C.GOutputMessage)(ptr)
	var v OutputMessage

	v.Address = gio.WrapSocketAddress(externglib.Take(unsafe.Pointer(p.address.Native())))
	v.Vectors = gio.WrapOutputVector(p.vectors)
	v.NumVectors = uint(p.num_vectors)
	v.BytesSent = uint(p.bytes_sent)
	{
		v.ControlMessages = make([]SocketControlMessage, p.num_control_messages)
		for i := 0; i < uintptr(p.num_control_messages); i++ {
			src := (*C.GSocketControlMessage)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			v.ControlMessages[i] = gio.WrapSocketControlMessage(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}

	return &v
}

func marshalOutputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOutputMessage(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GOutputMessage. The caller is expected to
// cast.
func (o *OutputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
type OutputVector struct {
	// Buffer: pointer to a buffer of data to read.
	Buffer interface{}
	// Size: the size of @buffer.
	Size uint

	native *C.GOutputVector
}

// WrapOutputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputVector(ptr unsafe.Pointer) *OutputVector {
	p := (*C.GOutputVector)(ptr)
	var v OutputVector

	v.Buffer = box.Get(uintptr(p.buffer))
	v.Size = uint(p.size)

	return &v
}

func marshalOutputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOutputVector(unsafe.Pointer(b))
}

// Native returns the pointer to *C.GOutputVector. The caller is expected to
// cast.
func (o *OutputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(o.native)
}

// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
//
// `to-pixdata` which will use the gdk-pixbuf-pixdata command to convert images
// to the GdkPixdata format, which allows you to create pixbufs directly using
// the data inside the resource file, rather than an (uncompressed) copy of it.
// For this, the gdk-pixbuf-pixdata program must be in the PATH, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// gdk-pixbuf-pixdata executable; otherwise the resource compiler will abort.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
// An example resource description:
//
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//    ]|
//
//    This will create a resource bundle with the following files:
//    |[
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//    ]|
//
//    Note that all resources in the process share the same namespace, so use Java-style
//    path prefixes (like in the above example) to avoid conflicts.
//
//    You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
//    binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
//    --generate-header arguments to create a source file and header to link directly into your application.
//    This will generate `get_resource()`, `register_resource()` and
//    `unregister_resource()` functions, prefixed by the `--c-name` argument passed
//    to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
//    the generated #GResource object. The register and unregister functions
//    register the resource so its files can be accessed using
//    g_resources_lookup_data().
//
//    Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
//    using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
//    to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
//    the resource data.
//
//    Some higher-level APIs, such as Application, will automatically load
//    resources from certain well-known paths in the resource namespace as a
//    convenience. See the documentation for those APIs for details.
//
//    There are two forms of the generated source, the default version uses the compiler support for constructor
//    and destructor functions (where available) to automatically create and register the #GResource on startup
//    or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
//    instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
//    even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
//
//    Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
//    during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
//    when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
//    are for your own resources, and resource data is often used once, during parsing, and then released.
//
//    When debugging a program or testing a change to an installed version, it is often useful to be able to
//    replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
//    purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
//    resources with replacements from the filesystem.  It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
//    during resource lookups.
//
//    A substitution has the form
//
//    |[
//       /org/gtk/libgtk=/home/desrt/gtk-overlay
//
//
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
type Resource struct {
	native *C.GResource
}

// WrapResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapResource(ptr unsafe.Pointer) *Resource {
	p := (*C.GResource)(ptr)
	v := Resource{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*Resource).free)

	return &v
}

func marshalResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapResource(unsafe.Pointer(b))
}

func (r *Resource) free() {
	C.free(unsafe.Pointer(r.native))
}

// Native returns the pointer to *C.GResource. The caller is expected to
// cast.
func (r *Resource) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

func NewResource(data *glib.Bytes) *Resource

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema struct {
	native *C.GSettingsSchema
}

// WrapSettingsSchema wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchema(ptr unsafe.Pointer) *SettingsSchema {
	p := (*C.GSettingsSchema)(ptr)
	v := SettingsSchema{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*SettingsSchema).free)

	return &v
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchema(unsafe.Pointer(b))
}

func (s *SettingsSchema) free() {
	C.free(unsafe.Pointer(s.native))
}

// Native returns the pointer to *C.GSettingsSchema. The caller is expected to
// cast.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
type SettingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

// WrapSettingsSchemaKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaKey(ptr unsafe.Pointer) *SettingsSchemaKey {
	p := (*C.GSettingsSchemaKey)(ptr)
	v := SettingsSchemaKey{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*SettingsSchemaKey).free)

	return &v
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaKey(unsafe.Pointer(b))
}

func (s *SettingsSchemaKey) free() {
	C.free(unsafe.Pointer(s.native))
}

// Native returns the pointer to *C.GSettingsSchemaKey. The caller is expected to
// cast.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

// WrapSettingsSchemaSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaSource(ptr unsafe.Pointer) *SettingsSchemaSource {
	p := (*C.GSettingsSchemaSource)(ptr)
	v := SettingsSchemaSource{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*SettingsSchemaSource).free)

	return &v
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaSource(unsafe.Pointer(b))
}

func (s *SettingsSchemaSource) free() {
	C.free(unsafe.Pointer(s.native))
}

// Native returns the pointer to *C.GSettingsSchemaSource. The caller is expected to
// cast.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSettingsSchemaSource(directory string, parent *SettingsSchemaSource, trusted bool) *SettingsSchemaSource

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
type SrvTarget struct {
	native *C.GSrvTarget
}

// WrapSrvTarget wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSrvTarget(ptr unsafe.Pointer) *SrvTarget {
	p := (*C.GSrvTarget)(ptr)
	v := SrvTarget{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*SrvTarget).free)

	return &v
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSrvTarget(unsafe.Pointer(b))
}

func (s *SrvTarget) free() {
	C.free(unsafe.Pointer(s.native))
}

// Native returns the pointer to *C.GSrvTarget. The caller is expected to
// cast.
func (s *SrvTarget) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget

// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
type StaticResource struct {
	native *C.GStaticResource
}

// WrapStaticResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStaticResource(ptr unsafe.Pointer) *StaticResource {
	p := (*C.GStaticResource)(ptr)
	v := StaticResource{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*StaticResource).free)

	return &v
}

func marshalStaticResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStaticResource(unsafe.Pointer(b))
}

func (s *StaticResource) free() {
	C.free(unsafe.Pointer(s.native))
}

// Native returns the pointer to *C.GStaticResource. The caller is expected to
// cast.
func (s *StaticResource) Native() unsafe.Pointer {
	return unsafe.Pointer(s.native)
}

// UnixMountEntry defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native *C.GUnixMountEntry
}

// WrapUnixMountEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountEntry(ptr unsafe.Pointer) *UnixMountEntry {
	p := (*C.GUnixMountEntry)(ptr)
	v := UnixMountEntry{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*UnixMountEntry).free)

	return &v
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountEntry(unsafe.Pointer(b))
}

func (u *UnixMountEntry) free() {
	C.free(unsafe.Pointer(u.native))
}

// Native returns the pointer to *C.GUnixMountEntry. The caller is expected to
// cast.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// UnixMountPoint defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native *C.GUnixMountPoint
}

// WrapUnixMountPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountPoint(ptr unsafe.Pointer) *UnixMountPoint {
	p := (*C.GUnixMountPoint)(ptr)
	v := UnixMountPoint{native: p}

	runtime.SetFinalizer(&v, nil)
	runtime.SetFinalizer(&v, (*UnixMountPoint).free)

	return &v
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountPoint(unsafe.Pointer(b))
}

func (u *UnixMountPoint) free() {
	C.free(unsafe.Pointer(u.native))
}

// Native returns the pointer to *C.GUnixMountPoint. The caller is expected to
// cast.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(u.native)
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

type appInfoMonitor struct {
	*externglib.Object
}

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return appInfoMonitor{*externglib.Object{obj}}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext interface {
	gextras.Objector

	// Display gets the display string for the @context. This is used to ensure
	// new applications are started on the same display as the launching
	// application, by setting the `DISPLAY` environment variable.
	Display(info AppInfo, files *glib.List) string
	// Environment gets the complete environment variable list to be passed to
	// the child process when @context is used to launch an application. This is
	// a nil-terminated array of strings, where each string has the form
	// `KEY=VALUE`.
	Environment() []string
	// StartupNotifyID initiates startup notification for the application and
	// returns the `DESKTOP_STARTUP_ID` for the launched operation, if
	// supported.
	//
	// Startup notification IDs are defined in the FreeDesktop.Org Startup
	// Notifications standard
	// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
	StartupNotifyID(info AppInfo, files *glib.List) string
	// LaunchFailed: called when an application has failed to launch, so that it
	// can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	LaunchFailed(startupNotifyID string)
	// Setenv arranges for @variable to be set to @value in the child's
	// environment when @context is used to launch an application.
	Setenv(variable string, value string)
	// Unsetenv arranges for @variable to be unset in the child's environment
	// when @context is used to launch an application.
	Unsetenv(variable string)
}

type appLaunchContext struct {
	*externglib.Object
}

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return appLaunchContext{*externglib.Object{obj}}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

func NewAppLaunchContext() AppLaunchContext

func (a appLaunchContext) Display(info AppInfo, files *glib.List) string

func (a appLaunchContext) Environment() []string

func (a appLaunchContext) StartupNotifyID(info AppInfo, files *glib.List) string

func (a appLaunchContext) LaunchFailed(startupNotifyID string)

func (a appLaunchContext) Setenv(variable string, value string)

func (a appLaunchContext) Unsetenv(variable string)

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some ‘platform data’ from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application interface {
	gextras.Objector

	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate()
	// AddMainOption: add an option to be handled by @application.
	//
	// Calling this function is the equivalent of calling
	// g_application_add_main_option_entries() with a single Entry that has its
	// arg_data member set to nil.
	//
	// The parsed arguments will be packed into a Dict which is passed to
	// #GApplication::handle-local-options. If
	// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
	// the primary instance. See g_application_add_main_option_entries() for
	// more details.
	//
	// See Entry for more documentation of the arguments.
	AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)
	// AddOptionGroup adds a Group to the commandline handling of @application.
	//
	// This function is comparable to g_option_context_add_group().
	//
	// Unlike g_application_add_main_option_entries(), this function does not
	// deal with nil @arg_data and never transmits options to the primary
	// instance.
	//
	// The reason for that is because, by the time the options arrive at the
	// primary instance, it is typically too late to do anything with them.
	// Taking the GTK option group as an example: GTK will already have been
	// initialised by the time the #GApplication::command-line handler runs. In
	// the case that this is not the first-running instance of the application,
	// the existing instance may already have been running for a very long time.
	//
	// This means that the options from Group are only really usable in the case
	// that the instance of the application being run is the first instance.
	// Passing options like `--display=` or `--gdk-debug=` on future runs will
	// have no effect on the existing primary instance.
	//
	// Calling this function will cause the options in the supplied option group
	// to be parsed, but it does not cause you to be "opted in" to the new
	// functionality whereby unrecognised options are rejected even if
	// G_APPLICATION_HANDLES_COMMAND_LINE was given.
	AddOptionGroup(group *glib.OptionGroup)
	// BindBusyProperty marks @application as busy (see
	// g_application_mark_busy()) while @property on @object is true.
	//
	// The binding holds a reference to @application while it is active, but not
	// to @object. Instead, the binding is destroyed when @object is finalized.
	BindBusyProperty(object gextras.Objector, property string)
	// ApplicationID gets the unique identifier for @application.
	ApplicationID() string
	// DbusConnection gets the BusConnection being used by the application, or
	// nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the BusConnection being used for uniqueness and communication with
	// the desktop environment and other instances of the application.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DbusConnection() DBusConnection
	// DbusObjectPath gets the D-Bus object path being used by the application,
	// or nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the D-Bus object path that #GApplication is using. If the
	// application is the primary instance then there is an object published at
	// this path. If the application is not the primary instance then the result
	// of this function is undefined.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DbusObjectPath() string
	// Flags gets the flags for @application.
	//
	// See Flags.
	Flags() ApplicationFlags
	// InactivityTimeout gets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	InactivityTimeout() uint
	// IsBusy gets the application's current busy state, as set through
	// g_application_mark_busy() or g_application_bind_busy_property().
	IsBusy() bool
	// IsRegistered checks if @application is registered.
	//
	// An application is registered if g_application_register() has been
	// successfully called.
	IsRegistered() bool
	// IsRemote checks if @application is remote.
	//
	// If @application is remote then it means that another instance of
	// application already exists (the 'primary' instance). Calls to perform
	// actions on @application will result in the actions being performed by the
	// primary instance.
	//
	// The value of this property cannot be accessed before
	// g_application_register() has been called. See
	// g_application_get_is_registered().
	IsRemote() bool
	// ResourceBasePath gets the resource base path of @application.
	//
	// See g_application_set_resource_base_path() for more information.
	ResourceBasePath() string
	// Hold increases the use count of @application.
	//
	// Use this function to indicate that the application has a reason to
	// continue to run. For example, g_application_hold() is called by GTK+ when
	// a toplevel window is on the screen.
	//
	// To cancel the hold, call g_application_release().
	Hold()
	// MarkBusy increases the busy count of @application.
	//
	// Use this function to indicate that the application is busy, for instance
	// while a long running operation is pending.
	//
	// The busy state will be exposed to other processes, so a session shell
	// will use that information to indicate the state to the user (e.g. with a
	// spinner).
	//
	// To cancel the busy indication, use g_application_unmark_busy().
	MarkBusy()
	// Open opens the given files.
	//
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	//
	// @n_files must be greater than zero.
	//
	// @hint is simply passed through to the ::open signal. It is intended to be
	// used by applications that have multiple modes for opening files (eg:
	// "view" vs "edit", etc). Unless you have a need for this functionality,
	// you should use "".
	//
	// The application must be registered before calling this function and it
	// must have the G_APPLICATION_HANDLES_OPEN flag set.
	Open(files []File, hint string)
	// Quit: immediately quits the application.
	//
	// Upon return to the mainloop, g_application_run() will return, calling
	// only the 'shutdown' function before doing so.
	//
	// The hold count is ignored. Take care if your code has called
	// g_application_hold() on the application and is therefore still expecting
	// it to exist. (Note that you may have called g_application_hold()
	// indirectly, for example through gtk_application_add_window().)
	//
	// The result of calling g_application_run() again after it returns is
	// unspecified.
	Quit()
	// Register attempts registration of the application.
	//
	// This is the point at which the application discovers if it is the primary
	// instance or merely acting as a remote for an already-existing primary
	// instance. This is implemented by attempting to acquire the application
	// identifier as a unique bus name on the session bus using GDBus.
	//
	// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
	// then this process will always become the primary instance.
	//
	// Due to the internal architecture of GDBus, method calls can be dispatched
	// at any time (even if a main loop is not running). For this reason, you
	// must ensure that any object paths that you wish to register are
	// registered before calling this function.
	//
	// If the application has already been registered then true is returned with
	// no work performed.
	//
	// The #GApplication::startup signal is emitted if registration succeeds and
	// @application is the primary instance (including the non-unique case).
	//
	// In the event of an error (such as @cancellable being cancelled, or a
	// failure to connect to the session bus), false is returned and @error is
	// set appropriately.
	//
	// Note: the return value of this function is not an indicator that this
	// instance is or is not the primary instance of the application. See
	// g_application_get_is_remote() for that.
	Register(cancellable Cancellable) bool
	// Release: decrease the use count of @application.
	//
	// When the use count reaches zero, the application will stop running.
	//
	// Never call this function except to cancel the effect of a previous call
	// to g_application_hold().
	Release()
	// Run runs the application.
	//
	// This function is intended to be run from main() and its return value is
	// intended to be returned by main(). Although you are expected to pass the
	// @argc, @argv parameters from main() to this function, it is possible to
	// pass nil if @argv is not available or commandline handling is not
	// required. Note that on Windows, @argc and @argv are ignored, and
	// g_win32_get_command_line() is called internally (for proper support of
	// Unicode commandline arguments).
	//
	// #GApplication will attempt to parse the commandline arguments. You can
	// add commandline flags to the list of recognised options by way of
	// g_application_add_main_option_entries(). After this, the
	// #GApplication::handle-local-options signal is emitted, from which the
	// application can inspect the values of its Entrys.
	//
	// #GApplication::handle-local-options is a good place to handle options
	// such as `--version`, where an immediate reply from the local process is
	// desired (instead of communicating with an already-running instance). A
	// #GApplication::handle-local-options handler can stop further processing
	// by returning a non-negative value, which then becomes the exit status of
	// the process.
	//
	// What happens next depends on the flags: if
	// G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
	// commandline arguments are sent to the primary instance, where a
	// #GApplication::command-line signal is emitted. Otherwise, the remaining
	// commandline arguments are assumed to be a list of files. If there are no
	// files listed, the application is activated via the
	// #GApplication::activate signal. If there are one or more files, and
	// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via
	// the #GApplication::open signal.
	//
	// If you are interested in doing more complicated local handling of the
	// commandline then you should implement your own #GApplication subclass and
	// override local_command_line(). In this case, you most likely want to
	// return true from your local_command_line() implementation to suppress the
	// default handling. See
	// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
	// example.
	//
	// If, after the above is done, the use count of the application is zero
	// then the exit status is returned immediately. If the use count is
	// non-zero then the default main context is iterated until the use count
	// falls to zero, at which point 0 is returned.
	//
	// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run
	// for as much as 10 seconds with a use count of zero while waiting for the
	// message that caused the activation to arrive. After that, if the use
	// count falls to zero the application will exit immediately, except in the
	// case that g_application_set_inactivity_timeout() is in use.
	//
	// This function sets the prgname (g_set_prgname()), if not already set, to
	// the basename of argv[0].
	//
	// Much like g_main_loop_run(), this function will acquire the main context
	// for the duration that the application is running.
	//
	// Since 2.40, applications that are not explicitly flagged as services or
	// launchers (ie: neither G_APPLICATION_IS_SERVICE or
	// G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
	// default handler for local_command_line) if "--gapplication-service" was
	// given in the command line. If this flag is present then normal
	// commandline processing is interrupted and the G_APPLICATION_IS_SERVICE
	// flag is set. This provides a "compromise" solution whereby running an
	// application directly from the commandline will invoke it in the normal
	// way (which can be useful for debugging) while still allowing applications
	// to be D-Bus activated in service mode. The D-Bus service file should
	// invoke the executable with "--gapplication-service" as the sole
	// commandline argument. This approach is suitable for use by most graphical
	// applications but should not be used from applications like editors that
	// need precise control over when processes invoked via the commandline will
	// exit and what their exit status will be.
	Run(argc int, argv []string) int
	// SendNotification sends a notification on behalf of @application to the
	// desktop shell. There is no guarantee that the notification is displayed
	// immediately, or even at all.
	//
	// Notifications may persist after the application exits. It will be
	// D-Bus-activated when the notification or one of its actions is activated.
	//
	// Modifying @notification after this call has no effect. However, the
	// object can be reused for a later call to this function.
	//
	// @id may be any string that uniquely identifies the event for the
	// application. It does not need to be in any special format. For example,
	// "new-message" might be appropriate for a notification about new messages.
	//
	// If a previous notification was sent with the same @id, it will be
	// replaced with @notification and shown again as if it was a new
	// notification. This works even for notifications sent from a previous
	// execution of the application, as long as @id is the same string.
	//
	// @id may be nil, but it is impossible to replace or withdraw notifications
	// without an id.
	//
	// If @notification is no longer relevant, it can be withdrawn with
	// g_application_withdraw_notification().
	SendNotification(id string, notification Notification)
	// SetActionGroup: this used to be how actions were associated with a
	// #GApplication. Now there is Map for that.
	SetActionGroup(actionGroup ActionGroup)
	// SetApplicationID sets the unique identifier for @application.
	//
	// The application id can only be modified if @application has not yet been
	// registered.
	//
	// If non-nil, the application id must be valid. See
	// g_application_id_is_valid().
	SetApplicationID(applicationID string)
	// SetDefault sets or unsets the default application for the process, as
	// returned by g_application_get_default().
	//
	// This function does not take its own reference on @application. If
	// @application is destroyed then the default application will revert back
	// to nil.
	SetDefault()
	// SetFlags sets the flags for @application.
	//
	// The flags can only be modified if @application has not yet been
	// registered.
	//
	// See Flags.
	SetFlags(flags ApplicationFlags)
	// SetInactivityTimeout sets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	//
	// This call has no side effects of its own. The value set here is only used
	// for next time g_application_release() drops the use count to zero. Any
	// timeouts currently in progress are not impacted.
	SetInactivityTimeout(inactivityTimeout uint)
	// SetOptionContextDescription adds a description to the @application option
	// context.
	//
	// See g_option_context_set_description() for more information.
	SetOptionContextDescription(description string)
	// SetOptionContextParameterString sets the parameter string to be used by
	// the commandline handling of @application.
	//
	// This function registers the argument to be passed to
	// g_option_context_new() when the internal Context of @application is
	// created.
	//
	// See g_option_context_new() for more information about @parameter_string.
	SetOptionContextParameterString(parameterString string)
	// SetOptionContextSummary adds a summary to the @application option
	// context.
	//
	// See g_option_context_set_summary() for more information.
	SetOptionContextSummary(summary string)
	// SetResourceBasePath sets (or unsets) the base resource path of
	// @application.
	//
	// The path is used to automatically load various [application
	// resources][gresource] such as menu layouts and action descriptions. The
	// various types of resources will be found at fixed names relative to the
	// given base path.
	//
	// By default, the resource base path is determined from the application ID
	// by prefixing '/' and replacing each '.' with '/'. This is done at the
	// time that the #GApplication object is constructed. Changes to the
	// application ID after that point will not have an impact on the resource
	// base path.
	//
	// As an example, if the application has an ID of "org.example.app" then the
	// default resource base path will be "/org/example/app". If this is a
	// Application (and you have not manually changed the path) then Gtk will
	// then search for the menus of the application at
	// "/org/example/app/gtk/menus.ui".
	//
	// See #GResource for more information about adding resources to your
	// application.
	//
	// You can disable automatic resource loading functionality by setting the
	// path to nil.
	//
	// Changing the resource base path once the application is running is not
	// recommended. The point at which the resource path is consulted for
	// forming paths for various purposes is unspecified. When writing a
	// sub-class of #GApplication you should either set the
	// #GApplication:resource-base-path property at construction time, or call
	// this function during the instance initialization. Alternatively, you can
	// call this function in the Class.startup virtual function, before chaining
	// up to the parent implementation.
	SetResourceBasePath(resourcePath string)
	// UnbindBusyProperty destroys a binding between @property and the busy
	// state of @application that was previously created with
	// g_application_bind_busy_property().
	UnbindBusyProperty(object gextras.Objector, property string)
	// UnmarkBusy decreases the busy count of @application.
	//
	// When the busy count reaches zero, the new state will be propagated to
	// other processes.
	//
	// This function must only be called to cancel the effect of a previous call
	// to g_application_mark_busy().
	UnmarkBusy()
	// WithdrawNotification withdraws a notification that was sent with
	// g_application_send_notification().
	//
	// This call does nothing if a notification with @id doesn't exist or the
	// notification was never sent.
	//
	// This function works even for notifications sent in previous executions of
	// this application, as long @id is the same as it was for the sent
	// notification.
	//
	// Note that notifications are dismissed when the user clicks on one of the
	// buttons in a notification or triggers its default action, so there is no
	// need to explicitly withdraw the notification in that case.
	WithdrawNotification(id string)
}

type application struct {
	*externglib.Object
}

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return application{*externglib.Object{obj}}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

func NewApplication(applicationID string, flags ApplicationFlags) Application

func (a application) Activate()

func (a application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)

func (a application) AddOptionGroup(group *glib.OptionGroup)

func (a application) BindBusyProperty(object gextras.Objector, property string)

func (a application) ApplicationID() string

func (a application) DbusConnection() DBusConnection

func (a application) DbusObjectPath() string

func (a application) Flags() ApplicationFlags

func (a application) InactivityTimeout() uint

func (a application) IsBusy() bool

func (a application) IsRegistered() bool

func (a application) IsRemote() bool

func (a application) ResourceBasePath() string

func (a application) Hold()

func (a application) MarkBusy()

func (a application) Open(files []File, hint string)

func (a application) Quit()

func (a application) Register(cancellable Cancellable) bool

func (a application) Release()

func (a application) Run(argc int, argv []string) int

func (a application) SendNotification(id string, notification Notification)

func (a application) SetActionGroup(actionGroup ActionGroup)

func (a application) SetApplicationID(applicationID string)

func (a application) SetDefault()

func (a application) SetFlags(flags ApplicationFlags)

func (a application) SetInactivityTimeout(inactivityTimeout uint)

func (a application) SetOptionContextDescription(description string)

func (a application) SetOptionContextParameterString(parameterString string)

func (a application) SetOptionContextSummary(summary string)

func (a application) SetResourceBasePath(resourcePath string)

func (a application) UnbindBusyProperty(object gextras.Objector, property string)

func (a application) UnmarkBusy()

func (a application) WithdrawNotification(id string)

// ApplicationCommandLine represents a command-line invocation of an
// application. It is created by #GApplication and emitted in the
// #GApplication::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
//
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
//
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance.
//
//    static gboolean
//    my_cmdline_handler (gpointer data)
//    {
//      GApplicationCommandLine *cmdline = data;
//
//      // do the heavy lifting in an idle
//
//      g_application_command_line_set_exit_status (cmdline, 0);
//      g_object_unref (cmdline); // this releases the application
//
//      return G_SOURCE_REMOVE;
//    }
//
//    static int
//    command_line (GApplication            *application,
//                  GApplicationCommandLine *cmdline)
//    {
//      // keep the application running until we are done with this commandline
//      g_application_hold (application);
//
//      g_object_set_data_full (G_OBJECT (cmdline),
//                              "application", application,
//                              (GDestroyNotify)g_application_release);
//
//      g_object_ref (cmdline);
//      g_idle_add (my_cmdline_handler, cmdline);
//
//      return 0;
//    }
//
//
// In this example the commandline is not completely handled before the
// #GApplication::command-line handler returns. Instead, we keep a reference to
// the CommandLine object and handle it later (in this example, in an idle).
// Note that it is necessary to hold the application until you are done with the
// commandline.
//
// The complete example can be found here: gapplication-example-cmdline3.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine interface {
	gextras.Objector

	// CreateFileForArg creates a #GFile corresponding to a filename that was
	// given as part of the invocation of @cmdline.
	//
	// This differs from g_file_new_for_commandline_arg() in that it resolves
	// relative pathnames using the current working directory of the invoking
	// process rather than the local process.
	CreateFileForArg(arg string) File
	// Arguments gets the list of arguments that was passed on the command line.
	//
	// The strings in the array may contain non-UTF-8 data on UNIX (such as
	// filenames or arguments given in the system locale) but are always in
	// UTF-8 on Windows.
	//
	// If you wish to use the return value with Context, you must use
	// g_option_context_parse_strv().
	//
	// The return value is nil-terminated and should be freed using
	// g_strfreev().
	Arguments() (argc int, filenames []string)
	// Cwd gets the working directory of the command line invocation. The string
	// may contain non-utf8 data.
	//
	// It is possible that the remote application did not send a working
	// directory, so this may be nil.
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	Cwd() string
	// Environ gets the contents of the 'environ' variable of the command line
	// invocation, as would be returned by g_get_environ(), ie as a
	// nil-terminated list of strings in the form 'NAME=VALUE'. The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	//
	// See g_application_command_line_getenv() if you are only interested in the
	// value of a single environment variable.
	Environ() []string
	// ExitStatus gets the exit status of @cmdline. See
	// g_application_command_line_set_exit_status() for more information.
	ExitStatus() int
	// IsRemote determines if @cmdline represents a remote invocation.
	IsRemote() bool
	// OptionsDict gets the options there were passed to
	// g_application_command_line().
	//
	// If you did not override local_command_line() then these are the same
	// options that were parsed according to the Entrys added to the application
	// with g_application_add_main_option_entries() and possibly modified from
	// your GApplication::handle-local-options handler.
	//
	// If no options were sent then an empty dictionary is returned so that you
	// don't need to check for nil.
	OptionsDict() *glib.VariantDict
	// PlatformData gets the platform data associated with the invocation of
	// @cmdline.
	//
	// This is a #GVariant dictionary containing information about the context
	// in which the invocation occurred. It typically contains information like
	// the current working directory and the startup notification ID.
	//
	// For local invocation, it will be nil.
	PlatformData() *glib.Variant
	// Stdin gets the stdin of the invoking process.
	//
	// The Stream can be used to read data passed to the standard input of the
	// invoking process. This doesn't work on all platforms. Presently, it is
	// only available on UNIX when using a DBus daemon capable of passing file
	// descriptors. If stdin is not available then nil will be returned. In the
	// future, support may be expanded to other platforms.
	//
	// You must only call this function once per commandline invocation.
	Stdin() InputStream
	// env gets the value of a particular environment variable of the command
	// line invocation, as would be returned by g_getenv(). The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	env(name string) string
	// SetExitStatus sets the exit status that will be used when the invoking
	// process exits.
	//
	// The return value of the #GApplication::command-line signal is passed to
	// this function when the handler returns. This is the usual way of setting
	// the exit status.
	//
	// In the event that you want the remote invocation to continue running and
	// want to decide on the exit status in the future, you can use this call.
	// For the case of a remote invocation, the remote process will typically
	// exit when the last reference is dropped on @cmdline. The exit status of
	// the remote process will be equal to the last value that was set with this
	// function.
	//
	// In the case that the commandline invocation is local, the situation is
	// slightly more complicated. If the commandline invocation results in the
	// mainloop running (ie: because the use-count of the application increased
	// to a non-zero value) then the application is considered to have been
	// 'successful' in a certain sense, and the exit status is always zero. If
	// the application use count is zero, though, the exit status of the local
	// CommandLine is used.
	SetExitStatus(exitStatus int)
}

type applicationCommandLine struct {
	*externglib.Object
}

// WrapApplicationCommandLine wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationCommandLine(obj *externglib.Object) ApplicationCommandLine {
	return applicationCommandLine{*externglib.Object{obj}}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationCommandLine(obj), nil
}

func (a applicationCommandLine) CreateFileForArg(arg string) File

func (a applicationCommandLine) Arguments() (argc int, filenames []string)

func (a applicationCommandLine) Cwd() string

func (a applicationCommandLine) Environ() []string

func (a applicationCommandLine) ExitStatus() int

func (a applicationCommandLine) IsRemote() bool

func (a applicationCommandLine) OptionsDict() *glib.VariantDict

func (a applicationCommandLine) PlatformData() *glib.Variant

func (a applicationCommandLine) Stdin() InputStream

func (a applicationCommandLine) env(name string) string

func (a applicationCommandLine) SetExitStatus(exitStatus int)

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, InputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedInputStream interface {
	FilterInputStream

	// Fill tries to read @count bytes from the stream into the buffer. Will
	// block during this read.
	//
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	//
	// For the asynchronous, non-blocking, version of this function, see
	// g_buffered_input_stream_fill_async().
	Fill(count int, cancellable Cancellable) int
	// FillAsync reads data into @stream's buffer asynchronously, up to @count
	// size. @io_priority can be used to prioritize reads. For the synchronous
	// version of this function, see g_buffered_input_stream_fill().
	//
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	FillAsync(count int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// FillFinish finishes an asynchronous read.
	FillFinish(result AsyncResult) int
	// Available gets the size of the available data within the stream.
	Available() uint
	// BufferSize gets the size of the input buffer.
	BufferSize() uint
	// Peek peeks in the buffer, copying data of size @count into @buffer,
	// offset @offset bytes.
	Peek(buffer []uint8, offset uint) uint
	// PeekBuffer returns the buffer with the currently available bytes. The
	// returned buffer must not be modified and will become invalid when reading
	// from the stream or filling the buffer.
	PeekBuffer() (count uint, guint8s []uint8)
	// ReadByte tries to read a single byte from the stream or the buffer. Will
	// block during this read.
	//
	// On success, the byte read from the stream is returned. On end of stream
	// -1 is returned but it's not an exceptional error and @error is not set.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	ReadByte(cancellable Cancellable) int
	// SetBufferSize sets the size of the internal buffer of @stream to @size,
	// or to the size of the contents of the buffer. The buffer can never be
	// resized smaller than its current contents.
	SetBufferSize(size uint)
}

type bufferedInputStream struct {
	filterInputStream
}

// WrapBufferedInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedInputStream(obj *externglib.Object) BufferedInputStream {
	return bufferedInputStream{filterInputStream{inputStream{*externglib.Object{obj}}}}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedInputStream(obj), nil
}

func NewBufferedInputStream(baseStream InputStream) BufferedInputStream

func NewBufferedInputStreamSized(baseStream InputStream, size uint) BufferedInputStream

func (b bufferedInputStream) Fill(count int, cancellable Cancellable) int

func (b bufferedInputStream) FillAsync(count int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (b bufferedInputStream) FillFinish(result AsyncResult) int

func (b bufferedInputStream) Available() uint

func (b bufferedInputStream) BufferSize() uint

func (b bufferedInputStream) Peek(buffer []uint8, offset uint) uint

func (b bufferedInputStream) PeekBuffer() (count uint, guint8s []uint8)

func (b bufferedInputStream) ReadByte(cancellable Cancellable) int

func (b bufferedInputStream) SetBufferSize(size uint)

// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
//
// By default, OutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream interface {
	FilterOutputStream

	// AutoGrow checks if the buffer automatically grows as data is added.
	AutoGrow() bool
	// BufferSize gets the size of the buffer in the @stream.
	BufferSize() uint
	// SetAutoGrow sets whether or not the @stream's buffer should automatically
	// grow. If @auto_grow is true, then each write will just make the buffer
	// larger, and you must manually flush the buffer to actually write out the
	// data to the underlying stream.
	SetAutoGrow(autoGrow bool)
	// SetBufferSize sets the size of the internal buffer to @size.
	SetBufferSize(size uint)
}

type bufferedOutputStream struct {
	filterOutputStream
}

// WrapBufferedOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedOutputStream(obj *externglib.Object) BufferedOutputStream {
	return bufferedOutputStream{filterOutputStream{outputStream{*externglib.Object{obj}}}}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedOutputStream(obj), nil
}

func NewBufferedOutputStream(baseStream OutputStream) BufferedOutputStream

func NewBufferedOutputStreamSized(baseStream OutputStream, size uint) BufferedOutputStream

func (b bufferedOutputStream) AutoGrow() bool

func (b bufferedOutputStream) BufferSize() uint

func (b bufferedOutputStream) SetAutoGrow(autoGrow bool)

func (b bufferedOutputStream) SetBufferSize(size uint)

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector

	// Bytes gets the #GBytes associated with the given @icon.
	Bytes() *glib.Bytes
}

type bytesIcon struct {
	*externglib.Object
}

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return bytesIcon{*externglib.Object{obj}}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

func NewBytesIcon(bytes *glib.Bytes) BytesIcon

func (b bytesIcon) Bytes() *glib.Bytes

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable interface {
	gextras.Objector

	// Cancel: will set @cancellable to cancelled, and will emit the
	// #GCancellable::cancelled signal. (However, see the warning about race
	// conditions in the documentation for that signal if you are planning to
	// connect to it.)
	//
	// This function is thread-safe. In other words, you can safely call it from
	// a thread other than the one running the operation that was passed the
	// @cancellable.
	//
	// If @cancellable is nil, this function returns immediately for
	// convenience.
	//
	// The convention within GIO is that cancelling an asynchronous operation
	// causes it to complete asynchronously. That is, if you cancel the
	// operation from the same thread in which it is running, then the
	// operation's ReadyCallback will not be invoked until the application
	// returns to the main loop.
	Cancel()
	// Connect: convenience function to connect to the #GCancellable::cancelled
	// signal. Also handles the race condition that may happen if the
	// cancellable is cancelled right before connecting.
	//
	// @callback is called at most once, either directly at the time of the
	// connect if @cancellable is already cancelled, or when @cancellable is
	// cancelled in some thread.
	//
	// @data_destroy_func will be called when the handler is disconnected, or
	// immediately if the cancellable is already cancelled.
	//
	// See #GCancellable::cancelled for details on how to use this.
	//
	// Since GLib 2.40, the lock protecting @cancellable is not held when
	// @callback is invoked. This lifts a restriction in place for earlier GLib
	// versions which now makes it easier to write cleanup code that
	// unconditionally invokes e.g. g_cancellable_cancel().
	Connect(callback interface{}) uint32
	// Disconnect disconnects a handler from a cancellable instance similar to
	// g_signal_handler_disconnect(). Additionally, in the event that a signal
	// handler is currently running, this call will block until the handler has
	// finished. Calling this function from a #GCancellable::cancelled signal
	// handler will therefore result in a deadlock.
	//
	// This avoids a race condition where a thread cancels at the same time as
	// the cancellable operation is finished and the signal handler is removed.
	// See #GCancellable::cancelled for details on how to use this.
	//
	// If @cancellable is nil or @handler_id is `0` this function does nothing.
	Disconnect(handlerID uint32)
	// Fd gets the file descriptor for a cancellable job. This can be used to
	// implement cancellable operations on Unix systems. The returned fd will
	// turn readable when @cancellable is cancelled.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	//
	// After a successful return from this function, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// returned file descriptor.
	//
	// See also g_cancellable_make_pollfd().
	Fd() int
	// IsCancelled checks if a cancellable job has been cancelled.
	IsCancelled() bool
	// MakePollfd creates a FD corresponding to @cancellable; this can be passed
	// to g_poll() and used to poll for cancellation. This is useful both for
	// unix systems without a native poll and for portability to windows.
	//
	// When this function returns true, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// @pollfd. After a false return, do not call g_cancellable_release_fd().
	//
	// If this function returns false, either no @cancellable was given or
	// resource limits prevent this function from allocating the necessary
	// structures for polling. (On Linux, you will likely have reached the
	// maximum number of file descriptors.) The suggested way to handle these
	// cases is to ignore the @cancellable.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	MakePollfd(pollfd *glib.PollFD) bool
	// PopCurrent pops @cancellable off the cancellable stack (verifying that
	// @cancellable is on the top of the stack).
	PopCurrent()
	// PushCurrent pushes @cancellable onto the cancellable stack. The current
	// cancellable can then be received using g_cancellable_get_current().
	//
	// This is useful when implementing cancellable operations in code that does
	// not allow you to pass down the cancellable object.
	//
	// This is typically called automatically by e.g. #GFile operations, so you
	// rarely have to call this yourself.
	PushCurrent()
	// ReleaseFd releases a resources previously allocated by
	// g_cancellable_get_fd() or g_cancellable_make_pollfd().
	//
	// For compatibility reasons with older releases, calling this function is
	// not strictly required, the resources will be automatically freed when the
	// @cancellable is finalized. However, the @cancellable will block scarce
	// file descriptors until it is finalized if this function is not called.
	// This can cause the application to run out of file descriptors when many
	// #GCancellables are used at the same time.
	ReleaseFd()
	// Reset resets @cancellable to its uncancelled state.
	//
	// If cancellable is currently in use by any cancellable operation then the
	// behavior of this function is undefined.
	//
	// Note that it is generally not a good idea to reuse an existing
	// cancellable for more operations after it has been cancelled once, as this
	// function might tempt you to do. The recommended practice is to drop the
	// reference to a cancellable after cancelling it, and let it die with the
	// outstanding async operations. You should create a fresh cancellable for
	// further async operations.
	Reset()
	// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
	// notify that the operation was cancelled.
	SetErrorIfCancelled() bool
	// NewSource creates a source that triggers if @cancellable is cancelled and
	// calls its callback of type SourceFunc. This is primarily useful for
	// attaching to another (non-cancellable) source with
	// g_source_add_child_source() to add cancellability to it.
	//
	// For convenience, you can call this with a nil #GCancellable, in which
	// case the source will never trigger.
	//
	// The new #GSource will hold a reference to the #GCancellable.
	NewSource() *glib.Source
}

type cancellable struct {
	*externglib.Object
}

// WrapCancellable wraps a GObject to the right type. It is
// primarily used internally.
func WrapCancellable(obj *externglib.Object) Cancellable {
	return cancellable{*externglib.Object{obj}}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCancellable(obj), nil
}

func NewCancellable() Cancellable

func (c cancellable) Cancel()

func (c cancellable) Connect(callback interface{}) uint32

func (c cancellable) Disconnect(handlerID uint32)

func (c cancellable) Fd() int

func (c cancellable) IsCancelled() bool

func (c cancellable) MakePollfd(pollfd *glib.PollFD) bool

func (c cancellable) PopCurrent()

func (c cancellable) PushCurrent()

func (c cancellable) ReleaseFd()

func (c cancellable) Reset()

func (c cancellable) SetErrorIfCancelled() bool

func (c cancellable) NewSource() *glib.Source

// CharsetConverter is an implementation of #GConverter based on GIConv.
type CharsetConverter interface {
	gextras.Objector

	// NumFallbacks gets the number of fallbacks that @converter has applied so
	// far.
	NumFallbacks() uint
	// UseFallback gets the Converter:use-fallback property.
	UseFallback() bool
	// SetUseFallback sets the Converter:use-fallback property.
	SetUseFallback(useFallback bool)
}

type charsetConverter struct {
	*externglib.Object
}

// WrapCharsetConverter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCharsetConverter(obj *externglib.Object) CharsetConverter {
	return charsetConverter{*externglib.Object{obj}}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCharsetConverter(obj), nil
}

func NewCharsetConverter(toCharset string, fromCharset string) CharsetConverter

func (c charsetConverter) NumFallbacks() uint

func (c charsetConverter) UseFallback() bool

func (c charsetConverter) SetUseFallback(useFallback bool)

// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, InputStream implements InputStream.
type ConverterInputStream interface {
	FilterInputStream

	// Converter gets the #GConverter that is used by @converter_stream.
	Converter() Converter
}

type converterInputStream struct {
	filterInputStream
}

// WrapConverterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterInputStream(obj *externglib.Object) ConverterInputStream {
	return converterInputStream{filterInputStream{inputStream{*externglib.Object{obj}}}}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterInputStream(obj), nil
}

func NewConverterInputStream(baseStream InputStream, converter Converter) ConverterInputStream

func (c converterInputStream) Converter() Converter

// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, OutputStream implements OutputStream.
type ConverterOutputStream interface {
	FilterOutputStream

	// Converter gets the #GConverter that is used by @converter_stream.
	Converter() Converter
}

type converterOutputStream struct {
	filterOutputStream
}

// WrapConverterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterOutputStream(obj *externglib.Object) ConverterOutputStream {
	return converterOutputStream{filterOutputStream{outputStream{*externglib.Object{obj}}}}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterOutputStream(obj), nil
}

func NewConverterOutputStream(baseStream OutputStream, converter Converter) ConverterOutputStream

func (c converterOutputStream) Converter() Converter

// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
//
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
//
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
type Credentials interface {
	gextras.Objector

	// Native gets a pointer to native credentials of type @native_type from
	// @credentials.
	//
	// It is a programming error (which will cause a warning to be logged) to
	// use this method if there is no #GCredentials support for the OS or if
	// @native_type isn't supported by the OS.
	Native(nativeType CredentialsType) interface{}
	// UnixPid tries to get the UNIX process identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// process ID (for example this is the case for
	// G_CREDENTIALS_TYPE_APPLE_XUCRED).
	UnixPid() int
	// UnixUser tries to get the UNIX user identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user.
	UnixUser() uint
	// IsSameUser checks if @credentials and @other_credentials is the same
	// user.
	//
	// This operation can fail if #GCredentials is not supported on the the OS.
	IsSameUser(otherCredentials Credentials) bool
	// SetNative copies the native credentials of type @native_type from @native
	// into @credentials.
	//
	// It is a programming error (which will cause a warning to be logged) to
	// use this method if there is no #GCredentials support for the OS or if
	// @native_type isn't supported by the OS.
	SetNative(nativeType CredentialsType, native interface{})
	// SetUnixUser tries to set the UNIX user identifier on @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user. It can also fail if the OS does not allow the use of "spoofed"
	// credentials.
	SetUnixUser(uid uint) bool
	// ToString creates a human-readable textual representation of @credentials
	// that can be used in logging and debug messages. The format of the
	// returned string may change in future GLib release.
	ToString() string
}

type credentials struct {
	*externglib.Object
}

// WrapCredentials wraps a GObject to the right type. It is
// primarily used internally.
func WrapCredentials(obj *externglib.Object) Credentials {
	return credentials{*externglib.Object{obj}}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCredentials(obj), nil
}

func NewCredentials() Credentials

func (c credentials) Native(nativeType CredentialsType) interface{}

func (c credentials) UnixPid() int

func (c credentials) UnixUser() uint

func (c credentials) IsSameUser(otherCredentials Credentials) bool

func (c credentials) SetNative(nativeType CredentialsType, native interface{})

func (c credentials) SetUnixUser(uid uint) bool

func (c credentials) ToString() string

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector
}

type dBusActionGroup struct {
	*externglib.Object
}

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return dBusActionGroup{*externglib.Object{obj}}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
//
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

type dBusAuthObserver struct {
	*externglib.Object
}

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return dBusAuthObserver{*externglib.Object{obj}}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

func NewDBusAuthObserver() DBusAuthObserver

func (d dBusAuthObserver) AllowMechanism(mechanism string) bool

func (d dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector

	// AddFilter adds a message filter. Filters are handlers that are run on all
	// incoming and outgoing messages, prior to standard dispatch. Filters are
	// run in the order that they were added. The same handler can be added as a
	// filter more than once, in which case it will be run more than once.
	// Filters added during a filter callback won't be run on the message being
	// processed. Filter functions are allowed to modify and even drop messages.
	//
	// Note that filters are run in a dedicated message handling thread so they
	// can't block and, generally, can't do anything but signal a worker thread.
	// Also note that filters are rarely needed - use API such as
	// g_dbus_connection_send_message_with_reply(),
	// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
	//
	// If a filter consumes an incoming message the message is not dispatched
	// anywhere else - not even the standard dispatch machinery (that API such
	// as g_dbus_connection_signal_subscribe() and
	// g_dbus_connection_send_message_with_reply() relies on) will see the
	// message. Similarly, if a filter consumes an outgoing message, the message
	// will not be sent to the other peer.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the filter is removed, and may
	// be called after @connection has been destroyed.)
	AddFilter(filterFunction DBusMessageFilterFunction) uint
	// Call: asynchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type. Unless it’s G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
	// containing one or more values.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_connection_call (connection,
	//                             "org.freedesktop.StringThings",
	//                             "/org/freedesktop/StringThings",
	//                             "org.freedesktop.StringThings",
	//                             "TwoStrings",
	//                             g_variant_new ("(ss)",
	//                                            "Thing One",
	//                                            "Thing Two"),
	//                             NULL,
	//                             G_DBUS_CALL_FLAGS_NONE,
	//                             -1,
	//                             NULL,
	//                             (GAsyncReadyCallback) two_strings_done,
	//                             NULL);
	//
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_call_finish() to get the result of the operation. See
	// g_dbus_connection_call_sync() for the synchronous version of this
	// function.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResult) *glib.Variant
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_connection_call_sync (connection,
	//                                  "org.freedesktop.StringThings",
	//                                  "/org/freedesktop/StringThings",
	//                                  "org.freedesktop.StringThings",
	//                                  "TwoStrings",
	//                                  g_variant_new ("(ss)",
	//                                                 "Thing One",
	//                                                 "Thing Two"),
	//                                  NULL,
	//                                  G_DBUS_CALL_FLAGS_NONE,
	//                                  -1,
	//                                  NULL,
	//                                  &error);
	//
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant
	// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)
	// Close closes @connection. Note that this never causes the process to exit
	// (this might only happen if the other end of a shared message bus
	// connection disconnects, see BusConnection:exit-on-close).
	//
	// Once the connection is closed, operations such as sending a message will
	// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
	// automatically flush the connection so queued messages may be lost. Use
	// g_dbus_connection_flush() if you need such guarantees.
	//
	// If @connection is already closed, this method fails with
	// G_IO_ERROR_CLOSED.
	//
	// When @connection has been closed, the BusConnection::closed signal is
	// emitted in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread that
	// @connection was constructed in.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_close_finish() to get the result of the operation. See
	// g_dbus_connection_close_sync() for the synchronous version.
	Close(cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResult) bool
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) bool
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) bool
	// ExportActionGroup exports @action_group on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// A given object path can only have one action group exported on it. If
	// this constraint is violated, the export will fail and 0 will be returned
	// (with @error set accordingly).
	//
	// You can unexport the action group using
	// g_dbus_connection_unexport_action_group() with the return value of this
	// function.
	//
	// The thread default main context is taken at the time of this call. All
	// incoming action activations and state change requests are reported from
	// this context. Any changes on the action group that cause it to emit
	// signals must also come from this same context. Since incoming action
	// activations and state change requests are rather likely to cause changes
	// on the action group, this effectively limits a given action group to
	// being exported from only one main context.
	ExportActionGroup(objectPath string, actionGroup ActionGroup) uint
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) uint
	// Flush: asynchronously flushes @connection, that is, writes all queued
	// outgoing message to the transport and then flushes the transport (using
	// g_output_stream_flush_async()). This is useful in programs that wants to
	// emit a D-Bus signal and then exit immediately. Without flushing the
	// connection, there is no guaranteed that the message has been sent to the
	// networking buffers in the OS kernel.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_flush_finish() to get the result of the operation. See
	// g_dbus_connection_flush_sync() for the synchronous version.
	Flush(cancellable Cancellable, callback AsyncReadyCallback)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResult) bool
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) bool
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RegisterObject registers callbacks for exported objects at @object_path
	// with the D-Bus interface that is described in @interface_info.
	//
	// Calls to functions in @vtable (and @user_data_free_func) will happen in
	// the [thread-default main context][g-main-context-push-thread-default] of
	// the thread you are calling this method from.
	//
	// Note that all #GVariant values passed to functions in @vtable will match
	// the signature given in @interface_info - if a remote caller passes
	// incorrect values, the `org.freedesktop.DBus.Error.InvalidArgs` is
	// returned to the remote caller.
	//
	// Additionally, if the remote caller attempts to invoke methods or access
	// properties not mentioned in @interface_info the
	// `org.freedesktop.DBus.Error.UnknownMethod` resp.
	// `org.freedesktop.DBus.Error.InvalidArgs` errors are returned to the
	// caller.
	//
	// It is considered a programming error if the BusInterfaceGetPropertyFunc
	// function in @vtable returns a #GVariant of incorrect type.
	//
	// If an existing callback is already registered at @object_path and
	// @interface_name, then @error is set to IO_ERROR_EXISTS.
	//
	// GDBus automatically implements the standard D-Bus interfaces
	// org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable and
	// org.freedesktop.Peer, so you don't have to implement those for the
	// objects you export. You can implement org.freedesktop.DBus.Properties
	// yourself, e.g. to handle getting and setting of properties
	// asynchronously.
	//
	// Note that the reference count on @interface_info will be incremented by 1
	// (unless allocated statically, e.g. if the reference count is -1, see
	// g_dbus_interface_info_ref()) for as long as the object is exported. Also
	// note that @vtable will be copied.
	//
	// See this [server][gdbus-server] for an example of how to use this method.
	RegisterObject(objectPath string, interfaceInfo *DBusInterfaceInfo, vtable *DBusInterfaceVTable, userData interface{}) uint
	// RegisterObjectWithClosures: version of
	// g_dbus_connection_register_object() using closures instead of a
	// BusInterfaceVTable for easier binding in other languages.
	RegisterObjectWithClosures(objectPath string, interfaceInfo *DBusInterfaceInfo, methodCallClosure *externglib.Closure, getPropertyClosure *externglib.Closure, setPropertyClosure *externglib.Closure) uint
	// RegisterSubtree registers a whole subtree of dynamic objects.
	//
	// The @enumerate and @introspection functions in @vtable are used to
	// convey, to remote callers, what nodes exist in the subtree rooted by
	// @object_path.
	//
	// When handling remote calls into any node in the subtree, first the
	// @enumerate function is used to check if the node exists. If the node
	// exists or the DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is
	// set the @introspection function is used to check if the node supports the
	// requested method. If so, the @dispatch function is used to determine
	// where to dispatch the call. The collected BusInterfaceVTable and
	// #gpointer will be used to call into the interface vtable for processing
	// the request.
	//
	// All calls into user-provided code will be invoked in the [thread-default
	// main context][g-main-context-push-thread-default] of the thread you are
	// calling this method from.
	//
	// If an existing subtree is already registered at @object_path or then
	// @error is set to IO_ERROR_EXISTS.
	//
	// Note that it is valid to register regular objects (using
	// g_dbus_connection_register_object()) in a subtree registered with
	// g_dbus_connection_register_subtree() - if so, the subtree handler is
	// tried as the last resort. One way to think about a subtree handler is to
	// consider it a fallback handler for object paths not registered via
	// g_dbus_connection_register_object() or other bindings.
	//
	// Note that @vtable will be copied so you cannot change it after
	// registration.
	//
	// See this [server][gdbus-subtree-server] for an example of how to use this
	// method.
	RegisterSubtree(objectPath string, vtable *DBusSubtreeVTable, flags DBusSubtreeFlags, userData interface{}) uint
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterID uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, ok bool)
	// SendMessageWithReply: asynchronously sends @message to the peer
	// represented by @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_send_message_with_reply_finish() to get the result of
	// the operation. See g_dbus_connection_send_message_with_reply_sync() for
	// the synchronous version.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReplyFinish(res AsyncResult) DBusMessage
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalSubscribe subscribes to signals on @connection and invokes
	// @callback with a whenever the signal is received. Note that @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from.
	//
	// If @connection is not a message bus connection, @sender must be nil.
	//
	// If @sender is a well-known name note that @callback is invoked with the
	// unique name for the owner of @sender, not the well-known name as one
	// would expect. This is because the message bus rewrites the name. As such,
	// to avoid certain race conditions, users should be tracking the name owner
	// of the well-known name and use that when processing the received signal.
	//
	// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
	// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is interpreted as
	// part of a namespace or path. The first argument of a signal is matched
	// against that part as specified by D-Bus.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the signal is unsubscribed
	// from, and may be called after @connection has been destroyed.)
	//
	// As @callback is potentially invoked in a different thread from where it’s
	// emitted, it’s possible for this to happen after
	// g_dbus_connection_signal_unsubscribe() has been called in another thread.
	// Due to this, @user_data should have a strong reference which is freed
	// with @user_data_free_func, rather than pointing to data whose lifecycle
	// is tied to the signal subscription. For example, if a #GObject is used to
	// store the subscription ID from g_dbus_connection_signal_subscribe(), a
	// strong reference to that #GObject must be passed to @user_data, and
	// g_object_unref() passed to @user_data_free_func. You are responsible for
	// breaking the resulting reference count cycle by explicitly unsubscribing
	// from the signal when dropping the last external reference to the
	// #GObject. Alternatively, a weak reference may be used.
	//
	// It is guaranteed that if you unsubscribe from a signal using
	// g_dbus_connection_signal_unsubscribe() from the same thread which made
	// the corresponding g_dbus_connection_signal_subscribe() call, @callback
	// will not be invoked after g_dbus_connection_signal_unsubscribe() returns.
	//
	// The returned subscription identifier is an opaque value which is
	// guaranteed to never be zero.
	//
	// This function can never fail.
	SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after it’s stopped being iterated.
	SignalUnsubscribe(subscriptionID uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportID uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportID uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationID uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationID uint) bool
}

type dBusConnection struct {
	*externglib.Object
}

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return dBusConnection{*externglib.Object{obj}}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

func NewDBusConnectionFinish(res AsyncResult) DBusConnection

func NewDBusConnectionForAddressFinish(res AsyncResult) DBusConnection

func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) DBusConnection

func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) DBusConnection

func (d dBusConnection) AddFilter(filterFunction DBusMessageFilterFunction) uint

func (d dBusConnection) Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusConnection) CallFinish(res AsyncResult) *glib.Variant

func (d dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant

func (d dBusConnection) CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusConnection) CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant)

func (d dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)

func (d dBusConnection) Close(cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusConnection) CloseFinish(res AsyncResult) bool

func (d dBusConnection) CloseSync(cancellable Cancellable) bool

func (d dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) bool

func (d dBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) uint

func (d dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) uint

func (d dBusConnection) Flush(cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusConnection) FlushFinish(res AsyncResult) bool

func (d dBusConnection) FlushSync(cancellable Cancellable) bool

func (d dBusConnection) Capabilities() DBusCapabilityFlags

func (d dBusConnection) ExitOnClose() bool

func (d dBusConnection) Flags() DBusConnectionFlags

func (d dBusConnection) Guid() string

func (d dBusConnection) LastSerial() uint32

func (d dBusConnection) PeerCredentials() Credentials

func (d dBusConnection) Stream() IOStream

func (d dBusConnection) UniqueName() string

func (d dBusConnection) IsClosed() bool

func (d dBusConnection) RegisterObject(objectPath string, interfaceInfo *DBusInterfaceInfo, vtable *DBusInterfaceVTable, userData interface{}) uint

func (d dBusConnection) RegisterObjectWithClosures(objectPath string, interfaceInfo *DBusInterfaceInfo, methodCallClosure *externglib.Closure, getPropertyClosure *externglib.Closure, setPropertyClosure *externglib.Closure) uint

func (d dBusConnection) RegisterSubtree(objectPath string, vtable *DBusSubtreeVTable, flags DBusSubtreeFlags, userData interface{}) uint

func (d dBusConnection) RemoveFilter(filterID uint)

func (d dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, ok bool)

func (d dBusConnection) SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32

func (d dBusConnection) SendMessageWithReplyFinish(res AsyncResult) DBusMessage

func (d dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage)

func (d dBusConnection) SetExitOnClose(exitOnClose bool)

func (d dBusConnection) SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint

func (d dBusConnection) SignalUnsubscribe(subscriptionID uint)

func (d dBusConnection) StartMessageProcessing()

func (d dBusConnection) UnexportActionGroup(exportID uint)

func (d dBusConnection) UnexportMenuModel(exportID uint)

func (d dBusConnection) UnregisterObject(registrationID uint) bool

func (d dBusConnection) UnregisterSubtree(registrationID uint) bool

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton interface {
	gextras.Objector

	// Export exports @interface_ at @object_path on @connection.
	//
	// This can be called multiple times to export the same @interface_ onto
	// multiple connections however the @object_path provided must be the same
	// for all connections.
	//
	// Use g_dbus_interface_skeleton_unexport() to unexport the object.
	Export(connection DBusConnection, objectPath string) bool
	// Flush: if @interface_ has outstanding changes, request for these changes
	// to be emitted immediately.
	//
	// For example, an exported D-Bus interface may queue up property changes
	// and emit the `org.freedesktop.DBus.Properties.PropertiesChanged` signal
	// later (e.g. in an idle handler). This technique is useful for collapsing
	// multiple property changes into one.
	Flush()
	// Connection gets the first connection that @interface_ is exported on, if
	// any.
	Connection() DBusConnection
	// Connections gets a list of the connections that @interface_ is exported
	// on.
	Connections() *glib.List
	// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior
	// of @interface_
	Flags() DBusInterfaceSkeletonFlags
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
	Info() *DBusInterfaceInfo
	// ObjectPath gets the object path that @interface_ is exported on, if any.
	ObjectPath() string
	// Properties gets all D-Bus properties for @interface_.
	Properties() *glib.Variant
	// Vtable gets the interface vtable for the D-Bus interface implemented by
	// @interface_. The returned function pointers should expect @interface_
	// itself to be passed as @user_data.
	Vtable() *DBusInterfaceVTable
	// HasConnection checks if @interface_ is exported on @connection.
	HasConnection(connection DBusConnection) bool
	// SetFlags sets flags describing what the behavior of @skeleton should be.
	SetFlags(flags DBusInterfaceSkeletonFlags)
	// Unexport stops exporting @interface_ on all connections it is exported
	// on.
	//
	// To unexport @interface_ from only a single connection, use
	// g_dbus_interface_skeleton_unexport_from_connection()
	Unexport()
	// UnexportFromConnection stops exporting @interface_ on @connection.
	//
	// To stop exporting on all connections the interface is exported on, use
	// g_dbus_interface_skeleton_unexport().
	UnexportFromConnection(connection DBusConnection)
}

type dBusInterfaceSkeleton struct {
	*externglib.Object
}

// WrapDBusInterfaceSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusInterfaceSkeleton(obj *externglib.Object) DBusInterfaceSkeleton {
	return dBusInterfaceSkeleton{*externglib.Object{obj}}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusInterfaceSkeleton(obj), nil
}

func (d dBusInterfaceSkeleton) Export(connection DBusConnection, objectPath string) bool

func (d dBusInterfaceSkeleton) Flush()

func (d dBusInterfaceSkeleton) Connection() DBusConnection

func (d dBusInterfaceSkeleton) Connections() *glib.List

func (d dBusInterfaceSkeleton) Flags() DBusInterfaceSkeletonFlags

func (d dBusInterfaceSkeleton) Info() *DBusInterfaceInfo

func (d dBusInterfaceSkeleton) ObjectPath() string

func (d dBusInterfaceSkeleton) Properties() *glib.Variant

func (d dBusInterfaceSkeleton) Vtable() *DBusInterfaceVTable

func (d dBusInterfaceSkeleton) HasConnection(connection DBusConnection) bool

func (d dBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags)

func (d dBusInterfaceSkeleton) Unexport()

func (d dBusInterfaceSkeleton) UnexportFromConnection(connection DBusConnection)

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

type dBusMenuModel struct {
	menuModel
}

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return dBusMenuModel{menuModel{*externglib.Object{obj}}}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() DBusMessage
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []uint8
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//    ]|
	//    or
	//    |[
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	//
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(_type DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	SetUnixFdList(fdList UnixFDList)
	// ToBlob serializes @message to a blob. The byte order returned by
	// g_dbus_message_get_byte_order() will be used.
	ToBlob(capabilities DBusCapabilityFlags) (outSize uint, guint8s []uint8)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() bool
}

type dBusMessage struct {
	*externglib.Object
}

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return dBusMessage{*externglib.Object{obj}}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

func NewDBusMessage() DBusMessage

func NewDBusMessageFromBlob(blob []uint8, capabilities DBusCapabilityFlags) DBusMessage

func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage

func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage

func (d dBusMessage) Copy() DBusMessage

func (d dBusMessage) Arg0() string

func (d dBusMessage) Body() *glib.Variant

func (d dBusMessage) ByteOrder() DBusMessageByteOrder

func (d dBusMessage) Destination() string

func (d dBusMessage) ErrorName() string

func (d dBusMessage) Flags() DBusMessageFlags

func (d dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant

func (d dBusMessage) HeaderFields() []uint8

func (d dBusMessage) Interface() string

func (d dBusMessage) Locked() bool

func (d dBusMessage) Member() string

func (d dBusMessage) MessageType() DBusMessageType

func (d dBusMessage) NumUnixFds() uint32

func (d dBusMessage) Path() string

func (d dBusMessage) ReplySerial() uint32

func (d dBusMessage) Sender() string

func (d dBusMessage) Serial() uint32

func (d dBusMessage) Signature() string

func (d dBusMessage) UnixFdList() UnixFDList

func (d dBusMessage) Lock()

func (d dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage

func (d dBusMessage) NewMethodReply() DBusMessage

func (d dBusMessage) Print(indent uint) string

func (d dBusMessage) SetBody(body *glib.Variant)

func (d dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder)

func (d dBusMessage) SetDestination(value string)

func (d dBusMessage) SetErrorName(value string)

func (d dBusMessage) SetFlags(flags DBusMessageFlags)

func (d dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)

func (d dBusMessage) SetInterface(value string)

func (d dBusMessage) SetMember(value string)

func (d dBusMessage) SetMessageType(_type DBusMessageType)

func (d dBusMessage) SetNumUnixFds(value uint32)

func (d dBusMessage) SetPath(value string)

func (d dBusMessage) SetReplySerial(value uint32)

func (d dBusMessage) SetSender(value string)

func (d dBusMessage) SetSerial(serial uint32)

func (d dBusMessage) SetSignature(value string)

func (d dBusMessage) SetUnixFdList(fdList UnixFDList)

func (d dBusMessage) ToBlob(capabilities DBusCapabilityFlags) (outSize uint, guint8s []uint8)

func (d dBusMessage) ToGerror() bool

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// UserData gets the @user_data #gpointer passed to
	// g_dbus_connection_register_object().
	UserData() interface{}
	// ReturnDbusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDbusError(errorName string, errorMessage string)
	// ReturnErrorLiteral: like g_dbus_method_invocation_return_error() but
	// without printf()-style formatting.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnErrorLiteral(domain glib.Quark, code int, message string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(error *glib.Error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
	// TakeError: like g_dbus_method_invocation_return_gerror() but takes
	// ownership of @error so the caller does not need to free it.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	TakeError(error *glib.Error)
}

type dBusMethodInvocation struct {
	*externglib.Object
}

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return dBusMethodInvocation{*externglib.Object{obj}}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

func (d dBusMethodInvocation) Connection() DBusConnection

func (d dBusMethodInvocation) InterfaceName() string

func (d dBusMethodInvocation) Message() DBusMessage

func (d dBusMethodInvocation) MethodInfo() *DBusMethodInfo

func (d dBusMethodInvocation) MethodName() string

func (d dBusMethodInvocation) ObjectPath() string

func (d dBusMethodInvocation) Parameters() *glib.Variant

func (d dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo

func (d dBusMethodInvocation) Sender() string

func (d dBusMethodInvocation) UserData() interface{}

func (d dBusMethodInvocation) ReturnDbusError(errorName string, errorMessage string)

func (d dBusMethodInvocation) ReturnErrorLiteral(domain glib.Quark, code int, message string)

func (d dBusMethodInvocation) ReturnGerror(error *glib.Error)

func (d dBusMethodInvocation) ReturnValue(parameters *glib.Variant)

func (d dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)

func (d dBusMethodInvocation) TakeError(error *glib.Error)

// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted) – BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient interface {
	gextras.Objector

	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// Flags gets the flags that @manager was constructed with.
	Flags() DBusObjectManagerClientFlags
	// Name gets the name that @manager is for, or nil if not a message bus
	// connection.
	Name() string
	// NameOwner: the unique name that owns the name that @manager is for or nil
	// if no-one currently owns that name. You can connect to the
	// #GObject::notify signal to track changes to the
	// BusObjectManagerClient:name-owner property.
	NameOwner() string
}

type dBusObjectManagerClient struct {
	*externglib.Object
}

// WrapDBusObjectManagerClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerClient(obj *externglib.Object) DBusObjectManagerClient {
	return dBusObjectManagerClient{*externglib.Object{obj}}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerClient(obj), nil
}

func NewDBusObjectManagerClientFinish(res AsyncResult) DBusObjectManagerClient

func NewDBusObjectManagerClientForBusFinish(res AsyncResult) DBusObjectManagerClient

func NewDBusObjectManagerClientForBusSync(busType BusType, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, cancellable Cancellable) DBusObjectManagerClient

func NewDBusObjectManagerClientSync(connection DBusConnection, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, cancellable Cancellable) DBusObjectManagerClient

func (d dBusObjectManagerClient) Connection() DBusConnection

func (d dBusObjectManagerClient) Flags() DBusObjectManagerClientFlags

func (d dBusObjectManagerClient) Name() string

func (d dBusObjectManagerClient) NameOwner() string

// DBusObjectManagerServer is used to export BusObject instances using the
// standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
//
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer interface {
	gextras.Objector

	// Export exports @object on @manager.
	//
	// If there is already a BusObject exported at the object path, then the old
	// object is removed.
	//
	// The object path for @object must be in the hierarchy rooted by the object
	// path for @manager.
	//
	// Note that @manager will take a reference on @object for as long as it is
	// exported.
	Export(object DBusObjectSkeleton)
	// ExportUniquely: like g_dbus_object_manager_server_export() but appends a
	// string of the form _N (with N being a natural number) to @object's object
	// path if an object with the given path already exists. As such, the
	// BusObjectProxy:g-object-path property of @object may be modified.
	ExportUniquely(object DBusObjectSkeleton)
	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// IsExported returns whether @object is currently exported on @manager.
	IsExported(object DBusObjectSkeleton) bool
	// SetConnection exports all objects managed by @manager on @connection. If
	// @connection is nil, stops exporting objects.
	SetConnection(connection DBusConnection)
	// Unexport: if @manager has an object at @path, removes the object.
	// Otherwise does nothing.
	//
	// Note that @object_path must be in the hierarchy rooted by the object path
	// for @manager.
	Unexport(objectPath string) bool
}

type dBusObjectManagerServer struct {
	*externglib.Object
}

// WrapDBusObjectManagerServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerServer(obj *externglib.Object) DBusObjectManagerServer {
	return dBusObjectManagerServer{*externglib.Object{obj}}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerServer(obj), nil
}

func NewDBusObjectManagerServer(objectPath string) DBusObjectManagerServer

func (d dBusObjectManagerServer) Export(object DBusObjectSkeleton)

func (d dBusObjectManagerServer) ExportUniquely(object DBusObjectSkeleton)

func (d dBusObjectManagerServer) Connection() DBusConnection

func (d dBusObjectManagerServer) IsExported(object DBusObjectSkeleton) bool

func (d dBusObjectManagerServer) SetConnection(connection DBusConnection)

func (d dBusObjectManagerServer) Unexport(objectPath string) bool

// DBusObjectProxy: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
type DBusObjectProxy interface {
	gextras.Objector

	// Connection gets the connection that @proxy is for.
	Connection() DBusConnection
}

type dBusObjectProxy struct {
	*externglib.Object
}

// WrapDBusObjectProxy wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectProxy(obj *externglib.Object) DBusObjectProxy {
	return dBusObjectProxy{*externglib.Object{obj}}
}

func marshalDBusObjectProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectProxy(obj), nil
}

func NewDBusObjectProxy(connection DBusConnection, objectPath string) DBusObjectProxy

func (d dBusObjectProxy) Connection() DBusConnection

// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with BusObjectManager.
type DBusObjectSkeleton interface {
	gextras.Objector

	// AddInterface adds @interface_ to @object.
	//
	// If @object already contains a BusInterfaceSkeleton with the same
	// interface name, it is removed before @interface_ is added.
	//
	// Note that @object takes its own reference on @interface_ and holds it
	// until removed.
	AddInterface(interface_ DBusInterfaceSkeleton)
	// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
	// interfaces belonging to @object. See that method for when flushing is
	// useful.
	Flush()
	// RemoveInterface removes @interface_ from @object.
	RemoveInterface(interface_ DBusInterfaceSkeleton)
	// RemoveInterfaceByName removes the BusInterface with @interface_name from
	// @object.
	//
	// If no D-Bus interface of the given interface exists, this function does
	// nothing.
	RemoveInterfaceByName(interfaceName string)
	// SetObjectPath sets the object path for @object.
	SetObjectPath(objectPath string)
}

type dBusObjectSkeleton struct {
	*externglib.Object
}

// WrapDBusObjectSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectSkeleton(obj *externglib.Object) DBusObjectSkeleton {
	return dBusObjectSkeleton{*externglib.Object{obj}}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectSkeleton(obj), nil
}

func NewDBusObjectSkeleton(objectPath string) DBusObjectSkeleton

func (d dBusObjectSkeleton) AddInterface(interface_ DBusInterfaceSkeleton)

func (d dBusObjectSkeleton) Flush()

func (d dBusObjectSkeleton) RemoveInterface(interface_ DBusInterfaceSkeleton)

func (d dBusObjectSkeleton) RemoveInterfaceByName(interfaceName string)

func (d dBusObjectSkeleton) SetObjectPath(objectPath string)

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProxy interface {
	gextras.Objector

	// Call: asynchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is closed then the operation
	// will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
	// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
	// value not compatible with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_proxy_call (proxy,
	//                        "TwoStrings",
	//                        g_variant_new ("(ss)",
	//                                       "Thing One",
	//                                       "Thing Two"),
	//                        G_DBUS_CALL_FLAGS_NONE,
	//                        -1,
	//                        NULL,
	//                        (GAsyncReadyCallback) two_strings_done,
	//                        &data);
	//
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call g_dbus_proxy_call_finish() to
	// get the result of the operation. See g_dbus_proxy_call_sync() for the
	// synchronous version of this method.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallFinish finishes an operation started with g_dbus_proxy_call().
	CallFinish(res AsyncResult) *glib.Variant
	// CallSync: synchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is disconnected then the
	// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
	// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
	// contains a value not compatible with the D-Bus protocol, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_proxy_call_sync (proxy,
	//                             "TwoStrings",
	//                             g_variant_new ("(ss)",
	//                                            "Thing One",
	//                                            "Thing Two"),
	//                             G_DBUS_CALL_FLAGS_NONE,
	//                             -1,
	//                             NULL,
	//                             &error);
	//
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_proxy_call() for the asynchronous version of this method.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant
	// CallWithUnixFdList: like g_dbus_proxy_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_proxy_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant)
	// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
	// returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)
	// CachedProperty looks up the value for a property from the cache. This
	// call does no blocking IO.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	CachedProperty(propertyName string) *glib.Variant
	// CachedPropertyNames gets the names of all cached properties on @proxy.
	CachedPropertyNames() []string
	// Connection gets the connection @proxy is for.
	Connection() DBusConnection
	// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
	// is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	DefaultTimeout() int
	// Flags gets the flags that @proxy was constructed with.
	Flags() DBusProxyFlags
	// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
	// interface that @proxy conforms to. See the BusProxy:g-interface-info
	// property for more details.
	InterfaceInfo() *DBusInterfaceInfo
	// InterfaceName gets the D-Bus interface name @proxy is for.
	InterfaceName() string
	// Name gets the name that @proxy was constructed for.
	Name() string
	// NameOwner: the unique name that owns the name that @proxy is for or nil
	// if no-one currently owns that name. You may connect to the
	// #GObject::notify signal to track changes to the BusProxy:g-name-owner
	// property.
	NameOwner() string
	// ObjectPath gets the object path @proxy is for.
	ObjectPath() string
	// SetCachedProperty: if @value is not nil, sets the cached value for the
	// property with name @property_name to the value in @value.
	//
	// If @value is nil, then the cached value is removed from the property
	// cache.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	//
	// If the @value #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.
	//
	//     g_dbus_proxy_set_cached_property (proxy,
	//                                       "SomeProperty",
	//                                       g_variant_new ("(si)",
	//                                                     "A String",
	//                                                     42));
	//
	//
	// Normally you will not need to use this method since @proxy is tracking
	// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
	// D-Bus signal. However, for performance reasons an object may decide to
	// not use this signal for some properties and instead use a proprietary
	// out-of-band mechanism to transmit changes.
	//
	// As a concrete example, consider an object with a property
	// `ChatroomParticipants` which is an array of strings. Instead of
	// transmitting the same (long) array every time the property changes, it is
	// more efficient to only transmit the delta using e.g. signals
	// `ChatroomParticipantJoined(String name)` and
	// `ChatroomParticipantParted(String name)`.
	SetCachedProperty(propertyName string, value *glib.Variant)
	// SetDefaultTimeout sets the timeout to use if -1 (specifying default
	// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	SetDefaultTimeout(timeoutMsec int)
	// SetInterfaceInfo: ensure that interactions with @proxy conform to the
	// given interface. See the BusProxy:g-interface-info property for more
	// details.
	SetInterfaceInfo(info *DBusInterfaceInfo)
}

type dBusProxy struct {
	*externglib.Object
}

// WrapDBusProxy wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusProxy(obj *externglib.Object) DBusProxy {
	return dBusProxy{*externglib.Object{obj}}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusProxy(obj), nil
}

func NewDBusProxyFinish(res AsyncResult) DBusProxy

func NewDBusProxyForBusFinish(res AsyncResult) DBusProxy

func NewDBusProxyForBusSync(busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) DBusProxy

func NewDBusProxySync(connection DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) DBusProxy

func (d dBusProxy) Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusProxy) CallFinish(res AsyncResult) *glib.Variant

func (d dBusProxy) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant

func (d dBusProxy) CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)

func (d dBusProxy) CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant)

func (d dBusProxy) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)

func (d dBusProxy) CachedProperty(propertyName string) *glib.Variant

func (d dBusProxy) CachedPropertyNames() []string

func (d dBusProxy) Connection() DBusConnection

func (d dBusProxy) DefaultTimeout() int

func (d dBusProxy) Flags() DBusProxyFlags

func (d dBusProxy) InterfaceInfo() *DBusInterfaceInfo

func (d dBusProxy) InterfaceName() string

func (d dBusProxy) Name() string

func (d dBusProxy) NameOwner() string

func (d dBusProxy) ObjectPath() string

func (d dBusProxy) SetCachedProperty(propertyName string, value *glib.Variant)

func (d dBusProxy) SetDefaultTimeout(timeoutMsec int)

func (d dBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo)

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with G-DBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer.
type DBusServer interface {
	gextras.Objector

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

type dBusServer struct {
	*externglib.Object
}

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return dBusServer{*externglib.Object{obj}}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) DBusServer

func (d dBusServer) ClientAddress() string

func (d dBusServer) Flags() DBusServerFlags

func (d dBusServer) Guid() string

func (d dBusServer) IsActive() bool

func (d dBusServer) Start()

func (d dBusServer) Stop()

// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream interface {
	BufferedInputStream

	// ByteOrder gets the byte order for the data input stream.
	ByteOrder() DataStreamByteOrder
	// NewlineType gets the current newline type for the @stream.
	NewlineType() DataStreamNewlineType
	// ReadByte reads an unsigned 8-bit/1-byte value from @stream.
	ReadByte(cancellable Cancellable) uint8
	// ReadInt16 reads a 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadInt16(cancellable Cancellable) int16
	// ReadInt32 reads a signed 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt32(cancellable Cancellable) int32
	// ReadInt64 reads a 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt64(cancellable Cancellable) int64
	// ReadLine reads a line from the data input stream. Note that no encoding
	// checks or conversion is performed; the input is not guaranteed to be
	// UTF-8, and may in fact have embedded NUL characters.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLine(cancellable Cancellable) (length uint, guint8s []uint8)
	// ReadLineAsync: the asynchronous version of
	// g_data_input_stream_read_line(). It is an error to have two outstanding
	// calls to this function.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_line_finish() to get the result of the
	// operation.
	ReadLineAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadLineFinish: finish an asynchronous call started by
	// g_data_input_stream_read_line_async(). Note the warning about string
	// encoding in g_data_input_stream_read_line() applies here as well.
	ReadLineFinish(result AsyncResult) (length uint, guint8s []uint8)
	// ReadLineFinishUTF8: finish an asynchronous call started by
	// g_data_input_stream_read_line_async().
	ReadLineFinishUTF8(result AsyncResult) (length uint, utf8 string)
	// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLineUTF8(cancellable Cancellable) (length uint, utf8 string)
	// ReadUint16 reads an unsigned 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadUint16(cancellable Cancellable) uint16
	// ReadUint32 reads an unsigned 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint32(cancellable Cancellable) uint32
	// ReadUint64 reads an unsigned 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint64(cancellable Cancellable) uint64
	// ReadUntil reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// Note that, in contrast to g_data_input_stream_read_until_async(), this
	// function consumes the stop character that it finds.
	//
	// Don't use this function in new code. Its functionality is inconsistent
	// with g_data_input_stream_read_until_async(). Both functions will be
	// marked as deprecated in a future release. Use
	// g_data_input_stream_read_upto() instead, but note that that function does
	// not consume the stop character.
	ReadUntil(stopChars string, cancellable Cancellable) (length uint, utf8 string)
	// ReadUntilAsync: the asynchronous version of
	// g_data_input_stream_read_until(). It is an error to have two outstanding
	// calls to this function.
	//
	// Note that, in contrast to g_data_input_stream_read_until(), this function
	// does not consume the stop character that it finds. You must read it for
	// yourself.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_until_finish() to get the result of the
	// operation.
	//
	// Don't use this function in new code. Its functionality is inconsistent
	// with g_data_input_stream_read_until(). Both functions will be marked as
	// deprecated in a future release. Use g_data_input_stream_read_upto_async()
	// instead.
	ReadUntilAsync(stopChars string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadUntilFinish: finish an asynchronous call started by
	// g_data_input_stream_read_until_async().
	ReadUntilFinish(result AsyncResult) (length uint, utf8 string)
	// ReadUpto reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// In contrast to g_data_input_stream_read_until(), this function does not
	// consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	//
	// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
	//
	// The returned string will always be nul-terminated on success.
	ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (length uint, utf8 string)
	// ReadUptoAsync: the asynchronous version of
	// g_data_input_stream_read_upto(). It is an error to have two outstanding
	// calls to this function.
	//
	// In contrast to g_data_input_stream_read_until(), this function does not
	// consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	//
	// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_upto_finish() to get the result of the
	// operation.
	ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadUptoFinish: finish an asynchronous call started by
	// g_data_input_stream_read_upto_async().
	//
	// Note that this function does not consume the stop character. You have to
	// use g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto_async() again.
	//
	// The returned string will always be nul-terminated on success.
	ReadUptoFinish(result AsyncResult) (length uint, utf8 string)
	// SetByteOrder: this function sets the byte order for the given @stream.
	// All subsequent reads from the @stream will be read in the given @order.
	SetByteOrder(order DataStreamByteOrder)
	// SetNewlineType sets the newline type for the @stream.
	//
	// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a
	// read chunk ends in "CR" we must read an additional byte to know if this
	// is "CR" or "CR LF", and this might block if there is no more data
	// available.
	SetNewlineType(_type DataStreamNewlineType)
}

type dataInputStream struct {
	bufferedInputStream
}

// WrapDataInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataInputStream(obj *externglib.Object) DataInputStream {
	return dataInputStream{bufferedInputStream{filterInputStream{inputStream{*externglib.Object{obj}}}}}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataInputStream(obj), nil
}

func NewDataInputStream(baseStream InputStream) DataInputStream

func (d dataInputStream) ByteOrder() DataStreamByteOrder

func (d dataInputStream) NewlineType() DataStreamNewlineType

func (d dataInputStream) ReadByte(cancellable Cancellable) uint8

func (d dataInputStream) ReadInt16(cancellable Cancellable) int16

func (d dataInputStream) ReadInt32(cancellable Cancellable) int32

func (d dataInputStream) ReadInt64(cancellable Cancellable) int64

func (d dataInputStream) ReadLine(cancellable Cancellable) (length uint, guint8s []uint8)

func (d dataInputStream) ReadLineAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (d dataInputStream) ReadLineFinish(result AsyncResult) (length uint, guint8s []uint8)

func (d dataInputStream) ReadLineFinishUTF8(result AsyncResult) (length uint, utf8 string)

func (d dataInputStream) ReadLineUTF8(cancellable Cancellable) (length uint, utf8 string)

func (d dataInputStream) ReadUint16(cancellable Cancellable) uint16

func (d dataInputStream) ReadUint32(cancellable Cancellable) uint32

func (d dataInputStream) ReadUint64(cancellable Cancellable) uint64

func (d dataInputStream) ReadUntil(stopChars string, cancellable Cancellable) (length uint, utf8 string)

func (d dataInputStream) ReadUntilAsync(stopChars string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (d dataInputStream) ReadUntilFinish(result AsyncResult) (length uint, utf8 string)

func (d dataInputStream) ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (length uint, utf8 string)

func (d dataInputStream) ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (d dataInputStream) ReadUptoFinish(result AsyncResult) (length uint, utf8 string)

func (d dataInputStream) SetByteOrder(order DataStreamByteOrder)

func (d dataInputStream) SetNewlineType(_type DataStreamNewlineType)

// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
type DataOutputStream interface {
	FilterOutputStream

	// ByteOrder gets the byte order for the stream.
	ByteOrder() DataStreamByteOrder
	// PutByte puts a byte into the output stream.
	PutByte(data uint8, cancellable Cancellable) bool
	// PutInt16 puts a signed 16-bit integer into the output stream.
	PutInt16(data int16, cancellable Cancellable) bool
	// PutInt32 puts a signed 32-bit integer into the output stream.
	PutInt32(data int32, cancellable Cancellable) bool
	// PutInt64 puts a signed 64-bit integer into the stream.
	PutInt64(data int64, cancellable Cancellable) bool
	// PutString puts a string into the output stream.
	PutString(str string, cancellable Cancellable) bool
	// PutUint16 puts an unsigned 16-bit integer into the output stream.
	PutUint16(data uint16, cancellable Cancellable) bool
	// PutUint32 puts an unsigned 32-bit integer into the stream.
	PutUint32(data uint32, cancellable Cancellable) bool
	// PutUint64 puts an unsigned 64-bit integer into the stream.
	PutUint64(data uint64, cancellable Cancellable) bool
	// SetByteOrder sets the byte order of the data output stream to @order.
	SetByteOrder(order DataStreamByteOrder)
}

type dataOutputStream struct {
	filterOutputStream
}

// WrapDataOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataOutputStream(obj *externglib.Object) DataOutputStream {
	return dataOutputStream{filterOutputStream{outputStream{*externglib.Object{obj}}}}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataOutputStream(obj), nil
}

func NewDataOutputStream(baseStream OutputStream) DataOutputStream

func (d dataOutputStream) ByteOrder() DataStreamByteOrder

func (d dataOutputStream) PutByte(data uint8, cancellable Cancellable) bool

func (d dataOutputStream) PutInt16(data int16, cancellable Cancellable) bool

func (d dataOutputStream) PutInt32(data int32, cancellable Cancellable) bool

func (d dataOutputStream) PutInt64(data int64, cancellable Cancellable) bool

func (d dataOutputStream) PutString(str string, cancellable Cancellable) bool

func (d dataOutputStream) PutUint16(data uint16, cancellable Cancellable) bool

func (d dataOutputStream) PutUint32(data uint32, cancellable Cancellable) bool

func (d dataOutputStream) PutUint64(data uint64, cancellable Cancellable) bool

func (d dataOutputStream) SetByteOrder(order DataStreamByteOrder)

// DesktopAppInfo is an implementation of Info based on desktop files.
//
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type DesktopAppInfo interface {
	gextras.Objector

	// ActionName gets the user-visible display name of the "additional
	// application action" specified by @action_name.
	//
	// This corresponds to the "Name" key within the keyfile group for the
	// action.
	ActionName(actionName string) string
	// Boolean looks up a boolean value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	Boolean(key string) bool
	// Categories gets the categories from the desktop file.
	Categories() string
	// Filename: when @info was created from a known filename, return it. In
	// some situations such as the AppInfo returned from
	// g_desktop_app_info_new_from_keyfile(), this function will return nil.
	Filename() string
	// GenericName gets the generic name from the destkop file.
	GenericName() string
	// IsHidden: a desktop file is hidden if the Hidden key in it is set to
	// True.
	IsHidden() bool
	// Keywords gets the keywords from the desktop file.
	Keywords() []string
	// LocaleString looks up a localized string value in the keyfile backing
	// @info translated to the current locale.
	//
	// The @key is looked up in the "Desktop Entry" group.
	LocaleString(key string) string
	// Nodisplay gets the value of the NoDisplay key, which helps determine if
	// the application info should be shown in menus. See
	// KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
	Nodisplay() bool
	// ShowIn checks if the application info should be shown in menus that list
	// available applications for a specific name of the desktop, based on the
	// `OnlyShowIn` and `NotShowIn` keys.
	//
	// @desktop_env should typically be given as nil, in which case the
	// `XDG_CURRENT_DESKTOP` environment variable is consulted. If you want to
	// override the default mechanism then you may specify @desktop_env, but
	// this is not recommended.
	//
	// Note that g_app_info_should_show() for @info will include this check
	// (with nil for @desktop_env) as well as additional checks.
	ShowIn(desktopEnv string) bool
	// StartupWmClass retrieves the StartupWMClass field from @info. This
	// represents the WM_CLASS property of the main window of the application,
	// if launched through @info.
	StartupWmClass() string
	// String looks up a string value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	String(key string) string
	// StringList looks up a string list value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	StringList(key string) (length uint, utf8s []string)
	// HasKey returns whether @key exists in the "Desktop Entry" group of the
	// keyfile backing @info.
	HasKey(key string) bool
	// LaunchAction activates the named application action.
	//
	// You may only call this function on action names that were returned from
	// g_desktop_app_info_list_actions().
	//
	// Note that if the main entry of the desktop file indicates that the
	// application supports startup notification, and @launch_context is
	// non-nil, then startup notification will be used when activating the
	// action (and as such, invocation of the action on the receiving side must
	// signal the end of startup notification when it is completed). This is the
	// expected behaviour of applications declaring additional actions, as per
	// the desktop file specification.
	//
	// As with g_app_info_launch() there is no way to detect failures that occur
	// while using this function.
	LaunchAction(actionName string, launchContext AppLaunchContext)
	// LaunchUrisAsManager: this function performs the equivalent of
	// g_app_info_launch_uris(), but is intended primarily for operating system
	// components that launch applications. Ordinary applications should use
	// g_app_info_launch_uris().
	//
	// If the application is launched via GSpawn, then @spawn_flags, @user_setup
	// and @user_setup_data are used for the call to g_spawn_async().
	// Additionally, @pid_callback (with @pid_callback_data) will be called to
	// inform about the PID of the created process. See
	// g_spawn_async_with_pipes() for information on certain parameter
	// conditions that can enable an optimized posix_spawn() codepath to be
	// used.
	//
	// If application launching occurs via some other mechanism (eg: D-Bus
	// activation) then @spawn_flags, @user_setup, @user_setup_data,
	// @pid_callback and @pid_callback_data are ignored.
	LaunchUrisAsManager(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback) bool
	// LaunchUrisAsManagerWithFds: equivalent to
	// g_desktop_app_info_launch_uris_as_manager() but allows you to pass in
	// file descriptors for the stdin, stdout and stderr streams of the launched
	// process.
	//
	// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
	// activation) then @stdin_fd, @stdout_fd and @stderr_fd are ignored.
	LaunchUrisAsManagerWithFds(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback, stdinFd int, stdoutFd int, stderrFd int) bool
	// ListActions returns the list of "additional application actions"
	// supported on the desktop file, as per the desktop file specification.
	//
	// As per the specification, this is the list of actions that are explicitly
	// listed in the "Actions" key of the [Desktop Entry] group.
	ListActions() []string
}

type desktopAppInfo struct {
	*externglib.Object
}

// WrapDesktopAppInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapDesktopAppInfo(obj *externglib.Object) DesktopAppInfo {
	return desktopAppInfo{*externglib.Object{obj}}
}

func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDesktopAppInfo(obj), nil
}

func NewDesktopAppInfo(desktopID string) DesktopAppInfo

func NewDesktopAppInfoFromFilename(filename string) DesktopAppInfo

func NewDesktopAppInfoFromKeyfile(keyFile *glib.KeyFile) DesktopAppInfo

func (d desktopAppInfo) ActionName(actionName string) string

func (d desktopAppInfo) Boolean(key string) bool

func (d desktopAppInfo) Categories() string

func (d desktopAppInfo) Filename() string

func (d desktopAppInfo) GenericName() string

func (d desktopAppInfo) IsHidden() bool

func (d desktopAppInfo) Keywords() []string

func (d desktopAppInfo) LocaleString(key string) string

func (d desktopAppInfo) Nodisplay() bool

func (d desktopAppInfo) ShowIn(desktopEnv string) bool

func (d desktopAppInfo) StartupWmClass() string

func (d desktopAppInfo) String(key string) string

func (d desktopAppInfo) StringList(key string) (length uint, utf8s []string)

func (d desktopAppInfo) HasKey(key string) bool

func (d desktopAppInfo) LaunchAction(actionName string, launchContext AppLaunchContext)

func (d desktopAppInfo) LaunchUrisAsManager(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback) bool

func (d desktopAppInfo) LaunchUrisAsManagerWithFds(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback, stdinFd int, stdoutFd int, stderrFd int) bool

func (d desktopAppInfo) ListActions() []string

// Emblem is an implementation of #GIcon that supports having an emblem, which
// is an icon with additional properties. It can than be added to a Icon.
//
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
type Emblem interface {
	gextras.Objector

	// Icon gives back the icon from @emblem.
	Icon() Icon
	// Origin gets the origin of the emblem.
	Origin() EmblemOrigin
}

type emblem struct {
	*externglib.Object
}

// WrapEmblem wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblem(obj *externglib.Object) Emblem {
	return emblem{*externglib.Object{obj}}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblem(obj), nil
}

func NewEmblem(icon Icon) Emblem

func NewEmblemWithOrigin(icon Icon, origin EmblemOrigin) Emblem

func (e emblem) Icon() Icon

func (e emblem) Origin() EmblemOrigin

// EmblemedIcon is an implementation of #GIcon that supports adding an emblem to
// an icon. Adding multiple emblems to an icon is ensured via
// g_emblemed_icon_add_emblem().
//
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
type EmblemedIcon interface {
	gextras.Objector

	// AddEmblem adds @emblem to the #GList of #GEmblems.
	AddEmblem(emblem Emblem)
	// ClearEmblems removes all the emblems from @icon.
	ClearEmblems()
	// Emblems gets the list of emblems for the @icon.
	Emblems() *glib.List
	// Icon gets the main icon for @emblemed.
	Icon() Icon
}

type emblemedIcon struct {
	*externglib.Object
}

// WrapEmblemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblemedIcon(obj *externglib.Object) EmblemedIcon {
	return emblemedIcon{*externglib.Object{obj}}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblemedIcon(obj), nil
}

func NewEmblemedIcon(icon Icon, emblem Emblem) EmblemedIcon

func (e emblemedIcon) AddEmblem(emblem Emblem)

func (e emblemedIcon) ClearEmblems()

func (e emblemedIcon) Emblems() *glib.List

func (e emblemedIcon) Icon() Icon

// FileEnumerator allows you to operate on a set of #GFiles, returning a Info
// structure for each file enumerated (e.g. g_file_enumerate_children() will
// return a Enumerator for each of the children within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator interface {
	gextras.Objector

	// Close releases all resources used by this enumerator, making the
	// enumerator return G_IO_ERROR_CLOSED on all calls.
	//
	// This will be automatically called when the last reference is dropped, but
	// you might want to call this function to make sure resources are released
	// as early as possible.
	Close(cancellable Cancellable) bool
	// CloseAsync: asynchronously closes the file enumerator.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
	// g_file_enumerator_close_finish().
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish finishes closing a file enumerator, started from
	// g_file_enumerator_close_async().
	//
	// If the file enumerator was already closed when
	// g_file_enumerator_close_async() was called, then this function will
	// report G_IO_ERROR_CLOSED in @error, and return false. If the file
	// enumerator had pending operation when the close operation was started,
	// then this function will report G_IO_ERROR_PENDING, and return false. If
	// @cancellable was not nil, then the operation may have been cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and false will
	// be returned.
	CloseFinish(result AsyncResult) bool
	// Child: return a new #GFile which refers to the file named by @info in the
	// source directory of @enumerator. This function is primarily intended to
	// be used inside loops with g_file_enumerator_next_file().
	//
	// This is a convenience method that's equivalent to:
	//
	//      gchar *name = g_file_info_get_name (info);
	//      GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
	//                                       name);
	//
	Child(info FileInfo) File
	// Container: get the #GFile container which is being enumerated.
	Container() File
	// HasPending checks if the file enumerator has pending operations.
	HasPending() bool
	// IsClosed checks if the file enumerator has been closed.
	IsClosed() bool
	// Iterate: this is a version of g_file_enumerator_next_file() that's easier
	// to use correctly from C programs. With g_file_enumerator_next_file(), the
	// gboolean return value signifies "end of iteration or error", which
	// requires allocation of a temporary #GError.
	//
	// In contrast, with this function, a false return from
	// g_file_enumerator_iterate() *always* means "error". End of iteration is
	// signaled by @out_info or @out_child being nil.
	//
	// Another crucial difference is that the references for @out_info and
	// @out_child are owned by @direnum (they are cached as hidden properties).
	// You must not unref them in your own code. This makes memory management
	// significantly easier for C code in combination with loops.
	//
	// Finally, this function optionally allows retrieving a #GFile as well.
	//
	// You must specify at least one of @out_info or @out_child.
	//
	// The code pattern for correctly using g_file_enumerator_iterate() from C
	// is:
	//
	//
	//    direnum = g_file_enumerate_children (file, ...);
	//    while (TRUE)
	//      {
	//        GFileInfo *info;
	//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
	//          goto out;
	//        if (!info)
	//          break;
	//        ... do stuff with "info"; do not unref it! ...
	//      }
	//
	//    out:
	//      g_object_unref (direnum); // Note: frees the last @info
	//
	Iterate(cancellable Cancellable) (outInfo FileInfo, outChild File, ok bool)
	// NextFile returns information for the next file in the enumerated object.
	// Will block until the information is available. The Info returned from
	// this function will contain attributes that match the attribute string
	// that was passed when the Enumerator was created.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// On error, returns nil and sets @error to the error. If the enumerator is
	// at the end, nil will be returned and @error will be unset.
	NextFile(cancellable Cancellable) FileInfo
	// NextFilesAsync: request information for a number of files from the
	// enumerator asynchronously. When all i/o for the operation is finished the
	// @callback will be called with the requested information.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// The callback can be called with less than @num_files files in case of
	// error or at the end of the enumerator. In case of a partial error the
	// callback will be called with any succeeding items and no error, and on
	// the next request the error will be reported. If a request is cancelled
	// the callback will be called with G_IO_ERROR_CANCELLED.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	NextFilesAsync(numFiles int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// NextFilesFinish finishes the asynchronous operation started with
	// g_file_enumerator_next_files_async().
	NextFilesFinish(result AsyncResult) *glib.List
	// SetPending sets the file enumerator as having pending operations.
	SetPending(pending bool)
}

type fileEnumerator struct {
	*externglib.Object
}

// WrapFileEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileEnumerator(obj *externglib.Object) FileEnumerator {
	return fileEnumerator{*externglib.Object{obj}}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileEnumerator(obj), nil
}

func (f fileEnumerator) Close(cancellable Cancellable) bool

func (f fileEnumerator) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (f fileEnumerator) CloseFinish(result AsyncResult) bool

func (f fileEnumerator) Child(info FileInfo) File

func (f fileEnumerator) Container() File

func (f fileEnumerator) HasPending() bool

func (f fileEnumerator) IsClosed() bool

func (f fileEnumerator) Iterate(cancellable Cancellable) (outInfo FileInfo, outChild File, ok bool)

func (f fileEnumerator) NextFile(cancellable Cancellable) FileInfo

func (f fileEnumerator) NextFilesAsync(numFiles int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (f fileEnumerator) NextFilesFinish(result AsyncResult) *glib.List

func (f fileEnumerator) SetPending(pending bool)

// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream interface {
	IOStream

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file io stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_io_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync: asynchronously queries the @stream for a Info. When
	// completed, @callback will be called with a Result which can be used to
	// finish the operation with g_file_io_stream_query_info_finish().
	//
	// For the synchronous version of this function, see
	// g_file_io_stream_query_info().
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_io_stream_query_info_async().
	QueryInfoFinish(result AsyncResult) FileInfo
}

type fileIOStream struct {
	ioStream
}

// WrapFileIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIOStream(obj *externglib.Object) FileIOStream {
	return fileIOStream{ioStream{*externglib.Object{obj}}}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIOStream(obj), nil
}

func (f fileIOStream) Etag() string

func (f fileIOStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo

func (f fileIOStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (f fileIOStream) QueryInfoFinish(result AsyncResult) FileInfo

// FileIcon specifies an icon by pointing to an image file to be used as icon.
type FileIcon interface {
	gextras.Objector

	// File gets the #GFile associated with the given @icon.
	File() File
}

type fileIcon struct {
	*externglib.Object
}

// WrapFileIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIcon(obj *externglib.Object) FileIcon {
	return fileIcon{*externglib.Object{obj}}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIcon(obj), nil
}

func NewFileIcon(file File) FileIcon

func (f fileIcon) File() File

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo interface {
	gextras.Objector

	// ClearStatus clears the status information from @info.
	ClearStatus()
	// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
	// @dest_info, and then copies all of the file attributes from @src_info to
	// @dest_info.
	CopyInto(destInfo FileInfo)
	// Dup duplicates a file info structure.
	Dup() FileInfo
	// AttributeAsString gets the value of a attribute, formatted as a string.
	// This escapes things as needed to make the string valid UTF-8.
	AttributeAsString(attribute string) string
	// AttributeBoolean gets the value of a boolean attribute. If the attribute
	// does not contain a boolean value, false will be returned.
	AttributeBoolean(attribute string) bool
	// AttributeByteString gets the value of a byte string attribute. If the
	// attribute does not contain a byte string, nil will be returned.
	AttributeByteString(attribute string) string
	// AttributeData gets the attribute type, value and status for an attribute
	// key.
	AttributeData(attribute string) (_type FileAttributeType, valuePp interface{}, status FileAttributeStatus, ok bool)
	// AttributeInt32 gets a signed 32-bit integer contained within the
	// attribute. If the attribute does not contain a signed 32-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt32(attribute string) int32
	// AttributeInt64 gets a signed 64-bit integer contained within the
	// attribute. If the attribute does not contain a signed 64-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt64(attribute string) int64
	// AttributeObject gets the value of a #GObject attribute. If the attribute
	// does not contain a #GObject, nil will be returned.
	AttributeObject(attribute string) gextras.Objector
	// AttributeStatus gets the attribute status for an attribute key.
	AttributeStatus(attribute string) FileAttributeStatus
	// AttributeString gets the value of a string attribute. If the attribute
	// does not contain a string, nil will be returned.
	AttributeString(attribute string) string
	// AttributeStringv gets the value of a stringv attribute. If the attribute
	// does not contain a stringv, nil will be returned.
	AttributeStringv(attribute string) []string
	// AttributeType gets the attribute type for an attribute key.
	AttributeType(attribute string) FileAttributeType
	// AttributeUint32 gets an unsigned 32-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 32-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint32(attribute string) uint32
	// AttributeUint64 gets a unsigned 64-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 64-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint64(attribute string) uint64
	// ContentType gets the file's content type.
	ContentType() string
	// DeletionDate returns the Time representing the deletion date of the file,
	// as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
	// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, nil is returned.
	DeletionDate() *glib.DateTime
	// DisplayName gets a display name for a file. This is guaranteed to always
	// be set.
	DisplayName() string
	// EditName gets the edit name for a file.
	EditName() string
	// Etag gets the [entity tag][gfile-etag] for a given Info. See
	// G_FILE_ATTRIBUTE_ETAG_VALUE.
	Etag() string
	// FileType gets a file's type (whether it is a regular file, symlink, etc).
	// This is different from the file's content type, see
	// g_file_info_get_content_type().
	FileType() FileType
	// Icon gets the icon for a file.
	Icon() Icon
	// IsBackup checks if a file is a backup file.
	IsBackup() bool
	// IsHidden checks if a file is hidden.
	IsHidden() bool
	// IsSymlink checks if a file is a symlink.
	IsSymlink() bool
	// ModificationDateTime gets the modification time of the current @info and
	// returns it as a Time.
	//
	// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will
	// have microsecond precision.
	ModificationDateTime() *glib.DateTime
	// ModificationTime gets the modification time of the current @info and sets
	// it in @result.
	ModificationTime() glib.TimeVal
	// Name gets the name for a file. This is guaranteed to always be set.
	Name() string
	// Size gets the file's size.
	Size() int64
	// SortOrder gets the value of the sort_order attribute from the Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SortOrder() int32
	// SymbolicIcon gets the symbolic icon for a file.
	SymbolicIcon() Icon
	// SymlinkTarget gets the symlink target for a given Info.
	SymlinkTarget() string
	// HasAttribute checks if a file info structure has an attribute named
	// @attribute.
	HasAttribute(attribute string) bool
	// HasNamespace checks if a file info structure has an attribute in the
	// specified @name_space.
	HasNamespace(nameSpace string) bool
	// ListAttributes lists the file info structure's attributes.
	ListAttributes(nameSpace string) []string
	// RemoveAttribute removes all cases of @attribute from @info if it exists.
	RemoveAttribute(attribute string)
	// SetAttribute sets the @attribute to contain the given value, if possible.
	// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for @type.
	SetAttribute(attribute string, _type FileAttributeType, valueP interface{})
	// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeBoolean(attribute string, attrValue bool)
	// SetAttributeByteString sets the @attribute to contain the given
	// @attr_value, if possible.
	SetAttributeByteString(attribute string, attrValue string)
	// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt32(attribute string, attrValue int32)
	// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt64(attribute string, attrValue int64)
	// SetAttributeMask sets @mask on @info to match specific attribute types.
	SetAttributeMask(mask *FileAttributeMatcher)
	// SetAttributeObject sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeObject(attribute string, attrValue gextras.Objector)
	// SetAttributeStatus sets the attribute status for an attribute key. This
	// is only needed by external code that implement
	// g_file_set_attributes_from_info() or similar functions.
	//
	// The attribute must exist in @info for this to work. Otherwise false is
	// returned and @info is unchanged.
	SetAttributeStatus(attribute string, status FileAttributeStatus) bool
	// SetAttributeString sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeString(attribute string, attrValue string)
	// SetAttributeStringv sets the @attribute to contain the given @attr_value,
	// if possible.
	//
	// Sinze: 2.22
	SetAttributeStringv(attribute string, attrValue []string)
	// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint32(attribute string, attrValue uint32)
	// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint64(attribute string, attrValue uint64)
	// SetContentType sets the content type attribute for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	SetContentType(contentType string)
	// SetDisplayName sets the display name for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	SetDisplayName(displayName string)
	// SetEditName sets the edit name for the current file. See
	// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	SetEditName(editName string)
	// SetFileType sets the file type in a Info to @type. See
	// G_FILE_ATTRIBUTE_STANDARD_TYPE.
	SetFileType(_type FileType)
	// SetIcon sets the icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_ICON.
	SetIcon(icon Icon)
	// SetIsHidden sets the "is_hidden" attribute in a Info according to
	// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	SetIsHidden(isHidden bool)
	// SetIsSymlink sets the "is_symlink" attribute in a Info according to
	// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	SetIsSymlink(isSymlink bool)
	// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given date/time value.
	SetModificationDateTime(mtime *glib.DateTime)
	// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given time value.
	SetModificationTime(mtime *glib.TimeVal)
	// SetName sets the name attribute for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_NAME.
	SetName(name string)
	// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
	// info to the given size.
	SetSize(size int64)
	// SetSortOrder sets the sort order attribute in the file info structure.
	// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SetSortOrder(sortOrder int32)
	// SetSymbolicIcon sets the symbolic icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	SetSymbolicIcon(icon Icon)
	// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
	// attribute in the file info to the given symlink target.
	SetSymlinkTarget(symlinkTarget string)
	// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
	// if one is set.
	UnsetAttributeMask()
}

type fileInfo struct {
	*externglib.Object
}

// WrapFileInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInfo(obj *externglib.Object) FileInfo {
	return fileInfo{*externglib.Object{obj}}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInfo(obj), nil
}

func NewFileInfo() FileInfo

func (f fileInfo) ClearStatus()

func (f fileInfo) CopyInto(destInfo FileInfo)

func (f fileInfo) Dup() FileInfo

func (f fileInfo) AttributeAsString(attribute string) string

func (f fileInfo) AttributeBoolean(attribute string) bool

func (f fileInfo) AttributeByteString(attribute string) string

func (f fileInfo) AttributeData(attribute string) (_type FileAttributeType, valuePp interface{}, status FileAttributeStatus, ok bool)

func (f fileInfo) AttributeInt32(attribute string) int32

func (f fileInfo) AttributeInt64(attribute string) int64

func (f fileInfo) AttributeObject(attribute string) gextras.Objector

func (f fileInfo) AttributeStatus(attribute string) FileAttributeStatus

func (f fileInfo) AttributeString(attribute string) string

func (f fileInfo) AttributeStringv(attribute string) []string

func (f fileInfo) AttributeType(attribute string) FileAttributeType

func (f fileInfo) AttributeUint32(attribute string) uint32

func (f fileInfo) AttributeUint64(attribute string) uint64

func (f fileInfo) ContentType() string

func (f fileInfo) DeletionDate() *glib.DateTime

func (f fileInfo) DisplayName() string

func (f fileInfo) EditName() string

func (f fileInfo) Etag() string

func (f fileInfo) FileType() FileType

func (f fileInfo) Icon() Icon

func (f fileInfo) IsBackup() bool

func (f fileInfo) IsHidden() bool

func (f fileInfo) IsSymlink() bool

func (f fileInfo) ModificationDateTime() *glib.DateTime

func (f fileInfo) ModificationTime() glib.TimeVal

func (f fileInfo) Name() string

func (f fileInfo) Size() int64

func (f fileInfo) SortOrder() int32

func (f fileInfo) SymbolicIcon() Icon

func (f fileInfo) SymlinkTarget() string

func (f fileInfo) HasAttribute(attribute string) bool

func (f fileInfo) HasNamespace(nameSpace string) bool

func (f fileInfo) ListAttributes(nameSpace string) []string

func (f fileInfo) RemoveAttribute(attribute string)

func (f fileInfo) SetAttribute(attribute string, _type FileAttributeType, valueP interface{})

func (f fileInfo) SetAttributeBoolean(attribute string, attrValue bool)

func (f fileInfo) SetAttributeByteString(attribute string, attrValue string)

func (f fileInfo) SetAttributeInt32(attribute string, attrValue int32)

func (f fileInfo) SetAttributeInt64(attribute string, attrValue int64)

func (f fileInfo) SetAttributeMask(mask *FileAttributeMatcher)

func (f fileInfo) SetAttributeObject(attribute string, attrValue gextras.Objector)

func (f fileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool

func (f fileInfo) SetAttributeString(attribute string, attrValue string)

func (f fileInfo) SetAttributeStringv(attribute string, attrValue []string)

func (f fileInfo) SetAttributeUint32(attribute string, attrValue uint32)

func (f fileInfo) SetAttributeUint64(attribute string, attrValue uint64)

func (f fileInfo) SetContentType(contentType string)

func (f fileInfo) SetDisplayName(displayName string)

func (f fileInfo) SetEditName(editName string)

func (f fileInfo) SetFileType(_type FileType)

func (f fileInfo) SetIcon(icon Icon)

func (f fileInfo) SetIsHidden(isHidden bool)

func (f fileInfo) SetIsSymlink(isSymlink bool)

func (f fileInfo) SetModificationDateTime(mtime *glib.DateTime)

func (f fileInfo) SetModificationTime(mtime *glib.TimeVal)

func (f fileInfo) SetName(name string)

func (f fileInfo) SetSize(size int64)

func (f fileInfo) SetSortOrder(sortOrder int32)

func (f fileInfo) SetSymbolicIcon(icon Icon)

func (f fileInfo) SetSymlinkTarget(symlinkTarget string)

func (f fileInfo) UnsetAttributeMask()

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream interface {
	InputStream

	// QueryInfo queries a file input stream the given @attributes. This
	// function blocks while querying the stream. For the asynchronous
	// (non-blocking) version of this function, see
	// g_file_input_stream_query_info_async(). While the stream is blocked, the
	// stream will set the pending flag internally, and any other operations on
	// the stream will fail with G_IO_ERROR_PENDING.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync queries the stream information asynchronously. When the
	// operation is finished @callback will be called. You can then call
	// g_file_input_stream_query_info_finish() to get the result of the
	// operation.
	//
	// For the synchronous version of this function, see
	// g_file_input_stream_query_info().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryInfoFinish finishes an asynchronous info query operation.
	QueryInfoFinish(result AsyncResult) FileInfo
}

type fileInputStream struct {
	inputStream
}

// WrapFileInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInputStream(obj *externglib.Object) FileInputStream {
	return fileInputStream{inputStream{*externglib.Object{obj}}}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInputStream(obj), nil
}

func (f fileInputStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo

func (f fileInputStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (f fileInputStream) QueryInfoFinish(result AsyncResult) FileInfo

// FileMonitor monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor interface {
	gextras.Objector

	// Cancel cancels a file monitor.
	Cancel() bool
	// EmitEvent emits the Monitor::changed signal if a change has taken place.
	// Should be called from file monitor implementations only.
	//
	// Implementations are responsible to call this method from the
	// [thread-default main context][g-main-context-push-thread-default] of the
	// thread that the monitor was created in.
	EmitEvent(child File, otherFile File, eventType FileMonitorEvent)
	// IsCancelled returns whether the monitor is canceled.
	IsCancelled() bool
	// SetRateLimit sets the rate limit to which the @monitor will report
	// consecutive change events to the same file.
	SetRateLimit(limitMsecs int)
}

type fileMonitor struct {
	*externglib.Object
}

// WrapFileMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileMonitor(obj *externglib.Object) FileMonitor {
	return fileMonitor{*externglib.Object{obj}}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileMonitor(obj), nil
}

func (f fileMonitor) Cancel() bool

func (f fileMonitor) EmitEvent(child File, otherFile File, eventType FileMonitorEvent)

func (f fileMonitor) IsCancelled() bool

func (f fileMonitor) SetRateLimit(limitMsecs int)

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
type FileOutputStream interface {
	OutputStream

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file output stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_output_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED).
	// In all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync: asynchronously queries the @stream for a Info. When
	// completed, @callback will be called with a Result which can be used to
	// finish the operation with g_file_output_stream_query_info_finish().
	//
	// For the synchronous version of this function, see
	// g_file_output_stream_query_info().
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryInfoFinish finalizes the asynchronous query started by
	// g_file_output_stream_query_info_async().
	QueryInfoFinish(result AsyncResult) FileInfo
}

type fileOutputStream struct {
	outputStream
}

// WrapFileOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileOutputStream(obj *externglib.Object) FileOutputStream {
	return fileOutputStream{outputStream{*externglib.Object{obj}}}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileOutputStream(obj), nil
}

func (f fileOutputStream) Etag() string

func (f fileOutputStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo

func (f fileOutputStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (f fileOutputStream) QueryInfoFinish(result AsyncResult) FileInfo

// FilenameCompleter completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter interface {
	gextras.Objector

	// CompletionSuffix obtains a completion for @initial_text from @completer.
	CompletionSuffix(initialText string) string
	// Completions gets an array of completion strings for a given initial text.
	Completions(initialText string) []string
	// SetDirsOnly: if @dirs_only is true, @completer will only complete
	// directory names, and not file names.
	SetDirsOnly(dirsOnly bool)
}

type filenameCompleter struct {
	*externglib.Object
}

// WrapFilenameCompleter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilenameCompleter(obj *externglib.Object) FilenameCompleter {
	return filenameCompleter{*externglib.Object{obj}}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilenameCompleter(obj), nil
}

func NewFilenameCompleter() FilenameCompleter

func (f filenameCompleter) CompletionSuffix(initialText string) string

func (f filenameCompleter) Completions(initialText string) []string

func (f filenameCompleter) SetDirsOnly(dirsOnly bool)

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream interface {
	InputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() InputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

type filterInputStream struct {
	inputStream
}

// WrapFilterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterInputStream(obj *externglib.Object) FilterInputStream {
	return filterInputStream{inputStream{*externglib.Object{obj}}}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterInputStream(obj), nil
}

func (f filterInputStream) BaseStream() InputStream

func (f filterInputStream) CloseBaseStream() bool

func (f filterInputStream) SetCloseBaseStream(closeBase bool)

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream interface {
	OutputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() OutputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

type filterOutputStream struct {
	outputStream
}

// WrapFilterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterOutputStream(obj *externglib.Object) FilterOutputStream {
	return filterOutputStream{outputStream{*externglib.Object{obj}}}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterOutputStream(obj), nil
}

func (f filterOutputStream) BaseStream() OutputStream

func (f filterOutputStream) CloseBaseStream() bool

func (f filterOutputStream) SetCloseBaseStream(closeBase bool)

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
//
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
//
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application can’t start any
// Stream or Stream operation while there is a OStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
//
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
type IOStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it. This will
	// also close the individual input and output streams, if they are not
	// already closed.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	//
	// The default implementation of this method just calls close on the
	// individual input/output streams.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous close of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_io_stream_close_finish() to get the result of
	// the operation.
	//
	// For behaviour details see g_io_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish closes a stream.
	CloseFinish(result AsyncResult) bool
	// InputStream gets the input stream for this object. This is used for
	// reading.
	InputStream() InputStream
	// OutputStream gets the output stream for this object. This is used for
	// writing.
	OutputStream() OutputStream
	// HasPending checks if a stream has pending actions.
	HasPending() bool
	// IsClosed checks if a stream is closed.
	IsClosed() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// SpliceAsync: asynchronously splice the output stream of @stream1 to the
	// input stream of @stream2, and splice the output stream of @stream2 to the
	// input stream of @stream1.
	//
	// When the operation is finished @callback will be called. You can then
	// call g_io_stream_splice_finish() to get the result of the operation.
	SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

type ioStream struct {
	*externglib.Object
}

// WrapIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapIOStream(obj *externglib.Object) IOStream {
	return ioStream{*externglib.Object{obj}}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIOStream(obj), nil
}

func (i ioStream) ClearPending()

func (i ioStream) Close(cancellable Cancellable) bool

func (i ioStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (i ioStream) CloseFinish(result AsyncResult) bool

func (i ioStream) InputStream() InputStream

func (i ioStream) OutputStream() OutputStream

func (i ioStream) HasPending() bool

func (i ioStream) IsClosed() bool

func (i ioStream) SetPending() bool

func (i ioStream) SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress interface {
	gextras.Objector

	// Equal checks if two Address instances are equal, e.g. the same address.
	Equal(otherAddress InetAddress) bool
	// Family gets @address's family
	Family() SocketFamily
	// IsAny tests whether @address is the "any" address for its family.
	IsAny() bool
	// IsLinkLocal tests whether @address is a link-local address (that is, if
	// it identifies a host on a local network that is not connected to the
	// Internet).
	IsLinkLocal() bool
	// IsLoopback tests whether @address is the loopback address for its family.
	IsLoopback() bool
	// IsMcGlobal tests whether @address is a global multicast address.
	IsMcGlobal() bool
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	IsMcLinkLocal() bool
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	IsMcNodeLocal() bool
	// IsMcOrgLocal tests whether @address is an organization-local multicast
	// address.
	IsMcOrgLocal() bool
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	IsMcSiteLocal() bool
	// IsMulticast tests whether @address is a multicast address.
	IsMulticast() bool
	// IsSiteLocal tests whether @address is a site-local address such as
	// 10.0.0.1 (that is, the address identifies a host on a local network that
	// can not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	IsSiteLocal() bool
	// NativeSize gets the size of the native raw binary address for @address.
	// This is the size of the data that you get from g_inet_address_to_bytes().
	NativeSize() uint
	// ToBytes gets the raw binary address data from @address.
	ToBytes() uint8
	// ToString converts @address to string form.
	ToString() string
}

type inetAddress struct {
	*externglib.Object
}

// WrapInetAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddress(obj *externglib.Object) InetAddress {
	return inetAddress{*externglib.Object{obj}}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddress(obj), nil
}

func NewInetAddressAny(family SocketFamily) InetAddress

func NewInetAddressFromBytes(bytes []uint8, family SocketFamily) InetAddress

func NewInetAddressFromString(string string) InetAddress

func NewInetAddressLoopback(family SocketFamily) InetAddress

func (i inetAddress) Equal(otherAddress InetAddress) bool

func (i inetAddress) Family() SocketFamily

func (i inetAddress) IsAny() bool

func (i inetAddress) IsLinkLocal() bool

func (i inetAddress) IsLoopback() bool

func (i inetAddress) IsMcGlobal() bool

func (i inetAddress) IsMcLinkLocal() bool

func (i inetAddress) IsMcNodeLocal() bool

func (i inetAddress) IsMcOrgLocal() bool

func (i inetAddress) IsMcSiteLocal() bool

func (i inetAddress) IsMulticast() bool

func (i inetAddress) IsSiteLocal() bool

func (i inetAddress) NativeSize() uint

func (i inetAddress) ToBytes() uint8

func (i inetAddress) ToString() string

// InetAddressMask represents a range of IPv4 or IPv6 addresses described by a
// base address and a length indicating how many bits of the base address are
// relevant for matching purposes. These are often given in string form. Eg,
// "10.0.0.0/8", or "fe80::/10".
type InetAddressMask interface {
	gextras.Objector

	// Equal tests if @mask and @mask2 are the same mask.
	Equal(mask2 InetAddressMask) bool
	// Address gets @mask's base address
	Address() InetAddress
	// Family gets the Family of @mask's address
	Family() SocketFamily
	// Length gets @mask's length
	Length() uint
	// Matches tests if @address falls within the range described by @mask.
	Matches(address InetAddress) bool
	// ToString converts @mask back to its corresponding string form.
	ToString() string
}

type inetAddressMask struct {
	*externglib.Object
}

// WrapInetAddressMask wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddressMask(obj *externglib.Object) InetAddressMask {
	return inetAddressMask{*externglib.Object{obj}}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddressMask(obj), nil
}

func NewInetAddressMask(addr InetAddress, length uint) InetAddressMask

func NewInetAddressMaskFromString(maskString string) InetAddressMask

func (i inetAddressMask) Equal(mask2 InetAddressMask) bool

func (i inetAddressMask) Address() InetAddress

func (i inetAddressMask) Family() SocketFamily

func (i inetAddressMask) Length() uint

func (i inetAddressMask) Matches(address InetAddress) bool

func (i inetAddressMask) ToString() string

// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
type InetSocketAddress interface {
	SocketAddress

	// Address gets @address's Address.
	Address() InetAddress
	// Flowinfo gets the `sin6_flowinfo` field from @address, which must be an
	// IPv6 address.
	Flowinfo() uint32
	// Port gets @address's port.
	Port() uint16
	// ScopeID gets the `sin6_scope_id` field from @address, which must be an
	// IPv6 address.
	ScopeID() uint32
}

type inetSocketAddress struct {
	socketAddress
}

// WrapInetSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetSocketAddress(obj *externglib.Object) InetSocketAddress {
	return inetSocketAddress{socketAddress{*externglib.Object{obj}}}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetSocketAddress(obj), nil
}

func NewInetSocketAddress(address InetAddress, port uint16) InetSocketAddress

func NewInetSocketAddressFromString(address string, port uint) InetSocketAddress

func (i inetSocketAddress) Address() InetAddress

func (i inetSocketAddress) Flowinfo() uint32

func (i inetSocketAddress) Port() uint16

func (i inetSocketAddress) ScopeID() uint32

// InputStream has functions to read from a stream (g_input_stream_read()), to
// close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous closes of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_input_stream_close_finish() to get the result
	// of the operation.
	//
	// For behaviour details see g_input_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish finishes closing a stream asynchronously, started from
	// g_input_stream_close_async().
	CloseFinish(result AsyncResult) bool
	// HasPending checks if an input stream has pending actions.
	HasPending() bool
	// IsClosed checks if an input stream is closed.
	IsClosed() bool
	// Read tries to read @count bytes from the stream into the buffer starting
	// at @buffer. Will block during this read.
	//
	// If count is zero returns zero and does nothing. A value of @count larger
	// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// The returned @buffer is not a nul-terminated string, it can contain nul
	// bytes at any position, and this function doesn't nul-terminate the
	// @buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	Read(cancellable Cancellable) (buffer []uint8, count uint, gssize int)
	// ReadAll tries to read @count bytes from the stream into the buffer
	// starting at @buffer. Will block during this read.
	//
	// This function is similar to g_input_stream_read(), except it tries to
	// read as many bytes as requested, only stopping on an error or end of
	// stream.
	//
	// On a successful read of @count bytes, or if we reached the end of the
	// stream, true is returned, and @bytes_read is set to the number of bytes
	// read into @buffer.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_input_stream_read().
	ReadAll(cancellable Cancellable) (buffer []uint8, count uint, bytesRead uint, ok bool)
	// ReadAllAsync: request an asynchronous read of @count bytes from the
	// stream into the buffer starting at @buffer.
	//
	// This is the asynchronous equivalent of g_input_stream_read_all().
	//
	// Call g_input_stream_read_all_finish() to collect the result.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	ReadAllAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []uint8, count uint)
	// ReadAllFinish finishes an asynchronous stream read operation started with
	// g_input_stream_read_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_input_stream_read_async().
	ReadAllFinish(result AsyncResult) (bytesRead uint, ok bool)
	// ReadAsync: request an asynchronous read of @count bytes from the stream
	// into the buffer starting at @buffer. When the operation is finished
	// @callback will be called. You can then call g_input_stream_read_finish()
	// to get the result of the operation.
	//
	// During an async request no other sync and async calls are allowed on
	// @stream, and will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer will be passed to
	// the callback. It is not an error if this is not the same as the requested
	// size, as it can happen e.g. near the end of a file, but generally we try
	// to read as many bytes as requested. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []uint8, count uint)
	// ReadBytes: like g_input_stream_read(), this tries to read @count bytes
	// from the stream in a blocking fashion. However, rather than reading into
	// a user-supplied buffer, this will create a new #GBytes containing the
	// data that was read. This may be easier to use from language bindings.
	//
	// If count is zero, returns a zero-length #GBytes and does nothing. A value
	// of @count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT
	// error.
	//
	// On success, a new #GBytes is returned. It is not an error if the size of
	// this object is not the same as the requested size, as it can happen e.g.
	// near the end of a file. A zero-length #GBytes is returned on end of file
	// (or if @count is zero), but never otherwise.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error nil is returned and @error is set accordingly.
	ReadBytes(count uint, cancellable Cancellable) *glib.Bytes
	// ReadBytesAsync: request an asynchronous read of @count bytes from the
	// stream into a new #GBytes. When the operation is finished @callback will
	// be called. You can then call g_input_stream_read_bytes_finish() to get
	// the result of the operation.
	//
	// During an async request no other sync and async calls are allowed on
	// @stream, and will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the new #GBytes will be passed to the callback. It is not an
	// error if this is smaller than the requested size, as it can happen e.g.
	// near the end of a file, but generally we try to read as many bytes as
	// requested. Zero is returned on end of file (or if @count is zero), but
	// never otherwise.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	ReadBytesAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadBytesFinish finishes an asynchronous stream read-into-#GBytes
	// operation.
	ReadBytesFinish(result AsyncResult) *glib.Bytes
	// ReadFinish finishes an asynchronous stream read operation.
	ReadFinish(result AsyncResult) int
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// Skip tries to skip @count bytes from the stream. Will block during the
	// operation.
	//
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some streams
	// have an implementation that is more efficient than reading the data.
	//
	// This function is optional for inherited classes, as the default
	// implementation emulates it using read.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Skip(count uint, cancellable Cancellable) int
	// SkipAsync: request an asynchronous skip of @count bytes from the stream.
	// When the operation is finished @callback will be called. You can then
	// call g_input_stream_skip_finish() to get the result of the operation.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes skipped will be passed to the callback.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file, but generally we try to skip as
	// many bytes as requested. Zero is returned on end of file (or if @count is
	// zero), but never otherwise.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one, you must override all.
	SkipAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SkipFinish finishes a stream skip operation.
	SkipFinish(result AsyncResult) int
}

type inputStream struct {
	*externglib.Object
}

// WrapInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapInputStream(obj *externglib.Object) InputStream {
	return inputStream{*externglib.Object{obj}}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInputStream(obj), nil
}

func (i inputStream) ClearPending()

func (i inputStream) Close(cancellable Cancellable) bool

func (i inputStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (i inputStream) CloseFinish(result AsyncResult) bool

func (i inputStream) HasPending() bool

func (i inputStream) IsClosed() bool

func (i inputStream) Read(cancellable Cancellable) (buffer []uint8, count uint, gssize int)

func (i inputStream) ReadAll(cancellable Cancellable) (buffer []uint8, count uint, bytesRead uint, ok bool)

func (i inputStream) ReadAllAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []uint8, count uint)

func (i inputStream) ReadAllFinish(result AsyncResult) (bytesRead uint, ok bool)

func (i inputStream) ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []uint8, count uint)

func (i inputStream) ReadBytes(count uint, cancellable Cancellable) *glib.Bytes

func (i inputStream) ReadBytesAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (i inputStream) ReadBytesFinish(result AsyncResult) *glib.Bytes

func (i inputStream) ReadFinish(result AsyncResult) int

func (i inputStream) SetPending() bool

func (i inputStream) Skip(count uint, cancellable Cancellable) int

func (i inputStream) SkipAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (i inputStream) SkipFinish(result AsyncResult) int

// ListStore is a simple implementation of Model that stores all items in
// memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore interface {
	gextras.Objector

	// Append appends @item to @store. @item must be of type Store:item-type.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to append multiple items at the same time
	// efficiently.
	Append(item gextras.Objector)
	// Find looks up the given @item in the list store by looping over the items
	// until the first occurrence of @item. If @item was not found, then
	// @position will not be set, and this method will return false.
	//
	// If you need to compare the two items with a custom comparison function,
	// use g_list_store_find_with_equal_func() with a custom Func instead.
	Find(item gextras.Objector) (position uint, ok bool)
	// FindWithEqualFunc looks up the given @item in the list store by looping
	// over the items and comparing them with @compare_func until the first
	// occurrence of @item which matches. If @item was not found, then @position
	// will not be set, and this method will return false.
	FindWithEqualFunc(item gextras.Objector, equalFunc glib.EqualFunc) (position uint, ok bool)
	// Insert inserts @item into @store at @position. @item must be of type
	// Store:item-type or derived from it. @position must be smaller than the
	// length of the list, or equal to it to append.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to insert multiple items at the same time
	// efficiently.
	Insert(position uint, item gextras.Objector)
	// InsertSorted inserts @item into @store at a position to be determined by
	// the @compare_func.
	//
	// The list must already be sorted before calling this function or the
	// result is undefined. Usually you would approach this by only ever
	// inserting items by way of this function.
	//
	// This function takes a ref on @item.
	InsertSorted(item gextras.Objector, compareFunc glib.CompareDataFunc) uint
	// Remove removes the item from @store that is at @position. @position must
	// be smaller than the current length of the list.
	//
	// Use g_list_store_splice() to remove multiple items at the same time
	// efficiently.
	Remove(position uint)
	// RemoveAll removes all items from @store.
	RemoveAll()
	// Sort: sort the items in @store according to @compare_func.
	Sort(compareFunc glib.CompareDataFunc)
	// Splice changes @store by removing @n_removals items and adding
	// @n_additions items to it. @additions must contain @n_additions items of
	// type Store:item-type. nil is not permitted.
	//
	// This function is more efficient than g_list_store_insert() and
	// g_list_store_remove(), because it only emits Model::items-changed once
	// for the change.
	//
	// This function takes a ref on each item in @additions.
	//
	// The parameters @position and @n_removals must be correct (ie: @position +
	// @n_removals must be less than or equal to the length of the list at the
	// time this function is called).
	Splice(position uint, nRemovals uint, additions []gextras.Objector)
}

type listStore struct {
	*externglib.Object
}

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return listStore{*externglib.Object{obj}}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

func NewListStore(itemType externglib.Type) ListStore

func (l listStore) Append(item gextras.Objector)

func (l listStore) Find(item gextras.Objector) (position uint, ok bool)

func (l listStore) FindWithEqualFunc(item gextras.Objector, equalFunc glib.EqualFunc) (position uint, ok bool)

func (l listStore) Insert(position uint, item gextras.Objector)

func (l listStore) InsertSorted(item gextras.Objector, compareFunc glib.CompareDataFunc) uint

func (l listStore) Remove(position uint)

func (l listStore) RemoveAll()

func (l listStore) Sort(compareFunc glib.CompareDataFunc)

func (l listStore) Splice(position uint, nRemovals uint, additions []gextras.Objector)

// MemoryInputStream is a class for using arbitrary memory chunks as input for
// GIO streaming input operations.
//
// As of GLib 2.34, InputStream implements InputStream.
type MemoryInputStream interface {
	InputStream

	// AddBytes appends @bytes to data that can be read from the input stream.
	AddBytes(bytes *glib.Bytes)
	// AddData appends @data to data that can be read from the input stream
	AddData(data []uint8)
}

type memoryInputStream struct {
	inputStream
}

// WrapMemoryInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryInputStream(obj *externglib.Object) MemoryInputStream {
	return memoryInputStream{inputStream{*externglib.Object{obj}}}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryInputStream(obj), nil
}

func NewMemoryInputStream() MemoryInputStream

func NewMemoryInputStreamFromBytes(bytes *glib.Bytes) MemoryInputStream

func NewMemoryInputStreamFromData(data []uint8) MemoryInputStream

func (m memoryInputStream) AddBytes(bytes *glib.Bytes)

func (m memoryInputStream) AddData(data []uint8)

// MemoryOutputStream is a class for using arbitrary memory chunks as output for
// GIO streaming output operations.
//
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
type MemoryOutputStream interface {
	OutputStream

	// Data gets any loaded data from the @ostream.
	//
	// Note that the returned pointer may become invalid on the next write or
	// truncate operation on the stream.
	Data() interface{}
	// DataSize returns the number of bytes from the start up to including the
	// last byte written in the stream that has not been truncated away.
	DataSize() uint
	// Size gets the size of the currently allocated data area (available from
	// g_memory_output_stream_get_data()).
	//
	// You probably don't want to use this function on resizable streams. See
	// g_memory_output_stream_get_data_size() instead. For resizable streams the
	// size returned by this function is an implementation detail and may be
	// change at any time in response to operations on the stream.
	//
	// If the stream is fixed-sized (ie: no realloc was passed to
	// g_memory_output_stream_new()) then this is the maximum size of the stream
	// and further writes will return G_IO_ERROR_NO_SPACE.
	//
	// In any case, if you want the number of bytes currently written to the
	// stream, use g_memory_output_stream_get_data_size().
	Size() uint
	// StealAsBytes returns data from the @ostream as a #GBytes. @ostream must
	// be closed before calling this function.
	StealAsBytes() *glib.Bytes
	// StealData gets any loaded data from the @ostream. Ownership of the data
	// is transferred to the caller; when no longer needed it must be freed
	// using the free function set in @ostream's OutputStream:destroy-function
	// property.
	//
	// @ostream must be closed before calling this function.
	StealData() interface{}
}

type memoryOutputStream struct {
	outputStream
}

// WrapMemoryOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryOutputStream(obj *externglib.Object) MemoryOutputStream {
	return memoryOutputStream{outputStream{*externglib.Object{obj}}}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryOutputStream(obj), nil
}

func NewMemoryOutputStream(data interface{}, size uint, reallocFunction ReallocFunc) MemoryOutputStream

func NewMemoryOutputStreamResizable() MemoryOutputStream

func (m memoryOutputStream) Data() interface{}

func (m memoryOutputStream) DataSize() uint

func (m memoryOutputStream) Size() uint

func (m memoryOutputStream) StealAsBytes() *glib.Bytes

func (m memoryOutputStream) StealData() interface{}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

type menu struct {
	menuModel
}

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{menuModel{*externglib.Object{obj}}}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

func NewMenu() Menu

func (m menu) Append(label string, detailedAction string)

func (m menu) AppendItem(item MenuItem)

func (m menu) AppendSection(label string, section MenuModel)

func (m menu) AppendSubmenu(label string, submenu MenuModel)

func (m menu) Freeze()

func (m menu) Insert(position int, label string, detailedAction string)

func (m menu) InsertItem(position int, item MenuItem)

func (m menu) InsertSection(position int, label string, section MenuModel)

func (m menu) InsertSubmenu(position int, label string, submenu MenuModel)

func (m menu) Prepend(label string, detailedAction string)

func (m menu) PrependItem(item MenuItem)

func (m menu) PrependSection(label string, section MenuModel)

func (m menu) PrependSubmenu(label string, submenu MenuModel)

func (m menu) Remove(position int)

func (m menu) RemoveAll()

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter interface {
	gextras.Objector

	// Name gets the name of the attribute at the current iterator position, as
	// a string.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute. If
	// that fails, then false is returned and there are no other effects.
	//
	// If successful, @name and @value are set to the name and value of the
	// attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in @name remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	GetNext() (outName string, value *glib.Variant, ok bool)
	// Value gets the value of the attribute at the current iterator position.
	//
	// The iterator is not advanced.
	Value() *glib.Variant
	// Next attempts to advance the iterator to the next (possibly first)
	// attribute.
	//
	// true is returned on success, or false if there are no more attributes.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first attribute (and determine if the first attribute
	// exists at all).
	Next() bool
}

type menuAttributeIter struct {
	*externglib.Object
}

// WrapMenuAttributeIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuAttributeIter(obj *externglib.Object) MenuAttributeIter {
	return menuAttributeIter{*externglib.Object{obj}}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuAttributeIter(obj), nil
}

func (m menuAttributeIter) Name() string

func (m menuAttributeIter) GetNext() (outName string, value *glib.Variant, ok bool)

func (m menuAttributeIter) Value() *glib.Variant

func (m menuAttributeIter) Next() bool

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	//
	// This call is the same as calling g_icon_serialize() and using the result
	// as the value to g_menu_item_set_attribute_value() for
	// G_MENU_ATTRIBUTE_ICON.
	//
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu. Don't use it on menu
	// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
	//
	// If @icon is nil then the icon is unset.
	SetIcon(icon Icon)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

type menuItem struct {
	*externglib.Object
}

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{*externglib.Object{obj}}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

func NewMenuItem(label string, detailedAction string) MenuItem

func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem

func NewMenuItemSection(label string, section MenuModel) MenuItem

func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem

func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant

func (m menuItem) Link(link string) MenuModel

func (m menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant)

func (m menuItem) SetAttributeValue(attribute string, value *glib.Variant)

func (m menuItem) SetDetailedAction(detailedAction string)

func (m menuItem) SetIcon(icon Icon)

func (m menuItem) SetLabel(label string)

func (m menuItem) SetLink(link string, model MenuModel)

func (m menuItem) SetSection(section MenuModel)

func (m menuItem) SetSubmenu(submenu MenuModel)

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter interface {
	gextras.Objector

	// Name gets the name of the link at the current iterator position.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link. If that
	// fails, then false is returned and there are no other effects.
	//
	// If successful, @out_link and @value are set to the name and Model of the
	// link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_object_unref() when it is no longer in use.
	GetNext() (outLink string, value MenuModel, ok bool)
	// Value gets the linked Model at the current iterator position.
	//
	// The iterator is not advanced.
	Value() MenuModel
	// Next attempts to advance the iterator to the next (possibly first) link.
	//
	// true is returned on success, or false if there are no more links.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first link (and determine if the first link exists at
	// all).
	Next() bool
}

type menuLinkIter struct {
	*externglib.Object
}

// WrapMenuLinkIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuLinkIter(obj *externglib.Object) MenuLinkIter {
	return menuLinkIter{*externglib.Object{obj}}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuLinkIter(obj), nil
}

func (m menuLinkIter) Name() string

func (m menuLinkIter) GetNext() (outLink string, value MenuModel, ok bool)

func (m menuLinkIter) Value() MenuModel

func (m menuLinkIter) Next() bool

// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
//
// An example menu
//
// ! (menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
//
// A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel interface {
	gextras.Objector

	// ItemAttributeValue queries the item at position @item_index in @model for
	// the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemLink queries the item at position @item_index in @model for the link
	// specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	ItemLink(itemIndex int, link string) MenuModel
	// NItems: query the number of items in @model.
	NItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks(itemIndex int) MenuLinkIter
}

type menuModel struct {
	*externglib.Object
}

// WrapMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuModel(obj *externglib.Object) MenuModel {
	return menuModel{*externglib.Object{obj}}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuModel(obj), nil
}

func (m menuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant

func (m menuModel) ItemLink(itemIndex int, link string) MenuModel

func (m menuModel) NItems() int

func (m menuModel) IsMutable() bool

func (m menuModel) ItemsChanged(position int, removed int, added int)

func (m menuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter

func (m menuModel) IterateItemLinks(itemIndex int) MenuLinkIter

// MountOperation provides a mechanism for interacting with the user. It can be
// used for authenticating mountable operations, such as loop mounting files,
// hard drive partitions or server locations. It can also be used to ask the
// user questions or show a list of applications preventing unmount or eject
// operations from completing.
//
// Note that Operation is used for more than just #GMount objects – for example
// it is also used in g_drive_start() and g_drive_stop().
//
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
//
// The term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
// TrueCrypt (https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. VeraCrypt (https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
type MountOperation interface {
	gextras.Objector

	// Anonymous: check to see whether the mount operation is being used for an
	// anonymous user.
	Anonymous() bool
	// Choice gets a choice from the mount operation.
	Choice() int
	// Domain gets the domain of the mount operation.
	Domain() string
	// IsTcryptHiddenVolume: check to see whether the mount operation is being
	// used for a TCRYPT hidden volume.
	IsTcryptHiddenVolume() bool
	// IsTcryptSystemVolume: check to see whether the mount operation is being
	// used for a TCRYPT system volume.
	IsTcryptSystemVolume() bool
	// Password gets a password from the mount operation.
	Password() string
	// PasswordSave gets the state of saving passwords for the mount operation.
	PasswordSave() PasswordSave
	// Pim gets a PIM from the mount operation.
	Pim() uint
	// Username: get the user name from the mount operation.
	Username() string
	// Reply emits the Operation::reply signal.
	Reply(result MountOperationResult)
	// SetAnonymous sets the mount operation to use an anonymous user if
	// @anonymous is true.
	SetAnonymous(anonymous bool)
	// SetChoice sets a default choice for the mount operation.
	SetChoice(choice int)
	// SetDomain sets the mount operation's domain.
	SetDomain(domain string)
	// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume
	// if @hidden_volume is true.
	SetIsTcryptHiddenVolume(hiddenVolume bool)
	// SetIsTcryptSystemVolume sets the mount operation to use a system volume
	// if @system_volume is true.
	SetIsTcryptSystemVolume(systemVolume bool)
	// SetPassword sets the mount operation's password to @password.
	SetPassword(password string)
	// SetPasswordSave sets the state of saving passwords for the mount
	// operation.
	SetPasswordSave(save PasswordSave)
	// SetPim sets the mount operation's PIM to @pim.
	SetPim(pim uint)
	// SetUsername sets the user name within @op to @username.
	SetUsername(username string)
}

type mountOperation struct {
	*externglib.Object
}

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return mountOperation{*externglib.Object{obj}}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

func NewMountOperation() MountOperation

func (m mountOperation) Anonymous() bool

func (m mountOperation) Choice() int

func (m mountOperation) Domain() string

func (m mountOperation) IsTcryptHiddenVolume() bool

func (m mountOperation) IsTcryptSystemVolume() bool

func (m mountOperation) Password() string

func (m mountOperation) PasswordSave() PasswordSave

func (m mountOperation) Pim() uint

func (m mountOperation) Username() string

func (m mountOperation) Reply(result MountOperationResult)

func (m mountOperation) SetAnonymous(anonymous bool)

func (m mountOperation) SetChoice(choice int)

func (m mountOperation) SetDomain(domain string)

func (m mountOperation) SetIsTcryptHiddenVolume(hiddenVolume bool)

func (m mountOperation) SetIsTcryptSystemVolume(systemVolume bool)

func (m mountOperation) SetPassword(password string)

func (m mountOperation) SetPasswordSave(save PasswordSave)

func (m mountOperation) SetPim(pim uint)

func (m mountOperation) SetUsername(username string)

// NativeSocketAddress: a socket address of some unknown native type.
type NativeSocketAddress interface {
	SocketAddress
}

type nativeSocketAddress struct {
	socketAddress
}

// WrapNativeSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeSocketAddress(obj *externglib.Object) NativeSocketAddress {
	return nativeSocketAddress{socketAddress{*externglib.Object{obj}}}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeSocketAddress(obj), nil
}

func NewNativeSocketAddress(native interface{}, len uint) NativeSocketAddress

type NativeVolumeMonitor interface {
	VolumeMonitor
}

type nativeVolumeMonitor struct {
	volumeMonitor
}

// WrapNativeVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeVolumeMonitor(obj *externglib.Object) NativeVolumeMonitor {
	return nativeVolumeMonitor{volumeMonitor{*externglib.Object{obj}}}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeVolumeMonitor(obj), nil
}

// NetworkAddress provides an easy way to resolve a hostname and then attempt to
// connect to that host, handling the possibility of multiple IP addresses and
// multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See Connectable for an example of using the connectable interface.
type NetworkAddress interface {
	gextras.Objector

	// Hostname gets @addr's hostname. This might be either UTF-8 or
	// ASCII-encoded, depending on what @addr was created with.
	Hostname() string
	// Port gets @addr's port number
	Port() uint16
	// Scheme gets @addr's scheme
	Scheme() string
}

type networkAddress struct {
	*externglib.Object
}

// WrapNetworkAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkAddress(obj *externglib.Object) NetworkAddress {
	return networkAddress{*externglib.Object{obj}}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkAddress(obj), nil
}

func NewNetworkAddress(hostname string, port uint16) NetworkAddress

func NewNetworkAddressLoopback(port uint16) NetworkAddress

func (n networkAddress) Hostname() string

func (n networkAddress) Port() uint16

func (n networkAddress) Scheme() string

// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
//
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
type NetworkService interface {
	gextras.Objector

	// Domain gets the domain that @srv serves. This might be either UTF-8 or
	// ASCII-encoded, depending on what @srv was created with.
	Domain() string
	// Protocol gets @srv's protocol name (eg, "tcp").
	Protocol() string
	// Scheme gets the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	Scheme() string
	// Service gets @srv's service name (eg, "ldap").
	Service() string
	// SetScheme set's the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	SetScheme(scheme string)
}

type networkService struct {
	*externglib.Object
}

// WrapNetworkService wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkService(obj *externglib.Object) NetworkService {
	return networkService{*externglib.Object{obj}}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkService(obj), nil
}

func NewNetworkService(service string, protocol string, domain string) NetworkService

func (n networkService) Domain() string

func (n networkService) Protocol() string

func (n networkService) Scheme() string

func (n networkService) Service() string

func (n networkService) SetScheme(scheme string)

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Icon)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

type notification struct {
	*externglib.Object
}

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return notification{*externglib.Object{obj}}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

func NewNotification(title string) Notification

func (n notification) AddButton(label string, detailedAction string)

func (n notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant)

func (n notification) SetBody(body string)

func (n notification) SetDefaultAction(detailedAction string)

func (n notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant)

func (n notification) SetIcon(icon Icon)

func (n notification) SetPriority(priority NotificationPriority)

func (n notification) SetTitle(title string)

func (n notification) SetUrgent(urgent bool)

// OutputStream has functions to write to a stream (g_output_stream_write()), to
// close a stream (g_output_stream_close()) and to flush pending writes
// (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but there some
	// streams can use a faster close that doesn't block to e.g. check errors.
	// On cancellation (as with any error) there is no guarantee that all
	// written data will reach the target.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous close of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_output_stream_close_finish() to get the
	// result of the operation.
	//
	// For behaviour details see g_output_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish closes an output stream.
	CloseFinish(result AsyncResult) bool
	// Flush forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	//
	// This function is optional for inherited classes.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Flush(cancellable Cancellable) bool
	// FlushAsync forces an asynchronous write of all user-space buffered data
	// for the given @stream. For behaviour details see g_output_stream_flush().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_output_stream_flush_finish() to get the result of the operation.
	FlushAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// FlushFinish finishes flushing an output stream.
	FlushFinish(result AsyncResult) bool
	// HasPending checks if an output stream has pending actions.
	HasPending() bool
	// IsClosed checks if an output stream has already been closed.
	IsClosed() bool
	// IsClosing checks if an output stream is being closed. This can be used
	// inside e.g. a flush implementation to see if the flush (or other i/o
	// operation) is called from within the closing operation.
	IsClosing() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// Splice splices an input stream into an output stream.
	Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) int
	// SpliceAsync splices a stream asynchronously. When the operation is
	// finished @callback will be called. You can then call
	// g_output_stream_splice_finish() to get the result of the operation.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_splice().
	SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SpliceFinish finishes an asynchronous stream splice operation.
	SpliceFinish(result AsyncResult) int
	// Write tries to write @count bytes from @buffer into the stream. Will
	// block during the operation.
	//
	// If count is 0, returns 0 and does nothing. A value of @count larger than
	// G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes written to the stream is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. on a partial I/O error, or if there is not enough storage in
	// the stream. All writes block until at least one byte is written or an
	// error occurs; 0 is never returned (unless @count is 0).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	Write(buffer []uint8, cancellable Cancellable) int
	// WriteAll tries to write @count bytes from @buffer into the stream. Will
	// block during the operation.
	//
	// This function is similar to g_output_stream_write(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	//
	// On a successful write of @count bytes, true is returned, and
	// @bytes_written is set to @count.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write().
	WriteAll(buffer []uint8, cancellable Cancellable) (bytesWritten uint, ok bool)
	// WriteAllAsync: request an asynchronous write of @count bytes from @buffer
	// into the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_write_all_finish() to get the result of
	// the operation.
	//
	// This is the asynchronous version of g_output_stream_write_all().
	//
	// Call g_output_stream_write_all_finish() to collect the result.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// Note that no copy of @buffer will be made, so it must stay valid until
	// @callback is called.
	WriteAllAsync(buffer []uint8, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WriteAllFinish finishes an asynchronous stream write operation started
	// with g_output_stream_write_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write_async().
	WriteAllFinish(result AsyncResult) (bytesWritten uint, ok bool)
	// WriteAsync: request an asynchronous write of @count bytes from @buffer
	// into the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_write_finish() to get the result of the
	// operation.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes written will be passed to the @callback.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, but generally we try to write as
	// many bytes as requested.
	//
	// You are guaranteed that this method will never fail with
	// G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the method
	// will just wait until this changes.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_write().
	//
	// Note that no copy of @buffer will be made, so it must stay valid until
	// @callback is called. See g_output_stream_write_bytes_async() for a
	// #GBytes version that will automatically hold a reference to the contents
	// (without copying) for the duration of the call.
	WriteAsync(buffer []uint8, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WriteBytes: a wrapper function for g_output_stream_write() which takes a
	// #GBytes as input. This can be more convenient for use by language
	// bindings or in other cases where the refcounted nature of #GBytes is
	// helpful over a bare pointer interface.
	//
	// However, note that this function may still perform partial writes, just
	// like g_output_stream_write(). If that occurs, to continue writing, you
	// will need to create a new #GBytes containing just the remaining bytes,
	// using g_bytes_new_from_bytes(). Passing the same #GBytes instance
	// multiple times potentially can result in duplicated data in the output
	// stream.
	WriteBytes(bytes *glib.Bytes, cancellable Cancellable) int
	// WriteBytesAsync: this function is similar to
	// g_output_stream_write_async(), but takes a #GBytes as input. Due to the
	// refcounted nature of #GBytes, this allows the stream to avoid taking a
	// copy of the data.
	//
	// However, note that this function may still perform partial writes, just
	// like g_output_stream_write_async(). If that occurs, to continue writing,
	// you will need to create a new #GBytes containing just the remaining
	// bytes, using g_bytes_new_from_bytes(). Passing the same #GBytes instance
	// multiple times potentially can result in duplicated data in the output
	// stream.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_write_bytes().
	WriteBytesAsync(bytes *glib.Bytes, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WriteBytesFinish finishes a stream write-from-#GBytes operation.
	WriteBytesFinish(result AsyncResult) int
	// WriteFinish finishes a stream write operation.
	WriteFinish(result AsyncResult) int
	// Writev tries to write the bytes contained in the @n_vectors @vectors into
	// the stream. Will block during the operation.
	//
	// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0
	// and does nothing.
	//
	// On success, the number of bytes written to the stream is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. on a partial I/O error, or if there is not enough storage in
	// the stream. All writes block until at least one byte is written or an
	// error occurs; 0 is never returned (unless @n_vectors is 0 or the sum of
	// all bytes in @vectors is 0).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// Some implementations of g_output_stream_writev() may have limitations on
	// the aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if
	// these are exceeded. For example, when writing to a local file on UNIX
	// platforms, the aggregate buffer size must not exceed G_MAXSSIZE bytes.
	Writev(vectors []OutputVector, cancellable Cancellable) (bytesWritten uint, ok bool)
	// WritevAll tries to write the bytes contained in the @n_vectors @vectors
	// into the stream. Will block during the operation.
	//
	// This function is similar to g_output_stream_writev(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	//
	// On a successful write of all @n_vectors vectors, true is returned, and
	// @bytes_written is set to the sum of all the sizes of @vectors.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_write().
	//
	// The content of the individual elements of @vectors might be changed by
	// this function.
	WritevAll(vectors []OutputVector, cancellable Cancellable) (bytesWritten uint, ok bool)
	// WritevAllAsync: request an asynchronous write of the bytes contained in
	// the @n_vectors @vectors into the stream. When the operation is finished
	// @callback will be called. You can then call
	// g_output_stream_writev_all_finish() to get the result of the operation.
	//
	// This is the asynchronous version of g_output_stream_writev_all().
	//
	// Call g_output_stream_writev_all_finish() to collect the result.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// Note that no copy of @vectors will be made, so it must stay valid until
	// @callback is called. The content of the individual elements of @vectors
	// might be changed by this function.
	WritevAllAsync(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WritevAllFinish finishes an asynchronous stream write operation started
	// with g_output_stream_writev_all_async().
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_written will be set to the number of bytes that were successfully
	// written before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_output_stream_writev_async().
	WritevAllFinish(result AsyncResult) (bytesWritten uint, ok bool)
	// WritevAsync: request an asynchronous write of the bytes contained in
	// @n_vectors @vectors into the stream. When the operation is finished
	// @callback will be called. You can then call
	// g_output_stream_writev_finish() to get the result of the operation.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// On success, the number of bytes written will be passed to the @callback.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, but generally we try to write as
	// many bytes as requested.
	//
	// You are guaranteed that this method will never fail with
	// G_IO_ERROR_WOULD_BLOCK — if @stream can't accept more data, the method
	// will just wait until this changes.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_writev().
	//
	// Note that no copy of @vectors will be made, so it must stay valid until
	// @callback is called.
	WritevAsync(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WritevFinish finishes a stream writev operation.
	WritevFinish(result AsyncResult) (bytesWritten uint, ok bool)
}

type outputStream struct {
	*externglib.Object
}

// WrapOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutputStream(obj *externglib.Object) OutputStream {
	return outputStream{*externglib.Object{obj}}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutputStream(obj), nil
}

func (o outputStream) ClearPending()

func (o outputStream) Close(cancellable Cancellable) bool

func (o outputStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) CloseFinish(result AsyncResult) bool

func (o outputStream) Flush(cancellable Cancellable) bool

func (o outputStream) FlushAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) FlushFinish(result AsyncResult) bool

func (o outputStream) HasPending() bool

func (o outputStream) IsClosed() bool

func (o outputStream) IsClosing() bool

func (o outputStream) SetPending() bool

func (o outputStream) Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) int

func (o outputStream) SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) SpliceFinish(result AsyncResult) int

func (o outputStream) Write(buffer []uint8, cancellable Cancellable) int

func (o outputStream) WriteAll(buffer []uint8, cancellable Cancellable) (bytesWritten uint, ok bool)

func (o outputStream) WriteAllAsync(buffer []uint8, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) WriteAllFinish(result AsyncResult) (bytesWritten uint, ok bool)

func (o outputStream) WriteAsync(buffer []uint8, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) WriteBytes(bytes *glib.Bytes, cancellable Cancellable) int

func (o outputStream) WriteBytesAsync(bytes *glib.Bytes, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) WriteBytesFinish(result AsyncResult) int

func (o outputStream) WriteFinish(result AsyncResult) int

func (o outputStream) Writev(vectors []OutputVector, cancellable Cancellable) (bytesWritten uint, ok bool)

func (o outputStream) WritevAll(vectors []OutputVector, cancellable Cancellable) (bytesWritten uint, ok bool)

func (o outputStream) WritevAllAsync(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) WritevAllFinish(result AsyncResult) (bytesWritten uint, ok bool)

func (o outputStream) WritevAsync(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (o outputStream) WritevFinish(result AsyncResult) (bytesWritten uint, ok bool)

// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission interface {
	gextras.Objector

	// Acquire attempts to acquire the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. A simple example is that a
	// dialog may appear asking the user to enter their password.
	//
	// You should check with g_permission_get_can_acquire() before calling this
	// function.
	//
	// If the permission is acquired then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_acquire_async() for the
	// non-blocking version.
	Acquire(cancellable Cancellable) bool
	// AcquireAsync attempts to acquire the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_acquire().
	AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcquireFinish collects the result of attempting to acquire the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	AcquireFinish(result AsyncResult) bool
	// Allowed gets the value of the 'allowed' property. This property is true
	// if the caller currently has permission to perform the action that
	// @permission represents the permission to perform.
	Allowed() bool
	// CanAcquire gets the value of the 'can-acquire' property. This property is
	// true if it is generally possible to acquire the permission by calling
	// g_permission_acquire().
	CanAcquire() bool
	// CanRelease gets the value of the 'can-release' property. This property is
	// true if it is generally possible to release the permission by calling
	// g_permission_release().
	CanRelease() bool
	// ImplUpdate: this function is called by the #GPermission implementation to
	// update the properties of the permission. You should never call this
	// function except from a #GPermission implementation.
	//
	// GObject notify signals are generated, as appropriate.
	ImplUpdate(allowed bool, canAcquire bool, canRelease bool)
	// Release attempts to release the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. In most cases the permission
	// will be dropped immediately without further action.
	//
	// You should check with g_permission_get_can_release() before calling this
	// function.
	//
	// If the permission is released then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_release_async() for the
	// non-blocking version.
	Release(cancellable Cancellable) bool
	// ReleaseAsync attempts to release the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_release().
	ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// ReleaseFinish collects the result of attempting to release the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_release().
	ReleaseFinish(result AsyncResult) bool
}

type permission struct {
	*externglib.Object
}

// WrapPermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapPermission(obj *externglib.Object) Permission {
	return permission{*externglib.Object{obj}}
}

func marshalPermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPermission(obj), nil
}

func (p permission) Acquire(cancellable Cancellable) bool

func (p permission) AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (p permission) AcquireFinish(result AsyncResult) bool

func (p permission) Allowed() bool

func (p permission) CanAcquire() bool

func (p permission) CanRelease() bool

func (p permission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool)

func (p permission) Release(cancellable Cancellable) bool

func (p permission) ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (p permission) ReleaseFinish(result AsyncResult) bool

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector
}

type propertyAction struct {
	*externglib.Object
}

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return propertyAction{*externglib.Object{obj}}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction

// ProxyAddress: support for proxied SocketAddress.
type ProxyAddress interface {
	InetSocketAddress

	// DestinationHostname gets @proxy's destination hostname; that is, the name
	// of the host that will be connected to via the proxy, not the name of the
	// proxy itself.
	DestinationHostname() string
	// DestinationPort gets @proxy's destination port; that is, the port on the
	// destination host that will be connected to via the proxy, not the port
	// number of the proxy itself.
	DestinationPort() uint16
	// DestinationProtocol gets the protocol that is being spoken to the
	// destination server; eg, "http" or "ftp".
	DestinationProtocol() string
	// Password gets @proxy's password.
	Password() string
	// Protocol gets @proxy's protocol. eg, "socks" or "http"
	Protocol() string
	// URI gets the proxy URI that @proxy was constructed from.
	URI() string
	// Username gets @proxy's username.
	Username() string
}

type proxyAddress struct {
	inetSocketAddress
}

// WrapProxyAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapProxyAddress(obj *externglib.Object) ProxyAddress {
	return proxyAddress{inetSocketAddress{socketAddress{*externglib.Object{obj}}}}
}

func marshalProxyAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProxyAddress(obj), nil
}

func NewProxyAddress(inetaddr InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) ProxyAddress

func (p proxyAddress) DestinationHostname() string

func (p proxyAddress) DestinationPort() uint16

func (p proxyAddress) DestinationProtocol() string

func (p proxyAddress) Password() string

func (p proxyAddress) Protocol() string

func (p proxyAddress) URI() string

func (p proxyAddress) Username() string

// ProxyAddressEnumerator is a wrapper around AddressEnumerator which takes the
// Address instances returned by the AddressEnumerator and wraps them in Address
// instances, using the given AddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
type ProxyAddressEnumerator interface {
	SocketAddressEnumerator
}

type proxyAddressEnumerator struct {
	socketAddressEnumerator
}

// WrapProxyAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapProxyAddressEnumerator(obj *externglib.Object) ProxyAddressEnumerator {
	return proxyAddressEnumerator{socketAddressEnumerator{*externglib.Object{obj}}}
}

func marshalProxyAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProxyAddressEnumerator(obj), nil
}

// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver interface {
	gextras.Objector

	// LookupByAddress: synchronously reverse-resolves @address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	LookupByAddress(address InetAddress, cancellable Cancellable) string
	// LookupByAddressAsync begins asynchronously reverse-resolving @address to
	// determine its associated hostname, and eventually calls @callback, which
	// must call g_resolver_lookup_by_address_finish() to get the final result.
	LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupByAddressFinish retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupByAddressFinish(result AsyncResult) string
	// LookupByName: synchronously resolves @hostname to determine its
	// associated IP address(es). @hostname may be an ASCII-only or UTF-8
	// hostname, or the textual form of an IP address (in which case this just
	// becomes a wrapper around g_inet_address_new_from_string()).
	//
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// Address, sorted in order of preference and guaranteed to not contain
	// duplicates. That is, if using the result to connect to @hostname, you
	// should attempt to connect to the first address first, then the second if
	// the first fails, etc. If you are using the result to listen on a socket,
	// it is appropriate to add each result using e.g.
	// g_socket_listener_add_address().
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to a socket on the resolved IP address, it
	// may be easier to create a Address and use its Connectable interface.
	LookupByName(hostname string, cancellable Cancellable) *glib.List
	// LookupByNameAsync begins asynchronously resolving @hostname to determine
	// its associated IP address(es), and eventually calls @callback, which must
	// call g_resolver_lookup_by_name_finish() to get the result. See
	// g_resolver_lookup_by_name() for more details.
	LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupByNameFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupByNameFinish(result AsyncResult) *glib.List
	// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in
	// that you can modify the lookup behavior with @flags. For example this can
	// be used to limit results with RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) *glib.List
	// LookupByNameWithFlagsAsync begins asynchronously resolving @hostname to
	// determine its associated IP address(es), and eventually calls @callback,
	// which must call g_resolver_lookup_by_name_with_flags_finish() to get the
	// result. See g_resolver_lookup_by_name() for more details.
	LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupByNameWithFlagsFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupByNameWithFlagsFinish(result AsyncResult) *glib.List
	// LookupRecords: synchronously performs a DNS record lookup for the given
	// @rrname and returns a list of records as #GVariant tuples. See RecordType
	// for information on what the records contain for each @record_type.
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	LookupRecords(rrname string, recordType ResolverRecordType, cancellable Cancellable) *glib.List
	// LookupRecordsAsync begins asynchronously performing a DNS lookup for the
	// given @rrname, and eventually calls @callback, which must call
	// g_resolver_lookup_records_finish() to get the final result. See
	// g_resolver_lookup_records() for more details.
	LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupRecordsFinish retrieves the result of a previous call to
	// g_resolver_lookup_records_async(). Returns a non-empty list of records as
	// #GVariant tuples. See RecordType for information on what the records
	// contain.
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupRecordsFinish(result AsyncResult) *glib.List
	// LookupService: synchronously performs a DNS SRV lookup for the given
	// @service and @protocol in the given @domain and returns an array of
	// Target. @domain may be an ASCII-only or UTF-8 hostname. Note also that
	// the @service and @protocol arguments do not include the leading
	// underscore that appears in the actual DNS entry.
	//
	// On success, g_resolver_lookup_service() will return a non-empty #GList of
	// Target, sorted in order of preference. (That is, you should attempt to
	// connect to the first target first, then the second if the first fails,
	// etc.)
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to the service, it is usually easier to
	// create a Service and use its Connectable interface.
	LookupService(service string, protocol string, domain string, cancellable Cancellable) *glib.List
	// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for
	// the given @service and @protocol in the given @domain, and eventually
	// calls @callback, which must call g_resolver_lookup_service_finish() to
	// get the final result. See g_resolver_lookup_service() for more details.
	LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupServiceFinish retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	//
	// If the DNS resolution failed, @error (if non-nil) will be set to a value
	// from Error. If the operation was cancelled, @error will be set to
	// G_IO_ERROR_CANCELLED.
	LookupServiceFinish(result AsyncResult) *glib.List
	// SetDefault sets @resolver to be the application's default resolver
	// (reffing @resolver, and unreffing the previous default resolver, if any).
	// Future calls to g_resolver_get_default() will return this resolver.
	//
	// This can be used if an application wants to perform any sort of DNS
	// caching or "pinning"; it can implement its own #GResolver that calls the
	// original default resolver for DNS operations, and implements its own
	// cache policies on top of that, and then set itself as the default
	// resolver for all later code to use.
	SetDefault()
}

type resolver struct {
	*externglib.Object
}

// WrapResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapResolver(obj *externglib.Object) Resolver {
	return resolver{*externglib.Object{obj}}
}

func marshalResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapResolver(obj), nil
}

func (r resolver) LookupByAddress(address InetAddress, cancellable Cancellable) string

func (r resolver) LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback)

func (r resolver) LookupByAddressFinish(result AsyncResult) string

func (r resolver) LookupByName(hostname string, cancellable Cancellable) *glib.List

func (r resolver) LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback)

func (r resolver) LookupByNameFinish(result AsyncResult) *glib.List

func (r resolver) LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) *glib.List

func (r resolver) LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (r resolver) LookupByNameWithFlagsFinish(result AsyncResult) *glib.List

func (r resolver) LookupRecords(rrname string, recordType ResolverRecordType, cancellable Cancellable) *glib.List

func (r resolver) LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback)

func (r resolver) LookupRecordsFinish(result AsyncResult) *glib.List

func (r resolver) LookupService(service string, protocol string, domain string, cancellable Cancellable) *glib.List

func (r resolver) LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback)

func (r resolver) LookupServiceFinish(result AsyncResult) *glib.List

func (r resolver) SetDefault()

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element — it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//
//     <!-- Translators: A list of words which are not allowed to be typed, in
//          GVariant serialization syntax.
//          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//    ]|
//
//    Translations of default values must remain syntactically valid serialized
//    #GVariants (e.g. retaining any surrounding quotation marks) or runtime
//    errors will occur.
//
//    GSettings uses schemas in a compact binary form that is created
//    by the [glib-compile-schemas][glib-compile-schemas]
//    utility. The input is a schema description in an XML format.
//
//    A DTD for the gschema XML format can be found here:
//    gschema.dtd (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
//    The [glib-compile-schemas][glib-compile-schemas] tool expects schema
//    files to have the extension `.gschema.xml`.
//
//    At runtime, schemas are identified by their id (as specified in the
//    id attribute of the <schema> element). The convention for schema
//    ids is to use a dotted name, similar in style to a D-Bus bus name,
//    e.g. "org.gnome.SessionManager". In particular, if the settings are
//    for a specific service that owns a D-Bus bus name, the D-Bus bus name
//    and schema id should match. For schemas which deal with settings not
//    associated with one named application, the id should not use
//    StudlyCaps, e.g. "org.gnome.font-rendering".
//
//    In addition to #GVariant types, keys can have types that have
//    enumerated types. These can be described by a <choice>,
//    <enum> or <flags> element, as seen in the
//    [example][schema-enumerated]. The underlying type of such a key
//    is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
//    g_settings_get_flags(), g_settings_set_flags() access the numeric values
//    corresponding to the string value of enum and flags keys.
//
//    An example for default value:
//    |[
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
//
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
//
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
//
//      </schema>
//    </schemalist>
//    ]|
//
//    An example for ranges, choices and enumerated types:
//    |[
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//    ]|
//
//
//
// Vendor overrides
//
//
//    Default values are defined in the schemas that get installed by
//    an application. Sometimes, it is necessary for a vendor or distributor
//    to adjust these defaults. Since patching the XML source for the schema
//    is inconvenient and error-prone,
//    [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
//    override' files. These are keyfiles in the same directory as the XML
//    schema sources which can override default values. The schema id serves
//    as the group name in the key file, and the values are expected in
//    serialized GVariant form, as in the following example:
//    |[
//        [org.gtk.Example]
//        key1='string'
//        key2=1.5
//    ]|
//
//    glib-compile-schemas expects schema files to have the extension
//    `.gschema.override`.
//
//
//
// Binding
//
//
//    A very convenient feature of GSettings lets you bind #GObject properties
//    directly to settings, using g_settings_bind(). Once a GObject property
//    has been bound to a setting, changes on either side are automatically
//    propagated to the other side. GSettings handles details like mapping
//    between GObject and GVariant types, and preventing infinite cycles.
//
//    This makes it very easy to hook up a preferences dialog to the
//    underlying settings. To make this even more convenient, GSettings
//    looks for a boolean property with the name "sensitivity" and
//    automatically binds it to the writability of the bound setting.
//    If this 'magic' gets in the way, it can be suppressed with the
//    SETTINGS_BIND_NO_SENSITIVITY flag.
//
//
//
// Relocatable schemas
//
//
//    A relocatable schema is one with no `path` attribute specified on its
//    <schema> element. By using g_settings_new_with_path(), a #GSettings object
//    can be instantiated for a relocatable schema, assigning a path to the
//    instance. Paths passed to g_settings_new_with_path() will typically be
//    constructed dynamically from a constant prefix plus some form of instance
//    identifier; but they must still be valid GSettings paths. Paths could also
//    be constant and used with a globally installed schema originating from a
//    dependency library.
//
//    For example, a relocatable schema could be used to store geometry information
//    for different windows in an application. If the schema ID was
//    `org.foo.MyApp.Window`, it could be instantiated for paths
//    `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
//    `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
//    they can be specified as <child> elements in the parent schema, e.g.:
//    |[
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//    ]|
//
//
//
// Build system integration
//
//
//    GSettings comes with autotools integration to simplify compiling and
//    installing schemas. To add GSettings support to an application, add the
//    following to your `configure.ac`:
//    |[
//    GLIB_GSETTINGS
//    ]|
//
//    In the appropriate `Makefile.am`, use the following snippet to compile and
//    install the named schema:
//    |[
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//    ]|
//
//    No changes are needed to the build system to mark a schema XML file for
//    translation. Assuming it sets the `gettext-domain` attribute, a schema may
//    be marked for translation by adding it to `POTFILES.in`, assuming gettext
//    0.19 is in use (the preferred method for translation):
//    |[
//    data/org.foo.MyApp.gschema.xml
//    ]|
//
//    Alternatively, if intltool 0.50.1 is in use:
//    |[
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//    ]|
//
//    GSettings will use gettext to look up translations for the <summary> and
//    <description> elements, and also any <default> elements which have a `l10n`
//    attribute set. Translations must not be included in the `.gschema.xml` file
//    by the build system, for example by using intltool XML rules with a
//    `.gschema.xml.in` template.
//
//    If an enumerated type defined in a C header file is to be used in a GSettings
//    schema, it can either be defined manually using an <enum> element in the
//    schema XML, or it can be extracted automatically from the C header. This
//    approach is preferred, as it ensures the two representations are always
//    synchronised. To do so, add the following to the relevant `Makefile.am`:
//    |[
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings interface {
	gextras.Objector

	// Apply applies any changes that have been made to the settings. This
	// function does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	Apply()
	// Bind: create a binding between the @key in the @settings object and the
	// property @property of @object.
	//
	// The binding uses the default GIO mapping functions to map between the
	// settings and property values. These functions handle booleans, numeric
	// types and string types in a straightforward way. Use
	// g_settings_bind_with_mapping() if you need a custom mapping, or map
	// between types that are not supported by the default mapping functions.
	//
	// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
	// also establishes a binding between the writability of @key and the
	// "sensitive" property of @object (if @object has a boolean property by
	// that name). See g_settings_bind_writable() for more details about
	// writable bindings.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags)
	// BindWithMapping: create a binding between the @key in the @settings
	// object and the property @property of @object.
	//
	// The binding uses the provided mapping functions to map between settings
	// and property values.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWithMapping(key string, object gextras.Objector, property string, flags SettingsBindFlags, getMapping SettingsBindGetMapping, setMapping SettingsBindSetMapping)
	// BindWritable: create a binding between the writability of @key in the
	// @settings object and the property @property of @object. The property must
	// be boolean; "sensitive" or "visible" properties of widgets are the most
	// likely candidates.
	//
	// Writable bindings are always uni-directional; changes of the writability
	// of the setting will be propagated to the object property, not the other
	// way.
	//
	// When the @inverted argument is true, the binding inverts the value as it
	// passes from the setting to the object, i.e. @property will be set to true
	// if the key is not writable.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWritable(key string, object gextras.Objector, property string, inverted bool)
	// CreateAction creates a #GAction corresponding to a given #GSettings key.
	//
	// The action has the same name as the key.
	//
	// The value of the key becomes the state of the action and the action is
	// enabled when the key is writable. Changing the state of the action
	// results in the key being written to. Changes to the value or writability
	// of the key cause appropriate change notifications to be emitted for the
	// action.
	//
	// For boolean-valued keys, action activations take no parameter and result
	// in the toggling of the value. For all other types, activations take the
	// new value for the key (which must have the correct type).
	CreateAction(key string) Action
	// Delay changes the #GSettings object into 'delay-apply' mode. In this
	// mode, changes to @settings are not immediately propagated to the backend,
	// but kept locally until g_settings_apply() is called.
	Delay()
	// Boolean gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	Boolean(key string) bool
	// Child creates a child settings object which has a base path of
	// `base-path/@name`, where `base-path` is the base path of @settings.
	//
	// The schema for the child settings object must have been declared in the
	// schema of @settings using a <child> element.
	Child(name string) Settings
	// DefaultValue gets the "default value" of a key.
	//
	// This is the value that would be read if g_settings_reset() were to be
	// called on the key.
	//
	// Note that this may be a different value than returned by
	// g_settings_schema_key_get_default_value() if the system administrator has
	// provided a default value.
	//
	// Comparing the return values of g_settings_get_default_value() and
	// g_settings_get_value() is not sufficient for determining if a value has
	// been set because the user may have explicitly set the value to something
	// that happens to be equal to the default. The difference here is that if
	// the default changes in the future, the user's key will still be set.
	//
	// This function may be useful for adding an indication to a UI of what the
	// default value was before the user set it.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	DefaultValue(key string) *glib.Variant
	// Double gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	Double(key string) float64
	// Enum gets the value that is stored in @settings for @key and converts it
	// to the enum value that it represents.
	//
	// In order to use this function the type of the value must be a string and
	// it must be marked in the schema file as an enumerated type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the enumerated type then this function will return the default value.
	Enum(key string) int
	// Flags gets the value that is stored in @settings for @key and converts it
	// to the flags value that it represents.
	//
	// In order to use this function the type of the value must be an array of
	// strings and it must be marked in the schema file as a flags type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the flags type then this function will return the default value.
	Flags(key string) uint
	// HasUnapplied returns whether the #GSettings object has any unapplied
	// changes. This can only be the case if it is in 'delayed-apply' mode.
	HasUnapplied() bool
	// Int gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	Int(key string) int
	// Int64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	Int64(key string) int64
	// Mapped gets the value that is stored at @key in @settings, subject to
	// application-level validation/mapping.
	//
	// You should use this function when the application needs to perform some
	// processing on the value of the key (for example, parsing). The @mapping
	// function performs that processing. If the function indicates that the
	// processing was unsuccessful (due to a parse error, for example) then the
	// mapping is tried again with another value.
	//
	// This allows a robust 'fall back to defaults' behaviour to be implemented
	// somewhat automatically.
	//
	// The first value that is tried is the user's setting for the key. If the
	// mapping function fails to map this value, other values may be tried in an
	// unspecified order (system or site defaults, translated schema default
	// values, untranslated schema default values, etc).
	//
	// If the mapping function fails for all possible values, one additional
	// attempt is made: the mapping function is called with a nil value. If the
	// mapping function still indicates failure at this point then the
	// application will be aborted.
	//
	// The result parameter for the @mapping function is pointed to a #gpointer
	// which is initially set to nil. The same pointer is given to each
	// invocation of @mapping. The final value of that #gpointer is what is
	// returned by this function. nil is valid; it is returned just as any other
	// value would be.
	Mapped(key string, mapping SettingsGetMapping) interface{}
	// Range queries the range of a key.
	Range(key string) *glib.Variant
	// String gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	String(key string) string
	// Strv: a convenience variant of g_settings_get() for string arrays.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	Strv(key string) []string
	// Uint gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	Uint(key string) uint
	// Uint64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	Uint64(key string) uint64
	// UserValue checks the "user value" of a key, if there is one.
	//
	// The user value of a key is the last value that was set by the user.
	//
	// After calling g_settings_reset() this function should always return nil
	// (assuming something is not wrong with the system configuration).
	//
	// It is possible that g_settings_get_value() will return a different value
	// than this function. This can happen in the case that the user set a value
	// for a key that was subsequently locked down by the system administrator
	// -- this function will return the user's old value.
	//
	// This function may be useful for adding a "reset" option to a UI or for
	// providing indication that a particular value has been changed.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	UserValue(key string) *glib.Variant
	// Value gets the value that is stored in @settings for @key.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	Value(key string) *glib.Variant
	// IsWritable finds out if a key can be written or not
	IsWritable(name string) bool
	// ListChildren gets the list of children on @settings.
	//
	// The list is exactly the list of strings for which it is not an error to
	// call g_settings_get_child().
	//
	// There is little reason to call this function from "normal" code, since
	// you should already know what children are in your schema. This function
	// may still be useful there for introspection reasons, however.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListChildren() []string
	// ListKeys introspects the list of keys on @settings.
	//
	// You should probably not be calling this function from "normal" code
	// (since you should already know what keys are in your schema). This
	// function is intended for introspection reasons.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListKeys() []string
	// RangeCheck checks if the given @value is of the correct type and within
	// the permitted range for @key.
	RangeCheck(key string, value *glib.Variant) bool
	// Reset resets @key to its default value.
	//
	// This call resets the key, as much as possible, to its default value. That
	// might be the value specified in the schema or the one set by the
	// administrator.
	Reset(key string)
	// Revert reverts all non-applied changes to the settings. This function
	// does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	//
	// Change notifications will be emitted for affected keys.
	Revert()
	// SetBoolean sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	SetBoolean(key string, value bool) bool
	// SetDouble sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	SetDouble(key string, value float64) bool
	// SetEnum looks up the enumerated type nick for @value and writes it to
	// @key, within @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type, or for
	// @value not to be a valid value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_string() will return the 'nick' associated with @value.
	SetEnum(key string, value int) bool
	// SetFlags looks up the flags type nicks for the bits specified by @value,
	// puts them in an array of strings and writes the array to @key, within
	// @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type, or for @value to
	// contain any bits that are not value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_strv() will return an array of 'nicks'; one for each bit
	// in @value.
	SetFlags(key string, value uint) bool
	// SetInt sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	SetInt(key string, value int) bool
	// SetInt64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	SetInt64(key string, value int64) bool
	// SetString sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	SetString(key string, value string) bool
	// SetStrv sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for string arrays. If @value is
	// nil, then @key is set to be the empty array.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	SetStrv(key string, value []string) bool
	// SetUint sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	SetUint(key string, value uint) bool
	// SetUint64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	SetUint64(key string, value uint64) bool
	// SetValue sets @key in @settings to @value.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or for @value to have the incorrect type, per the
	// schema.
	//
	// If @value is floating then this function consumes the reference.
	SetValue(key string, value *glib.Variant) bool
}

type settings struct {
	*externglib.Object
}

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return settings{*externglib.Object{obj}}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

func NewSettings(schemaID string) Settings

func NewSettingsFull(schema *SettingsSchema, backend SettingsBackend, path string) Settings

func NewSettingsWithBackend(schemaID string, backend SettingsBackend) Settings

func NewSettingsWithBackendAndPath(schemaID string, backend SettingsBackend, path string) Settings

func NewSettingsWithPath(schemaID string, path string) Settings

func (s settings) Apply()

func (s settings) Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags)

func (s settings) BindWithMapping(key string, object gextras.Objector, property string, flags SettingsBindFlags, getMapping SettingsBindGetMapping, setMapping SettingsBindSetMapping)

func (s settings) BindWritable(key string, object gextras.Objector, property string, inverted bool)

func (s settings) CreateAction(key string) Action

func (s settings) Delay()

func (s settings) Boolean(key string) bool

func (s settings) Child(name string) Settings

func (s settings) DefaultValue(key string) *glib.Variant

func (s settings) Double(key string) float64

func (s settings) Enum(key string) int

func (s settings) Flags(key string) uint

func (s settings) HasUnapplied() bool

func (s settings) Int(key string) int

func (s settings) Int64(key string) int64

func (s settings) Mapped(key string, mapping SettingsGetMapping) interface{}

func (s settings) Range(key string) *glib.Variant

func (s settings) String(key string) string

func (s settings) Strv(key string) []string

func (s settings) Uint(key string) uint

func (s settings) Uint64(key string) uint64

func (s settings) UserValue(key string) *glib.Variant

func (s settings) Value(key string) *glib.Variant

func (s settings) IsWritable(name string) bool

func (s settings) ListChildren() []string

func (s settings) ListKeys() []string

func (s settings) RangeCheck(key string, value *glib.Variant) bool

func (s settings) Reset(key string)

func (s settings) Revert()

func (s settings) SetBoolean(key string, value bool) bool

func (s settings) SetDouble(key string, value float64) bool

func (s settings) SetEnum(key string, value int) bool

func (s settings) SetFlags(key string, value uint) bool

func (s settings) SetInt(key string, value int) bool

func (s settings) SetInt64(key string, value int64) bool

func (s settings) SetString(key string, value string) bool

func (s settings) SetStrv(key string, value []string) bool

func (s settings) SetUint(key string, value uint) bool

func (s settings) SetUint64(key string, value uint64) bool

func (s settings) SetValue(key string, value *glib.Variant) bool

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend interface {
	gextras.Objector

	// Changed signals that a single key has possibly changed. Backend
	// implementations should call this if a key has possibly changed its value.
	//
	// @key must be a valid key (ie starting with a slash, not containing '//',
	// and not ending with a slash).
	//
	// The implementation must call this function during any call to
	// g_settings_backend_write(), before the call returns (except in the case
	// that no keys are actually changed and it cares to detect this fact). It
	// may not rely on the existence of a mainloop for dispatching the signal
	// later.
	//
	// The implementation may call this function at any other time it likes in
	// response to other events (such as changes occurring outside of the
	// program). These calls may originate from a mainloop or may originate in
	// response to any other action (including from calls to
	// g_settings_backend_write()).
	//
	// In the case that this call is in response to a call to
	// g_settings_backend_write() then @origin_tag must be set to the same value
	// that was passed to that call.
	Changed(key string, originTag interface{})
	// ChangedTree: this call is a convenience wrapper. It gets the list of
	// changes from @tree, computes the longest common prefix and calls
	// g_settings_backend_changed().
	ChangedTree(tree *glib.Tree, originTag interface{})
	// KeysChanged signals that a list of keys have possibly changed. Backend
	// implementations should call this if keys have possibly changed their
	// values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//'). Each string in @items must form a valid key name when
	// @path is prefixed to it (ie: each item must not start or end with '/' and
	// must not contain '//').
	//
	// The meaning of this signal is that any of the key names resulting from
	// the contatenation of @path with each item in @items may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). These two calls can be used interchangeably
	// if exactly one item has changed (although in that case
	// g_settings_backend_changed() is definitely preferred).
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required.
	KeysChanged(path string, items []string, originTag interface{})
	// PathChanged signals that all keys below a given path may have possibly
	// changed. Backend implementations should call this if an entire path of
	// keys have possibly changed their values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//').
	//
	// The meaning of this signal is that any of the key which has a name
	// starting with @path may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). This call might be an appropriate reasponse
	// to a 'reset' call but implementations are also free to explicitly list
	// the keys that were affected by that call if they can easily do so.
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required. As an example, if
	// this function is called with the path of "/" then every single key in the
	// application will be notified of a possible change.
	PathChanged(path string, originTag interface{})
	// PathWritableChanged signals that the writability of all keys below a
	// given path may have changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	PathWritableChanged(path string)
	// WritableChanged signals that the writability of a single key has possibly
	// changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	WritableChanged(key string)
}

type settingsBackend struct {
	*externglib.Object
}

// WrapSettingsBackend wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettingsBackend(obj *externglib.Object) SettingsBackend {
	return settingsBackend{*externglib.Object{obj}}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettingsBackend(obj), nil
}

func (s settingsBackend) Changed(key string, originTag interface{})

func (s settingsBackend) ChangedTree(tree *glib.Tree, originTag interface{})

func (s settingsBackend) KeysChanged(path string, items []string, originTag interface{})

func (s settingsBackend) PathChanged(path string, originTag interface{})

func (s settingsBackend) PathWritableChanged(path string)

func (s settingsBackend) WritableChanged(key string)

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

type simpleAction struct {
	*externglib.Object
}

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return simpleAction{*externglib.Object{obj}}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction

func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction

func (s simpleAction) SetEnabled(enabled bool)

func (s simpleAction) SetState(value *glib.Variant)

func (s simpleAction) SetStateHint(stateHint *glib.Variant)

// SimpleActionGroup is a hash table filled with #GAction objects, implementing
// the Group and Map interfaces.
type SimpleActionGroup interface {
	gextras.Objector

	// AddEntries: a convenience function for creating multiple Action instances
	// and adding them to the action group.
	AddEntries(entries []ActionEntry, userData interface{})
	// Insert adds an action to the action group.
	//
	// If the action group already contains an action with the same name as
	// @action then the old action is dropped from the group.
	//
	// The action group takes its own reference on @action.
	Insert(action Action)
	// Lookup looks up the action with the name @action_name in the group.
	//
	// If no such action exists, returns nil.
	Lookup(actionName string) Action
	// Remove removes the named action from the action group.
	//
	// If no action of this name is in the group then nothing happens.
	Remove(actionName string)
}

type simpleActionGroup struct {
	*externglib.Object
}

// WrapSimpleActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleActionGroup(obj *externglib.Object) SimpleActionGroup {
	return simpleActionGroup{*externglib.Object{obj}}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleActionGroup(obj), nil
}

func NewSimpleActionGroup() SimpleActionGroup

func (s simpleActionGroup) AddEntries(entries []ActionEntry, userData interface{})

func (s simpleActionGroup) Insert(action Action)

func (s simpleActionGroup) Lookup(actionName string) Action

func (s simpleActionGroup) Remove(actionName string)

// SimpleAsyncResult as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop — inadvisable, but some APIs do so —
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
//
type SimpleAsyncResult interface {
	gextras.Objector

	// Complete completes an asynchronous I/O job immediately. Must be called in
	// the thread where the asynchronous result was to be delivered, as it
	// invokes the callback directly. If you are in a different thread use
	// g_simple_async_result_complete_in_idle().
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	Complete()
	// CompleteInIdle completes an asynchronous function in an idle handler in
	// the [thread-default main context][g-main-context-push-thread-default] of
	// the thread that @simple was initially created in (and re-pushes that
	// context around the invocation of the callback).
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	CompleteInIdle()
	// OpResGboolean gets the operation result boolean from within the
	// asynchronous result.
	OpResGboolean() bool
	// OpResGpointer gets a pointer result as returned by the asynchronous
	// function.
	OpResGpointer() interface{}
	// OpResGssize gets a gssize from the asynchronous result.
	OpResGssize() int
	// SourceTag gets the source tag for the AsyncResult.
	SourceTag() interface{}
	// PropagateError propagates an error from within the simple asynchronous
	// result to a given destination.
	//
	// If the #GCancellable given to a prior call to
	// g_simple_async_result_set_check_cancellable() is cancelled then this
	// function will return true with @dest set appropriately.
	PropagateError() bool
	// RunInThread runs the asynchronous job in a separate thread and then calls
	// g_simple_async_result_complete_in_idle() on @simple to return the result
	// to the appropriate main loop.
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to run the job and report its completion.
	RunInThread(_func SimpleAsyncThreadFunc, ioPriority int, cancellable Cancellable)
	// SetCheckCancellable sets a #GCancellable to check before dispatching
	// results.
	//
	// This function has one very specific purpose: the provided cancellable is
	// checked at the time of g_simple_async_result_propagate_error() If it is
	// cancelled, these functions will return an "Operation was cancelled" error
	// (G_IO_ERROR_CANCELLED).
	//
	// Implementors of cancellable asynchronous functions should use this in
	// order to provide a guarantee to their callers that cancelling an async
	// operation will reliably result in an error being returned for that
	// operation (even if a positive result for the operation has already been
	// sent as an idle to the main context to be dispatched).
	//
	// The checking described above is done regardless of any call to the
	// unrelated g_simple_async_result_set_handle_cancellation() function.
	SetCheckCancellable(checkCancellable Cancellable)
	// SetFromError sets the result from a #GError.
	SetFromError(error *glib.Error)
	// SetHandleCancellation sets whether to handle cancellation within the
	// asynchronous operation.
	//
	// This function has nothing to do with
	// g_simple_async_result_set_check_cancellable(). It only refers to the
	// #GCancellable passed to g_simple_async_result_run_in_thread().
	SetHandleCancellation(handleCancellation bool)
	// SetOpResGboolean sets the operation result to a boolean within the
	// asynchronous result.
	SetOpResGboolean(opRes bool)
	// SetOpResGpointer sets the operation result within the asynchronous result
	// to a pointer.
	SetOpResGpointer(opRes interface{})
	// SetOpResGssize sets the operation result within the asynchronous result
	// to the given @op_res.
	SetOpResGssize(opRes int)
	// TakeError sets the result from @error, and takes over the caller's
	// ownership of @error, so the caller does not need to free it any more.
	TakeError(error *glib.Error)
}

type simpleAsyncResult struct {
	*externglib.Object
}

// WrapSimpleAsyncResult wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAsyncResult(obj *externglib.Object) SimpleAsyncResult {
	return simpleAsyncResult{*externglib.Object{obj}}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAsyncResult(obj), nil
}

func NewSimpleAsyncResult(sourceObject gextras.Objector, callback AsyncReadyCallback, sourceTag interface{}) SimpleAsyncResult

func NewSimpleAsyncResultFromError(sourceObject gextras.Objector, callback AsyncReadyCallback, error *glib.Error) SimpleAsyncResult

func NewSimpleAsyncResultTakeError(sourceObject gextras.Objector, callback AsyncReadyCallback, error *glib.Error) SimpleAsyncResult

func (s simpleAsyncResult) Complete()

func (s simpleAsyncResult) CompleteInIdle()

func (s simpleAsyncResult) OpResGboolean() bool

func (s simpleAsyncResult) OpResGpointer() interface{}

func (s simpleAsyncResult) OpResGssize() int

func (s simpleAsyncResult) SourceTag() interface{}

func (s simpleAsyncResult) PropagateError() bool

func (s simpleAsyncResult) RunInThread(_func SimpleAsyncThreadFunc, ioPriority int, cancellable Cancellable)

func (s simpleAsyncResult) SetCheckCancellable(checkCancellable Cancellable)

func (s simpleAsyncResult) SetFromError(error *glib.Error)

func (s simpleAsyncResult) SetHandleCancellation(handleCancellation bool)

func (s simpleAsyncResult) SetOpResGboolean(opRes bool)

func (s simpleAsyncResult) SetOpResGpointer(opRes interface{})

func (s simpleAsyncResult) SetOpResGssize(opRes int)

func (s simpleAsyncResult) TakeError(error *glib.Error)

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

type simpleIOStream struct {
	ioStream
}

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return simpleIOStream{ioStream{*externglib.Object{obj}}}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

type simplePermission struct {
	permission
}

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return simplePermission{permission{*externglib.Object{obj}}}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

func NewSimplePermission(allowed bool) SimplePermission

// SimpleProxyResolver is a simple Resolver implementation that handles a single
// default proxy, multiple URI-scheme-specific proxies, and a list of hosts that
// proxies should not be used for.
//
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
type SimpleProxyResolver interface {
	gextras.Objector

	// SetDefaultProxy sets the default proxy on @resolver, to be used for any
	// URIs that don't match ProxyResolver:ignore-hosts or a proxy set via
	// g_simple_proxy_resolver_set_uri_proxy().
	//
	// If @default_proxy starts with "socks://", ProxyResolver will treat it as
	// referring to all three of the socks5, socks4a, and socks4 proxy types.
	SetDefaultProxy(defaultProxy string)
	// SetIgnoreHosts sets the list of ignored hosts.
	//
	// See ProxyResolver:ignore-hosts for more details on how the @ignore_hosts
	// argument is interpreted.
	SetIgnoreHosts(ignoreHosts string)
	// SetURIProxy adds a URI-scheme-specific proxy to @resolver; URIs whose
	// scheme matches @uri_scheme (and which don't match
	// ProxyResolver:ignore-hosts) will be proxied via @proxy.
	//
	// As with ProxyResolver:default-proxy, if @proxy starts with "socks://",
	// ProxyResolver will treat it as referring to all three of the socks5,
	// socks4a, and socks4 proxy types.
	SetURIProxy(uriScheme string, proxy string)
}

type simpleProxyResolver struct {
	*externglib.Object
}

// WrapSimpleProxyResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleProxyResolver(obj *externglib.Object) SimpleProxyResolver {
	return simpleProxyResolver{*externglib.Object{obj}}
}

func marshalSimpleProxyResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleProxyResolver(obj), nil
}

func (s simpleProxyResolver) SetDefaultProxy(defaultProxy string)

func (s simpleProxyResolver) SetIgnoreHosts(ignoreHosts string)

func (s simpleProxyResolver) SetURIProxy(uriScheme string, proxy string)

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which don’t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	gextras.Objector

	// Accept: accept incoming connections on a connection-based socket. This
	// removes the first outstanding connection request from the listening
	// socket and creates a #GSocket object for it.
	//
	// The @socket must be bound to a local address with g_socket_bind() and
	// must be listening for incoming connections (g_socket_listen()).
	//
	// If there are no outstanding connections then the operation will block or
	// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
	// notified of an incoming connection, wait for the G_IO_IN condition.
	Accept(cancellable Cancellable) Socket
	// Bind: when a socket is created it is attached to an address family, but
	// it doesn't have an address in this family. g_socket_bind() assigns the
	// address (sometimes called name) of the socket.
	//
	// It is generally required to bind to a local address before you can
	// receive connections. (See g_socket_listen() and g_socket_accept() ). In
	// certain situations, you may also want to bind a socket that will be used
	// to initiate connections, though this is not normally required.
	//
	// If @socket is a TCP socket, then @allow_reuse controls the setting of the
	// `SO_REUSEADDR` socket option; normally it should be true for server
	// sockets (sockets that you will eventually call g_socket_accept() on), and
	// false for client sockets. (Failing to set this flag on a server socket
	// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
	// server program is stopped and then immediately restarted.)
	//
	// If @socket is a UDP socket, then @allow_reuse determines whether or not
	// other UDP sockets can be bound to the same address at the same time. In
	// particular, you can have several UDP sockets bound to the same address,
	// and they will all receive all of the multicast and broadcast packets sent
	// to that address. (The behavior of unicast UDP packets to an address with
	// multiple listeners is not defined.)
	Bind(address SocketAddress, allowReuse bool) bool
	// CheckConnectResult checks and resets the pending connect error for the
	// socket. This is used to check for errors when g_socket_connect() is used
	// in non-blocking mode.
	CheckConnectResult() bool
	// Close closes the socket, shutting down any active connection.
	//
	// Closing a socket does not wait for all outstanding I/O operations to
	// finish, so the caller should not rely on them to be guaranteed to
	// complete even if the close returns with no error.
	//
	// Once the socket is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
	// error.
	//
	// Sockets will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Beware that due to the way that TCP works, it is possible for
	// recently-sent data to be lost if either you close a socket while the
	// G_IO_IN condition is set, or else if the remote connection tries to send
	// something to you after you close the socket but before it has finished
	// reading all of the data you sent. There is no easy generic way to avoid
	// this problem; the easiest fix is to design the network protocol such that
	// the client will never send data "out of turn". Another solution is for
	// the server to half-close the connection by calling g_socket_shutdown()
	// with only the @shutdown_write flag set, and then wait for the client to
	// notice this and close its side of the connection, after which the server
	// can safely call g_socket_close(). (This is what Connection does if you
	// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
	// works if the client will close its connection after the server does.)
	Close() bool
	// ConditionCheck checks on the readiness of @socket to perform operations.
	// The operations specified in @condition are checked for and masked against
	// the currently-satisfied conditions on @socket. The result is returned.
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
	// has claimed that the socket is ready for writing. Rather than calling
	// g_socket_condition_check() and then writing to the socket if it succeeds,
	// it is generally better to simply try writing to the socket right away,
	// and try again later if the initial attempt returns
	// G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
	// conditions will always be set in the output if they are true.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionTimedWait waits for up to @timeout_us microseconds for
	// @condition to become true on @socket. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if
	// @timeout_us (or the socket's #GSocket:timeout) is reached before the
	// condition is met, then false is returned and @error, if non-nil, is set
	// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// If you don't want a timeout, use g_socket_condition_wait().
	// (Alternatively, you can pass -1 for @timeout_us.)
	//
	// Note that although @timeout_us is in microseconds for consistency with
	// other GLib APIs, this function actually only has millisecond resolution,
	// and the behavior is undefined if @timeout_us is not an exact number of
	// milliseconds.
	ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) bool
	// ConditionWait waits for @condition to become true on @socket. When the
	// condition is met, true is returned.
	//
	// If @cancellable is cancelled before the condition is met, or if the
	// socket has a timeout set and it is reached before the condition is met,
	// then false is returned and @error, if non-nil, is set to the appropriate
	// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// See also g_socket_condition_timed_wait().
	ConditionWait(condition glib.IOCondition, cancellable Cancellable) bool
	// Connect: connect the socket to the specified remote address.
	//
	// For connection oriented socket this generally means we attempt to make a
	// connection to the @address. For a connection-less socket it sets the
	// default address for g_socket_send() and discards all incoming datagrams
	// from other sources.
	//
	// Generally connection oriented sockets can only connect once, but
	// connection-less sockets can connect multiple times to change the default
	// address.
	//
	// If the connect call needs to do network I/O it will block, unless
	// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
	// user can be notified of the connection finishing by waiting for the
	// G_IO_OUT condition. The result of the connection must then be checked
	// with g_socket_check_connect_result().
	Connect(address SocketAddress, cancellable Cancellable) bool
	// ConnectionFactoryCreateConnection creates a Connection subclass of the
	// right type for @socket.
	ConnectionFactoryCreateConnection() SocketConnection
	// CreateSource creates a #GSource that can be attached to a GMainContext to
	// monitor for the availability of the specified @condition on the socket.
	// The #GSource keeps a reference to the @socket.
	//
	// The callback on the source is of the SourceFunc type.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be reported output if they are true.
	//
	// @cancellable if not nil can be used to cancel the source, which will
	// cause the source to trigger, reporting the current condition (which is
	// likely 0 unless cancellation happened at the same time as a condition
	// change). You can check for this in the callback using
	// g_cancellable_is_cancelled().
	//
	// If @socket has a timeout set, and it is reached before @condition occurs,
	// the source will then trigger anyway, reporting G_IO_IN or G_IO_OUT
	// depending on @condition. However, @socket will have been marked as having
	// had a timeout, and so the next #GSocket I/O method you call will then
	// fail with a G_IO_ERROR_TIMED_OUT.
	CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source
	// AvailableBytes: get the amount of data pending in the OS input buffer,
	// without blocking.
	//
	// If @socket is a UDP or SCTP socket, this will return the size of just the
	// next packet, even if additional packets are buffered after that one.
	//
	// Note that on Windows, this function is rather inefficient in the UDP
	// case, and so if you know any plausible upper bound on the size of the
	// incoming packet, it is better to just do a g_socket_receive() with a
	// buffer of that size, rather than calling g_socket_get_available_bytes()
	// first and then doing a receive of exactly the right size.
	AvailableBytes() int
	// Blocking gets the blocking mode of the socket. For details on blocking
	// I/O, see g_socket_set_blocking().
	Blocking() bool
	// Broadcast gets the broadcast setting on @socket; if true, it is possible
	// to send packets to broadcast addresses.
	Broadcast() bool
	// Credentials returns the credentials of the foreign process connected to
	// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
	// sockets).
	//
	// If this operation isn't supported on the OS, the method fails with the
	// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
	// the SO_PEERCRED option on the underlying socket.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
	// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
	// since GLib 2.66
	//
	// Other ways to obtain credentials from a foreign peer includes the
	// CredentialsMessage type and g_unix_connection_send_credentials() /
	// g_unix_connection_receive_credentials() functions.
	Credentials() Credentials
	// Family gets the socket family of the socket.
	Family() SocketFamily
	// Fd returns the underlying OS socket object. On unix this is a socket file
	// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
	// useful for doing platform specific or otherwise unusual operations on the
	// socket.
	Fd() int
	// Keepalive gets the keepalive mode of the socket. For details on this, see
	// g_socket_set_keepalive().
	Keepalive() bool
	// ListenBacklog gets the listen backlog setting of the socket. For details
	// on this, see g_socket_set_listen_backlog().
	ListenBacklog() int
	// LocalAddress: try to get the local address of a bound socket. This is
	// only useful if the socket has been bound to a local address, either
	// explicitly or implicitly when connecting.
	LocalAddress() SocketAddress
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
	// (the default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	MulticastLoopback() bool
	// MulticastTtl gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	MulticastTtl() uint
	// Option gets the value of an integer-valued option on @socket, as with
	// getsockopt(). (If you need to fetch a non-integer-valued option, you will
	// need to call getsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	//
	// Note that even for socket options that are a single byte in size, @value
	// is still a pointer to a #gint variable, not a #guchar;
	// g_socket_get_option() will handle the conversion internally.
	Option(level int, optname int) (value int, ok bool)
	// Protocol gets the socket protocol id the socket was created with. In case
	// the protocol is unknown, -1 is returned.
	Protocol() SocketProtocol
	// RemoteAddress: try to get the remote address of a connected socket. This
	// is only useful for connection oriented sockets that have been connected.
	RemoteAddress() SocketAddress
	// SocketType gets the socket type of the socket.
	SocketType() SocketType
	// Timeout gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	Timeout() uint
	// Ttl gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	Ttl() uint
	// IsClosed checks whether a socket is closed.
	IsClosed() bool
	// IsConnected: check whether the socket is connected. This is only useful
	// for connection-oriented sockets.
	//
	// If using g_socket_shutdown(), this function will return true until the
	// socket has been shut down for reading and writing. If you do a
	// non-blocking connect, this function will not return true until after you
	// call g_socket_check_connect_result().
	IsConnected() bool
	// JoinMulticastGroup registers @socket to receive multicast messages sent
	// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is true, source-specific multicast as defined in RFC
	// 4604 is used. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// To bind to a given source-specific multicast address, use
	// g_socket_join_multicast_group_ssm() instead.
	JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool
	// JoinMulticastGroupSsm registers @socket to receive multicast messages
	// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
	// have been bound to an appropriate interface and port with
	// g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is not nil, use source-specific multicast as defined
	// in RFC 4604. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// Note that this function can be called multiple times for the same @group
	// with different @source_specific in order to receive multicast packets
	// from more than one source.
	JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool
	// LeaveMulticastGroup removes @socket from the multicast group defined by
	// @group, @iface, and @source_specific (which must all have the same values
	// they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	//
	// To unbind to a given source-specific multicast address, use
	// g_socket_leave_multicast_group_ssm() instead.
	LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool
	// LeaveMulticastGroupSsm removes @socket from the multicast group defined
	// by @group, @iface, and @source_specific (which must all have the same
	// values they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool
	// Listen marks the socket as a server socket, i.e. a socket that is used to
	// accept incoming requests using g_socket_accept().
	//
	// Before calling this the socket must be bound to a local address using
	// g_socket_bind().
	//
	// To set the maximum amount of outstanding clients, use
	// g_socket_set_listen_backlog().
	Listen() bool
	// Receive: receive data (up to @size bytes) from a socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_receive_from() with @address set to nil.
	//
	// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
	// g_socket_receive() will always read either 0 or 1 complete messages from
	// the socket. If the received message is too large to fit in @buffer, then
	// the data beyond @size bytes will be discarded, without any explicit
	// indication that this has occurred.
	//
	// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
	// number of bytes, up to @size. If more than @size bytes have been
	// received, the additional data will be returned in future calls to
	// g_socket_receive().
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	Receive(cancellable Cancellable) (buffer []uint8, size uint, gssize int)
	// ReceiveFrom: receive data (up to @size bytes) from a socket.
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// See g_socket_receive() for additional information.
	ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []uint8, size uint, gssize int)
	// ReceiveMessage: receive data from a socket. For receiving multiple
	// messages, see g_socket_receive_messages(); for easier use, see
	// g_socket_receive() and g_socket_receive_from().
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// @vector must point to an array of Vector structs and @num_vectors must be
	// the length of this array. These structs describe the buffers that
	// received data will be scattered into. If @num_vectors is -1, then
	// @vectors is assumed to be terminated by a Vector with a nil buffer
	// pointer.
	//
	// As a special case, if @num_vectors is 0 (in which case, @vectors may of
	// course be nil), then a single byte is received and discarded. This is to
	// facilitate the common practice of sending a single '\0' byte for the
	// purposes of transferring ancillary data.
	//
	// @messages, if non-nil, will be set to point to a newly-allocated array of
	// ControlMessage instances or nil if no such messages was received. These
	// correspond to the control messages received from the kernel, one
	// ControlMessage per message from the kernel. This array is nil-terminated
	// and must be freed by the caller using g_free() after calling
	// g_object_unref() on each element. If @messages is nil, any control
	// messages received will be discarded.
	//
	// @num_messages, if non-nil, will be set to the number of control messages
	// received.
	//
	// If both @messages and @num_messages are non-nil, then @num_messages gives
	// the number of ControlMessage instances in @messages (ie: not including
	// the nil terminator).
	//
	// @flags is an in/out parameter. The commonly available arguments for this
	// are available in the MsgFlags enum, but the values there are the same as
	// the system values, and the flags are passed in as-is, so you can pass in
	// system-specific flags too (and g_socket_receive_message() may pass
	// system-specific flags out). Flags passed in to the parameter affect the
	// receive operation; flags returned out of it are relevant to the specific
	// returned message.
	//
	// As with g_socket_receive(), data may be discarded if @socket is
	// G_SOCKET_TYPE_DATAGRAM or G_SOCKET_TYPE_SEQPACKET and you do not provide
	// enough buffer space to read a complete message. You can pass
	// G_SOCKET_MSG_PEEK in @flags to peek at the current message without
	// removing it from the receive queue, but there is no portable way to find
	// out the length of the message other than by reading it into a
	// sufficiently-large buffer.
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	ReceiveMessage(vectors []InputVector, flags int, cancellable Cancellable) (address SocketAddress, messages []SocketControlMessage, numMessages int, gssize int)
	// ReceiveMessages: receive multiple data messages from @socket in one go.
	// This is the most complicated and fully-featured version of this call. For
	// easier use, see g_socket_receive(), g_socket_receive_from(), and
	// g_socket_receive_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains a pointer to an
	// array of Vector structs describing the buffers that the data received in
	// each message will be written to. Using multiple Vectors is more
	// memory-efficient than manually copying data out of a single buffer to
	// multiple sources, and more system-call-efficient than making multiple
	// calls to g_socket_receive(), such as in scenarios where a lot of data
	// packets need to be received (e.g. high-bandwidth video streaming over
	// RTP/UDP).
	//
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the MsgFlags enum, but the values
	// there are the same as the system values, and the flags are passed in
	// as-is, so you can pass in system-specific flags too. These flags affect
	// the overall receive operation. Flags affecting individual messages are
	// returned in Message.flags.
	//
	// The other members of Message are treated as described in its
	// documentation.
	//
	// If #GSocket:blocking is true the call will block until @num_messages have
	// been received, or the end of the stream is reached.
	//
	// If #GSocket:blocking is false the call will return up to @num_messages
	// without blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in
	// the operating system to be received.
	//
	// In blocking mode, if #GSocket:timeout is positive and is reached before
	// any messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up
	// to @num_messages are returned. (Note: This is effectively the behaviour
	// of `MSG_WAITFORONE` with recvmmsg().)
	//
	// To be notified when messages are available, wait for the G_IO_IN
	// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK
	// from g_socket_receive_messages() even if you were previously notified of
	// a G_IO_IN condition.
	//
	// If the remote peer closes the connection, any messages queued in the
	// operating system will be returned, and subsequent calls to
	// g_socket_receive_messages() will return 0 (with no error set).
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned.
	ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) int
	// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []uint8, size uint, gssize int)
	// Send tries to send @size bytes from @buffer on the socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_send_to() with @address set to nil.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly.
	Send(buffer []uint8, cancellable Cancellable) int
	// SendMessage: send data to @address on @socket. For sending multiple
	// messages see g_socket_send_messages(); for easier use, see
	// g_socket_send() and g_socket_send_to().
	//
	// If @address is nil then the message is sent to the default receiver (set
	// by g_socket_connect()).
	//
	// @vectors must point to an array of Vector structs and @num_vectors must
	// be the length of this array. (If @num_vectors is -1, then @vectors is
	// assumed to be terminated by a Vector with a nil buffer pointer.) The
	// Vector structs describe the buffers that the sent data will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send().
	//
	// @messages, if non-nil, is taken to point to an array of @num_messages
	// ControlMessage instances. These correspond to the control messages to be
	// sent on the socket. If @num_messages is -1 then @messages is treated as a
	// nil-terminated array.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// G_IO_OUT condition. Note though that you may still receive
	// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a G_IO_OUT condition. (On Windows in particular, this is very
	// common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly.
	SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) int
	// SendMessageWithTimeout: this behaves exactly the same as
	// g_socket_send_message(), except that the choice of timeout behavior is
	// determined by the @timeout_us argument rather than by @socket's
	// properties.
	//
	// On error G_POLLABLE_RETURN_FAILED is returned and @error is set
	// accordingly, or if the socket is currently not writable
	// G_POLLABLE_RETURN_WOULD_BLOCK is returned. @bytes_written will contain 0
	// in both cases.
	SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (bytesWritten uint, pollableReturn PollableReturn)
	// SendMessages: send multiple data messages from @socket in one go. This is
	// the most complicated and fully-featured version of this call. For easier
	// use, see g_socket_send(), g_socket_send_to(), and
	// g_socket_send_message().
	//
	// @messages must point to an array of Message structs and @num_messages
	// must be the length of this array. Each Message contains an address to
	// send the data to, and a pointer to an array of Vector structs to describe
	// the buffers that the data to be sent for each message will be gathered
	// from. Using multiple Vectors is more memory-efficient than manually
	// copying data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send(). Sending
	// multiple messages in one go avoids the overhead of making a lot of
	// syscalls in scenarios where a lot of data packets need to be sent (e.g.
	// high-bandwidth video streaming over RTP/UDP), or where the same data
	// needs to be sent to multiple recipients.
	//
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the MsgFlags enum, but the values there are the
	// same as the system values, and the flags are passed in as-is, so you can
	// pass in system-specific flags too.
	//
	// If the socket is in blocking mode the call will block until there is
	// space for all the data in the socket queue. If there is no space
	// available and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK
	// error will be returned if no data was written at all, otherwise the
	// number of messages sent will be returned. To be notified when space is
	// available, wait for the G_IO_OUT condition. Note though that you may
	// still receive G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you
	// were previously notified of a G_IO_OUT condition. (On Windows in
	// particular, this is very common due to the way the underlying APIs work.)
	//
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of
	// messages successfully sent before the error will be returned.
	SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) int
	// SendTo tries to send @size bytes from @buffer to @address. If @address is
	// nil then the message is sent to the default receiver (set by
	// g_socket_connect()).
	//
	// See g_socket_send() for additional information.
	SendTo(address SocketAddress, buffer []uint8, cancellable Cancellable) int
	// SendWithBlocking: this behaves exactly the same as g_socket_send(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	SendWithBlocking(buffer []uint8, blocking bool, cancellable Cancellable) int
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
	// operations (which don’t take an explicit blocking parameter) block until
	// they succeed or there is an error. In non-blocking mode all functions
	// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
	//
	// All sockets are created in blocking mode. However, note that the platform
	// level socket is always non-blocking, and blocking mode is a GSocket level
	// feature.
	SetBlocking(blocking bool)
	// SetBroadcast sets whether @socket should allow sending to broadcast
	// addresses. This is false by default.
	SetBroadcast(broadcast bool)
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
	// socket. When this flag is set on a socket, the system will attempt to
	// verify that the remote socket endpoint is still present if a sufficiently
	// long period of time passes with no data being exchanged. If the system is
	// unable to verify the presence of the remote endpoint, it will
	// automatically close the connection.
	//
	// This option is only functional on certain kinds of sockets. (Notably,
	// G_SOCKET_PROTOCOL_TCP sockets.)
	//
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag on
	// a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(keepalive bool)
	// SetListenBacklog sets the maximum number of outstanding connections
	// allowed when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them on time
	// then the new connections will be refused.
	//
	// Note that this must be called before g_socket_listen() and has no effect
	// if called after that.
	SetListenBacklog(backlog int)
	// SetMulticastLoopback sets whether outgoing multicast packets will be
	// received by sockets listening on that multicast address on the same host.
	// This is true by default.
	SetMulticastLoopback(loopback bool)
	// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
	// @socket. By default, this is 1, meaning that multicast packets will not
	// leave the local network.
	SetMulticastTtl(ttl uint)
	// SetOption sets the value of an integer-valued option on @socket, as with
	// setsockopt(). (If you need to set a non-integer-valued option, you will
	// need to call setsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	SetOption(level int, optname int, value int) bool
	// SetTimeout sets the time in seconds after which I/O operations on @socket
	// will time out if they have not yet completed.
	//
	// On a blocking socket, this means that any blocking #GSocket operation
	// will time out after @timeout seconds of inactivity, returning
	// G_IO_ERROR_TIMED_OUT.
	//
	// On a non-blocking socket, calls to g_socket_condition_wait() will also
	// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
	// g_socket_create_source() will trigger after @timeout seconds of
	// inactivity, with the requested condition set, at which point calling
	// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
	// etc, will fail with G_IO_ERROR_TIMED_OUT.
	//
	// If @timeout is 0 (the default), operations will never time out on their
	// own.
	//
	// Note that if an I/O operation is interrupted by a signal, this may cause
	// the timeout to be reset.
	SetTimeout(timeout uint)
	// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
	// default the platform-specific default value is used.
	SetTtl(ttl uint)
	// Shutdown: shut down part or all of a full-duplex connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be true.
	//
	// One example where it is useful to shut down only one side of a connection
	// is graceful disconnect for TCP connections where you close the sending
	// side, then wait for the other side to close the connection, thus ensuring
	// that the other side saw all sent data.
	Shutdown(shutdownRead bool, shutdownWrite bool) bool
	// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
	//
	// IPv4 sockets are capable of speaking IPv4. On some operating systems and
	// under some combinations of circumstances IPv6 sockets are also capable of
	// speaking IPv4. See RFC 3493 section 3.7 for more information.
	//
	// No other types of sockets are currently considered as being capable of
	// speaking IPv4.
	SpeaksIpv4() bool
}

type socket struct {
	*externglib.Object
}

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{*externglib.Object{obj}}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

func NewSocket(family SocketFamily, _type SocketType, protocol SocketProtocol) Socket

func NewSocketFromFd(fd int) Socket

func (s socket) Accept(cancellable Cancellable) Socket

func (s socket) Bind(address SocketAddress, allowReuse bool) bool

func (s socket) CheckConnectResult() bool

func (s socket) Close() bool

func (s socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition

func (s socket) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) bool

func (s socket) ConditionWait(condition glib.IOCondition, cancellable Cancellable) bool

func (s socket) Connect(address SocketAddress, cancellable Cancellable) bool

func (s socket) ConnectionFactoryCreateConnection() SocketConnection

func (s socket) CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source

func (s socket) AvailableBytes() int

func (s socket) Blocking() bool

func (s socket) Broadcast() bool

func (s socket) Credentials() Credentials

func (s socket) Family() SocketFamily

func (s socket) Fd() int

func (s socket) Keepalive() bool

func (s socket) ListenBacklog() int

func (s socket) LocalAddress() SocketAddress

func (s socket) MulticastLoopback() bool

func (s socket) MulticastTtl() uint

func (s socket) Option(level int, optname int) (value int, ok bool)

func (s socket) Protocol() SocketProtocol

func (s socket) RemoteAddress() SocketAddress

func (s socket) SocketType() SocketType

func (s socket) Timeout() uint

func (s socket) Ttl() uint

func (s socket) IsClosed() bool

func (s socket) IsConnected() bool

func (s socket) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool

func (s socket) JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool

func (s socket) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool

func (s socket) LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool

func (s socket) Listen() bool

func (s socket) Receive(cancellable Cancellable) (buffer []uint8, size uint, gssize int)

func (s socket) ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []uint8, size uint, gssize int)

func (s socket) ReceiveMessage(vectors []InputVector, flags int, cancellable Cancellable) (address SocketAddress, messages []SocketControlMessage, numMessages int, gssize int)

func (s socket) ReceiveMessages(messages []InputMessage, flags int, cancellable Cancellable) int

func (s socket) ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []uint8, size uint, gssize int)

func (s socket) Send(buffer []uint8, cancellable Cancellable) int

func (s socket) SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) int

func (s socket) SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (bytesWritten uint, pollableReturn PollableReturn)

func (s socket) SendMessages(messages []OutputMessage, flags int, cancellable Cancellable) int

func (s socket) SendTo(address SocketAddress, buffer []uint8, cancellable Cancellable) int

func (s socket) SendWithBlocking(buffer []uint8, blocking bool, cancellable Cancellable) int

func (s socket) SetBlocking(blocking bool)

func (s socket) SetBroadcast(broadcast bool)

func (s socket) SetKeepalive(keepalive bool)

func (s socket) SetListenBacklog(backlog int)

func (s socket) SetMulticastLoopback(loopback bool)

func (s socket) SetMulticastTtl(ttl uint)

func (s socket) SetOption(level int, optname int, value int) bool

func (s socket) SetTimeout(timeout uint)

func (s socket) SetTtl(ttl uint)

func (s socket) Shutdown(shutdownRead bool, shutdownWrite bool) bool

func (s socket) SpeaksIpv4() bool

// SocketAddress is the equivalent of struct sockaddr in the BSD sockets API.
// This is an abstract class; use SocketAddress for internet sockets, or
// SocketAddress for UNIX domain sockets.
type SocketAddress interface {
	gextras.Objector

	// Family gets the socket family type of @address.
	Family() SocketFamily
	// NativeSize gets the size of @address's native struct sockaddr. You can
	// use this to allocate memory to pass to g_socket_address_to_native().
	NativeSize() int
	// ToNative converts a Address to a native struct sockaddr, which can be
	// passed to low-level functions like connect() or bind().
	//
	// If not enough space is available, a G_IO_ERROR_NO_SPACE error is
	// returned. If the address type is not known on the system then a
	// G_IO_ERROR_NOT_SUPPORTED error is returned.
	ToNative(dest interface{}, destlen uint) bool
}

type socketAddress struct {
	*externglib.Object
}

// WrapSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddress(obj *externglib.Object) SocketAddress {
	return socketAddress{*externglib.Object{obj}}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddress(obj), nil
}

func NewSocketAddressFromNative(native interface{}, len uint) SocketAddress

func (s socketAddress) Family() SocketFamily

func (s socketAddress) NativeSize() int

func (s socketAddress) ToNative(dest interface{}, destlen uint) bool

// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator interface {
	gextras.Objector

	// Next retrieves the next Address from @enumerator. Note that this may
	// block for some amount of time. (Eg, a Address may need to do a DNS lookup
	// before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid blocking.
	//
	// If @enumerator is expected to yield addresses, but for some reason is
	// unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error in
	// *@error. However, if the first call to g_socket_address_enumerator_next()
	// succeeds, then any further internal errors (other than @cancellable being
	// triggered) will be ignored.
	Next(cancellable Cancellable) SocketAddress
	// NextAsync: asynchronously retrieves the next Address from @enumerator and
	// then calls @callback, which must call
	// g_socket_address_enumerator_next_finish() to get the result.
	//
	// It is an error to call this multiple times before the previous callback
	// has finished.
	NextAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// NextFinish retrieves the result of a completed call to
	// g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about error
	// handling.
	NextFinish(result AsyncResult) SocketAddress
}

type socketAddressEnumerator struct {
	*externglib.Object
}

// WrapSocketAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddressEnumerator(obj *externglib.Object) SocketAddressEnumerator {
	return socketAddressEnumerator{*externglib.Object{obj}}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddressEnumerator(obj), nil
}

func (s socketAddressEnumerator) Next(cancellable Cancellable) SocketAddress

func (s socketAddressEnumerator) NextAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (s socketAddressEnumerator) NextFinish(result AsyncResult) SocketAddress

// SocketClient is a lightweight high-level utility class for connecting to a
// network host using a connection oriented socket type.
//
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
//
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
type SocketClient interface {
	gextras.Objector

	// AddApplicationProxy: enable proxy protocols to be handled by the
	// application. When the indicated proxy protocol is returned by the
	// Resolver, Client will consider this protocol as supported but will not
	// try to find a #GProxy instance to handle handshaking. The application
	// must check for this case by calling
	// g_socket_connection_get_remote_address() on the returned Connection, and
	// seeing if it's a Address of the appropriate type, to determine whether or
	// not it needs to handle the proxy handshaking itself.
	//
	// This should be used for proxy protocols that are dialects of another
	// protocol such as HTTP proxy. It also allows cohabitation of proxy
	// protocols that are reused between protocols. A good example is HTTP. It
	// can be used to proxy HTTP, FTP and Gopher and can also be use as generic
	// socket proxy through the HTTP CONNECT method.
	//
	// When the proxy is detected as being an application proxy, TLS handshake
	// will be skipped. This is required to let the application do the proxy
	// specific handshake.
	AddApplicationProxy(protocol string)
	// Connect tries to resolve the @connectable and make a network connection
	// to it.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// The type of the Connection object returned depends on the type of the
	// underlying socket that is used. For instance, for a TCP/IP connection it
	// will be a Connection.
	//
	// The socket created will be the same family as the address that the
	// @connectable resolves to, unless family is set with
	// g_socket_client_set_family() or indirectly via
	// g_socket_client_set_local_address(). The socket type defaults to
	// G_SOCKET_TYPE_STREAM but can be set with
	// g_socket_client_set_socket_type().
	//
	// If a local address is specified with g_socket_client_set_local_address()
	// the socket will be bound to this address before connecting.
	Connect(connectable SocketConnectable, cancellable Cancellable) SocketConnection
	// ConnectAsync: this is the asynchronous version of
	// g_socket_client_connect().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_client_connect_finish() to get the result of the operation.
	ConnectAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectFinish finishes an async connect operation. See
	// g_socket_client_connect_async()
	ConnectFinish(result AsyncResult) SocketConnection
	// ConnectToHost: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection to the named host.
	//
	// @host_and_port may be in any of a number of recognized formats; an IPv6
	// address, an IPv4 address, or a domain name (in which case a DNS lookup is
	// performed). Quoting with [] is supported for all address types. A port
	// override may be specified in the usual way with a colon. Ports may be
	// given as decimal numbers or symbolic names (in which case an
	// /etc/services lookup is performed).
	//
	// If no port override is given in @host_and_port then @default_port will be
	// used as the port number to connect to.
	//
	// In general, @host_and_port is expected to be provided by the user
	// (allowing them to give the hostname, and a port override if necessary)
	// and @default_port is expected to be provided by the application.
	//
	// In the case that an IP address is given, a single connection attempt is
	// made. In the case that a name is given, multiple connection attempts may
	// be made, in turn and according to the number of address records in DNS,
	// until a connection succeeds.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) SocketConnection
	// ConnectToHostAsync: this is the asynchronous version of
	// g_socket_client_connect_to_host().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_client_connect_to_host_finish() to get the result of the
	// operation.
	ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectToHostFinish finishes an async connect operation. See
	// g_socket_client_connect_to_host_async()
	ConnectToHostFinish(result AsyncResult) SocketConnection
	// ConnectToService attempts to create a TCP connection to a service.
	//
	// This call looks up the SRV record for @service at @domain for the "tcp"
	// protocol. It then attempts to connect, in turn, to each of the hosts
	// providing the service until either a connection succeeds or there are no
	// hosts remaining.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToService(domain string, service string, cancellable Cancellable) SocketConnection
	// ConnectToServiceAsync: this is the asynchronous version of
	// g_socket_client_connect_to_service().
	ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectToServiceFinish finishes an async connect operation. See
	// g_socket_client_connect_to_service_async()
	ConnectToServiceFinish(result AsyncResult) SocketConnection
	// ConnectToURI: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection with a network URI.
	//
	// @uri may be any valid URI containing an "authority" (hostname/port)
	// component. If a port is not specified in the URI, @default_port will be
	// used. TLS will be negotiated if Client:tls is true. (Client does not know
	// to automatically assume TLS for certain URI schemes.)
	//
	// Using this rather than g_socket_client_connect() or
	// g_socket_client_connect_to_host() allows Client to determine when to use
	// application-specific proxy protocols.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) SocketConnection
	// ConnectToURIAsync: this is the asynchronous version of
	// g_socket_client_connect_to_uri().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_client_connect_to_uri_finish() to get the result of the
	// operation.
	ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectToURIFinish finishes an async connect operation. See
	// g_socket_client_connect_to_uri_async()
	ConnectToURIFinish(result AsyncResult) SocketConnection
	// EnableProxy gets the proxy enable state; see
	// g_socket_client_set_enable_proxy()
	EnableProxy() bool
	// Family gets the socket family of the socket client.
	//
	// See g_socket_client_set_family() for details.
	Family() SocketFamily
	// LocalAddress gets the local address of the socket client.
	//
	// See g_socket_client_set_local_address() for details.
	LocalAddress() SocketAddress
	// Protocol gets the protocol name type of the socket client.
	//
	// See g_socket_client_set_protocol() for details.
	Protocol() SocketProtocol
	// ProxyResolver gets the Resolver being used by @client. Normally, this
	// will be the resolver returned by g_proxy_resolver_get_default(), but you
	// can override it with g_socket_client_set_proxy_resolver().
	ProxyResolver() ProxyResolver
	// SocketType gets the socket type of the socket client.
	//
	// See g_socket_client_set_socket_type() for details.
	SocketType() SocketType
	// Timeout gets the I/O timeout time for sockets created by @client.
	//
	// See g_socket_client_set_timeout() for details.
	Timeout() uint
	// Tls gets whether @client creates TLS connections. See
	// g_socket_client_set_tls() for details.
	Tls() bool
	// TlsValidationFlags gets the TLS validation flags used creating TLS
	// connections via @client.
	TlsValidationFlags() TlsCertificateFlags
	// SetEnableProxy sets whether or not @client attempts to make connections
	// via a proxy server. When enabled (the default), Client will use a
	// Resolver to determine if a proxy protocol such as SOCKS is needed, and
	// automatically do the necessary proxy negotiation.
	//
	// See also g_socket_client_set_proxy_resolver().
	SetEnableProxy(enable bool)
	// SetFamily sets the socket family of the socket client. If this is set to
	// something other than G_SOCKET_FAMILY_INVALID then the sockets created by
	// this object will be of the specified family.
	//
	// This might be useful for instance if you want to force the local
	// connection to be an ipv4 socket, even though the address might be an ipv6
	// mapped to ipv4 address.
	SetFamily(family SocketFamily)
	// SetLocalAddress sets the local address of the socket client. The sockets
	// created by this object will bound to the specified address (if not nil)
	// before connecting.
	//
	// This is useful if you want to ensure that the local side of the
	// connection is on a specific port, or on a specific interface.
	SetLocalAddress(address SocketAddress)
	// SetProtocol sets the protocol of the socket client. The sockets created
	// by this object will use of the specified protocol.
	//
	// If @protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
	// protocol for the socket family and type.
	SetProtocol(protocol SocketProtocol)
	// SetProxyResolver overrides the Resolver used by @client. You can call
	// this if you want to use specific proxies, rather than using the system
	// default proxy settings.
	//
	// Note that whether or not the proxy resolver is actually used depends on
	// the setting of Client:enable-proxy, which is not changed by this function
	// (but which is true by default)
	SetProxyResolver(proxyResolver ProxyResolver)
	// SetSocketType sets the socket type of the socket client. The sockets
	// created by this object will be of the specified type.
	//
	// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM, as
	// GSocketClient is used for connection oriented services.
	SetSocketType(_type SocketType)
	// SetTimeout sets the I/O timeout for sockets created by @client. @timeout
	// is a time in seconds, or 0 for no timeout (the default).
	//
	// The timeout value affects the initial connection attempt as well, so
	// setting this may cause calls to g_socket_client_connect(), etc, to fail
	// with G_IO_ERROR_TIMED_OUT.
	SetTimeout(timeout uint)
	// SetTls sets whether @client creates TLS (aka SSL) connections. If @tls is
	// true, @client will wrap its connections in a ClientConnection and perform
	// a TLS handshake when connecting.
	//
	// Note that since Client must return a Connection, but ClientConnection is
	// not a Connection, this actually wraps the resulting ClientConnection in a
	// WrapperConnection when returning it. You can use
	// g_tcp_wrapper_connection_get_base_io_stream() on the return value to
	// extract the ClientConnection.
	//
	// If you need to modify the behavior of the TLS handshake (eg, by setting a
	// client-side certificate to use, or connecting to the
	// Connection::accept-certificate signal), you can connect to @client's
	// Client::event signal and wait for it to be emitted with
	// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
	// ClientConnection before the handshake starts.
	SetTls(tls bool)
	// SetTlsValidationFlags sets the TLS validation flags used when creating
	// TLS connections via @client. The default value is
	// G_TLS_CERTIFICATE_VALIDATE_ALL.
	SetTlsValidationFlags(flags TlsCertificateFlags)
}

type socketClient struct {
	*externglib.Object
}

// WrapSocketClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketClient(obj *externglib.Object) SocketClient {
	return socketClient{*externglib.Object{obj}}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketClient(obj), nil
}

func NewSocketClient() SocketClient

func (s socketClient) AddApplicationProxy(protocol string)

func (s socketClient) Connect(connectable SocketConnectable, cancellable Cancellable) SocketConnection

func (s socketClient) ConnectAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback)

func (s socketClient) ConnectFinish(result AsyncResult) SocketConnection

func (s socketClient) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) SocketConnection

func (s socketClient) ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)

func (s socketClient) ConnectToHostFinish(result AsyncResult) SocketConnection

func (s socketClient) ConnectToService(domain string, service string, cancellable Cancellable) SocketConnection

func (s socketClient) ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback)

func (s socketClient) ConnectToServiceFinish(result AsyncResult) SocketConnection

func (s socketClient) ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) SocketConnection

func (s socketClient) ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)

func (s socketClient) ConnectToURIFinish(result AsyncResult) SocketConnection

func (s socketClient) EnableProxy() bool

func (s socketClient) Family() SocketFamily

func (s socketClient) LocalAddress() SocketAddress

func (s socketClient) Protocol() SocketProtocol

func (s socketClient) ProxyResolver() ProxyResolver

func (s socketClient) SocketType() SocketType

func (s socketClient) Timeout() uint

func (s socketClient) Tls() bool

func (s socketClient) TlsValidationFlags() TlsCertificateFlags

func (s socketClient) SetEnableProxy(enable bool)

func (s socketClient) SetFamily(family SocketFamily)

func (s socketClient) SetLocalAddress(address SocketAddress)

func (s socketClient) SetProtocol(protocol SocketProtocol)

func (s socketClient) SetProxyResolver(proxyResolver ProxyResolver)

func (s socketClient) SetSocketType(_type SocketType)

func (s socketClient) SetTimeout(timeout uint)

func (s socketClient) SetTls(tls bool)

func (s socketClient) SetTlsValidationFlags(flags TlsCertificateFlags)

// SocketConnection is a OStream for a connected socket. They can be created
// either by Client when connecting to a host, or by Listener when accepting a
// new client.
//
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
//
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
type SocketConnection interface {
	IOStream

	// Connect: connect @connection to the specified remote address.
	Connect(address SocketAddress, cancellable Cancellable) bool
	// ConnectAsync: asynchronously connect @connection to the specified remote
	// address.
	//
	// This clears the #GSocket:blocking flag on @connection's underlying socket
	// if it is currently set.
	//
	// Use g_socket_connection_connect_finish() to retrieve the result.
	ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectFinish gets the result of a g_socket_connection_connect_async()
	// call.
	ConnectFinish(result AsyncResult) bool
	// LocalAddress: try to get the local address of a socket connection.
	LocalAddress() SocketAddress
	// RemoteAddress: try to get the remote address of a socket connection.
	//
	// Since GLib 2.40, when used with g_socket_client_connect() or
	// g_socket_client_connect_async(), during emission of
	// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address
	// that will be used for the connection. This allows applications to print
	// e.g. "Connecting to example.com (10.42.77.3)...".
	RemoteAddress() SocketAddress
	// Socket gets the underlying #GSocket object of the connection. This can be
	// useful if you want to do something unusual on it not supported by the
	// Connection APIs.
	Socket() Socket
	// IsConnected checks if @connection is connected. This is equivalent to
	// calling g_socket_is_connected() on @connection's underlying #GSocket.
	IsConnected() bool
}

type socketConnection struct {
	ioStream
}

// WrapSocketConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketConnection(obj *externglib.Object) SocketConnection {
	return socketConnection{ioStream{*externglib.Object{obj}}}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketConnection(obj), nil
}

func (s socketConnection) Connect(address SocketAddress, cancellable Cancellable) bool

func (s socketConnection) ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback)

func (s socketConnection) ConnectFinish(result AsyncResult) bool

func (s socketConnection) LocalAddress() SocketAddress

func (s socketConnection) RemoteAddress() SocketAddress

func (s socketConnection) Socket() Socket

func (s socketConnection) IsConnected() bool

// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage interface {
	gextras.Objector

	// Level returns the "level" (i.e. the originating protocol) of the control
	// message. This is often SOL_SOCKET.
	Level() int
	// MsgType returns the protocol specific type of the control message. For
	// instance, for UNIX fd passing this would be SCM_RIGHTS.
	MsgType() int
	// Size returns the space required for the control message, not including
	// headers or alignment.
	Size() uint
	// Serialize converts the data in the message to bytes placed in the
	// message.
	//
	// @data is guaranteed to have enough space to fit the size returned by
	// g_socket_control_message_get_size() on this object.
	Serialize(data interface{})
}

type socketControlMessage struct {
	*externglib.Object
}

// WrapSocketControlMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketControlMessage(obj *externglib.Object) SocketControlMessage {
	return socketControlMessage{*externglib.Object{obj}}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketControlMessage(obj), nil
}

func (s socketControlMessage) Level() int

func (s socketControlMessage) MsgType() int

func (s socketControlMessage) Size() uint

func (s socketControlMessage) Serialize(data interface{})

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener interface {
	gextras.Objector

	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection)
	// AcceptAsync: this is the asynchronous version of
	// g_socket_listener_accept().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket() to get the result of the
	// operation.
	AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptFinish finishes an async accept operation. See
	// g_socket_listener_accept_async()
	AcceptFinish(result AsyncResult) (sourceObject gextras.Objector, socketConnection SocketConnection)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket)
	// AcceptSocketAsync: this is the asynchronous version of
	// g_socket_listener_accept_socket().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket_finish() to get the result of the
	// operation.
	AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptSocketFinish finishes an async accept operation. See
	// g_socket_listener_accept_socket_async()
	AcceptSocketFinish(result AsyncResult) (sourceObject gextras.Objector, socket Socket)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	AddAddress(address SocketAddress, _type SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, ok bool)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	AddAnyInetPort(sourceObject gextras.Objector) uint16
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddInetPort(port uint16, sourceObject gextras.Objector) bool
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	AddSocket(socket Socket, sourceObject gextras.Objector) bool
	// Close closes all the sockets in the listener.
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	SetBacklog(listenBacklog int)
}

type socketListener struct {
	*externglib.Object
}

// WrapSocketListener wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketListener(obj *externglib.Object) SocketListener {
	return socketListener{*externglib.Object{obj}}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketListener(obj), nil
}

func NewSocketListener() SocketListener

func (s socketListener) Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection)

func (s socketListener) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (s socketListener) AcceptFinish(result AsyncResult) (sourceObject gextras.Objector, socketConnection SocketConnection)

func (s socketListener) AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket)

func (s socketListener) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (s socketListener) AcceptSocketFinish(result AsyncResult) (sourceObject gextras.Objector, socket Socket)

func (s socketListener) AddAddress(address SocketAddress, _type SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, ok bool)

func (s socketListener) AddAnyInetPort(sourceObject gextras.Objector) uint16

func (s socketListener) AddInetPort(port uint16, sourceObject gextras.Objector) bool

func (s socketListener) AddSocket(socket Socket, sourceObject gextras.Objector) bool

func (s socketListener) Close()

func (s socketListener) SetBacklog(listenBacklog int)

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	SocketListener

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	Stop()
}

type socketService struct {
	socketListener
}

// WrapSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketService(obj *externglib.Object) SocketService {
	return socketService{socketListener{*externglib.Object{obj}}}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketService(obj), nil
}

func NewSocketService() SocketService

func (s socketService) IsActive() bool

func (s socketService) Start()

func (s socketService) Stop()

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector

	// Communicate: communicate with the subprocess until it terminates, and all
	// input and output has been completed.
	//
	// If @stdin_buf is given, the subprocess must have been created with
	// G_SUBPROCESS_FLAGS_STDIN_PIPE. The given data is fed to the stdin of the
	// subprocess and the pipe is closed (ie: EOF).
	//
	// At the same time (as not to cause blocking when dealing with large
	// amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
	// G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those streams. The
	// data that was read is returned in @stdout and/or the @stderr.
	//
	// If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// @stdout_buf will contain the data read from stdout. Otherwise, for
	// subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE, @stdout_buf
	// will be set to nil. Similar provisions apply to @stderr_buf and
	// G_SUBPROCESS_FLAGS_STDERR_PIPE.
	//
	// As usual, any output variable may be given as nil to ignore it.
	//
	// If you desire the stdout and stderr data to be interleaved, create the
	// subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
	// G_SUBPROCESS_FLAGS_STDERR_MERGE. The merged result will be returned in
	// @stdout_buf and @stderr_buf will be set to nil.
	//
	// In case of any error (including cancellation), false will be returned
	// with @error set. Some or all of the stdin data may have been written. Any
	// stdout or stderr data that has been read will be discarded. None of the
	// out variables (aside from @error) will have been set to anything in
	// particular and should not be inspected.
	//
	// In the case that true is returned, the subprocess has exited and the exit
	// status inspection APIs (eg: g_subprocess_get_if_exited(),
	// g_subprocess_get_exit_status()) may be used.
	//
	// You should not attempt to use any of the subprocess pipes after starting
	// this function, since they may be left in strange states, even if the
	// operation was cancelled. You should especially not attempt to interact
	// with the pipes while the operation is in progress (either from another
	// thread or if using the asynchronous version).
	Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool)
	// CommunicateAsync asynchronous version of g_subprocess_communicate().
	// Complete invocation with g_subprocess_communicate_finish().
	CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateFinish: complete an invocation of
	// g_subprocess_communicate_async().
	CommunicateFinish(result AsyncResult) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool)
	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, ok bool)
	// CommunicateUTF8Async asynchronous version of
	// g_subprocess_communicate_utf8(). Complete invocation with
	// g_subprocess_communicate_utf8_finish().
	CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, ok bool)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) bool
	// WaitAsync: wait for the subprocess to terminate.
	//
	// This is the asynchronous version of g_subprocess_wait().
	WaitAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) bool
	// WaitCheckAsync combines g_subprocess_wait_async() with
	// g_spawn_check_exit_status().
	//
	// This is the asynchronous version of g_subprocess_wait_check().
	WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResult) bool
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResult) bool
}

type subprocess struct {
	*externglib.Object
}

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return subprocess{*externglib.Object{obj}}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

func NewSubprocessv(argv []string, flags SubprocessFlags) Subprocess

func (s subprocess) Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool)

func (s subprocess) CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback)

func (s subprocess) CommunicateFinish(result AsyncResult) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool)

func (s subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, ok bool)

func (s subprocess) CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)

func (s subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, ok bool)

func (s subprocess) ForceExit()

func (s subprocess) ExitStatus() int

func (s subprocess) Identifier() string

func (s subprocess) IfExited() bool

func (s subprocess) IfSignaled() bool

func (s subprocess) Status() int

func (s subprocess) StderrPipe() InputStream

func (s subprocess) StdinPipe() OutputStream

func (s subprocess) StdoutPipe() InputStream

func (s subprocess) Successful() bool

func (s subprocess) TermSig() int

func (s subprocess) SendSignal(signalNum int)

func (s subprocess) Wait(cancellable Cancellable) bool

func (s subprocess) WaitAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (s subprocess) WaitCheck(cancellable Cancellable) bool

func (s subprocess) WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (s subprocess) WaitCheckFinish(result AsyncResult) bool

func (s subprocess) WaitFinish(result AsyncResult) bool

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetChildSetup sets up a child setup function.
	//
	// The child setup function will be called after fork() but before exec() on
	// the child's side.
	//
	// @destroy_notify will not be automatically called on the child's side of
	// the fork(). It will only be called when the last reference on the
	// Launcher is dropped or when a new child setup function is given.
	//
	// nil can be given as @child_setup to disable the functionality.
	//
	// Child setup functions are only available on UNIX.
	SetChildSetup(childSetup glib.SpawnChildSetupFunc)
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process’ environment. As of GLib 2.54, the parent process’
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) Subprocess
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes "ownership" of the fd; it will be closed in
	// the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom pipe() or
	// socketpair() before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// --passphrase-fd providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

type subprocessLauncher struct {
	*externglib.Object
}

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return subprocessLauncher{*externglib.Object{obj}}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher

func (s subprocessLauncher) env(variable string) string

func (s subprocessLauncher) SetChildSetup(childSetup glib.SpawnChildSetupFunc)

func (s subprocessLauncher) SetCwd(cwd string)

func (s subprocessLauncher) SetEnviron(env []string)

func (s subprocessLauncher) SetFlags(flags SubprocessFlags)

func (s subprocessLauncher) SetStderrFilePath(path string)

func (s subprocessLauncher) SetStdinFilePath(path string)

func (s subprocessLauncher) SetStdoutFilePath(path string)

func (s subprocessLauncher) Setenv(variable string, value string, overwrite bool)

func (s subprocessLauncher) Spawnv(argv []string) Subprocess

func (s subprocessLauncher) TakeFd(sourceFd int, targetFd int)

func (s subprocessLauncher) TakeStderrFd(fd int)

func (s subprocessLauncher) TakeStdinFd(fd int)

func (s subprocessLauncher) TakeStdoutFd(fd int)

func (s subprocessLauncher) Unsetenv(variable string)

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult:
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
type Task interface {
	gextras.Objector

	// AttachSource: a utility function for dealing with async operations where
	// you need to wait for a #GSource to trigger. Attaches @source to @task's
	// Context with @task's [priority][io-priority], and sets @source's callback
	// to @callback, with @task as the callback's `user_data`.
	//
	// It will set the @source’s name to the task’s name (as set with
	// g_task_set_name()), if one has been set.
	//
	// This takes a reference on @task until @source is destroyed.
	AttachSource(source *glib.Source, callback glib.SourceFunc)
	// Cancellable gets @task's #GCancellable
	Cancellable() Cancellable
	// CheckCancellable gets @task's check-cancellable flag. See
	// g_task_set_check_cancellable() for more details.
	CheckCancellable() bool
	// Completed gets the value of #GTask:completed. This changes from false to
	// true after the task’s callback is invoked, and will return false if
	// called from inside the callback.
	Completed() bool
	// Context gets the Context that @task will return its result in (that is,
	// the context that was the [thread-default main
	// context][g-main-context-push-thread-default] at the point when @task was
	// created).
	//
	// This will always return a non-nil value, even if the task's context is
	// the default Context.
	Context() *glib.MainContext
	// Name gets @task’s name. See g_task_set_name().
	Name() string
	// Priority gets @task's priority
	Priority() int
	// ReturnOnCancel gets @task's return-on-cancel flag. See
	// g_task_set_return_on_cancel() for more details.
	ReturnOnCancel() bool
	// SourceObject gets the source object from @task. Like
	// g_async_result_get_source_object(), but does not ref the object.
	SourceObject() gextras.Objector
	// SourceTag gets @task's source tag. See g_task_set_source_tag().
	SourceTag() interface{}
	// TaskData gets @task's `task_data`.
	TaskData() interface{}
	// HadError tests if @task resulted in an error.
	HadError() bool
	// PropagateBoolean gets the result of @task as a #gboolean.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return false and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateBoolean() bool
	// PropagateInt gets the result of @task as an integer (#gssize).
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return -1 and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateInt() int
	// PropagatePointer gets the result of @task as a pointer, and transfers
	// ownership of that value to the caller.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return nil and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagatePointer() interface{}
	// PropagateValue gets the result of @task as a #GValue, and transfers
	// ownership of that value to the caller. As with g_task_return_value(),
	// this is a generic low-level method; g_task_propagate_pointer() and the
	// like will usually be more useful for C code.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead set @error and return false.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateValue() (value externglib.Value, ok bool)
	// ReturnBoolean sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnBoolean(result bool)
	// ReturnError sets @task's result to @error (which @task assumes ownership
	// of) and completes the task (see g_task_return_pointer() for more
	// discussion of exactly what this means).
	//
	// Note that since the task takes ownership of @error, and since the task
	// may be completed before returning from g_task_return_error(), you cannot
	// assume that @error is still valid after calling this. Call g_error_copy()
	// on the error if you need to keep a local copy as well.
	//
	// See also g_task_return_new_error().
	ReturnError(error *glib.Error)
	// ReturnErrorIfCancelled checks if @task's #GCancellable has been
	// cancelled, and if so, sets @task's error accordingly and completes the
	// task (see g_task_return_pointer() for more discussion of exactly what
	// this means).
	ReturnErrorIfCancelled() bool
	// ReturnInt sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnInt(result int)
	// ReturnPointer sets @task's result to @result and completes the task. If
	// @result is not nil, then @result_destroy will be used to free @result if
	// the caller does not take ownership of it with g_task_propagate_pointer().
	//
	// "Completes the task" means that for an ordinary asynchronous task it will
	// either invoke the task's callback, or else queue that callback to be
	// invoked in the proper Context, or in the next iteration of the current
	// Context. For a task run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync(), calling this method will save @result to be
	// returned to the caller later, but the task will not actually be completed
	// until the ThreadFunc exits.
	//
	// Note that since the task may be completed before returning from
	// g_task_return_pointer(), you cannot assume that @result is still valid
	// after calling this, unless you are still holding another reference on it.
	ReturnPointer(result interface{})
	// ReturnValue sets @task's result to @result (by copying it) and completes
	// the task.
	//
	// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
	// will be used for the result.
	//
	// This is a very generic low-level method intended primarily for use by
	// language bindings; for C code, g_task_return_pointer() and the like will
	// normally be much easier to use.
	ReturnValue(result *externglib.Value)
	// RunInThread runs @task_func in another thread. When @task_func returns,
	// @task's ReadyCallback will be invoked in @task's Context.
	//
	// This takes a ref on @task until the task completes.
	//
	// See ThreadFunc for more details about how @task_func is handled.
	//
	// Although GLib currently rate-limits the tasks queued via
	// g_task_run_in_thread(), you should not assume that it will always do
	// this. If you have a very large number of tasks to run, but don't want
	// them to all run at once, you should only queue a limited number of them
	// at a time.
	RunInThread(taskFunc TaskThreadFunc)
	// RunInThreadSync runs @task_func in another thread, and waits for it to
	// return or be cancelled. You can use g_task_propagate_pointer(), etc,
	// afterward to get the result of @task_func.
	//
	// See ThreadFunc for more details about how @task_func is handled.
	//
	// Normally this is used with tasks created with a nil `callback`, but note
	// that even if the task does have a callback, it will not be invoked when
	// @task_func returns. #GTask:completed will be set to true just before this
	// function returns.
	//
	// Although GLib currently rate-limits the tasks queued via
	// g_task_run_in_thread_sync(), you should not assume that it will always do
	// this. If you have a very large number of tasks to run, but don't want
	// them to all run at once, you should only queue a limited number of them
	// at a time.
	RunInThreadSync(taskFunc TaskThreadFunc)
	// SetCheckCancellable sets or clears @task's check-cancellable flag. If
	// this is true (the default), then g_task_propagate_pointer(), etc, and
	// g_task_had_error() will check the task's #GCancellable first, and if it
	// has been cancelled, then they will consider the task to have returned an
	// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
	// other error or return value the task may have had.
	//
	// If @check_cancellable is false, then the #GTask will not check the
	// cancellable itself, and it is up to @task's owner to do this (eg, via
	// g_task_return_error_if_cancelled()).
	//
	// If you are using g_task_set_return_on_cancel() as well, then you must
	// leave check-cancellable set true.
	SetCheckCancellable(checkCancellable bool)
	// SetName sets @task’s name, used in debugging and profiling. The name
	// defaults to nil.
	//
	// The task name should describe in a human readable way what the task does.
	// For example, ‘Open file’ or ‘Connect to network host’. It is used to set
	// the name of the #GSource used for idle completion of the task.
	//
	// This function may only be called before the @task is first used in a
	// thread other than the one it was constructed in.
	SetName(name string)
	// SetPriority sets @task's priority. If you do not call this, it will
	// default to G_PRIORITY_DEFAULT.
	//
	// This will affect the priority of #GSources created with
	// g_task_attach_source() and the scheduling of tasks run in threads, and
	// can also be explicitly retrieved later via g_task_get_priority().
	SetPriority(priority int)
	// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
	// only meaningful for tasks run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync().
	//
	// If @return_on_cancel is true, then cancelling @task's #GCancellable will
	// immediately cause it to return, as though the task's ThreadFunc had
	// called g_task_return_error_if_cancelled() and then returned.
	//
	// This allows you to create a cancellable wrapper around an uninterruptible
	// function. The ThreadFunc just needs to be careful that it does not modify
	// any externally-visible state after it has been cancelled. To do that, the
	// thread should call g_task_set_return_on_cancel() again to (atomically)
	// set return-on-cancel false before making externally-visible changes; if
	// the task gets cancelled before the return-on-cancel flag could be
	// changed, g_task_set_return_on_cancel() will indicate this by returning
	// false.
	//
	// You can disable and re-enable this flag multiple times if you wish. If
	// the task's #GCancellable is cancelled while return-on-cancel is false,
	// then calling g_task_set_return_on_cancel() to set it true again will
	// cause the task to be cancelled at that point.
	//
	// If the task's #GCancellable is already cancelled before you call
	// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
	// will still be run (for consistency), but the task will also be completed
	// right away.
	SetReturnOnCancel(returnOnCancel bool) bool
	// SetSourceTag sets @task's source tag. You can use this to tag a task
	// return value with a particular pointer (usually a pointer to the function
	// doing the tagging) and then later check it using g_task_get_source_tag()
	// (or g_async_result_is_tagged()) in the task's "finish" function, to
	// figure out if the response came from a particular place.
	SetSourceTag(sourceTag interface{})
	// SetTaskData sets @task's task data (freeing the existing task data, if
	// any).
	SetTaskData(taskData interface{})
}

type task struct {
	*externglib.Object
}

// WrapTask wraps a GObject to the right type. It is
// primarily used internally.
func WrapTask(obj *externglib.Object) Task {
	return task{*externglib.Object{obj}}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTask(obj), nil
}

func NewTask(sourceObject gextras.Objector, cancellable Cancellable, callback AsyncReadyCallback) Task

func (t task) AttachSource(source *glib.Source, callback glib.SourceFunc)

func (t task) Cancellable() Cancellable

func (t task) CheckCancellable() bool

func (t task) Completed() bool

func (t task) Context() *glib.MainContext

func (t task) Name() string

func (t task) Priority() int

func (t task) ReturnOnCancel() bool

func (t task) SourceObject() gextras.Objector

func (t task) SourceTag() interface{}

func (t task) TaskData() interface{}

func (t task) HadError() bool

func (t task) PropagateBoolean() bool

func (t task) PropagateInt() int

func (t task) PropagatePointer() interface{}

func (t task) PropagateValue() (value externglib.Value, ok bool)

func (t task) ReturnBoolean(result bool)

func (t task) ReturnError(error *glib.Error)

func (t task) ReturnErrorIfCancelled() bool

func (t task) ReturnInt(result int)

func (t task) ReturnPointer(result interface{})

func (t task) ReturnValue(result *externglib.Value)

func (t task) RunInThread(taskFunc TaskThreadFunc)

func (t task) RunInThreadSync(taskFunc TaskThreadFunc)

func (t task) SetCheckCancellable(checkCancellable bool)

func (t task) SetName(name string)

func (t task) SetPriority(priority int)

func (t task) SetReturnOnCancel(returnOnCancel bool) bool

func (t task) SetSourceTag(sourceTag interface{})

func (t task) SetTaskData(taskData interface{})

// TcpConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TcpConnection interface {
	SocketConnection

	// GracefulDisconnect checks if graceful disconnects are used. See
	// g_tcp_connection_set_graceful_disconnect().
	GracefulDisconnect() bool
	// SetGracefulDisconnect: this enables graceful disconnects on close. A
	// graceful disconnect means that we signal the receiving end that the
	// connection is terminated and wait for it to close the connection before
	// closing the connection.
	//
	// A graceful disconnect means that we can be sure that we successfully sent
	// all the outstanding data to the other end, or get an error reported.
	// However, it also means we have to wait for all the data to reach the
	// other side and for it to acknowledge this by closing the socket, which
	// may take a while. For this reason it is disabled by default.
	SetGracefulDisconnect(gracefulDisconnect bool)
}

type tcpConnection struct {
	socketConnection
}

// WrapTcpConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTcpConnection(obj *externglib.Object) TcpConnection {
	return tcpConnection{socketConnection{ioStream{*externglib.Object{obj}}}}
}

func marshalTcpConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTcpConnection(obj), nil
}

func (t tcpConnection) GracefulDisconnect() bool

func (t tcpConnection) SetGracefulDisconnect(gracefulDisconnect bool)

// TcpWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
type TcpWrapperConnection interface {
	TcpConnection

	// BaseIOStream gets @conn's base OStream
	BaseIOStream() IOStream
}

type tcpWrapperConnection struct {
	tcpConnection
}

// WrapTcpWrapperConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTcpWrapperConnection(obj *externglib.Object) TcpWrapperConnection {
	return tcpWrapperConnection{tcpConnection{socketConnection{ioStream{*externglib.Object{obj}}}}}
}

func marshalTcpWrapperConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTcpWrapperConnection(obj), nil
}

func NewTcpWrapperConnection(baseIOStream IOStream, socket Socket) TcpWrapperConnection

func (t tcpWrapperConnection) BaseIOStream() IOStream

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the user’s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//
//        [D-BUS Service]
//        Name=org.gtk.GDBus.Examples.ObjectManager
//        Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//    ]|
//    You will also need to indicate this service directory in your test
//    fixtures, so you will need to pass the path while compiling your
//    test cases. Typically this is done with autotools with an added
//    preprocessor flag specified to compile your tests such as:
//    |[
//        -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//    ]|
//        Once you have a service definition file which is local to your source tree,
//    you can proceed to set up a GTest fixture using the DBus scaffolding.
//
//    An example of a test fixture for D-Bus services can be found
//    here:
//    gdbus-test-fixture.c (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
//    Note that these examples only deal with isolating the D-Bus aspect of your
//    service. To successfully run isolated unit tests on your service you may need
//    some additional modifications to your test case fixture. For example; if your
//    service uses GSettings and installs a schema then it is important that your test service
//    not load the schema in the ordinary installed location (chances are that your service
//    and schema files are not yet installed, or worse; there is an older version of the
//    schema file sitting in the install location).
//
//    Most of the time we can work around these obstacles using the
//    environment. Since the environment is inherited by the D-Bus daemon
//    created by DBus and then in turn inherited by any services the
//    D-Bus daemon activates, using the setup routine for your fixture is
//    a practical place to help sandbox your runtime environment. For the
//    rather typical GSettings case we can work around this by setting
//    `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
//    in the above fixture_setup() routine.
//
//    The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
//    by compiling the schemas locally as a step before running test cases, an autotools setup might
//    do the following in the directory holding schemas:
//    |[
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
//
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop: stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

type testDBus struct {
	*externglib.Object
}

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return testDBus{*externglib.Object{obj}}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

func NewTestDBus(flags TestDBusFlags) TestDBus

func (t testDBus) AddServiceDir(path string)

func (t testDBus) Down()

func (t testDBus) BusAddress() string

func (t testDBus) Flags() TestDBusFlags

func (t testDBus) Stop()

func (t testDBus) Up()

// ThemedIcon is an implementation of #GIcon that supports icon themes. Icon
// contains a list of all of the icons present in an icon theme, so that icons
// can be looked up quickly. Icon does not provide actual pixmaps for icons,
// just the icon names. Ideally something like gtk_icon_theme_choose_icon()
// should be used to resolve the list of names so that fallback icons work
// nicely with themes that inherit other themes.
type ThemedIcon interface {
	gextras.Objector

	// AppendName: append a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	AppendName(iconname string)
	// Names gets the names of icons from within @icon.
	Names() []string
	// PrependName: prepend a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	PrependName(iconname string)
}

type themedIcon struct {
	*externglib.Object
}

// WrapThemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapThemedIcon(obj *externglib.Object) ThemedIcon {
	return themedIcon{*externglib.Object{obj}}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThemedIcon(obj), nil
}

func NewThemedIcon(iconname string) ThemedIcon

func NewThemedIconFromNames(iconnames []string) ThemedIcon

func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon

func (t themedIcon) AppendName(iconname string)

func (t themedIcon) Names() []string

func (t themedIcon) PrependName(iconname string)

// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService interface {
	SocketService
}

type threadedSocketService struct {
	socketService
}

// WrapThreadedSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapThreadedSocketService(obj *externglib.Object) ThreadedSocketService {
	return threadedSocketService{socketService{socketListener{*externglib.Object{obj}}}}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThreadedSocketService(obj), nil
}

func NewThreadedSocketService(maxThreads int) ThreadedSocketService

// TlsCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
type TlsCertificate interface {
	gextras.Objector

	// Issuer gets the Certificate representing @cert's issuer, if known
	Issuer() TlsCertificate
	// IsSame: check if two Certificate objects represent the same certificate.
	// The raw DER byte data of the two certificates are checked for equality.
	// This has the effect that two certificates may compare equal even if their
	// Certificate:issuer, Certificate:private-key, or
	// Certificate:private-key-pem properties differ.
	IsSame(certTwo TlsCertificate) bool
	// Verify: this verifies @cert and returns a set of CertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to check a
	// certificate against a CA that is not part of the system CA database.
	//
	// If @identity is not nil, @cert's name(s) will be compared against it, and
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does
	// not match. If @identity is nil, that bit will never be set in the return
	// value.
	//
	// If @trusted_ca is not nil, then @cert (or one of the certificates in its
	// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be
	// set in the return value. If @trusted_ca is nil, that bit will never be
	// set in the return value.
	//
	// (All other CertificateFlags values will always be set or unset as
	// appropriate.)
	Verify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags
}

type tlsCertificate struct {
	*externglib.Object
}

// WrapTlsCertificate wraps a GObject to the right type. It is
// primarily used internally.
func WrapTlsCertificate(obj *externglib.Object) TlsCertificate {
	return tlsCertificate{*externglib.Object{obj}}
}

func marshalTlsCertificate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTlsCertificate(obj), nil
}

func NewTlsCertificateFromFile(file string) TlsCertificate

func NewTlsCertificateFromFiles(certFile string, keyFile string) TlsCertificate

func NewTlsCertificateFromPem(data string, length int) TlsCertificate

func (t tlsCertificate) Issuer() TlsCertificate

func (t tlsCertificate) IsSame(certTwo TlsCertificate) bool

func (t tlsCertificate) Verify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags

// TlsConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TlsConnection interface {
	IOStream

	// EmitAcceptCertificate: used by Connection implementations to emit the
	// Connection::accept-certificate signal.
	EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool
	// Certificate gets @conn's certificate, as set by
	// g_tls_connection_set_certificate().
	Certificate() TlsCertificate
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
	// @type for @conn.
	//
	// This call retrieves TLS channel binding data as specified in RFC 5056
	// (https://tools.ietf.org/html/rfc5056), RFC 5929
	// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data
	// is returned in @data. The @data is resized by the callee using Array
	// buffer management and will be freed when the @data is destroyed by
	// g_byte_array_unref(). If @data is nil, it will only check whether TLS
	// backend is able to fetch the data (e.g. whether @type is supported by the
	// TLS backend). It does not guarantee that the data will be available
	// though. That could happen if TLS connection does not support @type or the
	// binding data is not available yet due to additional negotiation or input
	// required.
	ChannelBindingData(_type TlsChannelBindingType) (data []uint8, ok bool)
	// Database gets the certificate database that @conn uses to verify peer
	// certificates. See g_tls_connection_set_database().
	Database() TlsDatabase
	// Interaction: get the object that will be used to interact with the user.
	// It will be used for things like prompting the user for passwords. If nil
	// is returned, then no user interaction will occur for this connection.
	Interaction() TlsInteraction
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_tls_connection_set_advertised_protocols().
	NegotiatedProtocol() string
	// PeerCertificate gets @conn's peer's certificate after the handshake has
	// completed or failed. (It is not set during the emission of
	// Connection::accept-certificate.)
	PeerCertificate() TlsCertificate
	// PeerCertificateErrors gets the errors associated with validating @conn's
	// peer's certificate, after the handshake has completed or failed. (It is
	// not set during the emission of Connection::accept-certificate.)
	PeerCertificateErrors() TlsCertificateFlags
	// RehandshakeMode gets @conn rehandshaking mode. See
	// g_tls_connection_set_rehandshake_mode() for details.
	RehandshakeMode() TlsRehandshakeMode
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
	// notification when the connection is closed. See
	// g_tls_connection_set_require_close_notify() for details.
	RequireCloseNotify() bool
	// UseSystemCertdb gets whether @conn uses the system certificate database
	// to verify peer certificates. See
	// g_tls_connection_set_use_system_certdb().
	UseSystemCertdb() bool
	// Handshake attempts a TLS handshake on @conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting (or after
	// sending a "STARTTLS"-type command), Connection will handle this for you
	// automatically when you try to send or receive data on the connection. You
	// can call g_tls_connection_handshake() manually if you want to know
	// whether the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case, if it
	// fails, it may not be possible to tell if it failed before or after
	// completing the handshake), but beware that servers may reject client
	// authentication after the handshake has completed, so a successful
	// handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// When using a Connection created by Client, the Client performs the
	// initial handshake, so calling this function manually is not recommended.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	Handshake(cancellable Cancellable) bool
	// HandshakeAsync: asynchronously performs a TLS handshake on @conn. See
	// g_tls_connection_handshake() for more information.
	HandshakeAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// HandshakeFinish: finish an asynchronous TLS handshake operation. See
	// g_tls_connection_handshake() for more information.
	HandshakeFinish(result AsyncResult) bool
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_tls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	//
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: this sets the certificate that @conn will present to its
	// peer during the TLS handshake. For a ServerConnection, it is mandatory to
	// set this, and that will normally be done at construct time.
	//
	// For a ClientConnection, this is optional. If a handshake fails with
	// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
	// certificate, and if you try connecting again, you should call this method
	// first. You can call g_tls_client_connection_get_accepted_cas() on the
	// failed connection to get a list of Certificate Authorities that the
	// server will accept certificates from.
	//
	// (It is also possible that a server will allow the connection with or
	// without a certificate; in that case, if you don't provide a certificate,
	// you can tell that the server requested one by the fact that
	// g_tls_client_connection_get_accepted_cas() will return non-nil.)
	SetCertificate(certificate TlsCertificate)
	// SetDatabase sets the certificate database that is used to verify peer
	// certificates. This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to nil, then peer
	// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
	// error (meaning Connection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetDatabase(database TlsDatabase)
	// SetInteraction: set the object that will be used to interact with the
	// user. It will be used for things like prompting the user for passwords.
	//
	// The @interaction argument will normally be a derived subclass of
	// Interaction. nil can also be provided if no user interaction should occur
	// for this connection.
	SetInteraction(interaction TlsInteraction)
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
	// longer supported and will have no effect. With TLS 1.3, rehandshaking has
	// been removed from the TLS protocol, replaced by separate post-handshake
	// authentication and rekey operations.
	SetRehandshakeMode(mode TlsRehandshakeMode)
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS
	// close notification before the connection is closed. If this is true (the
	// default), then @conn will expect to receive a TLS close notification from
	// its peer before the connection is closed, and will return a
	// G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	//
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data (because
	// the application-level data includes a length field, or is somehow
	// self-delimiting); in this case, the close notify is redundant and
	// sometimes omitted. (TLS 1.1 explicitly allows this; in TLS 1.0 it is
	// technically an error, but often done anyway.) You can use
	// g_tls_connection_set_require_close_notify() to tell @conn to allow an
	// "unannounced" connection close, in which case the close will show up as a
	// 0-length read, as in a non-TLS Connection, and it is up to the
	// application to check that the data has been fully received.
	//
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_io_stream_close() itself on
	// @conn, this will send a close notification regardless of the setting of
	// this property. If you explicitly want to do an unclean close, you can
	// close @conn's Connection:base-io-stream rather than closing @conn itself,
	// but note that this may only be done when no other operations are pending
	// on @conn or the base I/O stream.
	SetRequireCloseNotify(requireCloseNotify bool)
	// SetUseSystemCertdb sets whether @conn uses the system certificate
	// database to verify peer certificates. This is true by default. If set to
	// false, then peer certificate validation will always set the
	// G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// Connection::accept-certificate will always be emitted on client-side
	// connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetUseSystemCertdb(useSystemCertdb bool)
}

type tlsConnection struct {
	ioStream
}

// WrapTlsConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTlsConnection(obj *externglib.Object) TlsConnection {
	return tlsConnection{ioStream{*externglib.Object{obj}}}
}

func marshalTlsConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTlsConnection(obj), nil
}

func (t tlsConnection) EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool

func (t tlsConnection) Certificate() TlsCertificate

func (t tlsConnection) ChannelBindingData(_type TlsChannelBindingType) (data []uint8, ok bool)

func (t tlsConnection) Database() TlsDatabase

func (t tlsConnection) Interaction() TlsInteraction

func (t tlsConnection) NegotiatedProtocol() string

func (t tlsConnection) PeerCertificate() TlsCertificate

func (t tlsConnection) PeerCertificateErrors() TlsCertificateFlags

func (t tlsConnection) RehandshakeMode() TlsRehandshakeMode

func (t tlsConnection) RequireCloseNotify() bool

func (t tlsConnection) UseSystemCertdb() bool

func (t tlsConnection) Handshake(cancellable Cancellable) bool

func (t tlsConnection) HandshakeAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsConnection) HandshakeFinish(result AsyncResult) bool

func (t tlsConnection) SetAdvertisedProtocols(protocols []string)

func (t tlsConnection) SetCertificate(certificate TlsCertificate)

func (t tlsConnection) SetDatabase(database TlsDatabase)

func (t tlsConnection) SetInteraction(interaction TlsInteraction)

func (t tlsConnection) SetRehandshakeMode(mode TlsRehandshakeMode)

func (t tlsConnection) SetRequireCloseNotify(requireCloseNotify bool)

func (t tlsConnection) SetUseSystemCertdb(useSystemCertdb bool)

// TlsDatabase is used to look up certificates and other information from a
// certificate or key store. It is an abstract base class which TLS library
// specific subtypes override.
//
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
type TlsDatabase interface {
	gextras.Objector

	// CreateCertificateHandle: create a handle string for the certificate. The
	// database will only be able to create a handle for certificates that
	// originate from the database. In cases where the database cannot create a
	// handle for a certificate, nil will be returned.
	//
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	CreateCertificateHandle(certificate TlsCertificate) string
	// LookupCertificateForHandle: look up a certificate by its handle.
	//
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a Database object of the
	// same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then nil will be returned.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_for_handle_async() to perform the
	// lookup operation asynchronously.
	LookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) TlsCertificate
	// LookupCertificateForHandleAsync: asynchronously look up a certificate by
	// its handle in the database. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	LookupCertificateForHandleAsync(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupCertificateForHandleFinish: finish an asynchronous lookup of a
	// certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then nil will be returned.
	LookupCertificateForHandleFinish(result AsyncResult) TlsCertificate
	// LookupCertificateIssuer: look up the issuer of @certificate in the
	// database.
	//
	// The Certificate:issuer property of @certificate is not modified, and the
	// two certificates are not hooked into a chain.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_issuer_async() to perform the lookup
	// operation asynchronously.
	LookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) TlsCertificate
	// LookupCertificateIssuerAsync: asynchronously look up the issuer of
	// @certificate in the database. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	LookupCertificateIssuerAsync(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupCertificateIssuerFinish: finish an asynchronous lookup issuer
	// operation. See g_tls_database_lookup_certificate_issuer() for more
	// information.
	LookupCertificateIssuerFinish(result AsyncResult) TlsCertificate
	// LookupCertificatesIssuedBy: look up certificates issued by this issuer in
	// the database.
	//
	// This function can block, use
	// g_tls_database_lookup_certificates_issued_by_async() to perform the
	// lookup operation asynchronously.
	LookupCertificatesIssuedBy(issuerRawDn []uint8, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) *glib.List
	// LookupCertificatesIssuedByAsync: asynchronously look up certificates
	// issued by this issuer in the database. See
	// g_tls_database_lookup_certificates_issued_by() for more information.
	//
	// The database may choose to hold a reference to the issuer byte array for
	// the duration of of this asynchronous operation. The byte array should not
	// be modified during this time.
	LookupCertificatesIssuedByAsync(issuerRawDn []uint8, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupCertificatesIssuedByFinish: finish an asynchronous lookup of
	// certificates. See g_tls_database_lookup_certificates_issued_by() for more
	// information.
	LookupCertificatesIssuedByFinish(result AsyncResult) *glib.List
	// VerifyChain determines the validity of a certificate chain after looking
	// up and adding any missing certificates to the chain.
	//
	// @chain is a chain of Certificate objects each pointing to the next
	// certificate in the chain by its Certificate:issuer property. The chain
	// may initially consist of one or more certificates. After the verification
	// process is complete, @chain may be modified by adding missing
	// certificates, or removing extra certificates. If a certificate anchor was
	// found, then it is added to the @chain.
	//
	// @purpose describes the purpose (or usage) for which the certificate is
	// being used. Typically @purpose will be set to
	// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
	// is being used to authenticate a server (and we are acting as the client).
	//
	// The @identity is used to ensure the server certificate is valid for the
	// expected peer identity. If the identity does not match the certificate,
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If
	// @identity is nil, that bit will never be set in the return value. The
	// peer identity may also be used to check for pinned certificates (trust
	// exceptions) in the database. These may override the normal verification
	// process on a host-by-host basis.
	//
	// Currently there are no @flags, and G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	//
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate the
	// problems found. If the function is unable to determine whether @chain is
	// valid or not (eg, because @cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
	// will be set accordingly. @error is not set when @chain is successfully
	// analyzed but found to be invalid.
	//
	// This function can block, use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	VerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) TlsCertificateFlags
	// VerifyChainAsync: asynchronously determines the validity of a certificate
	// chain after looking up and adding any missing certificates to the chain.
	// See g_tls_database_verify_chain() for more information.
	VerifyChainAsync(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// VerifyChainFinish: finish an asynchronous verify chain operation. See
	// g_tls_database_verify_chain() for more information.
	//
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate the
	// problems found. If the function is unable to determine whether @chain is
	// valid or not (eg, because @cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
	// will be set accordingly. @error is not set when @chain is successfully
	// analyzed but found to be invalid.
	VerifyChainFinish(result AsyncResult) TlsCertificateFlags
}

type tlsDatabase struct {
	*externglib.Object
}

// WrapTlsDatabase wraps a GObject to the right type. It is
// primarily used internally.
func WrapTlsDatabase(obj *externglib.Object) TlsDatabase {
	return tlsDatabase{*externglib.Object{obj}}
}

func marshalTlsDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTlsDatabase(obj), nil
}

func (t tlsDatabase) CreateCertificateHandle(certificate TlsCertificate) string

func (t tlsDatabase) LookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) TlsCertificate

func (t tlsDatabase) LookupCertificateForHandleAsync(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsDatabase) LookupCertificateForHandleFinish(result AsyncResult) TlsCertificate

func (t tlsDatabase) LookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) TlsCertificate

func (t tlsDatabase) LookupCertificateIssuerAsync(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsDatabase) LookupCertificateIssuerFinish(result AsyncResult) TlsCertificate

func (t tlsDatabase) LookupCertificatesIssuedBy(issuerRawDn []uint8, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) *glib.List

func (t tlsDatabase) LookupCertificatesIssuedByAsync(issuerRawDn []uint8, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsDatabase) LookupCertificatesIssuedByFinish(result AsyncResult) *glib.List

func (t tlsDatabase) VerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) TlsCertificateFlags

func (t tlsDatabase) VerifyChainAsync(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsDatabase) VerifyChainFinish(result AsyncResult) TlsCertificateFlags

// TlsInteraction provides a mechanism for the TLS connection and database code
// to interact with the user. It can be used to ask the user for passwords.
//
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction interface {
	gextras.Objector

	// AskPassword: run synchronous interaction to ask the user for a password.
	// In general, g_tls_interaction_invoke_ask_password() should be used
	// instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	AskPassword(password TlsPassword, cancellable Cancellable) TlsInteractionResult
	// AskPasswordAsync: run asynchronous interaction to ask the user for a
	// password. In general, g_tls_interaction_invoke_ask_password() should be
	// used instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	//
	// Certain implementations may not support immediate cancellation.
	AskPasswordAsync(password TlsPassword, cancellable Cancellable, callback AsyncReadyCallback)
	// AskPasswordFinish: complete an ask password user interaction request.
	// This should be once the g_tls_interaction_ask_password_async() completion
	// callback is called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Password passed to
	// g_tls_interaction_ask_password() will have its password filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	AskPasswordFinish(result AsyncResult) TlsInteractionResult
	// InvokeAskPassword: invoke the interaction to ask the user for a password.
	// It invokes this interaction in the main loop, specifically the Context
	// returned by g_main_context_get_thread_default() when the interaction is
	// created. This is called by called by Connection or Database to ask the
	// user for a password.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeAskPassword(password TlsPassword, cancellable Cancellable) TlsInteractionResult
	// InvokeRequestCertificate: invoke the interaction to ask the user to
	// choose a certificate to use with the connection. It invokes this
	// interaction in the main loop, specifically the Context returned by
	// g_main_context_get_thread_default() when the interaction is created. This
	// is called by called by Connection when the peer requests a certificate
	// during the handshake.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which may or
	// may not abort the TLS connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) TlsInteractionResult
	// RequestCertificate: run synchronous interaction to ask the user to choose
	// a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which will
	// usually abort the TLS connection.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
	// g_tls_interaction_request_certificate() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	RequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) TlsInteractionResult
	// RequestCertificateAsync: run asynchronous interaction to ask the user for
	// a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere. @callback
	// will be called when the operation completes. Alternatively the user may
	// abort this certificate request, which will usually abort the TLS
	// connection.
	RequestCertificateAsync(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// RequestCertificateFinish: complete a request certificate user interaction
	// request. This should be once the
	// g_tls_interaction_request_certificate_async() completion callback is
	// called.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
	// g_tls_interaction_request_certificate_async() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code.
	RequestCertificateFinish(result AsyncResult) TlsInteractionResult
}

type tlsInteraction struct {
	*externglib.Object
}

// WrapTlsInteraction wraps a GObject to the right type. It is
// primarily used internally.
func WrapTlsInteraction(obj *externglib.Object) TlsInteraction {
	return tlsInteraction{*externglib.Object{obj}}
}

func marshalTlsInteraction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTlsInteraction(obj), nil
}

func (t tlsInteraction) AskPassword(password TlsPassword, cancellable Cancellable) TlsInteractionResult

func (t tlsInteraction) AskPasswordAsync(password TlsPassword, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsInteraction) AskPasswordFinish(result AsyncResult) TlsInteractionResult

func (t tlsInteraction) InvokeAskPassword(password TlsPassword, cancellable Cancellable) TlsInteractionResult

func (t tlsInteraction) InvokeRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) TlsInteractionResult

func (t tlsInteraction) RequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) TlsInteractionResult

func (t tlsInteraction) RequestCertificateAsync(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback)

func (t tlsInteraction) RequestCertificateFinish(result AsyncResult) TlsInteractionResult

// TlsPassword holds a password used in TLS.
type TlsPassword interface {
	gextras.Objector

	// Description: get a description string about what the password will be
	// used for.
	Description() string
	// Flags: get flags about the password.
	Flags() TlsPasswordFlags
	// Value: get the password value. If @length is not nil then it will be
	// filled in with the length of the password value. (Note that the password
	// value is not nul-terminated, so you can only pass nil for @length in
	// contexts where you know the password will have a certain fixed length.)
	Value(length uint) uint8
	// Warning: get a user readable translated warning. Usually this warning is
	// a representation of the password flags returned from
	// g_tls_password_get_flags().
	Warning() string
	// SetDescription: set a description string about what the password will be
	// used for.
	SetDescription(description string)
	// SetFlags: set flags about the password.
	SetFlags(flags TlsPasswordFlags)
	// SetValue: set the value for this password. The @value will be copied by
	// the password object.
	//
	// Specify the @length, for a non-nul-terminated password. Pass -1 as
	// @length if using a nul-terminated password, and @length will be
	// calculated automatically. (Note that the terminating nul is not
	// considered part of the password in this case.)
	SetValue(value []uint8)
	// SetValueFull: provide the value for this password.
	//
	// The @value will be owned by the password object, and later freed using
	// the @destroy function callback.
	//
	// Specify the @length, for a non-nul-terminated password. Pass -1 as
	// @length if using a nul-terminated password, and @length will be
	// calculated automatically. (Note that the terminating nul is not
	// considered part of the password in this case.)
	SetValueFull(value []uint8)
	// SetWarning: set a user readable translated warning. Usually this warning
	// is a representation of the password flags returned from
	// g_tls_password_get_flags().
	SetWarning(warning string)
}

type tlsPassword struct {
	*externglib.Object
}

// WrapTlsPassword wraps a GObject to the right type. It is
// primarily used internally.
func WrapTlsPassword(obj *externglib.Object) TlsPassword {
	return tlsPassword{*externglib.Object{obj}}
}

func marshalTlsPassword(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTlsPassword(obj), nil
}

func NewTlsPassword(flags TlsPasswordFlags, description string) TlsPassword

func (t tlsPassword) Description() string

func (t tlsPassword) Flags() TlsPasswordFlags

func (t tlsPassword) Value(length uint) uint8

func (t tlsPassword) Warning() string

func (t tlsPassword) SetDescription(description string)

func (t tlsPassword) SetFlags(flags TlsPasswordFlags)

func (t tlsPassword) SetValue(value []uint8)

func (t tlsPassword) SetValueFull(value []uint8)

func (t tlsPassword) SetWarning(warning string)

// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
//
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
//
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixConnection interface {
	SocketConnection

	// ReceiveCredentials receives credentials from the sending end of the
	// connection. The sending end has to call
	// g_unix_connection_send_credentials() (or similar) for this to work.
	//
	// As well as reading the credentials this also reads (and discards) a
	// single byte from the stream, as this is required for credentials passing
	// to work on some implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	ReceiveCredentials(cancellable Cancellable) Credentials
	// ReceiveCredentialsAsync: asynchronously receive credentials.
	//
	// For more details, see g_unix_connection_receive_credentials() which is
	// the synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_unix_connection_receive_credentials_finish() to get the result of
	// the operation.
	ReceiveCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// ReceiveCredentialsFinish finishes an asynchronous receive credentials
	// operation started with g_unix_connection_receive_credentials_async().
	ReceiveCredentialsFinish(result AsyncResult) Credentials
	// ReceiveFd receives a file descriptor from the sending end of the
	// connection. The sending end has to call g_unix_connection_send_fd() for
	// this to work.
	//
	// As well as reading the fd this also reads a single byte from the stream,
	// as this is required for fd passing to work on some implementations.
	ReceiveFd(cancellable Cancellable) int
	// SendCredentials passes the credentials of the current user the receiving
	// side of the connection. The receiving end has to call
	// g_unix_connection_receive_credentials() (or similar) to accept the
	// credentials.
	//
	// As well as sending the credentials this also writes a single NUL byte to
	// the stream, as this is required for credentials passing to work on some
	// implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	SendCredentials(cancellable Cancellable) bool
	// SendCredentialsAsync: asynchronously send credentials.
	//
	// For more details, see g_unix_connection_send_credentials() which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_unix_connection_send_credentials_finish() to get the result of the
	// operation.
	SendCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// SendCredentialsFinish finishes an asynchronous send credentials operation
	// started with g_unix_connection_send_credentials_async().
	SendCredentialsFinish(result AsyncResult) bool
	// SendFd passes a file descriptor to the receiving side of the connection.
	// The receiving end has to call g_unix_connection_receive_fd() to accept
	// the file descriptor.
	//
	// As well as sending the fd this also writes a single byte to the stream,
	// as this is required for fd passing to work on some implementations.
	SendFd(fd int, cancellable Cancellable) bool
}

type unixConnection struct {
	socketConnection
}

// WrapUnixConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixConnection(obj *externglib.Object) UnixConnection {
	return unixConnection{socketConnection{ioStream{*externglib.Object{obj}}}}
}

func marshalUnixConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixConnection(obj), nil
}

func (u unixConnection) ReceiveCredentials(cancellable Cancellable) Credentials

func (u unixConnection) ReceiveCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (u unixConnection) ReceiveCredentialsFinish(result AsyncResult) Credentials

func (u unixConnection) ReceiveFd(cancellable Cancellable) int

func (u unixConnection) SendCredentials(cancellable Cancellable) bool

func (u unixConnection) SendCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)

func (u unixConnection) SendCredentialsFinish(result AsyncResult) bool

func (u unixConnection) SendFd(fd int, cancellable Cancellable) bool

// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
type UnixCredentialsMessage interface {
	SocketControlMessage

	// Credentials gets the credentials stored in @message.
	Credentials() Credentials
}

type unixCredentialsMessage struct {
	socketControlMessage
}

// WrapUnixCredentialsMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixCredentialsMessage(obj *externglib.Object) UnixCredentialsMessage {
	return unixCredentialsMessage{socketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixCredentialsMessage(obj), nil
}

func NewUnixCredentialsMessage() UnixCredentialsMessage

func NewUnixCredentialsMessageWithCredentials(credentials Credentials) UnixCredentialsMessage

func (u unixCredentialsMessage) Credentials() Credentials

// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
//
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
type UnixFDList interface {
	gextras.Objector

	// Append adds a file descriptor to @list.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @list will be closed when @list is
	// finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	//
	// The index of the file descriptor in the list is returned. If you use this
	// index with g_unix_fd_list_get() then you will receive back a duplicated
	// copy of the same file descriptor.
	Append(fd int) int
	// Get gets a file descriptor out of @list.
	//
	// @index_ specifies the index of the file descriptor to get. It is a
	// programmer error for @index_ to be out of range; see
	// g_unix_fd_list_get_length().
	//
	// The file descriptor is duplicated using dup() and set as close-on-exec
	// before being returned. You must call close() on it when you are done.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	Get(index_ int) int
	// Length gets the length of @list (ie: the number of file descriptors
	// contained within).
	Length() int
	// PeekFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors remain the property of @list. The caller
	// must not close them and must not free the array. The array is valid only
	// until @list is changed in any way.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @list, an empty array is returned.
	PeekFds() (length int, gints []int)
	// StealFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors are no longer contained in @list.
	// Further calls will return an empty list (unless more descriptors have
	// been added).
	//
	// The return result of this function must be freed with g_free(). The
	// caller is also responsible for closing all of the file descriptors. The
	// file descriptors in the array are set to close-on-exec.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @list, an empty array is returned.
	StealFds() (length int, gints []int)
}

type unixFDList struct {
	*externglib.Object
}

// WrapUnixFDList wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDList(obj *externglib.Object) UnixFDList {
	return unixFDList{*externglib.Object{obj}}
}

func marshalUnixFDList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDList(obj), nil
}

func NewUnixFDList() UnixFDList

func NewUnixFDListFromArray(fds []int) UnixFDList

func (u unixFDList) Append(fd int) int

func (u unixFDList) Get(index_ int) int

func (u unixFDList) Length() int

func (u unixFDList) PeekFds() (length int, gints []int)

func (u unixFDList) StealFds() (length int, gints []int)

// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
//
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixFDMessage interface {
	SocketControlMessage

	// AppendFd adds a file descriptor to @message.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @message will be closed when
	// @message is finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	AppendFd(fd int) bool
	// FdList gets the FDList contained in @message. This function does not
	// return a reference to the caller, but the returned list is valid for the
	// lifetime of @message.
	FdList() UnixFDList
	// StealFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors are no longer contained in @message.
	// Further calls will return an empty list (unless more descriptors have
	// been added).
	//
	// The return result of this function must be freed with g_free(). The
	// caller is also responsible for closing all of the file descriptors.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @message, an empty array is returned.
	StealFds() (length int, gints []int)
}

type unixFDMessage struct {
	socketControlMessage
}

// WrapUnixFDMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDMessage(obj *externglib.Object) UnixFDMessage {
	return unixFDMessage{socketControlMessage{*externglib.Object{obj}}}
}

func marshalUnixFDMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDMessage(obj), nil
}

func NewUnixFDMessage() UnixFDMessage

func NewUnixFDMessageWithFdList(fdList UnixFDList) UnixFDMessage

func (u unixFDMessage) AppendFd(fd int) bool

func (u unixFDMessage) FdList() UnixFDList

func (u unixFDMessage) StealFds() (length int, gints []int)

// UnixInputStream implements Stream for reading from a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixInputStream interface {
	InputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream reads from.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

type unixInputStream struct {
	inputStream
}

// WrapUnixInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixInputStream(obj *externglib.Object) UnixInputStream {
	return unixInputStream{inputStream{*externglib.Object{obj}}}
}

func marshalUnixInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixInputStream(obj), nil
}

func NewUnixInputStream(fd int, closeFd bool) UnixInputStream

func (u unixInputStream) CloseFd() bool

func (u unixInputStream) Fd() int

func (u unixInputStream) SetCloseFd(closeFd bool)

// UnixMountMonitor watches Mounts for changes.
type UnixMountMonitor interface {
	gextras.Objector

	// SetRateLimit: this function does nothing.
	//
	// Before 2.44, this was a partially-effective way of controlling the rate
	// at which events would be reported under some uncommon circumstances.
	// Since @mount_monitor is a singleton, it also meant that calling this
	// function would have side effects for other users of the monitor.
	SetRateLimit(limitMsec int)
}

type unixMountMonitor struct {
	*externglib.Object
}

// WrapUnixMountMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixMountMonitor(obj *externglib.Object) UnixMountMonitor {
	return unixMountMonitor{*externglib.Object{obj}}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixMountMonitor(obj), nil
}

func NewUnixMountMonitor() UnixMountMonitor

func (u unixMountMonitor) SetRateLimit(limitMsec int)

// UnixOutputStream implements Stream for writing to a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixOutputStream interface {
	OutputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream writes to.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

type unixOutputStream struct {
	outputStream
}

// WrapUnixOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixOutputStream(obj *externglib.Object) UnixOutputStream {
	return unixOutputStream{outputStream{*externglib.Object{obj}}}
}

func marshalUnixOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixOutputStream(obj), nil
}

func NewUnixOutputStream(fd int, closeFd bool) UnixOutputStream

func (u unixOutputStream) CloseFd() bool

func (u unixOutputStream) Fd() int

func (u unixOutputStream) SetCloseFd(closeFd bool)

// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
//
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
//
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixSocketAddress interface {
	SocketAddress

	// AddressType gets @address's type.
	AddressType() UnixSocketAddressType
	// IsAbstract tests if @address is abstract.
	IsAbstract() bool
	// Path gets @address's path, or for abstract sockets the "name".
	//
	// Guaranteed to be zero-terminated, but an abstract socket may contain
	// embedded zeros, and thus you should use
	// g_unix_socket_address_get_path_len() to get the true length of this
	// string.
	Path() string
	// PathLen gets the length of @address's path.
	//
	// For details, see g_unix_socket_address_get_path().
	PathLen() uint
}

type unixSocketAddress struct {
	socketAddress
}

// WrapUnixSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixSocketAddress(obj *externglib.Object) UnixSocketAddress {
	return unixSocketAddress{socketAddress{*externglib.Object{obj}}}
}

func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixSocketAddress(obj), nil
}

func NewUnixSocketAddress(path string) UnixSocketAddress

func NewUnixSocketAddressAbstract(path []byte) UnixSocketAddress

func NewUnixSocketAddressWithType(path []byte, _type UnixSocketAddressType) UnixSocketAddress

func (u unixSocketAddress) AddressType() UnixSocketAddressType

func (u unixSocketAddress) IsAbstract() bool

func (u unixSocketAddress) Path() string

func (u unixSocketAddress) PathLen() uint

// Vfs: entry point for using GIO functionality.
type Vfs interface {
	gextras.Objector

	// FileForPath gets a #GFile for @path.
	FileForPath(path string) File
	// FileForURI gets a #GFile for @uri.
	//
	// This operation never fails, but the returned object might not support any
	// I/O operation if the URI is malformed or if the URI scheme is not
	// supported.
	FileForURI(uri string) File
	// SupportedURISchemes gets a list of URI schemes supported by @vfs.
	SupportedURISchemes() []string
	// IsActive checks if the VFS is active.
	IsActive() bool
	// ParseName: this operation never fails, but the returned object might not
	// support any I/O operations if the @parse_name cannot be parsed by the
	// #GVfs module.
	ParseName(parseName string) File
	// RegisterURIScheme registers @uri_func and @parse_name_func as the #GFile
	// URI and parse name lookup functions for URIs with a scheme matching
	// @scheme. Note that @scheme is registered only within the running
	// application, as opposed to desktop-wide as it happens with GVfs backends.
	//
	// When a #GFile is requested with an URI containing @scheme (e.g. through
	// g_file_new_for_uri()), @uri_func will be called to allow a custom
	// constructor. The implementation of @uri_func should not be blocking, and
	// must not call g_vfs_register_uri_scheme() or
	// g_vfs_unregister_uri_scheme().
	//
	// When g_file_parse_name() is called with a parse name obtained from such
	// file, @parse_name_func will be called to allow the #GFile to be created
	// again. In that case, it's responsibility of @parse_name_func to make sure
	// the parse name matches what the custom #GFile implementation returned
	// when g_file_get_parse_name() was previously called. The implementation of
	// @parse_name_func should not be blocking, and must not call
	// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
	//
	// It's an error to call this function twice with the same scheme. To
	// unregister a custom URI scheme, use g_vfs_unregister_uri_scheme().
	RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool
	// UnregisterURIScheme unregisters the URI handler for @scheme previously
	// registered with g_vfs_register_uri_scheme().
	UnregisterURIScheme(scheme string) bool
}

type vfs struct {
	*externglib.Object
}

// WrapVfs wraps a GObject to the right type. It is
// primarily used internally.
func WrapVfs(obj *externglib.Object) Vfs {
	return vfs{*externglib.Object{obj}}
}

func marshalVfs(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVfs(obj), nil
}

func (v vfs) FileForPath(path string) File

func (v vfs) FileForURI(uri string) File

func (v vfs) SupportedURISchemes() []string

func (v vfs) IsActive() bool

func (v vfs) ParseName(parseName string) File

func (v vfs) RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool

func (v vfs) UnregisterURIScheme(scheme string) bool

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor interface {
	gextras.Objector

	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	ConnectedDrives() *glib.List
	// MountForUuid finds a #GMount object by its UUID (see g_mount_get_uuid())
	MountForUuid(uuid string) Mount
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	Mounts() *glib.List
	// VolumeForUuid finds a #GVolume object by its UUID (see
	// g_volume_get_uuid())
	VolumeForUuid(uuid string) Volume
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	Volumes() *glib.List
}

type volumeMonitor struct {
	*externglib.Object
}

// WrapVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeMonitor(obj *externglib.Object) VolumeMonitor {
	return volumeMonitor{*externglib.Object{obj}}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeMonitor(obj), nil
}

func (v volumeMonitor) ConnectedDrives() *glib.List

func (v volumeMonitor) MountForUuid(uuid string) Mount

func (v volumeMonitor) Mounts() *glib.List

func (v volumeMonitor) VolumeForUuid(uuid string) Volume

func (v volumeMonitor) Volumes() *glib.List

// ZlibCompressor: zlib decompression
type ZlibCompressor interface {
	gextras.Objector

	// FileInfo returns the Compressor:file-info property.
	FileInfo() FileInfo
	// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
	// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
	// used to set the file name and modification time in the GZIP header of the
	// compressed data.
	//
	// Note: it is an error to call this function while a compression is in
	// progress; it may only be called immediately after creation of
	// @compressor, or after resetting it with g_converter_reset().
	SetFileInfo(fileInfo FileInfo)
}

type zlibCompressor struct {
	*externglib.Object
}

// WrapZlibCompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibCompressor(obj *externglib.Object) ZlibCompressor {
	return zlibCompressor{*externglib.Object{obj}}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibCompressor(obj), nil
}

func NewZlibCompressor(format ZlibCompressorFormat, level int) ZlibCompressor

func (z zlibCompressor) FileInfo() FileInfo

func (z zlibCompressor) SetFileInfo(fileInfo FileInfo)

// ZlibDecompressor: zlib decompression
type ZlibDecompressor interface {
	gextras.Objector

	// FileInfo retrieves the Info constructed from the GZIP header data of
	// compressed data processed by @compressor, or nil if @decompressor's
	// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
	// header data was not fully processed yet, or it not present in the data
	// stream at all.
	FileInfo() FileInfo
}

type zlibDecompressor struct {
	*externglib.Object
}

// WrapZlibDecompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibDecompressor(obj *externglib.Object) ZlibDecompressor {
	return zlibDecompressor{*externglib.Object{obj}}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibDecompressor(obj), nil
}

func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor

func (z zlibDecompressor) FileInfo() FileInfo
