// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
//
// // extern void callbackDelete(gpointer);
// extern void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer)
// extern void gotk4_BusAcquiredCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameAcquiredCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameAppearedCallback(GDBusConnection*, const gchar*, const gchar*, gpointer)
// extern void gotk4_BusNameLostCallback(GDBusConnection*, const gchar*, gpointer)
// extern void gotk4_BusNameVanishedCallback(GDBusConnection*, const gchar*, gpointer)
// extern gboolean gotk4_CancellableSourceFunc(GCancellable*, gpointer)
// extern GVariant* gotk4_DBusInterfaceGetPropertyFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GError**, gpointer)
// extern void gotk4_DBusInterfaceMethodCallFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, GDBusMethodInvocation*, gpointer)
// extern gboolean gotk4_DBusInterfaceSetPropertyFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, GError**, gpointer)
// extern GDBusMessage* gotk4_DBusMessageFilterFunction(GDBusConnection*, GDBusMessage*, gboolean, gpointer)
// extern GType gotk4_DBusProxyTypeFunc(GDBusObjectManagerClient*, const gchar*, const gchar*, gpointer)
// extern void gotk4_DBusSignalCallback(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, GVariant*, gpointer)
// extern const GDBusInterfaceVTable* gotk4_DBusSubtreeDispatchFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, const gchar*, gpointer*, gpointer)
// extern gchar** gotk4_DBusSubtreeEnumerateFunc(GDBusConnection*, const gchar*, const gchar*, gpointer)
// extern GDBusInterfaceInfo** gotk4_DBusSubtreeIntrospectFunc(GDBusConnection*, const gchar*, const gchar*, const gchar*, gpointer)
// extern gboolean gotk4_DatagramBasedSourceFunc(GDatagramBased*, GIOCondition, gpointer)
// extern void gotk4_DesktopAppLaunchCallback(GDesktopAppInfo*, GPid, gpointer)
// extern void gotk4_FileMeasureProgressCallback(gboolean, guint64, guint64, guint64, gpointer)
// extern void gotk4_FileProgressCallback(goffset, goffset, gpointer)
// extern gboolean gotk4_FileReadMoreCallback(const char*, goffset, gpointer)
// extern gboolean gotk4_IOSchedulerJobFunc(GIOSchedulerJob*, GCancellable*, gpointer)
// extern gboolean gotk4_PollableSourceFunc(GObject*, gpointer)
// extern gboolean gotk4_SettingsBindGetMapping(GValue*, GVariant*, gpointer)
// extern GVariant* gotk4_SettingsBindSetMapping(const GValue*, const GVariantType*, gpointer)
// extern gboolean gotk4_SettingsGetMapping(GVariant*, gpointer*, gpointer)
// extern gboolean gotk4_SocketSourceFunc(GSocket*, GIOCondition, gpointer)
// extern GFile* gotk4_VfsFileLookupFunc(GVfs*, const char*, gpointer)
import "C"

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTLSAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTLSCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTLSChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTLSChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTLSDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTLSError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTLSInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTLSRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},

		// Records
		// Skipped ActionEntry.
		// Skipped ActionGroupInterface.
		// Skipped ActionInterface.
		// Skipped ActionMapInterface.
		// Skipped AppInfoIface.
		// Skipped AppLaunchContextClass.
		// Skipped AppLaunchContextPrivate.
		// Skipped ApplicationClass.
		// Skipped ApplicationCommandLineClass.
		// Skipped ApplicationCommandLinePrivate.
		// Skipped ApplicationPrivate.
		// Skipped AsyncInitableIface.
		// Skipped AsyncResultIface.
		// Skipped BufferedInputStreamClass.
		// Skipped BufferedInputStreamPrivate.
		// Skipped BufferedOutputStreamClass.
		// Skipped BufferedOutputStreamPrivate.
		// Skipped CancellableClass.
		// Skipped CancellablePrivate.
		// Skipped CharsetConverterClass.
		// Skipped ConverterIface.
		// Skipped ConverterInputStreamClass.
		// Skipped ConverterInputStreamPrivate.
		// Skipped ConverterOutputStreamClass.
		// Skipped ConverterOutputStreamPrivate.
		// Skipped CredentialsClass.
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		// Skipped DBusErrorEntry.
		// Skipped DBusInterfaceIface.
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		// Skipped DBusInterfaceSkeletonClass.
		// Skipped DBusInterfaceSkeletonPrivate.
		// Skipped DBusInterfaceVTable.
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		// Skipped DBusObjectIface.
		// Skipped DBusObjectManagerClientClass.
		// Skipped DBusObjectManagerClientPrivate.
		// Skipped DBusObjectManagerIface.
		// Skipped DBusObjectManagerServerClass.
		// Skipped DBusObjectManagerServerPrivate.
		// Skipped DBusObjectProxyClass.
		// Skipped DBusObjectProxyPrivate.
		// Skipped DBusObjectSkeletonClass.
		// Skipped DBusObjectSkeletonPrivate.
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		// Skipped DBusProxyClass.
		// Skipped DBusProxyPrivate.
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
		// Skipped DBusSubtreeVTable.
		// Skipped DataInputStreamClass.
		// Skipped DataInputStreamPrivate.
		// Skipped DataOutputStreamClass.
		// Skipped DataOutputStreamPrivate.
		// Skipped DatagramBasedInterface.
		// Skipped DesktopAppInfoClass.
		// Skipped DesktopAppInfoLookupIface.
		// Skipped DriveIface.
		// Skipped DtlsClientConnectionInterface.
		// Skipped DtlsConnectionInterface.
		// Skipped DtlsServerConnectionInterface.
		// Skipped EmblemClass.
		// Skipped EmblemedIconClass.
		// Skipped EmblemedIconPrivate.
		// Skipped FileAttributeInfo.
		{T: externglib.Type(C.g_file_attribute_info_list_get_type()), F: marshalFileAttributeInfoList},
		{T: externglib.Type(C.g_file_attribute_matcher_get_type()), F: marshalFileAttributeMatcher},
		// Skipped FileDescriptorBasedIface.
		// Skipped FileEnumeratorClass.
		// Skipped FileEnumeratorPrivate.
		// Skipped FileIOStreamClass.
		// Skipped FileIOStreamPrivate.
		// Skipped FileIconClass.
		// Skipped FileIface.
		// Skipped FileInfoClass.
		// Skipped FileInputStreamClass.
		// Skipped FileInputStreamPrivate.
		// Skipped FileMonitorClass.
		// Skipped FileMonitorPrivate.
		// Skipped FileOutputStreamClass.
		// Skipped FileOutputStreamPrivate.
		// Skipped FilenameCompleterClass.
		// Skipped FilterInputStreamClass.
		// Skipped FilterOutputStreamClass.
		// Skipped IOExtension.
		// Skipped IOExtensionPoint.
		// Skipped IOModuleClass.
		// Skipped IOModuleScope.
		// Skipped IOSchedulerJob.
		// Skipped IOStreamAdapter.
		// Skipped IOStreamClass.
		// Skipped IOStreamPrivate.
		// Skipped IconIface.
		// Skipped InetAddressClass.
		// Skipped InetAddressMaskClass.
		// Skipped InetAddressMaskPrivate.
		// Skipped InetAddressPrivate.
		// Skipped InetSocketAddressClass.
		// Skipped InetSocketAddressPrivate.
		// Skipped InitableIface.
		// Skipped InputMessage.
		// Skipped InputStreamClass.
		// Skipped InputStreamPrivate.
		// Skipped InputVector.
		// Skipped ListModelInterface.
		// Skipped ListStoreClass.
		// Skipped LoadableIconIface.
		// Skipped MemoryInputStreamClass.
		// Skipped MemoryInputStreamPrivate.
		// Skipped MemoryMonitorInterface.
		// Skipped MemoryOutputStreamClass.
		// Skipped MemoryOutputStreamPrivate.
		// Skipped MenuAttributeIterClass.
		// Skipped MenuAttributeIterPrivate.
		// Skipped MenuLinkIterClass.
		// Skipped MenuLinkIterPrivate.
		// Skipped MenuModelClass.
		// Skipped MenuModelPrivate.
		// Skipped MountIface.
		// Skipped MountOperationClass.
		// Skipped MountOperationPrivate.
		// Skipped NativeSocketAddressClass.
		// Skipped NativeSocketAddressPrivate.
		// Skipped NativeVolumeMonitorClass.
		// Skipped NetworkAddressClass.
		// Skipped NetworkAddressPrivate.
		// Skipped NetworkMonitorInterface.
		// Skipped NetworkServiceClass.
		// Skipped NetworkServicePrivate.
		// Skipped OutputMessage.
		// Skipped OutputStreamClass.
		// Skipped OutputStreamPrivate.
		// Skipped OutputVector.
		// Skipped PermissionClass.
		// Skipped PermissionPrivate.
		// Skipped PollableInputStreamInterface.
		// Skipped PollableOutputStreamInterface.
		// Skipped ProxyAddressClass.
		// Skipped ProxyAddressEnumeratorClass.
		// Skipped ProxyAddressEnumeratorPrivate.
		// Skipped ProxyAddressPrivate.
		// Skipped ProxyInterface.
		// Skipped ProxyResolverInterface.
		// Skipped RemoteActionGroupInterface.
		// Skipped ResolverClass.
		// Skipped ResolverPrivate.
		{T: externglib.Type(C.g_resource_get_type()), F: marshalResource},
		// Skipped SeekableIface.
		// Skipped SettingsBackendClass.
		// Skipped SettingsBackendPrivate.
		// Skipped SettingsClass.
		// Skipped SettingsPrivate.
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
		// Skipped SimpleActionGroupClass.
		// Skipped SimpleActionGroupPrivate.
		// Skipped SimpleAsyncResultClass.
		// Skipped SimpleProxyResolverClass.
		// Skipped SimpleProxyResolverPrivate.
		// Skipped SocketAddressClass.
		// Skipped SocketAddressEnumeratorClass.
		// Skipped SocketClass.
		// Skipped SocketClientClass.
		// Skipped SocketClientPrivate.
		// Skipped SocketConnectableIface.
		// Skipped SocketConnectionClass.
		// Skipped SocketConnectionPrivate.
		// Skipped SocketControlMessageClass.
		// Skipped SocketControlMessagePrivate.
		// Skipped SocketListenerClass.
		// Skipped SocketListenerPrivate.
		// Skipped SocketPrivate.
		// Skipped SocketServiceClass.
		// Skipped SocketServicePrivate.
		{T: externglib.Type(C.g_srv_target_get_type()), F: marshalSrvTarget},
		// Skipped StaticResource.
		// Skipped TaskClass.
		// Skipped TcpConnectionClass.
		// Skipped TcpConnectionPrivate.
		// Skipped TcpWrapperConnectionClass.
		// Skipped TcpWrapperConnectionPrivate.
		// Skipped ThemedIconClass.
		// Skipped ThreadedSocketServiceClass.
		// Skipped ThreadedSocketServicePrivate.
		// Skipped TlsBackendInterface.
		// Skipped TlsCertificateClass.
		// Skipped TlsCertificatePrivate.
		// Skipped TlsClientConnectionInterface.
		// Skipped TlsConnectionClass.
		// Skipped TlsConnectionPrivate.
		// Skipped TlsDatabaseClass.
		// Skipped TlsDatabasePrivate.
		// Skipped TlsFileDatabaseInterface.
		// Skipped TlsInteractionClass.
		// Skipped TlsInteractionPrivate.
		// Skipped TlsPasswordClass.
		// Skipped TlsPasswordPrivate.
		// Skipped TlsServerConnectionInterface.
		// Skipped UnixConnectionClass.
		// Skipped UnixConnectionPrivate.
		// Skipped UnixCredentialsMessageClass.
		// Skipped UnixCredentialsMessagePrivate.
		// Skipped UnixFDListClass.
		// Skipped UnixFDListPrivate.
		// Skipped UnixFDMessageClass.
		// Skipped UnixFDMessagePrivate.
		// Skipped UnixInputStreamClass.
		// Skipped UnixInputStreamPrivate.
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		// Skipped UnixMountMonitorClass.
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
		// Skipped UnixOutputStreamClass.
		// Skipped UnixOutputStreamPrivate.
		// Skipped UnixSocketAddressClass.
		// Skipped UnixSocketAddressPrivate.
		// Skipped VfsClass.
		// Skipped VolumeIface.
		// Skipped VolumeMonitorClass.
		// Skipped ZlibCompressorClass.
		// Skipped ZlibDecompressorClass.

		// Classes
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
		{T: externglib.Type(C.g_application_command_line_get_type()), F: marshalApplicationCommandLine},
		{T: externglib.Type(C.g_buffered_input_stream_get_type()), F: marshalBufferedInputStream},
		{T: externglib.Type(C.g_buffered_output_stream_get_type()), F: marshalBufferedOutputStream},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
		{T: externglib.Type(C.g_charset_converter_get_type()), F: marshalCharsetConverter},
		{T: externglib.Type(C.g_converter_input_stream_get_type()), F: marshalConverterInputStream},
		{T: externglib.Type(C.g_converter_output_stream_get_type()), F: marshalConverterOutputStream},
		{T: externglib.Type(C.g_credentials_get_type()), F: marshalCredentials},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_interface_skeleton_get_type()), F: marshalDBusInterfaceSkeleton},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_object_manager_client_get_type()), F: marshalDBusObjectManagerClient},
		{T: externglib.Type(C.g_dbus_object_manager_server_get_type()), F: marshalDBusObjectManagerServer},
		{T: externglib.Type(C.g_dbus_object_proxy_get_type()), F: marshalDBusObjectProxy},
		{T: externglib.Type(C.g_dbus_object_skeleton_get_type()), F: marshalDBusObjectSkeleton},
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProxy},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_data_input_stream_get_type()), F: marshalDataInputStream},
		{T: externglib.Type(C.g_data_output_stream_get_type()), F: marshalDataOutputStream},
		{T: externglib.Type(C.g_desktop_app_info_get_type()), F: marshalDesktopAppInfo},
		{T: externglib.Type(C.g_emblem_get_type()), F: marshalEmblem},
		{T: externglib.Type(C.g_emblemed_icon_get_type()), F: marshalEmblemedIcon},
		{T: externglib.Type(C.g_file_enumerator_get_type()), F: marshalFileEnumerator},
		{T: externglib.Type(C.g_file_io_stream_get_type()), F: marshalFileIOStream},
		{T: externglib.Type(C.g_file_icon_get_type()), F: marshalFileIcon},
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
		{T: externglib.Type(C.g_file_input_stream_get_type()), F: marshalFileInputStream},
		{T: externglib.Type(C.g_file_monitor_get_type()), F: marshalFileMonitor},
		{T: externglib.Type(C.g_file_output_stream_get_type()), F: marshalFileOutputStream},
		{T: externglib.Type(C.g_filename_completer_get_type()), F: marshalFilenameCompleter},
		{T: externglib.Type(C.g_filter_input_stream_get_type()), F: marshalFilterInputStream},
		{T: externglib.Type(C.g_filter_output_stream_get_type()), F: marshalFilterOutputStream},
		// Skipped IOModule.
		{T: externglib.Type(C.g_io_stream_get_type()), F: marshalIOStream},
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
		{T: externglib.Type(C.g_inet_address_mask_get_type()), F: marshalInetAddressMask},
		{T: externglib.Type(C.g_inet_socket_address_get_type()), F: marshalInetSocketAddress},
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
		{T: externglib.Type(C.g_list_store_get_type()), F: marshalListStore},
		{T: externglib.Type(C.g_memory_input_stream_get_type()), F: marshalMemoryInputStream},
		{T: externglib.Type(C.g_memory_output_stream_get_type()), F: marshalMemoryOutputStream},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
		{T: externglib.Type(C.g_mount_operation_get_type()), F: marshalMountOperation},
		{T: externglib.Type(C.g_native_socket_address_get_type()), F: marshalNativeSocketAddress},
		{T: externglib.Type(C.g_native_volume_monitor_get_type()), F: marshalNativeVolumeMonitor},
		{T: externglib.Type(C.g_network_address_get_type()), F: marshalNetworkAddress},
		{T: externglib.Type(C.g_network_service_get_type()), F: marshalNetworkService},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
		{T: externglib.Type(C.g_permission_get_type()), F: marshalPermission},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_proxy_address_get_type()), F: marshalProxyAddress},
		{T: externglib.Type(C.g_proxy_address_enumerator_get_type()), F: marshalProxyAddressEnumerator},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolver},
		{T: externglib.Type(C.g_settings_get_type()), F: marshalSettings},
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_action_group_get_type()), F: marshalSimpleActionGroup},
		{T: externglib.Type(C.g_simple_async_result_get_type()), F: marshalSimpleAsyncResult},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_simple_proxy_resolver_get_type()), F: marshalSimpleProxyResolver},
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
		{T: externglib.Type(C.g_socket_address_get_type()), F: marshalSocketAddress},
		{T: externglib.Type(C.g_socket_address_enumerator_get_type()), F: marshalSocketAddressEnumerator},
		{T: externglib.Type(C.g_socket_client_get_type()), F: marshalSocketClient},
		{T: externglib.Type(C.g_socket_connection_get_type()), F: marshalSocketConnection},
		{T: externglib.Type(C.g_socket_control_message_get_type()), F: marshalSocketControlMessage},
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTcpConnection},
		{T: externglib.Type(C.g_tcp_wrapper_connection_get_type()), F: marshalTcpWrapperConnection},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
		{T: externglib.Type(C.g_themed_icon_get_type()), F: marshalThemedIcon},
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
		{T: externglib.Type(C.g_tls_certificate_get_type()), F: marshalTLSCertificate},
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTLSConnection},
		{T: externglib.Type(C.g_tls_database_get_type()), F: marshalTLSDatabase},
		{T: externglib.Type(C.g_tls_interaction_get_type()), F: marshalTLSInteraction},
		{T: externglib.Type(C.g_tls_password_get_type()), F: marshalTLSPassword},
		{T: externglib.Type(C.g_unix_connection_get_type()), F: marshalUnixConnection},
		{T: externglib.Type(C.g_unix_credentials_message_get_type()), F: marshalUnixCredentialsMessage},
		{T: externglib.Type(C.g_unix_fd_list_get_type()), F: marshalUnixFDList},
		{T: externglib.Type(C.g_unix_fd_message_get_type()), F: marshalUnixFDMessage},
		{T: externglib.Type(C.g_unix_input_stream_get_type()), F: marshalUnixInputStream},
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_output_stream_get_type()), F: marshalUnixOutputStream},
		{T: externglib.Type(C.g_unix_socket_address_get_type()), F: marshalUnixSocketAddress},
		{T: externglib.Type(C.g_vfs_get_type()), F: marshalVfs},
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitor},
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
		{T: externglib.Type(C.g_zlib_decompressor_get_type()), F: marshalZlibDecompressor},
	})
}

// BusType: an enumeration for well-known message buses.
type BusType int

const (
	// BusTypeStarter: an alias for the message bus that activated the process,
	// if any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: the system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: the login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult int

const (
	// ConverterResultError: there was an error during conversion.
	ConverterResultError ConverterResult = 0
	// ConverterResultConverted: some data was consumed or produced
	ConverterResultConverted ConverterResult = 1
	// ConverterResultFinished: the conversion is finished
	ConverterResultFinished ConverterResult = 2
	// ConverterResultFlushed: flushing is finished
	ConverterResultFlushed ConverterResult = 3
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType int

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred: the native credentials type is a `struct
	// ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred: the native credentials type is a `struct
	// cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred: the native credentials type is a
	// `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred: the native credentials type is a `ucred_t`.
	// Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid: the native credentials type is a `struct
	// unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred: the native credentials type is a `struct
	// xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError int

const (
	// DBusErrorFailed: a generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = 0
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory DBusError = 1
	// DBusErrorServiceUnknown: the bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown DBusError = 2
	// DBusErrorNameHasNoOwner: the bus name you referenced doesn't exist (i.e.
	// no application owns it).
	DBusErrorNameHasNoOwner DBusError = 3
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply DBusError = 4
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError DBusError = 5
	// DBusErrorBadAddress: a D-Bus bus address was malformed.
	DBusErrorBadAddress DBusError = 6
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported DBusError = 7
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded DBusError = 8
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied DBusError = 9
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed DBusError = 10
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer DBusError = 11
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout DBusError = 12
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork DBusError = 13
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse DBusError = 14
	// DBusErrorDisconnected: the connection is disconnected and you're trying
	// to use it.
	DBusErrorDisconnected DBusError = 15
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs DBusError = 16
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound DBusError = 17
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists DBusError = 18
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod DBusError = 19
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut DBusError = 20
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound DBusError = 21
	// DBusErrorMatchRuleInvalid: the match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid DBusError = 22
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed DBusError = 23
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed DBusError = 24
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited DBusError = 25
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled DBusError = 26
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed DBusError = 27
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed DBusError = 28
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid DBusError = 29
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid DBusError = 30
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound DBusError = 31
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid DBusError = 32
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid DBusError = 33
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory DBusError = 34
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown DBusError = 35
	// DBusErrorInvalidSignature: a type signature is not valid.
	DBusErrorInvalidSignature DBusError = 36
	// DBusErrorInvalidFileContent: a file contains invalid syntax or is
	// otherwise broken.
	DBusErrorInvalidFileContent DBusError = 37
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown DBusError = 38
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown DBusError = 39
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse DBusError = 40
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42
	DBusErrorUnknownObject DBusError = 41
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42
	DBusErrorUnknownInterface DBusError = 42
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42
	DBusErrorUnknownProperty DBusError = 43
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42
	DBusErrorPropertyReadOnly DBusError = 44
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder int

const (
	// DBusMessageByteOrderBigEndian: the byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: the byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField int

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = 0
	// DBusMessageHeaderFieldPath: the object path.
	DBusMessageHeaderFieldPath DBusMessageHeaderField = 1
	// DBusMessageHeaderFieldInterface: the interface name.
	DBusMessageHeaderFieldInterface DBusMessageHeaderField = 2
	// DBusMessageHeaderFieldMember: the method or signal name.
	DBusMessageHeaderFieldMember DBusMessageHeaderField = 3
	// DBusMessageHeaderFieldErrorName: the name of the error that occurred.
	DBusMessageHeaderFieldErrorName DBusMessageHeaderField = 4
	// DBusMessageHeaderFieldReplySerial: the serial number the message is a
	// reply to.
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderField = 5
	// DBusMessageHeaderFieldDestination: the name the message is intended for.
	DBusMessageHeaderFieldDestination DBusMessageHeaderField = 6
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender DBusMessageHeaderField = 7
	// DBusMessageHeaderFieldSignature: the signature of the message body.
	DBusMessageHeaderFieldSignature DBusMessageHeaderField = 8
	// DBusMessageHeaderFieldNumUnixFds: the number of UNIX file descriptors
	// that accompany the message.
	DBusMessageHeaderFieldNumUnixFds DBusMessageHeaderField = 9
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType int

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = 0
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall DBusMessageType = 1
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn DBusMessageType = 2
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError DBusMessageType = 3
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal DBusMessageType = 4
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder int

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType int

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType int

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown: the stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork: the start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk: the start/stop methods will
	// assemble/disassemble a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword: the start/stop methods will unlock/lock the
	// disk (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EmblemOrigin: GEmblemOrigin is used to add information about the origin of
// the emblem to #GEmblem.
type EmblemOrigin int

const (
	// EmblemOriginUnknown: emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice: emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus int

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeType: the data types for file attributes.
type FileAttributeType int

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString: a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString: a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean: a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32: an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32: a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64: an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64: a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject: a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv: a nil terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent int

const (
	// FileMonitorEventChanged: a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint: a hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted: a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated: a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged: a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount: the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted: the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved: the file was moved -- only sent if the
	// (deprecated) G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed: the file was renamed within the current
	// directory -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set.
	// Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn: the file was moved into the monitored directory
	// from another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut: the file was moved out of the monitored
	// directory to another location -- only sent if the
	// G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType int

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType int

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum int

const (
	// IOErrorEnumFailed: generic error condition for when an operation fails
	// and no more specific OErrorEnum value is defined.
	IOErrorEnumFailed IOErrorEnum = 0
	// IOErrorEnumNotFound: file not found.
	IOErrorEnumNotFound IOErrorEnum = 1
	// IOErrorEnumExists: file already exists.
	IOErrorEnumExists IOErrorEnum = 2
	// IOErrorEnumIsDirectory: file is a directory.
	IOErrorEnumIsDirectory IOErrorEnum = 3
	// IOErrorEnumNotDirectory: file is not a directory.
	IOErrorEnumNotDirectory IOErrorEnum = 4
	// IOErrorEnumNotEmpty: file is a directory that isn't empty.
	IOErrorEnumNotEmpty IOErrorEnum = 5
	// IOErrorEnumNotRegularFile: file is not a regular file.
	IOErrorEnumNotRegularFile IOErrorEnum = 6
	// IOErrorEnumNotSymbolicLink: file is not a symbolic link.
	IOErrorEnumNotSymbolicLink IOErrorEnum = 7
	// IOErrorEnumNotMountableFile: file cannot be mounted.
	IOErrorEnumNotMountableFile IOErrorEnum = 8
	// IOErrorEnumFilenameTooLong: filename is too many characters.
	IOErrorEnumFilenameTooLong IOErrorEnum = 9
	// IOErrorEnumInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorEnumInvalidFilename IOErrorEnum = 10
	// IOErrorEnumTooManyLinks: file contains too many symbolic links.
	IOErrorEnumTooManyLinks IOErrorEnum = 11
	// IOErrorEnumNoSpace: no space left on drive.
	IOErrorEnumNoSpace IOErrorEnum = 12
	// IOErrorEnumInvalidArgument: invalid argument.
	IOErrorEnumInvalidArgument IOErrorEnum = 13
	// IOErrorEnumPermissionDenied: permission denied.
	IOErrorEnumPermissionDenied IOErrorEnum = 14
	// IOErrorEnumNotSupported: operation (or one of its parameters) not
	// supported
	IOErrorEnumNotSupported IOErrorEnum = 15
	// IOErrorEnumNotMounted: file isn't mounted.
	IOErrorEnumNotMounted IOErrorEnum = 16
	// IOErrorEnumAlreadyMounted: file is already mounted.
	IOErrorEnumAlreadyMounted IOErrorEnum = 17
	// IOErrorEnumClosed: file was closed.
	IOErrorEnumClosed IOErrorEnum = 18
	// IOErrorEnumCancelled: operation was cancelled. See #GCancellable.
	IOErrorEnumCancelled IOErrorEnum = 19
	// IOErrorEnumPending operations are still pending.
	IOErrorEnumPending IOErrorEnum = 20
	// IOErrorEnumReadOnly: file is read only.
	IOErrorEnumReadOnly IOErrorEnum = 21
	// IOErrorEnumCantCreateBackup: backup couldn't be created.
	IOErrorEnumCantCreateBackup IOErrorEnum = 22
	// IOErrorEnumWrongEtag file's Entity Tag was incorrect.
	IOErrorEnumWrongEtag IOErrorEnum = 23
	// IOErrorEnumTimedOut: operation timed out.
	IOErrorEnumTimedOut IOErrorEnum = 24
	// IOErrorEnumWouldRecurse: operation would be recursive.
	IOErrorEnumWouldRecurse IOErrorEnum = 25
	// IOErrorEnumBusy: file is busy.
	IOErrorEnumBusy IOErrorEnum = 26
	// IOErrorEnumWouldBlock: operation would block.
	IOErrorEnumWouldBlock IOErrorEnum = 27
	// IOErrorEnumHostNotFound: host couldn't be found (remote operations).
	IOErrorEnumHostNotFound IOErrorEnum = 28
	// IOErrorEnumWouldMerge: operation would merge files.
	IOErrorEnumWouldMerge IOErrorEnum = 29
	// IOErrorEnumFailedHandled: operation failed and a helper program has
	// already interacted with the user. Do not display any error dialog.
	IOErrorEnumFailedHandled IOErrorEnum = 30
	// IOErrorEnumTooManyOpenFiles: the current process has too many files open
	// and can't open any more. Duplicate descriptors do count toward this
	// limit. Since 2.20
	IOErrorEnumTooManyOpenFiles IOErrorEnum = 31
	// IOErrorEnumNotInitialized: the object has not been initialized. Since
	// 2.22
	IOErrorEnumNotInitialized IOErrorEnum = 32
	// IOErrorEnumAddressInUse: the requested address is already in use. Since
	// 2.22
	IOErrorEnumAddressInUse IOErrorEnum = 33
	// IOErrorEnumPartialInput: need more input to finish operation. Since 2.24
	IOErrorEnumPartialInput IOErrorEnum = 34
	// IOErrorEnumInvalidData: the input data was invalid. Since 2.24
	IOErrorEnumInvalidData IOErrorEnum = 35
	// IOErrorEnumDBusError: a remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorEnumDBusError IOErrorEnum = 36
	// IOErrorEnumHostUnreachable: host unreachable. Since 2.26
	IOErrorEnumHostUnreachable IOErrorEnum = 37
	// IOErrorEnumNetworkUnreachable: network unreachable. Since 2.26
	IOErrorEnumNetworkUnreachable IOErrorEnum = 38
	// IOErrorEnumConnectionRefused: connection refused. Since 2.26
	IOErrorEnumConnectionRefused IOErrorEnum = 39
	// IOErrorEnumProxyFailed: connection to proxy server failed. Since 2.26
	IOErrorEnumProxyFailed IOErrorEnum = 40
	// IOErrorEnumProxyAuthFailed: proxy authentication failed. Since 2.26
	IOErrorEnumProxyAuthFailed IOErrorEnum = 41
	// IOErrorEnumProxyNeedAuth: proxy server needs authentication. Since 2.26
	IOErrorEnumProxyNeedAuth IOErrorEnum = 42
	// IOErrorEnumProxyNotAllowed: proxy connection is not allowed by ruleset.
	// Since 2.26
	IOErrorEnumProxyNotAllowed IOErrorEnum = 43
	// IOErrorEnumBrokenPipe: broken pipe. Since 2.36
	IOErrorEnumBrokenPipe IOErrorEnum = 44
	// IOErrorEnumConnectionClosed: connection closed by peer. Note that this is
	// the same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection
	// closed" errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorEnumConnectionClosed IOErrorEnum = 44
	// IOErrorEnumNotConnected: transport endpoint is not connected. Since 2.44
	IOErrorEnumNotConnected IOErrorEnum = 45
	// IOErrorEnumMessageTooLarge: message too large. Since 2.48.
	IOErrorEnumMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags int

const (
	// IOModuleScopeFlagsNone: no module scan flags
	IOModuleScopeFlagsNone IOModuleScopeFlags = 0
	// IOModuleScopeFlagsBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();
//
type MemoryMonitorWarningLevel int

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// @G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: the system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult int

const (
	// MountOperationResultHandled: the request was fulfilled and the user
	// specified data is now available
	MountOperationResultHandled MountOperationResult = 0
	// MountOperationResultAborted: the user requested the mount operation to be
	// aborted
	MountOperationResultAborted MountOperationResult = 1
	// MountOperationResultUnhandled: the request was unhandled (i.e. not
	// implemented)
	MountOperationResultUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NetworkConnectivity: the host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity int

const (
	// NetworkConnectivityLocal: the host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: the host is connected to a network, but does
	// not appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: the host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: the host is connected to a network, and appears
	// to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority int

const (
	// NotificationPriorityNormal: the default priority, to be used for the
	// majority of notifications (for example email messages, software updates,
	// completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave int

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn int

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOk: the operation was successfully finished.
	PollableReturnOk PollableReturn = 1
	// PollableReturnWouldBlock: the operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverError: an error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError int

const (
	// ResolverErrorNotFound: the requested name/address/service was not found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure: the requested information could not be
	// looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal: unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverRecordType: the type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most
// TXT records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire
// timeout as a `guint32`, and the TTL as a `guint32`.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType int

const (
	// ResolverRecordTypeSrv: look up DNS SRV records for a domain
	ResolverRecordTypeSrv ResolverRecordType = 1
	// ResolverRecordTypeMx: look up DNS MX records for a domain
	ResolverRecordTypeMx ResolverRecordType = 2
	// ResolverRecordTypeTxt: look up DNS TXT records for a name
	ResolverRecordTypeTxt ResolverRecordType = 3
	// ResolverRecordTypeSoa: look up DNS SOA records for a zone
	ResolverRecordTypeSoa ResolverRecordType = 4
	// ResolverRecordTypeNs: look up DNS NS records for a domain
	ResolverRecordTypeNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceError: an error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError int

const (
	// ResourceErrorNotFound: no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal: unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent int

const (
	// SocketClientEventResolving: the client is doing a DNS lookup.
	SocketClientEventResolving SocketClientEvent = 0
	// SocketClientEventResolved: the client has completed a DNS lookup.
	SocketClientEventResolved SocketClientEvent = 1
	// SocketClientEventConnecting: the client is connecting to a remote host
	// (either a proxy or the destination server).
	SocketClientEventConnecting SocketClientEvent = 2
	// SocketClientEventConnected: the client has connected to a remote host.
	SocketClientEventConnected SocketClientEvent = 3
	// SocketClientEventProxyNegotiating: the client is negotiating with a proxy
	// to connect to the destination server.
	SocketClientEventProxyNegotiating SocketClientEvent = 4
	// SocketClientEventProxyNegotiated: the client has negotiated with the
	// proxy server.
	SocketClientEventProxyNegotiated SocketClientEvent = 5
	// SocketClientEventTLSHandshaking: the client is performing a TLS
	// handshake.
	SocketClientEventTLSHandshaking SocketClientEvent = 6
	// SocketClientEventTLSHandshaked: the client has performed a TLS handshake.
	SocketClientEventTLSHandshaked SocketClientEvent = 7
	// SocketClientEventComplete: the client is done with a particular
	// Connectable.
	SocketClientEventComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketFamily: the protocol family of a Address. (These values are identical
// to the system defines AF_INET, AF_INET6 and AF_UNIX, if available.)
type SocketFamily int

const (
	// SocketFamilyInvalid: no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: the UNIX domain family
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIpv4: the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6: the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent int

const (
	// SocketListenerEventBinding: the listener is about to bind a socket.
	SocketListenerEventBinding SocketListenerEvent = 0
	// SocketListenerEventBound: the listener has bound a socket.
	SocketListenerEventBound SocketListenerEvent = 1
	// SocketListenerEventListening: the listener is about to start listening on
	// this socket.
	SocketListenerEventListening SocketListenerEvent = 2
	// SocketListenerEventListened: the listener is now listening on this
	// socket.
	SocketListenerEventListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketProtocol: a protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol int

const (
	// SocketProtocolUnknown: the protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: the default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp: TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp: UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp: SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType int

const (
	// SocketTypeInvalid: type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSAuthenticationMode: the client authentication mode for a ServerConnection.
type TLSAuthenticationMode int

const (
	// TLSAuthenticationModeNone: client authentication not required
	TLSAuthenticationModeNone TLSAuthenticationMode = 0
	// TLSAuthenticationModeRequested: client authentication is requested
	TLSAuthenticationModeRequested TLSAuthenticationMode = 1
	// TLSAuthenticationModeRequired: client authentication is required
	TLSAuthenticationModeRequired TLSAuthenticationMode = 2
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TLSCertificateRequestFlags int

const (
	// TLSCertificateRequestFlagsNone: no flags
	TLSCertificateRequestFlagsNone TLSCertificateRequestFlags = 0
)

func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TLSCertificateRequestFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingError: an error code used with G_TLS_CHANNEL_BINDING_ERROR
// in a #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError int

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = 0
	// TLSChannelBindingErrorInvalidState: the handshake is not yet complete on
	// the connection which is a strong requirement for any existing binding
	// type.
	TLSChannelBindingErrorInvalidState TLSChannelBindingError = 1
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable TLSChannelBindingError = 2
	// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// `tls-server-end-point` binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported TLSChannelBindingError = 3
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError TLSChannelBindingError = 4
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSChannelBindingType: the type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// `tls-unique-for-telnet` (https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TLSChannelBindingType int

const (
	// TLSChannelBindingTypeUnique: `tls-unique`
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type
	TLSChannelBindingTypeUnique TLSChannelBindingType = 0
	// TLSChannelBindingTypeServerEndPoint: `tls-server-end-point`
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type
	TLSChannelBindingTypeServerEndPoint TLSChannelBindingType = 1
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags int

const (
	// TLSDatabaseLookupFlagsNone: no lookup flags
	TLSDatabaseLookupFlagsNone TLSDatabaseLookupFlags = 0
	// TLSDatabaseLookupFlagsKeypair: restrict lookup to certificates that have
	// a private key.
	TLSDatabaseLookupFlagsKeypair TLSDatabaseLookupFlags = 1
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSError: an error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError int

const (
	// TLSErrorUnavailable: no TLS provider is available
	TLSErrorUnavailable TLSError = 0
	// TLSErrorMisc miscellaneous TLS error
	TLSErrorMisc TLSError = 1
	// TLSErrorBadCertificate: the certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate TLSError = 2
	// TLSErrorNotTLS: the TLS handshake failed because the peer does not seem
	// to be a TLS server.
	TLSErrorNotTLS TLSError = 3
	// TLSErrorHandshake: the TLS handshake failed because the peer's
	// certificate was not acceptable.
	TLSErrorHandshake TLSError = 4
	// TLSErrorCertificateRequired: the TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired TLSError = 5
	// TLSErrorEOF: the TLS connection was closed without proper notice, which
	// may indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF TLSError = 6
	// TLSErrorInappropriateFallback: the TLS handshake failed because the
	// client sent the fallback SCSV, indicating a protocol downgrade attack.
	// Since: 2.60
	TLSErrorInappropriateFallback TLSError = 7
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult int

const (
	// TLSInteractionResultUnhandled: the interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionResultUnhandled TLSInteractionResult = 0
	// TLSInteractionResultHandled: the interaction completed, and resulting
	// data is available.
	TLSInteractionResultHandled TLSInteractionResult = 1
	// TLSInteractionResultFailed: the interaction has failed, or was cancelled.
	// and the operation should be aborted.
	TLSInteractionResultFailed TLSInteractionResult = 2
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
type TLSRehandshakeMode int

const (
	// TLSRehandshakeModeNever: never allow rehandshaking
	TLSRehandshakeModeNever TLSRehandshakeMode = 0
	// TLSRehandshakeModeSafely: allow safe rehandshaking only
	TLSRehandshakeModeSafely TLSRehandshakeMode = 1
	// TLSRehandshakeModeUnsafely: allow unsafe rehandshaking
	TLSRehandshakeModeUnsafely TLSRehandshakeMode = 2
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// UnixSocketAddressType: the type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire `struct sockaddr_un` as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType int

const (
	// UnixSocketAddressTypeInvalid: invalid
	UnixSocketAddressTypeInvalid UnixSocketAddressType = 0
	// UnixSocketAddressTypeAnonymous: anonymous
	UnixSocketAddressTypeAnonymous UnixSocketAddressType = 1
	// UnixSocketAddressTypePath: a filesystem path
	UnixSocketAddressTypePath UnixSocketAddressType = 2
	// UnixSocketAddressTypeAbstract: an abstract name
	UnixSocketAddressTypeAbstract UnixSocketAddressType = 3
	// UnixSocketAddressTypeAbstractPadded: an abstract name, 0-padded to the
	// full length of a unix socket name
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressType = 4
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat int

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip: gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw: deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags int

const (
	// AppInfoCreateFlagsNone: no flags.
	AppInfoCreateFlagsNone AppInfoCreateFlags = 0b0
	// AppInfoCreateFlagsNeedsTerminal: application opens in a terminal window.
	AppInfoCreateFlagsNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateFlagsSupportsUris: application supports URI arguments.
	AppInfoCreateFlagsSupportsUris AppInfoCreateFlags = 0b10
	// AppInfoCreateFlagsSupportsStartupNotification: application supports
	// startup notification. Since 2.26
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags int

const (
	// ApplicationFlagsFlagsNone: default
	ApplicationFlagsFlagsNone ApplicationFlags = 0b0
	// ApplicationFlagsIsService: run as a service. In this mode, registration
	// fails if the service is already running, and the application will
	// initially wait up to 10 seconds for an initial activation message to
	// arrive.
	ApplicationFlagsIsService ApplicationFlags = 0b1
	// ApplicationFlagsIsLauncher: don't try to become the primary instance.
	ApplicationFlagsIsLauncher ApplicationFlags = 0b10
	// ApplicationFlagsHandlesOpen: this application handles opening files (in
	// the primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationFlagsHandlesOpen ApplicationFlags = 0b100
	// ApplicationFlagsHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationFlagsSendEnvironment: send the environment of the launching
	// process to the primary instance. Set this flag if your application is
	// expected to behave differently depending on certain environment
	// variables. For instance, an editor might be expected to use the
	// `GIT_COMMITTER_NAME` environment variable when editing a git commit
	// message. The environment is available to the #GApplication::command-line
	// signal handler, via g_application_command_line_getenv().
	ApplicationFlagsSendEnvironment ApplicationFlags = 0b10000
	// ApplicationFlagsNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationFlagsNonUnique ApplicationFlags = 0b100000
	// ApplicationFlagsCanOverrideAppID: allow users to override the application
	// ID from the command line with `--gapplication-app-id`. Since: 2.48
	ApplicationFlagsCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationFlagsAllowReplacement: allow another instance to take over the
	// bus name. Since: 2.60
	ApplicationFlagsAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationFlagsReplace: take over from another instance. This flag is
	// usually set by passing `--gapplication-replace` on the commandline.
	// Since: 2.60
	ApplicationFlagsReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AskPasswordFlags PasswordFlags are used to request specific information from
// the user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags int

const (
	// AskPasswordFlagsNeedPassword: operation requires a password.
	AskPasswordFlagsNeedPassword AskPasswordFlags = 0b1
	// AskPasswordFlagsNeedUsername: operation requires a username.
	AskPasswordFlagsNeedUsername AskPasswordFlags = 0b10
	// AskPasswordFlagsNeedDomain: operation requires a domain.
	AskPasswordFlagsNeedDomain AskPasswordFlags = 0b100
	// AskPasswordFlagsSavingSupported: operation supports saving settings.
	AskPasswordFlagsSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordFlagsAnonymousSupported: operation supports anonymous users.
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordFlagsTcrypt: operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordFlagsTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags int

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54)
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags int

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags int

const (
	// ConverterFlagsNone: no flags.
	ConverterFlagsNone ConverterFlags = 0b0
	// ConverterFlagsInputAtEnd: at end of input data
	ConverterFlagsInputAtEnd ConverterFlags = 0b1
	// ConverterFlagsFlush: flush data
	ConverterFlagsFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags int

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: the caller is prepared to
	// wait for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags int

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing: the connection supports exchanging UNIX
	// file descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags int

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags int

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags int

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: a reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart: the bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags int

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags int

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags int

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the `PropertiesChanged`
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags int

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags int

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags int

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags int

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags int

const (
	// DriveStartFlagsNone: no flags set.
	DriveStartFlagsNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags int

const (
	// FileAttributeInfoFlagsNone: no flags set.
	FileAttributeInfoFlagsNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoFlagsCopyWithFile: copy the attribute values when the
	// file is copied.
	FileAttributeInfoFlagsCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoFlagsCopyWhenMoved: copy the attribute values when the
	// file is moved.
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags int

const (
	// FileCopyFlagsNone: no flags set.
	FileCopyFlagsNone FileCopyFlags = 0b0
	// FileCopyFlagsOverwrite: overwrite any existing files
	FileCopyFlagsOverwrite FileCopyFlags = 0b1
	// FileCopyFlagsBackup: make a backup of any existing files.
	FileCopyFlagsBackup FileCopyFlags = 0b10
	// FileCopyFlagsNofollowSymlinks: don't follow symlinks.
	FileCopyFlagsNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyFlagsAllMetadata: copy all file metadata instead of just default
	// set used for copy (see Info).
	FileCopyFlagsAllMetadata FileCopyFlags = 0b1000
	// FileCopyFlagsNoFallbackForMove: don't use copy and delete fallback if
	// native move not supported.
	FileCopyFlagsNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyFlagsTargetDefaultPerms leaves target file with default perms,
	// instead of setting the source file perms.
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags int

const (
	// FileCreateFlagsNone: no flags set.
	FileCreateFlagsNone FileCreateFlags = 0b0
	// FileCreateFlagsPrivate: create a file that can only be accessed by the
	// current user.
	FileCreateFlagsPrivate FileCreateFlags = 0b1
	// FileCreateFlagsReplaceDestination: replace the destination as if it
	// didn't exist before. Don't try to keep any old permissions, replace
	// instead of following links. This is generally useful if you're doing a
	// "copy over" rather than a "save new version of" replace operation. You
	// can think of it as "unlink destination" before writing to it, although
	// the implementation may not be exactly like that. This flag can only be
	// used with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20
	FileCreateFlagsReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags int

const (
	// FileMeasureFlagsNone: no flags set.
	FileMeasureFlagsNone FileMeasureFlags = 0b0
	// FileMeasureFlagsReportAnyError: report any error encountered while
	// traversing the directory tree. Normally errors are only reported for the
	// toplevel file.
	FileMeasureFlagsReportAnyError FileMeasureFlags = 0b10
	// FileMeasureFlagsApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with `du
	// --apparent-size`.
	FileMeasureFlagsApparentSize FileMeasureFlags = 0b100
	// FileMeasureFlagsNoXdev: do not cross mount point boundaries. Compare with
	// `du -x`.
	FileMeasureFlagsNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags int

const (
	// FileMonitorFlagsNone: no flags set.
	FileMonitorFlagsNone FileMonitorFlags = 0b0
	// FileMonitorFlagsWatchMounts: watch for mount events.
	FileMonitorFlagsWatchMounts FileMonitorFlags = 0b1
	// FileMonitorFlagsSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorFlagsSendMoved FileMonitorFlags = 0b10
	// FileMonitorFlagsWatchHardLinks: watch for changes to the file made via
	// another hard link. Since 2.36.
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorFlagsWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorFlagsWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags int

const (
	// FileQueryInfoFlagsNone: no flags set.
	FileQueryInfoFlagsNone FileQueryInfoFlags = 0b0
	// FileQueryInfoFlagsNofollowSymlinks: don't follow symlinks.
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// IOStreamSpliceFlags gIOStreamSpliceFlags determine how streams should be
// spliced.
type IOStreamSpliceFlags int

const (
	// IOStreamSpliceFlagsNone: do not close either stream.
	IOStreamSpliceFlagsNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceFlagsCloseStream1: close the first stream after the splice.
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceFlagsCloseStream2: close the second stream after the
	// splice.
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceFlagsWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceFlagsWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags int

const (
	// MountMountFlagsNone: no flags set.
	MountMountFlagsNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags int

const (
	// MountUnmountFlagsNone: no flags set.
	MountUnmountFlagsNone MountUnmountFlags = 0b0
	// MountUnmountFlagsForce: unmount even if there are outstanding file
	// operations on the mount.
	MountUnmountFlagsForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OutputStreamSpliceFlags gOutputStreamSpliceFlags determine how streams should
// be spliced.
type OutputStreamSpliceFlags int

const (
	// OutputStreamSpliceFlagsNone: do not close either stream.
	OutputStreamSpliceFlagsNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceFlagsCloseSource: close the source stream after the
	// splice.
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceFlagsCloseTarget: close the target stream after the
	// splice.
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags int

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIpv4Only: only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIpv6Only: only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceFlags gResourceFlags give information about a particular file inside
// a resource bundle.
type ResourceFlags int

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: the file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ResourceLookupFlags gResourceLookupFlags determine how resource path lookups
// are handled.
type ResourceLookupFlags int

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags int

const (
	// SettingsBindFlagsDefault: equivalent to
	// `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindFlagsDefault SettingsBindFlags = 0b0
	// SettingsBindFlagsGet: update the #GObject property when the setting
	// changes. It is an error to use this flag if the property is not writable.
	SettingsBindFlagsGet SettingsBindFlags = 0b1
	// SettingsBindFlagsSet: update the setting when the #GObject property
	// changes. It is an error to use this flag if the property is not readable.
	SettingsBindFlagsSet SettingsBindFlags = 0b10
	// SettingsBindFlagsNoSensitivity: do not try to bind a "sensitivity"
	// property to the writability of the setting
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindFlagsGetNoChanges: when set in addition to SETTINGS_BIND_GET,
	// set the #GObject property value initially from the setting, but do not
	// listen for changes of the setting
	SettingsBindFlagsGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindFlagsInvertBoolean: when passed to g_settings_bind(), uses a
	// pair of mapping functions that invert the boolean value when mapping
	// between the setting and the property. The setting and property must both
	// be booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags int

const (
	// SocketMsgFlagsNone: no flags.
	SocketMsgFlagsNone SocketMsgFlags = 0b0
	// SocketMsgFlagsOob: request to send/receive out of band data.
	SocketMsgFlagsOob SocketMsgFlags = 0b1
	// SocketMsgFlagsPeek: read data from the socket without removing it from
	// the queue.
	SocketMsgFlagsPeek SocketMsgFlags = 0b10
	// SocketMsgFlagsDontroute: don't use a gateway to send out the packet, only
	// send to hosts on directly connected networks.
	SocketMsgFlagsDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from `/dev/null`. For stdout
// and stderr the default are for them to inherit the corresponding descriptor
// from the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags int

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to `/dev/null`).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags int

const (
	// TestDBusFlagsNone: no flags.
	TestDBusFlagsNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSCertificateFlags: a set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TLSCertificateFlags int

const (
	// TLSCertificateFlagsUnknownCa: the signing certificate authority is not
	// known.
	TLSCertificateFlagsUnknownCa TLSCertificateFlags = 0b1
	// TLSCertificateFlagsBadIdentity: the certificate does not match the
	// expected identity of the site that it was retrieved from.
	TLSCertificateFlagsBadIdentity TLSCertificateFlags = 0b10
	// TLSCertificateFlagsNotActivated: the certificate's activation time is
	// still in the future
	TLSCertificateFlagsNotActivated TLSCertificateFlags = 0b100
	// TLSCertificateFlagsExpired: the certificate has expired
	TLSCertificateFlagsExpired TLSCertificateFlags = 0b1000
	// TLSCertificateFlagsRevoked: the certificate has been revoked according to
	// the Connection's certificate revocation list.
	TLSCertificateFlagsRevoked TLSCertificateFlags = 0b10000
	// TLSCertificateFlagsInsecure: the certificate's algorithm is considered
	// insecure.
	TLSCertificateFlagsInsecure TLSCertificateFlags = 0b100000
	// TLSCertificateFlagsGenericError: some other error occurred validating the
	// certificate
	TLSCertificateFlagsGenericError TLSCertificateFlags = 0b1000000
	// TLSCertificateFlagsValidateAll: the combination of all of the above flags
	TLSCertificateFlagsValidateAll TLSCertificateFlags = 0b1111111
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags int

const (
	// TLSDatabaseVerifyFlagsNone: no verification flags
	TLSDatabaseVerifyFlagsNone TLSDatabaseVerifyFlags = 0b0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags int

const (
	// TLSPasswordFlagsNone: no flags
	TLSPasswordFlagsNone TLSPasswordFlags = 0b0
	// TLSPasswordFlagsRetry: the password was wrong, and the user should retry.
	TLSPasswordFlagsRetry TLSPasswordFlags = 0b10
	// TLSPasswordFlagsManyTries: hint to the user that the password has been
	// wrong many times, and the user may not have many chances left.
	TLSPasswordFlagsManyTries TLSPasswordFlags = 0b100
	// TLSPasswordFlagsFinalTry: hint to the user that this is the last try to
	// get this password right.
	TLSPasswordFlagsFinalTry TLSPasswordFlags = 0b1000
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
type AsyncReadyCallback func(sourceObject gextras.Objector, res AsyncResult)

//export gotk4_AsyncReadyCallback
func gotk4_AsyncReadyCallback(arg0 *C.GObject, arg1 *C.GAsyncResult, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var sourceObject gextras.Objector
	var res AsyncResult

	sourceObject = externglib.Take(unsafe.Pointer(arg0.Native()))

	v.(AsyncReadyCallback)(sourceObject, res)
}

// BusAcquiredCallback: invoked when a connection to a message bus has been
// obtained.
type BusAcquiredCallback func(connection DBusConnection, name string)

//export gotk4_BusAcquiredCallback
func gotk4_BusAcquiredCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var name string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	name = C.GoString(arg1)

	v.(BusAcquiredCallback)(connection, name)
}

// BusNameAcquiredCallback: invoked when the name is acquired.
type BusNameAcquiredCallback func(connection DBusConnection, name string)

//export gotk4_BusNameAcquiredCallback
func gotk4_BusNameAcquiredCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var name string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	name = C.GoString(arg1)

	v.(BusNameAcquiredCallback)(connection, name)
}

// BusNameAppearedCallback: invoked when the name being watched is known to have
// to have an owner.
type BusNameAppearedCallback func(connection DBusConnection, name string, nameOwner string)

//export gotk4_BusNameAppearedCallback
func gotk4_BusNameAppearedCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var name string
	var nameOwner string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	name = C.GoString(arg1)

	nameOwner = C.GoString(arg2)

	v.(BusNameAppearedCallback)(connection, name, nameOwner)
}

// BusNameLostCallback: invoked when the name is lost or @connection has been
// closed.
type BusNameLostCallback func(connection DBusConnection, name string)

//export gotk4_BusNameLostCallback
func gotk4_BusNameLostCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var name string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	name = C.GoString(arg1)

	v.(BusNameLostCallback)(connection, name)
}

// BusNameVanishedCallback: invoked when the name being watched is known not to
// have to have an owner.
//
// This is also invoked when the BusConnection on which the watch was
// established has been closed. In that case, @connection will be nil.
type BusNameVanishedCallback func(connection DBusConnection, name string)

//export gotk4_BusNameVanishedCallback
func gotk4_BusNameVanishedCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var name string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	name = C.GoString(arg1)

	v.(BusNameVanishedCallback)(connection, name)
}

// CancellableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_cancellable_source_new().
type CancellableSourceFunc func(cancellable Cancellable) bool

//export gotk4_CancellableSourceFunc
func gotk4_CancellableSourceFunc(arg0 *C.GCancellable, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var cancellable Cancellable

	cancellable = WrapCancellable(externglib.Take(unsafe.Pointer(arg0.Native())))

	ok := v.(CancellableSourceFunc)(cancellable)
}

// DBusInterfaceGetPropertyFunc: the type of the @get_property function in
// BusInterfaceVTable.
type DBusInterfaceGetPropertyFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, propertyName string, error **glib.Error) *glib.Variant

//export gotk4_DBusInterfaceGetPropertyFunc
func gotk4_DBusInterfaceGetPropertyFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 **C.GError, arg6 C.gpointer) *C.GVariant {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string
	var interfaceName string
	var propertyName string
	var error **glib.Error

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	interfaceName = C.GoString(arg3)

	propertyName = C.GoString(arg4)

	error = glib.WrapError(arg5)

	variant := v.(DBusInterfaceGetPropertyFunc)(connection, sender, objectPath, interfaceName, propertyName, error)
}

// DBusInterfaceMethodCallFunc: the type of the @method_call function in
// BusInterfaceVTable.
type DBusInterfaceMethodCallFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, invocation DBusMethodInvocation)

//export gotk4_DBusInterfaceMethodCallFunc
func gotk4_DBusInterfaceMethodCallFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 *C.GDBusMethodInvocation, arg7 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg7))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string
	var interfaceName string
	var methodName string
	var parameters *glib.Variant
	var invocation DBusMethodInvocation

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	interfaceName = C.GoString(arg3)

	methodName = C.GoString(arg4)

	parameters = glib.WrapVariant(arg5)

	invocation = WrapDBusMethodInvocation(externglib.AssumeOwnership(unsafe.Pointer(arg6.Native())))

	v.(DBusInterfaceMethodCallFunc)(connection, sender, objectPath, interfaceName, methodName, parameters, invocation)
}

// DBusInterfaceSetPropertyFunc: the type of the @set_property function in
// BusInterfaceVTable.
type DBusInterfaceSetPropertyFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, propertyName string, value *glib.Variant, error **glib.Error) bool

//export gotk4_DBusInterfaceSetPropertyFunc
func gotk4_DBusInterfaceSetPropertyFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 **C.GError, arg7 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg7))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string
	var interfaceName string
	var propertyName string
	var value *glib.Variant
	var error **glib.Error

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	interfaceName = C.GoString(arg3)

	propertyName = C.GoString(arg4)

	value = glib.WrapVariant(arg5)

	error = glib.WrapError(arg6)

	ok := v.(DBusInterfaceSetPropertyFunc)(connection, sender, objectPath, interfaceName, propertyName, value, error)
}

// DBusMessageFilterFunction: signature for function used in
// g_dbus_connection_add_filter().
//
// A filter function is passed a BusMessage and expected to return a BusMessage
// too. Passive filter functions that don't modify the message can simply return
// the @message object:
//
//
//    static GDBusMessage *
//    passive_filter (GDBusConnection *connection
//                    GDBusMessage    *message,
//                    gboolean         incoming,
//                    gpointer         user_data)
//    {
//      // inspect @message
//      return message;
//    }
//    ]|
//    Filter functions that wants to drop a message can simply return nil:
//    |[
//    static GDBusMessage *
//    drop_filter (GDBusConnection *connection
//                 GDBusMessage    *message,
//                 gboolean         incoming,
//                 gpointer         user_data)
//    {
//      if (should_drop_message)
//        {
//          g_object_unref (message);
//          message = NULL;
//        }
//      return message;
//    }
//    ]|
//    Finally, a filter function may modify a message by copying it:
//    |[
//    static GDBusMessage *
//    modifying_filter (GDBusConnection *connection
//                      GDBusMessage    *message,
//                      gboolean         incoming,
//                      gpointer         user_data)
//    {
//      GDBusMessage *copy;
//      GError *error;
//
//      error = NULL;
//      copy = g_dbus_message_copy (message, &error);
//      // handle @error being set
//      g_object_unref (message);
//
//      // modify @copy
//
//      return copy;
//    }
//
//
// If the returned BusMessage is different from @message and cannot be sent on
// @connection (it could use features, such as file descriptors, not compatible
// with @connection), then a warning is logged to standard error. Applications
// can check this ahead of time using g_dbus_message_to_blob() passing a
// BusCapabilityFlags value obtained from @connection.
type DBusMessageFilterFunction func(connection DBusConnection, message DBusMessage, incoming bool) DBusMessage

//export gotk4_DBusMessageFilterFunction
func gotk4_DBusMessageFilterFunction(arg0 *C.GDBusConnection, arg1 *C.GDBusMessage, arg2 C.gboolean, arg3 C.gpointer) *C.GDBusMessage {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var message DBusMessage
	var incoming bool

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	message = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native())))

	incoming = gextras.Gobool(arg2)

	dBusMessage := v.(DBusMessageFilterFunction)(connection, message, incoming)
}

// DBusProxyTypeFunc: function signature for a function used to determine the
// #GType to use for an interface proxy (if @interface_name is not nil) or
// object proxy (if @interface_name is nil).
//
// This function is called in the [thread-default main
// loop][g-main-context-push-thread-default] that @manager was constructed in.
type DBusProxyTypeFunc func(manager DBusObjectManagerClient, objectPath string, interfaceName string) externglib.Type

//export gotk4_DBusProxyTypeFunc
func gotk4_DBusProxyTypeFunc(arg0 *C.GDBusObjectManagerClient, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) C.GType {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var manager DBusObjectManagerClient
	var objectPath string
	var interfaceName string

	manager = WrapDBusObjectManagerClient(externglib.Take(unsafe.Pointer(arg0.Native())))

	objectPath = C.GoString(arg1)

	interfaceName = C.GoString(arg2)

	gType := v.(DBusProxyTypeFunc)(manager, objectPath, interfaceName)
}

// DBusSignalCallback: signature for callback function used in
// g_dbus_connection_signal_subscribe().
type DBusSignalCallback func(connection DBusConnection, senderName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant)

//export gotk4_DBusSignalCallback
func gotk4_DBusSignalCallback(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.GVariant, arg6 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var senderName string
	var objectPath string
	var interfaceName string
	var signalName string
	var parameters *glib.Variant

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	senderName = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	interfaceName = C.GoString(arg3)

	signalName = C.GoString(arg4)

	parameters = glib.WrapVariant(arg5)

	v.(DBusSignalCallback)(connection, senderName, objectPath, interfaceName, signalName, parameters)
}

// DBusSubtreeDispatchFunc: the type of the @dispatch function in
// BusSubtreeVTable.
//
// Subtrees are flat. @node, if non-nil, is always exactly one segment of the
// object path (ie: it never contains a slash).
type DBusSubtreeDispatchFunc func(connection DBusConnection, sender string, objectPath string, interfaceName string, node string, outUserData interface{}) *DBusInterfaceVTable

//export gotk4_DBusSubtreeDispatchFunc
func gotk4_DBusSubtreeDispatchFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 *C.gpointer, arg6 C.gpointer) *C.GDBusInterfaceVTable {
	v := box.Get(box.Callback, uintptr(arg6))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string
	var interfaceName string
	var node string
	var outUserData interface{}

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	interfaceName = C.GoString(arg3)

	node = C.GoString(arg4)

	outUserData = box.Get(uintptr(arg5))

	dBusInterfaceVTable := v.(DBusSubtreeDispatchFunc)(connection, sender, objectPath, interfaceName, node, outUserData)
}

// DBusSubtreeEnumerateFunc: the type of the @enumerate function in
// BusSubtreeVTable.
//
// This function is called when generating introspection data and also when
// preparing to dispatch incoming messages in the event that the
// G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not specified
// (ie: to verify that the object path is valid).
//
// Hierarchies are not supported; the items that you return should not contain
// the '/' character.
//
// The return value will be freed with g_strfreev().
type DBusSubtreeEnumerateFunc func(connection DBusConnection, sender string, objectPath string) []string

//export gotk4_DBusSubtreeEnumerateFunc
func gotk4_DBusSubtreeEnumerateFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 C.gpointer) **C.gchar {
	v := box.Get(box.Callback, uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	utf8s := v.(DBusSubtreeEnumerateFunc)(connection, sender, objectPath)
}

// DBusSubtreeIntrospectFunc: the type of the @introspect function in
// BusSubtreeVTable.
//
// Subtrees are flat. @node, if non-nil, is always exactly one segment of the
// object path (ie: it never contains a slash).
//
// This function should return nil to indicate that there is no object at this
// node.
//
// If this function returns non-nil, the return value is expected to be a
// nil-terminated array of pointers to BusInterfaceInfo structures describing
// the interfaces implemented by @node. This array will have
// g_dbus_interface_info_unref() called on each item before being freed with
// g_free().
//
// The difference between returning nil and an array containing zero items is
// that the standard DBus interfaces will returned to the remote introspector in
// the empty array case, but not in the nil case.
type DBusSubtreeIntrospectFunc func(connection DBusConnection, sender string, objectPath string, node string) **DBusInterfaceInfo

//export gotk4_DBusSubtreeIntrospectFunc
func gotk4_DBusSubtreeIntrospectFunc(arg0 *C.GDBusConnection, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 C.gpointer) **C.GDBusInterfaceInfo {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var connection DBusConnection
	var sender string
	var objectPath string
	var node string

	connection = WrapDBusConnection(externglib.Take(unsafe.Pointer(arg0.Native())))

	sender = C.GoString(arg1)

	objectPath = C.GoString(arg2)

	node = C.GoString(arg3)

	dBusInterfaceInfo := v.(DBusSubtreeIntrospectFunc)(connection, sender, objectPath, node)
}

// DatagramBasedSourceFunc: this is the function type of the callback used for
// the #GSource returned by g_datagram_based_create_source().
type DatagramBasedSourceFunc func(datagramBased DatagramBased, condition glib.IOCondition) bool

//export gotk4_DatagramBasedSourceFunc
func gotk4_DatagramBasedSourceFunc(arg0 *C.GDatagramBased, arg1 C.GIOCondition, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var datagramBased DatagramBased
	var condition glib.IOCondition

	condition = glib.IOCondition(arg1)

	ok := v.(DatagramBasedSourceFunc)(datagramBased, condition)
}

// DesktopAppLaunchCallback: during invocation,
// g_desktop_app_info_launch_uris_as_manager() may create one or more child
// processes. This callback is invoked once for each, providing the process ID.
type DesktopAppLaunchCallback func(appinfo DesktopAppInfo, pid glib.Pid)

//export gotk4_DesktopAppLaunchCallback
func gotk4_DesktopAppLaunchCallback(arg0 *C.GDesktopAppInfo, arg1 C.GPid, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var appinfo DesktopAppInfo
	var pid glib.Pid

	appinfo = WrapDesktopAppInfo(externglib.Take(unsafe.Pointer(arg0.Native())))

	{
		var tmp int
		tmp = int(arg1)
		pid = glib.Pid(tmp)
	}

	v.(DesktopAppLaunchCallback)(appinfo, pid)
}

// FileMeasureProgressCallback: this callback type is used by
// g_file_measure_disk_usage() to make periodic progress reports when measuring
// the amount of disk spaced used by a directory.
//
// These calls are made on a best-effort basis and not all types of #GFile will
// support them. At the minimum, however, one call will always be made
// immediately.
//
// In the case that there is no support, @reporting will be set to false (and
// the other values undefined) and no further calls will be made. Otherwise, the
// @reporting will be true and the other values all-zeros during the first
// (immediate) call. In this way, you can know which type of progress UI to show
// without a delay.
//
// For g_file_measure_disk_usage() the callback is made directly. For
// g_file_measure_disk_usage_async() the callback is made via the default main
// context of the calling thread (ie: the same way that the final async result
// would be reported).
//
// @current_size is in the same units as requested by the operation (see
// G_FILE_MEASURE_APPARENT_SIZE).
//
// The frequency of the updates is implementation defined, but is ideally about
// once every 200ms.
//
// The last progress callback may or may not be equal to the final result.
// Always check the async result to get the final value.
type FileMeasureProgressCallback func(reporting bool, currentSize uint64, numDirs uint64, numFiles uint64)

//export gotk4_FileMeasureProgressCallback
func gotk4_FileMeasureProgressCallback(arg0 C.gboolean, arg1 C.guint64, arg2 C.guint64, arg3 C.guint64, arg4 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var reporting bool
	var currentSize uint64
	var numDirs uint64
	var numFiles uint64

	reporting = gextras.Gobool(arg0)

	currentSize = uint64(arg1)

	numDirs = uint64(arg2)

	numFiles = uint64(arg3)

	v.(FileMeasureProgressCallback)(reporting, currentSize, numDirs, numFiles)
}

// FileProgressCallback: when doing file operations that may take a while, such
// as moving a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(currentNumBytes int64, totalNumBytes int64)

//export gotk4_FileProgressCallback
func gotk4_FileProgressCallback(arg0 C.goffset, arg1 C.goffset, arg2 C.gpointer) {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var currentNumBytes int64
	var totalNumBytes int64

	currentNumBytes = int64(arg0)

	totalNumBytes = int64(arg1)

	v.(FileProgressCallback)(currentNumBytes, totalNumBytes)
}

// FileReadMoreCallback: when loading the partial contents of a file with
// g_file_load_partial_contents_async(), it may become necessary to determine if
// any more data from the file should be loaded. A ReadMoreCallback function
// facilitates this by returning true if more data should be read, or false
// otherwise.
type FileReadMoreCallback func(fileContents string, fileSize int64) bool

//export gotk4_FileReadMoreCallback
func gotk4_FileReadMoreCallback(arg0 *C.char, arg1 C.goffset, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var fileContents string
	var fileSize int64

	fileContents = C.GoString(arg0)

	fileSize = int64(arg1)

	ok := v.(FileReadMoreCallback)(fileContents, fileSize)
}

// IOSchedulerJobFunc: i/O Job function.
//
// Long-running jobs should periodically check the @cancellable to see if they
// have been cancelled.
type IOSchedulerJobFunc func(job *IOSchedulerJob, cancellable Cancellable) bool

//export gotk4_IOSchedulerJobFunc
func gotk4_IOSchedulerJobFunc(arg0 *C.GIOSchedulerJob, arg1 *C.GCancellable, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var job *IOSchedulerJob
	var cancellable Cancellable

	job = WrapIOSchedulerJob(arg0)

	cancellable = WrapCancellable(externglib.Take(unsafe.Pointer(arg1.Native())))

	ok := v.(IOSchedulerJobFunc)(job, cancellable)
}

// PollableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_pollable_input_stream_create_source() and
// g_pollable_output_stream_create_source().
type PollableSourceFunc func(pollableStream gextras.Objector) bool

//export gotk4_PollableSourceFunc
func gotk4_PollableSourceFunc(arg0 *C.GObject, arg1 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var pollableStream gextras.Objector

	pollableStream = externglib.Take(unsafe.Pointer(arg0.Native()))

	ok := v.(PollableSourceFunc)(pollableStream)
}

// SettingsBindGetMapping: the type for the function that is used to convert
// from #GSettings to an object property. The @value is already initialized to
// hold values of the appropriate type.
type SettingsBindGetMapping func(value *externglib.Value, variant *glib.Variant) bool

//export gotk4_SettingsBindGetMapping
func gotk4_SettingsBindGetMapping(arg0 *C.GValue, arg1 *C.GVariant, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *externglib.Value
	var variant *glib.Variant

	variant = glib.WrapVariant(arg1)

	ok := v.(SettingsBindGetMapping)(value, variant)
}

// SettingsBindSetMapping: the type for the function that is used to convert an
// object property value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func(value *externglib.Value, expectedType *glib.VariantType) *glib.Variant

//export gotk4_SettingsBindSetMapping
func gotk4_SettingsBindSetMapping(arg0 *C.GValue, arg1 *C.GVariantType, arg2 C.gpointer) *C.GVariant {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *externglib.Value
	var expectedType *glib.VariantType

	expectedType = glib.WrapVariantType(arg1)

	variant := v.(SettingsBindSetMapping)(value, expectedType)
}

// SettingsGetMapping: the type of the function that is used to convert from a
// value stored in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at @result
// and true returned. If mapping fails (for example, if @value is not in the
// right format) then false should be returned.
//
// If @value is nil then it means that the mapping function is being given a
// "last chance" to successfully return a valid value. true must be returned in
// this case.
type SettingsGetMapping func(value *glib.Variant) (result interface{}, ok bool)

//export gotk4_SettingsGetMapping
func gotk4_SettingsGetMapping(arg0 *C.GVariant, arg1 *C.gpointer, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var value *glib.Variant

	value = glib.WrapVariant(arg0)

	result, ok := v.(SettingsGetMapping)(value)
}

// SocketSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_socket_create_source().
type SocketSourceFunc func(socket Socket, condition glib.IOCondition) bool

//export gotk4_SocketSourceFunc
func gotk4_SocketSourceFunc(arg0 *C.GSocket, arg1 C.GIOCondition, arg2 C.gpointer) C.gboolean {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var socket Socket
	var condition glib.IOCondition

	socket = WrapSocket(externglib.Take(unsafe.Pointer(arg0.Native())))

	condition = glib.IOCondition(arg1)

	ok := v.(SocketSourceFunc)(socket, condition)
}

// VfsFileLookupFunc: this function type is used by g_vfs_register_uri_scheme()
// to make it possible for a client to associate an URI scheme to a different
// #GFile implementation.
//
// The client should return a reference to the new file that has been created
// for @uri, or nil to continue with the default implementation.
type VfsFileLookupFunc func(vfs Vfs, identifier string) File

//export gotk4_VfsFileLookupFunc
func gotk4_VfsFileLookupFunc(arg0 *C.GVfs, arg1 *C.char, arg2 C.gpointer) *C.GFile {
	v := box.Get(box.Callback, uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var vfs Vfs
	var identifier string

	vfs = WrapVfs(externglib.Take(unsafe.Pointer(arg0.Native())))

	identifier = C.GoString(arg1)

	file := v.(VfsFileLookupFunc)(vfs, identifier)
}

// ActionNameIsValid checks if @action_name is valid.
//
// @action_name is valid if it consists only of alphanumeric characters, plus
// '-' and '.'. The empty string is not a valid action name.
//
// It is an error to call this function with a non-utf8 @action_name.
// @action_name must not be nil.
func ActionNameIsValid(actionName string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_name_is_valid(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ActionParseDetailedName parses a detailed action name into its separate name
// and target components.
//
// Detailed action names can have three formats.
//
// The first format is used to represent an action name with no target value and
// consists of just an action name containing no whitespace nor the characters
// ':', '(' or ')'. For example: "app.action".
//
// The second format is used to represent an action with a target value that is
// a non-empty string consisting only of alphanumerics, plus '-' and '.'. In
// that case, the action name and target value are separated by a double colon
// ("::"). For example: "app.action::target".
//
// The third format is used to represent an action with any type of target
// value, including strings. The target value follows the action name,
// surrounded in parens. For example: "app.action(42)". The target value is
// parsed using g_variant_parse(). If a tuple-typed value is desired, it must be
// specified in the same way, resulting in two sets of parens, for example:
// "app.action((1,2,3))". A string target can be specified this way as well:
// "app.action('target')". For strings, this third format must be used if *
// target value is empty or contains characters other than alphanumerics, '-'
// and '.'.
func ActionParseDetailedName(detailedName string) (actionName string, targetValue *glib.Variant, ok bool) {
	var arg1 *C.gchar
	var arg2 **C.gchar    // out
	var arg3 **C.GVariant // out

	arg1 = (*C.gchar)(C.CString(detailedName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_parse_detailed_name(arg1, &arg2, &arg3)

	var ret0 string
	var ret1 **glib.Variant
	var ret2 bool

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = glib.WrapVariant(arg3)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ActionPrintDetailedName formats a detailed action name from @action_name and
// @target_value.
//
// It is an error to call this function with an invalid action name.
//
// This function is the opposite of g_action_parse_detailed_name(). It will
// produce a string that can be parsed back to the @action_name and
// @target_value by that function.
//
// See that function for the types of strings that will be printed by this
// function.
func ActionPrintDetailedName(actionName string, targetValue *glib.Variant) string {
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(targetValue.Native())

	ret := C.g_action_print_detailed_name(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AppInfoGetAll gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have `NoDisplay=true` set
// or are excluded from display by means of `OnlyShowIn` or `NotShowIn`. See
// g_app_info_should_show(). The returned list does not include applications
// which have the `Hidden` key set.
func AppInfoGetAll() *glib.List {

	ret := C.g_app_info_get_all()

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetAllForType gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
func AppInfoGetAllForType(contentType string) *glib.List {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_app_info_get_all_for_type(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetFallbackForType gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
func AppInfoGetFallbackForType(contentType string) *glib.List {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_app_info_get_fallback_for_type(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoGetRecommendedForType gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
func AppInfoGetRecommendedForType(contentType string) *glib.List {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_app_info_get_recommended_for_type(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Bus–activated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
func AppInfoLaunchDefaultForURI(uri string, context AppLaunchContext) bool {
	var arg1 *C.char
	var arg2 *C.GAppLaunchContext

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GAppLaunchContext)(context.Native())

	ret := C.g_app_info_launch_default_for_uri(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AppInfoLaunchDefaultForURIAsync: async version of
// g_app_info_launch_default_for_uri().
//
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
//
// This is also useful if you want to be sure that the D-Bus–activated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForURIAsync(uri string, context AppLaunchContext, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg1 *C.char
	var arg2 *C.GAppLaunchContext
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GAppLaunchContext)(context.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_app_info_launch_default_for_uri_async(arg1, arg2, arg3, arg4)
}

// AppInfoResetTypeAssociations removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
func AppInfoResetTypeAssociations(contentType string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	C.g_app_info_reset_type_associations(arg1)
}

// BusGet: asynchronously connects to the message bus specified by @bus_type.
//
// When the operation is finished, @callback will be invoked. You can then call
// g_bus_get_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See g_bus_get_sync() for the
// synchronous version.
func BusGet(busType BusType, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg1 C.GBusType
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg1 = (C.GBusType)(busType)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_bus_get(arg1, arg2, arg3)
}

// BusGetSync: synchronously connects to the message bus specified by @bus_type.
// Note that the returned object may shared with other callers, e.g. if two
// separate parts of a process calls this function with the same @bus_type, they
// will share the same object.
//
// This is a synchronous failable function. See g_bus_get() and
// g_bus_get_finish() for the asynchronous version.
//
// The returned object is a singleton, that is, shared with other callers of
// g_bus_get() and g_bus_get_sync() for @bus_type. In the event that you need a
// private message bus connection, use g_dbus_address_get_for_bus_sync() and
// g_dbus_connection_new_for_address().
//
// Note that the returned BusConnection object will (usually) have the
// BusConnection:exit-on-close property set to true.
func BusGetSync(busType BusType, cancellable Cancellable) DBusConnection {
	var arg1 C.GBusType
	var arg2 *C.GCancellable

	arg1 = (C.GBusType)(busType)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_bus_get_sync(arg1, arg2)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BusOwnNameOnConnectionWithClosures: version of g_bus_own_name_on_connection()
// using closures instead of callbacks for easier binding in other languages.
func BusOwnNameOnConnectionWithClosures(connection DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint {
	var arg1 *C.GDBusConnection
	var arg2 *C.gchar
	var arg3 C.GBusNameOwnerFlags
	var arg4 *C.GClosure
	var arg5 *C.GClosure

	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GBusNameOwnerFlags)(flags)

	ret := C.g_bus_own_name_on_connection_with_closures(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// BusOwnNameWithClosures: version of g_bus_own_name() using closures instead of
// callbacks for easier binding in other languages.
func BusOwnNameWithClosures(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredClosure *externglib.Closure, nameAcquiredClosure *externglib.Closure, nameLostClosure *externglib.Closure) uint {
	var arg1 C.GBusType
	var arg2 *C.gchar
	var arg3 C.GBusNameOwnerFlags
	var arg4 *C.GClosure
	var arg5 *C.GClosure
	var arg6 *C.GClosure

	arg1 = (C.GBusType)(busType)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GBusNameOwnerFlags)(flags)

	ret := C.g_bus_own_name_with_closures(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// BusUnownName stops owning a name.
//
// Note that there may still be D-Bus traffic to process (relating to owning and
// unowning the name) in the current thread-default Context after this function
// has returned. You should continue to iterate the Context until the Notify
// function passed to g_bus_own_name() is called, in order to avoid memory leaks
// through callbacks queued on the Context after it’s stopped being iterated.
func BusUnownName(ownerID uint) {
	var arg1 C.guint

	arg1 = C.guint(ownerID)

	C.g_bus_unown_name(arg1)
}

// BusUnwatchName stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after it’s stopped being
// iterated.
func BusUnwatchName(watcherID uint) {
	var arg1 C.guint

	arg1 = C.guint(watcherID)

	C.g_bus_unwatch_name(arg1)
}

// BusWatchNameOnConnectionWithClosures: version of
// g_bus_watch_name_on_connection() using closures instead of callbacks for
// easier binding in other languages.
func BusWatchNameOnConnectionWithClosures(connection DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint {
	var arg1 *C.GDBusConnection
	var arg2 *C.gchar
	var arg3 C.GBusNameWatcherFlags
	var arg4 *C.GClosure
	var arg5 *C.GClosure

	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GBusNameWatcherFlags)(flags)

	ret := C.g_bus_watch_name_on_connection_with_closures(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// BusWatchNameWithClosures: version of g_bus_watch_name() using closures
// instead of callbacks for easier binding in other languages.
func BusWatchNameWithClosures(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedClosure *externglib.Closure, nameVanishedClosure *externglib.Closure) uint {
	var arg1 C.GBusType
	var arg2 *C.gchar
	var arg3 C.GBusNameWatcherFlags
	var arg4 *C.GClosure
	var arg5 *C.GClosure

	arg1 = (C.GBusType)(busType)
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GBusNameWatcherFlags)(flags)

	ret := C.g_bus_watch_name_with_closures(arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ContentTypeCanBeExecutable checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(_type string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_can_be_executable(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeEquals compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(type1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(type2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_equals(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
func ContentTypeFromMIMEType(mimeType string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_from_mime_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetDescription gets the human readable description of the content
// type.
func ContentTypeGetDescription(_type string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_description(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetGenericIconName gets the generic icon name for a content type.
//
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(_type string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_generic_icon_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMIMEDirs() []string {

	ret := C.g_content_type_get_mime_dirs()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMIMEType(_type string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_mime_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeIsA determines if @type is a subset of @supertype.
func ContentTypeIsA(_type string, supertype string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(supertype))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_is_a(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeIsMIMEType determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMIMEType(_type string, mimeType string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_is_mime_type(arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(_type string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(_type))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_is_unknown(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
//    - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//    - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the system’s MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      …
//
//      return g_test_run ();
//
func ContentTypeSetMIMEDirs(dirs []string) {
	var arg1 **C.gchar

	{

	}

	C.g_content_type_set_mime_dirs(arg1)
}

// ContentTypesGetRegistered gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() *glib.List {

	ret := C.g_content_types_get_registered()

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// DBusAddressEscapeValue: escape @string so it can appear in a D-Bus address as
// the value part of a key-value pair.
//
// For instance, if @string is `/run/bus-for-:0`, this function would return
// `/run/bus-for-3A0`, which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-3A0`.
func DBusAddressEscapeValue(string string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_address_escape_value(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusAddressGetForBusSync: synchronously looks up the D-Bus address for the
// well-known message bus instance specified by @bus_type. This may involve
// using various platform specific mechanisms.
//
// The returned address will be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusAddressGetForBusSync(busType BusType, cancellable Cancellable) string {
	var arg1 C.GBusType
	var arg2 *C.GCancellable

	arg1 = (C.GBusType)(busType)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_address_get_for_bus_sync(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusAddressGetStream: asynchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// When the operation is finished, @callback will be invoked. You can then call
// g_dbus_address_get_stream_finish() to get the result of the operation.
//
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DBusAddressGetStream(address string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg1 *C.gchar
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_address_get_stream(arg1, arg2, arg3)
}

// DBusAddressGetStreamSync: synchronously connects to an endpoint specified by
// @address and sets up the connection so it is in a state to run the
// client-side of the D-Bus authentication conversation. @address must be in the
// D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This is a synchronous failable function. See g_dbus_address_get_stream() for
// the asynchronous version.
func DBusAddressGetStreamSync(address string, cancellable Cancellable) (outGuid string, ioStream IOStream) {
	var arg1 *C.gchar
	var arg2 **C.gchar // out
	var arg3 *C.GCancellable

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_address_get_stream_sync(arg1, &arg2, arg3)

	var ret0 string
	var ret1 IOStream

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = WrapIOStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// DBusAnnotationInfoLookup looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
func DBusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string {
	var arg1 **C.GDBusAnnotationInfo
	var arg2 *C.gchar

	{

	}
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dbus_annotation_info_lookup(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DBusErrorEncodeGerror creates a D-Bus error name to use for @error. If @error
// matches a registered error (cf. g_dbus_error_register_error()), the
// corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE` will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
func DBusErrorEncodeGerror(error *glib.Error) string {
	var arg1 *C.GError

	arg1 = (*C.GError)(error.Native())

	ret := C.g_dbus_error_encode_gerror(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusErrorGetRemoteError gets the D-Bus error name used for @error, if any.
//
// This function is guaranteed to return a D-Bus error name for all #GErrors
// returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on @error.
func DBusErrorGetRemoteError(error *glib.Error) string {
	var arg1 *C.GError

	arg1 = (*C.GError)(error.Native())

	ret := C.g_dbus_error_get_remote_error(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusErrorIsRemoteError checks if @error represents an error received via
// D-Bus from a remote peer. If so, use g_dbus_error_get_remote_error() to get
// the name of the error.
func DBusErrorIsRemoteError(error *glib.Error) bool {
	var arg1 *C.GError

	arg1 = (*C.GError)(error.Native())

	ret := C.g_dbus_error_is_remote_error(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusErrorNewForDBusError creates a #GError based on the contents of
// @dbus_error_name and @dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up using
// @dbus_error_name and if a match is found, the error domain and code is used.
// Applications can use g_dbus_error_get_remote_error() to recover
// @dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error name
// is in a form as returned by g_dbus_error_encode_gerror() the error domain and
// code encoded in the name is used to create the #GError. Also,
// @dbus_error_name is added to the error message such that it can be recovered
// with g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in the
// IO_ERROR error domain is returned. Also, @dbus_error_name is added to the
// error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, @dbus_error_name can always be recovered from the
// returned #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
func DBusErrorNewForDBusError(dbusErrorName string, dbusErrorMessage string) *glib.Error {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(dbusErrorName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(dbusErrorMessage))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dbus_error_new_for_dbus_error(arg1, arg2)

	var ret0 *glib.Error

	ret0 = glib.WrapError(ret)

	return ret0
}

func DBusErrorQuark() glib.Quark {

	ret := C.g_dbus_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// DBusErrorStripRemoteError looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped, the
// message field in @error will correspond exactly to what was received on the
// wire.
//
// This is typically used when presenting errors to the end user.
func DBusErrorStripRemoteError(error *glib.Error) bool {
	var arg1 *C.GError

	arg1 = (*C.GError)(error.Native())

	ret := C.g_dbus_error_strip_remote_error(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusGenerateGuid() string {

	ret := C.g_dbus_generate_guid()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusGValueToGvariant converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DBusGValueToGvariant(gvalue *externglib.Value, _type *glib.VariantType) *glib.Variant {
	var arg1 *C.GValue
	var arg2 *C.GVariantType

	arg1 = (*C.GValue)(gvalue.GValue)
	arg2 = (*C.GVariantType)(_type.Native())

	ret := C.g_dbus_gvalue_to_gvariant(arg1, arg2)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// DBusIsAddress checks if @string is a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This doesn't check if @string is actually supported by BusServer or
// BusConnection - use g_dbus_is_supported_address() to do more checks.
func DBusIsAddress(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_address(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsGuid checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusIsGuid(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_guid(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsInterfaceName checks if @string is a valid D-Bus interface name.
func DBusIsInterfaceName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_interface_name(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DBusIsMemberName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_member_name(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DBusIsName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_name(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsSupportedAddress: like g_dbus_is_address() but also checks if the
// library supports the transports in @string and that key/value pairs for each
// transport are valid. See the specification of the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusIsSupportedAddress(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_supported_address(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusIsUniqueName checks if @string is a valid D-Bus unique bus name.
func DBusIsUniqueName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_unique_name(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IconHash gets a hash for an icon.
func IconHash(icon interface{}) uint {
	var arg1 C.gpointer

	arg1 = C.gpointer(box.Assign(icon))

	ret := C.g_icon_hash(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IOErrorFromErrno converts errno.h error codes into GIO error codes. The
// fallback value G_IO_ERROR_FAILED is returned for error codes not currently
// handled (but note that future GLib releases may return a more specific value
// instead).
//
// As errno is global and may be modified by intermediate function calls, you
// should save its value as soon as the call which sets it
func IOErrorFromErrno(errNo int) IOErrorEnum {
	var arg1 C.gint

	arg1 = C.gint(errNo)

	ret := C.g_io_error_from_errno(arg1)

	var ret0 IOErrorEnum

	ret0 = IOErrorEnum(ret)

	return ret0
}

// IOErrorQuark gets the GIO Error Quark.
func IOErrorQuark() glib.Quark {

	ret := C.g_io_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// IOExtensionPointImplement registers @type as extension for the extension
// point with name @extension_point_name.
//
// If @type has already been registered as an extension for this extension
// point, the existing OExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, _type externglib.Type, extensionName string, priority int) *IOExtension {
	var arg1 *C.char
	var arg2 C.GType
	var arg3 *C.char
	var arg4 C.gint

	arg1 = (*C.gchar)(C.CString(extensionPointName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(_type)
	arg3 = (*C.gchar)(C.CString(extensionName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint(priority)

	ret := C.g_io_extension_point_implement(arg1, arg2, arg3, arg4)

	var ret0 *IOExtension

	ret0 = WrapIOExtension(ret)

	return ret0
}

// IOExtensionPointLookup looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_io_extension_point_lookup(arg1)

	var ret0 *IOExtensionPoint

	ret0 = WrapIOExtensionPoint(ret)

	return ret0
}

// IOExtensionPointRegister registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_io_extension_point_register(arg1)

	var ret0 *IOExtensionPoint

	ret0 = WrapIOExtensionPoint(ret)

	return ret0
}

// IOModulesLoadAllInDirectory loads all the modules in the specified directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectory(dirname string) *glib.List {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_io_modules_load_all_in_directory(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// IOModulesLoadAllInDirectoryWithScope loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List {
	var arg1 *C.gchar
	var arg2 *C.GIOModuleScope

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GIOModuleScope)(scope.Native())

	ret := C.g_io_modules_load_all_in_directory_with_scope(arg1, arg2)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string) {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))

	C.g_io_modules_scan_all_in_directory(arg1)
}

// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var arg1 *C.gchar
	var arg2 *C.GIOModuleScope

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GIOModuleScope)(scope.Native())

	C.g_io_modules_scan_all_in_directory_with_scope(arg1, arg2)
}

// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs() {

	C.g_io_scheduler_cancel_all_jobs()
}

// IOSchedulerPushJob schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned, regardless
// whether the job was cancelled or has run to completion.
//
// If @cancellable is not nil, it can be used to cancel the I/O job by calling
// g_cancellable_cancel() or by calling g_io_scheduler_cancel_all_jobs().
func IOSchedulerPushJob(jobFunc IOSchedulerJobFunc, ioPriority int, cancellable Cancellable) {
	var arg1 C.GIOSchedulerJobFunc
	arg2 := C.gpointer(box.Assign(userData))
	var arg4 C.gint
	var arg5 *C.GCancellable

	arg1 = (*[0]byte)(C.gotk4_IOSchedulerJobFunc)
	arg4 = C.gint(ioPriority)
	arg5 = (*C.GCancellable)(cancellable.Native())

	C.g_io_scheduler_push_job(arg1, (*[0]byte)(C.callbackDelete), arg4, arg5)
}

// NewKeyfileSettingsBackend creates a keyfile-backed Backend.
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the path
// given in @root_path (which must start and end with a slash and not contain
// two consecutive slashes). @root_path may be "/".
//
// If @root_group is non-nil then it specifies the name of the keyfile group
// used for keys that are written directly below @root_path. For example, if
// @root_path is "/apps/example/" and @root_group is "toplevel", then settings
// the key "/apps/example/enabled" to a value of true will cause the following
// to appear in the keyfile:
//
//
//      [toplevel]
//      enabled=true
//    ]|
//
//    If @root_group is nil then it is not permitted to store keys
//    directly below the @root_path.
//
//    For keys not stored directly below @root_path (ie: in a sub-path),
//    the name of the subpath (with the final slash stripped) is used as
//    the name of the keyfile group.  To continue the example, if
//    "/apps/example/profiles/default/font-size" were set to
//    12 then the following would appear in the keyfile:
//
//    |[
//      [profiles/default]
//      font-size=12
//
//
// The backend will refuse writes (and return writability as being false) for
// keys outside of @root_path and, in the event that @root_group is nil, also
// for keys directly under @root_path. Writes will also be refused if the
// backend detects that it has the inability to rewrite the keyfile (ie: the
// containing directory is not writable).
//
// There is no checking done for your key namespace clashing with the syntax of
// the key file format. For example, if you have '[' or ']' characters in your
// path names or '=' in your key names you may be in trouble.
//
// The backend reads default values from a keyfile called `defaults` in the
// directory specified by the SettingsBackend:defaults-dir property, and a list
// of locked keys from a text file with the name `locks` in the same location.
func NewKeyfileSettingsBackend(filename string, rootPath string, rootGroup string) SettingsBackend {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(rootPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(rootGroup))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_keyfile_settings_backend_new(arg1, arg2, arg3)

	var ret0 SettingsBackend

	ret0 = WrapSettingsBackend(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMemorySettingsBackend creates a memory-backed Backend.
//
// This backend allows changes to settings, but does not write them to any
// backing storage, so the next time you run your application, the memory
// backend will start out with the default values again.
func NewMemorySettingsBackend() SettingsBackend {

	ret := C.g_memory_settings_backend_new()

	var ret0 SettingsBackend

	ret0 = WrapSettingsBackend(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NetworkingInit initializes the platform networking libraries (eg, on Windows,
// this calls WSAStartup()). GLib will call this itself if it is needed, so you
// only need to call it if you directly call system networking functions
// (without calling any GLib networking functions first).
func NetworkingInit() {

	C.g_networking_init()
}

// NewNullSettingsBackend creates a readonly Backend.
//
// This backend does not allow changes to settings, so all settings will always
// have their default values.
func NewNullSettingsBackend() SettingsBackend {

	ret := C.g_null_settings_backend_new()

	var ret0 SettingsBackend

	ret0 = WrapSettingsBackend(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewPollableSource: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource that expects a callback of type
// SourceFunc. The new source does not actually do anything on its own; use
// g_source_add_child_source() to add other sources to it to cause it to
// trigger.
func NewPollableSource(pollableStream gextras.Objector) *glib.Source {
	var arg1 *C.GObject

	arg1 = (*C.GObject)(pollableStream.Native())

	ret := C.g_pollable_source_new(arg1)

	var ret0 *glib.Source

	ret0 = glib.WrapSource(ret)

	return ret0
}

// PollableSourceNewFull: utility method for InputStream and OutputStream
// implementations. Creates a new #GSource, as with g_pollable_source_new(), but
// also attaching @child_source (with a dummy callback), and @cancellable, if
// they are non-nil.
func PollableSourceNewFull(pollableStream gextras.Objector, childSource *glib.Source, cancellable Cancellable) *glib.Source {
	var arg1 C.gpointer
	var arg2 *C.GSource
	var arg3 *C.GCancellable

	arg1 = (*C.GObject)(pollableStream.Native())
	arg2 = (*C.GSource)(childSource.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_pollable_source_new_full(arg1, arg2, arg3)

	var ret0 *glib.Source

	ret0 = glib.WrapSource(ret)

	return ret0
}

// ResolverErrorQuark gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {

	ret := C.g_resolver_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// ResourceErrorQuark gets the #GResource Error Quark.
func ResourceErrorQuark() glib.Quark {

	ret := C.g_resource_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// ResourceLoad loads a binary resource bundle and creates a #GResource
// representation of it, allowing you to query it for data.
//
// If you want to use this resource in the global resource namespace you need to
// register it with g_resources_register().
//
// If @filename is empty or the data in it is corrupt, G_RESOURCE_ERROR_INTERNAL
// will be returned. If @filename doesn’t exist, or there is an error in reading
// it, an error from g_mapped_file_new() will be returned.
func ResourceLoad(filename string) *Resource {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_resource_load(arg1)

	var ret0 *Resource

	ret0 = WrapResource(ret)

	return ret0
}

// ResourcesEnumerateChildren returns all the names of children at the specified
// @path in the set of globally registered resources. The return result is a nil
// terminated list of strings which should be released with g_strfreev().
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) []string {
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resources_enumerate_children(arg1, arg2)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ResourcesGetInfo looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (size uint, flags uint32, ok bool) {
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags
	var arg3 *C.gsize   // out
	var arg4 *C.guint32 // out

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resources_get_info(arg1, arg2, &arg3, &arg4)

	var ret0 uint
	var ret1 uint32
	var ret2 bool

	ret0 = uint(arg3)

	ret1 = uint32(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// ResourcesLookupData looks for a file at the specified @path in the set of
// globally registered resources and returns a #GBytes that lets you directly
// access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) *glib.Bytes {
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resources_lookup_data(arg1, arg2)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// ResourcesOpenStream looks for a file at the specified @path in the set of
// globally registered resources and returns a Stream that lets you read the
// data.
//
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) InputStream {
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resources_open_stream(arg1, arg2)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ResourcesRegister registers the resource with the process-global set of
// resources. Once a resource is registered the files in it can be accessed with
// the global resource lookup functions like g_resources_lookup_data().
func ResourcesRegister(resource *Resource) {
	var arg1 *C.GResource

	arg1 = (*C.GResource)(resource.Native())

	C.g_resources_register(arg1)
}

// ResourcesUnregister unregisters the resource from the process-global set of
// resources.
func ResourcesUnregister(resource *Resource) {
	var arg1 *C.GResource

	arg1 = (*C.GResource)(resource.Native())

	C.g_resources_unregister(arg1)
}

// SettingsSchemaSourceGetDefault gets the default system schema source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If no schemas are installed, nil will be returned.
//
// The returned source may actually consist of multiple schema sources from
// different directories, depending on which directories were given in
// `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all lookups
// performed against the default source should probably be done recursively.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {

	ret := C.g_settings_schema_source_get_default()

	var ret0 *SettingsSchemaSource

	ret0 = WrapSettingsSchemaSource(ret)

	return ret0
}

// SimpleAsyncReportGerrorInIdle reports an error in an idle function. Similar
// to g_simple_async_report_error_in_idle(), but takes a #GError rather than
// building a new one.
func SimpleAsyncReportGerrorInIdle(object gextras.Objector, callback AsyncReadyCallback, error *glib.Error) {
	var arg1 *C.GObject
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))
	var arg4 *C.GError

	arg1 = (*C.GObject)(object.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = (*C.GError)(error.Native())

	C.g_simple_async_report_gerror_in_idle(arg1, arg2, arg4)
}

// SimpleAsyncReportTakeGerrorInIdle reports an error in an idle function.
// Similar to g_simple_async_report_gerror_in_idle(), but takes over the
// caller's ownership of @error, so the caller does not have to free it any
// more.
func SimpleAsyncReportTakeGerrorInIdle(object gextras.Objector, callback AsyncReadyCallback, error *glib.Error) {
	var arg1 *C.GObject
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))
	var arg4 *C.GError

	arg1 = (*C.GObject)(object.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = (*C.GError)(error.Native())

	C.g_simple_async_report_take_gerror_in_idle(arg1, arg2, arg4)
}

// SrvTargetListSort sorts @targets in place according to the algorithm in RFC
// 2782.
func SrvTargetListSort(targets *glib.List) *glib.List {
	var arg1 *C.GList

	arg1 = (*C.GList)(targets.Native())

	ret := C.g_srv_target_list_sort(arg1)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// TLSChannelBindingErrorQuark gets the TLS channel binding error quark.
func TLSChannelBindingErrorQuark() glib.Quark {

	ret := C.g_tls_channel_binding_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// TLSErrorQuark gets the TLS error quark.
func TLSErrorQuark() glib.Quark {

	ret := C.g_tls_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// UnixIsMountPathSystemInternal determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_mount_path_system_internal(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixIsSystemDevicePath determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered ‘system’ ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(devicePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_system_device_path(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixIsSystemFSType determines if @fs_type is considered a type of file system
// which is only used in implementation of the OS. This is primarily used for
// hiding mounted volumes that are intended as APIs for programs to read, and
// system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered ‘system’ ones may change over time.
func UnixIsSystemFSType(fsType string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(fsType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_system_fs_type(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountAt gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_at(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountEntry

	ret0 = uint64(arg2)

	ret1 = WrapUnixMountEntry(ret)

	return ret0, ret1
}

// UnixMountCompare compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int {
	var arg1 *C.GUnixMountEntry
	var arg2 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mount1.Native())
	arg2 = (*C.GUnixMountEntry)(mount2.Native())

	ret := C.g_unix_mount_compare(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnixMountCopy makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_copy(arg1)

	var ret0 *UnixMountEntry

	ret0 = WrapUnixMountEntry(ret)

	return ret0
}

// UnixMountFor gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(filePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_for(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountEntry

	ret0 = uint64(arg2)

	ret1 = WrapUnixMountEntry(ret)

	return ret0, ret1
}

// UnixMountFree frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry) {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	C.g_unix_mount_free(arg1)
}

// UnixMountGetDevicePath gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_device_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetFSType gets the filesystem type for the unix mount.
func UnixMountGetFSType(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_fs_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetMountPath gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_mount_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetOptions gets a comma-separated list of mount options for the unix
// mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_options(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetRootPath gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_root_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGuessCanEject guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_can_eject(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountGuessName guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGuessShouldDisplay guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_should_display(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountIsReadonly checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_is_readonly(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountIsSystemInternal checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entry’s properties.
//
// The definition of what a ‘system’ mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_is_system_internal(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountPointAt gets a MountPoint for a given mount path. If @time_read is
// set, it will be filled with a unix timestamp for checking if the mount points
// have changed since with g_unix_mount_points_changed_since().
//
// If more mount points have the same mount path, the last matching mount point
// is returned.
func UnixMountPointAt(mountPath string) (timeRead uint64, unixMountPoint *UnixMountPoint) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_point_at(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountPoint

	ret0 = uint64(arg2)

	ret1 = WrapUnixMountPoint(ret)

	return ret0, ret1
}

// UnixMountPointsChangedSince checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool {
	var arg1 C.guint64

	arg1 = C.guint64(time)

	ret := C.g_unix_mount_points_changed_since(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountPointsGet gets a #GList of MountPoint containing the unix mount
// points. If @time_read is set, it will be filled with the mount timestamp,
// allowing for checking if the mounts have changed with
// g_unix_mount_points_changed_since().
func UnixMountPointsGet() (timeRead uint64, list *glib.List) {
	var arg1 *C.guint64 // out

	ret := C.g_unix_mount_points_get(&arg1)

	var ret0 uint64
	var ret1 *glib.List

	ret0 = uint64(arg1)

	ret1 = glib.WrapList(ret)

	return ret0, ret1
}

// UnixMountsChangedSince checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool {
	var arg1 C.guint64

	arg1 = C.guint64(time)

	ret := C.g_unix_mounts_changed_since(arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixMountsGet gets a #GList of MountEntry containing the unix mounts. If
// @time_read is set, it will be filled with the mount timestamp, allowing for
// checking if the mounts have changed with g_unix_mounts_changed_since().
func UnixMountsGet() (timeRead uint64, list *glib.List) {
	var arg1 *C.guint64 // out

	ret := C.g_unix_mounts_get(&arg1)

	var ret0 uint64
	var ret1 *glib.List

	ret0 = uint64(arg1)

	ret1 = glib.WrapList(ret)

	return ret0, ret1
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
type Icon interface {
	gextras.Objector

	// _ checks if two icons are equal.
	_(icon2 Icon) bool
}

func WrapIcon(obj *externglib.Object) Icon {
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	native C.GDBusAnnotationInfo
}

// WrapDBusAnnotationInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusAnnotationInfo(ptr unsafe.Pointer) *DBusAnnotationInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusAnnotationInfo)(ptr)
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusAnnotationInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusAnnotationInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Key gets the field inside the struct.
func (k *DBusAnnotationInfo) Key() string {
	var ret string
	ret = C.GoString(d.native.key)
	return ret
}

// Value gets the field inside the struct.
func (v *DBusAnnotationInfo) Value() string {
	var ret string
	ret = C.GoString(d.native.value)
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusAnnotationInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusAnnotationInfo) Ref() *DBusAnnotationInfo {
	var arg0 *C.GDBusAnnotationInfo

	arg0 = (*C.GDBusAnnotationInfo)(info.Native())

	ret := C.g_dbus_annotation_info_ref(arg0)

	var ret0 *DBusAnnotationInfo

	ret0 = WrapDBusAnnotationInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusAnnotationInfo) Unref() {
	var arg0 *C.GDBusAnnotationInfo

	arg0 = (*C.GDBusAnnotationInfo)(info.Native())

	C.g_dbus_annotation_info_unref(arg0)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	native C.GDBusArgInfo
}

// WrapDBusArgInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusArgInfo(ptr unsafe.Pointer) *DBusArgInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusArgInfo)(ptr)
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusArgInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusArgInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Name gets the field inside the struct.
func (n *DBusArgInfo) Name() string {
	var ret string
	ret = C.GoString(d.native.name)
	return ret
}

// Signature gets the field inside the struct.
func (s *DBusArgInfo) Signature() string {
	var ret string
	ret = C.GoString(d.native.signature)
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusArgInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusArgInfo) Ref() *DBusArgInfo {
	var arg0 *C.GDBusArgInfo

	arg0 = (*C.GDBusArgInfo)(info.Native())

	ret := C.g_dbus_arg_info_ref(arg0)

	var ret0 *DBusArgInfo

	ret0 = WrapDBusArgInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusArgInfo) Unref() {
	var arg0 *C.GDBusArgInfo

	arg0 = (*C.GDBusArgInfo)(info.Native())

	C.g_dbus_arg_info_unref(arg0)
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
type DBusErrorEntry struct {
	native C.GDBusErrorEntry
}

// WrapDBusErrorEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusErrorEntry(ptr unsafe.Pointer) *DBusErrorEntry {
	if ptr == nil {
		return nil
	}

	return (*DBusErrorEntry)(ptr)
}

func marshalDBusErrorEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusErrorEntry(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusErrorEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// ErrorCode gets the field inside the struct.
func (e *DBusErrorEntry) ErrorCode() int {
	var ret int
	ret = int(d.native.error_code)
	return ret
}

// DBusErrorName gets the field inside the struct.
func (d *DBusErrorEntry) DBusErrorName() string {
	var ret string
	ret = C.GoString(d.native.dbus_error_name)
	return ret
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	native C.GDBusInterfaceInfo
}

// WrapDBusInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceInfo(ptr unsafe.Pointer) *DBusInterfaceInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusInterfaceInfo)(ptr)
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusInterfaceInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Name gets the field inside the struct.
func (n *DBusInterfaceInfo) Name() string {
	var ret string
	ret = C.GoString(d.native.name)
	return ret
}

// Methods gets the field inside the struct.
func (m *DBusInterfaceInfo) Methods() []*DBusMethodInfo {
	var ret []*DBusMethodInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.methods); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusMethodInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusMethodInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.methods)) + i))
			ret[i] = WrapDBusMethodInfo(src)
		}
	}
	return ret
}

// Signals gets the field inside the struct.
func (s *DBusInterfaceInfo) Signals() []*DBusSignalInfo {
	var ret []*DBusSignalInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.signals); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusSignalInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusSignalInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.signals)) + i))
			ret[i] = WrapDBusSignalInfo(src)
		}
	}
	return ret
}

// Properties gets the field inside the struct.
func (p *DBusInterfaceInfo) Properties() []*DBusPropertyInfo {
	var ret []*DBusPropertyInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.properties); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusPropertyInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusPropertyInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.properties)) + i))
			ret[i] = WrapDBusPropertyInfo(src)
		}
	}
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusInterfaceInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
//
// If this has already been called with @info, the existing cache is used and
// its use count is increased.
//
// Note that @info cannot be modified until
// g_dbus_interface_info_cache_release() is called.
func (info *DBusInterfaceInfo) CacheBuild() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())

	C.g_dbus_interface_info_cache_build(arg0)
}

// CacheRelease decrements the usage count for the cache for @info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
func (info *DBusInterfaceInfo) CacheRelease() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())

	C.g_dbus_interface_info_cache_release(arg0)
}

// GenerateXml appends an XML representation of @info (and its children) to
// @string_builder.
//
// This function is typically used for generating introspection XML documents at
// run-time for handling the `org.freedesktop.DBus.Introspectable.Introspect`
// method.
func (info *DBusInterfaceInfo) GenerateXml(indent uint, stringBuilder *glib.String) {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 C.guint
	var arg2 *C.GString

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())
	arg1 = C.guint(indent)
	arg2 = (*C.GString)(stringBuilder.Native())

	C.g_dbus_interface_info_generate_xml(arg0, arg1, arg2)
}

// LookupMethod looks up information about a method.
//
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (info *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_interface_info_lookup_method(arg0, arg1)

	var ret0 *DBusMethodInfo

	ret0 = WrapDBusMethodInfo(ret)

	return ret0
}

// LookupProperty looks up information about a property.
//
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (info *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_interface_info_lookup_property(arg0, arg1)

	var ret0 *DBusPropertyInfo

	ret0 = WrapDBusPropertyInfo(ret)

	return ret0
}

// LookupSignal looks up information about a signal.
//
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (info *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_interface_info_lookup_signal(arg0, arg1)

	var ret0 *DBusSignalInfo

	ret0 = WrapDBusSignalInfo(ret)

	return ret0
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusInterfaceInfo) Ref() *DBusInterfaceInfo {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())

	ret := C.g_dbus_interface_info_ref(arg0)

	var ret0 *DBusInterfaceInfo

	ret0 = WrapDBusInterfaceInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusInterfaceInfo) Unref() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(info.Native())

	C.g_dbus_interface_info_unref(arg0)
}

// DBusInterfaceVTable: virtual table for handling properties and method calls
// for a D-Bus interface.
//
// Since 2.38, if you want to handle getting/setting D-Bus properties
// asynchronously, give nil as your get_property() or set_property() function.
// The D-Bus call will be directed to your @method_call function, with the
// provided @interface_name set to "org.freedesktop.DBus.Properties".
//
// Ownership of the BusMethodInvocation object passed to the method_call()
// function is transferred to your handler; you must call one of the methods of
// BusMethodInvocation to return a reply (possibly empty), or an error. These
// functions also take ownership of the passed-in invocation object, so unless
// the invocation object has otherwise been referenced, it will be then be
// freed. Calling one of these functions may be done within your method_call()
// implementation but it also can be done at a later point to handle the method
// asynchronously.
//
// The usual checks on the validity of the calls is performed. For `Get` calls,
// an error is automatically returned if the property does not exist or the
// permissions do not allow access. The same checks are performed for `Set`
// calls, and the provided value is also checked for being the correct type.
//
// For both `Get` and `Set` calls, the BusMethodInvocation passed to the
// @method_call handler can be queried with
// g_dbus_method_invocation_get_property_info() to get a pointer to the
// BusPropertyInfo of the property.
//
// If you have readable properties specified in your interface info, you must
// ensure that you either provide a non-nil @get_property() function or provide
// implementations of both the `Get` and `GetAll` methods on
// org.freedesktop.DBus.Properties interface in your @method_call function. Note
// that the required return type of the `Get` call is `(v)`, not the type of the
// property. `GetAll` expects a return value of type `a{sv}`.
//
// If you have writable properties specified in your interface info, you must
// ensure that you either provide a non-nil @set_property() function or provide
// an implementation of the `Set` call. If implementing the call, you must
// return the value of type G_VARIANT_TYPE_UNIT.
type DBusInterfaceVTable struct {
	native C.GDBusInterfaceVTable
}

// WrapDBusInterfaceVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceVTable(ptr unsafe.Pointer) *DBusInterfaceVTable {
	if ptr == nil {
		return nil
	}

	return (*DBusInterfaceVTable)(ptr)
}

func marshalDBusInterfaceVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceVTable(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusInterfaceVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	native C.GDBusMethodInfo
}

// WrapDBusMethodInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusMethodInfo(ptr unsafe.Pointer) *DBusMethodInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusMethodInfo)(ptr)
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusMethodInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusMethodInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Name gets the field inside the struct.
func (n *DBusMethodInfo) Name() string {
	var ret string
	ret = C.GoString(d.native.name)
	return ret
}

// InArgs gets the field inside the struct.
func (i *DBusMethodInfo) InArgs() []*DBusArgInfo {
	var ret []*DBusArgInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.in_args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.in_args)) + i))
			ret[i] = WrapDBusArgInfo(src)
		}
	}
	return ret
}

// OutArgs gets the field inside the struct.
func (o *DBusMethodInfo) OutArgs() []*DBusArgInfo {
	var ret []*DBusArgInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.out_args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.out_args)) + i))
			ret[i] = WrapDBusArgInfo(src)
		}
	}
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusMethodInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusMethodInfo) Ref() *DBusMethodInfo {
	var arg0 *C.GDBusMethodInfo

	arg0 = (*C.GDBusMethodInfo)(info.Native())

	ret := C.g_dbus_method_info_ref(arg0)

	var ret0 *DBusMethodInfo

	ret0 = WrapDBusMethodInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusMethodInfo) Unref() {
	var arg0 *C.GDBusMethodInfo

	arg0 = (*C.GDBusMethodInfo)(info.Native())

	C.g_dbus_method_info_unref(arg0)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	native C.GDBusNodeInfo
}

// WrapDBusNodeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusNodeInfo(ptr unsafe.Pointer) *DBusNodeInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusNodeInfo)(ptr)
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusNodeInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// NewDBusNodeInfoForXml constructs a struct DBusNodeInfo.
func NewDBusNodeInfoForXml(xmlData string) *DBusNodeInfo {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(xmlData))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_node_info_new_for_xml(arg1)

	var ret0 *DBusNodeInfo

	ret0 = WrapDBusNodeInfo(ret)

	return ret0
}

// RefCount gets the field inside the struct.
func (r *DBusNodeInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Path gets the field inside the struct.
func (p *DBusNodeInfo) Path() string {
	var ret string
	ret = C.GoString(d.native.path)
	return ret
}

// Interfaces gets the field inside the struct.
func (i *DBusNodeInfo) Interfaces() []*DBusInterfaceInfo {
	var ret []*DBusInterfaceInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.interfaces); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusInterfaceInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusInterfaceInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.interfaces)) + i))
			ret[i] = WrapDBusInterfaceInfo(src)
		}
	}
	return ret
}

// Nodes gets the field inside the struct.
func (n *DBusNodeInfo) Nodes() []*DBusNodeInfo {
	var ret []*DBusNodeInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.nodes); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusNodeInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusNodeInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.nodes)) + i))
			ret[i] = WrapDBusNodeInfo(src)
		}
	}
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusNodeInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// GenerateXml appends an XML representation of @info (and its children) to
// @string_builder.
//
// This function is typically used for generating introspection XML documents at
// run-time for handling the `org.freedesktop.DBus.Introspectable.Introspect`
// method.
func (info *DBusNodeInfo) GenerateXml(indent uint, stringBuilder *glib.String) {
	var arg0 *C.GDBusNodeInfo
	var arg1 C.guint
	var arg2 *C.GString

	arg0 = (*C.GDBusNodeInfo)(info.Native())
	arg1 = C.guint(indent)
	arg2 = (*C.GString)(stringBuilder.Native())

	C.g_dbus_node_info_generate_xml(arg0, arg1, arg2)
}

// LookupInterface looks up information about an interface.
//
// The cost of this function is O(n) in number of interfaces.
func (info *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	var arg0 *C.GDBusNodeInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusNodeInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_node_info_lookup_interface(arg0, arg1)

	var ret0 *DBusInterfaceInfo

	ret0 = WrapDBusInterfaceInfo(ret)

	return ret0
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusNodeInfo) Ref() *DBusNodeInfo {
	var arg0 *C.GDBusNodeInfo

	arg0 = (*C.GDBusNodeInfo)(info.Native())

	ret := C.g_dbus_node_info_ref(arg0)

	var ret0 *DBusNodeInfo

	ret0 = WrapDBusNodeInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusNodeInfo) Unref() {
	var arg0 *C.GDBusNodeInfo

	arg0 = (*C.GDBusNodeInfo)(info.Native())

	C.g_dbus_node_info_unref(arg0)
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	native C.GDBusPropertyInfo
}

// WrapDBusPropertyInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusPropertyInfo(ptr unsafe.Pointer) *DBusPropertyInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusPropertyInfo)(ptr)
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusPropertyInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusPropertyInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Name gets the field inside the struct.
func (n *DBusPropertyInfo) Name() string {
	var ret string
	ret = C.GoString(d.native.name)
	return ret
}

// Signature gets the field inside the struct.
func (s *DBusPropertyInfo) Signature() string {
	var ret string
	ret = C.GoString(d.native.signature)
	return ret
}

// Flags gets the field inside the struct.
func (f *DBusPropertyInfo) Flags() DBusPropertyInfoFlags {
	var ret DBusPropertyInfoFlags
	ret = DBusPropertyInfoFlags(d.native.flags)
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusPropertyInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusPropertyInfo) Ref() *DBusPropertyInfo {
	var arg0 *C.GDBusPropertyInfo

	arg0 = (*C.GDBusPropertyInfo)(info.Native())

	ret := C.g_dbus_property_info_ref(arg0)

	var ret0 *DBusPropertyInfo

	ret0 = WrapDBusPropertyInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusPropertyInfo) Unref() {
	var arg0 *C.GDBusPropertyInfo

	arg0 = (*C.GDBusPropertyInfo)(info.Native())

	C.g_dbus_property_info_unref(arg0)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	native C.GDBusSignalInfo
}

// WrapDBusSignalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSignalInfo(ptr unsafe.Pointer) *DBusSignalInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusSignalInfo)(ptr)
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSignalInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (r *DBusSignalInfo) RefCount() int {
	var ret int
	ret = int(d.native.ref_count)
	return ret
}

// Name gets the field inside the struct.
func (n *DBusSignalInfo) Name() string {
	var ret string
	ret = C.GoString(d.native.name)
	return ret
}

// Args gets the field inside the struct.
func (a *DBusSignalInfo) Args() []*DBusArgInfo {
	var ret []*DBusArgInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.args); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusArgInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusArgInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.args)) + i))
			ret[i] = WrapDBusArgInfo(src)
		}
	}
	return ret
}

// Annotations gets the field inside the struct.
func (a *DBusSignalInfo) Annotations() []*DBusAnnotationInfo {
	var ret []*DBusAnnotationInfo
	{
		var length uint
		for p := unsafe.Pointer(d.native.annotations); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret = make([]*DBusAnnotationInfo, length)
		for i := 0; i < length; i++ {
			src := (*C.GDBusAnnotationInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(d.native.annotations)) + i))
			ret[i] = WrapDBusAnnotationInfo(src)
		}
	}
	return ret
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (info *DBusSignalInfo) Ref() *DBusSignalInfo {
	var arg0 *C.GDBusSignalInfo

	arg0 = (*C.GDBusSignalInfo)(info.Native())

	ret := C.g_dbus_signal_info_ref(arg0)

	var ret0 *DBusSignalInfo

	ret0 = WrapDBusSignalInfo(ret)

	return ret0
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (info *DBusSignalInfo) Unref() {
	var arg0 *C.GDBusSignalInfo

	arg0 = (*C.GDBusSignalInfo)(info.Native())

	C.g_dbus_signal_info_unref(arg0)
}

// DBusSubtreeVTable: virtual table for handling subtrees registered with
// g_dbus_connection_register_subtree().
type DBusSubtreeVTable struct {
	native C.GDBusSubtreeVTable
}

// WrapDBusSubtreeVTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSubtreeVTable(ptr unsafe.Pointer) *DBusSubtreeVTable {
	if ptr == nil {
		return nil
	}

	return (*DBusSubtreeVTable)(ptr)
}

func marshalDBusSubtreeVTable(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSubtreeVTable(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (d *DBusSubtreeVTable) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// FileAttributeInfo: information about a specific attribute.
type FileAttributeInfo struct {
	native C.GFileAttributeInfo
}

// WrapFileAttributeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfo(ptr unsafe.Pointer) *FileAttributeInfo {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeInfo)(ptr)
}

func marshalFileAttributeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeInfo(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FileAttributeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Name gets the field inside the struct.
func (n *FileAttributeInfo) Name() string {
	var ret string
	ret = C.GoString(f.native.name)
	return ret
}

// Type gets the field inside the struct.
func (t *FileAttributeInfo) Type() FileAttributeType {
	var ret FileAttributeType
	ret = FileAttributeType(f.native._type)
	return ret
}

// Flags gets the field inside the struct.
func (f *FileAttributeInfo) Flags() FileAttributeInfoFlags {
	var ret FileAttributeInfoFlags
	ret = FileAttributeInfoFlags(f.native.flags)
	return ret
}

// FileAttributeInfoList acts as a lightweight registry for possible valid file
// attributes. The registry stores Key-Value pair formats as AttributeInfos.
type FileAttributeInfoList struct {
	native C.GFileAttributeInfoList
}

// WrapFileAttributeInfoList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeInfoList(ptr unsafe.Pointer) *FileAttributeInfoList {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeInfoList)(ptr)
}

func marshalFileAttributeInfoList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeInfoList(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FileAttributeInfoList) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// NewFileAttributeInfoList constructs a struct FileAttributeInfoList.
func NewFileAttributeInfoList() *FileAttributeInfoList {

	ret := C.g_file_attribute_info_list_new()

	var ret0 *FileAttributeInfoList

	ret0 = WrapFileAttributeInfoList(ret)

	return ret0
}

// Infos gets the field inside the struct.
func (i *FileAttributeInfoList) Infos() *FileAttributeInfo {
	var ret *FileAttributeInfo
	ret = WrapFileAttributeInfo(f.native.infos)
	return ret
}

// NInfos gets the field inside the struct.
func (n *FileAttributeInfoList) NInfos() int {
	var ret int
	ret = int(f.native.n_infos)
	return ret
}

// Add adds a new attribute with @name to the @list, setting its @type and
// @flags.
func (list *FileAttributeInfoList) Add(name string, _type FileAttributeType, flags FileAttributeInfoFlags) {
	var arg0 *C.GFileAttributeInfoList
	var arg1 *C.char
	var arg2 C.GFileAttributeType
	var arg3 C.GFileAttributeInfoFlags

	arg0 = (*C.GFileAttributeInfoList)(list.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeType)(_type)
	arg3 = (C.GFileAttributeInfoFlags)(flags)

	C.g_file_attribute_info_list_add(arg0, arg1, arg2, arg3)
}

// Dup makes a duplicate of a file attribute info list.
func (list *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	var arg0 *C.GFileAttributeInfoList

	arg0 = (*C.GFileAttributeInfoList)(list.Native())

	ret := C.g_file_attribute_info_list_dup(arg0)

	var ret0 *FileAttributeInfoList

	ret0 = WrapFileAttributeInfoList(ret)

	return ret0
}

// Lookup gets the file attribute with the name @name from @list.
func (list *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	var arg0 *C.GFileAttributeInfoList
	var arg1 *C.char

	arg0 = (*C.GFileAttributeInfoList)(list.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_attribute_info_list_lookup(arg0, arg1)

	var ret0 *FileAttributeInfo

	ret0 = WrapFileAttributeInfo(ret)

	return ret0
}

// Ref references a file attribute info list.
func (list *FileAttributeInfoList) Ref() *FileAttributeInfoList {
	var arg0 *C.GFileAttributeInfoList

	arg0 = (*C.GFileAttributeInfoList)(list.Native())

	ret := C.g_file_attribute_info_list_ref(arg0)

	var ret0 *FileAttributeInfoList

	ret0 = WrapFileAttributeInfoList(ret)

	return ret0
}

// Unref removes a reference from the given @list. If the reference count falls
// to zero, the @list is deleted.
func (list *FileAttributeInfoList) Unref() {
	var arg0 *C.GFileAttributeInfoList

	arg0 = (*C.GFileAttributeInfoList)(list.Native())

	C.g_file_attribute_info_list_unref(arg0)
}

// FileAttributeMatcher determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	native C.GFileAttributeMatcher
}

// WrapFileAttributeMatcher wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFileAttributeMatcher(ptr unsafe.Pointer) *FileAttributeMatcher {
	if ptr == nil {
		return nil
	}

	return (*FileAttributeMatcher)(ptr)
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFileAttributeMatcher(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (f *FileAttributeMatcher) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_attribute_matcher_new(arg1)

	var ret0 *FileAttributeMatcher

	ret0 = WrapFileAttributeMatcher(ret)

	return ret0
}

// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return true if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and @ns is "standard", or
// if matcher was created using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var arg0 *C.GFileAttributeMatcher
	var arg1 *C.char

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())
	arg1 = (*C.gchar)(C.CString(ns))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_attribute_matcher_enumerate_namespace(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EnumerateNext gets the next matched attribute from a AttributeMatcher.
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var arg0 *C.GFileAttributeMatcher

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())

	ret := C.g_file_attribute_matcher_enumerate_next(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Matches checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function will
// always return true.
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var arg0 *C.GFileAttributeMatcher
	var arg1 *C.char

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_attribute_matcher_matches(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MatchesOnly checks if a attribute matcher only matches a given attribute.
// Always returns false if "*" was used when creating the matcher.
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var arg0 *C.GFileAttributeMatcher
	var arg1 *C.char

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_attribute_matcher_matches_only(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Ref references a file attribute matcher.
func (matcher *FileAttributeMatcher) Ref() *FileAttributeMatcher {
	var arg0 *C.GFileAttributeMatcher

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())

	ret := C.g_file_attribute_matcher_ref(arg0)

	var ret0 *FileAttributeMatcher

	ret0 = WrapFileAttributeMatcher(ret)

	return ret0
}

// Subtract subtracts all attributes of @subtract from @matcher and returns a
// matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single attribute when the
// @matcher matches the whole namespace - or remove a namespace or attribute
// when the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var arg0 *C.GFileAttributeMatcher
	var arg1 *C.GFileAttributeMatcher

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())
	arg1 = (*C.GFileAttributeMatcher)(subtract.Native())

	ret := C.g_file_attribute_matcher_subtract(arg0, arg1)

	var ret0 *FileAttributeMatcher

	ret0 = WrapFileAttributeMatcher(ret)

	return ret0
}

// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
func (matcher *FileAttributeMatcher) String() string {
	var arg0 *C.GFileAttributeMatcher

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())

	ret := C.g_file_attribute_matcher_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Unref unreferences @matcher. If the reference count falls below 1, the
// @matcher is automatically freed.
func (matcher *FileAttributeMatcher) Unref() {
	var arg0 *C.GFileAttributeMatcher

	arg0 = (*C.GFileAttributeMatcher)(matcher.Native())

	C.g_file_attribute_matcher_unref(arg0)
}

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set @bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from the
// POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-nil then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If @control_messages is non-nil then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	native C.GInputMessage
}

// WrapInputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputMessage(ptr unsafe.Pointer) *InputMessage {
	if ptr == nil {
		return nil
	}

	return (*InputMessage)(ptr)
}

func marshalInputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInputMessage(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (i *InputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Address gets the field inside the struct.
func (a *InputMessage) Address() SocketAddress {
	var ret SocketAddress
	ret = WrapSocketAddress(externglib.Take(unsafe.Pointer(i.native.address.Native())))
	return ret
}

// Vectors gets the field inside the struct.
func (v *InputMessage) Vectors() []InputVector {
	var ret []InputVector
	{
		ret = make([]InputVector, i.native.num_vectors)
		for i := 0; i < uintptr(i.native.num_vectors); i++ {
			src := (C.GInputVector)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret[i] = WrapInputVector(src)
		}
	}
	return ret
}

// BytesReceived gets the field inside the struct.
func (b *InputMessage) BytesReceived() uint {
	var ret uint
	ret = uint(i.native.bytes_received)
	return ret
}

// Flags gets the field inside the struct.
func (f *InputMessage) Flags() int {
	var ret int
	ret = int(i.native.flags)
	return ret
}

// ControlMessages gets the field inside the struct.
func (c *InputMessage) ControlMessages() []SocketControlMessage {
	var ret []SocketControlMessage
	{
		ret = make([]SocketControlMessage, i.native.num_control_messages)
		for i := 0; i < uintptr(i.native.num_control_messages); i++ {
			src := (**C.GSocketControlMessage)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret[i] = WrapSocketControlMessage(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}
	return ret
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
type InputVector struct {
	native C.GInputVector
}

// WrapInputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInputVector(ptr unsafe.Pointer) *InputVector {
	if ptr == nil {
		return nil
	}

	return (*InputVector)(ptr)
}

func marshalInputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInputVector(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (i *InputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Buffer gets the field inside the struct.
func (b *InputVector) Buffer() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(i.native.buffer))
	return ret
}

// Size gets the field inside the struct.
func (s *InputVector) Size() uint {
	var ret uint
	ret = uint(i.native.size)
	return ret
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If @address is nil then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
type OutputMessage struct {
	native C.GOutputMessage
}

// WrapOutputMessage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputMessage(ptr unsafe.Pointer) *OutputMessage {
	if ptr == nil {
		return nil
	}

	return (*OutputMessage)(ptr)
}

func marshalOutputMessage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOutputMessage(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (o *OutputMessage) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// Address gets the field inside the struct.
func (a *OutputMessage) Address() SocketAddress {
	var ret SocketAddress
	ret = WrapSocketAddress(externglib.Take(unsafe.Pointer(o.native.address.Native())))
	return ret
}

// Vectors gets the field inside the struct.
func (v *OutputMessage) Vectors() *OutputVector {
	var ret *OutputVector
	ret = WrapOutputVector(o.native.vectors)
	return ret
}

// NumVectors gets the field inside the struct.
func (n *OutputMessage) NumVectors() uint {
	var ret uint
	ret = uint(o.native.num_vectors)
	return ret
}

// BytesSent gets the field inside the struct.
func (b *OutputMessage) BytesSent() uint {
	var ret uint
	ret = uint(o.native.bytes_sent)
	return ret
}

// ControlMessages gets the field inside the struct.
func (c *OutputMessage) ControlMessages() []SocketControlMessage {
	var ret []SocketControlMessage
	{
		ret = make([]SocketControlMessage, o.native.num_control_messages)
		for i := 0; i < uintptr(o.native.num_control_messages); i++ {
			src := (*C.GSocketControlMessage)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret[i] = WrapSocketControlMessage(externglib.Take(unsafe.Pointer(src.Native())))
		}
	}
	return ret
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
type OutputVector struct {
	native C.GOutputVector
}

// WrapOutputVector wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapOutputVector(ptr unsafe.Pointer) *OutputVector {
	if ptr == nil {
		return nil
	}

	return (*OutputVector)(ptr)
}

func marshalOutputVector(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapOutputVector(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (o *OutputVector) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// Buffer gets the field inside the struct.
func (b *OutputVector) Buffer() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(o.native.buffer))
	return ret
}

// Size gets the field inside the struct.
func (s *OutputVector) Size() uint {
	var ret uint
	ret = uint(o.native.size)
	return ret
}

// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in `$datadir/appname`, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the `preprocess` attribute to a comma-separated list of preprocessing
// options. The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the `XMLLINT` environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the `PATH`; otherwise the preprocessing step is skipped.
//
// `to-pixdata` which will use the gdk-pixbuf-pixdata command to convert images
// to the GdkPixdata format, which allows you to create pixbufs directly using
// the data inside the resource file, rather than an (uncompressed) copy of it.
// For this, the gdk-pixbuf-pixdata program must be in the PATH, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// gdk-pixbuf-pixdata executable; otherwise the resource compiler will abort.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
// An example resource description:
//
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//    ]|
//
//    This will create a resource bundle with the following files:
//    |[
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//    ]|
//
//    Note that all resources in the process share the same namespace, so use Java-style
//    path prefixes (like in the above example) to avoid conflicts.
//
//    You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
//    binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
//    --generate-header arguments to create a source file and header to link directly into your application.
//    This will generate `get_resource()`, `register_resource()` and
//    `unregister_resource()` functions, prefixed by the `--c-name` argument passed
//    to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
//    the generated #GResource object. The register and unregister functions
//    register the resource so its files can be accessed using
//    g_resources_lookup_data().
//
//    Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
//    using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
//    to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
//    the resource data.
//
//    Some higher-level APIs, such as Application, will automatically load
//    resources from certain well-known paths in the resource namespace as a
//    convenience. See the documentation for those APIs for details.
//
//    There are two forms of the generated source, the default version uses the compiler support for constructor
//    and destructor functions (where available) to automatically create and register the #GResource on startup
//    or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
//    instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
//    even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
//
//    Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
//    during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
//    when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
//    are for your own resources, and resource data is often used once, during parsing, and then released.
//
//    When debugging a program or testing a change to an installed version, it is often useful to be able to
//    replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
//    purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
//    resources with replacements from the filesystem.  It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
//    during resource lookups.
//
//    A substitution has the form
//
//    |[
//       /org/gtk/libgtk=/home/desrt/gtk-overlay
//
//
// The part before the `=` is the resource subpath for which the overlay
// applies. The part after is a filesystem path which contains files and
// subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check
// the filesystem path `/home/desrt/gtk-overlay/ui/gtkdialog.ui`. If a file was
// found there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
type Resource struct {
	native C.GResource
}

// WrapResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapResource(ptr unsafe.Pointer) *Resource {
	if ptr == nil {
		return nil
	}

	return (*Resource)(ptr)
}

func marshalResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapResource(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (r *Resource) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// NewResourceFromData constructs a struct Resource.
func NewResourceFromData(data *glib.Bytes) *Resource {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(data.Native())

	ret := C.g_resource_new_from_data(arg1)

	var ret0 *Resource

	ret0 = WrapResource(ret)

	return ret0
}

// Register registers the resource with the process-global set of resources.
// Once a resource is registered the files in it can be accessed with the global
// resource lookup functions like g_resources_lookup_data().
func (resource *Resource) Register() {
	var arg0 *C.GResource

	arg0 = (*C.GResource)(resource.Native())

	C.g_resources_register(arg0)
}

// Unregister unregisters the resource from the process-global set of resources.
func (resource *Resource) Unregister() {
	var arg0 *C.GResource

	arg0 = (*C.GResource)(resource.Native())

	C.g_resources_unregister(arg0)
}

// EnumerateChildren returns all the names of children at the specified @path in
// the resource. The return result is a nil terminated list of strings which
// should be released with g_strfreev().
//
// If @path is invalid or does not exist in the #GResource,
// G_RESOURCE_ERROR_NOT_FOUND will be returned.
//
// @lookup_flags controls the behaviour of the lookup.
func (resource *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) []string {
	var arg0 *C.GResource
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg0 = (*C.GResource)(resource.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resource_enumerate_children(arg0, arg1, arg2)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Info looks for a file at the specified @path in the resource and if found
// returns information about it.
//
// @lookup_flags controls the behaviour of the lookup.
func (resource *Resource) Info(path string, lookupFlags ResourceLookupFlags) (size uint, flags uint32, ok bool) {
	var arg0 *C.GResource
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags
	var arg3 *C.gsize   // out
	var arg4 *C.guint32 // out

	arg0 = (*C.GResource)(resource.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resource_get_info(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 uint
	var ret1 uint32
	var ret2 bool

	ret0 = uint(arg3)

	ret1 = uint32(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// LookupData looks for a file at the specified @path in the resource and
// returns a #GBytes that lets you directly access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// @lookup_flags controls the behaviour of the lookup.
func (resource *Resource) LookupData(path string, lookupFlags ResourceLookupFlags) *glib.Bytes {
	var arg0 *C.GResource
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg0 = (*C.GResource)(resource.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resource_lookup_data(arg0, arg1, arg2)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// OpenStream looks for a file at the specified @path in the resource and
// returns a Stream that lets you read the data.
//
// @lookup_flags controls the behaviour of the lookup.
func (resource *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) InputStream {
	var arg0 *C.GResource
	var arg1 *C.char
	var arg2 C.GResourceLookupFlags

	arg0 = (*C.GResource)(resource.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResourceLookupFlags)(lookupFlags)

	ret := C.g_resource_open_stream(arg0, arg1, arg2)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Ref: atomically increments the reference count of @resource by one. This
// function is MT-safe and may be called from any thread.
func (resource *Resource) Ref() *Resource {
	var arg0 *C.GResource

	arg0 = (*C.GResource)(resource.Native())

	ret := C.g_resource_ref(arg0)

	var ret0 *Resource

	ret0 = WrapResource(ret)

	return ret0
}

// Unref: atomically decrements the reference count of @resource by one. If the
// reference count drops to 0, all memory allocated by the resource is released.
// This function is MT-safe and may be called from any thread.
func (resource *Resource) Unref() {
	var arg0 *C.GResource

	arg0 = (*C.GResource)(resource.Native())

	C.g_resource_unref(arg0)
}

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema struct {
	native C.GSettingsSchema
}

// WrapSettingsSchema wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchema(ptr unsafe.Pointer) *SettingsSchema {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchema)(ptr)
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchema(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// ID: get the ID of @schema.
func (schema *SettingsSchema) ID() string {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	ret := C.g_settings_schema_get_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Key gets the key named @name from @schema.
//
// It is a programmer error to request a key that does not exist. See
// g_settings_schema_list_keys().
func (schema *SettingsSchema) Key(name string) *SettingsSchemaKey {
	var arg0 *C.GSettingsSchema
	var arg1 *C.gchar

	arg0 = (*C.GSettingsSchema)(schema.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_schema_get_key(arg0, arg1)

	var ret0 *SettingsSchemaKey

	ret0 = WrapSettingsSchemaKey(ret)

	return ret0
}

// Path gets the path associated with @schema, or nil.
//
// Schemas may be single-instance or relocatable. Single-instance schemas
// correspond to exactly one set of keys in the backend database: those located
// at the path returned by this function.
//
// Relocatable schemas can be referenced by other schemas and can therefore
// describe multiple sets of keys at different locations. For relocatable
// schemas, this function will return nil.
func (schema *SettingsSchema) Path() string {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	ret := C.g_settings_schema_get_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// HasKey checks if @schema has a key named @name.
func (schema *SettingsSchema) HasKey(name string) bool {
	var arg0 *C.GSettingsSchema
	var arg1 *C.gchar

	arg0 = (*C.GSettingsSchema)(schema.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_schema_has_key(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListChildren gets the list of children in @schema.
//
// You should free the return value with g_strfreev() when you are done with it.
func (schema *SettingsSchema) ListChildren() []string {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	ret := C.g_settings_schema_list_children(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ListKeys introspects the list of keys on @schema.
//
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
func (schema *SettingsSchema) ListKeys() []string {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	ret := C.g_settings_schema_list_keys(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Ref: increase the reference count of @schema, returning a new reference.
func (schema *SettingsSchema) Ref() *SettingsSchema {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	ret := C.g_settings_schema_ref(arg0)

	var ret0 *SettingsSchema

	ret0 = WrapSettingsSchema(ret)

	return ret0
}

// Unref: decrease the reference count of @schema, possibly freeing it.
func (schema *SettingsSchema) Unref() {
	var arg0 *C.GSettingsSchema

	arg0 = (*C.GSettingsSchema)(schema.Native())

	C.g_settings_schema_unref(arg0)
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
type SettingsSchemaKey struct {
	native C.GSettingsSchemaKey
}

// WrapSettingsSchemaKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaKey(ptr unsafe.Pointer) *SettingsSchemaKey {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchemaKey)(ptr)
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaKey(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// DefaultValue gets the default value for @key.
//
// Note that this is the default value according to the schema. System
// administrator defaults and lockdown are not visible via this API.
func (key *SettingsSchemaKey) DefaultValue() *glib.Variant {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_default_value(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Description gets the description for @key.
//
// If no description has been provided in the schema for @key, returns nil.
//
// The description can be one sentence to several paragraphs in length.
// Paragraphs are delimited with a double newline. Descriptions can be
// translated and the value returned from this function is is the current
// locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
func (key *SettingsSchemaKey) Description() string {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Name gets the name of @key.
func (key *SettingsSchemaKey) Name() string {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Range queries the range of a key.
//
// This function will return a #GVariant that fully describes the range of
// values that are valid for @key.
//
// The type of #GVariant returned is `(sv)`. The string describes the type of
// range restriction in effect. The type and meaning of the value contained in
// the variant depends on the string.
//
// If the string is `'type'` then the variant contains an empty array. The
// element type of that empty array is the expected type of value and all values
// of that type are valid.
//
// If the string is `'enum'` then the variant contains an array enumerating the
// possible values. Each item in the array is a possible valid value and no
// other values are valid.
//
// If the string is `'flags'` then the variant contains an array. Each item in
// the array is a value that may appear zero or one times in an array to be used
// as the value for this key. For example, if the variant contained the array
// `['x', 'y']` then the valid values for the key would be `[]`, `['x']`,
// `['y']`, `['x', 'y']` and `['y', 'x']`.
//
// Finally, if the string is `'range'` then the variant contains a pair of
// like-typed values -- the minimum and maximum permissible values for this key.
//
// This information should not be used by normal programs. It is considered to
// be a hint for introspection purposes. Normal programs should already know
// what is permitted by their own schema. The format may change in any way in
// the future -- but particularly, new forms may be added to the possibilities
// described above.
//
// You should free the returned value with g_variant_unref() when it is no
// longer needed.
func (key *SettingsSchemaKey) Range() *glib.Variant {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_range(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Summary gets the summary for @key.
//
// If no summary has been provided in the schema for @key, returns nil.
//
// The summary is a short description of the purpose of the key; usually one
// short sentence. Summaries can be translated and the value returned from this
// function is is the current locale.
//
// This function is slow. The summary and description information for the
// schemas is not stored in the compiled schema database so this function has to
// parse all of the source XML files in the schema directory.
func (key *SettingsSchemaKey) Summary() string {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_summary(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ValueType gets the Type of @key.
func (key *SettingsSchemaKey) ValueType() *glib.VariantType {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_get_value_type(arg0)

	var ret0 *glib.VariantType

	ret0 = glib.WrapVariantType(ret)

	return ret0
}

// RangeCheck checks if the given @value is of the correct type and within the
// permitted range for @key.
//
// It is a programmer error if @value is not of the correct type -- you must
// check for this first.
func (key *SettingsSchemaKey) RangeCheck(value *glib.Variant) bool {
	var arg0 *C.GSettingsSchemaKey
	var arg1 *C.GVariant

	arg0 = (*C.GSettingsSchemaKey)(key.Native())
	arg1 = (*C.GVariant)(value.Native())

	ret := C.g_settings_schema_key_range_check(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Ref: increase the reference count of @key, returning a new reference.
func (key *SettingsSchemaKey) Ref() *SettingsSchemaKey {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	ret := C.g_settings_schema_key_ref(arg0)

	var ret0 *SettingsSchemaKey

	ret0 = WrapSettingsSchemaKey(ret)

	return ret0
}

// Unref: decrease the reference count of @key, possibly freeing it.
func (key *SettingsSchemaKey) Unref() {
	var arg0 *C.GSettingsSchemaKey

	arg0 = (*C.GSettingsSchemaKey)(key.Native())

	C.g_settings_schema_key_unref(arg0)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource struct {
	native C.GSettingsSchemaSource
}

// WrapSettingsSchemaSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaSource(ptr unsafe.Pointer) *SettingsSchemaSource {
	if ptr == nil {
		return nil
	}

	return (*SettingsSchemaSource)(ptr)
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSettingsSchemaSource(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewSettingsSchemaSourceFromDirectory constructs a struct SettingsSchemaSource.
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) *SettingsSchemaSource {
	var arg1 *C.gchar
	var arg2 *C.GSettingsSchemaSource
	var arg3 C.gboolean

	arg1 = (*C.gchar)(C.CString(directory))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GSettingsSchemaSource)(parent.Native())
	arg3 = gextras.Cbool(trusted)

	ret := C.g_settings_schema_source_new_from_directory(arg1, arg2, arg3)

	var ret0 *SettingsSchemaSource

	ret0 = WrapSettingsSchemaSource(ret)

	return ret0
}

// ListSchemas lists the schemas in a given source.
//
// If @recursive is true then include parent sources. If false then only include
// the schemas from one source (ie: one directory). You probably want true.
//
// Non-relocatable schemas are those for which you can call g_settings_new().
// Relocatable schemas are those for which you must use
// g_settings_new_with_path().
//
// Do not call this function from normal programs. This is designed for use by
// database editors, commandline tools, etc.
func (source *SettingsSchemaSource) ListSchemas(recursive bool) (nonRelocatable []string, relocatable []string) {
	var arg0 *C.GSettingsSchemaSource
	var arg1 C.gboolean
	var arg2 ***C.gchar // out
	var arg3 ***C.gchar // out

	arg0 = (*C.GSettingsSchemaSource)(source.Native())
	arg1 = gextras.Cbool(recursive)

	ret := C.g_settings_schema_source_list_schemas(arg0, arg1, &arg2, &arg3)

	var ret0 []string
	var ret1 []string

	{
		var length uint
		for p := unsafe.Pointer(arg2); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg2)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	{
		var length uint
		for p := unsafe.Pointer(arg3); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg3)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Lookup looks up a schema with the identifier @schema_id in @source.
//
// This function is not required for normal uses of #GSettings but it may be
// useful to authors of plugin management systems or to those who want to
// introspect the content of schemas.
//
// If the schema isn't found directly in @source and @recursive is true then the
// parent sources will also be checked.
//
// If the schema isn't found, nil is returned.
func (source *SettingsSchemaSource) Lookup(schemaID string, recursive bool) *SettingsSchema {
	var arg0 *C.GSettingsSchemaSource
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GSettingsSchemaSource)(source.Native())
	arg1 = (*C.gchar)(C.CString(schemaID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(recursive)

	ret := C.g_settings_schema_source_lookup(arg0, arg1, arg2)

	var ret0 *SettingsSchema

	ret0 = WrapSettingsSchema(ret)

	return ret0
}

// Ref: increase the reference count of @source, returning a new reference.
func (source *SettingsSchemaSource) Ref() *SettingsSchemaSource {
	var arg0 *C.GSettingsSchemaSource

	arg0 = (*C.GSettingsSchemaSource)(source.Native())

	ret := C.g_settings_schema_source_ref(arg0)

	var ret0 *SettingsSchemaSource

	ret0 = WrapSettingsSchemaSource(ret)

	return ret0
}

// Unref: decrease the reference count of @source, possibly freeing it.
func (source *SettingsSchemaSource) Unref() {
	var arg0 *C.GSettingsSchemaSource

	arg0 = (*C.GSettingsSchemaSource)(source.Native())

	C.g_settings_schema_source_unref(arg0)
}

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
type SrvTarget struct {
	native C.GSrvTarget
}

// WrapSrvTarget wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSrvTarget(ptr unsafe.Pointer) *SrvTarget {
	if ptr == nil {
		return nil
	}

	return (*SrvTarget)(ptr)
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSrvTarget(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *SrvTarget) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// NewSrvTarget constructs a struct SrvTarget.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var arg1 *C.gchar
	var arg2 C.guint16
	var arg3 C.guint16
	var arg4 C.guint16

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(port)
	arg3 = C.guint16(priority)
	arg4 = C.guint16(weight)

	ret := C.g_srv_target_new(arg1, arg2, arg3, arg4)

	var ret0 *SrvTarget

	ret0 = WrapSrvTarget(ret)

	return ret0
}

// Copy copies @target
func (target *SrvTarget) Copy() *SrvTarget {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	ret := C.g_srv_target_copy(arg0)

	var ret0 *SrvTarget

	ret0 = WrapSrvTarget(ret)

	return ret0
}

// Free frees @target
func (target *SrvTarget) Free() {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	C.g_srv_target_free(arg0)
}

// Hostname gets @target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.)
func (target *SrvTarget) Hostname() string {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	ret := C.g_srv_target_get_hostname(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Port gets @target's port
func (target *SrvTarget) Port() uint16 {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	ret := C.g_srv_target_get_port(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Priority gets @target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
func (target *SrvTarget) Priority() uint16 {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	ret := C.g_srv_target_get_priority(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Weight gets @target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
func (target *SrvTarget) Weight() uint16 {
	var arg0 *C.GSrvTarget

	arg0 = (*C.GSrvTarget)(target.Native())

	ret := C.g_srv_target_get_weight(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// StaticResource is an opaque data structure and can only be accessed using the
// following functions.
type StaticResource struct {
	native C.GStaticResource
}

// WrapStaticResource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapStaticResource(ptr unsafe.Pointer) *StaticResource {
	if ptr == nil {
		return nil
	}

	return (*StaticResource)(ptr)
}

func marshalStaticResource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapStaticResource(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (s *StaticResource) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Fini: finalized a GResource initialized by g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (staticResource *StaticResource) Fini() {
	var arg0 *C.GStaticResource

	arg0 = (*C.GStaticResource)(staticResource.Native())

	C.g_static_resource_fini(arg0)
}

// Resource gets the GResource that was registered by a call to
// g_static_resource_init().
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (staticResource *StaticResource) Resource() *Resource {
	var arg0 *C.GStaticResource

	arg0 = (*C.GStaticResource)(staticResource.Native())

	ret := C.g_static_resource_get_resource(arg0)

	var ret0 *Resource

	ret0 = WrapResource(ret)

	return ret0
}

// Init initializes a GResource from static data using a GStaticResource.
//
// This is normally used by code generated by
// [glib-compile-resources][glib-compile-resources] and is not typically used by
// other code.
func (staticResource *StaticResource) Init() {
	var arg0 *C.GStaticResource

	arg0 = (*C.GStaticResource)(staticResource.Native())

	C.g_static_resource_init(arg0)
}

// UnixMountEntry defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native C.GUnixMountEntry
}

// WrapUnixMountEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountEntry(ptr unsafe.Pointer) *UnixMountEntry {
	if ptr == nil {
		return nil
	}

	return (*UnixMountEntry)(ptr)
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountEntry(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// UnixMountPoint defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native C.GUnixMountPoint
}

// WrapUnixMountPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountPoint(ptr unsafe.Pointer) *UnixMountPoint {
	if ptr == nil {
		return nil
	}

	return (*UnixMountPoint)(ptr)
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountPoint(unsafe.Pointer(b))
}

// Native returns the underlying C source pointer.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// Compare compares two unix mount points.
func (mount1 *UnixMountPoint) Compare(mount2 *UnixMountPoint) int {
	var arg0 *C.GUnixMountPoint
	var arg1 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mount1.Native())
	arg1 = (*C.GUnixMountPoint)(mount2.Native())

	ret := C.g_unix_mount_point_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy makes a copy of @mount_point.
func (mountPoint *UnixMountPoint) Copy() *UnixMountPoint {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_copy(arg0)

	var ret0 *UnixMountPoint

	ret0 = WrapUnixMountPoint(ret)

	return ret0
}

// Free frees a unix mount point.
func (mountPoint *UnixMountPoint) Free() {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	C.g_unix_mount_point_free(arg0)
}

// DevicePath gets the device path for a unix mount point.
func (mountPoint *UnixMountPoint) DevicePath() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_get_device_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// FSType gets the file system type for the mount point.
func (mountPoint *UnixMountPoint) FSType() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_get_fs_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MountPath gets the mount path for a unix mount point.
func (mountPoint *UnixMountPoint) MountPath() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_get_mount_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Options gets the options for the mount point.
func (mountPoint *UnixMountPoint) Options() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_get_options(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GuessCanEject guesses whether a Unix mount point can be ejected.
func (mountPoint *UnixMountPoint) GuessCanEject() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_guess_can_eject(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// GuessName guesses the name of a Unix mount point. The result is a translated
// string.
func (mountPoint *UnixMountPoint) GuessName() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_guess_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// IsLoopback checks if a unix mount point is a loopback device.
func (mountPoint *UnixMountPoint) IsLoopback() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_is_loopback(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsReadonly checks if a unix mount point is read only.
func (mountPoint *UnixMountPoint) IsReadonly() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_is_readonly(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsUserMountable checks if a unix mount point is mountable by the user.
func (mountPoint *UnixMountPoint) IsUserMountable() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(mountPoint.Native())

	ret := C.g_unix_mount_point_is_user_mountable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor interface.
type appInfoMonitor struct {
	gextras.Objector
}

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return AppInfoMonitor{
		gextras.Objector: (obj),
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext interface {
	gextras.Objector

	// Environment gets the complete environment variable list to be passed to
	// the child process when @context is used to launch an application. This is
	// a nil-terminated array of strings, where each string has the form
	// `KEY=VALUE`.
	Environment() []string
	// LaunchFailed: called when an application has failed to launch, so that it
	// can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	LaunchFailed(startupNotifyID string)
	// Setenv arranges for @variable to be set to @value in the child's
	// environment when @context is used to launch an application.
	Setenv(variable string, value string)
	// Unsetenv arranges for @variable to be unset in the child's environment
	// when @context is used to launch an application.
	Unsetenv(variable string)
}

// appLaunchContext implements the AppLaunchContext interface.
type appLaunchContext struct {
	gextras.Objector
}

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return AppLaunchContext{
		gextras.Objector: (obj),
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

// NewAppLaunchContext constructs a class AppLaunchContext.
func NewAppLaunchContext() AppLaunchContext {

	ret := C.g_app_launch_context_new()

	var ret0 AppLaunchContext

	ret0 = WrapAppLaunchContext(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Environment gets the complete environment variable list to be passed to
// the child process when @context is used to launch an application. This is
// a nil-terminated array of strings, where each string has the form
// `KEY=VALUE`.
func (context appLaunchContext) Environment() []string {
	var arg0 *C.GAppLaunchContext

	arg0 = (*C.GAppLaunchContext)(context.Native())

	ret := C.g_app_launch_context_get_environment(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.filename)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// LaunchFailed: called when an application has failed to launch, so that it
// can cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
func (context appLaunchContext) LaunchFailed(startupNotifyID string) {
	var arg0 *C.GAppLaunchContext
	var arg1 *C.char

	arg0 = (*C.GAppLaunchContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(startupNotifyID))
	defer C.free(unsafe.Pointer(arg1))

	C.g_app_launch_context_launch_failed(arg0, arg1)
}

// Setenv arranges for @variable to be set to @value in the child's
// environment when @context is used to launch an application.
func (context appLaunchContext) Setenv(variable string, value string) {
	var arg0 *C.GAppLaunchContext
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GAppLaunchContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	C.g_app_launch_context_setenv(arg0, arg1, arg2)
}

// Unsetenv arranges for @variable to be unset in the child's environment
// when @context is used to launch an application.
func (context appLaunchContext) Unsetenv(variable string) {
	var arg0 *C.GAppLaunchContext
	var arg1 *C.char

	arg0 = (*C.GAppLaunchContext)(context.Native())
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	C.g_app_launch_context_unsetenv(arg0, arg1)
}

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some ‘platform data’ from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application interface {
	gextras.Objector

	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate()
	// AddMainOption: add an option to be handled by @application.
	//
	// Calling this function is the equivalent of calling
	// g_application_add_main_option_entries() with a single Entry that has its
	// arg_data member set to nil.
	//
	// The parsed arguments will be packed into a Dict which is passed to
	// #GApplication::handle-local-options. If
	// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
	// the primary instance. See g_application_add_main_option_entries() for
	// more details.
	//
	// See Entry for more documentation of the arguments.
	AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)
	// AddOptionGroup adds a Group to the commandline handling of @application.
	//
	// This function is comparable to g_option_context_add_group().
	//
	// Unlike g_application_add_main_option_entries(), this function does not
	// deal with nil @arg_data and never transmits options to the primary
	// instance.
	//
	// The reason for that is because, by the time the options arrive at the
	// primary instance, it is typically too late to do anything with them.
	// Taking the GTK option group as an example: GTK will already have been
	// initialised by the time the #GApplication::command-line handler runs. In
	// the case that this is not the first-running instance of the application,
	// the existing instance may already have been running for a very long time.
	//
	// This means that the options from Group are only really usable in the case
	// that the instance of the application being run is the first instance.
	// Passing options like `--display=` or `--gdk-debug=` on future runs will
	// have no effect on the existing primary instance.
	//
	// Calling this function will cause the options in the supplied option group
	// to be parsed, but it does not cause you to be "opted in" to the new
	// functionality whereby unrecognised options are rejected even if
	// G_APPLICATION_HANDLES_COMMAND_LINE was given.
	AddOptionGroup(group *glib.OptionGroup)
	// BindBusyProperty marks @application as busy (see
	// g_application_mark_busy()) while @property on @object is true.
	//
	// The binding holds a reference to @application while it is active, but not
	// to @object. Instead, the binding is destroyed when @object is finalized.
	BindBusyProperty(object gextras.Objector, property string)
	// ApplicationID gets the unique identifier for @application.
	ApplicationID() string
	// DBusConnection gets the BusConnection being used by the application, or
	// nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the BusConnection being used for uniqueness and communication with
	// the desktop environment and other instances of the application.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusConnection() DBusConnection
	// DBusObjectPath gets the D-Bus object path being used by the application,
	// or nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the D-Bus object path that #GApplication is using. If the
	// application is the primary instance then there is an object published at
	// this path. If the application is not the primary instance then the result
	// of this function is undefined.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusObjectPath() string
	// Flags gets the flags for @application.
	//
	// See Flags.
	Flags() ApplicationFlags
	// InactivityTimeout gets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	InactivityTimeout() uint
	// IsBusy gets the application's current busy state, as set through
	// g_application_mark_busy() or g_application_bind_busy_property().
	IsBusy() bool
	// IsRegistered checks if @application is registered.
	//
	// An application is registered if g_application_register() has been
	// successfully called.
	IsRegistered() bool
	// IsRemote checks if @application is remote.
	//
	// If @application is remote then it means that another instance of
	// application already exists (the 'primary' instance). Calls to perform
	// actions on @application will result in the actions being performed by the
	// primary instance.
	//
	// The value of this property cannot be accessed before
	// g_application_register() has been called. See
	// g_application_get_is_registered().
	IsRemote() bool
	// ResourceBasePath gets the resource base path of @application.
	//
	// See g_application_set_resource_base_path() for more information.
	ResourceBasePath() string
	// Hold increases the use count of @application.
	//
	// Use this function to indicate that the application has a reason to
	// continue to run. For example, g_application_hold() is called by GTK+ when
	// a toplevel window is on the screen.
	//
	// To cancel the hold, call g_application_release().
	Hold()
	// MarkBusy increases the busy count of @application.
	//
	// Use this function to indicate that the application is busy, for instance
	// while a long running operation is pending.
	//
	// The busy state will be exposed to other processes, so a session shell
	// will use that information to indicate the state to the user (e.g. with a
	// spinner).
	//
	// To cancel the busy indication, use g_application_unmark_busy().
	MarkBusy()
	// Quit: immediately quits the application.
	//
	// Upon return to the mainloop, g_application_run() will return, calling
	// only the 'shutdown' function before doing so.
	//
	// The hold count is ignored. Take care if your code has called
	// g_application_hold() on the application and is therefore still expecting
	// it to exist. (Note that you may have called g_application_hold()
	// indirectly, for example through gtk_application_add_window().)
	//
	// The result of calling g_application_run() again after it returns is
	// unspecified.
	Quit()
	// Register attempts registration of the application.
	//
	// This is the point at which the application discovers if it is the primary
	// instance or merely acting as a remote for an already-existing primary
	// instance. This is implemented by attempting to acquire the application
	// identifier as a unique bus name on the session bus using GDBus.
	//
	// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
	// then this process will always become the primary instance.
	//
	// Due to the internal architecture of GDBus, method calls can be dispatched
	// at any time (even if a main loop is not running). For this reason, you
	// must ensure that any object paths that you wish to register are
	// registered before calling this function.
	//
	// If the application has already been registered then true is returned with
	// no work performed.
	//
	// The #GApplication::startup signal is emitted if registration succeeds and
	// @application is the primary instance (including the non-unique case).
	//
	// In the event of an error (such as @cancellable being cancelled, or a
	// failure to connect to the session bus), false is returned and @error is
	// set appropriately.
	//
	// Note: the return value of this function is not an indicator that this
	// instance is or is not the primary instance of the application. See
	// g_application_get_is_remote() for that.
	Register(cancellable Cancellable) bool
	// Release: decrease the use count of @application.
	//
	// When the use count reaches zero, the application will stop running.
	//
	// Never call this function except to cancel the effect of a previous call
	// to g_application_hold().
	Release()
	// SendNotification sends a notification on behalf of @application to the
	// desktop shell. There is no guarantee that the notification is displayed
	// immediately, or even at all.
	//
	// Notifications may persist after the application exits. It will be
	// D-Bus-activated when the notification or one of its actions is activated.
	//
	// Modifying @notification after this call has no effect. However, the
	// object can be reused for a later call to this function.
	//
	// @id may be any string that uniquely identifies the event for the
	// application. It does not need to be in any special format. For example,
	// "new-message" might be appropriate for a notification about new messages.
	//
	// If a previous notification was sent with the same @id, it will be
	// replaced with @notification and shown again as if it was a new
	// notification. This works even for notifications sent from a previous
	// execution of the application, as long as @id is the same string.
	//
	// @id may be nil, but it is impossible to replace or withdraw notifications
	// without an id.
	//
	// If @notification is no longer relevant, it can be withdrawn with
	// g_application_withdraw_notification().
	SendNotification(id string, notification Notification)
	// SetActionGroup: this used to be how actions were associated with a
	// #GApplication. Now there is Map for that.
	SetActionGroup(actionGroup ActionGroup)
	// SetApplicationID sets the unique identifier for @application.
	//
	// The application id can only be modified if @application has not yet been
	// registered.
	//
	// If non-nil, the application id must be valid. See
	// g_application_id_is_valid().
	SetApplicationID(applicationID string)
	// SetDefault sets or unsets the default application for the process, as
	// returned by g_application_get_default().
	//
	// This function does not take its own reference on @application. If
	// @application is destroyed then the default application will revert back
	// to nil.
	SetDefault()
	// SetFlags sets the flags for @application.
	//
	// The flags can only be modified if @application has not yet been
	// registered.
	//
	// See Flags.
	SetFlags(flags ApplicationFlags)
	// SetInactivityTimeout sets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	//
	// This call has no side effects of its own. The value set here is only used
	// for next time g_application_release() drops the use count to zero. Any
	// timeouts currently in progress are not impacted.
	SetInactivityTimeout(inactivityTimeout uint)
	// SetOptionContextDescription adds a description to the @application option
	// context.
	//
	// See g_option_context_set_description() for more information.
	SetOptionContextDescription(description string)
	// SetOptionContextParameterString sets the parameter string to be used by
	// the commandline handling of @application.
	//
	// This function registers the argument to be passed to
	// g_option_context_new() when the internal Context of @application is
	// created.
	//
	// See g_option_context_new() for more information about @parameter_string.
	SetOptionContextParameterString(parameterString string)
	// SetOptionContextSummary adds a summary to the @application option
	// context.
	//
	// See g_option_context_set_summary() for more information.
	SetOptionContextSummary(summary string)
	// SetResourceBasePath sets (or unsets) the base resource path of
	// @application.
	//
	// The path is used to automatically load various [application
	// resources][gresource] such as menu layouts and action descriptions. The
	// various types of resources will be found at fixed names relative to the
	// given base path.
	//
	// By default, the resource base path is determined from the application ID
	// by prefixing '/' and replacing each '.' with '/'. This is done at the
	// time that the #GApplication object is constructed. Changes to the
	// application ID after that point will not have an impact on the resource
	// base path.
	//
	// As an example, if the application has an ID of "org.example.app" then the
	// default resource base path will be "/org/example/app". If this is a
	// Application (and you have not manually changed the path) then Gtk will
	// then search for the menus of the application at
	// "/org/example/app/gtk/menus.ui".
	//
	// See #GResource for more information about adding resources to your
	// application.
	//
	// You can disable automatic resource loading functionality by setting the
	// path to nil.
	//
	// Changing the resource base path once the application is running is not
	// recommended. The point at which the resource path is consulted for
	// forming paths for various purposes is unspecified. When writing a
	// sub-class of #GApplication you should either set the
	// #GApplication:resource-base-path property at construction time, or call
	// this function during the instance initialization. Alternatively, you can
	// call this function in the Class.startup virtual function, before chaining
	// up to the parent implementation.
	SetResourceBasePath(resourcePath string)
	// UnbindBusyProperty destroys a binding between @property and the busy
	// state of @application that was previously created with
	// g_application_bind_busy_property().
	UnbindBusyProperty(object gextras.Objector, property string)
	// UnmarkBusy decreases the busy count of @application.
	//
	// When the busy count reaches zero, the new state will be propagated to
	// other processes.
	//
	// This function must only be called to cancel the effect of a previous call
	// to g_application_mark_busy().
	UnmarkBusy()
	// WithdrawNotification withdraws a notification that was sent with
	// g_application_send_notification().
	//
	// This call does nothing if a notification with @id doesn't exist or the
	// notification was never sent.
	//
	// This function works even for notifications sent in previous executions of
	// this application, as long @id is the same as it was for the sent
	// notification.
	//
	// Note that notifications are dismissed when the user clicks on one of the
	// buttons in a notification or triggers its default action, so there is no
	// need to explicitly withdraw the notification in that case.
	WithdrawNotification(id string)
}

// application implements the Application interface.
type application struct {
	gextras.Objector
}

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return Application{
		gextras.Objector: (obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication constructs a class Application.
func NewApplication(applicationID string, flags ApplicationFlags) Application {
	var arg1 *C.gchar
	var arg2 C.GApplicationFlags

	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GApplicationFlags)(flags)

	ret := C.g_application_new(arg1, arg2)

	var ret0 Application

	ret0 = WrapApplication(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Activate activates the application.
//
// In essence, this results in the #GApplication::activate signal being
// emitted in the primary instance.
//
// The application must be registered before calling this function.
func (application application) Activate() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_activate(arg0)
}

// AddMainOption: add an option to be handled by @application.
//
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single Entry that has its
// arg_data member set to nil.
//
// The parsed arguments will be packed into a Dict which is passed to
// #GApplication::handle-local-options. If
// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
// the primary instance. See g_application_add_main_option_entries() for
// more details.
//
// See Entry for more documentation of the arguments.
func (application application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string) {
	var arg0 *C.GApplication
	var arg1 *C.char
	var arg2 C.char
	var arg3 C.GOptionFlags
	var arg4 C.GOptionArg
	var arg5 *C.char
	var arg6 *C.char

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(longName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.char(shortName)
	arg3 = (C.GOptionFlags)(flags)
	arg4 = (C.GOptionArg)(arg)
	arg5 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(argDescription))
	defer C.free(unsafe.Pointer(arg6))

	C.g_application_add_main_option(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AddOptionGroup adds a Group to the commandline handling of @application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does not
// deal with nil @arg_data and never transmits options to the primary
// instance.
//
// The reason for that is because, by the time the options arrive at the
// primary instance, it is typically too late to do anything with them.
// Taking the GTK option group as an example: GTK will already have been
// initialised by the time the #GApplication::command-line handler runs. In
// the case that this is not the first-running instance of the application,
// the existing instance may already have been running for a very long time.
//
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance.
// Passing options like `--display=` or `--gdk-debug=` on future runs will
// have no effect on the existing primary instance.
//
// Calling this function will cause the options in the supplied option group
// to be parsed, but it does not cause you to be "opted in" to the new
// functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
func (application application) AddOptionGroup(group *glib.OptionGroup) {
	var arg0 *C.GApplication
	var arg1 *C.GOptionGroup

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.GOptionGroup)(group.Native())

	C.g_application_add_option_group(arg0, arg1)
}

// BindBusyProperty marks @application as busy (see
// g_application_mark_busy()) while @property on @object is true.
//
// The binding holds a reference to @application while it is active, but not
// to @object. Instead, the binding is destroyed when @object is finalized.
func (application application) BindBusyProperty(object gextras.Objector, property string) {
	var arg0 *C.GApplication
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.GObject)(object.Native())
	arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg2))

	C.g_application_bind_busy_property(arg0, arg1, arg2)
}

// ApplicationID gets the unique identifier for @application.
func (application application) ApplicationID() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_application_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DBusConnection gets the BusConnection being used by the application, or
// nil.
//
// If #GApplication is using its D-Bus backend then this function will
// return the BusConnection being used for uniqueness and communication with
// the desktop environment and other instances of the application.
//
// If #GApplication is not using D-Bus then this function will return nil.
// This includes the situation where the D-Bus backend would normally be in
// use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered. See g_application_get_is_registered().
func (application application) DBusConnection() DBusConnection {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_dbus_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DBusObjectPath gets the D-Bus object path being used by the application,
// or nil.
//
// If #GApplication is using its D-Bus backend then this function will
// return the D-Bus object path that #GApplication is using. If the
// application is the primary instance then there is an object published at
// this path. If the application is not the primary instance then the result
// of this function is undefined.
//
// If #GApplication is not using D-Bus then this function will return nil.
// This includes the situation where the D-Bus backend would normally be in
// use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered. See g_application_get_is_registered().
func (application application) DBusObjectPath() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_dbus_object_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets the flags for @application.
//
// See Flags.
func (application application) Flags() ApplicationFlags {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_flags(arg0)

	var ret0 ApplicationFlags

	ret0 = ApplicationFlags(ret)

	return ret0
}

// InactivityTimeout gets the current inactivity timeout for the
// application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
func (application application) InactivityTimeout() uint {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_inactivity_timeout(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsBusy gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
func (application application) IsBusy() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_is_busy(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsRegistered checks if @application is registered.
//
// An application is registered if g_application_register() has been
// successfully called.
func (application application) IsRegistered() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_is_registered(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsRemote checks if @application is remote.
//
// If @application is remote then it means that another instance of
// application already exists (the 'primary' instance). Calls to perform
// actions on @application will result in the actions being performed by the
// primary instance.
//
// The value of this property cannot be accessed before
// g_application_register() has been called. See
// g_application_get_is_registered().
func (application application) IsRemote() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_is_remote(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ResourceBasePath gets the resource base path of @application.
//
// See g_application_set_resource_base_path() for more information.
func (application application) ResourceBasePath() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	ret := C.g_application_get_resource_base_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Hold increases the use count of @application.
//
// Use this function to indicate that the application has a reason to
// continue to run. For example, g_application_hold() is called by GTK+ when
// a toplevel window is on the screen.
//
// To cancel the hold, call g_application_release().
func (application application) Hold() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_hold(arg0)
}

// MarkBusy increases the busy count of @application.
//
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
//
// The busy state will be exposed to other processes, so a session shell
// will use that information to indicate the state to the user (e.g. with a
// spinner).
//
// To cancel the busy indication, use g_application_unmark_busy().
func (application application) MarkBusy() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_mark_busy(arg0)
}

// Quit: immediately quits the application.
//
// Upon return to the mainloop, g_application_run() will return, calling
// only the 'shutdown' function before doing so.
//
// The hold count is ignored. Take care if your code has called
// g_application_hold() on the application and is therefore still expecting
// it to exist. (Note that you may have called g_application_hold()
// indirectly, for example through gtk_application_add_window().)
//
// The result of calling g_application_run() again after it returns is
// unspecified.
func (application application) Quit() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_quit(arg0)
}

// Register attempts registration of the application.
//
// This is the point at which the application discovers if it is the primary
// instance or merely acting as a remote for an already-existing primary
// instance. This is implemented by attempting to acquire the application
// identifier as a unique bus name on the session bus using GDBus.
//
// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
// then this process will always become the primary instance.
//
// Due to the internal architecture of GDBus, method calls can be dispatched
// at any time (even if a main loop is not running). For this reason, you
// must ensure that any object paths that you wish to register are
// registered before calling this function.
//
// If the application has already been registered then true is returned with
// no work performed.
//
// The #GApplication::startup signal is emitted if registration succeeds and
// @application is the primary instance (including the non-unique case).
//
// In the event of an error (such as @cancellable being cancelled, or a
// failure to connect to the session bus), false is returned and @error is
// set appropriately.
//
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application. See
// g_application_get_is_remote() for that.
func (application application) Register(cancellable Cancellable) bool {
	var arg0 *C.GApplication
	var arg1 *C.GCancellable

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_application_register(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Release: decrease the use count of @application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous call
// to g_application_hold().
func (application application) Release() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_release(arg0)
}

// SendNotification sends a notification on behalf of @application to the
// desktop shell. There is no guarantee that the notification is displayed
// immediately, or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
//
// Modifying @notification after this call has no effect. However, the
// object can be reused for a later call to this function.
//
// @id may be any string that uniquely identifies the event for the
// application. It does not need to be in any special format. For example,
// "new-message" might be appropriate for a notification about new messages.
//
// If a previous notification was sent with the same @id, it will be
// replaced with @notification and shown again as if it was a new
// notification. This works even for notifications sent from a previous
// execution of the application, as long as @id is the same string.
//
// @id may be nil, but it is impossible to replace or withdraw notifications
// without an id.
//
// If @notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
func (application application) SendNotification(id string, notification Notification) {
	var arg0 *C.GApplication
	var arg1 *C.gchar
	var arg2 *C.GNotification

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GNotification)(notification.Native())

	C.g_application_send_notification(arg0, arg1, arg2)
}

// SetActionGroup: this used to be how actions were associated with a
// #GApplication. Now there is Map for that.
func (application application) SetActionGroup(actionGroup ActionGroup) {
	var arg0 *C.GApplication
	var arg1 *C.GActionGroup

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_set_action_group(arg0, arg1)
}

// SetApplicationID sets the unique identifier for @application.
//
// The application id can only be modified if @application has not yet been
// registered.
//
// If non-nil, the application id must be valid. See
// g_application_id_is_valid().
func (application application) SetApplicationID(applicationID string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_application_id(arg0, arg1)
}

// SetDefault sets or unsets the default application for the process, as
// returned by g_application_get_default().
//
// This function does not take its own reference on @application. If
// @application is destroyed then the default application will revert back
// to nil.
func (application application) SetDefault() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_set_default(arg0)
}

// SetFlags sets the flags for @application.
//
// The flags can only be modified if @application has not yet been
// registered.
//
// See Flags.
func (application application) SetFlags(flags ApplicationFlags) {
	var arg0 *C.GApplication
	var arg1 C.GApplicationFlags

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (C.GApplicationFlags)(flags)

	C.g_application_set_flags(arg0, arg1)
}

// SetInactivityTimeout sets the current inactivity timeout for the
// application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// This call has no side effects of its own. The value set here is only used
// for next time g_application_release() drops the use count to zero. Any
// timeouts currently in progress are not impacted.
func (application application) SetInactivityTimeout(inactivityTimeout uint) {
	var arg0 *C.GApplication
	var arg1 C.guint

	arg0 = (*C.GApplication)(application.Native())
	arg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(arg0, arg1)
}

// SetOptionContextDescription adds a description to the @application option
// context.
//
// See g_option_context_set_description() for more information.
func (application application) SetOptionContextDescription(description string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_description(arg0, arg1)
}

// SetOptionContextParameterString sets the parameter string to be used by
// the commandline handling of @application.
//
// This function registers the argument to be passed to
// g_option_context_new() when the internal Context of @application is
// created.
//
// See g_option_context_new() for more information about @parameter_string.
func (application application) SetOptionContextParameterString(parameterString string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(parameterString))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_parameter_string(arg0, arg1)
}

// SetOptionContextSummary adds a summary to the @application option
// context.
//
// See g_option_context_set_summary() for more information.
func (application application) SetOptionContextSummary(summary string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_summary(arg0, arg1)
}

// SetResourceBasePath sets (or unsets) the base resource path of
// @application.
//
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions. The
// various types of resources will be found at fixed names relative to the
// given base path.
//
// By default, the resource base path is determined from the application ID
// by prefixing '/' and replacing each '.' with '/'. This is done at the
// time that the #GApplication object is constructed. Changes to the
// application ID after that point will not have an impact on the resource
// base path.
//
// As an example, if the application has an ID of "org.example.app" then the
// default resource base path will be "/org/example/app". If this is a
// Application (and you have not manually changed the path) then Gtk will
// then search for the menus of the application at
// "/org/example/app/gtk/menus.ui".
//
// See #GResource for more information about adding resources to your
// application.
//
// You can disable automatic resource loading functionality by setting the
// path to nil.
//
// Changing the resource base path once the application is running is not
// recommended. The point at which the resource path is consulted for
// forming paths for various purposes is unspecified. When writing a
// sub-class of #GApplication you should either set the
// #GApplication:resource-base-path property at construction time, or call
// this function during the instance initialization. Alternatively, you can
// call this function in the Class.startup virtual function, before chaining
// up to the parent implementation.
func (application application) SetResourceBasePath(resourcePath string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_resource_base_path(arg0, arg1)
}

// UnbindBusyProperty destroys a binding between @property and the busy
// state of @application that was previously created with
// g_application_bind_busy_property().
func (application application) UnbindBusyProperty(object gextras.Objector, property string) {
	var arg0 *C.GApplication
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.GObject)(object.Native())
	arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg2))

	C.g_application_unbind_busy_property(arg0, arg1, arg2)
}

// UnmarkBusy decreases the busy count of @application.
//
// When the busy count reaches zero, the new state will be propagated to
// other processes.
//
// This function must only be called to cancel the effect of a previous call
// to g_application_mark_busy().
func (application application) UnmarkBusy() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(application.Native())

	C.g_application_unmark_busy(arg0)
}

// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with @id doesn't exist or the
// notification was never sent.
//
// This function works even for notifications sent in previous executions of
// this application, as long @id is the same as it was for the sent
// notification.
//
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no
// need to explicitly withdraw the notification in that case.
func (application application) WithdrawNotification(id string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(application.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_withdraw_notification(arg0, arg1)
}

// ApplicationCommandLine represents a command-line invocation of an
// application. It is created by #GApplication and emitted in the
// #GApplication::command-line signal and virtual function.
//
// The class contains the list of arguments that the program was invoked with.
// It is also possible to query if the commandline invocation was local (ie: the
// current process is running in direct response to the invocation) or remote
// (ie: some other process forwarded the commandline to this process).
//
// The GApplicationCommandLine object can provide the @argc and @argv parameters
// for use with the Context command-line parsing API, with the
// g_application_command_line_get_arguments() function. See
// [gapplication-example-cmdline3.c][gapplication-example-cmdline3] for an
// example.
//
// The exit status of the originally-invoked process may be set and messages can
// be printed to stdout or stderr of that process. The lifecycle of the
// originally-invoked process is tied to the lifecycle of this object (ie: the
// process exits when the last reference is dropped).
//
// The main use for CommandLine (and the #GApplication::command-line signal) is
// 'Emacs server' like use cases: You can set the `EDITOR` environment variable
// to have e.g. git use your favourite editor to edit commit messages, and if
// you already have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important aspect of
// this use case is that the process that gets started by git does not return
// until the editing is done.
//
// Normally, the commandline is completely handled in the
// #GApplication::command-line handler. The launching instance exits once the
// signal handler in the primary instance has returned, and the return value of
// the signal handler becomes the exit status of the launching instance.
//
//    static gboolean
//    my_cmdline_handler (gpointer data)
//    {
//      GApplicationCommandLine *cmdline = data;
//
//      // do the heavy lifting in an idle
//
//      g_application_command_line_set_exit_status (cmdline, 0);
//      g_object_unref (cmdline); // this releases the application
//
//      return G_SOURCE_REMOVE;
//    }
//
//    static int
//    command_line (GApplication            *application,
//                  GApplicationCommandLine *cmdline)
//    {
//      // keep the application running until we are done with this commandline
//      g_application_hold (application);
//
//      g_object_set_data_full (G_OBJECT (cmdline),
//                              "application", application,
//                              (GDestroyNotify)g_application_release);
//
//      g_object_ref (cmdline);
//      g_idle_add (my_cmdline_handler, cmdline);
//
//      return 0;
//    }
//
//
// In this example the commandline is not completely handled before the
// #GApplication::command-line handler returns. Instead, we keep a reference to
// the CommandLine object and handle it later (in this example, in an idle).
// Note that it is necessary to hold the application until you are done with the
// commandline.
//
// The complete example can be found here: gapplication-example-cmdline3.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine interface {
	gextras.Objector

	// Arguments gets the list of arguments that was passed on the command line.
	//
	// The strings in the array may contain non-UTF-8 data on UNIX (such as
	// filenames or arguments given in the system locale) but are always in
	// UTF-8 on Windows.
	//
	// If you wish to use the return value with Context, you must use
	// g_option_context_parse_strv().
	//
	// The return value is nil-terminated and should be freed using
	// g_strfreev().
	Arguments() (argc int, filenames []string)
	// Cwd gets the working directory of the command line invocation. The string
	// may contain non-utf8 data.
	//
	// It is possible that the remote application did not send a working
	// directory, so this may be nil.
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	Cwd() string
	// Environ gets the contents of the 'environ' variable of the command line
	// invocation, as would be returned by g_get_environ(), ie as a
	// nil-terminated list of strings in the form 'NAME=VALUE'. The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	//
	// See g_application_command_line_getenv() if you are only interested in the
	// value of a single environment variable.
	Environ() []string
	// ExitStatus gets the exit status of @cmdline. See
	// g_application_command_line_set_exit_status() for more information.
	ExitStatus() int
	// IsRemote determines if @cmdline represents a remote invocation.
	IsRemote() bool
	// OptionsDict gets the options there were passed to
	// g_application_command_line().
	//
	// If you did not override local_command_line() then these are the same
	// options that were parsed according to the Entrys added to the application
	// with g_application_add_main_option_entries() and possibly modified from
	// your GApplication::handle-local-options handler.
	//
	// If no options were sent then an empty dictionary is returned so that you
	// don't need to check for nil.
	OptionsDict() *glib.VariantDict
	// PlatformData gets the platform data associated with the invocation of
	// @cmdline.
	//
	// This is a #GVariant dictionary containing information about the context
	// in which the invocation occurred. It typically contains information like
	// the current working directory and the startup notification ID.
	//
	// For local invocation, it will be nil.
	PlatformData() *glib.Variant
	// Stdin gets the stdin of the invoking process.
	//
	// The Stream can be used to read data passed to the standard input of the
	// invoking process. This doesn't work on all platforms. Presently, it is
	// only available on UNIX when using a DBus daemon capable of passing file
	// descriptors. If stdin is not available then nil will be returned. In the
	// future, support may be expanded to other platforms.
	//
	// You must only call this function once per commandline invocation.
	Stdin() InputStream
	// env gets the value of a particular environment variable of the command
	// line invocation, as would be returned by g_getenv(). The strings may
	// contain non-utf8 data.
	//
	// The remote application usually does not send an environment. Use
	// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
	// is possible that the environment is still not available (due to
	// invocation messages from other applications).
	//
	// The return value should not be modified or freed and is valid for as long
	// as @cmdline exists.
	env(name string) string
	// SetExitStatus sets the exit status that will be used when the invoking
	// process exits.
	//
	// The return value of the #GApplication::command-line signal is passed to
	// this function when the handler returns. This is the usual way of setting
	// the exit status.
	//
	// In the event that you want the remote invocation to continue running and
	// want to decide on the exit status in the future, you can use this call.
	// For the case of a remote invocation, the remote process will typically
	// exit when the last reference is dropped on @cmdline. The exit status of
	// the remote process will be equal to the last value that was set with this
	// function.
	//
	// In the case that the commandline invocation is local, the situation is
	// slightly more complicated. If the commandline invocation results in the
	// mainloop running (ie: because the use-count of the application increased
	// to a non-zero value) then the application is considered to have been
	// 'successful' in a certain sense, and the exit status is always zero. If
	// the application use count is zero, though, the exit status of the local
	// CommandLine is used.
	SetExitStatus(exitStatus int)
}

// applicationCommandLine implements the ApplicationCommandLine interface.
type applicationCommandLine struct {
	gextras.Objector
}

// WrapApplicationCommandLine wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplicationCommandLine(obj *externglib.Object) ApplicationCommandLine {
	return ApplicationCommandLine{
		gextras.Objector: (obj),
	}
}

func marshalApplicationCommandLine(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplicationCommandLine(obj), nil
}

// Arguments gets the list of arguments that was passed on the command line.
//
// The strings in the array may contain non-UTF-8 data on UNIX (such as
// filenames or arguments given in the system locale) but are always in
// UTF-8 on Windows.
//
// If you wish to use the return value with Context, you must use
// g_option_context_parse_strv().
//
// The return value is nil-terminated and should be freed using
// g_strfreev().
func (cmdline applicationCommandLine) Arguments() (argc int, filenames []string) {
	var arg0 *C.GApplicationCommandLine
	var arg1 *C.int // out

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_arguments(arg0, &arg1)

	var ret0 int
	var ret1 []string

	ret0 = int(arg1)

	{
		ret1 = make([]string, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.filename)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// Cwd gets the working directory of the command line invocation. The string
// may contain non-utf8 data.
//
// It is possible that the remote application did not send a working
// directory, so this may be nil.
//
// The return value should not be modified or freed and is valid for as long
// as @cmdline exists.
func (cmdline applicationCommandLine) Cwd() string {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_cwd(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Environ gets the contents of the 'environ' variable of the command line
// invocation, as would be returned by g_get_environ(), ie as a
// nil-terminated list of strings in the form 'NAME=VALUE'. The strings may
// contain non-utf8 data.
//
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
// is possible that the environment is still not available (due to
// invocation messages from other applications).
//
// The return value should not be modified or freed and is valid for as long
// as @cmdline exists.
//
// See g_application_command_line_getenv() if you are only interested in the
// value of a single environment variable.
func (cmdline applicationCommandLine) Environ() []string {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_environ(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.filename)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// ExitStatus gets the exit status of @cmdline. See
// g_application_command_line_set_exit_status() for more information.
func (cmdline applicationCommandLine) ExitStatus() int {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_exit_status(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsRemote determines if @cmdline represents a remote invocation.
func (cmdline applicationCommandLine) IsRemote() bool {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_is_remote(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// OptionsDict gets the options there were passed to
// g_application_command_line().
//
// If you did not override local_command_line() then these are the same
// options that were parsed according to the Entrys added to the application
// with g_application_add_main_option_entries() and possibly modified from
// your GApplication::handle-local-options handler.
//
// If no options were sent then an empty dictionary is returned so that you
// don't need to check for nil.
func (cmdline applicationCommandLine) OptionsDict() *glib.VariantDict {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_options_dict(arg0)

	var ret0 *glib.VariantDict

	ret0 = glib.WrapVariantDict(ret)

	return ret0
}

// PlatformData gets the platform data associated with the invocation of
// @cmdline.
//
// This is a #GVariant dictionary containing information about the context
// in which the invocation occurred. It typically contains information like
// the current working directory and the startup notification ID.
//
// For local invocation, it will be nil.
func (cmdline applicationCommandLine) PlatformData() *glib.Variant {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_platform_data(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Stdin gets the stdin of the invoking process.
//
// The Stream can be used to read data passed to the standard input of the
// invoking process. This doesn't work on all platforms. Presently, it is
// only available on UNIX when using a DBus daemon capable of passing file
// descriptors. If stdin is not available then nil will be returned. In the
// future, support may be expanded to other platforms.
//
// You must only call this function once per commandline invocation.
func (cmdline applicationCommandLine) Stdin() InputStream {
	var arg0 *C.GApplicationCommandLine

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())

	ret := C.g_application_command_line_get_stdin(arg0)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// env gets the value of a particular environment variable of the command
// line invocation, as would be returned by g_getenv(). The strings may
// contain non-utf8 data.
//
// The remote application usually does not send an environment. Use
// G_APPLICATION_SEND_ENVIRONMENT to affect that. Even with this flag set it
// is possible that the environment is still not available (due to
// invocation messages from other applications).
//
// The return value should not be modified or freed and is valid for as long
// as @cmdline exists.
func (cmdline applicationCommandLine) env(name string) string {
	var arg0 *C.GApplicationCommandLine
	var arg1 *C.gchar

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_application_command_line_getenv(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetExitStatus sets the exit status that will be used when the invoking
// process exits.
//
// The return value of the #GApplication::command-line signal is passed to
// this function when the handler returns. This is the usual way of setting
// the exit status.
//
// In the event that you want the remote invocation to continue running and
// want to decide on the exit status in the future, you can use this call.
// For the case of a remote invocation, the remote process will typically
// exit when the last reference is dropped on @cmdline. The exit status of
// the remote process will be equal to the last value that was set with this
// function.
//
// In the case that the commandline invocation is local, the situation is
// slightly more complicated. If the commandline invocation results in the
// mainloop running (ie: because the use-count of the application increased
// to a non-zero value) then the application is considered to have been
// 'successful' in a certain sense, and the exit status is always zero. If
// the application use count is zero, though, the exit status of the local
// CommandLine is used.
func (cmdline applicationCommandLine) SetExitStatus(exitStatus int) {
	var arg0 *C.GApplicationCommandLine
	var arg1 C.int

	arg0 = (*C.GApplicationCommandLine)(cmdline.Native())
	arg1 = C.int(exitStatus)

	C.g_application_command_line_set_exit_status(arg0, arg1)
}

// BufferedInputStream: buffered input stream implements InputStream and
// provides for buffered reads.
//
// By default, InputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered input stream, use g_buffered_input_stream_new(), or
// g_buffered_input_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_input_stream_get_buffer_size(). To change the size of a buffered
// input stream's buffer, use g_buffered_input_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedInputStream interface {
	FilterInputStream

	// Fill tries to read @count bytes from the stream into the buffer. Will
	// block during this read.
	//
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	//
	// For the asynchronous, non-blocking, version of this function, see
	// g_buffered_input_stream_fill_async().
	Fill(count int, cancellable Cancellable) int
	// FillAsync reads data into @stream's buffer asynchronously, up to @count
	// size. @io_priority can be used to prioritize reads. For the synchronous
	// version of this function, see g_buffered_input_stream_fill().
	//
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	FillAsync(count int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// Available gets the size of the available data within the stream.
	Available() uint
	// BufferSize gets the size of the input buffer.
	BufferSize() uint
	// PeekBuffer returns the buffer with the currently available bytes. The
	// returned buffer must not be modified and will become invalid when reading
	// from the stream or filling the buffer.
	PeekBuffer() (count uint, guint8s []byte)
	// ReadByte tries to read a single byte from the stream or the buffer. Will
	// block during this read.
	//
	// On success, the byte read from the stream is returned. On end of stream
	// -1 is returned but it's not an exceptional error and @error is not set.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	ReadByte(cancellable Cancellable) int
	// SetBufferSize sets the size of the internal buffer of @stream to @size,
	// or to the size of the contents of the buffer. The buffer can never be
	// resized smaller than its current contents.
	SetBufferSize(size uint)
}

// bufferedInputStream implements the BufferedInputStream interface.
type bufferedInputStream struct {
	FilterInputStream
}

// WrapBufferedInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedInputStream(obj *externglib.Object) BufferedInputStream {
	return BufferedInputStream{
		FilterInputStream: WrapFilterInputStream(obj),
	}
}

func marshalBufferedInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedInputStream(obj), nil
}

// NewBufferedInputStream constructs a class BufferedInputStream.
func NewBufferedInputStream(baseStream InputStream) BufferedInputStream {
	var arg1 *C.GInputStream

	arg1 = (*C.GInputStream)(baseStream.Native())

	ret := C.g_buffered_input_stream_new(arg1)

	var ret0 BufferedInputStream

	ret0 = WrapBufferedInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBufferedInputStreamSized constructs a class BufferedInputStream.
func NewBufferedInputStreamSized(baseStream InputStream, size uint) BufferedInputStream {
	var arg1 *C.GInputStream
	var arg2 C.gsize

	arg1 = (*C.GInputStream)(baseStream.Native())
	arg2 = C.gsize(size)

	ret := C.g_buffered_input_stream_new_sized(arg1, arg2)

	var ret0 BufferedInputStream

	ret0 = WrapBufferedInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Fill tries to read @count bytes from the stream into the buffer. Will
// block during this read.
//
// If @count is zero, returns zero and does nothing. A value of @count
// larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned. It is
// not an error if this is not the same as the requested size, as it can
// happen e.g. near the end of a file. Zero is returned on end of file (or
// if @count is zero), but never otherwise.
//
// If @count is -1 then the attempted read size is equal to the number of
// bytes that are required to fill the buffer.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error -1 is returned and @error is set accordingly.
//
// For the asynchronous, non-blocking, version of this function, see
// g_buffered_input_stream_fill_async().
func (stream bufferedInputStream) Fill(count int, cancellable Cancellable) int {
	var arg0 *C.GBufferedInputStream
	var arg1 C.gssize
	var arg2 *C.GCancellable

	arg0 = (*C.GBufferedInputStream)(stream.Native())
	arg1 = C.gssize(count)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_buffered_input_stream_fill(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// FillAsync reads data into @stream's buffer asynchronously, up to @count
// size. @io_priority can be used to prioritize reads. For the synchronous
// version of this function, see g_buffered_input_stream_fill().
//
// If @count is -1 then the attempted read size is equal to the number of
// bytes that are required to fill the buffer.
func (stream bufferedInputStream) FillAsync(count int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GBufferedInputStream
	var arg1 C.gssize
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GBufferedInputStream)(stream.Native())
	arg1 = C.gssize(count)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_buffered_input_stream_fill_async(arg0, arg1, arg2, arg3, arg4)
}

// Available gets the size of the available data within the stream.
func (stream bufferedInputStream) Available() uint {
	var arg0 *C.GBufferedInputStream

	arg0 = (*C.GBufferedInputStream)(stream.Native())

	ret := C.g_buffered_input_stream_get_available(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// BufferSize gets the size of the input buffer.
func (stream bufferedInputStream) BufferSize() uint {
	var arg0 *C.GBufferedInputStream

	arg0 = (*C.GBufferedInputStream)(stream.Native())

	ret := C.g_buffered_input_stream_get_buffer_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// PeekBuffer returns the buffer with the currently available bytes. The
// returned buffer must not be modified and will become invalid when reading
// from the stream or filling the buffer.
func (stream bufferedInputStream) PeekBuffer() (count uint, guint8s []byte) {
	var arg0 *C.GBufferedInputStream
	var arg1 *C.gsize // out

	arg0 = (*C.GBufferedInputStream)(stream.Native())

	ret := C.g_buffered_input_stream_peek_buffer(arg0, &arg1)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// ReadByte tries to read a single byte from the stream or the buffer. Will
// block during this read.
//
// On success, the byte read from the stream is returned. On end of stream
// -1 is returned but it's not an exceptional error and @error is not set.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error -1 is returned and @error is set accordingly.
func (stream bufferedInputStream) ReadByte(cancellable Cancellable) int {
	var arg0 *C.GBufferedInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GBufferedInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_buffered_input_stream_read_byte(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetBufferSize sets the size of the internal buffer of @stream to @size,
// or to the size of the contents of the buffer. The buffer can never be
// resized smaller than its current contents.
func (stream bufferedInputStream) SetBufferSize(size uint) {
	var arg0 *C.GBufferedInputStream
	var arg1 C.gsize

	arg0 = (*C.GBufferedInputStream)(stream.Native())
	arg1 = C.gsize(size)

	C.g_buffered_input_stream_set_buffer_size(arg0, arg1)
}

// BufferedOutputStream: buffered output stream implements OutputStream and
// provides for buffered writes.
//
// By default, OutputStream's buffer size is set at 4 kilobytes.
//
// To create a buffered output stream, use g_buffered_output_stream_new(), or
// g_buffered_output_stream_new_sized() to specify the buffer's size at
// construction.
//
// To get the size of a buffer within a buffered input stream, use
// g_buffered_output_stream_get_buffer_size(). To change the size of a buffered
// output stream's buffer, use g_buffered_output_stream_set_buffer_size(). Note
// that the buffer's size cannot be reduced below the size of the data within
// the buffer.
type BufferedOutputStream interface {
	FilterOutputStream

	// AutoGrow checks if the buffer automatically grows as data is added.
	AutoGrow() bool
	// BufferSize gets the size of the buffer in the @stream.
	BufferSize() uint
	// SetAutoGrow sets whether or not the @stream's buffer should automatically
	// grow. If @auto_grow is true, then each write will just make the buffer
	// larger, and you must manually flush the buffer to actually write out the
	// data to the underlying stream.
	SetAutoGrow(autoGrow bool)
	// SetBufferSize sets the size of the internal buffer to @size.
	SetBufferSize(size uint)
}

// bufferedOutputStream implements the BufferedOutputStream interface.
type bufferedOutputStream struct {
	FilterOutputStream
}

// WrapBufferedOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapBufferedOutputStream(obj *externglib.Object) BufferedOutputStream {
	return BufferedOutputStream{
		FilterOutputStream: WrapFilterOutputStream(obj),
	}
}

func marshalBufferedOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBufferedOutputStream(obj), nil
}

// NewBufferedOutputStream constructs a class BufferedOutputStream.
func NewBufferedOutputStream(baseStream OutputStream) BufferedOutputStream {
	var arg1 *C.GOutputStream

	arg1 = (*C.GOutputStream)(baseStream.Native())

	ret := C.g_buffered_output_stream_new(arg1)

	var ret0 BufferedOutputStream

	ret0 = WrapBufferedOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewBufferedOutputStreamSized constructs a class BufferedOutputStream.
func NewBufferedOutputStreamSized(baseStream OutputStream, size uint) BufferedOutputStream {
	var arg1 *C.GOutputStream
	var arg2 C.gsize

	arg1 = (*C.GOutputStream)(baseStream.Native())
	arg2 = C.gsize(size)

	ret := C.g_buffered_output_stream_new_sized(arg1, arg2)

	var ret0 BufferedOutputStream

	ret0 = WrapBufferedOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AutoGrow checks if the buffer automatically grows as data is added.
func (stream bufferedOutputStream) AutoGrow() bool {
	var arg0 *C.GBufferedOutputStream

	arg0 = (*C.GBufferedOutputStream)(stream.Native())

	ret := C.g_buffered_output_stream_get_auto_grow(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// BufferSize gets the size of the buffer in the @stream.
func (stream bufferedOutputStream) BufferSize() uint {
	var arg0 *C.GBufferedOutputStream

	arg0 = (*C.GBufferedOutputStream)(stream.Native())

	ret := C.g_buffered_output_stream_get_buffer_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SetAutoGrow sets whether or not the @stream's buffer should automatically
// grow. If @auto_grow is true, then each write will just make the buffer
// larger, and you must manually flush the buffer to actually write out the
// data to the underlying stream.
func (stream bufferedOutputStream) SetAutoGrow(autoGrow bool) {
	var arg0 *C.GBufferedOutputStream
	var arg1 C.gboolean

	arg0 = (*C.GBufferedOutputStream)(stream.Native())
	arg1 = gextras.Cbool(autoGrow)

	C.g_buffered_output_stream_set_auto_grow(arg0, arg1)
}

// SetBufferSize sets the size of the internal buffer to @size.
func (stream bufferedOutputStream) SetBufferSize(size uint) {
	var arg0 *C.GBufferedOutputStream
	var arg1 C.gsize

	arg0 = (*C.GBufferedOutputStream)(stream.Native())
	arg1 = C.gsize(size)

	C.g_buffered_output_stream_set_buffer_size(arg0, arg1)
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector

	// Bytes gets the #GBytes associated with the given @icon.
	Bytes() *glib.Bytes
}

// bytesIcon implements the BytesIcon interface.
type bytesIcon struct {
	gextras.Objector
}

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return BytesIcon{
		gextras.Objector: (obj),
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

// NewBytesIcon constructs a class BytesIcon.
func NewBytesIcon(bytes *glib.Bytes) BytesIcon {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(bytes.Native())

	ret := C.g_bytes_icon_new(arg1)

	var ret0 BytesIcon

	ret0 = WrapBytesIcon(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Bytes gets the #GBytes associated with the given @icon.
func (icon bytesIcon) Bytes() *glib.Bytes {
	var arg0 *C.GBytesIcon

	arg0 = (*C.GBytesIcon)(icon.Native())

	ret := C.g_bytes_icon_get_bytes(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable interface {
	gextras.Objector

	// Cancel: will set @cancellable to cancelled, and will emit the
	// #GCancellable::cancelled signal. (However, see the warning about race
	// conditions in the documentation for that signal if you are planning to
	// connect to it.)
	//
	// This function is thread-safe. In other words, you can safely call it from
	// a thread other than the one running the operation that was passed the
	// @cancellable.
	//
	// If @cancellable is nil, this function returns immediately for
	// convenience.
	//
	// The convention within GIO is that cancelling an asynchronous operation
	// causes it to complete asynchronously. That is, if you cancel the
	// operation from the same thread in which it is running, then the
	// operation's ReadyCallback will not be invoked until the application
	// returns to the main loop.
	Cancel()
	// Disconnect disconnects a handler from a cancellable instance similar to
	// g_signal_handler_disconnect(). Additionally, in the event that a signal
	// handler is currently running, this call will block until the handler has
	// finished. Calling this function from a #GCancellable::cancelled signal
	// handler will therefore result in a deadlock.
	//
	// This avoids a race condition where a thread cancels at the same time as
	// the cancellable operation is finished and the signal handler is removed.
	// See #GCancellable::cancelled for details on how to use this.
	//
	// If @cancellable is nil or @handler_id is `0` this function does nothing.
	Disconnect(handlerID uint32)
	// Fd gets the file descriptor for a cancellable job. This can be used to
	// implement cancellable operations on Unix systems. The returned fd will
	// turn readable when @cancellable is cancelled.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	//
	// After a successful return from this function, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// returned file descriptor.
	//
	// See also g_cancellable_make_pollfd().
	Fd() int
	// IsCancelled checks if a cancellable job has been cancelled.
	IsCancelled() bool
	// MakePollfd creates a FD corresponding to @cancellable; this can be passed
	// to g_poll() and used to poll for cancellation. This is useful both for
	// unix systems without a native poll and for portability to windows.
	//
	// When this function returns true, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// @pollfd. After a false return, do not call g_cancellable_release_fd().
	//
	// If this function returns false, either no @cancellable was given or
	// resource limits prevent this function from allocating the necessary
	// structures for polling. (On Linux, you will likely have reached the
	// maximum number of file descriptors.) The suggested way to handle these
	// cases is to ignore the @cancellable.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	MakePollfd(pollfd *glib.PollFD) bool
	// PopCurrent pops @cancellable off the cancellable stack (verifying that
	// @cancellable is on the top of the stack).
	PopCurrent()
	// PushCurrent pushes @cancellable onto the cancellable stack. The current
	// cancellable can then be received using g_cancellable_get_current().
	//
	// This is useful when implementing cancellable operations in code that does
	// not allow you to pass down the cancellable object.
	//
	// This is typically called automatically by e.g. #GFile operations, so you
	// rarely have to call this yourself.
	PushCurrent()
	// ReleaseFd releases a resources previously allocated by
	// g_cancellable_get_fd() or g_cancellable_make_pollfd().
	//
	// For compatibility reasons with older releases, calling this function is
	// not strictly required, the resources will be automatically freed when the
	// @cancellable is finalized. However, the @cancellable will block scarce
	// file descriptors until it is finalized if this function is not called.
	// This can cause the application to run out of file descriptors when many
	// #GCancellables are used at the same time.
	ReleaseFd()
	// Reset resets @cancellable to its uncancelled state.
	//
	// If cancellable is currently in use by any cancellable operation then the
	// behavior of this function is undefined.
	//
	// Note that it is generally not a good idea to reuse an existing
	// cancellable for more operations after it has been cancelled once, as this
	// function might tempt you to do. The recommended practice is to drop the
	// reference to a cancellable after cancelling it, and let it die with the
	// outstanding async operations. You should create a fresh cancellable for
	// further async operations.
	Reset()
	// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
	// notify that the operation was cancelled.
	SetErrorIfCancelled() bool
	// NewSource creates a source that triggers if @cancellable is cancelled and
	// calls its callback of type SourceFunc. This is primarily useful for
	// attaching to another (non-cancellable) source with
	// g_source_add_child_source() to add cancellability to it.
	//
	// For convenience, you can call this with a nil #GCancellable, in which
	// case the source will never trigger.
	//
	// The new #GSource will hold a reference to the #GCancellable.
	NewSource() *glib.Source
}

// cancellable implements the Cancellable interface.
type cancellable struct {
	gextras.Objector
}

// WrapCancellable wraps a GObject to the right type. It is
// primarily used internally.
func WrapCancellable(obj *externglib.Object) Cancellable {
	return Cancellable{
		gextras.Objector: (obj),
	}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCancellable(obj), nil
}

// NewCancellable constructs a class Cancellable.
func NewCancellable() Cancellable {

	ret := C.g_cancellable_new()

	var ret0 Cancellable

	ret0 = WrapCancellable(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Cancel: will set @cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about race
// conditions in the documentation for that signal if you are planning to
// connect to it.)
//
// This function is thread-safe. In other words, you can safely call it from
// a thread other than the one running the operation that was passed the
// @cancellable.
//
// If @cancellable is nil, this function returns immediately for
// convenience.
//
// The convention within GIO is that cancelling an asynchronous operation
// causes it to complete asynchronously. That is, if you cancel the
// operation from the same thread in which it is running, then the
// operation's ReadyCallback will not be invoked until the application
// returns to the main loop.
func (cancellable cancellable) Cancel() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	C.g_cancellable_cancel(arg0)
}

// Disconnect disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect(). Additionally, in the event that a signal
// handler is currently running, this call will block until the handler has
// finished. Calling this function from a #GCancellable::cancelled signal
// handler will therefore result in a deadlock.
//
// This avoids a race condition where a thread cancels at the same time as
// the cancellable operation is finished and the signal handler is removed.
// See #GCancellable::cancelled for details on how to use this.
//
// If @cancellable is nil or @handler_id is `0` this function does nothing.
func (cancellable cancellable) Disconnect(handlerID uint32) {
	var arg0 *C.GCancellable
	var arg1 C.gulong

	arg0 = (*C.GCancellable)(cancellable.Native())
	arg1 = C.gulong(handlerID)

	C.g_cancellable_disconnect(arg0, arg1)
}

// Fd gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will
// turn readable when @cancellable is cancelled.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done with
// g_cancellable_reset().
//
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// returned file descriptor.
//
// See also g_cancellable_make_pollfd().
func (cancellable cancellable) Fd() int {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_cancellable_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsCancelled checks if a cancellable job has been cancelled.
func (cancellable cancellable) IsCancelled() bool {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_cancellable_is_cancelled(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MakePollfd creates a FD corresponding to @cancellable; this can be passed
// to g_poll() and used to poll for cancellation. This is useful both for
// unix systems without a native poll and for portability to windows.
//
// When this function returns true, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// @pollfd. After a false return, do not call g_cancellable_release_fd().
//
// If this function returns false, either no @cancellable was given or
// resource limits prevent this function from allocating the necessary
// structures for polling. (On Linux, you will likely have reached the
// maximum number of file descriptors.) The suggested way to handle these
// cases is to ignore the @cancellable.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done with
// g_cancellable_reset().
func (cancellable cancellable) MakePollfd(pollfd *glib.PollFD) bool {
	var arg0 *C.GCancellable
	var arg1 *C.GPollFD

	arg0 = (*C.GCancellable)(cancellable.Native())
	arg1 = (*C.GPollFD)(pollfd.Native())

	ret := C.g_cancellable_make_pollfd(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PopCurrent pops @cancellable off the cancellable stack (verifying that
// @cancellable is on the top of the stack).
func (cancellable cancellable) PopCurrent() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	C.g_cancellable_pop_current(arg0)
}

// PushCurrent pushes @cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
//
// This is useful when implementing cancellable operations in code that does
// not allow you to pass down the cancellable object.
//
// This is typically called automatically by e.g. #GFile operations, so you
// rarely have to call this yourself.
func (cancellable cancellable) PushCurrent() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	C.g_cancellable_push_current(arg0)
}

// ReleaseFd releases a resources previously allocated by
// g_cancellable_get_fd() or g_cancellable_make_pollfd().
//
// For compatibility reasons with older releases, calling this function is
// not strictly required, the resources will be automatically freed when the
// @cancellable is finalized. However, the @cancellable will block scarce
// file descriptors until it is finalized if this function is not called.
// This can cause the application to run out of file descriptors when many
// #GCancellables are used at the same time.
func (cancellable cancellable) ReleaseFd() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	C.g_cancellable_release_fd(arg0)
}

// Reset resets @cancellable to its uncancelled state.
//
// If cancellable is currently in use by any cancellable operation then the
// behavior of this function is undefined.
//
// Note that it is generally not a good idea to reuse an existing
// cancellable for more operations after it has been cancelled once, as this
// function might tempt you to do. The recommended practice is to drop the
// reference to a cancellable after cancelling it, and let it die with the
// outstanding async operations. You should create a fresh cancellable for
// further async operations.
func (cancellable cancellable) Reset() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	C.g_cancellable_reset(arg0)
}

// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
// notify that the operation was cancelled.
func (cancellable cancellable) SetErrorIfCancelled() bool {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_cancellable_set_error_if_cancelled(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NewSource creates a source that triggers if @cancellable is cancelled and
// calls its callback of type SourceFunc. This is primarily useful for
// attaching to another (non-cancellable) source with
// g_source_add_child_source() to add cancellability to it.
//
// For convenience, you can call this with a nil #GCancellable, in which
// case the source will never trigger.
//
// The new #GSource will hold a reference to the #GCancellable.
func (cancellable cancellable) NewSource() *glib.Source {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_cancellable_source_new(arg0)

	var ret0 *glib.Source

	ret0 = glib.WrapSource(ret)

	return ret0
}

// CharsetConverter is an implementation of #GConverter based on GIConv.
type CharsetConverter interface {
	gextras.Objector

	// NumFallbacks gets the number of fallbacks that @converter has applied so
	// far.
	NumFallbacks() uint
	// UseFallback gets the Converter:use-fallback property.
	UseFallback() bool
	// SetUseFallback sets the Converter:use-fallback property.
	SetUseFallback(useFallback bool)
}

// charsetConverter implements the CharsetConverter interface.
type charsetConverter struct {
	gextras.Objector
}

// WrapCharsetConverter wraps a GObject to the right type. It is
// primarily used internally.
func WrapCharsetConverter(obj *externglib.Object) CharsetConverter {
	return CharsetConverter{
		gextras.Objector: (obj),
	}
}

func marshalCharsetConverter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCharsetConverter(obj), nil
}

// NewCharsetConverter constructs a class CharsetConverter.
func NewCharsetConverter(toCharset string, fromCharset string) CharsetConverter {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(toCharset))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(fromCharset))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_charset_converter_new(arg1, arg2)

	var ret0 CharsetConverter

	ret0 = WrapCharsetConverter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NumFallbacks gets the number of fallbacks that @converter has applied so
// far.
func (converter charsetConverter) NumFallbacks() uint {
	var arg0 *C.GCharsetConverter

	arg0 = (*C.GCharsetConverter)(converter.Native())

	ret := C.g_charset_converter_get_num_fallbacks(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// UseFallback gets the Converter:use-fallback property.
func (converter charsetConverter) UseFallback() bool {
	var arg0 *C.GCharsetConverter

	arg0 = (*C.GCharsetConverter)(converter.Native())

	ret := C.g_charset_converter_get_use_fallback(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetUseFallback sets the Converter:use-fallback property.
func (converter charsetConverter) SetUseFallback(useFallback bool) {
	var arg0 *C.GCharsetConverter
	var arg1 C.gboolean

	arg0 = (*C.GCharsetConverter)(converter.Native())
	arg1 = gextras.Cbool(useFallback)

	C.g_charset_converter_set_use_fallback(arg0, arg1)
}

// ConverterInputStream: converter input stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, InputStream implements InputStream.
type ConverterInputStream interface {
	FilterInputStream
}

// converterInputStream implements the ConverterInputStream interface.
type converterInputStream struct {
	FilterInputStream
}

// WrapConverterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterInputStream(obj *externglib.Object) ConverterInputStream {
	return ConverterInputStream{
		FilterInputStream: WrapFilterInputStream(obj),
	}
}

func marshalConverterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterInputStream(obj), nil
}

// ConverterOutputStream: converter output stream implements Stream and allows
// conversion of data of various types during reading.
//
// As of GLib 2.34, OutputStream implements OutputStream.
type ConverterOutputStream interface {
	FilterOutputStream
}

// converterOutputStream implements the ConverterOutputStream interface.
type converterOutputStream struct {
	FilterOutputStream
}

// WrapConverterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapConverterOutputStream(obj *externglib.Object) ConverterOutputStream {
	return ConverterOutputStream{
		FilterOutputStream: WrapFilterOutputStream(obj),
	}
}

func marshalConverterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConverterOutputStream(obj), nil
}

// Credentials: the #GCredentials type is a reference-counted wrapper for native
// credentials. This information is typically used for identifying,
// authenticating and authorizing other processes.
//
// Some operating systems supports looking up the credentials of the remote peer
// of a communication endpoint - see e.g. g_socket_get_credentials().
//
// Some operating systems supports securely sending and receiving credentials
// over a Unix Domain Socket, see CredentialsMessage,
// g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials() for details.
//
// On Linux, the native credential type is a `struct ucred` - see the unix(7)
// man page for details. This corresponds to G_CREDENTIALS_TYPE_LINUX_UCRED.
//
// On Apple operating systems (including iOS, tvOS, and macOS), the native
// credential type is a `struct xucred`. This corresponds to
// G_CREDENTIALS_TYPE_APPLE_XUCRED.
//
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is
// a `struct cmsgcred`. This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
//
// On NetBSD, the native credential type is a `struct unpcbid`. This corresponds
// to G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
//
// On OpenBSD, the native credential type is a `struct sockpeercred`. This
// corresponds to G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
//
// On Solaris (including OpenSolaris and its derivatives), the native credential
// type is a `ucred_t`. This corresponds to G_CREDENTIALS_TYPE_SOLARIS_UCRED.
type Credentials interface {
	gextras.Objector

	// Native gets a pointer to native credentials of type @native_type from
	// @credentials.
	//
	// It is a programming error (which will cause a warning to be logged) to
	// use this method if there is no #GCredentials support for the OS or if
	// @native_type isn't supported by the OS.
	Native(nativeType CredentialsType) interface{}
	// UnixPid tries to get the UNIX process identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// process ID (for example this is the case for
	// G_CREDENTIALS_TYPE_APPLE_XUCRED).
	UnixPid() int
	// UnixUser tries to get the UNIX user identifier from @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user.
	UnixUser() uint
	// IsSameUser checks if @credentials and @other_credentials is the same
	// user.
	//
	// This operation can fail if #GCredentials is not supported on the the OS.
	IsSameUser(otherCredentials Credentials) bool
	// SetNative copies the native credentials of type @native_type from @native
	// into @credentials.
	//
	// It is a programming error (which will cause a warning to be logged) to
	// use this method if there is no #GCredentials support for the OS or if
	// @native_type isn't supported by the OS.
	SetNative(nativeType CredentialsType, native interface{})
	// SetUnixUser tries to set the UNIX user identifier on @credentials. This
	// method is only available on UNIX platforms.
	//
	// This operation can fail if #GCredentials is not supported on the OS or if
	// the native credentials type does not contain information about the UNIX
	// user. It can also fail if the OS does not allow the use of "spoofed"
	// credentials.
	SetUnixUser(uid uint) bool
	// String creates a human-readable textual representation of @credentials
	// that can be used in logging and debug messages. The format of the
	// returned string may change in future GLib release.
	String() string
}

// credentials implements the Credentials interface.
type credentials struct {
	gextras.Objector
}

// WrapCredentials wraps a GObject to the right type. It is
// primarily used internally.
func WrapCredentials(obj *externglib.Object) Credentials {
	return Credentials{
		gextras.Objector: (obj),
	}
}

func marshalCredentials(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCredentials(obj), nil
}

// NewCredentials constructs a class Credentials.
func NewCredentials() Credentials {

	ret := C.g_credentials_new()

	var ret0 Credentials

	ret0 = WrapCredentials(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Native gets a pointer to native credentials of type @native_type from
// @credentials.
//
// It is a programming error (which will cause a warning to be logged) to
// use this method if there is no #GCredentials support for the OS or if
// @native_type isn't supported by the OS.
func (credentials credentials) Native(nativeType CredentialsType) interface{} {
	var arg0 *C.GCredentials
	var arg1 C.GCredentialsType

	arg0 = (*C.GCredentials)(credentials.Native())
	arg1 = (C.GCredentialsType)(nativeType)

	ret := C.g_credentials_get_native(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// UnixPid tries to get the UNIX process identifier from @credentials. This
// method is only available on UNIX platforms.
//
// This operation can fail if #GCredentials is not supported on the OS or if
// the native credentials type does not contain information about the UNIX
// process ID (for example this is the case for
// G_CREDENTIALS_TYPE_APPLE_XUCRED).
func (credentials credentials) UnixPid() int {
	var arg0 *C.GCredentials

	arg0 = (*C.GCredentials)(credentials.Native())

	ret := C.g_credentials_get_unix_pid(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnixUser tries to get the UNIX user identifier from @credentials. This
// method is only available on UNIX platforms.
//
// This operation can fail if #GCredentials is not supported on the OS or if
// the native credentials type does not contain information about the UNIX
// user.
func (credentials credentials) UnixUser() uint {
	var arg0 *C.GCredentials

	arg0 = (*C.GCredentials)(credentials.Native())

	ret := C.g_credentials_get_unix_user(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsSameUser checks if @credentials and @other_credentials is the same
// user.
//
// This operation can fail if #GCredentials is not supported on the the OS.
func (credentials credentials) IsSameUser(otherCredentials Credentials) bool {
	var arg0 *C.GCredentials
	var arg1 *C.GCredentials

	arg0 = (*C.GCredentials)(credentials.Native())
	arg1 = (*C.GCredentials)(otherCredentials.Native())

	ret := C.g_credentials_is_same_user(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetNative copies the native credentials of type @native_type from @native
// into @credentials.
//
// It is a programming error (which will cause a warning to be logged) to
// use this method if there is no #GCredentials support for the OS or if
// @native_type isn't supported by the OS.
func (credentials credentials) SetNative(nativeType CredentialsType, native interface{}) {
	var arg0 *C.GCredentials
	var arg1 C.GCredentialsType
	var arg2 C.gpointer

	arg0 = (*C.GCredentials)(credentials.Native())
	arg1 = (C.GCredentialsType)(nativeType)
	arg2 = C.gpointer(box.Assign(native))

	C.g_credentials_set_native(arg0, arg1, arg2)
}

// SetUnixUser tries to set the UNIX user identifier on @credentials. This
// method is only available on UNIX platforms.
//
// This operation can fail if #GCredentials is not supported on the OS or if
// the native credentials type does not contain information about the UNIX
// user. It can also fail if the OS does not allow the use of "spoofed"
// credentials.
func (credentials credentials) SetUnixUser(uid uint) bool {
	var arg0 *C.GCredentials
	var arg1 C.uid_t

	arg0 = (*C.GCredentials)(credentials.Native())
	arg1 = C.uid_t(uid)

	ret := C.g_credentials_set_unix_user(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// String creates a human-readable textual representation of @credentials
// that can be used in logging and debug messages. The format of the
// returned string may change in future GLib release.
func (credentials credentials) String() string {
	var arg0 *C.GCredentials

	arg0 = (*C.GCredentials)(credentials.Native())

	ret := C.g_credentials_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector
}

// dBusActionGroup implements the DBusActionGroup interface.
type dBusActionGroup struct {
	gextras.Objector
}

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return DBusActionGroup{
		gextras.Objector: (obj),
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
//
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver interface.
type dBusAuthObserver struct {
	gextras.Objector
}

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return DBusAuthObserver{
		gextras.Objector: (obj),
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver constructs a class DBusAuthObserver.
func NewDBusAuthObserver() DBusAuthObserver {

	ret := C.g_dbus_auth_observer_new()

	var ret0 DBusAuthObserver

	ret0 = WrapDBusAuthObserver(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
// @observer.
func (observer dBusAuthObserver) AllowMechanism(mechanism string) bool {
	var arg0 *C.GDBusAuthObserver
	var arg1 *C.gchar

	arg0 = (*C.GDBusAuthObserver)(observer.Native())
	arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_auth_observer_allow_mechanism(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on @observer.
func (observer dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool {
	var arg0 *C.GDBusAuthObserver
	var arg1 *C.GIOStream
	var arg2 *C.GCredentials

	arg0 = (*C.GDBusAuthObserver)(observer.Native())
	arg1 = (*C.GIOStream)(stream.Native())
	arg2 = (*C.GCredentials)(credentials.Native())

	ret := C.g_dbus_auth_observer_authorize_authenticated_peer(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector

	// AddFilter adds a message filter. Filters are handlers that are run on all
	// incoming and outgoing messages, prior to standard dispatch. Filters are
	// run in the order that they were added. The same handler can be added as a
	// filter more than once, in which case it will be run more than once.
	// Filters added during a filter callback won't be run on the message being
	// processed. Filter functions are allowed to modify and even drop messages.
	//
	// Note that filters are run in a dedicated message handling thread so they
	// can't block and, generally, can't do anything but signal a worker thread.
	// Also note that filters are rarely needed - use API such as
	// g_dbus_connection_send_message_with_reply(),
	// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
	//
	// If a filter consumes an incoming message the message is not dispatched
	// anywhere else - not even the standard dispatch machinery (that API such
	// as g_dbus_connection_signal_subscribe() and
	// g_dbus_connection_send_message_with_reply() relies on) will see the
	// message. Similarly, if a filter consumes an outgoing message, the message
	// will not be sent to the other peer.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the filter is removed, and may
	// be called after @connection has been destroyed.)
	AddFilter(filterFunction DBusMessageFilterFunction) uint
	// Call: asynchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type. Unless it’s G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
	// containing one or more values.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_connection_call (connection,
	//                             "org.freedesktop.StringThings",
	//                             "/org/freedesktop/StringThings",
	//                             "org.freedesktop.StringThings",
	//                             "TwoStrings",
	//                             g_variant_new ("(ss)",
	//                                            "Thing One",
	//                                            "Thing Two"),
	//                             NULL,
	//                             G_DBUS_CALL_FLAGS_NONE,
	//                             -1,
	//                             NULL,
	//                             (GAsyncReadyCallback) two_strings_done,
	//                             NULL);
	//
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_call_finish() to get the result of the operation. See
	// g_dbus_connection_call_sync() for the synchronous version of this
	// function.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_connection_call_sync (connection,
	//                                  "org.freedesktop.StringThings",
	//                                  "/org/freedesktop/StringThings",
	//                                  "org.freedesktop.StringThings",
	//                                  "TwoStrings",
	//                                  g_variant_new ("(ss)",
	//                                                 "Thing One",
	//                                                 "Thing Two"),
	//                                  NULL,
	//                                  G_DBUS_CALL_FLAGS_NONE,
	//                                  -1,
	//                                  NULL,
	//                                  &error);
	//
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant
	// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)
	// Close closes @connection. Note that this never causes the process to exit
	// (this might only happen if the other end of a shared message bus
	// connection disconnects, see BusConnection:exit-on-close).
	//
	// Once the connection is closed, operations such as sending a message will
	// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
	// automatically flush the connection so queued messages may be lost. Use
	// g_dbus_connection_flush() if you need such guarantees.
	//
	// If @connection is already closed, this method fails with
	// G_IO_ERROR_CLOSED.
	//
	// When @connection has been closed, the BusConnection::closed signal is
	// emitted in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread that
	// @connection was constructed in.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_close_finish() to get the result of the operation. See
	// g_dbus_connection_close_sync() for the synchronous version.
	Close(cancellable Cancellable, callback AsyncReadyCallback)
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) bool
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) bool
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) uint
	// Flush: asynchronously flushes @connection, that is, writes all queued
	// outgoing message to the transport and then flushes the transport (using
	// g_output_stream_flush_async()). This is useful in programs that wants to
	// emit a D-Bus signal and then exit immediately. Without flushing the
	// connection, there is no guaranteed that the message has been sent to the
	// networking buffers in the OS kernel.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_flush_finish() to get the result of the operation. See
	// g_dbus_connection_flush_sync() for the synchronous version.
	Flush(cancellable Cancellable, callback AsyncReadyCallback)
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) bool
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RegisterObjectWithClosures: version of
	// g_dbus_connection_register_object() using closures instead of a
	// BusInterfaceVTable for easier binding in other languages.
	RegisterObjectWithClosures(objectPath string, interfaceInfo *DBusInterfaceInfo, methodCallClosure *externglib.Closure, getPropertyClosure *externglib.Closure, setPropertyClosure *externglib.Closure) uint
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterID uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, ok bool)
	// SendMessageWithReply: asynchronously sends @message to the peer
	// represented by @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_send_message_with_reply_finish() to get the result of
	// the operation. See g_dbus_connection_send_message_with_reply_sync() for
	// the synchronous version.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalSubscribe subscribes to signals on @connection and invokes
	// @callback with a whenever the signal is received. Note that @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from.
	//
	// If @connection is not a message bus connection, @sender must be nil.
	//
	// If @sender is a well-known name note that @callback is invoked with the
	// unique name for the owner of @sender, not the well-known name as one
	// would expect. This is because the message bus rewrites the name. As such,
	// to avoid certain race conditions, users should be tracking the name owner
	// of the well-known name and use that when processing the received signal.
	//
	// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
	// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is interpreted as
	// part of a namespace or path. The first argument of a signal is matched
	// against that part as specified by D-Bus.
	//
	// If @user_data_free_func is non-nil, it will be called (in the
	// thread-default main context of the thread you are calling this method
	// from) at some point after @user_data is no longer needed. (It is not
	// guaranteed to be called synchronously when the signal is unsubscribed
	// from, and may be called after @connection has been destroyed.)
	//
	// As @callback is potentially invoked in a different thread from where it’s
	// emitted, it’s possible for this to happen after
	// g_dbus_connection_signal_unsubscribe() has been called in another thread.
	// Due to this, @user_data should have a strong reference which is freed
	// with @user_data_free_func, rather than pointing to data whose lifecycle
	// is tied to the signal subscription. For example, if a #GObject is used to
	// store the subscription ID from g_dbus_connection_signal_subscribe(), a
	// strong reference to that #GObject must be passed to @user_data, and
	// g_object_unref() passed to @user_data_free_func. You are responsible for
	// breaking the resulting reference count cycle by explicitly unsubscribing
	// from the signal when dropping the last external reference to the
	// #GObject. Alternatively, a weak reference may be used.
	//
	// It is guaranteed that if you unsubscribe from a signal using
	// g_dbus_connection_signal_unsubscribe() from the same thread which made
	// the corresponding g_dbus_connection_signal_subscribe() call, @callback
	// will not be invoked after g_dbus_connection_signal_unsubscribe() returns.
	//
	// The returned subscription identifier is an opaque value which is
	// guaranteed to never be zero.
	//
	// This function can never fail.
	SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after it’s stopped being iterated.
	SignalUnsubscribe(subscriptionID uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportID uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportID uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationID uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationID uint) bool
}

// dBusConnection implements the DBusConnection interface.
type dBusConnection struct {
	gextras.Objector
}

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return DBusConnection{
		gextras.Objector: (obj),
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

// NewDBusConnectionForAddressSync constructs a class DBusConnection.
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) DBusConnection {
	var arg1 *C.gchar
	var arg2 C.GDBusConnectionFlags
	var arg3 *C.GDBusAuthObserver
	var arg4 *C.GCancellable

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GDBusConnectionFlags)(flags)
	arg3 = (*C.GDBusAuthObserver)(observer.Native())
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_new_for_address_sync(arg1, arg2, arg3, arg4)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDBusConnectionSync constructs a class DBusConnection.
func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) DBusConnection {
	var arg1 *C.GIOStream
	var arg2 *C.gchar
	var arg3 C.GDBusConnectionFlags
	var arg4 *C.GDBusAuthObserver
	var arg5 *C.GCancellable

	arg1 = (*C.GIOStream)(stream.Native())
	arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GDBusConnectionFlags)(flags)
	arg4 = (*C.GDBusAuthObserver)(observer.Native())
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_new_sync(arg1, arg2, arg3, arg4, arg5)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddFilter adds a message filter. Filters are handlers that are run on all
// incoming and outgoing messages, prior to standard dispatch. Filters are
// run in the order that they were added. The same handler can be added as a
// filter more than once, in which case it will be run more than once.
// Filters added during a filter callback won't be run on the message being
// processed. Filter functions are allowed to modify and even drop messages.
//
// Note that filters are run in a dedicated message handling thread so they
// can't block and, generally, can't do anything but signal a worker thread.
// Also note that filters are rarely needed - use API such as
// g_dbus_connection_send_message_with_reply(),
// g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
//
// If a filter consumes an incoming message the message is not dispatched
// anywhere else - not even the standard dispatch machinery (that API such
// as g_dbus_connection_signal_subscribe() and
// g_dbus_connection_send_message_with_reply() relies on) will see the
// message. Similarly, if a filter consumes an outgoing message, the message
// will not be sent to the other peer.
//
// If @user_data_free_func is non-nil, it will be called (in the
// thread-default main context of the thread you are calling this method
// from) at some point after @user_data is no longer needed. (It is not
// guaranteed to be called synchronously when the filter is removed, and may
// be called after @connection has been destroyed.)
func (connection dBusConnection) AddFilter(filterFunction DBusMessageFilterFunction) uint {
	var arg0 *C.GDBusConnection
	var arg1 C.GDBusMessageFilterFunction
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*[0]byte)(C.gotk4_DBusMessageFilterFunction)

	ret := C.g_dbus_connection_add_filter(arg0, arg1, (*[0]byte)(C.callbackDelete))

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Call: asynchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path
// owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-nil then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a @reply_type then any non-nil return value will be of this
// type. Unless it’s G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
// containing one or more values.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//     g_dbus_connection_call (connection,
//                             "org.freedesktop.StringThings",
//                             "/org/freedesktop/StringThings",
//                             "org.freedesktop.StringThings",
//                             "TwoStrings",
//                             g_variant_new ("(ss)",
//                                            "Thing One",
//                                            "Thing Two"),
//                             NULL,
//                             G_DBUS_CALL_FLAGS_NONE,
//                             -1,
//                             NULL,
//                             (GAsyncReadyCallback) two_strings_done,
//                             NULL);
//
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_call_finish() to get the result of the operation. See
// g_dbus_connection_call_sync() for the synchronous version of this
// function.
//
// If @callback is nil then the D-Bus method call message will be sent with
// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (connection dBusConnection) Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GCancellable
	var arg10 C.GAsyncReadyCallback
	arg11 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(parameters.Native())
	arg6 = (*C.GVariantType)(replyType.Native())
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GCancellable)(cancellable.Native())
	arg10 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_connection_call(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
}

// CallSync: synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path
// owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-nil then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a @reply_type then any non-nil return value will be of this
// type.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//     g_dbus_connection_call_sync (connection,
//                                  "org.freedesktop.StringThings",
//                                  "/org/freedesktop/StringThings",
//                                  "org.freedesktop.StringThings",
//                                  "TwoStrings",
//                                  g_variant_new ("(ss)",
//                                                 "Thing One",
//                                                 "Thing Two"),
//                                  NULL,
//                                  G_DBUS_CALL_FLAGS_NONE,
//                                  -1,
//                                  NULL,
//                                  &error);
//
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
func (connection dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GCancellable

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(parameters.Native())
	arg6 = (*C.GVariantType)(replyType.Native())
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_call_sync(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
// object.
//
// This method is only available on UNIX.
func (connection dBusConnection) CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GUnixFDList
	var arg10 *C.GCancellable
	var arg11 C.GAsyncReadyCallback
	arg12 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(parameters.Native())
	arg6 = (*C.GVariantType)(replyType.Native())
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GUnixFDList)(fdList.Native())
	arg10 = (*C.GCancellable)(cancellable.Native())
	arg11 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_connection_call_with_unix_fd_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
}

// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
// and returns FDList objects.
//
// This method is only available on UNIX.
func (connection dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant) {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant
	var arg6 *C.GVariantType
	var arg7 C.GDBusCallFlags
	var arg8 C.gint
	var arg9 *C.GUnixFDList
	var arg10 **C.GUnixFDList // out
	var arg11 *C.GCancellable

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(parameters.Native())
	arg6 = (*C.GVariantType)(replyType.Native())
	arg7 = (C.GDBusCallFlags)(flags)
	arg8 = C.gint(timeoutMsec)
	arg9 = (*C.GUnixFDList)(fdList.Native())
	arg11 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_call_with_unix_fd_list_sync(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, &arg10, arg11)

	var ret0 UnixFDList
	var ret1 *glib.Variant

	ret0 = WrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(arg10.Native())))

	ret1 = glib.WrapVariant(ret)

	return ret0, ret1
}

// Close closes @connection. Note that this never causes the process to exit
// (this might only happen if the other end of a shared message bus
// connection disconnects, see BusConnection:exit-on-close).
//
// Once the connection is closed, operations such as sending a message will
// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
// automatically flush the connection so queued messages may be lost. Use
// g_dbus_connection_flush() if you need such guarantees.
//
// If @connection is already closed, this method fails with
// G_IO_ERROR_CLOSED.
//
// When @connection has been closed, the BusConnection::closed signal is
// emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread that
// @connection was constructed in.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_close_finish() to get the result of the operation. See
// g_dbus_connection_close_sync() for the synchronous version.
func (connection dBusConnection) Close(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_connection_close(arg0, arg1, arg2)
}

// CloseSync: synchronously closes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_close() for the
// asynchronous version of this method and more details about what it does.
func (connection dBusConnection) CloseSync(cancellable Cancellable) bool {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_close_sync(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus
// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (G_IO_ERROR_CLOSED).
func (connection dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) bool {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.GVariant

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.GVariant)(parameters.Native())

	ret := C.g_dbus_connection_emit_signal(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ExportMenuModel exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
//
// You can unexport the menu model using
// g_dbus_connection_unexport_menu_model() with the return value of this
// function.
func (connection dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) uint {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(menu.Native())

	ret := C.g_dbus_connection_export_menu_model(arg0, arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Flush: asynchronously flushes @connection, that is, writes all queued
// outgoing message to the transport and then flushes the transport (using
// g_output_stream_flush_async()). This is useful in programs that wants to
// emit a D-Bus signal and then exit immediately. Without flushing the
// connection, there is no guaranteed that the message has been sent to the
// networking buffers in the OS kernel.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_flush_finish() to get the result of the operation. See
// g_dbus_connection_flush_sync() for the synchronous version.
func (connection dBusConnection) Flush(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_connection_flush(arg0, arg1, arg2)
}

// FlushSync: synchronously flushes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_flush() for the
// asynchronous version of this method and more details about what it does.
func (connection dBusConnection) FlushSync(cancellable Cancellable) bool {
	var arg0 *C.GDBusConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_flush_sync(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Capabilities gets the capabilities negotiated with the remote peer
func (connection dBusConnection) Capabilities() DBusCapabilityFlags {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_capabilities(arg0)

	var ret0 DBusCapabilityFlags

	ret0 = DBusCapabilityFlags(ret)

	return ret0
}

// ExitOnClose gets whether the process is terminated when @connection is
// closed by the remote peer. See BusConnection:exit-on-close for more
// details.
func (connection dBusConnection) ExitOnClose() bool {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_exit_on_close(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Flags gets the flags used to construct this connection
func (connection dBusConnection) Flags() DBusConnectionFlags {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_flags(arg0)

	var ret0 DBusConnectionFlags

	ret0 = DBusConnectionFlags(ret)

	return ret0
}

// Guid: the GUID of the peer performing the role of server when
// authenticating. See BusConnection:guid for more details.
func (connection dBusConnection) Guid() string {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_guid(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// LastSerial retrieves the last serial number assigned to a BusMessage on
// the current thread. This includes messages sent via both low-level API
// such as g_dbus_connection_send_message() as well as high-level API such
// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
func (connection dBusConnection) LastSerial() uint32 {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_last_serial(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// PeerCredentials gets the credentials of the authenticated peer. This will
// always return nil unless @connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
// the client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return nil for
// message bus clients.
func (connection dBusConnection) PeerCredentials() Credentials {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_peer_credentials(arg0)

	var ret0 Credentials

	ret0 = WrapCredentials(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from
// a worker thread, so it is not safe to interact with the stream directly.
func (connection dBusConnection) Stream() IOStream {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_stream(arg0)

	var ret0 IOStream

	ret0 = WrapIOStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// UniqueName gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a message bus
// connection.
func (connection dBusConnection) UniqueName() string {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_get_unique_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsClosed gets whether @connection is closed.
func (connection dBusConnection) IsClosed() bool {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_connection_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RegisterObjectWithClosures: version of
// g_dbus_connection_register_object() using closures instead of a
// BusInterfaceVTable for easier binding in other languages.
func (connection dBusConnection) RegisterObjectWithClosures(objectPath string, interfaceInfo *DBusInterfaceInfo, methodCallClosure *externglib.Closure, getPropertyClosure *externglib.Closure, setPropertyClosure *externglib.Closure) uint {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.GDBusInterfaceInfo
	var arg3 *C.GClosure
	var arg4 *C.GClosure
	var arg5 *C.GClosure

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GDBusInterfaceInfo)(interfaceInfo.Native())

	ret := C.g_dbus_connection_register_object_with_closures(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even after
// calling g_dbus_connection_remove_filter(), so you cannot just free data
// that the filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is
// guaranteed that the data is no longer needed.
func (connection dBusConnection) RemoveFilter(filterID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(filterID)

	C.g_dbus_connection_remove_filter(arg0, arg1)
}

// SendMessage: asynchronously sends @message to the peer represented by
// @connection.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
// with G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (connection dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (outSerial uint32, ok bool) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GDBusMessage
	var arg2 C.GDBusSendMessageFlags
	var arg3 *C.guint32 // out

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GDBusMessage)(message.Native())
	arg2 = (C.GDBusSendMessageFlags)(flags)

	ret := C.g_dbus_connection_send_message(arg0, arg1, arg2, &arg3)

	var ret0 uint32
	var ret1 bool

	ret0 = uint32(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// SendMessageWithReply: asynchronously sends @message to the peer
// represented by @connection.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call
// g_dbus_connection_send_message_with_reply_finish() to get the result of
// the operation. See g_dbus_connection_send_message_with_reply_sync() for
// the synchronous version.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (connection dBusConnection) SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32 {
	var arg0 *C.GDBusConnection
	var arg1 *C.GDBusMessage
	var arg2 C.GDBusSendMessageFlags
	var arg3 C.gint
	var arg4 *C.guint32 // out
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	arg7 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GDBusMessage)(message.Native())
	arg2 = (C.GDBusSendMessageFlags)(flags)
	arg3 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	ret := C.g_dbus_connection_send_message_with_reply(arg0, arg1, arg2, arg3, &arg4, arg5, arg6)

	var ret0 uint32

	ret0 = uint32(arg4)

	return ret0
}

// SendMessageWithReplySync: synchronously sends @message to the peer
// represented by @connection and blocks the calling thread until a reply is
// received or the timeout is reached. See
// g_dbus_connection_send_message_with_reply() for the asynchronous version
// of this method.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that @error is only set if a local in-process error occurred. That
// is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
// this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (connection dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (outSerial uint32, dBusMessage DBusMessage) {
	var arg0 *C.GDBusConnection
	var arg1 *C.GDBusMessage
	var arg2 C.GDBusSendMessageFlags
	var arg3 C.gint
	var arg4 *C.guint32 // out
	var arg5 *C.GCancellable

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.GDBusMessage)(message.Native())
	arg2 = (C.GDBusSendMessageFlags)(flags)
	arg3 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_connection_send_message_with_reply_sync(arg0, arg1, arg2, arg3, &arg4, arg5)

	var ret0 uint32
	var ret1 DBusMessage

	ret0 = uint32(arg4)

	ret1 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// SetExitOnClose sets whether the process should be terminated when
// @connection is closed by the remote peer. See BusConnection:exit-on-close
// for more details.
//
// Note that this function should be used with care. Most modern UNIX
// desktops tie the notion of a user session with the session bus, and
// expect all of a user's applications to quit when their bus connection
// goes away. If you are setting @exit_on_close to false for the shared
// session bus connection, you should make sure that your application exits
// when the user session ends.
func (connection dBusConnection) SetExitOnClose(exitOnClose bool) {
	var arg0 *C.GDBusConnection
	var arg1 C.gboolean

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = gextras.Cbool(exitOnClose)

	C.g_dbus_connection_set_exit_on_close(arg0, arg1)
}

// SignalSubscribe subscribes to signals on @connection and invokes
// @callback with a whenever the signal is received. Note that @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from.
//
// If @connection is not a message bus connection, @sender must be nil.
//
// If @sender is a well-known name note that @callback is invoked with the
// unique name for the owner of @sender, not the well-known name as one
// would expect. This is because the message bus rewrites the name. As such,
// to avoid certain race conditions, users should be tracking the name owner
// of the well-known name and use that when processing the received signal.
//
// If one of G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
// G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, @arg0 is interpreted as
// part of a namespace or path. The first argument of a signal is matched
// against that part as specified by D-Bus.
//
// If @user_data_free_func is non-nil, it will be called (in the
// thread-default main context of the thread you are calling this method
// from) at some point after @user_data is no longer needed. (It is not
// guaranteed to be called synchronously when the signal is unsubscribed
// from, and may be called after @connection has been destroyed.)
//
// As @callback is potentially invoked in a different thread from where it’s
// emitted, it’s possible for this to happen after
// g_dbus_connection_signal_unsubscribe() has been called in another thread.
// Due to this, @user_data should have a strong reference which is freed
// with @user_data_free_func, rather than pointing to data whose lifecycle
// is tied to the signal subscription. For example, if a #GObject is used to
// store the subscription ID from g_dbus_connection_signal_subscribe(), a
// strong reference to that #GObject must be passed to @user_data, and
// g_object_unref() passed to @user_data_free_func. You are responsible for
// breaking the resulting reference count cycle by explicitly unsubscribing
// from the signal when dropping the last external reference to the
// #GObject. Alternatively, a weak reference may be used.
//
// It is guaranteed that if you unsubscribe from a signal using
// g_dbus_connection_signal_unsubscribe() from the same thread which made
// the corresponding g_dbus_connection_signal_subscribe() call, @callback
// will not be invoked after g_dbus_connection_signal_unsubscribe() returns.
//
// The returned subscription identifier is an opaque value which is
// guaranteed to never be zero.
//
// This function can never fail.
func (connection dBusConnection) SignalSubscribe(sender string, interfaceName string, member string, objectPath string, arg0 string, flags DBusSignalFlags, callback DBusSignalCallback) uint {
	var arg0 *C.GDBusConnection
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 C.GDBusSignalFlags
	var arg7 C.GDBusSignalCallback
	arg8 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = (*C.gchar)(C.CString(sender))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(member))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(arg0))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (C.GDBusSignalFlags)(flags)
	arg7 = (*[0]byte)(C.gotk4_DBusSignalCallback)

	ret := C.g_dbus_connection_signal_subscribe(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, (*[0]byte)(C.callbackDelete))

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until
// the Notify function passed to g_dbus_connection_signal_subscribe() is
// called, in order to avoid memory leaks through callbacks queued on the
// Context after it’s stopped being iterated.
func (connection dBusConnection) SignalUnsubscribe(subscriptionID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(subscriptionID)

	C.g_dbus_connection_signal_unsubscribe(arg0, arg1)
}

// StartMessageProcessing: if @connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if @connection wasn't created with
// this flag or if the method has already been called.
func (connection dBusConnection) StartMessageProcessing() {
	var arg0 *C.GDBusConnection

	arg0 = (*C.GDBusConnection)(connection.Native())

	C.g_dbus_connection_start_message_processing(arg0)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID
// more than once.
func (connection dBusConnection) UnexportActionGroup(exportID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(exportID)

	C.g_dbus_connection_unexport_action_group(arg0, arg1)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
func (connection dBusConnection) UnexportMenuModel(exportID uint) {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(exportID)

	C.g_dbus_connection_unexport_menu_model(arg0, arg1)
}

// UnregisterObject unregisters an object.
func (connection dBusConnection) UnregisterObject(registrationID uint) bool {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(registrationID)

	ret := C.g_dbus_connection_unregister_object(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnregisterSubtree unregisters a subtree.
func (connection dBusConnection) UnregisterSubtree(registrationID uint) bool {
	var arg0 *C.GDBusConnection
	var arg1 C.guint

	arg0 = (*C.GDBusConnection)(connection.Native())
	arg1 = C.guint(registrationID)

	ret := C.g_dbus_connection_unregister_subtree(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusInterfaceSkeleton: abstract base class for D-Bus interfaces on the
// service side.
type DBusInterfaceSkeleton interface {
	gextras.Objector

	// Export exports @interface_ at @object_path on @connection.
	//
	// This can be called multiple times to export the same @interface_ onto
	// multiple connections however the @object_path provided must be the same
	// for all connections.
	//
	// Use g_dbus_interface_skeleton_unexport() to unexport the object.
	Export(connection DBusConnection, objectPath string) bool
	// Flush: if @interface_ has outstanding changes, request for these changes
	// to be emitted immediately.
	//
	// For example, an exported D-Bus interface may queue up property changes
	// and emit the `org.freedesktop.DBus.Properties.PropertiesChanged` signal
	// later (e.g. in an idle handler). This technique is useful for collapsing
	// multiple property changes into one.
	Flush()
	// Connection gets the first connection that @interface_ is exported on, if
	// any.
	Connection() DBusConnection
	// Connections gets a list of the connections that @interface_ is exported
	// on.
	Connections() *glib.List
	// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior
	// of @interface_
	Flags() DBusInterfaceSkeletonFlags
	// Info gets D-Bus introspection information for the D-Bus interface
	// implemented by @interface_.
	Info() *DBusInterfaceInfo
	// ObjectPath gets the object path that @interface_ is exported on, if any.
	ObjectPath() string
	// Properties gets all D-Bus properties for @interface_.
	Properties() *glib.Variant
	// Vtable gets the interface vtable for the D-Bus interface implemented by
	// @interface_. The returned function pointers should expect @interface_
	// itself to be passed as @user_data.
	Vtable() *DBusInterfaceVTable
	// HasConnection checks if @interface_ is exported on @connection.
	HasConnection(connection DBusConnection) bool
	// SetFlags sets flags describing what the behavior of @skeleton should be.
	SetFlags(flags DBusInterfaceSkeletonFlags)
	// Unexport stops exporting @interface_ on all connections it is exported
	// on.
	//
	// To unexport @interface_ from only a single connection, use
	// g_dbus_interface_skeleton_unexport_from_connection()
	Unexport()
	// UnexportFromConnection stops exporting @interface_ on @connection.
	//
	// To stop exporting on all connections the interface is exported on, use
	// g_dbus_interface_skeleton_unexport().
	UnexportFromConnection(connection DBusConnection)
}

// dBusInterfaceSkeleton implements the DBusInterfaceSkeleton interface.
type dBusInterfaceSkeleton struct {
	gextras.Objector
}

// WrapDBusInterfaceSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusInterfaceSkeleton(obj *externglib.Object) DBusInterfaceSkeleton {
	return DBusInterfaceSkeleton{
		gextras.Objector: (obj),
	}
}

func marshalDBusInterfaceSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusInterfaceSkeleton(obj), nil
}

// Export exports @interface_ at @object_path on @connection.
//
// This can be called multiple times to export the same @interface_ onto
// multiple connections however the @object_path provided must be the same
// for all connections.
//
// Use g_dbus_interface_skeleton_unexport() to unexport the object.
func (interface_ dBusInterfaceSkeleton) Export(connection DBusConnection, objectPath string) bool {
	var arg0 *C.GDBusInterfaceSkeleton
	var arg1 *C.GDBusConnection
	var arg2 *C.gchar

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())
	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dbus_interface_skeleton_export(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Flush: if @interface_ has outstanding changes, request for these changes
// to be emitted immediately.
//
// For example, an exported D-Bus interface may queue up property changes
// and emit the `org.freedesktop.DBus.Properties.PropertiesChanged` signal
// later (e.g. in an idle handler). This technique is useful for collapsing
// multiple property changes into one.
func (interface_ dBusInterfaceSkeleton) Flush() {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	C.g_dbus_interface_skeleton_flush(arg0)
}

// Connection gets the first connection that @interface_ is exported on, if
// any.
func (interface_ dBusInterfaceSkeleton) Connection() DBusConnection {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Connections gets a list of the connections that @interface_ is exported
// on.
func (interface_ dBusInterfaceSkeleton) Connections() *glib.List {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_connections(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Flags gets the BusInterfaceSkeletonFlags that describes what the behavior
// of @interface_
func (interface_ dBusInterfaceSkeleton) Flags() DBusInterfaceSkeletonFlags {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_flags(arg0)

	var ret0 DBusInterfaceSkeletonFlags

	ret0 = DBusInterfaceSkeletonFlags(ret)

	return ret0
}

// Info gets D-Bus introspection information for the D-Bus interface
// implemented by @interface_.
func (interface_ dBusInterfaceSkeleton) Info() *DBusInterfaceInfo {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_info(arg0)

	var ret0 *DBusInterfaceInfo

	ret0 = WrapDBusInterfaceInfo(ret)

	return ret0
}

// ObjectPath gets the object path that @interface_ is exported on, if any.
func (interface_ dBusInterfaceSkeleton) ObjectPath() string {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_object_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Properties gets all D-Bus properties for @interface_.
func (interface_ dBusInterfaceSkeleton) Properties() *glib.Variant {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_properties(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Vtable gets the interface vtable for the D-Bus interface implemented by
// @interface_. The returned function pointers should expect @interface_
// itself to be passed as @user_data.
func (interface_ dBusInterfaceSkeleton) Vtable() *DBusInterfaceVTable {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	ret := C.g_dbus_interface_skeleton_get_vtable(arg0)

	var ret0 *DBusInterfaceVTable

	ret0 = WrapDBusInterfaceVTable(ret)

	return ret0
}

// HasConnection checks if @interface_ is exported on @connection.
func (interface_ dBusInterfaceSkeleton) HasConnection(connection DBusConnection) bool {
	var arg0 *C.GDBusInterfaceSkeleton
	var arg1 *C.GDBusConnection

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())
	arg1 = (*C.GDBusConnection)(connection.Native())

	ret := C.g_dbus_interface_skeleton_has_connection(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetFlags sets flags describing what the behavior of @skeleton should be.
func (interface_ dBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags) {
	var arg0 *C.GDBusInterfaceSkeleton
	var arg1 C.GDBusInterfaceSkeletonFlags

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())
	arg1 = (C.GDBusInterfaceSkeletonFlags)(flags)

	C.g_dbus_interface_skeleton_set_flags(arg0, arg1)
}

// Unexport stops exporting @interface_ on all connections it is exported
// on.
//
// To unexport @interface_ from only a single connection, use
// g_dbus_interface_skeleton_unexport_from_connection()
func (interface_ dBusInterfaceSkeleton) Unexport() {
	var arg0 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	C.g_dbus_interface_skeleton_unexport(arg0)
}

// UnexportFromConnection stops exporting @interface_ on @connection.
//
// To stop exporting on all connections the interface is exported on, use
// g_dbus_interface_skeleton_unexport().
func (interface_ dBusInterfaceSkeleton) UnexportFromConnection(connection DBusConnection) {
	var arg0 *C.GDBusInterfaceSkeleton
	var arg1 *C.GDBusConnection

	arg0 = (*C.GDBusInterfaceSkeleton)(interface_.Native())
	arg1 = (*C.GDBusConnection)(connection.Native())

	C.g_dbus_interface_skeleton_unexport_from_connection(arg0, arg1)
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

// dBusMenuModel implements the DBusMenuModel interface.
type dBusMenuModel struct {
	MenuModel
}

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return DBusMenuModel{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() DBusMessage
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//    ]|
	//    or
	//    |[
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	//
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(_type DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	SetUnixFdList(fdList UnixFDList)
	// ToBlob serializes @message to a blob. The byte order returned by
	// g_dbus_message_get_byte_order() will be used.
	ToBlob(capabilities DBusCapabilityFlags) (outSize uint, guint8s []byte)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() bool
}

// dBusMessage implements the DBusMessage interface.
type dBusMessage struct {
	gextras.Objector
}

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return DBusMessage{
		gextras.Objector: (obj),
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

// NewDBusMessage constructs a class DBusMessage.
func NewDBusMessage() DBusMessage {

	ret := C.g_dbus_message_new()

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDBusMessageMethodCall constructs a class DBusMessage.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(arg4))

	ret := C.g_dbus_message_new_method_call(arg1, arg2, arg3, arg4)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDBusMessageSignal constructs a class DBusMessage.
func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_dbus_message_new_signal(arg1, arg2, arg3)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Copy copies @message. The copy is a deep copy and the returned BusMessage
// is completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. @message contains file descriptors and
// the per-process or system-wide open files limit is reached.
func (message dBusMessage) Copy() DBusMessage {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_copy(arg0)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Arg0: convenience to get the first item in the body of @message.
func (message dBusMessage) Arg0() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_arg0(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Body gets the body of a message.
func (message dBusMessage) Body() *glib.Variant {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_body(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// ByteOrder gets the byte order of @message.
func (message dBusMessage) ByteOrder() DBusMessageByteOrder {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_byte_order(arg0)

	var ret0 DBusMessageByteOrder

	ret0 = DBusMessageByteOrder(ret)

	return ret0
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message dBusMessage) Destination() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_destination(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ErrorName: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (message dBusMessage) ErrorName() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_error_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets the flags for @message.
func (message dBusMessage) Flags() DBusMessageFlags {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_flags(arg0)

	var ret0 DBusMessageFlags

	ret0 = DBusMessageFlags(ret)

	return ret0
}

// Header gets a header field on @message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
func (message dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageHeaderField

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (C.GDBusMessageHeaderField)(headerField)

	ret := C.g_dbus_message_get_header(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// HeaderFields gets an array of all header fields on @message that are set.
func (message dBusMessage) HeaderFields() []byte {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_header_fields(arg0)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}

// Interface: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (message dBusMessage) Interface() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_interface(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Locked checks whether @message is locked. To monitor changes to this
// value, conncet to the #GObject::notify signal to listen for changes on
// the BusMessage:locked property.
func (message dBusMessage) Locked() bool {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_locked(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (message dBusMessage) Member() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_member(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MessageType gets the type of @message.
func (message dBusMessage) MessageType() DBusMessageType {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_message_type(arg0)

	var ret0 DBusMessageType

	ret0 = DBusMessageType(ret)

	return ret0
}

// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message dBusMessage) NumUnixFds() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_num_unix_fds(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (message dBusMessage) Path() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message dBusMessage) ReplySerial() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_reply_serial(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (message dBusMessage) Sender() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_sender(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Serial gets the serial for @message.
func (message dBusMessage) Serial() uint32 {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_serial(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Signature: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (message dBusMessage) Signature() string {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_signature(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixFdList gets the UNIX file descriptors associated with @message, if
// any.
//
// This method is only available on UNIX.
func (message dBusMessage) UnixFdList() UnixFDList {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_get_unix_fd_list(arg0)

	var ret0 UnixFDList

	ret0 = WrapUnixFDList(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Lock: if @message is locked, does nothing. Otherwise locks the message.
func (message dBusMessage) Lock() {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	C.g_dbus_message_lock(arg0)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// @method_call_message.
func (methodCallMessage dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GDBusMessage)(methodCallMessage.Native())
	arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dbus_message_new_method_error_literal(arg0, arg1, arg2)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMethodReply creates a new BusMessage that is a reply to
// @method_call_message.
func (methodCallMessage dBusMessage) NewMethodReply() DBusMessage {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(methodCallMessage.Native())

	ret := C.g_dbus_message_new_method_reply(arg0)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Print produces a human-readable multi-line description of @message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks
// something like this:
//
//
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
//    ]|
//    or
//    |[
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
//
func (message dBusMessage) Print(indent uint) string {
	var arg0 *C.GDBusMessage
	var arg1 C.guint

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = C.guint(indent)

	ret := C.g_dbus_message_print(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// SetBody sets the body @message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
// string of @body (or cleared if @body is nil).
//
// If @body is floating, @message assumes ownership of @body.
func (message dBusMessage) SetBody(body *glib.Variant) {
	var arg0 *C.GDBusMessage
	var arg1 *C.GVariant

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.GVariant)(body.Native())

	C.g_dbus_message_set_body(arg0, arg1)
}

// SetByteOrder sets the byte order of @message.
func (message dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageByteOrder

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (C.GDBusMessageByteOrder)(byteOrder)

	C.g_dbus_message_set_byte_order(arg0, arg1)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (message dBusMessage) SetDestination(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_destination(arg0, arg1)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (message dBusMessage) SetErrorName(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_error_name(arg0, arg1)
}

// SetFlags sets the flags to set on @message.
func (message dBusMessage) SetFlags(flags DBusMessageFlags) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageFlags

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (C.GDBusMessageFlags)(flags)

	C.g_dbus_message_set_flags(arg0, arg1)
}

// SetHeader sets a header field on @message.
//
// If @value is floating, @message assumes ownership of @value.
func (message dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageHeaderField
	var arg2 *C.GVariant

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (C.GDBusMessageHeaderField)(headerField)
	arg2 = (*C.GVariant)(value.Native())

	C.g_dbus_message_set_header(arg0, arg1, arg2)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (message dBusMessage) SetInterface(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_interface(arg0, arg1)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (message dBusMessage) SetMember(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_member(arg0, arg1)
}

// SetMessageType sets @message to be of @type.
func (message dBusMessage) SetMessageType(_type DBusMessageType) {
	var arg0 *C.GDBusMessage
	var arg1 C.GDBusMessageType

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (C.GDBusMessageType)(_type)

	C.g_dbus_message_set_message_type(arg0, arg1)
}

// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (message dBusMessage) SetNumUnixFds(value uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(arg0, arg1)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
// header field.
func (message dBusMessage) SetPath(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_path(arg0, arg1)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (message dBusMessage) SetReplySerial(value uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(arg0, arg1)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (message dBusMessage) SetSender(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_sender(arg0, arg1)
}

// SetSerial sets the serial for @message.
func (message dBusMessage) SetSerial(serial uint32) {
	var arg0 *C.GDBusMessage
	var arg1 C.guint32

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(arg0, arg1)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (message dBusMessage) SetSignature(value string) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gchar

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_message_set_signature(arg0, arg1)
}

// SetUnixFdList sets the UNIX file descriptors associated with @message. As
// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
//
// This method is only available on UNIX.
func (message dBusMessage) SetUnixFdList(fdList UnixFDList) {
	var arg0 *C.GDBusMessage
	var arg1 *C.GUnixFDList

	arg0 = (*C.GDBusMessage)(message.Native())
	arg1 = (*C.GUnixFDList)(fdList.Native())

	C.g_dbus_message_set_unix_fd_list(arg0, arg1)
}

// ToBlob serializes @message to a blob. The byte order returned by
// g_dbus_message_get_byte_order() will be used.
func (message dBusMessage) ToBlob(capabilities DBusCapabilityFlags) (outSize uint, guint8s []byte) {
	var arg0 *C.GDBusMessage
	var arg1 *C.gsize // out
	var arg2 C.GDBusCapabilityFlags

	arg0 = (*C.GDBusMessage)(message.Native())
	arg2 = (C.GDBusCapabilityFlags)(capabilities)

	ret := C.g_dbus_message_to_blob(arg0, &arg1, arg2)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		ret1 = make([]byte, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
// nothing and returns false.
//
// Otherwise this method encodes the error in @message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
// as the first string item in @message's body.
func (message dBusMessage) ToGerror() bool {
	var arg0 *C.GDBusMessage

	arg0 = (*C.GDBusMessage)(message.Native())

	ret := C.g_dbus_message_to_gerror(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// UserData gets the @user_data #gpointer passed to
	// g_dbus_connection_register_object().
	UserData() interface{}
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(error *glib.Error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
	// TakeError: like g_dbus_method_invocation_return_gerror() but takes
	// ownership of @error so the caller does not need to free it.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	TakeError(error *glib.Error)
}

// dBusMethodInvocation implements the DBusMethodInvocation interface.
type dBusMethodInvocation struct {
	gextras.Objector
}

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return DBusMethodInvocation{
		gextras.Objector: (obj),
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

// Connection gets the BusConnection the method was invoked on.
func (invocation dBusMethodInvocation) Connection() DBusConnection {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// InterfaceName gets the name of the D-Bus interface the method was invoked
// on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then
// "org.freedesktop.DBus.Properties" will be returned. See
// BusInterfaceVTable for more information.
func (invocation dBusMethodInvocation) InterfaceName() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_interface_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Message gets the BusMessage for the method invocation. This is useful if
// you need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (invocation dBusMethodInvocation) Message() DBusMessage {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_message(arg0)

	var ret0 DBusMessage

	ret0 = WrapDBusMessage(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has
// been redirected to the method call handler then nil will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
// more information.
func (invocation dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_method_info(arg0)

	var ret0 *DBusMethodInfo

	ret0 = WrapDBusMethodInfo(ret)

	return ret0
}

// MethodName gets the name of the method that was invoked.
func (invocation dBusMethodInvocation) MethodName() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_method_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ObjectPath gets the object path the method was invoked on.
func (invocation dBusMethodInvocation) ObjectPath() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_object_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather
// than NULL.
func (invocation dBusMethodInvocation) Parameters() *glib.Variant {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_parameters(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a
// property Get or Set call that has been directed to the method call
// handler for an object on account of its property_get() or property_set()
// vtable pointers being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, nil will be returned.
func (invocation dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_property_info(arg0)

	var ret0 *DBusPropertyInfo

	ret0 = WrapDBusPropertyInfo(ret)

	return ret0
}

// Sender gets the bus name that invoked the method.
func (invocation dBusMethodInvocation) Sender() string {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_sender(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UserData gets the @user_data #gpointer passed to
// g_dbus_connection_register_object().
func (invocation dBusMethodInvocation) UserData() interface{} {
	var arg0 *C.GDBusMethodInvocation

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())

	ret := C.g_dbus_method_invocation_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// ReturnDBusError finishes handling a D-Bus method call by returning an
// error.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (invocation dBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())
	arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(arg2))

	C.g_dbus_method_invocation_return_dbus_error(arg0, arg1, arg2)
}

// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (invocation dBusMethodInvocation) ReturnGerror(error *glib.Error) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GError

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_dbus_method_invocation_return_gerror(arg0, arg1)
}

// ReturnValue finishes handling a D-Bus method call by returning
// @parameters. If the @parameters GVariant is floating, it is consumed.
//
// It is an error if @parameters is not of the right format: it must be a
// tuple containing the out-parameters of the D-Bus method. Even if the
// method has a single out-parameter, it must be contained in a tuple. If
// the method has no out-parameters, @parameters may be nil or an empty
// tuple.
//
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
//
//    result_string = calculate_result (&error);
//
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
//
//    // Do not free @invocation here; returning a value does that
//
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then
// this call will sink @parameters and free @invocation, but otherwise do
// nothing (as per the recommendations of the D-Bus specification).
func (invocation dBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GVariant

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())
	arg1 = (*C.GVariant)(parameters.Native())

	C.g_dbus_method_invocation_return_value(arg0, arg1)
}

// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
// but also takes a FDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (invocation dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GVariant
	var arg2 *C.GUnixFDList

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())
	arg1 = (*C.GVariant)(parameters.Native())
	arg2 = (*C.GUnixFDList)(fdList.Native())

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(arg0, arg1, arg2)
}

// TakeError: like g_dbus_method_invocation_return_gerror() but takes
// ownership of @error so the caller does not need to free it.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (invocation dBusMethodInvocation) TakeError(error *glib.Error) {
	var arg0 *C.GDBusMethodInvocation
	var arg1 *C.GError

	arg0 = (*C.GDBusMethodInvocation)(invocation.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_dbus_method_invocation_take_error(arg0, arg1)
}

// DBusObjectManagerClient is used to create, monitor and delete object proxies
// for remote objects exported by a BusObjectManagerServer (or any code
// implementing the org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface).
//
// Once an instance of this type has been created, you can connect to the
// BusObjectManager::object-added and BusObjectManager::object-removed signals
// and inspect the BusObjectProxy objects returned by
// g_dbus_object_manager_get_objects().
//
// If the name for a BusObjectManagerClient is not owned by anyone at object
// construction time, the default behavior is to request the message bus to
// launch an owner for the name. This behavior can be disabled using the
// G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START flag. It's also worth
// noting that this only works if the name of interest is activatable in the
// first place. E.g. in some cases it is not possible to launch an owner for the
// requested name. In this case, BusObjectManagerClient object construction
// still succeeds but there will be no object proxies (e.g.
// g_dbus_object_manager_get_objects() returns the empty list) and the
// BusObjectManagerClient:name-owner property is nil.
//
// The owner of the requested name can come and go (for example consider a
// system service being restarted) – BusObjectManagerClient handles this case
// too; simply connect to the #GObject::notify signal to watch for changes on
// the BusObjectManagerClient:name-owner property. When the name owner vanishes,
// the behavior is that BusObjectManagerClient:name-owner is set to nil (this
// includes emission of the #GObject::notify signal) and then
// BusObjectManager::object-removed signals are synthesized for all currently
// existing object proxies. Since BusObjectManagerClient:name-owner is nil when
// this happens, you can use this information to disambiguate a synthesized
// signal from a genuine signal caused by object removal on the remote
// BusObjectManager. Similarly, when a new name owner appears,
// BusObjectManager::object-added signals are synthesized while
// BusObjectManagerClient:name-owner is still nil. Only when all object proxies
// have been added, the BusObjectManagerClient:name-owner is set to the new name
// owner (this includes emission of the #GObject::notify signal). Furthermore,
// you are guaranteed that BusObjectManagerClient:name-owner will alternate
// between a name owner (e.g. `:1.42`) and nil even in the case where the name
// of interest is atomically replaced
//
// Ultimately, BusObjectManagerClient is used to obtain BusProxy instances. All
// signals (including the org.freedesktop.DBus.Properties::PropertiesChanged
// signal) delivered to BusProxy instances are guaranteed to originate from the
// name owner. This guarantee along with the behavior described above, means
// that certain race conditions including the "half the proxy is from the old
// owner and the other half is from the new owner" problem cannot happen.
//
// To avoid having the application connect to signals on the returned
// BusObjectProxy and BusProxy objects, the BusObject::interface-added,
// BusObject::interface-removed, BusProxy::g-properties-changed and
// BusProxy::g-signal signals are also emitted on the BusObjectManagerClient
// instance managing these objects. The signals emitted are
// BusObjectManager::interface-added, BusObjectManager::interface-removed,
// BusObjectManagerClient::interface-proxy-properties-changed and
// BusObjectManagerClient::interface-proxy-signal.
//
// Note that all callbacks and signals are emitted in the [thread-default main
// context][g-main-context-push-thread-default] that the BusObjectManagerClient
// object was constructed in. Additionally, the BusObjectProxy and BusProxy
// objects originating from the BusObjectManagerClient object will be created in
// the same context and, consequently, will deliver signals in the same main
// loop.
type DBusObjectManagerClient interface {
	gextras.Objector

	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// Flags gets the flags that @manager was constructed with.
	Flags() DBusObjectManagerClientFlags
	// Name gets the name that @manager is for, or nil if not a message bus
	// connection.
	Name() string
	// NameOwner: the unique name that owns the name that @manager is for or nil
	// if no-one currently owns that name. You can connect to the
	// #GObject::notify signal to track changes to the
	// BusObjectManagerClient:name-owner property.
	NameOwner() string
}

// dBusObjectManagerClient implements the DBusObjectManagerClient interface.
type dBusObjectManagerClient struct {
	gextras.Objector
}

// WrapDBusObjectManagerClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerClient(obj *externglib.Object) DBusObjectManagerClient {
	return DBusObjectManagerClient{
		gextras.Objector: (obj),
	}
}

func marshalDBusObjectManagerClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerClient(obj), nil
}

// NewDBusObjectManagerClientForBusSync constructs a class DBusObjectManagerClient.
func NewDBusObjectManagerClientForBusSync(busType BusType, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, cancellable Cancellable) DBusObjectManagerClient {
	var arg1 C.GBusType
	var arg2 C.GDBusObjectManagerClientFlags
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.GDBusProxyTypeFunc
	arg6 := C.gpointer(box.Assign(getProxyTypeUserData))
	var arg8 *C.GCancellable

	arg1 = (C.GBusType)(busType)
	arg2 = (C.GDBusObjectManagerClientFlags)(flags)
	arg3 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*[0]byte)(C.gotk4_DBusProxyTypeFunc)
	arg8 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_object_manager_client_new_for_bus_sync(arg1, arg2, arg3, arg4, arg5, (*[0]byte)(C.callbackDelete), arg8)

	var ret0 DBusObjectManagerClient

	ret0 = WrapDBusObjectManagerClient(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDBusObjectManagerClientSync constructs a class DBusObjectManagerClient.
func NewDBusObjectManagerClientSync(connection DBusConnection, flags DBusObjectManagerClientFlags, name string, objectPath string, getProxyTypeFunc DBusProxyTypeFunc, cancellable Cancellable) DBusObjectManagerClient {
	var arg1 *C.GDBusConnection
	var arg2 C.GDBusObjectManagerClientFlags
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.GDBusProxyTypeFunc
	arg6 := C.gpointer(box.Assign(getProxyTypeUserData))
	var arg8 *C.GCancellable

	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (C.GDBusObjectManagerClientFlags)(flags)
	arg3 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*[0]byte)(C.gotk4_DBusProxyTypeFunc)
	arg8 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_object_manager_client_new_sync(arg1, arg2, arg3, arg4, arg5, (*[0]byte)(C.callbackDelete), arg8)

	var ret0 DBusObjectManagerClient

	ret0 = WrapDBusObjectManagerClient(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Connection gets the BusConnection used by @manager.
func (manager dBusObjectManagerClient) Connection() DBusConnection {
	var arg0 *C.GDBusObjectManagerClient

	arg0 = (*C.GDBusObjectManagerClient)(manager.Native())

	ret := C.g_dbus_object_manager_client_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Flags gets the flags that @manager was constructed with.
func (manager dBusObjectManagerClient) Flags() DBusObjectManagerClientFlags {
	var arg0 *C.GDBusObjectManagerClient

	arg0 = (*C.GDBusObjectManagerClient)(manager.Native())

	ret := C.g_dbus_object_manager_client_get_flags(arg0)

	var ret0 DBusObjectManagerClientFlags

	ret0 = DBusObjectManagerClientFlags(ret)

	return ret0
}

// Name gets the name that @manager is for, or nil if not a message bus
// connection.
func (manager dBusObjectManagerClient) Name() string {
	var arg0 *C.GDBusObjectManagerClient

	arg0 = (*C.GDBusObjectManagerClient)(manager.Native())

	ret := C.g_dbus_object_manager_client_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NameOwner: the unique name that owns the name that @manager is for or nil
// if no-one currently owns that name. You can connect to the
// #GObject::notify signal to track changes to the
// BusObjectManagerClient:name-owner property.
func (manager dBusObjectManagerClient) NameOwner() string {
	var arg0 *C.GDBusObjectManagerClient

	arg0 = (*C.GDBusObjectManagerClient)(manager.Native())

	ret := C.g_dbus_object_manager_client_get_name_owner(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusObjectManagerServer is used to export BusObject instances using the
// standardized org.freedesktop.DBus.ObjectManager
// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
// interface. For example, remote D-Bus clients can get all objects and
// properties in a single call. Additionally, any change in the object hierarchy
// is broadcast using signals. This means that D-Bus clients can keep caches up
// to date by only listening to D-Bus signals.
//
// The recommended path to export an object manager at is the path form of the
// well-known name of a D-Bus service, or below. For example, if a D-Bus service
// is available at the well-known name `net.example.ExampleService1`, the object
// manager should typically be exported at `/net/example/ExampleService1`, or
// below (to allow for multiple object managers in a service).
//
// It is supported, but not recommended, to export an object manager at the root
// path, `/`.
//
// See BusObjectManagerClient for the client-side code that is intended to be
// used with BusObjectManagerServer or any D-Bus object implementing the
// org.freedesktop.DBus.ObjectManager interface.
type DBusObjectManagerServer interface {
	gextras.Objector

	// Export exports @object on @manager.
	//
	// If there is already a BusObject exported at the object path, then the old
	// object is removed.
	//
	// The object path for @object must be in the hierarchy rooted by the object
	// path for @manager.
	//
	// Note that @manager will take a reference on @object for as long as it is
	// exported.
	Export(object DBusObjectSkeleton)
	// ExportUniquely: like g_dbus_object_manager_server_export() but appends a
	// string of the form _N (with N being a natural number) to @object's object
	// path if an object with the given path already exists. As such, the
	// BusObjectProxy:g-object-path property of @object may be modified.
	ExportUniquely(object DBusObjectSkeleton)
	// Connection gets the BusConnection used by @manager.
	Connection() DBusConnection
	// IsExported returns whether @object is currently exported on @manager.
	IsExported(object DBusObjectSkeleton) bool
	// SetConnection exports all objects managed by @manager on @connection. If
	// @connection is nil, stops exporting objects.
	SetConnection(connection DBusConnection)
	// Unexport: if @manager has an object at @path, removes the object.
	// Otherwise does nothing.
	//
	// Note that @object_path must be in the hierarchy rooted by the object path
	// for @manager.
	Unexport(objectPath string) bool
}

// dBusObjectManagerServer implements the DBusObjectManagerServer interface.
type dBusObjectManagerServer struct {
	gextras.Objector
}

// WrapDBusObjectManagerServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectManagerServer(obj *externglib.Object) DBusObjectManagerServer {
	return DBusObjectManagerServer{
		gextras.Objector: (obj),
	}
}

func marshalDBusObjectManagerServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectManagerServer(obj), nil
}

// NewDBusObjectManagerServer constructs a class DBusObjectManagerServer.
func NewDBusObjectManagerServer(objectPath string) DBusObjectManagerServer {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_object_manager_server_new(arg1)

	var ret0 DBusObjectManagerServer

	ret0 = WrapDBusObjectManagerServer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Export exports @object on @manager.
//
// If there is already a BusObject exported at the object path, then the old
// object is removed.
//
// The object path for @object must be in the hierarchy rooted by the object
// path for @manager.
//
// Note that @manager will take a reference on @object for as long as it is
// exported.
func (manager dBusObjectManagerServer) Export(object DBusObjectSkeleton) {
	var arg0 *C.GDBusObjectManagerServer
	var arg1 *C.GDBusObjectSkeleton

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())
	arg1 = (*C.GDBusObjectSkeleton)(object.Native())

	C.g_dbus_object_manager_server_export(arg0, arg1)
}

// ExportUniquely: like g_dbus_object_manager_server_export() but appends a
// string of the form _N (with N being a natural number) to @object's object
// path if an object with the given path already exists. As such, the
// BusObjectProxy:g-object-path property of @object may be modified.
func (manager dBusObjectManagerServer) ExportUniquely(object DBusObjectSkeleton) {
	var arg0 *C.GDBusObjectManagerServer
	var arg1 *C.GDBusObjectSkeleton

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())
	arg1 = (*C.GDBusObjectSkeleton)(object.Native())

	C.g_dbus_object_manager_server_export_uniquely(arg0, arg1)
}

// Connection gets the BusConnection used by @manager.
func (manager dBusObjectManagerServer) Connection() DBusConnection {
	var arg0 *C.GDBusObjectManagerServer

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())

	ret := C.g_dbus_object_manager_server_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsExported returns whether @object is currently exported on @manager.
func (manager dBusObjectManagerServer) IsExported(object DBusObjectSkeleton) bool {
	var arg0 *C.GDBusObjectManagerServer
	var arg1 *C.GDBusObjectSkeleton

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())
	arg1 = (*C.GDBusObjectSkeleton)(object.Native())

	ret := C.g_dbus_object_manager_server_is_exported(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetConnection exports all objects managed by @manager on @connection. If
// @connection is nil, stops exporting objects.
func (manager dBusObjectManagerServer) SetConnection(connection DBusConnection) {
	var arg0 *C.GDBusObjectManagerServer
	var arg1 *C.GDBusConnection

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())
	arg1 = (*C.GDBusConnection)(connection.Native())

	C.g_dbus_object_manager_server_set_connection(arg0, arg1)
}

// Unexport: if @manager has an object at @path, removes the object.
// Otherwise does nothing.
//
// Note that @object_path must be in the hierarchy rooted by the object path
// for @manager.
func (manager dBusObjectManagerServer) Unexport(objectPath string) bool {
	var arg0 *C.GDBusObjectManagerServer
	var arg1 *C.gchar

	arg0 = (*C.GDBusObjectManagerServer)(manager.Native())
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_object_manager_server_unexport(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// DBusObjectProxy: a BusObjectProxy is an object used to represent a remote
// object with one or more D-Bus interfaces. Normally, you don't instantiate a
// BusObjectProxy yourself - typically BusObjectManagerClient is used to obtain
// it.
type DBusObjectProxy interface {
	gextras.Objector

	// Connection gets the connection that @proxy is for.
	Connection() DBusConnection
}

// dBusObjectProxy implements the DBusObjectProxy interface.
type dBusObjectProxy struct {
	gextras.Objector
}

// WrapDBusObjectProxy wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectProxy(obj *externglib.Object) DBusObjectProxy {
	return DBusObjectProxy{
		gextras.Objector: (obj),
	}
}

func marshalDBusObjectProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectProxy(obj), nil
}

// NewDBusObjectProxy constructs a class DBusObjectProxy.
func NewDBusObjectProxy(connection DBusConnection, objectPath string) DBusObjectProxy {
	var arg1 *C.GDBusConnection
	var arg2 *C.gchar

	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_dbus_object_proxy_new(arg1, arg2)

	var ret0 DBusObjectProxy

	ret0 = WrapDBusObjectProxy(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Connection gets the connection that @proxy is for.
func (proxy dBusObjectProxy) Connection() DBusConnection {
	var arg0 *C.GDBusObjectProxy

	arg0 = (*C.GDBusObjectProxy)(proxy.Native())

	ret := C.g_dbus_object_proxy_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DBusObjectSkeleton: a BusObjectSkeleton instance is essentially a group of
// D-Bus interfaces. The set of exported interfaces on the object may be dynamic
// and change at runtime.
//
// This type is intended to be used with BusObjectManager.
type DBusObjectSkeleton interface {
	gextras.Objector

	// AddInterface adds @interface_ to @object.
	//
	// If @object already contains a BusInterfaceSkeleton with the same
	// interface name, it is removed before @interface_ is added.
	//
	// Note that @object takes its own reference on @interface_ and holds it
	// until removed.
	AddInterface(interface_ DBusInterfaceSkeleton)
	// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
	// interfaces belonging to @object. See that method for when flushing is
	// useful.
	Flush()
	// RemoveInterface removes @interface_ from @object.
	RemoveInterface(interface_ DBusInterfaceSkeleton)
	// RemoveInterfaceByName removes the BusInterface with @interface_name from
	// @object.
	//
	// If no D-Bus interface of the given interface exists, this function does
	// nothing.
	RemoveInterfaceByName(interfaceName string)
	// SetObjectPath sets the object path for @object.
	SetObjectPath(objectPath string)
}

// dBusObjectSkeleton implements the DBusObjectSkeleton interface.
type dBusObjectSkeleton struct {
	gextras.Objector
}

// WrapDBusObjectSkeleton wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusObjectSkeleton(obj *externglib.Object) DBusObjectSkeleton {
	return DBusObjectSkeleton{
		gextras.Objector: (obj),
	}
}

func marshalDBusObjectSkeleton(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusObjectSkeleton(obj), nil
}

// NewDBusObjectSkeleton constructs a class DBusObjectSkeleton.
func NewDBusObjectSkeleton(objectPath string) DBusObjectSkeleton {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_object_skeleton_new(arg1)

	var ret0 DBusObjectSkeleton

	ret0 = WrapDBusObjectSkeleton(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddInterface adds @interface_ to @object.
//
// If @object already contains a BusInterfaceSkeleton with the same
// interface name, it is removed before @interface_ is added.
//
// Note that @object takes its own reference on @interface_ and holds it
// until removed.
func (object dBusObjectSkeleton) AddInterface(interface_ DBusInterfaceSkeleton) {
	var arg0 *C.GDBusObjectSkeleton
	var arg1 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusObjectSkeleton)(object.Native())
	arg1 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	C.g_dbus_object_skeleton_add_interface(arg0, arg1)
}

// Flush: this method simply calls g_dbus_interface_skeleton_flush() on all
// interfaces belonging to @object. See that method for when flushing is
// useful.
func (object dBusObjectSkeleton) Flush() {
	var arg0 *C.GDBusObjectSkeleton

	arg0 = (*C.GDBusObjectSkeleton)(object.Native())

	C.g_dbus_object_skeleton_flush(arg0)
}

// RemoveInterface removes @interface_ from @object.
func (object dBusObjectSkeleton) RemoveInterface(interface_ DBusInterfaceSkeleton) {
	var arg0 *C.GDBusObjectSkeleton
	var arg1 *C.GDBusInterfaceSkeleton

	arg0 = (*C.GDBusObjectSkeleton)(object.Native())
	arg1 = (*C.GDBusInterfaceSkeleton)(interface_.Native())

	C.g_dbus_object_skeleton_remove_interface(arg0, arg1)
}

// RemoveInterfaceByName removes the BusInterface with @interface_name from
// @object.
//
// If no D-Bus interface of the given interface exists, this function does
// nothing.
func (object dBusObjectSkeleton) RemoveInterfaceByName(interfaceName string) {
	var arg0 *C.GDBusObjectSkeleton
	var arg1 *C.gchar

	arg0 = (*C.GDBusObjectSkeleton)(object.Native())
	arg1 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_object_skeleton_remove_interface_by_name(arg0, arg1)
}

// SetObjectPath sets the object path for @object.
func (object dBusObjectSkeleton) SetObjectPath(objectPath string) {
	var arg0 *C.GDBusObjectSkeleton
	var arg1 *C.gchar

	arg0 = (*C.GDBusObjectSkeleton)(object.Native())
	arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg1))

	C.g_dbus_object_skeleton_set_object_path(arg0, arg1)
}

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProxy interface {
	gextras.Objector

	// Call: asynchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is closed then the operation
	// will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
	// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
	// value not compatible with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_proxy_call (proxy,
	//                        "TwoStrings",
	//                        g_variant_new ("(ss)",
	//                                       "Thing One",
	//                                       "Thing Two"),
	//                        G_DBUS_CALL_FLAGS_NONE,
	//                        -1,
	//                        NULL,
	//                        (GAsyncReadyCallback) two_strings_done,
	//                        &data);
	//
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call g_dbus_proxy_call_finish() to
	// get the result of the operation. See g_dbus_proxy_call_sync() for the
	// synchronous version of this method.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallSync: synchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is disconnected then the
	// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
	// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
	// contains a value not compatible with the D-Bus protocol, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//     g_dbus_proxy_call_sync (proxy,
	//                             "TwoStrings",
	//                             g_variant_new ("(ss)",
	//                                            "Thing One",
	//                                            "Thing Two"),
	//                             G_DBUS_CALL_FLAGS_NONE,
	//                             -1,
	//                             NULL,
	//                             &error);
	//
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_proxy_call() for the asynchronous version of this method.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant
	// CallWithUnixFdList: like g_dbus_proxy_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
	// returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant)
	// CachedProperty looks up the value for a property from the cache. This
	// call does no blocking IO.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	CachedProperty(propertyName string) *glib.Variant
	// CachedPropertyNames gets the names of all cached properties on @proxy.
	CachedPropertyNames() []string
	// Connection gets the connection @proxy is for.
	Connection() DBusConnection
	// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
	// is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	DefaultTimeout() int
	// Flags gets the flags that @proxy was constructed with.
	Flags() DBusProxyFlags
	// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
	// interface that @proxy conforms to. See the BusProxy:g-interface-info
	// property for more details.
	InterfaceInfo() *DBusInterfaceInfo
	// InterfaceName gets the D-Bus interface name @proxy is for.
	InterfaceName() string
	// Name gets the name that @proxy was constructed for.
	Name() string
	// NameOwner: the unique name that owns the name that @proxy is for or nil
	// if no-one currently owns that name. You may connect to the
	// #GObject::notify signal to track changes to the BusProxy:g-name-owner
	// property.
	NameOwner() string
	// ObjectPath gets the object path @proxy is for.
	ObjectPath() string
	// SetCachedProperty: if @value is not nil, sets the cached value for the
	// property with name @property_name to the value in @value.
	//
	// If @value is nil, then the cached value is removed from the property
	// cache.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	//
	// If the @value #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.
	//
	//     g_dbus_proxy_set_cached_property (proxy,
	//                                       "SomeProperty",
	//                                       g_variant_new ("(si)",
	//                                                     "A String",
	//                                                     42));
	//
	//
	// Normally you will not need to use this method since @proxy is tracking
	// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
	// D-Bus signal. However, for performance reasons an object may decide to
	// not use this signal for some properties and instead use a proprietary
	// out-of-band mechanism to transmit changes.
	//
	// As a concrete example, consider an object with a property
	// `ChatroomParticipants` which is an array of strings. Instead of
	// transmitting the same (long) array every time the property changes, it is
	// more efficient to only transmit the delta using e.g. signals
	// `ChatroomParticipantJoined(String name)` and
	// `ChatroomParticipantParted(String name)`.
	SetCachedProperty(propertyName string, value *glib.Variant)
	// SetDefaultTimeout sets the timeout to use if -1 (specifying default
	// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	SetDefaultTimeout(timeoutMsec int)
	// SetInterfaceInfo: ensure that interactions with @proxy conform to the
	// given interface. See the BusProxy:g-interface-info property for more
	// details.
	SetInterfaceInfo(info *DBusInterfaceInfo)
}

// dBusProxy implements the DBusProxy interface.
type dBusProxy struct {
	gextras.Objector
}

// WrapDBusProxy wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusProxy(obj *externglib.Object) DBusProxy {
	return DBusProxy{
		gextras.Objector: (obj),
	}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusProxy(obj), nil
}

// NewDBusProxyForBusSync constructs a class DBusProxy.
func NewDBusProxyForBusSync(busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) DBusProxy {
	var arg1 C.GBusType
	var arg2 C.GDBusProxyFlags
	var arg3 *C.GDBusInterfaceInfo
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 *C.GCancellable

	arg1 = (C.GBusType)(busType)
	arg2 = (C.GDBusProxyFlags)(flags)
	arg3 = (*C.GDBusInterfaceInfo)(info.Native())
	arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_proxy_new_for_bus_sync(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 DBusProxy

	ret0 = WrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDBusProxySync constructs a class DBusProxy.
func NewDBusProxySync(connection DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) DBusProxy {
	var arg1 *C.GDBusConnection
	var arg2 C.GDBusProxyFlags
	var arg3 *C.GDBusInterfaceInfo
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 *C.GCancellable

	arg1 = (*C.GDBusConnection)(connection.Native())
	arg2 = (C.GDBusProxyFlags)(flags)
	arg3 = (*C.GDBusInterfaceInfo)(info.Native())
	arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_proxy_new_sync(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 DBusProxy

	ret0 = WrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Call: asynchronously invokes the @method_name method on @proxy.
//
// If @method_name contains any dots, then @name is split into interface and
// method name parts. This allows using @proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with @proxy is closed then the operation
// will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
// value not compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//     g_dbus_proxy_call (proxy,
//                        "TwoStrings",
//                        g_variant_new ("(ss)",
//                                       "Thing One",
//                                       "Thing Two"),
//                        G_DBUS_CALL_FLAGS_NONE,
//                        -1,
//                        NULL,
//                        (GAsyncReadyCallback) two_strings_done,
//                        &data);
//
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @method_name is referenced by it, then the return value is checked
// against the return type.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call g_dbus_proxy_call_finish() to
// get the result of the operation. See g_dbus_proxy_call_sync() for the
// synchronous version of this method.
//
// If @callback is nil then the D-Bus method call message will be sent with
// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (proxy dBusProxy) Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	arg7 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(parameters.Native())
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_proxy_call(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// CallSync: synchronously invokes the @method_name method on @proxy.
//
// If @method_name contains any dots, then @name is split into interface and
// method name parts. This allows using @proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with @proxy is disconnected then the
// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
// contains a value not compatible with the D-Bus protocol, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//     g_dbus_proxy_call_sync (proxy,
//                             "TwoStrings",
//                             g_variant_new ("(ss)",
//                                            "Thing One",
//                                            "Thing Two"),
//                             G_DBUS_CALL_FLAGS_NONE,
//                             -1,
//                             NULL,
//                             &error);
//
//
// The calling thread is blocked until a reply is received. See
// g_dbus_proxy_call() for the asynchronous version of this method.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @method_name is referenced by it, then the return value is checked
// against the return type.
func (proxy dBusProxy) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) *glib.Variant {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GCancellable

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(parameters.Native())
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_proxy_call_sync(arg0, arg1, arg2, arg3, arg4, arg5)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// CallWithUnixFdList: like g_dbus_proxy_call() but also takes a FDList
// object.
//
// This method is only available on UNIX.
func (proxy dBusProxy) CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GUnixFDList
	var arg6 *C.GCancellable
	var arg7 C.GAsyncReadyCallback
	arg8 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(parameters.Native())
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GUnixFDList)(fdList.Native())
	arg6 = (*C.GCancellable)(cancellable.Native())
	arg7 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_dbus_proxy_call_with_unix_fd_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
// returns FDList objects.
//
// This method is only available on UNIX.
func (proxy dBusProxy) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GUnixFDList
	var arg6 **C.GUnixFDList // out
	var arg7 *C.GCancellable

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(parameters.Native())
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GUnixFDList)(fdList.Native())
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_proxy_call_with_unix_fd_list_sync(arg0, arg1, arg2, arg3, arg4, arg5, &arg6, arg7)

	var ret0 UnixFDList
	var ret1 *glib.Variant

	ret0 = WrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(arg6.Native())))

	ret1 = glib.WrapVariant(ret)

	return ret0, ret1
}

// CachedProperty looks up the value for a property from the cache. This
// call does no blocking IO.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the
// type of the property.
func (proxy dBusProxy) CachedProperty(propertyName string) *glib.Variant {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_proxy_get_cached_property(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// CachedPropertyNames gets the names of all cached properties on @proxy.
func (proxy dBusProxy) CachedPropertyNames() []string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_cached_property_names(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Connection gets the connection @proxy is for.
func (proxy dBusProxy) Connection() DBusConnection {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_connection(arg0)

	var ret0 DBusConnection

	ret0 = WrapDBusConnection(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
// is passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
func (proxy dBusProxy) DefaultTimeout() int {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_default_timeout(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Flags gets the flags that @proxy was constructed with.
func (proxy dBusProxy) Flags() DBusProxyFlags {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_flags(arg0)

	var ret0 DBusProxyFlags

	ret0 = DBusProxyFlags(ret)

	return ret0
}

// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
// interface that @proxy conforms to. See the BusProxy:g-interface-info
// property for more details.
func (proxy dBusProxy) InterfaceInfo() *DBusInterfaceInfo {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_interface_info(arg0)

	var ret0 *DBusInterfaceInfo

	ret0 = WrapDBusInterfaceInfo(ret)

	return ret0
}

// InterfaceName gets the D-Bus interface name @proxy is for.
func (proxy dBusProxy) InterfaceName() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_interface_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Name gets the name that @proxy was constructed for.
func (proxy dBusProxy) Name() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NameOwner: the unique name that owns the name that @proxy is for or nil
// if no-one currently owns that name. You may connect to the
// #GObject::notify signal to track changes to the BusProxy:g-name-owner
// property.
func (proxy dBusProxy) NameOwner() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_name_owner(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ObjectPath gets the object path @proxy is for.
func (proxy dBusProxy) ObjectPath() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(proxy.Native())

	ret := C.g_dbus_proxy_get_object_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetCachedProperty: if @value is not nil, sets the cached value for the
// property with name @property_name to the value in @value.
//
// If @value is nil, then the cached value is removed from the property
// cache.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the
// type of the property.
//
// If the @value #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.
//
//     g_dbus_proxy_set_cached_property (proxy,
//                                       "SomeProperty",
//                                       g_variant_new ("(si)",
//                                                     "A String",
//                                                     42));
//
//
// Normally you will not need to use this method since @proxy is tracking
// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
// D-Bus signal. However, for performance reasons an object may decide to
// not use this signal for some properties and instead use a proprietary
// out-of-band mechanism to transmit changes.
//
// As a concrete example, consider an object with a property
// `ChatroomParticipants` which is an array of strings. Instead of
// transmitting the same (long) array every time the property changes, it is
// more efficient to only transmit the delta using e.g. signals
// `ChatroomParticipantJoined(String name)` and
// `ChatroomParticipantParted(String name)`.
func (proxy dBusProxy) SetCachedProperty(propertyName string, value *glib.Variant) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	C.g_dbus_proxy_set_cached_property(arg0, arg1, arg2)
}

// SetDefaultTimeout sets the timeout to use if -1 (specifying default
// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
func (proxy dBusProxy) SetDefaultTimeout(timeoutMsec int) {
	var arg0 *C.GDBusProxy
	var arg1 C.gint

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = C.gint(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout(arg0, arg1)
}

// SetInterfaceInfo: ensure that interactions with @proxy conform to the
// given interface. See the BusProxy:g-interface-info property for more
// details.
func (proxy dBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo) {
	var arg0 *C.GDBusProxy
	var arg1 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusProxy)(proxy.Native())
	arg1 = (*C.GDBusInterfaceInfo)(info.Native())

	C.g_dbus_proxy_set_interface_info(arg0, arg1)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with G-DBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer.
type DBusServer interface {
	gextras.Objector

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// dBusServer implements the DBusServer interface.
type dBusServer struct {
	gextras.Objector
}

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return DBusServer{
		gextras.Objector: (obj),
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

// NewDBusServerSync constructs a class DBusServer.
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) DBusServer {
	var arg1 *C.gchar
	var arg2 C.GDBusServerFlags
	var arg3 *C.gchar
	var arg4 *C.GDBusAuthObserver
	var arg5 *C.GCancellable

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GDBusServerFlags)(flags)
	arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GDBusAuthObserver)(observer.Native())
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_dbus_server_new_sync(arg1, arg2, arg3, arg4, arg5)

	var ret0 DBusServer

	ret0 = WrapDBusServer(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// string that can be used by clients to connect to @server.
func (server dBusServer) ClientAddress() string {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	ret := C.g_dbus_server_get_client_address(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets the flags for @server.
func (server dBusServer) Flags() DBusServerFlags {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	ret := C.g_dbus_server_get_flags(arg0)

	var ret0 DBusServerFlags

	ret0 = DBusServerFlags(ret)

	return ret0
}

// Guid gets the GUID for @server.
func (server dBusServer) Guid() string {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	ret := C.g_dbus_server_get_guid(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsActive gets whether @server is active.
func (server dBusServer) IsActive() bool {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	ret := C.g_dbus_server_is_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Start starts @server.
func (server dBusServer) Start() {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	C.g_dbus_server_start(arg0)
}

// Stop stops @server.
func (server dBusServer) Stop() {
	var arg0 *C.GDBusServer

	arg0 = (*C.GDBusServer)(server.Native())

	C.g_dbus_server_stop(arg0)
}

// DataInputStream: data input stream implements Stream and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream interface {
	BufferedInputStream

	// ByteOrder gets the byte order for the data input stream.
	ByteOrder() DataStreamByteOrder
	// NewlineType gets the current newline type for the @stream.
	NewlineType() DataStreamNewlineType
	// ReadByte reads an unsigned 8-bit/1-byte value from @stream.
	ReadByte(cancellable Cancellable) byte
	// ReadInt16 reads a 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadInt16(cancellable Cancellable) int16
	// ReadInt32 reads a signed 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt32(cancellable Cancellable) int32
	// ReadInt64 reads a 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadInt64(cancellable Cancellable) int64
	// ReadLine reads a line from the data input stream. Note that no encoding
	// checks or conversion is performed; the input is not guaranteed to be
	// UTF-8, and may in fact have embedded NUL characters.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLine(cancellable Cancellable) (length uint, guint8s []byte)
	// ReadLineAsync: the asynchronous version of
	// g_data_input_stream_read_line(). It is an error to have two outstanding
	// calls to this function.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_line_finish() to get the result of the
	// operation.
	ReadLineAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadLineUTF8(cancellable Cancellable) (length uint, utf8 string)
	// ReadUint16 reads an unsigned 16-bit/2-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	ReadUint16(cancellable Cancellable) uint16
	// ReadUint32 reads an unsigned 32-bit/4-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order() and
	// g_data_input_stream_set_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint32(cancellable Cancellable) uint32
	// ReadUint64 reads an unsigned 64-bit/8-byte value from @stream.
	//
	// In order to get the correct byte order for this read operation, see
	// g_data_input_stream_get_byte_order().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	ReadUint64(cancellable Cancellable) uint64
	// ReadUntil reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// Note that, in contrast to g_data_input_stream_read_until_async(), this
	// function consumes the stop character that it finds.
	//
	// Don't use this function in new code. Its functionality is inconsistent
	// with g_data_input_stream_read_until_async(). Both functions will be
	// marked as deprecated in a future release. Use
	// g_data_input_stream_read_upto() instead, but note that that function does
	// not consume the stop character.
	ReadUntil(stopChars string, cancellable Cancellable) (length uint, utf8 string)
	// ReadUntilAsync: the asynchronous version of
	// g_data_input_stream_read_until(). It is an error to have two outstanding
	// calls to this function.
	//
	// Note that, in contrast to g_data_input_stream_read_until(), this function
	// does not consume the stop character that it finds. You must read it for
	// yourself.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_until_finish() to get the result of the
	// operation.
	//
	// Don't use this function in new code. Its functionality is inconsistent
	// with g_data_input_stream_read_until(). Both functions will be marked as
	// deprecated in a future release. Use g_data_input_stream_read_upto_async()
	// instead.
	ReadUntilAsync(stopChars string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadUpto reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	//
	// In contrast to g_data_input_stream_read_until(), this function does not
	// consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	//
	// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
	//
	// The returned string will always be nul-terminated on success.
	ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (length uint, utf8 string)
	// ReadUptoAsync: the asynchronous version of
	// g_data_input_stream_read_upto(). It is an error to have two outstanding
	// calls to this function.
	//
	// In contrast to g_data_input_stream_read_until(), this function does not
	// consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	//
	// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_data_input_stream_read_upto_finish() to get the result of the
	// operation.
	ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetByteOrder: this function sets the byte order for the given @stream.
	// All subsequent reads from the @stream will be read in the given @order.
	SetByteOrder(order DataStreamByteOrder)
	// SetNewlineType sets the newline type for the @stream.
	//
	// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a
	// read chunk ends in "CR" we must read an additional byte to know if this
	// is "CR" or "CR LF", and this might block if there is no more data
	// available.
	SetNewlineType(_type DataStreamNewlineType)
}

// dataInputStream implements the DataInputStream interface.
type dataInputStream struct {
	BufferedInputStream
}

// WrapDataInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataInputStream(obj *externglib.Object) DataInputStream {
	return DataInputStream{
		BufferedInputStream: WrapBufferedInputStream(obj),
	}
}

func marshalDataInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataInputStream(obj), nil
}

// NewDataInputStream constructs a class DataInputStream.
func NewDataInputStream(baseStream InputStream) DataInputStream {
	var arg1 *C.GInputStream

	arg1 = (*C.GInputStream)(baseStream.Native())

	ret := C.g_data_input_stream_new(arg1)

	var ret0 DataInputStream

	ret0 = WrapDataInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ByteOrder gets the byte order for the data input stream.
func (stream dataInputStream) ByteOrder() DataStreamByteOrder {
	var arg0 *C.GDataInputStream

	arg0 = (*C.GDataInputStream)(stream.Native())

	ret := C.g_data_input_stream_get_byte_order(arg0)

	var ret0 DataStreamByteOrder

	ret0 = DataStreamByteOrder(ret)

	return ret0
}

// NewlineType gets the current newline type for the @stream.
func (stream dataInputStream) NewlineType() DataStreamNewlineType {
	var arg0 *C.GDataInputStream

	arg0 = (*C.GDataInputStream)(stream.Native())

	ret := C.g_data_input_stream_get_newline_type(arg0)

	var ret0 DataStreamNewlineType

	ret0 = DataStreamNewlineType(ret)

	return ret0
}

// ReadByte reads an unsigned 8-bit/1-byte value from @stream.
func (stream dataInputStream) ReadByte(cancellable Cancellable) byte {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_byte(arg0, arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// ReadInt16 reads a 16-bit/2-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
func (stream dataInputStream) ReadInt16(cancellable Cancellable) int16 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_int16(arg0, arg1)

	var ret0 int16

	ret0 = int16(ret)

	return ret0
}

// ReadInt32 reads a signed 32-bit/4-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadInt32(cancellable Cancellable) int32 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_int32(arg0, arg1)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// ReadInt64 reads a 64-bit/8-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadInt64(cancellable Cancellable) int64 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_int64(arg0, arg1)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// ReadLine reads a line from the data input stream. Note that no encoding
// checks or conversion is performed; the input is not guaranteed to be
// UTF-8, and may in fact have embedded NUL characters.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadLine(cancellable Cancellable) (length uint, guint8s []byte) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gsize // out
	var arg2 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_line(arg0, &arg1, arg2)

	var ret0 uint
	var ret1 []byte

	ret0 = uint(arg1)

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret1 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret1[i] = byte(src)
		}
	}

	return ret0, ret1
}

// ReadLineAsync: the asynchronous version of
// g_data_input_stream_read_line(). It is an error to have two outstanding
// calls to this function.
//
// When the operation is finished, @callback will be called. You can then
// call g_data_input_stream_read_line_finish() to get the result of the
// operation.
func (stream dataInputStream) ReadLineAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDataInputStream
	var arg1 C.gint
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = C.gint(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_data_input_stream_read_line_async(arg0, arg1, arg2, arg3)
}

// ReadLineUTF8 reads a UTF-8 encoded line from the data input stream.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadLineUTF8(cancellable Cancellable) (length uint, utf8 string) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gsize // out
	var arg2 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_line_utf8(arg0, &arg1, arg2)

	var ret0 uint
	var ret1 string

	ret0 = uint(arg1)

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// ReadUint16 reads an unsigned 16-bit/2-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
func (stream dataInputStream) ReadUint16(cancellable Cancellable) uint16 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_uint16(arg0, arg1)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// ReadUint32 reads an unsigned 32-bit/4-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order() and
// g_data_input_stream_set_byte_order().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadUint32(cancellable Cancellable) uint32 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_uint32(arg0, arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// ReadUint64 reads an unsigned 64-bit/8-byte value from @stream.
//
// In order to get the correct byte order for this read operation, see
// g_data_input_stream_get_byte_order().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream dataInputStream) ReadUint64(cancellable Cancellable) uint64 {
	var arg0 *C.GDataInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_uint64(arg0, arg1)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// ReadUntil reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
//
// Note that, in contrast to g_data_input_stream_read_until_async(), this
// function consumes the stop character that it finds.
//
// Don't use this function in new code. Its functionality is inconsistent
// with g_data_input_stream_read_until_async(). Both functions will be
// marked as deprecated in a future release. Use
// g_data_input_stream_read_upto() instead, but note that that function does
// not consume the stop character.
func (stream dataInputStream) ReadUntil(stopChars string, cancellable Cancellable) (length uint, utf8 string) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gchar
	var arg2 *C.gsize // out
	var arg3 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(arg1))
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_until(arg0, arg1, &arg2, arg3)

	var ret0 uint
	var ret1 string

	ret0 = uint(arg2)

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// ReadUntilAsync: the asynchronous version of
// g_data_input_stream_read_until(). It is an error to have two outstanding
// calls to this function.
//
// Note that, in contrast to g_data_input_stream_read_until(), this function
// does not consume the stop character that it finds. You must read it for
// yourself.
//
// When the operation is finished, @callback will be called. You can then
// call g_data_input_stream_read_until_finish() to get the result of the
// operation.
//
// Don't use this function in new code. Its functionality is inconsistent
// with g_data_input_stream_read_until(). Both functions will be marked as
// deprecated in a future release. Use g_data_input_stream_read_upto_async()
// instead.
func (stream dataInputStream) ReadUntilAsync(stopChars string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gchar
	var arg2 C.gint
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_data_input_stream_read_until_async(arg0, arg1, arg2, arg3, arg4)
}

// ReadUpto reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
//
// In contrast to g_data_input_stream_read_until(), this function does not
// consume the stop character. You have to use
// g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto() again.
//
// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
//
// The returned string will always be nul-terminated on success.
func (stream dataInputStream) ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (length uint, utf8 string) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 *C.gsize // out
	var arg4 *C.GCancellable

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(stopCharsLen)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_input_stream_read_upto(arg0, arg1, arg2, &arg3, arg4)

	var ret0 uint
	var ret1 string

	ret0 = uint(arg3)

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// ReadUptoAsync: the asynchronous version of
// g_data_input_stream_read_upto(). It is an error to have two outstanding
// calls to this function.
//
// In contrast to g_data_input_stream_read_until(), this function does not
// consume the stop character. You have to use
// g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto() again.
//
// Note that @stop_chars may contain '\0' if @stop_chars_len is specified.
//
// When the operation is finished, @callback will be called. You can then
// call g_data_input_stream_read_upto_finish() to get the result of the
// operation.
func (stream dataInputStream) ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDataInputStream
	var arg1 *C.gchar
	var arg2 C.gssize
	var arg3 C.gint
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(stopChars))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(stopCharsLen)
	arg3 = C.gint(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_data_input_stream_read_upto_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetByteOrder: this function sets the byte order for the given @stream.
// All subsequent reads from the @stream will be read in the given @order.
func (stream dataInputStream) SetByteOrder(order DataStreamByteOrder) {
	var arg0 *C.GDataInputStream
	var arg1 C.GDataStreamByteOrder

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (C.GDataStreamByteOrder)(order)

	C.g_data_input_stream_set_byte_order(arg0, arg1)
}

// SetNewlineType sets the newline type for the @stream.
//
// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a
// read chunk ends in "CR" we must read an additional byte to know if this
// is "CR" or "CR LF", and this might block if there is no more data
// available.
func (stream dataInputStream) SetNewlineType(_type DataStreamNewlineType) {
	var arg0 *C.GDataInputStream
	var arg1 C.GDataStreamNewlineType

	arg0 = (*C.GDataInputStream)(stream.Native())
	arg1 = (C.GDataStreamNewlineType)(_type)

	C.g_data_input_stream_set_newline_type(arg0, arg1)
}

// DataOutputStream: data output stream implements Stream and includes functions
// for writing data directly to an output stream.
type DataOutputStream interface {
	FilterOutputStream

	// ByteOrder gets the byte order for the stream.
	ByteOrder() DataStreamByteOrder
	// PutByte puts a byte into the output stream.
	PutByte(data byte, cancellable Cancellable) bool
	// PutInt16 puts a signed 16-bit integer into the output stream.
	PutInt16(data int16, cancellable Cancellable) bool
	// PutInt32 puts a signed 32-bit integer into the output stream.
	PutInt32(data int32, cancellable Cancellable) bool
	// PutInt64 puts a signed 64-bit integer into the stream.
	PutInt64(data int64, cancellable Cancellable) bool
	// PutString puts a string into the output stream.
	PutString(str string, cancellable Cancellable) bool
	// PutUint16 puts an unsigned 16-bit integer into the output stream.
	PutUint16(data uint16, cancellable Cancellable) bool
	// PutUint32 puts an unsigned 32-bit integer into the stream.
	PutUint32(data uint32, cancellable Cancellable) bool
	// PutUint64 puts an unsigned 64-bit integer into the stream.
	PutUint64(data uint64, cancellable Cancellable) bool
	// SetByteOrder sets the byte order of the data output stream to @order.
	SetByteOrder(order DataStreamByteOrder)
}

// dataOutputStream implements the DataOutputStream interface.
type dataOutputStream struct {
	FilterOutputStream
}

// WrapDataOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapDataOutputStream(obj *externglib.Object) DataOutputStream {
	return DataOutputStream{
		FilterOutputStream: WrapFilterOutputStream(obj),
	}
}

func marshalDataOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDataOutputStream(obj), nil
}

// NewDataOutputStream constructs a class DataOutputStream.
func NewDataOutputStream(baseStream OutputStream) DataOutputStream {
	var arg1 *C.GOutputStream

	arg1 = (*C.GOutputStream)(baseStream.Native())

	ret := C.g_data_output_stream_new(arg1)

	var ret0 DataOutputStream

	ret0 = WrapDataOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ByteOrder gets the byte order for the stream.
func (stream dataOutputStream) ByteOrder() DataStreamByteOrder {
	var arg0 *C.GDataOutputStream

	arg0 = (*C.GDataOutputStream)(stream.Native())

	ret := C.g_data_output_stream_get_byte_order(arg0)

	var ret0 DataStreamByteOrder

	ret0 = DataStreamByteOrder(ret)

	return ret0
}

// PutByte puts a byte into the output stream.
func (stream dataOutputStream) PutByte(data byte, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.guchar
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.guchar(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_byte(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutInt16 puts a signed 16-bit integer into the output stream.
func (stream dataOutputStream) PutInt16(data int16, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.gint16
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.gint16(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_int16(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutInt32 puts a signed 32-bit integer into the output stream.
func (stream dataOutputStream) PutInt32(data int32, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.gint32
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.gint32(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_int32(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutInt64 puts a signed 64-bit integer into the stream.
func (stream dataOutputStream) PutInt64(data int64, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.gint64
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.gint64(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_int64(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutString puts a string into the output stream.
func (stream dataOutputStream) PutString(str string, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 *C.char
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_string(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutUint16 puts an unsigned 16-bit integer into the output stream.
func (stream dataOutputStream) PutUint16(data uint16, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.guint16
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.guint16(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_uint16(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutUint32 puts an unsigned 32-bit integer into the stream.
func (stream dataOutputStream) PutUint32(data uint32, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.guint32
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.guint32(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_uint32(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PutUint64 puts an unsigned 64-bit integer into the stream.
func (stream dataOutputStream) PutUint64(data uint64, cancellable Cancellable) bool {
	var arg0 *C.GDataOutputStream
	var arg1 C.guint64
	var arg2 *C.GCancellable

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = C.guint64(data)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_data_output_stream_put_uint64(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetByteOrder sets the byte order of the data output stream to @order.
func (stream dataOutputStream) SetByteOrder(order DataStreamByteOrder) {
	var arg0 *C.GDataOutputStream
	var arg1 C.GDataStreamByteOrder

	arg0 = (*C.GDataOutputStream)(stream.Native())
	arg1 = (C.GDataStreamByteOrder)(order)

	C.g_data_output_stream_set_byte_order(arg0, arg1)
}

// DesktopAppInfo is an implementation of Info based on desktop files.
//
// Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type DesktopAppInfo interface {
	gextras.Objector

	// ActionName gets the user-visible display name of the "additional
	// application action" specified by @action_name.
	//
	// This corresponds to the "Name" key within the keyfile group for the
	// action.
	ActionName(actionName string) string
	// Boolean looks up a boolean value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	Boolean(key string) bool
	// Categories gets the categories from the desktop file.
	Categories() string
	// Filename: when @info was created from a known filename, return it. In
	// some situations such as the AppInfo returned from
	// g_desktop_app_info_new_from_keyfile(), this function will return nil.
	Filename() string
	// GenericName gets the generic name from the destkop file.
	GenericName() string
	// IsHidden: a desktop file is hidden if the Hidden key in it is set to
	// True.
	IsHidden() bool
	// Keywords gets the keywords from the desktop file.
	Keywords() []string
	// LocaleString looks up a localized string value in the keyfile backing
	// @info translated to the current locale.
	//
	// The @key is looked up in the "Desktop Entry" group.
	LocaleString(key string) string
	// Nodisplay gets the value of the NoDisplay key, which helps determine if
	// the application info should be shown in menus. See
	// KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
	Nodisplay() bool
	// ShowIn checks if the application info should be shown in menus that list
	// available applications for a specific name of the desktop, based on the
	// `OnlyShowIn` and `NotShowIn` keys.
	//
	// @desktop_env should typically be given as nil, in which case the
	// `XDG_CURRENT_DESKTOP` environment variable is consulted. If you want to
	// override the default mechanism then you may specify @desktop_env, but
	// this is not recommended.
	//
	// Note that g_app_info_should_show() for @info will include this check
	// (with nil for @desktop_env) as well as additional checks.
	ShowIn(desktopEnv string) bool
	// StartupWmClass retrieves the StartupWMClass field from @info. This
	// represents the WM_CLASS property of the main window of the application,
	// if launched through @info.
	StartupWmClass() string
	// String looks up a string value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	String(key string) string
	// StringList looks up a string list value in the keyfile backing @info.
	//
	// The @key is looked up in the "Desktop Entry" group.
	StringList(key string) (length uint, utf8s []string)
	// HasKey returns whether @key exists in the "Desktop Entry" group of the
	// keyfile backing @info.
	HasKey(key string) bool
	// LaunchAction activates the named application action.
	//
	// You may only call this function on action names that were returned from
	// g_desktop_app_info_list_actions().
	//
	// Note that if the main entry of the desktop file indicates that the
	// application supports startup notification, and @launch_context is
	// non-nil, then startup notification will be used when activating the
	// action (and as such, invocation of the action on the receiving side must
	// signal the end of startup notification when it is completed). This is the
	// expected behaviour of applications declaring additional actions, as per
	// the desktop file specification.
	//
	// As with g_app_info_launch() there is no way to detect failures that occur
	// while using this function.
	LaunchAction(actionName string, launchContext AppLaunchContext)
	// LaunchUrisAsManager: this function performs the equivalent of
	// g_app_info_launch_uris(), but is intended primarily for operating system
	// components that launch applications. Ordinary applications should use
	// g_app_info_launch_uris().
	//
	// If the application is launched via GSpawn, then @spawn_flags, @user_setup
	// and @user_setup_data are used for the call to g_spawn_async().
	// Additionally, @pid_callback (with @pid_callback_data) will be called to
	// inform about the PID of the created process. See
	// g_spawn_async_with_pipes() for information on certain parameter
	// conditions that can enable an optimized posix_spawn() codepath to be
	// used.
	//
	// If application launching occurs via some other mechanism (eg: D-Bus
	// activation) then @spawn_flags, @user_setup, @user_setup_data,
	// @pid_callback and @pid_callback_data are ignored.
	LaunchUrisAsManager(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback) bool
	// LaunchUrisAsManagerWithFds: equivalent to
	// g_desktop_app_info_launch_uris_as_manager() but allows you to pass in
	// file descriptors for the stdin, stdout and stderr streams of the launched
	// process.
	//
	// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
	// activation) then @stdin_fd, @stdout_fd and @stderr_fd are ignored.
	LaunchUrisAsManagerWithFds(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback, stdinFd int, stdoutFd int, stderrFd int) bool
	// ListActions returns the list of "additional application actions"
	// supported on the desktop file, as per the desktop file specification.
	//
	// As per the specification, this is the list of actions that are explicitly
	// listed in the "Actions" key of the [Desktop Entry] group.
	ListActions() []string
}

// desktopAppInfo implements the DesktopAppInfo interface.
type desktopAppInfo struct {
	gextras.Objector
}

// WrapDesktopAppInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapDesktopAppInfo(obj *externglib.Object) DesktopAppInfo {
	return DesktopAppInfo{
		gextras.Objector: (obj),
	}
}

func marshalDesktopAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDesktopAppInfo(obj), nil
}

// NewDesktopAppInfo constructs a class DesktopAppInfo.
func NewDesktopAppInfo(desktopID string) DesktopAppInfo {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(desktopID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_new(arg1)

	var ret0 DesktopAppInfo

	ret0 = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDesktopAppInfoFromFilename constructs a class DesktopAppInfo.
func NewDesktopAppInfoFromFilename(filename string) DesktopAppInfo {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_new_from_filename(arg1)

	var ret0 DesktopAppInfo

	ret0 = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewDesktopAppInfoFromKeyfile constructs a class DesktopAppInfo.
func NewDesktopAppInfoFromKeyfile(keyFile *glib.KeyFile) DesktopAppInfo {
	var arg1 *C.GKeyFile

	arg1 = (*C.GKeyFile)(keyFile.Native())

	ret := C.g_desktop_app_info_new_from_keyfile(arg1)

	var ret0 DesktopAppInfo

	ret0 = WrapDesktopAppInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ActionName gets the user-visible display name of the "additional
// application action" specified by @action_name.
//
// This corresponds to the "Name" key within the keyfile group for the
// action.
func (info desktopAppInfo) ActionName(actionName string) string {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.gchar

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_action_name(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Boolean looks up a boolean value in the keyfile backing @info.
//
// The @key is looked up in the "Desktop Entry" group.
func (info desktopAppInfo) Boolean(key string) bool {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.char

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_boolean(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Categories gets the categories from the desktop file.
func (info desktopAppInfo) Categories() string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_categories(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Filename: when @info was created from a known filename, return it. In
// some situations such as the AppInfo returned from
// g_desktop_app_info_new_from_keyfile(), this function will return nil.
func (info desktopAppInfo) Filename() string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_filename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GenericName gets the generic name from the destkop file.
func (info desktopAppInfo) GenericName() string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_generic_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsHidden: a desktop file is hidden if the Hidden key in it is set to
// True.
func (info desktopAppInfo) IsHidden() bool {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_is_hidden(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Keywords gets the keywords from the desktop file.
func (info desktopAppInfo) Keywords() []string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_keywords(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// LocaleString looks up a localized string value in the keyfile backing
// @info translated to the current locale.
//
// The @key is looked up in the "Desktop Entry" group.
func (info desktopAppInfo) LocaleString(key string) string {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.char

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_locale_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Nodisplay gets the value of the NoDisplay key, which helps determine if
// the application info should be shown in menus. See
// KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
func (info desktopAppInfo) Nodisplay() bool {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_nodisplay(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ShowIn checks if the application info should be shown in menus that list
// available applications for a specific name of the desktop, based on the
// `OnlyShowIn` and `NotShowIn` keys.
//
// @desktop_env should typically be given as nil, in which case the
// `XDG_CURRENT_DESKTOP` environment variable is consulted. If you want to
// override the default mechanism then you may specify @desktop_env, but
// this is not recommended.
//
// Note that g_app_info_should_show() for @info will include this check
// (with nil for @desktop_env) as well as additional checks.
func (info desktopAppInfo) ShowIn(desktopEnv string) bool {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.gchar

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(desktopEnv))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_show_in(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// StartupWmClass retrieves the StartupWMClass field from @info. This
// represents the WM_CLASS property of the main window of the application,
// if launched through @info.
func (info desktopAppInfo) StartupWmClass() string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_get_startup_wm_class(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// String looks up a string value in the keyfile backing @info.
//
// The @key is looked up in the "Desktop Entry" group.
func (info desktopAppInfo) String(key string) string {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.char

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// StringList looks up a string list value in the keyfile backing @info.
//
// The @key is looked up in the "Desktop Entry" group.
func (info desktopAppInfo) StringList(key string) (length uint, utf8s []string) {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.char
	var arg2 *C.gsize // out

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_get_string_list(arg0, arg1, &arg2)

	var ret0 uint
	var ret1 []string

	ret0 = uint(arg2)

	{
		ret1 = make([]string, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0, ret1
}

// HasKey returns whether @key exists in the "Desktop Entry" group of the
// keyfile backing @info.
func (info desktopAppInfo) HasKey(key string) bool {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.char

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_desktop_app_info_has_key(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LaunchAction activates the named application action.
//
// You may only call this function on action names that were returned from
// g_desktop_app_info_list_actions().
//
// Note that if the main entry of the desktop file indicates that the
// application supports startup notification, and @launch_context is
// non-nil, then startup notification will be used when activating the
// action (and as such, invocation of the action on the receiving side must
// signal the end of startup notification when it is completed). This is the
// expected behaviour of applications declaring additional actions, as per
// the desktop file specification.
//
// As with g_app_info_launch() there is no way to detect failures that occur
// while using this function.
func (info desktopAppInfo) LaunchAction(actionName string, launchContext AppLaunchContext) {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.gchar
	var arg2 *C.GAppLaunchContext

	arg0 = (*C.GDesktopAppInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GAppLaunchContext)(launchContext.Native())

	C.g_desktop_app_info_launch_action(arg0, arg1, arg2)
}

// LaunchUrisAsManager: this function performs the equivalent of
// g_app_info_launch_uris(), but is intended primarily for operating system
// components that launch applications. Ordinary applications should use
// g_app_info_launch_uris().
//
// If the application is launched via GSpawn, then @spawn_flags, @user_setup
// and @user_setup_data are used for the call to g_spawn_async().
// Additionally, @pid_callback (with @pid_callback_data) will be called to
// inform about the PID of the created process. See
// g_spawn_async_with_pipes() for information on certain parameter
// conditions that can enable an optimized posix_spawn() codepath to be
// used.
//
// If application launching occurs via some other mechanism (eg: D-Bus
// activation) then @spawn_flags, @user_setup, @user_setup_data,
// @pid_callback and @pid_callback_data are ignored.
func (appinfo desktopAppInfo) LaunchUrisAsManager(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback) bool {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.GList
	var arg2 *C.GAppLaunchContext
	var arg3 C.GSpawnFlags
	var arg4 C.GSpawnChildSetupFunc
	var arg5 C.gpointer
	var arg6 C.GDesktopAppLaunchCallback
	var arg7 C.gpointer

	arg0 = (*C.GDesktopAppInfo)(appinfo.Native())
	arg1 = (*C.GList)(uris.Native())
	arg2 = (*C.GAppLaunchContext)(launchContext.Native())
	arg3 = (C.GSpawnFlags)(spawnFlags)

	ret := C.g_desktop_app_info_launch_uris_as_manager(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LaunchUrisAsManagerWithFds: equivalent to
// g_desktop_app_info_launch_uris_as_manager() but allows you to pass in
// file descriptors for the stdin, stdout and stderr streams of the launched
// process.
//
// If application launching occurs via some non-spawn mechanism (e.g. D-Bus
// activation) then @stdin_fd, @stdout_fd and @stderr_fd are ignored.
func (appinfo desktopAppInfo) LaunchUrisAsManagerWithFds(uris *glib.List, launchContext AppLaunchContext, spawnFlags glib.SpawnFlags, userSetup glib.SpawnChildSetupFunc, pidCallback DesktopAppLaunchCallback, stdinFd int, stdoutFd int, stderrFd int) bool {
	var arg0 *C.GDesktopAppInfo
	var arg1 *C.GList
	var arg2 *C.GAppLaunchContext
	var arg3 C.GSpawnFlags
	var arg4 C.GSpawnChildSetupFunc
	var arg5 C.gpointer
	var arg6 C.GDesktopAppLaunchCallback
	var arg7 C.gpointer
	var arg8 C.gint
	var arg9 C.gint
	var arg10 C.gint

	arg0 = (*C.GDesktopAppInfo)(appinfo.Native())
	arg1 = (*C.GList)(uris.Native())
	arg2 = (*C.GAppLaunchContext)(launchContext.Native())
	arg3 = (C.GSpawnFlags)(spawnFlags)
	arg8 = C.gint(stdinFd)
	arg9 = C.gint(stdoutFd)
	arg10 = C.gint(stderrFd)

	ret := C.g_desktop_app_info_launch_uris_as_manager_with_fds(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListActions returns the list of "additional application actions"
// supported on the desktop file, as per the desktop file specification.
//
// As per the specification, this is the list of actions that are explicitly
// listed in the "Actions" key of the [Desktop Entry] group.
func (info desktopAppInfo) ListActions() []string {
	var arg0 *C.GDesktopAppInfo

	arg0 = (*C.GDesktopAppInfo)(info.Native())

	ret := C.g_desktop_app_info_list_actions(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// Emblem is an implementation of #GIcon that supports having an emblem, which
// is an icon with additional properties. It can than be added to a Icon.
//
// Currently, only metainformation about the emblem's origin is supported. More
// may be added in the future.
type Emblem interface {
	gextras.Objector

	// Origin gets the origin of the emblem.
	Origin() EmblemOrigin
}

// emblem implements the Emblem interface.
type emblem struct {
	gextras.Objector
}

// WrapEmblem wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblem(obj *externglib.Object) Emblem {
	return Emblem{
		gextras.Objector: (obj),
	}
}

func marshalEmblem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblem(obj), nil
}

// Origin gets the origin of the emblem.
func (emblem emblem) Origin() EmblemOrigin {
	var arg0 *C.GEmblem

	arg0 = (*C.GEmblem)(emblem.Native())

	ret := C.g_emblem_get_origin(arg0)

	var ret0 EmblemOrigin

	ret0 = EmblemOrigin(ret)

	return ret0
}

// EmblemedIcon is an implementation of #GIcon that supports adding an emblem to
// an icon. Adding multiple emblems to an icon is ensured via
// g_emblemed_icon_add_emblem().
//
// Note that Icon allows no control over the position of the emblems. See also
// #GEmblem for more information.
type EmblemedIcon interface {
	gextras.Objector

	// AddEmblem adds @emblem to the #GList of #GEmblems.
	AddEmblem(emblem Emblem)
	// ClearEmblems removes all the emblems from @icon.
	ClearEmblems()
	// Emblems gets the list of emblems for the @icon.
	Emblems() *glib.List
}

// emblemedIcon implements the EmblemedIcon interface.
type emblemedIcon struct {
	gextras.Objector
}

// WrapEmblemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapEmblemedIcon(obj *externglib.Object) EmblemedIcon {
	return EmblemedIcon{
		gextras.Objector: (obj),
	}
}

func marshalEmblemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapEmblemedIcon(obj), nil
}

// AddEmblem adds @emblem to the #GList of #GEmblems.
func (emblemed emblemedIcon) AddEmblem(emblem Emblem) {
	var arg0 *C.GEmblemedIcon
	var arg1 *C.GEmblem

	arg0 = (*C.GEmblemedIcon)(emblemed.Native())
	arg1 = (*C.GEmblem)(emblem.Native())

	C.g_emblemed_icon_add_emblem(arg0, arg1)
}

// ClearEmblems removes all the emblems from @icon.
func (emblemed emblemedIcon) ClearEmblems() {
	var arg0 *C.GEmblemedIcon

	arg0 = (*C.GEmblemedIcon)(emblemed.Native())

	C.g_emblemed_icon_clear_emblems(arg0)
}

// Emblems gets the list of emblems for the @icon.
func (emblemed emblemedIcon) Emblems() *glib.List {
	var arg0 *C.GEmblemedIcon

	arg0 = (*C.GEmblemedIcon)(emblemed.Native())

	ret := C.g_emblemed_icon_get_emblems(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// FileEnumerator allows you to operate on a set of #GFiles, returning a Info
// structure for each file enumerated (e.g. g_file_enumerate_children() will
// return a Enumerator for each of the children within a directory).
//
// To get the next file's information from a Enumerator, use
// g_file_enumerator_next_file() or its asynchronous version,
// g_file_enumerator_next_files_async(). Note that the asynchronous version will
// return a list of Infos, whereas the synchronous will only return the next
// file in the enumerator.
//
// The ordering of returned files is unspecified for non-Unix platforms; for
// more information, see g_dir_read_name(). On Unix, when operating on local
// files, returned files will be sorted by inode number. Effectively you can
// assume that the ordering of returned files will be stable between successive
// calls (and applications) assuming the directory is unchanged.
//
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your application code.
//
// To close a Enumerator, use g_file_enumerator_close(), or its asynchronous
// version, g_file_enumerator_close_async(). Once a Enumerator is closed, no
// further actions may be performed on it, and it should be freed with
// g_object_unref().
type FileEnumerator interface {
	gextras.Objector

	// Close releases all resources used by this enumerator, making the
	// enumerator return G_IO_ERROR_CLOSED on all calls.
	//
	// This will be automatically called when the last reference is dropped, but
	// you might want to call this function to make sure resources are released
	// as early as possible.
	Close(cancellable Cancellable) bool
	// CloseAsync: asynchronously closes the file enumerator.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
	// g_file_enumerator_close_finish().
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// HasPending checks if the file enumerator has pending operations.
	HasPending() bool
	// IsClosed checks if the file enumerator has been closed.
	IsClosed() bool
	// Iterate: this is a version of g_file_enumerator_next_file() that's easier
	// to use correctly from C programs. With g_file_enumerator_next_file(), the
	// gboolean return value signifies "end of iteration or error", which
	// requires allocation of a temporary #GError.
	//
	// In contrast, with this function, a false return from
	// g_file_enumerator_iterate() *always* means "error". End of iteration is
	// signaled by @out_info or @out_child being nil.
	//
	// Another crucial difference is that the references for @out_info and
	// @out_child are owned by @direnum (they are cached as hidden properties).
	// You must not unref them in your own code. This makes memory management
	// significantly easier for C code in combination with loops.
	//
	// Finally, this function optionally allows retrieving a #GFile as well.
	//
	// You must specify at least one of @out_info or @out_child.
	//
	// The code pattern for correctly using g_file_enumerator_iterate() from C
	// is:
	//
	//
	//    direnum = g_file_enumerate_children (file, ...);
	//    while (TRUE)
	//      {
	//        GFileInfo *info;
	//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
	//          goto out;
	//        if (!info)
	//          break;
	//        ... do stuff with "info"; do not unref it! ...
	//      }
	//
	//    out:
	//      g_object_unref (direnum); // Note: frees the last @info
	//
	Iterate(cancellable Cancellable) (outInfo FileInfo, outChild File, ok bool)
	// NextFile returns information for the next file in the enumerated object.
	// Will block until the information is available. The Info returned from
	// this function will contain attributes that match the attribute string
	// that was passed when the Enumerator was created.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// On error, returns nil and sets @error to the error. If the enumerator is
	// at the end, nil will be returned and @error will be unset.
	NextFile(cancellable Cancellable) FileInfo
	// NextFilesAsync: request information for a number of files from the
	// enumerator asynchronously. When all i/o for the operation is finished the
	// @callback will be called with the requested information.
	//
	// See the documentation of Enumerator for information about the order of
	// returned files.
	//
	// The callback can be called with less than @num_files files in case of
	// error or at the end of the enumerator. In case of a partial error the
	// callback will be called with any succeeding items and no error, and on
	// the next request the error will be reported. If a request is cancelled
	// the callback will be called with G_IO_ERROR_CANCELLED.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	NextFilesAsync(numFiles int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetPending sets the file enumerator as having pending operations.
	SetPending(pending bool)
}

// fileEnumerator implements the FileEnumerator interface.
type fileEnumerator struct {
	gextras.Objector
}

// WrapFileEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileEnumerator(obj *externglib.Object) FileEnumerator {
	return FileEnumerator{
		gextras.Objector: (obj),
	}
}

func marshalFileEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileEnumerator(obj), nil
}

// Close releases all resources used by this enumerator, making the
// enumerator return G_IO_ERROR_CLOSED on all calls.
//
// This will be automatically called when the last reference is dropped, but
// you might want to call this function to make sure resources are released
// as early as possible.
func (enumerator fileEnumerator) Close(cancellable Cancellable) bool {
	var arg0 *C.GFileEnumerator
	var arg1 *C.GCancellable

	arg0 = (*C.GFileEnumerator)(enumerator.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_enumerator_close(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CloseAsync: asynchronously closes the file enumerator.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
func (enumerator fileEnumerator) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFileEnumerator
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GFileEnumerator)(enumerator.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_file_enumerator_close_async(arg0, arg1, arg2, arg3)
}

// HasPending checks if the file enumerator has pending operations.
func (enumerator fileEnumerator) HasPending() bool {
	var arg0 *C.GFileEnumerator

	arg0 = (*C.GFileEnumerator)(enumerator.Native())

	ret := C.g_file_enumerator_has_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsClosed checks if the file enumerator has been closed.
func (enumerator fileEnumerator) IsClosed() bool {
	var arg0 *C.GFileEnumerator

	arg0 = (*C.GFileEnumerator)(enumerator.Native())

	ret := C.g_file_enumerator_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Iterate: this is a version of g_file_enumerator_next_file() that's easier
// to use correctly from C programs. With g_file_enumerator_next_file(), the
// gboolean return value signifies "end of iteration or error", which
// requires allocation of a temporary #GError.
//
// In contrast, with this function, a false return from
// g_file_enumerator_iterate() *always* means "error". End of iteration is
// signaled by @out_info or @out_child being nil.
//
// Another crucial difference is that the references for @out_info and
// @out_child are owned by @direnum (they are cached as hidden properties).
// You must not unref them in your own code. This makes memory management
// significantly easier for C code in combination with loops.
//
// Finally, this function optionally allows retrieving a #GFile as well.
//
// You must specify at least one of @out_info or @out_child.
//
// The code pattern for correctly using g_file_enumerator_iterate() from C
// is:
//
//
//    direnum = g_file_enumerate_children (file, ...);
//    while (TRUE)
//      {
//        GFileInfo *info;
//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
//          goto out;
//        if (!info)
//          break;
//        ... do stuff with "info"; do not unref it! ...
//      }
//
//    out:
//      g_object_unref (direnum); // Note: frees the last @info
//
func (direnum fileEnumerator) Iterate(cancellable Cancellable) (outInfo FileInfo, outChild File, ok bool) {
	var arg0 *C.GFileEnumerator
	var arg1 **C.GFileInfo // out
	var arg2 **C.GFile     // out
	var arg3 *C.GCancellable

	arg0 = (*C.GFileEnumerator)(direnum.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_enumerator_iterate(arg0, &arg1, &arg2, arg3)

	var ret0 FileInfo
	var ret1 *File
	var ret2 bool

	ret0 = WrapFileInfo(externglib.Take(unsafe.Pointer(arg1.Native())))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// NextFile returns information for the next file in the enumerated object.
// Will block until the information is available. The Info returned from
// this function will contain attributes that match the attribute string
// that was passed when the Enumerator was created.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// On error, returns nil and sets @error to the error. If the enumerator is
// at the end, nil will be returned and @error will be unset.
func (enumerator fileEnumerator) NextFile(cancellable Cancellable) FileInfo {
	var arg0 *C.GFileEnumerator
	var arg1 *C.GCancellable

	arg0 = (*C.GFileEnumerator)(enumerator.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_enumerator_next_file(arg0, arg1)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NextFilesAsync: request information for a number of files from the
// enumerator asynchronously. When all i/o for the operation is finished the
// @callback will be called with the requested information.
//
// See the documentation of Enumerator for information about the order of
// returned files.
//
// The callback can be called with less than @num_files files in case of
// error or at the end of the enumerator. In case of a partial error the
// callback will be called with any succeeding items and no error, and on
// the next request the error will be reported. If a request is cancelled
// the callback will be called with G_IO_ERROR_CANCELLED.
//
// During an async request no other sync and async calls are allowed, and
// will result in G_IO_ERROR_PENDING errors.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is G_PRIORITY_DEFAULT.
func (enumerator fileEnumerator) NextFilesAsync(numFiles int, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFileEnumerator
	var arg1 C.int
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GFileEnumerator)(enumerator.Native())
	arg1 = C.int(numFiles)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_file_enumerator_next_files_async(arg0, arg1, arg2, arg3, arg4)
}

// SetPending sets the file enumerator as having pending operations.
func (enumerator fileEnumerator) SetPending(pending bool) {
	var arg0 *C.GFileEnumerator
	var arg1 C.gboolean

	arg0 = (*C.GFileEnumerator)(enumerator.Native())
	arg1 = gextras.Cbool(pending)

	C.g_file_enumerator_set_pending(arg0, arg1)
}

// FileIOStream: GFileIOStream provides io streams that both read and write to
// the same file handle.
//
// GFileIOStream implements #GSeekable, which allows the io stream to jump to
// arbitrary positions in the file and to truncate the file, provided the
// filesystem of the file supports these operations.
//
// To find the position of a file io stream, use g_seekable_tell().
//
// To find out if a file io stream supports seeking, use g_seekable_can_seek().
// To position a file io stream, use g_seekable_seek(). To find out if a file io
// stream supports truncating, use g_seekable_can_truncate(). To truncate a file
// io stream, use g_seekable_truncate().
//
// The default implementation of all the IOStream operations and the
// implementation of #GSeekable just call into the same operations on the output
// stream.
type FileIOStream interface {
	IOStream

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file io stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_io_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync: asynchronously queries the @stream for a Info. When
	// completed, @callback will be called with a Result which can be used to
	// finish the operation with g_file_io_stream_query_info_finish().
	//
	// For the synchronous version of this function, see
	// g_file_io_stream_query_info().
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// fileIOStream implements the FileIOStream interface.
type fileIOStream struct {
	IOStream
}

// WrapFileIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIOStream(obj *externglib.Object) FileIOStream {
	return FileIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalFileIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIOStream(obj), nil
}

// Etag gets the entity tag for the file when it has been written. This must
// be called after the stream has been written and closed, as the etag can
// change while writing.
func (stream fileIOStream) Etag() string {
	var arg0 *C.GFileIOStream

	arg0 = (*C.GFileIOStream)(stream.Native())

	ret := C.g_file_io_stream_get_etag(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// QueryInfo queries a file io stream for the given @attributes. This
// function blocks while querying the stream. For the asynchronous version
// of this function, see g_file_io_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and
// any other operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with @error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED). I
// all cases of failure, nil will be returned.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
// be returned.
func (stream fileIOStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo {
	var arg0 *C.GFileIOStream
	var arg1 *C.char
	var arg2 *C.GCancellable

	arg0 = (*C.GFileIOStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_io_stream_query_info(arg0, arg1, arg2)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// QueryInfoAsync: asynchronously queries the @stream for a Info. When
// completed, @callback will be called with a Result which can be used to
// finish the operation with g_file_io_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_io_stream_query_info().
func (stream fileIOStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFileIOStream
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GFileIOStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_file_io_stream_query_info_async(arg0, arg1, arg2, arg3, arg4)
}

// FileIcon specifies an icon by pointing to an image file to be used as icon.
type FileIcon interface {
	gextras.Objector
}

// fileIcon implements the FileIcon interface.
type fileIcon struct {
	gextras.Objector
}

// WrapFileIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileIcon(obj *externglib.Object) FileIcon {
	return FileIcon{
		gextras.Objector: (obj),
	}
}

func marshalFileIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileIcon(obj), nil
}

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo interface {
	gextras.Objector

	// ClearStatus clears the status information from @info.
	ClearStatus()
	// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
	// @dest_info, and then copies all of the file attributes from @src_info to
	// @dest_info.
	CopyInto(destInfo FileInfo)
	// Dup duplicates a file info structure.
	Dup() FileInfo
	// AttributeAsString gets the value of a attribute, formatted as a string.
	// This escapes things as needed to make the string valid UTF-8.
	AttributeAsString(attribute string) string
	// AttributeBoolean gets the value of a boolean attribute. If the attribute
	// does not contain a boolean value, false will be returned.
	AttributeBoolean(attribute string) bool
	// AttributeByteString gets the value of a byte string attribute. If the
	// attribute does not contain a byte string, nil will be returned.
	AttributeByteString(attribute string) string
	// AttributeData gets the attribute type, value and status for an attribute
	// key.
	AttributeData(attribute string) (_type FileAttributeType, valuePp interface{}, status FileAttributeStatus, ok bool)
	// AttributeInt32 gets a signed 32-bit integer contained within the
	// attribute. If the attribute does not contain a signed 32-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt32(attribute string) int32
	// AttributeInt64 gets a signed 64-bit integer contained within the
	// attribute. If the attribute does not contain a signed 64-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt64(attribute string) int64
	// AttributeObject gets the value of a #GObject attribute. If the attribute
	// does not contain a #GObject, nil will be returned.
	AttributeObject(attribute string) gextras.Objector
	// AttributeStatus gets the attribute status for an attribute key.
	AttributeStatus(attribute string) FileAttributeStatus
	// AttributeString gets the value of a string attribute. If the attribute
	// does not contain a string, nil will be returned.
	AttributeString(attribute string) string
	// AttributeStringv gets the value of a stringv attribute. If the attribute
	// does not contain a stringv, nil will be returned.
	AttributeStringv(attribute string) []string
	// AttributeType gets the attribute type for an attribute key.
	AttributeType(attribute string) FileAttributeType
	// AttributeUint32 gets an unsigned 32-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 32-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint32(attribute string) uint32
	// AttributeUint64 gets a unsigned 64-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 64-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint64(attribute string) uint64
	// ContentType gets the file's content type.
	ContentType() string
	// DeletionDate returns the Time representing the deletion date of the file,
	// as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
	// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, nil is returned.
	DeletionDate() *glib.DateTime
	// DisplayName gets a display name for a file. This is guaranteed to always
	// be set.
	DisplayName() string
	// EditName gets the edit name for a file.
	EditName() string
	// Etag gets the [entity tag][gfile-etag] for a given Info. See
	// G_FILE_ATTRIBUTE_ETAG_VALUE.
	Etag() string
	// FileType gets a file's type (whether it is a regular file, symlink, etc).
	// This is different from the file's content type, see
	// g_file_info_get_content_type().
	FileType() FileType
	// IsBackup checks if a file is a backup file.
	IsBackup() bool
	// IsHidden checks if a file is hidden.
	IsHidden() bool
	// IsSymlink checks if a file is a symlink.
	IsSymlink() bool
	// ModificationDateTime gets the modification time of the current @info and
	// returns it as a Time.
	//
	// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will
	// have microsecond precision.
	ModificationDateTime() *glib.DateTime
	// ModificationTime gets the modification time of the current @info and sets
	// it in @result.
	ModificationTime() glib.TimeVal
	// Name gets the name for a file. This is guaranteed to always be set.
	Name() string
	// Size gets the file's size.
	Size() int64
	// SortOrder gets the value of the sort_order attribute from the Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SortOrder() int32
	// SymlinkTarget gets the symlink target for a given Info.
	SymlinkTarget() string
	// HasAttribute checks if a file info structure has an attribute named
	// @attribute.
	HasAttribute(attribute string) bool
	// HasNamespace checks if a file info structure has an attribute in the
	// specified @name_space.
	HasNamespace(nameSpace string) bool
	// ListAttributes lists the file info structure's attributes.
	ListAttributes(nameSpace string) []string
	// RemoveAttribute removes all cases of @attribute from @info if it exists.
	RemoveAttribute(attribute string)
	// SetAttribute sets the @attribute to contain the given value, if possible.
	// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for @type.
	SetAttribute(attribute string, _type FileAttributeType, valueP interface{})
	// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeBoolean(attribute string, attrValue bool)
	// SetAttributeByteString sets the @attribute to contain the given
	// @attr_value, if possible.
	SetAttributeByteString(attribute string, attrValue string)
	// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt32(attribute string, attrValue int32)
	// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt64(attribute string, attrValue int64)
	// SetAttributeMask sets @mask on @info to match specific attribute types.
	SetAttributeMask(mask *FileAttributeMatcher)
	// SetAttributeObject sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeObject(attribute string, attrValue gextras.Objector)
	// SetAttributeStatus sets the attribute status for an attribute key. This
	// is only needed by external code that implement
	// g_file_set_attributes_from_info() or similar functions.
	//
	// The attribute must exist in @info for this to work. Otherwise false is
	// returned and @info is unchanged.
	SetAttributeStatus(attribute string, status FileAttributeStatus) bool
	// SetAttributeString sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeString(attribute string, attrValue string)
	// SetAttributeStringv sets the @attribute to contain the given @attr_value,
	// if possible.
	//
	// Sinze: 2.22
	SetAttributeStringv(attribute string, attrValue []string)
	// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint32(attribute string, attrValue uint32)
	// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint64(attribute string, attrValue uint64)
	// SetContentType sets the content type attribute for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	SetContentType(contentType string)
	// SetDisplayName sets the display name for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	SetDisplayName(displayName string)
	// SetEditName sets the edit name for the current file. See
	// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	SetEditName(editName string)
	// SetFileType sets the file type in a Info to @type. See
	// G_FILE_ATTRIBUTE_STANDARD_TYPE.
	SetFileType(_type FileType)
	// SetIsHidden sets the "is_hidden" attribute in a Info according to
	// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	SetIsHidden(isHidden bool)
	// SetIsSymlink sets the "is_symlink" attribute in a Info according to
	// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	SetIsSymlink(isSymlink bool)
	// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given date/time value.
	SetModificationDateTime(mtime *glib.DateTime)
	// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given time value.
	SetModificationTime(mtime *glib.TimeVal)
	// SetName sets the name attribute for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_NAME.
	SetName(name string)
	// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
	// info to the given size.
	SetSize(size int64)
	// SetSortOrder sets the sort order attribute in the file info structure.
	// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SetSortOrder(sortOrder int32)
	// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
	// attribute in the file info to the given symlink target.
	SetSymlinkTarget(symlinkTarget string)
	// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
	// if one is set.
	UnsetAttributeMask()
}

// fileInfo implements the FileInfo interface.
type fileInfo struct {
	gextras.Objector
}

// WrapFileInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInfo(obj *externglib.Object) FileInfo {
	return FileInfo{
		gextras.Objector: (obj),
	}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInfo(obj), nil
}

// NewFileInfo constructs a class FileInfo.
func NewFileInfo() FileInfo {

	ret := C.g_file_info_new()

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ClearStatus clears the status information from @info.
func (info fileInfo) ClearStatus() {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	C.g_file_info_clear_status(arg0)
}

// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
// @dest_info, and then copies all of the file attributes from @src_info to
// @dest_info.
func (srcInfo fileInfo) CopyInto(destInfo FileInfo) {
	var arg0 *C.GFileInfo
	var arg1 *C.GFileInfo

	arg0 = (*C.GFileInfo)(srcInfo.Native())
	arg1 = (*C.GFileInfo)(destInfo.Native())

	C.g_file_info_copy_into(arg0, arg1)
}

// Dup duplicates a file info structure.
func (other fileInfo) Dup() FileInfo {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(other.Native())

	ret := C.g_file_info_dup(arg0)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AttributeAsString gets the value of a attribute, formatted as a string.
// This escapes things as needed to make the string valid UTF-8.
func (info fileInfo) AttributeAsString(attribute string) string {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_as_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// AttributeBoolean gets the value of a boolean attribute. If the attribute
// does not contain a boolean value, false will be returned.
func (info fileInfo) AttributeBoolean(attribute string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_boolean(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AttributeByteString gets the value of a byte string attribute. If the
// attribute does not contain a byte string, nil will be returned.
func (info fileInfo) AttributeByteString(attribute string) string {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_byte_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// AttributeData gets the attribute type, value and status for an attribute
// key.
func (info fileInfo) AttributeData(attribute string) (_type FileAttributeType, valuePp interface{}, status FileAttributeStatus, ok bool) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.GFileAttributeType   // out
	var arg3 *C.gpointer             // out
	var arg4 *C.GFileAttributeStatus // out

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_data(arg0, arg1, &arg2, &arg3, &arg4)

	var ret0 *FileAttributeType
	var ret1 interface{}
	var ret2 *FileAttributeStatus
	var ret3 bool

	ret0 = (*FileAttributeType)(arg2)

	ret1 = box.Get(uintptr(arg3)).(interface{})

	ret2 = (*FileAttributeStatus)(arg4)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// AttributeInt32 gets a signed 32-bit integer contained within the
// attribute. If the attribute does not contain a signed 32-bit integer, or
// is invalid, 0 will be returned.
func (info fileInfo) AttributeInt32(attribute string) int32 {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_int32(arg0, arg1)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// AttributeInt64 gets a signed 64-bit integer contained within the
// attribute. If the attribute does not contain a signed 64-bit integer, or
// is invalid, 0 will be returned.
func (info fileInfo) AttributeInt64(attribute string) int64 {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_int64(arg0, arg1)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// AttributeObject gets the value of a #GObject attribute. If the attribute
// does not contain a #GObject, nil will be returned.
func (info fileInfo) AttributeObject(attribute string) gextras.Objector {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_object(arg0, arg1)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// AttributeStatus gets the attribute status for an attribute key.
func (info fileInfo) AttributeStatus(attribute string) FileAttributeStatus {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_status(arg0, arg1)

	var ret0 FileAttributeStatus

	ret0 = FileAttributeStatus(ret)

	return ret0
}

// AttributeString gets the value of a string attribute. If the attribute
// does not contain a string, nil will be returned.
func (info fileInfo) AttributeString(attribute string) string {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// AttributeStringv gets the value of a stringv attribute. If the attribute
// does not contain a stringv, nil will be returned.
func (info fileInfo) AttributeStringv(attribute string) []string {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_stringv(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// AttributeType gets the attribute type for an attribute key.
func (info fileInfo) AttributeType(attribute string) FileAttributeType {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_type(arg0, arg1)

	var ret0 FileAttributeType

	ret0 = FileAttributeType(ret)

	return ret0
}

// AttributeUint32 gets an unsigned 32-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 32-bit integer,
// or is invalid, 0 will be returned.
func (info fileInfo) AttributeUint32(attribute string) uint32 {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_uint32(arg0, arg1)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// AttributeUint64 gets a unsigned 64-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 64-bit integer,
// or is invalid, 0 will be returned.
func (info fileInfo) AttributeUint64(attribute string) uint64 {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_get_attribute_uint64(arg0, arg1)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// ContentType gets the file's content type.
func (info fileInfo) ContentType() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_content_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DeletionDate returns the Time representing the deletion date of the file,
// as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, nil is returned.
func (info fileInfo) DeletionDate() *glib.DateTime {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_deletion_date(arg0)

	var ret0 *glib.DateTime

	ret0 = glib.WrapDateTime(ret)

	return ret0
}

// DisplayName gets a display name for a file. This is guaranteed to always
// be set.
func (info fileInfo) DisplayName() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_display_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// EditName gets the edit name for a file.
func (info fileInfo) EditName() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_edit_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Etag gets the [entity tag][gfile-etag] for a given Info. See
// G_FILE_ATTRIBUTE_ETAG_VALUE.
func (info fileInfo) Etag() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_etag(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// FileType gets a file's type (whether it is a regular file, symlink, etc).
// This is different from the file's content type, see
// g_file_info_get_content_type().
func (info fileInfo) FileType() FileType {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_file_type(arg0)

	var ret0 FileType

	ret0 = FileType(ret)

	return ret0
}

// IsBackup checks if a file is a backup file.
func (info fileInfo) IsBackup() bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_is_backup(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsHidden checks if a file is hidden.
func (info fileInfo) IsHidden() bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_is_hidden(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSymlink checks if a file is a symlink.
func (info fileInfo) IsSymlink() bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_is_symlink(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ModificationDateTime gets the modification time of the current @info and
// returns it as a Time.
//
// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will
// have microsecond precision.
func (info fileInfo) ModificationDateTime() *glib.DateTime {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_modification_date_time(arg0)

	var ret0 *glib.DateTime

	ret0 = glib.WrapDateTime(ret)

	return ret0
}

// ModificationTime gets the modification time of the current @info and sets
// it in @result.
func (info fileInfo) ModificationTime() glib.TimeVal {
	var arg0 *C.GFileInfo
	var arg1 *C.GTimeVal // out

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_modification_time(arg0, &arg1)

	var ret0 *glib.TimeVal

	ret0 = glib.WrapTimeVal(arg1)

	return ret0
}

// Name gets the name for a file. This is guaranteed to always be set.
func (info fileInfo) Name() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Size gets the file's size.
func (info fileInfo) Size() int64 {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_size(arg0)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// SortOrder gets the value of the sort_order attribute from the Info. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (info fileInfo) SortOrder() int32 {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_sort_order(arg0)

	var ret0 int32

	ret0 = int32(ret)

	return ret0
}

// SymlinkTarget gets the symlink target for a given Info.
func (info fileInfo) SymlinkTarget() string {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	ret := C.g_file_info_get_symlink_target(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// HasAttribute checks if a file info structure has an attribute named
// @attribute.
func (info fileInfo) HasAttribute(attribute string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_has_attribute(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HasNamespace checks if a file info structure has an attribute in the
// specified @name_space.
func (info fileInfo) HasNamespace(nameSpace string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_has_namespace(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListAttributes lists the file info structure's attributes.
func (info fileInfo) ListAttributes(nameSpace string) []string {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_info_list_attributes(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// RemoveAttribute removes all cases of @attribute from @info if it exists.
func (info fileInfo) RemoveAttribute(attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_remove_attribute(arg0, arg1)
}

// SetAttribute sets the @attribute to contain the given value, if possible.
// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for @type.
func (info fileInfo) SetAttribute(attribute string, _type FileAttributeType, valueP interface{}) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.GFileAttributeType
	var arg3 C.gpointer

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeType)(_type)
	arg3 = C.gpointer(box.Assign(valueP))

	C.g_file_info_set_attribute(arg0, arg1, arg2, arg3)
}

// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeBoolean(attribute string, attrValue bool) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(attrValue)

	C.g_file_info_set_attribute_boolean(arg0, arg1, arg2)
}

// SetAttributeByteString sets the @attribute to contain the given
// @attr_value, if possible.
func (info fileInfo) SetAttributeByteString(attribute string, attrValue string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(arg2))

	C.g_file_info_set_attribute_byte_string(arg0, arg1, arg2)
}

// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeInt32(attribute string, attrValue int32) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gint32

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(arg0, arg1, arg2)
}

// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeInt64(attribute string, attrValue int64) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gint64

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(arg0, arg1, arg2)
}

// SetAttributeMask sets @mask on @info to match specific attribute types.
func (info fileInfo) SetAttributeMask(mask *FileAttributeMatcher) {
	var arg0 *C.GFileInfo
	var arg1 *C.GFileAttributeMatcher

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.GFileAttributeMatcher)(mask.Native())

	C.g_file_info_set_attribute_mask(arg0, arg1)
}

// SetAttributeObject sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeObject(attribute string, attrValue gextras.Objector) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.GObject

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(attrValue.Native())

	C.g_file_info_set_attribute_object(arg0, arg1, arg2)
}

// SetAttributeStatus sets the attribute status for an attribute key. This
// is only needed by external code that implement
// g_file_set_attributes_from_info() or similar functions.
//
// The attribute must exist in @info for this to work. Otherwise false is
// returned and @info is unchanged.
func (info fileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.GFileAttributeStatus

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeStatus)(status)

	ret := C.g_file_info_set_attribute_status(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetAttributeString sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeString(attribute string, attrValue string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(arg2))

	C.g_file_info_set_attribute_string(arg0, arg1, arg2)
}

// SetAttributeStringv sets the @attribute to contain the given @attr_value,
// if possible.
//
// Sinze: 2.22
func (info fileInfo) SetAttributeStringv(attribute string, attrValue []string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	C.g_file_info_set_attribute_stringv(arg0, arg1, arg2)
}

// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeUint32(attribute string, attrValue uint32) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.guint32

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(arg0, arg1, arg2)
}

// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
// if possible.
func (info fileInfo) SetAttributeUint64(attribute string, attrValue uint64) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.guint64

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(arg0, arg1, arg2)
}

// SetContentType sets the content type attribute for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
func (info fileInfo) SetContentType(contentType string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_content_type(arg0, arg1)
}

// SetDisplayName sets the display name for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
func (info fileInfo) SetDisplayName(displayName string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_display_name(arg0, arg1)
}

// SetEditName sets the edit name for the current file. See
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
func (info fileInfo) SetEditName(editName string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(editName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_edit_name(arg0, arg1)
}

// SetFileType sets the file type in a Info to @type. See
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
func (info fileInfo) SetFileType(_type FileType) {
	var arg0 *C.GFileInfo
	var arg1 C.GFileType

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (C.GFileType)(_type)

	C.g_file_info_set_file_type(arg0, arg1)
}

// SetIsHidden sets the "is_hidden" attribute in a Info according to
// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
func (info fileInfo) SetIsHidden(isHidden bool) {
	var arg0 *C.GFileInfo
	var arg1 C.gboolean

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = gextras.Cbool(isHidden)

	C.g_file_info_set_is_hidden(arg0, arg1)
}

// SetIsSymlink sets the "is_symlink" attribute in a Info according to
// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
func (info fileInfo) SetIsSymlink(isSymlink bool) {
	var arg0 *C.GFileInfo
	var arg1 C.gboolean

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = gextras.Cbool(isSymlink)

	C.g_file_info_set_is_symlink(arg0, arg1)
}

// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
// given date/time value.
func (info fileInfo) SetModificationDateTime(mtime *glib.DateTime) {
	var arg0 *C.GFileInfo
	var arg1 *C.GDateTime

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.GDateTime)(mtime.Native())

	C.g_file_info_set_modification_date_time(arg0, arg1)
}

// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
// given time value.
func (info fileInfo) SetModificationTime(mtime *glib.TimeVal) {
	var arg0 *C.GFileInfo
	var arg1 *C.GTimeVal

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.GTimeVal)(mtime.Native())

	C.g_file_info_set_modification_time(arg0, arg1)
}

// SetName sets the name attribute for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_NAME.
func (info fileInfo) SetName(name string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_name(arg0, arg1)
}

// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
// info to the given size.
func (info fileInfo) SetSize(size int64) {
	var arg0 *C.GFileInfo
	var arg1 C.goffset

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = C.goffset(size)

	C.g_file_info_set_size(arg0, arg1)
}

// SetSortOrder sets the sort order attribute in the file info structure.
// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (info fileInfo) SetSortOrder(sortOrder int32) {
	var arg0 *C.GFileInfo
	var arg1 C.gint32

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(arg0, arg1)
}

// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
// attribute in the file info to the given symlink target.
func (info fileInfo) SetSymlinkTarget(symlinkTarget string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(info.Native())
	arg1 = (*C.gchar)(C.CString(symlinkTarget))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_symlink_target(arg0, arg1)
}

// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
// if one is set.
func (info fileInfo) UnsetAttributeMask() {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(info.Native())

	C.g_file_info_unset_attribute_mask(arg0)
}

// FileInputStream: GFileInputStream provides input streams that take their
// content from a file.
//
// GFileInputStream implements #GSeekable, which allows the input stream to jump
// to arbitrary positions in the file, provided the filesystem of the file
// allows it. To find the position of a file input stream, use
// g_seekable_tell(). To find out if a file input stream supports seeking, use
// g_seekable_can_seek(). To position a file input stream, use
// g_seekable_seek().
type FileInputStream interface {
	InputStream

	// QueryInfo queries a file input stream the given @attributes. This
	// function blocks while querying the stream. For the asynchronous
	// (non-blocking) version of this function, see
	// g_file_input_stream_query_info_async(). While the stream is blocked, the
	// stream will set the pending flag internally, and any other operations on
	// the stream will fail with G_IO_ERROR_PENDING.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync queries the stream information asynchronously. When the
	// operation is finished @callback will be called. You can then call
	// g_file_input_stream_query_info_finish() to get the result of the
	// operation.
	//
	// For the synchronous version of this function, see
	// g_file_input_stream_query_info().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// fileInputStream implements the FileInputStream interface.
type fileInputStream struct {
	InputStream
}

// WrapFileInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInputStream(obj *externglib.Object) FileInputStream {
	return FileInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalFileInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInputStream(obj), nil
}

// QueryInfo queries a file input stream the given @attributes. This
// function blocks while querying the stream. For the asynchronous
// (non-blocking) version of this function, see
// g_file_input_stream_query_info_async(). While the stream is blocked, the
// stream will set the pending flag internally, and any other operations on
// the stream will fail with G_IO_ERROR_PENDING.
func (stream fileInputStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo {
	var arg0 *C.GFileInputStream
	var arg1 *C.char
	var arg2 *C.GCancellable

	arg0 = (*C.GFileInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_input_stream_query_info(arg0, arg1, arg2)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// QueryInfoAsync queries the stream information asynchronously. When the
// operation is finished @callback will be called. You can then call
// g_file_input_stream_query_info_finish() to get the result of the
// operation.
//
// For the synchronous version of this function, see
// g_file_input_stream_query_info().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be set
func (stream fileInputStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFileInputStream
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GFileInputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_file_input_stream_query_info_async(arg0, arg1, arg2, arg3, arg4)
}

// FileMonitor monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor interface {
	gextras.Objector

	// Cancel cancels a file monitor.
	Cancel() bool
	// IsCancelled returns whether the monitor is canceled.
	IsCancelled() bool
	// SetRateLimit sets the rate limit to which the @monitor will report
	// consecutive change events to the same file.
	SetRateLimit(limitMsecs int)
}

// fileMonitor implements the FileMonitor interface.
type fileMonitor struct {
	gextras.Objector
}

// WrapFileMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileMonitor(obj *externglib.Object) FileMonitor {
	return FileMonitor{
		gextras.Objector: (obj),
	}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileMonitor(obj), nil
}

// Cancel cancels a file monitor.
func (monitor fileMonitor) Cancel() bool {
	var arg0 *C.GFileMonitor

	arg0 = (*C.GFileMonitor)(monitor.Native())

	ret := C.g_file_monitor_cancel(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsCancelled returns whether the monitor is canceled.
func (monitor fileMonitor) IsCancelled() bool {
	var arg0 *C.GFileMonitor

	arg0 = (*C.GFileMonitor)(monitor.Native())

	ret := C.g_file_monitor_is_cancelled(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetRateLimit sets the rate limit to which the @monitor will report
// consecutive change events to the same file.
func (monitor fileMonitor) SetRateLimit(limitMsecs int) {
	var arg0 *C.GFileMonitor
	var arg1 C.gint

	arg0 = (*C.GFileMonitor)(monitor.Native())
	arg1 = C.gint(limitMsecs)

	C.g_file_monitor_set_rate_limit(arg0, arg1)
}

// FileOutputStream: GFileOutputStream provides output streams that write their
// content to a file.
//
// GFileOutputStream implements #GSeekable, which allows the output stream to
// jump to arbitrary positions in the file and to truncate the file, provided
// the filesystem of the file supports these operations.
//
// To find the position of a file output stream, use g_seekable_tell(). To find
// out if a file output stream supports seeking, use g_seekable_can_seek().To
// position a file output stream, use g_seekable_seek(). To find out if a file
// output stream supports truncating, use g_seekable_can_truncate(). To truncate
// a file output stream, use g_seekable_truncate().
type FileOutputStream interface {
	OutputStream

	// Etag gets the entity tag for the file when it has been written. This must
	// be called after the stream has been written and closed, as the etag can
	// change while writing.
	Etag() string
	// QueryInfo queries a file output stream for the given @attributes. This
	// function blocks while querying the stream. For the asynchronous version
	// of this function, see g_file_output_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with G_IO_ERROR_PENDING.
	//
	// Can fail if the stream was already closed (with @error being set to
	// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
	// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED).
	// In all cases of failure, nil will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
	// be returned.
	QueryInfo(attributes string, cancellable Cancellable) FileInfo
	// QueryInfoAsync: asynchronously queries the @stream for a Info. When
	// completed, @callback will be called with a Result which can be used to
	// finish the operation with g_file_output_stream_query_info_finish().
	//
	// For the synchronous version of this function, see
	// g_file_output_stream_query_info().
	QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// fileOutputStream implements the FileOutputStream interface.
type fileOutputStream struct {
	OutputStream
}

// WrapFileOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileOutputStream(obj *externglib.Object) FileOutputStream {
	return FileOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalFileOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileOutputStream(obj), nil
}

// Etag gets the entity tag for the file when it has been written. This must
// be called after the stream has been written and closed, as the etag can
// change while writing.
func (stream fileOutputStream) Etag() string {
	var arg0 *C.GFileOutputStream

	arg0 = (*C.GFileOutputStream)(stream.Native())

	ret := C.g_file_output_stream_get_etag(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// QueryInfo queries a file output stream for the given @attributes. This
// function blocks while querying the stream. For the asynchronous version
// of this function, see g_file_output_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and
// any other operations on the stream will fail with G_IO_ERROR_PENDING.
//
// Can fail if the stream was already closed (with @error being set to
// G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to G_IO_ERROR_PENDING), or if querying info is not supported for the
// stream's interface (with @error being set to G_IO_ERROR_NOT_SUPPORTED).
// In all cases of failure, nil will be returned.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be set, and nil will
// be returned.
func (stream fileOutputStream) QueryInfo(attributes string, cancellable Cancellable) FileInfo {
	var arg0 *C.GFileOutputStream
	var arg1 *C.char
	var arg2 *C.GCancellable

	arg0 = (*C.GFileOutputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_output_stream_query_info(arg0, arg1, arg2)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// QueryInfoAsync: asynchronously queries the @stream for a Info. When
// completed, @callback will be called with a Result which can be used to
// finish the operation with g_file_output_stream_query_info_finish().
//
// For the synchronous version of this function, see
// g_file_output_stream_query_info().
func (stream fileOutputStream) QueryInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFileOutputStream
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GFileOutputStream)(stream.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_file_output_stream_query_info_async(arg0, arg1, arg2, arg3, arg4)
}

// FilenameCompleter completes partial file and directory names given a partial
// string by looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter interface {
	gextras.Objector

	// CompletionSuffix obtains a completion for @initial_text from @completer.
	CompletionSuffix(initialText string) string
	// Completions gets an array of completion strings for a given initial text.
	Completions(initialText string) []string
	// SetDirsOnly: if @dirs_only is true, @completer will only complete
	// directory names, and not file names.
	SetDirsOnly(dirsOnly bool)
}

// filenameCompleter implements the FilenameCompleter interface.
type filenameCompleter struct {
	gextras.Objector
}

// WrapFilenameCompleter wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilenameCompleter(obj *externglib.Object) FilenameCompleter {
	return FilenameCompleter{
		gextras.Objector: (obj),
	}
}

func marshalFilenameCompleter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilenameCompleter(obj), nil
}

// NewFilenameCompleter constructs a class FilenameCompleter.
func NewFilenameCompleter() FilenameCompleter {

	ret := C.g_filename_completer_new()

	var ret0 FilenameCompleter

	ret0 = WrapFilenameCompleter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CompletionSuffix obtains a completion for @initial_text from @completer.
func (completer filenameCompleter) CompletionSuffix(initialText string) string {
	var arg0 *C.GFilenameCompleter
	var arg1 *C.char

	arg0 = (*C.GFilenameCompleter)(completer.Native())
	arg1 = (*C.gchar)(C.CString(initialText))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_completer_get_completion_suffix(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Completions gets an array of completion strings for a given initial text.
func (completer filenameCompleter) Completions(initialText string) []string {
	var arg0 *C.GFilenameCompleter
	var arg1 *C.char

	arg0 = (*C.GFilenameCompleter)(completer.Native())
	arg1 = (*C.gchar)(C.CString(initialText))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_filename_completer_get_completions(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// SetDirsOnly: if @dirs_only is true, @completer will only complete
// directory names, and not file names.
func (completer filenameCompleter) SetDirsOnly(dirsOnly bool) {
	var arg0 *C.GFilenameCompleter
	var arg1 C.gboolean

	arg0 = (*C.GFilenameCompleter)(completer.Native())
	arg1 = gextras.Cbool(dirsOnly)

	C.g_filename_completer_set_dirs_only(arg0, arg1)
}

// FilterInputStream: base class for input stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterInputStream interface {
	InputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() InputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

// filterInputStream implements the FilterInputStream interface.
type filterInputStream struct {
	InputStream
}

// WrapFilterInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterInputStream(obj *externglib.Object) FilterInputStream {
	return FilterInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalFilterInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterInputStream(obj), nil
}

// BaseStream gets the base stream for the filter stream.
func (stream filterInputStream) BaseStream() InputStream {
	var arg0 *C.GFilterInputStream

	arg0 = (*C.GFilterInputStream)(stream.Native())

	ret := C.g_filter_input_stream_get_base_stream(arg0)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CloseBaseStream returns whether the base stream will be closed when
// @stream is closed.
func (stream filterInputStream) CloseBaseStream() bool {
	var arg0 *C.GFilterInputStream

	arg0 = (*C.GFilterInputStream)(stream.Native())

	ret := C.g_filter_input_stream_get_close_base_stream(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetCloseBaseStream sets whether the base stream will be closed when
// @stream is closed.
func (stream filterInputStream) SetCloseBaseStream(closeBase bool) {
	var arg0 *C.GFilterInputStream
	var arg1 C.gboolean

	arg0 = (*C.GFilterInputStream)(stream.Native())
	arg1 = gextras.Cbool(closeBase)

	C.g_filter_input_stream_set_close_base_stream(arg0, arg1)
}

// FilterOutputStream: base class for output stream implementations that perform
// some kind of filtering operation on a base stream. Typical examples of
// filtering operations are character set conversion, compression and byte order
// flipping.
type FilterOutputStream interface {
	OutputStream

	// BaseStream gets the base stream for the filter stream.
	BaseStream() OutputStream
	// CloseBaseStream returns whether the base stream will be closed when
	// @stream is closed.
	CloseBaseStream() bool
	// SetCloseBaseStream sets whether the base stream will be closed when
	// @stream is closed.
	SetCloseBaseStream(closeBase bool)
}

// filterOutputStream implements the FilterOutputStream interface.
type filterOutputStream struct {
	OutputStream
}

// WrapFilterOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapFilterOutputStream(obj *externglib.Object) FilterOutputStream {
	return FilterOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalFilterOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFilterOutputStream(obj), nil
}

// BaseStream gets the base stream for the filter stream.
func (stream filterOutputStream) BaseStream() OutputStream {
	var arg0 *C.GFilterOutputStream

	arg0 = (*C.GFilterOutputStream)(stream.Native())

	ret := C.g_filter_output_stream_get_base_stream(arg0)

	var ret0 OutputStream

	ret0 = WrapOutputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CloseBaseStream returns whether the base stream will be closed when
// @stream is closed.
func (stream filterOutputStream) CloseBaseStream() bool {
	var arg0 *C.GFilterOutputStream

	arg0 = (*C.GFilterOutputStream)(stream.Native())

	ret := C.g_filter_output_stream_get_close_base_stream(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetCloseBaseStream sets whether the base stream will be closed when
// @stream is closed.
func (stream filterOutputStream) SetCloseBaseStream(closeBase bool) {
	var arg0 *C.GFilterOutputStream
	var arg1 C.gboolean

	arg0 = (*C.GFilterOutputStream)(stream.Native())
	arg1 = gextras.Cbool(closeBase)

	C.g_filter_output_stream_set_close_base_stream(arg0, arg1)
}

// IOStream: GIOStream represents an object that has both read and write
// streams. Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for seekable
// streams, both streams may use the same position.
//
// Examples of OStream objects are Connection, which represents a two-way
// network connection; and IOStream, which represents a file handle opened in
// read-write mode.
//
// To do the actual reading and writing you need to get the substreams with
// g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
//
// The OStream object owns the input and the output streams, not the other way
// around, so keeping the substreams alive will not keep the OStream object
// alive. If the OStream object is freed it will be closed, thus closing the
// substreams, so even if the substreams stay alive they will always return
// G_IO_ERROR_CLOSED for all operations.
//
// To close a stream use g_io_stream_close() which will close the common stream
// object and also the individual substreams. You can also close the substreams
// themselves. In most cases this only marks the substream as closed, so further
// I/O on it fails but common state in the OStream may still be open. However,
// some streams may support "half-closed" states where one direction of the
// stream is actually shut down.
//
// Operations on OStreams cannot be started while another operation on the
// OStream or its substreams is in progress. Specifically, an application can
// read from the Stream and write to the Stream simultaneously (either in
// separate threads, or as asynchronous operations in the same thread), but an
// application cannot start any OStream operation while there is a OStream,
// Stream or Stream operation in progress, and an application can’t start any
// Stream or Stream operation while there is a OStream operation in progress.
//
// This is a product of individual stream operations being associated with a
// given Context (the thread-default context at the time the operation was
// started), rather than entire streams being associated with a single Context.
//
// GIO may run operations on OStreams from other (worker) threads, and this may
// be exposed to application code in the behaviour of wrapper streams, such as
// InputStream or Connection. With such wrapper APIs, application code may only
// run operations on the base (wrapped) stream when the wrapper stream is idle.
// Note that the semantics of such operations may not be well-defined due to the
// state the wrapper stream leaves the base stream in (though they are
// guaranteed not to crash).
type IOStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it. This will
	// also close the individual input and output streams, if they are not
	// already closed.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	//
	// The default implementation of this method just calls close on the
	// individual input/output streams.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous close of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_io_stream_close_finish() to get the result of
	// the operation.
	//
	// For behaviour details see g_io_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// InputStream gets the input stream for this object. This is used for
	// reading.
	InputStream() InputStream
	// OutputStream gets the output stream for this object. This is used for
	// writing.
	OutputStream() OutputStream
	// HasPending checks if a stream has pending actions.
	HasPending() bool
	// IsClosed checks if a stream is closed.
	IsClosed() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// SpliceAsync: asynchronously splice the output stream of @stream1 to the
	// input stream of @stream2, and splice the output stream of @stream2 to the
	// input stream of @stream1.
	//
	// When the operation is finished @callback will be called. You can then
	// call g_io_stream_splice_finish() to get the result of the operation.
	SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// ioStream implements the IOStream interface.
type ioStream struct {
	gextras.Objector
}

// WrapIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapIOStream(obj *externglib.Object) IOStream {
	return IOStream{
		gextras.Objector: (obj),
	}
}

func marshalIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapIOStream(obj), nil
}

// ClearPending clears the pending flag on @stream.
func (stream ioStream) ClearPending() {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	C.g_io_stream_clear_pending(arg0)
}

// Close closes the stream, releasing resources related to it. This will
// also close the individual input and output streams, if they are not
// already closed.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
// error.
//
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are
// released as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for
// the individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close
// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
// important to check and report the error to the user, otherwise there
// might be a loss of data as all data might not be written.
//
// If @cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
//
// The default implementation of this method just calls close on the
// individual input/output streams.
func (stream ioStream) Close(cancellable Cancellable) bool {
	var arg0 *C.GIOStream
	var arg1 *C.GCancellable

	arg0 = (*C.GIOStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_io_stream_close(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CloseAsync requests an asynchronous close of the stream, releasing
// resources related to it. When the operation is finished @callback will be
// called. You can then call g_io_stream_close_finish() to get the result of
// the operation.
//
// For behaviour details see g_io_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
func (stream ioStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GIOStream
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GIOStream)(stream.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_io_stream_close_async(arg0, arg1, arg2, arg3)
}

// InputStream gets the input stream for this object. This is used for
// reading.
func (stream ioStream) InputStream() InputStream {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	ret := C.g_io_stream_get_input_stream(arg0)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// OutputStream gets the output stream for this object. This is used for
// writing.
func (stream ioStream) OutputStream() OutputStream {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	ret := C.g_io_stream_get_output_stream(arg0)

	var ret0 OutputStream

	ret0 = WrapOutputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// HasPending checks if a stream has pending actions.
func (stream ioStream) HasPending() bool {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	ret := C.g_io_stream_has_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsClosed checks if a stream is closed.
func (stream ioStream) IsClosed() bool {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	ret := C.g_io_stream_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
func (stream ioStream) SetPending() bool {
	var arg0 *C.GIOStream

	arg0 = (*C.GIOStream)(stream.Native())

	ret := C.g_io_stream_set_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SpliceAsync: asynchronously splice the output stream of @stream1 to the
// input stream of @stream2, and splice the output stream of @stream2 to the
// input stream of @stream1.
//
// When the operation is finished @callback will be called. You can then
// call g_io_stream_splice_finish() to get the result of the operation.
func (stream1 ioStream) SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GIOStream
	var arg1 *C.GIOStream
	var arg2 C.GIOStreamSpliceFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GIOStream)(stream1.Native())
	arg1 = (*C.GIOStream)(stream2.Native())
	arg2 = (C.GIOStreamSpliceFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_io_stream_splice_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress interface {
	gextras.Objector

	// Equal checks if two Address instances are equal, e.g. the same address.
	Equal(otherAddress InetAddress) bool
	// Family gets @address's family
	Family() SocketFamily
	// IsAny tests whether @address is the "any" address for its family.
	IsAny() bool
	// IsLinkLocal tests whether @address is a link-local address (that is, if
	// it identifies a host on a local network that is not connected to the
	// Internet).
	IsLinkLocal() bool
	// IsLoopback tests whether @address is the loopback address for its family.
	IsLoopback() bool
	// IsMcGlobal tests whether @address is a global multicast address.
	IsMcGlobal() bool
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	IsMcLinkLocal() bool
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	IsMcNodeLocal() bool
	// IsMcOrgLocal tests whether @address is an organization-local multicast
	// address.
	IsMcOrgLocal() bool
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	IsMcSiteLocal() bool
	// IsMulticast tests whether @address is a multicast address.
	IsMulticast() bool
	// IsSiteLocal tests whether @address is a site-local address such as
	// 10.0.0.1 (that is, the address identifies a host on a local network that
	// can not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	IsSiteLocal() bool
	// NativeSize gets the size of the native raw binary address for @address.
	// This is the size of the data that you get from g_inet_address_to_bytes().
	NativeSize() uint
	// ToBytes gets the raw binary address data from @address.
	ToBytes() byte
	// String converts @address to string form.
	String() string
}

// inetAddress implements the InetAddress interface.
type inetAddress struct {
	gextras.Objector
}

// WrapInetAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddress(obj *externglib.Object) InetAddress {
	return InetAddress{
		gextras.Objector: (obj),
	}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddress(obj), nil
}

// NewInetAddressAny constructs a class InetAddress.
func NewInetAddressAny(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	ret := C.g_inet_address_new_any(arg1)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewInetAddressFromBytes constructs a class InetAddress.
func NewInetAddressFromBytes(bytes []byte, family SocketFamily) InetAddress {
	var arg1 *C.guint8
	var arg2 C.GSocketFamily

	{

	}
	arg2 = (C.GSocketFamily)(family)

	ret := C.g_inet_address_new_from_bytes(arg1, arg2)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewInetAddressFromString constructs a class InetAddress.
func NewInetAddressFromString(string string) InetAddress {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_inet_address_new_from_string(arg1)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewInetAddressLoopback constructs a class InetAddress.
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	ret := C.g_inet_address_new_loopback(arg1)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Equal checks if two Address instances are equal, e.g. the same address.
func (address inetAddress) Equal(otherAddress InetAddress) bool {
	var arg0 *C.GInetAddress
	var arg1 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())
	arg1 = (*C.GInetAddress)(otherAddress.Native())

	ret := C.g_inet_address_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Family gets @address's family
func (address inetAddress) Family() SocketFamily {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// IsAny tests whether @address is the "any" address for its family.
func (address inetAddress) IsAny() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_any(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsLinkLocal tests whether @address is a link-local address (that is, if
// it identifies a host on a local network that is not connected to the
// Internet).
func (address inetAddress) IsLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_link_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsLoopback tests whether @address is the loopback address for its family.
func (address inetAddress) IsLoopback() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_loopback(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMcGlobal tests whether @address is a global multicast address.
func (address inetAddress) IsMcGlobal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_mc_global(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMcLinkLocal tests whether @address is a link-local multicast address.
func (address inetAddress) IsMcLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_mc_link_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMcNodeLocal tests whether @address is a node-local multicast address.
func (address inetAddress) IsMcNodeLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_mc_node_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMcOrgLocal tests whether @address is an organization-local multicast
// address.
func (address inetAddress) IsMcOrgLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_mc_org_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMcSiteLocal tests whether @address is a site-local multicast address.
func (address inetAddress) IsMcSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_mc_site_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsMulticast tests whether @address is a multicast address.
func (address inetAddress) IsMulticast() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_multicast(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsSiteLocal tests whether @address is a site-local address such as
// 10.0.0.1 (that is, the address identifies a host on a local network that
// can not be reached directly from the Internet, but which may have
// outgoing Internet connectivity via a NAT or firewall).
func (address inetAddress) IsSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_is_site_local(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// NativeSize gets the size of the native raw binary address for @address.
// This is the size of the data that you get from g_inet_address_to_bytes().
func (address inetAddress) NativeSize() uint {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_get_native_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ToBytes gets the raw binary address data from @address.
func (address inetAddress) ToBytes() byte {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_to_bytes(arg0)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// String converts @address to string form.
func (address inetAddress) String() string {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// InetAddressMask represents a range of IPv4 or IPv6 addresses described by a
// base address and a length indicating how many bits of the base address are
// relevant for matching purposes. These are often given in string form. Eg,
// "10.0.0.0/8", or "fe80::/10".
type InetAddressMask interface {
	gextras.Objector

	// Equal tests if @mask and @mask2 are the same mask.
	Equal(mask2 InetAddressMask) bool
	// Address gets @mask's base address
	Address() InetAddress
	// Family gets the Family of @mask's address
	Family() SocketFamily
	// Length gets @mask's length
	Length() uint
	// Matches tests if @address falls within the range described by @mask.
	Matches(address InetAddress) bool
	// String converts @mask back to its corresponding string form.
	String() string
}

// inetAddressMask implements the InetAddressMask interface.
type inetAddressMask struct {
	gextras.Objector
}

// WrapInetAddressMask wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddressMask(obj *externglib.Object) InetAddressMask {
	return InetAddressMask{
		gextras.Objector: (obj),
	}
}

func marshalInetAddressMask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddressMask(obj), nil
}

// NewInetAddressMask constructs a class InetAddressMask.
func NewInetAddressMask(addr InetAddress, length uint) InetAddressMask {
	var arg1 *C.GInetAddress
	var arg2 C.guint

	arg1 = (*C.GInetAddress)(addr.Native())
	arg2 = C.guint(length)

	ret := C.g_inet_address_mask_new(arg1, arg2)

	var ret0 InetAddressMask

	ret0 = WrapInetAddressMask(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewInetAddressMaskFromString constructs a class InetAddressMask.
func NewInetAddressMaskFromString(maskString string) InetAddressMask {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(maskString))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_inet_address_mask_new_from_string(arg1)

	var ret0 InetAddressMask

	ret0 = WrapInetAddressMask(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Equal tests if @mask and @mask2 are the same mask.
func (mask inetAddressMask) Equal(mask2 InetAddressMask) bool {
	var arg0 *C.GInetAddressMask
	var arg1 *C.GInetAddressMask

	arg0 = (*C.GInetAddressMask)(mask.Native())
	arg1 = (*C.GInetAddressMask)(mask2.Native())

	ret := C.g_inet_address_mask_equal(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Address gets @mask's base address
func (mask inetAddressMask) Address() InetAddress {
	var arg0 *C.GInetAddressMask

	arg0 = (*C.GInetAddressMask)(mask.Native())

	ret := C.g_inet_address_mask_get_address(arg0)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Family gets the Family of @mask's address
func (mask inetAddressMask) Family() SocketFamily {
	var arg0 *C.GInetAddressMask

	arg0 = (*C.GInetAddressMask)(mask.Native())

	ret := C.g_inet_address_mask_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// Length gets @mask's length
func (mask inetAddressMask) Length() uint {
	var arg0 *C.GInetAddressMask

	arg0 = (*C.GInetAddressMask)(mask.Native())

	ret := C.g_inet_address_mask_get_length(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Matches tests if @address falls within the range described by @mask.
func (mask inetAddressMask) Matches(address InetAddress) bool {
	var arg0 *C.GInetAddressMask
	var arg1 *C.GInetAddress

	arg0 = (*C.GInetAddressMask)(mask.Native())
	arg1 = (*C.GInetAddress)(address.Native())

	ret := C.g_inet_address_mask_matches(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// String converts @mask back to its corresponding string form.
func (mask inetAddressMask) String() string {
	var arg0 *C.GInetAddressMask

	arg0 = (*C.GInetAddressMask)(mask.Native())

	ret := C.g_inet_address_mask_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// InetSocketAddress: an IPv4 or IPv6 socket address; that is, the combination
// of a Address and a port number.
type InetSocketAddress interface {
	SocketAddress

	// Address gets @address's Address.
	Address() InetAddress
	// Flowinfo gets the `sin6_flowinfo` field from @address, which must be an
	// IPv6 address.
	Flowinfo() uint32
	// Port gets @address's port.
	Port() uint16
	// ScopeID gets the `sin6_scope_id` field from @address, which must be an
	// IPv6 address.
	ScopeID() uint32
}

// inetSocketAddress implements the InetSocketAddress interface.
type inetSocketAddress struct {
	SocketAddress
}

// WrapInetSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetSocketAddress(obj *externglib.Object) InetSocketAddress {
	return InetSocketAddress{
		SocketAddress: WrapSocketAddress(obj),
	}
}

func marshalInetSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetSocketAddress(obj), nil
}

// NewInetSocketAddress constructs a class InetSocketAddress.
func NewInetSocketAddress(address InetAddress, port uint16) InetSocketAddress {
	var arg1 *C.GInetAddress
	var arg2 C.guint16

	arg1 = (*C.GInetAddress)(address.Native())
	arg2 = C.guint16(port)

	ret := C.g_inet_socket_address_new(arg1, arg2)

	var ret0 InetSocketAddress

	ret0 = WrapInetSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewInetSocketAddressFromString constructs a class InetSocketAddress.
func NewInetSocketAddressFromString(address string, port uint) InetSocketAddress {
	var arg1 *C.char
	var arg2 C.guint

	arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(port)

	ret := C.g_inet_socket_address_new_from_string(arg1, arg2)

	var ret0 InetSocketAddress

	ret0 = WrapInetSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Address gets @address's Address.
func (address inetSocketAddress) Address() InetAddress {
	var arg0 *C.GInetSocketAddress

	arg0 = (*C.GInetSocketAddress)(address.Native())

	ret := C.g_inet_socket_address_get_address(arg0)

	var ret0 InetAddress

	ret0 = WrapInetAddress(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Flowinfo gets the `sin6_flowinfo` field from @address, which must be an
// IPv6 address.
func (address inetSocketAddress) Flowinfo() uint32 {
	var arg0 *C.GInetSocketAddress

	arg0 = (*C.GInetSocketAddress)(address.Native())

	ret := C.g_inet_socket_address_get_flowinfo(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Port gets @address's port.
func (address inetSocketAddress) Port() uint16 {
	var arg0 *C.GInetSocketAddress

	arg0 = (*C.GInetSocketAddress)(address.Native())

	ret := C.g_inet_socket_address_get_port(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// ScopeID gets the `sin6_scope_id` field from @address, which must be an
// IPv6 address.
func (address inetSocketAddress) ScopeID() uint32 {
	var arg0 *C.GInetSocketAddress

	arg0 = (*C.GInetSocketAddress)(address.Native())

	ret := C.g_inet_socket_address_get_scope_id(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// InputStream has functions to read from a stream (g_input_stream_read()), to
// close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous closes of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_input_stream_close_finish() to get the result
	// of the operation.
	//
	// For behaviour details see g_input_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// HasPending checks if an input stream has pending actions.
	HasPending() bool
	// IsClosed checks if an input stream is closed.
	IsClosed() bool
	// Read tries to read @count bytes from the stream into the buffer starting
	// at @buffer. Will block during this read.
	//
	// If count is zero returns zero and does nothing. A value of @count larger
	// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer is returned. It is
	// not an error if this is not the same as the requested size, as it can
	// happen e.g. near the end of a file. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// The returned @buffer is not a nul-terminated string, it can contain nul
	// bytes at any position, and this function doesn't nul-terminate the
	// @buffer.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error -1 is returned and @error is set accordingly.
	Read(cancellable Cancellable) (buffer []byte, count uint, gssize int)
	// ReadAll tries to read @count bytes from the stream into the buffer
	// starting at @buffer. Will block during this read.
	//
	// This function is similar to g_input_stream_read(), except it tries to
	// read as many bytes as requested, only stopping on an error or end of
	// stream.
	//
	// On a successful read of @count bytes, or if we reached the end of the
	// stream, true is returned, and @bytes_read is set to the number of bytes
	// read into @buffer.
	//
	// If there is an error during the operation false is returned and @error is
	// set to indicate the error status.
	//
	// As a special exception to the normal conventions for functions that use
	// #GError, if this function returns false (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered. This functionality is only
	// available from C. If you need it from another language then you must
	// write your own loop around g_input_stream_read().
	ReadAll(cancellable Cancellable) (buffer []byte, count uint, bytesRead uint, ok bool)
	// ReadAllAsync: request an asynchronous read of @count bytes from the
	// stream into the buffer starting at @buffer.
	//
	// This is the asynchronous equivalent of g_input_stream_read_all().
	//
	// Call g_input_stream_read_all_finish() to collect the result.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	ReadAllAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []byte, count uint)
	// ReadAsync: request an asynchronous read of @count bytes from the stream
	// into the buffer starting at @buffer. When the operation is finished
	// @callback will be called. You can then call g_input_stream_read_finish()
	// to get the result of the operation.
	//
	// During an async request no other sync and async calls are allowed on
	// @stream, and will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes read into the buffer will be passed to
	// the callback. It is not an error if this is not the same as the requested
	// size, as it can happen e.g. near the end of a file, but generally we try
	// to read as many bytes as requested. Zero is returned on end of file (or
	// if @count is zero), but never otherwise.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []byte, count uint)
	// ReadBytes: like g_input_stream_read(), this tries to read @count bytes
	// from the stream in a blocking fashion. However, rather than reading into
	// a user-supplied buffer, this will create a new #GBytes containing the
	// data that was read. This may be easier to use from language bindings.
	//
	// If count is zero, returns a zero-length #GBytes and does nothing. A value
	// of @count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT
	// error.
	//
	// On success, a new #GBytes is returned. It is not an error if the size of
	// this object is not the same as the requested size, as it can happen e.g.
	// near the end of a file. A zero-length #GBytes is returned on end of file
	// (or if @count is zero), but never otherwise.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	//
	// On error nil is returned and @error is set accordingly.
	ReadBytes(count uint, cancellable Cancellable) *glib.Bytes
	// ReadBytesAsync: request an asynchronous read of @count bytes from the
	// stream into a new #GBytes. When the operation is finished @callback will
	// be called. You can then call g_input_stream_read_bytes_finish() to get
	// the result of the operation.
	//
	// During an async request no other sync and async calls are allowed on
	// @stream, and will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the new #GBytes will be passed to the callback. It is not an
	// error if this is smaller than the requested size, as it can happen e.g.
	// near the end of a file, but generally we try to read as many bytes as
	// requested. Zero is returned on end of file (or if @count is zero), but
	// never otherwise.
	//
	// Any outstanding I/O request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	ReadBytesAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// Skip tries to skip @count bytes from the stream. Will block during the
	// operation.
	//
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some streams
	// have an implementation that is more efficient than reading the data.
	//
	// This function is optional for inherited classes, as the default
	// implementation emulates it using read.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Skip(count uint, cancellable Cancellable) int
	// SkipAsync: request an asynchronous skip of @count bytes from the stream.
	// When the operation is finished @callback will be called. You can then
	// call g_input_stream_skip_finish() to get the result of the operation.
	//
	// During an async request no other sync and async calls are allowed, and
	// will result in G_IO_ERROR_PENDING errors.
	//
	// A value of @count larger than G_MAXSSIZE will cause a
	// G_IO_ERROR_INVALID_ARGUMENT error.
	//
	// On success, the number of bytes skipped will be passed to the callback.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file, but generally we try to skip as
	// many bytes as requested. Zero is returned on end of file (or if @count is
	// zero), but never otherwise.
	//
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is G_PRIORITY_DEFAULT.
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one, you must override all.
	SkipAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// inputStream implements the InputStream interface.
type inputStream struct {
	gextras.Objector
}

// WrapInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapInputStream(obj *externglib.Object) InputStream {
	return InputStream{
		gextras.Objector: (obj),
	}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInputStream(obj), nil
}

// ClearPending clears the pending flag on @stream.
func (stream inputStream) ClearPending() {
	var arg0 *C.GInputStream

	arg0 = (*C.GInputStream)(stream.Native())

	C.g_input_stream_clear_pending(arg0)
}

// Close closes the stream, releasing resources related to it.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
// error.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are
// released as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for
// the individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close
// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
// important to check and report the error to the user.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
func (stream inputStream) Close(cancellable Cancellable) bool {
	var arg0 *C.GInputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_input_stream_close(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CloseAsync requests an asynchronous closes of the stream, releasing
// resources related to it. When the operation is finished @callback will be
// called. You can then call g_input_stream_close_finish() to get the result
// of the operation.
//
// For behaviour details see g_input_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
func (stream inputStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GInputStream
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_input_stream_close_async(arg0, arg1, arg2, arg3)
}

// HasPending checks if an input stream has pending actions.
func (stream inputStream) HasPending() bool {
	var arg0 *C.GInputStream

	arg0 = (*C.GInputStream)(stream.Native())

	ret := C.g_input_stream_has_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsClosed checks if an input stream is closed.
func (stream inputStream) IsClosed() bool {
	var arg0 *C.GInputStream

	arg0 = (*C.GInputStream)(stream.Native())

	ret := C.g_input_stream_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Read tries to read @count bytes from the stream into the buffer starting
// at @buffer. Will block during this read.
//
// If count is zero returns zero and does nothing. A value of @count larger
// than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer is returned. It is
// not an error if this is not the same as the requested size, as it can
// happen e.g. near the end of a file. Zero is returned on end of file (or
// if @count is zero), but never otherwise.
//
// The returned @buffer is not a nul-terminated string, it can contain nul
// bytes at any position, and this function doesn't nul-terminate the
// @buffer.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error -1 is returned and @error is set accordingly.
func (stream inputStream) Read(cancellable Cancellable) (buffer []byte, count uint, gssize int) {
	var arg0 *C.GInputStream
	var arg1 *C.void // out
	var arg2 C.gsize // out
	var arg3 *C.GCancellable

	arg0 = (*C.GInputStream)(stream.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_input_stream_read(arg0, &arg1, &arg2, arg3)

	var ret0 []byte
	var ret1 uint
	var ret2 int

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	ret2 = int(ret)

	return ret0, ret1, ret2
}

// ReadAll tries to read @count bytes from the stream into the buffer
// starting at @buffer. Will block during this read.
//
// This function is similar to g_input_stream_read(), except it tries to
// read as many bytes as requested, only stopping on an error or end of
// stream.
//
// On a successful read of @count bytes, or if we reached the end of the
// stream, true is returned, and @bytes_read is set to the number of bytes
// read into @buffer.
//
// If there is an error during the operation false is returned and @error is
// set to indicate the error status.
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns false (and sets @error) then
// @bytes_read will be set to the number of bytes that were successfully
// read before the error was encountered. This functionality is only
// available from C. If you need it from another language then you must
// write your own loop around g_input_stream_read().
func (stream inputStream) ReadAll(cancellable Cancellable) (buffer []byte, count uint, bytesRead uint, ok bool) {
	var arg0 *C.GInputStream
	var arg1 *C.void  // out
	var arg2 C.gsize  // out
	var arg3 *C.gsize // out
	var arg4 *C.GCancellable

	arg0 = (*C.GInputStream)(stream.Native())
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_input_stream_read_all(arg0, &arg1, &arg2, &arg3, arg4)

	var ret0 []byte
	var ret1 uint
	var ret2 uint
	var ret3 bool

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	ret2 = uint(arg3)

	ret3 = gextras.Gobool(ret)

	return ret0, ret1, ret2, ret3
}

// ReadAllAsync: request an asynchronous read of @count bytes from the
// stream into the buffer starting at @buffer.
//
// This is the asynchronous equivalent of g_input_stream_read_all().
//
// Call g_input_stream_read_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is G_PRIORITY_DEFAULT.
func (stream inputStream) ReadAllAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []byte, count uint) {
	var arg0 *C.GInputStream
	var arg1 *C.void // out
	var arg2 C.gsize // out
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GInputStream)(stream.Native())
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	ret := C.g_input_stream_read_all_async(arg0, &arg1, &arg2, arg3, arg4, arg5)

	var ret0 []byte
	var ret1 uint

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	return ret0, ret1
}

// ReadAsync: request an asynchronous read of @count bytes from the stream
// into the buffer starting at @buffer. When the operation is finished
// @callback will be called. You can then call g_input_stream_read_finish()
// to get the result of the operation.
//
// During an async request no other sync and async calls are allowed on
// @stream, and will result in G_IO_ERROR_PENDING errors.
//
// A value of @count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes read into the buffer will be passed to
// the callback. It is not an error if this is not the same as the requested
// size, as it can happen e.g. near the end of a file, but generally we try
// to read as many bytes as requested. Zero is returned on end of file (or
// if @count is zero), but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
func (stream inputStream) ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) (buffer []byte, count uint) {
	var arg0 *C.GInputStream
	var arg1 *C.void // out
	var arg2 C.gsize // out
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GInputStream)(stream.Native())
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	ret := C.g_input_stream_read_async(arg0, &arg1, &arg2, arg3, arg4, arg5)

	var ret0 []byte
	var ret1 uint

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	return ret0, ret1
}

// ReadBytes: like g_input_stream_read(), this tries to read @count bytes
// from the stream in a blocking fashion. However, rather than reading into
// a user-supplied buffer, this will create a new #GBytes containing the
// data that was read. This may be easier to use from language bindings.
//
// If count is zero, returns a zero-length #GBytes and does nothing. A value
// of @count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT
// error.
//
// On success, a new #GBytes is returned. It is not an error if the size of
// this object is not the same as the requested size, as it can happen e.g.
// near the end of a file. A zero-length #GBytes is returned on end of file
// (or if @count is zero), but never otherwise.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
//
// On error nil is returned and @error is set accordingly.
func (stream inputStream) ReadBytes(count uint, cancellable Cancellable) *glib.Bytes {
	var arg0 *C.GInputStream
	var arg1 C.gsize
	var arg2 *C.GCancellable

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = C.gsize(count)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_input_stream_read_bytes(arg0, arg1, arg2)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// ReadBytesAsync: request an asynchronous read of @count bytes from the
// stream into a new #GBytes. When the operation is finished @callback will
// be called. You can then call g_input_stream_read_bytes_finish() to get
// the result of the operation.
//
// During an async request no other sync and async calls are allowed on
// @stream, and will result in G_IO_ERROR_PENDING errors.
//
// A value of @count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the new #GBytes will be passed to the callback. It is not an
// error if this is smaller than the requested size, as it can happen e.g.
// near the end of a file, but generally we try to read as many bytes as
// requested. Zero is returned on end of file (or if @count is zero), but
// never otherwise.
//
// Any outstanding I/O request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is G_PRIORITY_DEFAULT.
func (stream inputStream) ReadBytesAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GInputStream
	var arg1 C.gsize
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = C.gsize(count)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_input_stream_read_bytes_async(arg0, arg1, arg2, arg3, arg4)
}

// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
func (stream inputStream) SetPending() bool {
	var arg0 *C.GInputStream

	arg0 = (*C.GInputStream)(stream.Native())

	ret := C.g_input_stream_set_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Skip tries to skip @count bytes from the stream. Will block during the
// operation.
//
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some streams
// have an implementation that is more efficient than reading the data.
//
// This function is optional for inherited classes, as the default
// implementation emulates it using read.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (stream inputStream) Skip(count uint, cancellable Cancellable) int {
	var arg0 *C.GInputStream
	var arg1 C.gsize
	var arg2 *C.GCancellable

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = C.gsize(count)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_input_stream_skip(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SkipAsync: request an asynchronous skip of @count bytes from the stream.
// When the operation is finished @callback will be called. You can then
// call g_input_stream_skip_finish() to get the result of the operation.
//
// During an async request no other sync and async calls are allowed, and
// will result in G_IO_ERROR_PENDING errors.
//
// A value of @count larger than G_MAXSSIZE will cause a
// G_IO_ERROR_INVALID_ARGUMENT error.
//
// On success, the number of bytes skipped will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file, but generally we try to skip as
// many bytes as requested. Zero is returned on end of file (or if @count is
// zero), but never otherwise.
//
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one, you must override all.
func (stream inputStream) SkipAsync(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GInputStream
	var arg1 C.gsize
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GInputStream)(stream.Native())
	arg1 = C.gsize(count)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_input_stream_skip_async(arg0, arg1, arg2, arg3, arg4)
}

// ListStore is a simple implementation of Model that stores all items in
// memory.
//
// It provides insertions, deletions, and lookups in logarithmic time with a
// fast path for the common case of iterating the list linearly.
type ListStore interface {
	gextras.Objector

	// Append appends @item to @store. @item must be of type Store:item-type.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to append multiple items at the same time
	// efficiently.
	Append(item gextras.Objector)
	// Find looks up the given @item in the list store by looping over the items
	// until the first occurrence of @item. If @item was not found, then
	// @position will not be set, and this method will return false.
	//
	// If you need to compare the two items with a custom comparison function,
	// use g_list_store_find_with_equal_func() with a custom Func instead.
	Find(item gextras.Objector) (position uint, ok bool)
	// FindWithEqualFunc looks up the given @item in the list store by looping
	// over the items and comparing them with @compare_func until the first
	// occurrence of @item which matches. If @item was not found, then @position
	// will not be set, and this method will return false.
	FindWithEqualFunc(item gextras.Objector, equalFunc glib.EqualFunc) (position uint, ok bool)
	// Insert inserts @item into @store at @position. @item must be of type
	// Store:item-type or derived from it. @position must be smaller than the
	// length of the list, or equal to it to append.
	//
	// This function takes a ref on @item.
	//
	// Use g_list_store_splice() to insert multiple items at the same time
	// efficiently.
	Insert(position uint, item gextras.Objector)
	// InsertSorted inserts @item into @store at a position to be determined by
	// the @compare_func.
	//
	// The list must already be sorted before calling this function or the
	// result is undefined. Usually you would approach this by only ever
	// inserting items by way of this function.
	//
	// This function takes a ref on @item.
	InsertSorted(item gextras.Objector, compareFunc glib.CompareDataFunc) uint
	// Remove removes the item from @store that is at @position. @position must
	// be smaller than the current length of the list.
	//
	// Use g_list_store_splice() to remove multiple items at the same time
	// efficiently.
	Remove(position uint)
	// RemoveAll removes all items from @store.
	RemoveAll()
	// Sort: sort the items in @store according to @compare_func.
	Sort(compareFunc glib.CompareDataFunc)
}

// listStore implements the ListStore interface.
type listStore struct {
	gextras.Objector
}

// WrapListStore wraps a GObject to the right type. It is
// primarily used internally.
func WrapListStore(obj *externglib.Object) ListStore {
	return ListStore{
		gextras.Objector: (obj),
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapListStore(obj), nil
}

// NewListStore constructs a class ListStore.
func NewListStore(itemType externglib.Type) ListStore {
	var arg1 C.GType

	arg1 = C.GType(itemType)

	ret := C.g_list_store_new(arg1)

	var ret0 ListStore

	ret0 = WrapListStore(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append appends @item to @store. @item must be of type Store:item-type.
//
// This function takes a ref on @item.
//
// Use g_list_store_splice() to append multiple items at the same time
// efficiently.
func (store listStore) Append(item gextras.Objector) {
	var arg0 *C.GListStore
	var arg1 C.gpointer

	arg0 = (*C.GListStore)(store.Native())
	arg1 = (*C.GObject)(item.Native())

	C.g_list_store_append(arg0, arg1)
}

// Find looks up the given @item in the list store by looping over the items
// until the first occurrence of @item. If @item was not found, then
// @position will not be set, and this method will return false.
//
// If you need to compare the two items with a custom comparison function,
// use g_list_store_find_with_equal_func() with a custom Func instead.
func (store listStore) Find(item gextras.Objector) (position uint, ok bool) {
	var arg0 *C.GListStore
	var arg1 C.gpointer
	var arg2 *C.guint // out

	arg0 = (*C.GListStore)(store.Native())
	arg1 = (*C.GObject)(item.Native())

	ret := C.g_list_store_find(arg0, arg1, &arg2)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg2)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// FindWithEqualFunc looks up the given @item in the list store by looping
// over the items and comparing them with @compare_func until the first
// occurrence of @item which matches. If @item was not found, then @position
// will not be set, and this method will return false.
func (store listStore) FindWithEqualFunc(item gextras.Objector, equalFunc glib.EqualFunc) (position uint, ok bool) {
	var arg0 *C.GListStore
	var arg1 C.gpointer
	var arg2 C.GEqualFunc
	var arg3 *C.guint // out

	arg0 = (*C.GListStore)(store.Native())
	arg1 = (*C.GObject)(item.Native())
	arg2 = (*[0]byte)(C.gotk4_EqualFunc)

	ret := C.g_list_store_find_with_equal_func(arg0, arg1, arg2, &arg3)

	var ret0 uint
	var ret1 bool

	ret0 = uint(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Insert inserts @item into @store at @position. @item must be of type
// Store:item-type or derived from it. @position must be smaller than the
// length of the list, or equal to it to append.
//
// This function takes a ref on @item.
//
// Use g_list_store_splice() to insert multiple items at the same time
// efficiently.
func (store listStore) Insert(position uint, item gextras.Objector) {
	var arg0 *C.GListStore
	var arg1 C.guint
	var arg2 C.gpointer

	arg0 = (*C.GListStore)(store.Native())
	arg1 = C.guint(position)
	arg2 = (*C.GObject)(item.Native())

	C.g_list_store_insert(arg0, arg1, arg2)
}

// InsertSorted inserts @item into @store at a position to be determined by
// the @compare_func.
//
// The list must already be sorted before calling this function or the
// result is undefined. Usually you would approach this by only ever
// inserting items by way of this function.
//
// This function takes a ref on @item.
func (store listStore) InsertSorted(item gextras.Objector, compareFunc glib.CompareDataFunc) uint {
	var arg0 *C.GListStore
	var arg1 C.gpointer
	var arg2 C.GCompareDataFunc
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GListStore)(store.Native())
	arg1 = (*C.GObject)(item.Native())
	arg2 = (*[0]byte)(C.gotk4_CompareDataFunc)

	ret := C.g_list_store_insert_sorted(arg0, arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Remove removes the item from @store that is at @position. @position must
// be smaller than the current length of the list.
//
// Use g_list_store_splice() to remove multiple items at the same time
// efficiently.
func (store listStore) Remove(position uint) {
	var arg0 *C.GListStore
	var arg1 C.guint

	arg0 = (*C.GListStore)(store.Native())
	arg1 = C.guint(position)

	C.g_list_store_remove(arg0, arg1)
}

// RemoveAll removes all items from @store.
func (store listStore) RemoveAll() {
	var arg0 *C.GListStore

	arg0 = (*C.GListStore)(store.Native())

	C.g_list_store_remove_all(arg0)
}

// Sort: sort the items in @store according to @compare_func.
func (store listStore) Sort(compareFunc glib.CompareDataFunc) {
	var arg0 *C.GListStore
	var arg1 C.GCompareDataFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GListStore)(store.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)

	C.g_list_store_sort(arg0, arg1)
}

// MemoryInputStream is a class for using arbitrary memory chunks as input for
// GIO streaming input operations.
//
// As of GLib 2.34, InputStream implements InputStream.
type MemoryInputStream interface {
	InputStream

	// AddBytes appends @bytes to data that can be read from the input stream.
	AddBytes(bytes *glib.Bytes)
}

// memoryInputStream implements the MemoryInputStream interface.
type memoryInputStream struct {
	InputStream
}

// WrapMemoryInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryInputStream(obj *externglib.Object) MemoryInputStream {
	return MemoryInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalMemoryInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryInputStream(obj), nil
}

// NewMemoryInputStream constructs a class MemoryInputStream.
func NewMemoryInputStream() MemoryInputStream {

	ret := C.g_memory_input_stream_new()

	var ret0 MemoryInputStream

	ret0 = WrapMemoryInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMemoryInputStreamFromBytes constructs a class MemoryInputStream.
func NewMemoryInputStreamFromBytes(bytes *glib.Bytes) MemoryInputStream {
	var arg1 *C.GBytes

	arg1 = (*C.GBytes)(bytes.Native())

	ret := C.g_memory_input_stream_new_from_bytes(arg1)

	var ret0 MemoryInputStream

	ret0 = WrapMemoryInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddBytes appends @bytes to data that can be read from the input stream.
func (stream memoryInputStream) AddBytes(bytes *glib.Bytes) {
	var arg0 *C.GMemoryInputStream
	var arg1 *C.GBytes

	arg0 = (*C.GMemoryInputStream)(stream.Native())
	arg1 = (*C.GBytes)(bytes.Native())

	C.g_memory_input_stream_add_bytes(arg0, arg1)
}

// MemoryOutputStream is a class for using arbitrary memory chunks as output for
// GIO streaming output operations.
//
// As of GLib 2.34, OutputStream trivially implements OutputStream: it always
// polls as ready.
type MemoryOutputStream interface {
	OutputStream

	// Data gets any loaded data from the @ostream.
	//
	// Note that the returned pointer may become invalid on the next write or
	// truncate operation on the stream.
	Data() interface{}
	// DataSize returns the number of bytes from the start up to including the
	// last byte written in the stream that has not been truncated away.
	DataSize() uint
	// Size gets the size of the currently allocated data area (available from
	// g_memory_output_stream_get_data()).
	//
	// You probably don't want to use this function on resizable streams. See
	// g_memory_output_stream_get_data_size() instead. For resizable streams the
	// size returned by this function is an implementation detail and may be
	// change at any time in response to operations on the stream.
	//
	// If the stream is fixed-sized (ie: no realloc was passed to
	// g_memory_output_stream_new()) then this is the maximum size of the stream
	// and further writes will return G_IO_ERROR_NO_SPACE.
	//
	// In any case, if you want the number of bytes currently written to the
	// stream, use g_memory_output_stream_get_data_size().
	Size() uint
	// StealAsBytes returns data from the @ostream as a #GBytes. @ostream must
	// be closed before calling this function.
	StealAsBytes() *glib.Bytes
	// StealData gets any loaded data from the @ostream. Ownership of the data
	// is transferred to the caller; when no longer needed it must be freed
	// using the free function set in @ostream's OutputStream:destroy-function
	// property.
	//
	// @ostream must be closed before calling this function.
	StealData() interface{}
}

// memoryOutputStream implements the MemoryOutputStream interface.
type memoryOutputStream struct {
	OutputStream
}

// WrapMemoryOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryOutputStream(obj *externglib.Object) MemoryOutputStream {
	return MemoryOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalMemoryOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryOutputStream(obj), nil
}

// NewMemoryOutputStream constructs a class MemoryOutputStream.
func NewMemoryOutputStream(data interface{}, size uint, reallocFunction ReallocFunc) MemoryOutputStream {
	var arg1 C.gpointer
	var arg2 C.gsize
	var arg3 C.GReallocFunc

	arg1 = C.gpointer(box.Assign(data))
	arg2 = C.gsize(size)
	arg3 = (*[0]byte)(C.gotk4_ReallocFunc)

	ret := C.g_memory_output_stream_new(arg1, arg2, arg3, (*[0]byte)(C.callbackDelete))

	var ret0 MemoryOutputStream

	ret0 = WrapMemoryOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMemoryOutputStreamResizable constructs a class MemoryOutputStream.
func NewMemoryOutputStreamResizable() MemoryOutputStream {

	ret := C.g_memory_output_stream_new_resizable()

	var ret0 MemoryOutputStream

	ret0 = WrapMemoryOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Data gets any loaded data from the @ostream.
//
// Note that the returned pointer may become invalid on the next write or
// truncate operation on the stream.
func (ostream memoryOutputStream) Data() interface{} {
	var arg0 *C.GMemoryOutputStream

	arg0 = (*C.GMemoryOutputStream)(ostream.Native())

	ret := C.g_memory_output_stream_get_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// DataSize returns the number of bytes from the start up to including the
// last byte written in the stream that has not been truncated away.
func (ostream memoryOutputStream) DataSize() uint {
	var arg0 *C.GMemoryOutputStream

	arg0 = (*C.GMemoryOutputStream)(ostream.Native())

	ret := C.g_memory_output_stream_get_data_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Size gets the size of the currently allocated data area (available from
// g_memory_output_stream_get_data()).
//
// You probably don't want to use this function on resizable streams. See
// g_memory_output_stream_get_data_size() instead. For resizable streams the
// size returned by this function is an implementation detail and may be
// change at any time in response to operations on the stream.
//
// If the stream is fixed-sized (ie: no realloc was passed to
// g_memory_output_stream_new()) then this is the maximum size of the stream
// and further writes will return G_IO_ERROR_NO_SPACE.
//
// In any case, if you want the number of bytes currently written to the
// stream, use g_memory_output_stream_get_data_size().
func (ostream memoryOutputStream) Size() uint {
	var arg0 *C.GMemoryOutputStream

	arg0 = (*C.GMemoryOutputStream)(ostream.Native())

	ret := C.g_memory_output_stream_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// StealAsBytes returns data from the @ostream as a #GBytes. @ostream must
// be closed before calling this function.
func (ostream memoryOutputStream) StealAsBytes() *glib.Bytes {
	var arg0 *C.GMemoryOutputStream

	arg0 = (*C.GMemoryOutputStream)(ostream.Native())

	ret := C.g_memory_output_stream_steal_as_bytes(arg0)

	var ret0 *glib.Bytes

	ret0 = glib.WrapBytes(ret)

	return ret0
}

// StealData gets any loaded data from the @ostream. Ownership of the data
// is transferred to the caller; when no longer needed it must be freed
// using the free function set in @ostream's OutputStream:destroy-function
// property.
//
// @ostream must be closed before calling this function.
func (ostream memoryOutputStream) StealData() interface{} {
	var arg0 *C.GMemoryOutputStream

	arg0 = (*C.GMemoryOutputStream)(ostream.Native())

	ret := C.g_memory_output_stream_steal_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// menu implements the Menu interface.
type menu struct {
	MenuModel
}

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return Menu{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu constructs a class Menu.
func NewMenu() Menu {

	ret := C.g_menu_new()

	var ret0 Menu

	ret0 = WrapMenu(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append: convenience function for appending a normal menu item to the end
// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (menu menu) Append(label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_menu_append(arg0, arg1, arg2)
}

// AppendItem appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (menu menu) AppendItem(item MenuItem) {
	var arg0 *C.GMenu
	var arg1 *C.GMenuItem

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.GMenuItem)(item.Native())

	C.g_menu_append_item(arg0, arg1)
}

// AppendSection: convenience function for appending a section menu item to
// the end of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (menu menu) AppendSection(label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(section.Native())

	C.g_menu_append_section(arg0, arg1, arg2)
}

// AppendSubmenu: convenience function for appending a submenu menu item to
// the end of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (menu menu) AppendSubmenu(label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(submenu.Native())

	C.g_menu_append_submenu(arg0, arg1, arg2)
}

// Freeze marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes
// to it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning false,
// which has some positive performance implications.
func (menu menu) Freeze() {
	var arg0 *C.GMenu

	arg0 = (*C.GMenu)(menu.Native())

	C.g_menu_freeze(arg0)
}

// Insert: convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu menu) Insert(position int, label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg3))

	C.g_menu_insert(arg0, arg1, arg2, arg3)
}

// InsertItem inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of @item and using them to form a new item within @menu. As such,
// @item itself is not really inserted, but rather, a menu item that is
// exactly the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion occurs.
// Any changes you make to it are ignored unless it is inserted again (at
// which point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
// well as "prepend" and "append" variants of each of these functions.
func (menu menu) InsertItem(position int, item MenuItem) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.GMenuItem

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = C.gint(position)
	arg2 = (*C.GMenuItem)(item.Native())

	C.g_menu_insert_item(arg0, arg1, arg2)
}

// InsertSection: convenience function for inserting a section menu item
// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
// for a more flexible alternative.
func (menu menu) InsertSection(position int, label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GMenuModel)(section.Native())

	C.g_menu_insert_section(arg0, arg1, arg2, arg3)
}

// InsertSubmenu: convenience function for inserting a submenu menu item
// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
// for a more flexible alternative.
func (menu menu) InsertSubmenu(position int, label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = C.gint(position)
	arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GMenuModel)(submenu.Native())

	C.g_menu_insert_submenu(arg0, arg1, arg2, arg3)
}

// Prepend: convenience function for prepending a normal menu item to the
// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
// more flexible alternative.
func (menu menu) Prepend(label string, detailedAction string) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_menu_prepend(arg0, arg1, arg2)
}

// PrependItem prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (menu menu) PrependItem(item MenuItem) {
	var arg0 *C.GMenu
	var arg1 *C.GMenuItem

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.GMenuItem)(item.Native())

	C.g_menu_prepend_item(arg0, arg1)
}

// PrependSection: convenience function for prepending a section menu item
// to the start of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (menu menu) PrependSection(label string, section MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(section.Native())

	C.g_menu_prepend_section(arg0, arg1, arg2)
}

// PrependSubmenu: convenience function for prepending a submenu menu item
// to the start of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (menu menu) PrependSubmenu(label string, submenu MenuModel) {
	var arg0 *C.GMenu
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(submenu.Native())

	C.g_menu_prepend_submenu(arg0, arg1, arg2)
}

// Remove removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less
// than the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to
// the menu simply by copying their links and attributes (ie: identity of
// the item itself is not preserved).
func (menu menu) Remove(position int) {
	var arg0 *C.GMenu
	var arg1 C.gint

	arg0 = (*C.GMenu)(menu.Native())
	arg1 = C.gint(position)

	C.g_menu_remove(arg0, arg1)
}

// RemoveAll removes all items in the menu.
func (menu menu) RemoveAll() {
	var arg0 *C.GMenu

	arg0 = (*C.GMenu)(menu.Native())

	C.g_menu_remove_all(arg0)
}

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter interface {
	gextras.Objector

	// Name gets the name of the attribute at the current iterator position, as
	// a string.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute. If
	// that fails, then false is returned and there are no other effects.
	//
	// If successful, @name and @value are set to the name and value of the
	// attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in @name remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	GetNext() (outName string, value *glib.Variant, ok bool)
	// Value gets the value of the attribute at the current iterator position.
	//
	// The iterator is not advanced.
	Value() *glib.Variant
	// Next attempts to advance the iterator to the next (possibly first)
	// attribute.
	//
	// true is returned on success, or false if there are no more attributes.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first attribute (and determine if the first attribute
	// exists at all).
	Next() bool
}

// menuAttributeIter implements the MenuAttributeIter interface.
type menuAttributeIter struct {
	gextras.Objector
}

// WrapMenuAttributeIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuAttributeIter(obj *externglib.Object) MenuAttributeIter {
	return MenuAttributeIter{
		gextras.Objector: (obj),
	}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuAttributeIter(obj), nil
}

// Name gets the name of the attribute at the current iterator position, as
// a string.
//
// The iterator is not advanced.
func (iter menuAttributeIter) Name() string {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(iter.Native())

	ret := C.g_menu_attribute_iter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetNext: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) attribute. If
// that fails, then false is returned and there are no other effects.
//
// If successful, @name and @value are set to the name and value of the
// attribute that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
// will return the same values again.
//
// The value returned in @name remains valid for as long as the iterator
// remains at the current position. The value returned in @value must be
// unreffed using g_variant_unref() when it is no longer in use.
func (iter menuAttributeIter) GetNext() (outName string, value *glib.Variant, ok bool) {
	var arg0 *C.GMenuAttributeIter
	var arg1 **C.gchar    // out
	var arg2 **C.GVariant // out

	arg0 = (*C.GMenuAttributeIter)(iter.Native())

	ret := C.g_menu_attribute_iter_get_next(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 **glib.Variant
	var ret2 bool

	ret0 = C.GoString(arg1)

	ret1 = glib.WrapVariant(arg2)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// Value gets the value of the attribute at the current iterator position.
//
// The iterator is not advanced.
func (iter menuAttributeIter) Value() *glib.Variant {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(iter.Native())

	ret := C.g_menu_attribute_iter_get_value(arg0)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Next attempts to advance the iterator to the next (possibly first)
// attribute.
//
// true is returned on success, or false if there are no more attributes.
//
// You must call this function when you first acquire the iterator to
// advance it to the first attribute (and determine if the first attribute
// exists at all).
func (iter menuAttributeIter) Next() bool {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(iter.Native())

	ret := C.g_menu_attribute_iter_next(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

// menuItem implements the MenuItem interface.
type menuItem struct {
	gextras.Objector
}

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return MenuItem{
		gextras.Objector: (obj),
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem constructs a class MenuItem.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_menu_item_new(arg1, arg2)

	var ret0 MenuItem

	ret0 = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMenuItemFromModel constructs a class MenuItem.
func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var arg1 *C.GMenuModel
	var arg2 C.gint

	arg1 = (*C.GMenuModel)(model.Native())
	arg2 = C.gint(itemIndex)

	ret := C.g_menu_item_new_from_model(arg1, arg2)

	var ret0 MenuItem

	ret0 = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMenuItemSection constructs a class MenuItem.
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(section.Native())

	ret := C.g_menu_item_new_section(arg1, arg2)

	var ret0 MenuItem

	ret0 = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewMenuItemSubmenu constructs a class MenuItem.
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(submenu.Native())

	ret := C.g_menu_item_new_submenu(arg1, arg2)

	var ret0 MenuItem

	ret0 = WrapMenuItem(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AttributeValue queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this type,
// nil is returned. nil is also returned if the attribute simply does not
// exist.
func (menuItem menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(expectedType.Native())

	ret := C.g_menu_item_get_attribute_value(arg0, arg1, arg2)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Link queries the named @link on @menu_item.
func (menuItem menuItem) Link(link string) MenuModel {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_menu_item_get_link(arg0, arg1)

	var ret0 MenuModel

	ret0 = WrapMenuModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetActionAndTargetValue sets or unsets the "action" and "target"
// attributes of @menu_item.
//
// If @action is nil then both the "action" and "target" attributes are
// unset (and @target_value is ignored).
//
// If @action is non-nil then the "action" attribute is set. The "target"
// attribute is then set to the value of @target_value if it is non-nil or
// unset otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types)
// are expected to have the "action" attribute set to identify the action
// that they are associated with. The state type of the action help to
// determine the disposition of the menu item. See #GAction and Group for an
// overview of actions.
//
// In general, clicking on the menu item will result in activation of the
// named action with the "target" attribute given as the parameter to the
// action invocation. If the "target" attribute is not set then the action
// is invoked with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as
// a toggle menu item (ie: with a checkmark or equivalent indication). The
// item should be marked as 'toggled' or 'checked' when the boolean state is
// true.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The
// item should be marked as 'selected' when the string state is equal to the
// value of the @target property.
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_detailed_action() for two equivalent calls that are
// probably more convenient for most uses.
func (menuItem menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(targetValue.Native())

	C.g_menu_item_set_action_and_target_value(arg0, arg1, arg2)
}

// SetAttributeValue sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This can be one
// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
// name. Attribute names are restricted to lowercase characters, numbers and
// '-'. Furthermore, the names must begin with a lowercase character, must
// not end with a '-', and must not contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If @value is non-nil then it is used as the new value for the attribute.
// If @value is nil then the attribute is unset. If the @value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
func (menuItem menuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	C.g_menu_item_set_attribute_value(arg0, arg1, arg2)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute
// of @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (menuItem menuItem) SetDetailedAction(detailedAction string) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg1))

	C.g_menu_item_set_detailed_action(arg0, arg1)
}

// SetLabel sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-nil it is used as the label for the menu item. If it is
// nil then the label attribute is unset.
func (menuItem menuItem) SetLabel(label string) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))

	C.g_menu_item_set_label(arg0, arg1)
}

// SetLink creates a link from @menu_item to @model if non-nil, or unsets
// it.
//
// Links are used to establish a relationship between a particular menu item
// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
// create a section. Other types of link can be used, but there is no
// guarantee that clients will be able to make sense of them. Link types are
// restricted to lowercase characters, numbers and '-'. Furthermore, the
// names must begin with a lowercase character, must not end with a '-', and
// must not contain consecutive dashes.
func (menuItem menuItem) SetLink(link string, model MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.gchar
	var arg2 *C.GMenuModel

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GMenuModel)(model.Native())

	C.g_menu_item_set_link(arg0, arg1, arg2)
}

// SetSection sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is exactly
// as it sounds: the items from @section become a direct part of the menu
// that @menu_item is added to. See g_menu_item_new_section() for more
// information about what it means for a menu item to be a section.
func (menuItem menuItem) SetSection(section MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.GMenuModel

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.GMenuModel)(section.Native())

	C.g_menu_item_set_section(arg0, arg1)
}

// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-nil, it is linked to. If it is nil then the link is
// unset.
//
// The effect of having one menu appear as a submenu of another is exactly
// as it sounds.
func (menuItem menuItem) SetSubmenu(submenu MenuModel) {
	var arg0 *C.GMenuItem
	var arg1 *C.GMenuModel

	arg0 = (*C.GMenuItem)(menuItem.Native())
	arg1 = (*C.GMenuModel)(submenu.Native())

	C.g_menu_item_set_submenu(arg0, arg1)
}

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter interface {
	gextras.Objector

	// Name gets the name of the link at the current iterator position.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link. If that
	// fails, then false is returned and there are no other effects.
	//
	// If successful, @out_link and @value are set to the name and Model of the
	// link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_object_unref() when it is no longer in use.
	GetNext() (outLink string, value MenuModel, ok bool)
	// Value gets the linked Model at the current iterator position.
	//
	// The iterator is not advanced.
	Value() MenuModel
	// Next attempts to advance the iterator to the next (possibly first) link.
	//
	// true is returned on success, or false if there are no more links.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first link (and determine if the first link exists at
	// all).
	Next() bool
}

// menuLinkIter implements the MenuLinkIter interface.
type menuLinkIter struct {
	gextras.Objector
}

// WrapMenuLinkIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuLinkIter(obj *externglib.Object) MenuLinkIter {
	return MenuLinkIter{
		gextras.Objector: (obj),
	}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuLinkIter(obj), nil
}

// Name gets the name of the link at the current iterator position.
//
// The iterator is not advanced.
func (iter menuLinkIter) Name() string {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(iter.Native())

	ret := C.g_menu_link_iter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetNext: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then false is returned and there are no other effects.
//
// If successful, @out_link and @value are set to the name and Model of the
// link that has just been advanced to. At this point,
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
// the same values again.
//
// The value returned in @out_link remains valid for as long as the iterator
// remains at the current position. The value returned in @value must be
// unreffed using g_object_unref() when it is no longer in use.
func (iter menuLinkIter) GetNext() (outLink string, value MenuModel, ok bool) {
	var arg0 *C.GMenuLinkIter
	var arg1 **C.gchar      // out
	var arg2 **C.GMenuModel // out

	arg0 = (*C.GMenuLinkIter)(iter.Native())

	ret := C.g_menu_link_iter_get_next(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 MenuModel
	var ret2 bool

	ret0 = C.GoString(arg1)

	ret1 = WrapMenuModel(externglib.AssumeOwnership(unsafe.Pointer(arg2.Native())))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// Value gets the linked Model at the current iterator position.
//
// The iterator is not advanced.
func (iter menuLinkIter) Value() MenuModel {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(iter.Native())

	ret := C.g_menu_link_iter_get_value(arg0)

	var ret0 MenuModel

	ret0 = WrapMenuModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Next attempts to advance the iterator to the next (possibly first) link.
//
// true is returned on success, or false if there are no more links.
//
// You must call this function when you first acquire the iterator to
// advance it to the first link (and determine if the first link exists at
// all).
func (iter menuLinkIter) Next() bool {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(iter.Native())

	ret := C.g_menu_link_iter_next(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
//
// An example menu
//
// ! (menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
//
// A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel interface {
	gextras.Objector

	// ItemAttributeValue queries the item at position @item_index in @model for
	// the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemLink queries the item at position @item_index in @model for the link
	// specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	ItemLink(itemIndex int, link string) MenuModel
	// NItems: query the number of items in @model.
	NItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks(itemIndex int) MenuLinkIter
}

// menuModel implements the MenuModel interface.
type menuModel struct {
	gextras.Objector
}

// WrapMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuModel(obj *externglib.Object) MenuModel {
	return MenuModel{
		gextras.Objector: (obj),
	}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuModel(obj), nil
}

// ItemAttributeValue queries the item at position @item_index in @model for
// the attribute specified by @attribute.
//
// If @expected_type is non-nil then it specifies the expected type of the
// attribute. If it is nil then any type will be accepted.
//
// If the attribute exists and matches @expected_type (or if the expected
// type is unspecified) then the value is returned.
//
// If the attribute does not exist, or does not match the expected type then
// nil is returned.
func (model menuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GVariantType

	arg0 = (*C.GMenuModel)(model.Native())
	arg1 = C.gint(itemIndex)
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GVariantType)(expectedType.Native())

	ret := C.g_menu_model_get_item_attribute_value(arg0, arg1, arg2, arg3)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// ItemLink queries the item at position @item_index in @model for the link
// specified by @link.
//
// If the link exists, the linked Model is returned. If the link does not
// exist, nil is returned.
func (model menuModel) ItemLink(itemIndex int, link string) MenuModel {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GMenuModel)(model.Native())
	arg1 = C.gint(itemIndex)
	arg2 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_menu_model_get_item_link(arg0, arg1, arg2)

	var ret0 MenuModel

	ret0 = WrapMenuModel(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NItems: query the number of items in @model.
func (model menuModel) NItems() int {
	var arg0 *C.GMenuModel

	arg0 = (*C.GMenuModel)(model.Native())

	ret := C.g_menu_model_get_n_items(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsMutable queries if @model is mutable.
//
// An immutable Model will never emit the Model::items-changed signal.
// Consumers of the model may make optimisations accordingly.
func (model menuModel) IsMutable() bool {
	var arg0 *C.GMenuModel

	arg0 = (*C.GMenuModel)(model.Native())

	ret := C.g_menu_model_is_mutable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ItemsChanged requests emission of the Model::items-changed signal on
// @model.
//
// This function should never be called except by Model subclasses. Any
// other calls to this function will very likely lead to a violation of the
// interface of the model.
//
// The implementation should update its internal representation of the menu
// before emitting the signal. The implementation should further expect to
// receive queries about the new state of the menu (and particularly added
// menu items) while signal handlers are running.
//
// The implementation must dispatch this call directly from a mainloop entry
// and not in response to calls -- particularly those from the Model API.
// Said another way: the menu must not change while user code is running
// without returning to the mainloop.
func (model menuModel) ItemsChanged(position int, removed int, added int) {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GMenuModel)(model.Native())
	arg1 = C.gint(position)
	arg2 = C.gint(removed)
	arg3 = C.gint(added)

	C.g_menu_model_items_changed(arg0, arg1, arg2, arg3)
}

// IterateItemAttributes creates a AttributeIter to iterate over the
// attributes of the item at position @item_index in @model.
//
// You must free the iterator with g_object_unref() when you are done.
func (model menuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter {
	var arg0 *C.GMenuModel
	var arg1 C.gint

	arg0 = (*C.GMenuModel)(model.Native())
	arg1 = C.gint(itemIndex)

	ret := C.g_menu_model_iterate_item_attributes(arg0, arg1)

	var ret0 MenuAttributeIter

	ret0 = WrapMenuAttributeIter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// IterateItemLinks creates a LinkIter to iterate over the links of the item
// at position @item_index in @model.
//
// You must free the iterator with g_object_unref() when you are done.
func (model menuModel) IterateItemLinks(itemIndex int) MenuLinkIter {
	var arg0 *C.GMenuModel
	var arg1 C.gint

	arg0 = (*C.GMenuModel)(model.Native())
	arg1 = C.gint(itemIndex)

	ret := C.g_menu_model_iterate_item_links(arg0, arg1)

	var ret0 MenuLinkIter

	ret0 = WrapMenuLinkIter(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// MountOperation provides a mechanism for interacting with the user. It can be
// used for authenticating mountable operations, such as loop mounting files,
// hard drive partitions or server locations. It can also be used to ask the
// user questions or show a list of applications preventing unmount or eject
// operations from completing.
//
// Note that Operation is used for more than just #GMount objects – for example
// it is also used in g_drive_start() and g_drive_stop().
//
// Users should instantiate a subclass of this that implements all the various
// callbacks to show the required dialogs, such as MountOperation. If no user
// interaction is desired (for example when automounting filesystems at login
// time), usually nil can be passed, see each method taking a Operation for
// details.
//
// The term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
// TrueCrypt (https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system
// for encrypting file containers, partitions or whole disks, typically used
// with Windows. VeraCrypt (https://www.veracrypt.fr/) is a maintained fork of
// TrueCrypt with various improvements and auditing fixes.
type MountOperation interface {
	gextras.Objector

	// Anonymous: check to see whether the mount operation is being used for an
	// anonymous user.
	Anonymous() bool
	// Choice gets a choice from the mount operation.
	Choice() int
	// Domain gets the domain of the mount operation.
	Domain() string
	// IsTcryptHiddenVolume: check to see whether the mount operation is being
	// used for a TCRYPT hidden volume.
	IsTcryptHiddenVolume() bool
	// IsTcryptSystemVolume: check to see whether the mount operation is being
	// used for a TCRYPT system volume.
	IsTcryptSystemVolume() bool
	// Password gets a password from the mount operation.
	Password() string
	// PasswordSave gets the state of saving passwords for the mount operation.
	PasswordSave() PasswordSave
	// Pim gets a PIM from the mount operation.
	Pim() uint
	// Username: get the user name from the mount operation.
	Username() string
	// Reply emits the Operation::reply signal.
	Reply(result MountOperationResult)
	// SetAnonymous sets the mount operation to use an anonymous user if
	// @anonymous is true.
	SetAnonymous(anonymous bool)
	// SetChoice sets a default choice for the mount operation.
	SetChoice(choice int)
	// SetDomain sets the mount operation's domain.
	SetDomain(domain string)
	// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume
	// if @hidden_volume is true.
	SetIsTcryptHiddenVolume(hiddenVolume bool)
	// SetIsTcryptSystemVolume sets the mount operation to use a system volume
	// if @system_volume is true.
	SetIsTcryptSystemVolume(systemVolume bool)
	// SetPassword sets the mount operation's password to @password.
	SetPassword(password string)
	// SetPasswordSave sets the state of saving passwords for the mount
	// operation.
	SetPasswordSave(save PasswordSave)
	// SetPim sets the mount operation's PIM to @pim.
	SetPim(pim uint)
	// SetUsername sets the user name within @op to @username.
	SetUsername(username string)
}

// mountOperation implements the MountOperation interface.
type mountOperation struct {
	gextras.Objector
}

// WrapMountOperation wraps a GObject to the right type. It is
// primarily used internally.
func WrapMountOperation(obj *externglib.Object) MountOperation {
	return MountOperation{
		gextras.Objector: (obj),
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMountOperation(obj), nil
}

// NewMountOperation constructs a class MountOperation.
func NewMountOperation() MountOperation {

	ret := C.g_mount_operation_new()

	var ret0 MountOperation

	ret0 = WrapMountOperation(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Anonymous: check to see whether the mount operation is being used for an
// anonymous user.
func (op mountOperation) Anonymous() bool {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_anonymous(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Choice gets a choice from the mount operation.
func (op mountOperation) Choice() int {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_choice(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Domain gets the domain of the mount operation.
func (op mountOperation) Domain() string {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_domain(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsTcryptHiddenVolume: check to see whether the mount operation is being
// used for a TCRYPT hidden volume.
func (op mountOperation) IsTcryptHiddenVolume() bool {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_is_tcrypt_hidden_volume(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsTcryptSystemVolume: check to see whether the mount operation is being
// used for a TCRYPT system volume.
func (op mountOperation) IsTcryptSystemVolume() bool {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_is_tcrypt_system_volume(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Password gets a password from the mount operation.
func (op mountOperation) Password() string {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_password(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PasswordSave gets the state of saving passwords for the mount operation.
func (op mountOperation) PasswordSave() PasswordSave {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_password_save(arg0)

	var ret0 PasswordSave

	ret0 = PasswordSave(ret)

	return ret0
}

// Pim gets a PIM from the mount operation.
func (op mountOperation) Pim() uint {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_pim(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Username: get the user name from the mount operation.
func (op mountOperation) Username() string {
	var arg0 *C.GMountOperation

	arg0 = (*C.GMountOperation)(op.Native())

	ret := C.g_mount_operation_get_username(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Reply emits the Operation::reply signal.
func (op mountOperation) Reply(result MountOperationResult) {
	var arg0 *C.GMountOperation
	var arg1 C.GMountOperationResult

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = (C.GMountOperationResult)(result)

	C.g_mount_operation_reply(arg0, arg1)
}

// SetAnonymous sets the mount operation to use an anonymous user if
// @anonymous is true.
func (op mountOperation) SetAnonymous(anonymous bool) {
	var arg0 *C.GMountOperation
	var arg1 C.gboolean

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = gextras.Cbool(anonymous)

	C.g_mount_operation_set_anonymous(arg0, arg1)
}

// SetChoice sets a default choice for the mount operation.
func (op mountOperation) SetChoice(choice int) {
	var arg0 *C.GMountOperation
	var arg1 C.int

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = C.int(choice)

	C.g_mount_operation_set_choice(arg0, arg1)
}

// SetDomain sets the mount operation's domain.
func (op mountOperation) SetDomain(domain string) {
	var arg0 *C.GMountOperation
	var arg1 *C.char

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))

	C.g_mount_operation_set_domain(arg0, arg1)
}

// SetIsTcryptHiddenVolume sets the mount operation to use a hidden volume
// if @hidden_volume is true.
func (op mountOperation) SetIsTcryptHiddenVolume(hiddenVolume bool) {
	var arg0 *C.GMountOperation
	var arg1 C.gboolean

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = gextras.Cbool(hiddenVolume)

	C.g_mount_operation_set_is_tcrypt_hidden_volume(arg0, arg1)
}

// SetIsTcryptSystemVolume sets the mount operation to use a system volume
// if @system_volume is true.
func (op mountOperation) SetIsTcryptSystemVolume(systemVolume bool) {
	var arg0 *C.GMountOperation
	var arg1 C.gboolean

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = gextras.Cbool(systemVolume)

	C.g_mount_operation_set_is_tcrypt_system_volume(arg0, arg1)
}

// SetPassword sets the mount operation's password to @password.
func (op mountOperation) SetPassword(password string) {
	var arg0 *C.GMountOperation
	var arg1 *C.char

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg1))

	C.g_mount_operation_set_password(arg0, arg1)
}

// SetPasswordSave sets the state of saving passwords for the mount
// operation.
func (op mountOperation) SetPasswordSave(save PasswordSave) {
	var arg0 *C.GMountOperation
	var arg1 C.GPasswordSave

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = (C.GPasswordSave)(save)

	C.g_mount_operation_set_password_save(arg0, arg1)
}

// SetPim sets the mount operation's PIM to @pim.
func (op mountOperation) SetPim(pim uint) {
	var arg0 *C.GMountOperation
	var arg1 C.guint

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = C.guint(pim)

	C.g_mount_operation_set_pim(arg0, arg1)
}

// SetUsername sets the user name within @op to @username.
func (op mountOperation) SetUsername(username string) {
	var arg0 *C.GMountOperation
	var arg1 *C.char

	arg0 = (*C.GMountOperation)(op.Native())
	arg1 = (*C.gchar)(C.CString(username))
	defer C.free(unsafe.Pointer(arg1))

	C.g_mount_operation_set_username(arg0, arg1)
}

// NativeSocketAddress: a socket address of some unknown native type.
type NativeSocketAddress interface {
	SocketAddress
}

// nativeSocketAddress implements the NativeSocketAddress interface.
type nativeSocketAddress struct {
	SocketAddress
}

// WrapNativeSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeSocketAddress(obj *externglib.Object) NativeSocketAddress {
	return NativeSocketAddress{
		SocketAddress: WrapSocketAddress(obj),
	}
}

func marshalNativeSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeSocketAddress(obj), nil
}

// NewNativeSocketAddress constructs a class NativeSocketAddress.
func NewNativeSocketAddress(native interface{}, len uint) NativeSocketAddress {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(native))
	arg2 = C.gsize(len)

	ret := C.g_native_socket_address_new(arg1, arg2)

	var ret0 NativeSocketAddress

	ret0 = WrapNativeSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

type NativeVolumeMonitor interface {
	VolumeMonitor
}

// nativeVolumeMonitor implements the NativeVolumeMonitor interface.
type nativeVolumeMonitor struct {
	VolumeMonitor
}

// WrapNativeVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapNativeVolumeMonitor(obj *externglib.Object) NativeVolumeMonitor {
	return NativeVolumeMonitor{
		VolumeMonitor: WrapVolumeMonitor(obj),
	}
}

func marshalNativeVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNativeVolumeMonitor(obj), nil
}

// NetworkAddress provides an easy way to resolve a hostname and then attempt to
// connect to that host, handling the possibility of multiple IP addresses and
// multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long as this
// object is kept alive which may have unexpected results if alive for too long.
//
// See Connectable for an example of using the connectable interface.
type NetworkAddress interface {
	gextras.Objector

	// Hostname gets @addr's hostname. This might be either UTF-8 or
	// ASCII-encoded, depending on what @addr was created with.
	Hostname() string
	// Port gets @addr's port number
	Port() uint16
	// Scheme gets @addr's scheme
	Scheme() string
}

// networkAddress implements the NetworkAddress interface.
type networkAddress struct {
	gextras.Objector
}

// WrapNetworkAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkAddress(obj *externglib.Object) NetworkAddress {
	return NetworkAddress{
		gextras.Objector: (obj),
	}
}

func marshalNetworkAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkAddress(obj), nil
}

// NewNetworkAddress constructs a class NetworkAddress.
func NewNetworkAddress(hostname string, port uint16) NetworkAddress {
	var arg1 *C.gchar
	var arg2 C.guint16

	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(port)

	ret := C.g_network_address_new(arg1, arg2)

	var ret0 NetworkAddress

	ret0 = WrapNetworkAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewNetworkAddressLoopback constructs a class NetworkAddress.
func NewNetworkAddressLoopback(port uint16) NetworkAddress {
	var arg1 C.guint16

	arg1 = C.guint16(port)

	ret := C.g_network_address_new_loopback(arg1)

	var ret0 NetworkAddress

	ret0 = WrapNetworkAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Hostname gets @addr's hostname. This might be either UTF-8 or
// ASCII-encoded, depending on what @addr was created with.
func (addr networkAddress) Hostname() string {
	var arg0 *C.GNetworkAddress

	arg0 = (*C.GNetworkAddress)(addr.Native())

	ret := C.g_network_address_get_hostname(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Port gets @addr's port number
func (addr networkAddress) Port() uint16 {
	var arg0 *C.GNetworkAddress

	arg0 = (*C.GNetworkAddress)(addr.Native())

	ret := C.g_network_address_get_port(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// Scheme gets @addr's scheme
func (addr networkAddress) Scheme() string {
	var arg0 *C.GNetworkAddress

	arg0 = (*C.GNetworkAddress)(addr.Native())

	ret := C.g_network_address_get_scheme(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NetworkService: like Address does with hostnames, Service provides an easy
// way to resolve a SRV record, and then attempt to connect to one of the hosts
// that implements that service, handling service priority/weighting, multiple
// IP addresses, and multiple address families.
//
// See Target for more information about SRV records, and see Connectable for an
// example of using the connectable interface.
type NetworkService interface {
	gextras.Objector

	// Domain gets the domain that @srv serves. This might be either UTF-8 or
	// ASCII-encoded, depending on what @srv was created with.
	Domain() string
	// Protocol gets @srv's protocol name (eg, "tcp").
	Protocol() string
	// Scheme gets the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	Scheme() string
	// Service gets @srv's service name (eg, "ldap").
	Service() string
	// SetScheme set's the URI scheme used to resolve proxies. By default, the
	// service name is used as scheme.
	SetScheme(scheme string)
}

// networkService implements the NetworkService interface.
type networkService struct {
	gextras.Objector
}

// WrapNetworkService wraps a GObject to the right type. It is
// primarily used internally.
func WrapNetworkService(obj *externglib.Object) NetworkService {
	return NetworkService{
		gextras.Objector: (obj),
	}
}

func marshalNetworkService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNetworkService(obj), nil
}

// NewNetworkService constructs a class NetworkService.
func NewNetworkService(service string, protocol string, domain string) NetworkService {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_network_service_new(arg1, arg2, arg3)

	var ret0 NetworkService

	ret0 = WrapNetworkService(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Domain gets the domain that @srv serves. This might be either UTF-8 or
// ASCII-encoded, depending on what @srv was created with.
func (srv networkService) Domain() string {
	var arg0 *C.GNetworkService

	arg0 = (*C.GNetworkService)(srv.Native())

	ret := C.g_network_service_get_domain(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Protocol gets @srv's protocol name (eg, "tcp").
func (srv networkService) Protocol() string {
	var arg0 *C.GNetworkService

	arg0 = (*C.GNetworkService)(srv.Native())

	ret := C.g_network_service_get_protocol(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Scheme gets the URI scheme used to resolve proxies. By default, the
// service name is used as scheme.
func (srv networkService) Scheme() string {
	var arg0 *C.GNetworkService

	arg0 = (*C.GNetworkService)(srv.Native())

	ret := C.g_network_service_get_scheme(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Service gets @srv's service name (eg, "ldap").
func (srv networkService) Service() string {
	var arg0 *C.GNetworkService

	arg0 = (*C.GNetworkService)(srv.Native())

	ret := C.g_network_service_get_service(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetScheme set's the URI scheme used to resolve proxies. By default, the
// service name is used as scheme.
func (srv networkService) SetScheme(scheme string) {
	var arg0 *C.GNetworkService
	var arg1 *C.gchar

	arg0 = (*C.GNetworkService)(srv.Native())
	arg1 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg1))

	C.g_network_service_set_scheme(arg0, arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

// notification implements the Notification interface.
type notification struct {
	gextras.Objector
}

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return Notification{
		gextras.Objector: (obj),
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

// NewNotification constructs a class Notification.
func NewNotification(title string) Notification {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_notification_new(arg1)

	var ret0 Notification

	ret0 = WrapNotification(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddButton adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an application-wide
// action (starting with "app."). If @detailed_action contains a target, the
// action will be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
func (notification notification) AddButton(label string, detailedAction string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg2))

	C.g_notification_add_button(arg0, arg1, arg2)
}

// AddButtonWithTargetValue adds a button to @notification that activates
// @action when clicked. @action must be an application-wide action (it must
// start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
func (notification notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.GVariant

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GVariant)(target.Native())

	C.g_notification_add_button_with_target_value(arg0, arg1, arg2, arg3)
}

// SetBody sets the body of @notification to @body.
func (notification notification) SetBody(body string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_body(arg0, arg1)
}

// SetDefaultAction sets the default action of @notification to
// @detailed_action. This action is activated when the notification is
// clicked on.
//
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the given
// action will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (notification notification) SetDefaultAction(detailedAction string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_default_action(arg0, arg1)
}

// SetDefaultActionAndTargetValue sets the default action of @notification
// to @action. This action is activated when the notification is clicked on.
// It must be an application-wide action (start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (notification notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var arg0 *C.GNotification
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(target.Native())

	C.g_notification_set_default_action_and_target_value(arg0, arg1, arg2)
}

// SetPriority sets the priority of @notification to @priority. See Priority
// for possible values.
func (notification notification) SetPriority(priority NotificationPriority) {
	var arg0 *C.GNotification
	var arg1 C.GNotificationPriority

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (C.GNotificationPriority)(priority)

	C.g_notification_set_priority(arg0, arg1)
}

// SetTitle sets the title of @notification to @title.
func (notification notification) SetTitle(title string) {
	var arg0 *C.GNotification
	var arg1 *C.gchar

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.g_notification_set_title(arg0, arg1)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
func (notification notification) SetUrgent(urgent bool) {
	var arg0 *C.GNotification
	var arg1 C.gboolean

	arg0 = (*C.GNotification)(notification.Native())
	arg1 = gextras.Cbool(urgent)

	C.g_notification_set_urgent(arg0, arg1)
}

// OutputStream has functions to write to a stream (g_output_stream_write()), to
// close a stream (g_output_stream_close()) and to flush pending writes
// (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream interface {
	gextras.Objector

	// ClearPending clears the pending flag on @stream.
	ClearPending()
	// Close closes the stream, releasing resources related to it.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but there some
	// streams can use a faster close that doesn't block to e.g. check errors.
	// On cancellation (as with any error) there is no guarantee that all
	// written data will reach the target.
	Close(cancellable Cancellable) bool
	// CloseAsync requests an asynchronous close of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_output_stream_close_finish() to get the
	// result of the operation.
	//
	// For behaviour details see g_output_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// Flush forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	//
	// This function is optional for inherited classes.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Flush(cancellable Cancellable) bool
	// FlushAsync forces an asynchronous write of all user-space buffered data
	// for the given @stream. For behaviour details see g_output_stream_flush().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_output_stream_flush_finish() to get the result of the operation.
	FlushAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// HasPending checks if an output stream has pending actions.
	HasPending() bool
	// IsClosed checks if an output stream has already been closed.
	IsClosed() bool
	// IsClosing checks if an output stream is being closed. This can be used
	// inside e.g. a flush implementation to see if the flush (or other i/o
	// operation) is called from within the closing operation.
	IsClosing() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	SetPending() bool
	// Splice splices an input stream into an output stream.
	Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) int
	// SpliceAsync splices a stream asynchronously. When the operation is
	// finished @callback will be called. You can then call
	// g_output_stream_splice_finish() to get the result of the operation.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_splice().
	SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// WriteBytes: a wrapper function for g_output_stream_write() which takes a
	// #GBytes as input. This can be more convenient for use by language
	// bindings or in other cases where the refcounted nature of #GBytes is
	// helpful over a bare pointer interface.
	//
	// However, note that this function may still perform partial writes, just
	// like g_output_stream_write(). If that occurs, to continue writing, you
	// will need to create a new #GBytes containing just the remaining bytes,
	// using g_bytes_new_from_bytes(). Passing the same #GBytes instance
	// multiple times potentially can result in duplicated data in the output
	// stream.
	WriteBytes(bytes *glib.Bytes, cancellable Cancellable) int
	// WriteBytesAsync: this function is similar to
	// g_output_stream_write_async(), but takes a #GBytes as input. Due to the
	// refcounted nature of #GBytes, this allows the stream to avoid taking a
	// copy of the data.
	//
	// However, note that this function may still perform partial writes, just
	// like g_output_stream_write_async(). If that occurs, to continue writing,
	// you will need to create a new #GBytes containing just the remaining
	// bytes, using g_bytes_new_from_bytes(). Passing the same #GBytes instance
	// multiple times potentially can result in duplicated data in the output
	// stream.
	//
	// For the synchronous, blocking version of this function, see
	// g_output_stream_write_bytes().
	WriteBytesAsync(bytes *glib.Bytes, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// outputStream implements the OutputStream interface.
type outputStream struct {
	gextras.Objector
}

// WrapOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutputStream(obj *externglib.Object) OutputStream {
	return OutputStream{
		gextras.Objector: (obj),
	}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutputStream(obj), nil
}

// ClearPending clears the pending flag on @stream.
func (stream outputStream) ClearPending() {
	var arg0 *C.GOutputStream

	arg0 = (*C.GOutputStream)(stream.Native())

	C.g_output_stream_clear_pending(arg0)
}

// Close closes the stream, releasing resources related to it.
//
// Once the stream is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
// error.
//
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
//
// Streams will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are
// released as early as possible.
//
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for
// the individual stream for details.
//
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to close
// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
// important to check and report the error to the user, otherwise there
// might be a loss of data as all data might not be written.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but there some
// streams can use a faster close that doesn't block to e.g. check errors.
// On cancellation (as with any error) there is no guarantee that all
// written data will reach the target.
func (stream outputStream) Close(cancellable Cancellable) bool {
	var arg0 *C.GOutputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_output_stream_close(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CloseAsync requests an asynchronous close of the stream, releasing
// resources related to it. When the operation is finished @callback will be
// called. You can then call g_output_stream_close_finish() to get the
// result of the operation.
//
// For behaviour details see g_output_stream_close().
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
func (stream outputStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GOutputStream
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_output_stream_close_async(arg0, arg1, arg2, arg3)
}

// Flush forces a write of all user-space buffered data for the given
// @stream. Will block during the operation. Closing the stream will
// implicitly cause a flush.
//
// This function is optional for inherited classes.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (stream outputStream) Flush(cancellable Cancellable) bool {
	var arg0 *C.GOutputStream
	var arg1 *C.GCancellable

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_output_stream_flush(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FlushAsync forces an asynchronous write of all user-space buffered data
// for the given @stream. For behaviour details see g_output_stream_flush().
//
// When the operation is finished @callback will be called. You can then
// call g_output_stream_flush_finish() to get the result of the operation.
func (stream outputStream) FlushAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GOutputStream
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_output_stream_flush_async(arg0, arg1, arg2, arg3)
}

// HasPending checks if an output stream has pending actions.
func (stream outputStream) HasPending() bool {
	var arg0 *C.GOutputStream

	arg0 = (*C.GOutputStream)(stream.Native())

	ret := C.g_output_stream_has_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsClosed checks if an output stream has already been closed.
func (stream outputStream) IsClosed() bool {
	var arg0 *C.GOutputStream

	arg0 = (*C.GOutputStream)(stream.Native())

	ret := C.g_output_stream_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsClosing checks if an output stream is being closed. This can be used
// inside e.g. a flush implementation to see if the flush (or other i/o
// operation) is called from within the closing operation.
func (stream outputStream) IsClosing() bool {
	var arg0 *C.GOutputStream

	arg0 = (*C.GOutputStream)(stream.Native())

	ret := C.g_output_stream_is_closing(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetPending sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return false and set @error.
func (stream outputStream) SetPending() bool {
	var arg0 *C.GOutputStream

	arg0 = (*C.GOutputStream)(stream.Native())

	ret := C.g_output_stream_set_pending(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Splice splices an input stream into an output stream.
func (stream outputStream) Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) int {
	var arg0 *C.GOutputStream
	var arg1 *C.GInputStream
	var arg2 C.GOutputStreamSpliceFlags
	var arg3 *C.GCancellable

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GInputStream)(source.Native())
	arg2 = (C.GOutputStreamSpliceFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_output_stream_splice(arg0, arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SpliceAsync splices a stream asynchronously. When the operation is
// finished @callback will be called. You can then call
// g_output_stream_splice_finish() to get the result of the operation.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_splice().
func (stream outputStream) SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GOutputStream
	var arg1 *C.GInputStream
	var arg2 C.GOutputStreamSpliceFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GInputStream)(source.Native())
	arg2 = (C.GOutputStreamSpliceFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_output_stream_splice_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// WriteBytes: a wrapper function for g_output_stream_write() which takes a
// #GBytes as input. This can be more convenient for use by language
// bindings or in other cases where the refcounted nature of #GBytes is
// helpful over a bare pointer interface.
//
// However, note that this function may still perform partial writes, just
// like g_output_stream_write(). If that occurs, to continue writing, you
// will need to create a new #GBytes containing just the remaining bytes,
// using g_bytes_new_from_bytes(). Passing the same #GBytes instance
// multiple times potentially can result in duplicated data in the output
// stream.
func (stream outputStream) WriteBytes(bytes *glib.Bytes, cancellable Cancellable) int {
	var arg0 *C.GOutputStream
	var arg1 *C.GBytes
	var arg2 *C.GCancellable

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GBytes)(bytes.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_output_stream_write_bytes(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// WriteBytesAsync: this function is similar to
// g_output_stream_write_async(), but takes a #GBytes as input. Due to the
// refcounted nature of #GBytes, this allows the stream to avoid taking a
// copy of the data.
//
// However, note that this function may still perform partial writes, just
// like g_output_stream_write_async(). If that occurs, to continue writing,
// you will need to create a new #GBytes containing just the remaining
// bytes, using g_bytes_new_from_bytes(). Passing the same #GBytes instance
// multiple times potentially can result in duplicated data in the output
// stream.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_write_bytes().
func (stream outputStream) WriteBytesAsync(bytes *glib.Bytes, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GOutputStream
	var arg1 *C.GBytes
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GOutputStream)(stream.Native())
	arg1 = (*C.GBytes)(bytes.Native())
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_output_stream_write_bytes_async(arg0, arg1, arg2, arg3, arg4)
}

// Permission: a #GPermission represents the status of the caller's permission
// to perform a certain action.
//
// You can query if the action is currently allowed and if it is possible to
// acquire the permission so that the action will be allowed in the future.
//
// There is also an API to actually acquire the permission and one to release
// it.
//
// As an example, a #GPermission might represent the ability for the user to
// write to a #GSettings object. This #GPermission object could then be used to
// decide if it is appropriate to show a "Click here to unlock" button in a
// dialog and to provide the mechanism to invoke when that button is clicked.
type Permission interface {
	gextras.Objector

	// Acquire attempts to acquire the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. A simple example is that a
	// dialog may appear asking the user to enter their password.
	//
	// You should check with g_permission_get_can_acquire() before calling this
	// function.
	//
	// If the permission is acquired then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_acquire_async() for the
	// non-blocking version.
	Acquire(cancellable Cancellable) bool
	// AcquireAsync attempts to acquire the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_acquire().
	AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// Allowed gets the value of the 'allowed' property. This property is true
	// if the caller currently has permission to perform the action that
	// @permission represents the permission to perform.
	Allowed() bool
	// CanAcquire gets the value of the 'can-acquire' property. This property is
	// true if it is generally possible to acquire the permission by calling
	// g_permission_acquire().
	CanAcquire() bool
	// CanRelease gets the value of the 'can-release' property. This property is
	// true if it is generally possible to release the permission by calling
	// g_permission_release().
	CanRelease() bool
	// ImplUpdate: this function is called by the #GPermission implementation to
	// update the properties of the permission. You should never call this
	// function except from a #GPermission implementation.
	//
	// GObject notify signals are generated, as appropriate.
	ImplUpdate(allowed bool, canAcquire bool, canRelease bool)
	// Release attempts to release the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. In most cases the permission
	// will be dropped immediately without further action.
	//
	// You should check with g_permission_get_can_release() before calling this
	// function.
	//
	// If the permission is released then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_release_async() for the
	// non-blocking version.
	Release(cancellable Cancellable) bool
	// ReleaseAsync attempts to release the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_release().
	ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback)
}

// permission implements the Permission interface.
type permission struct {
	gextras.Objector
}

// WrapPermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapPermission(obj *externglib.Object) Permission {
	return Permission{
		gextras.Objector: (obj),
	}
}

func marshalPermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPermission(obj), nil
}

// Acquire attempts to acquire the permission represented by @permission.
//
// The precise method by which this happens depends on the permission and
// the underlying authentication mechanism. A simple example is that a
// dialog may appear asking the user to enter their password.
//
// You should check with g_permission_get_can_acquire() before calling this
// function.
//
// If the permission is acquired then true is returned. Otherwise, false is
// returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that user
// interaction is required). See g_permission_acquire_async() for the
// non-blocking version.
func (permission permission) Acquire(cancellable Cancellable) bool {
	var arg0 *C.GPermission
	var arg1 *C.GCancellable

	arg0 = (*C.GPermission)(permission.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_permission_acquire(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AcquireAsync attempts to acquire the permission represented by
// @permission.
//
// This is the first half of the asynchronous version of
// g_permission_acquire().
func (permission permission) AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GPermission
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GPermission)(permission.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_permission_acquire_async(arg0, arg1, arg2)
}

// Allowed gets the value of the 'allowed' property. This property is true
// if the caller currently has permission to perform the action that
// @permission represents the permission to perform.
func (permission permission) Allowed() bool {
	var arg0 *C.GPermission

	arg0 = (*C.GPermission)(permission.Native())

	ret := C.g_permission_get_allowed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CanAcquire gets the value of the 'can-acquire' property. This property is
// true if it is generally possible to acquire the permission by calling
// g_permission_acquire().
func (permission permission) CanAcquire() bool {
	var arg0 *C.GPermission

	arg0 = (*C.GPermission)(permission.Native())

	ret := C.g_permission_get_can_acquire(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CanRelease gets the value of the 'can-release' property. This property is
// true if it is generally possible to release the permission by calling
// g_permission_release().
func (permission permission) CanRelease() bool {
	var arg0 *C.GPermission

	arg0 = (*C.GPermission)(permission.Native())

	ret := C.g_permission_get_can_release(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ImplUpdate: this function is called by the #GPermission implementation to
// update the properties of the permission. You should never call this
// function except from a #GPermission implementation.
//
// GObject notify signals are generated, as appropriate.
func (permission permission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	var arg0 *C.GPermission
	var arg1 C.gboolean
	var arg2 C.gboolean
	var arg3 C.gboolean

	arg0 = (*C.GPermission)(permission.Native())
	arg1 = gextras.Cbool(allowed)
	arg2 = gextras.Cbool(canAcquire)
	arg3 = gextras.Cbool(canRelease)

	C.g_permission_impl_update(arg0, arg1, arg2, arg3)
}

// Release attempts to release the permission represented by @permission.
//
// The precise method by which this happens depends on the permission and
// the underlying authentication mechanism. In most cases the permission
// will be dropped immediately without further action.
//
// You should check with g_permission_get_can_release() before calling this
// function.
//
// If the permission is released then true is returned. Otherwise, false is
// returned and @error is set appropriately.
//
// This call is blocking, likely for a very long time (in the case that user
// interaction is required). See g_permission_release_async() for the
// non-blocking version.
func (permission permission) Release(cancellable Cancellable) bool {
	var arg0 *C.GPermission
	var arg1 *C.GCancellable

	arg0 = (*C.GPermission)(permission.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_permission_release(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ReleaseAsync attempts to release the permission represented by
// @permission.
//
// This is the first half of the asynchronous version of
// g_permission_release().
func (permission permission) ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GPermission
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GPermission)(permission.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_permission_release_async(arg0, arg1, arg2)
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector
}

// propertyAction implements the PropertyAction interface.
type propertyAction struct {
	gextras.Objector
}

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return PropertyAction{
		gextras.Objector: (obj),
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

// NewPropertyAction constructs a class PropertyAction.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())
	arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_property_action_new(arg1, arg2, arg3)

	var ret0 PropertyAction

	ret0 = WrapPropertyAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ProxyAddress: support for proxied SocketAddress.
type ProxyAddress interface {
	InetSocketAddress

	// DestinationHostname gets @proxy's destination hostname; that is, the name
	// of the host that will be connected to via the proxy, not the name of the
	// proxy itself.
	DestinationHostname() string
	// DestinationPort gets @proxy's destination port; that is, the port on the
	// destination host that will be connected to via the proxy, not the port
	// number of the proxy itself.
	DestinationPort() uint16
	// DestinationProtocol gets the protocol that is being spoken to the
	// destination server; eg, "http" or "ftp".
	DestinationProtocol() string
	// Password gets @proxy's password.
	Password() string
	// Protocol gets @proxy's protocol. eg, "socks" or "http"
	Protocol() string
	// URI gets the proxy URI that @proxy was constructed from.
	URI() string
	// Username gets @proxy's username.
	Username() string
}

// proxyAddress implements the ProxyAddress interface.
type proxyAddress struct {
	InetSocketAddress
}

// WrapProxyAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapProxyAddress(obj *externglib.Object) ProxyAddress {
	return ProxyAddress{
		InetSocketAddress: WrapInetSocketAddress(obj),
	}
}

func marshalProxyAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProxyAddress(obj), nil
}

// NewProxyAddress constructs a class ProxyAddress.
func NewProxyAddress(inetaddr InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) ProxyAddress {
	var arg1 *C.GInetAddress
	var arg2 C.guint16
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.guint16
	var arg6 *C.gchar
	var arg7 *C.gchar

	arg1 = (*C.GInetAddress)(inetaddr.Native())
	arg2 = C.guint16(port)
	arg3 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(destHostname))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = C.guint16(destPort)
	arg6 = (*C.gchar)(C.CString(username))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.gchar)(C.CString(password))
	defer C.free(unsafe.Pointer(arg7))

	ret := C.g_proxy_address_new(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ProxyAddress

	ret0 = WrapProxyAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DestinationHostname gets @proxy's destination hostname; that is, the name
// of the host that will be connected to via the proxy, not the name of the
// proxy itself.
func (proxy proxyAddress) DestinationHostname() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_destination_hostname(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DestinationPort gets @proxy's destination port; that is, the port on the
// destination host that will be connected to via the proxy, not the port
// number of the proxy itself.
func (proxy proxyAddress) DestinationPort() uint16 {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_destination_port(arg0)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// DestinationProtocol gets the protocol that is being spoken to the
// destination server; eg, "http" or "ftp".
func (proxy proxyAddress) DestinationProtocol() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_destination_protocol(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Password gets @proxy's password.
func (proxy proxyAddress) Password() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_password(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Protocol gets @proxy's protocol. eg, "socks" or "http"
func (proxy proxyAddress) Protocol() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_protocol(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// URI gets the proxy URI that @proxy was constructed from.
func (proxy proxyAddress) URI() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Username gets @proxy's username.
func (proxy proxyAddress) Username() string {
	var arg0 *C.GProxyAddress

	arg0 = (*C.GProxyAddress)(proxy.Native())

	ret := C.g_proxy_address_get_username(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ProxyAddressEnumerator is a wrapper around AddressEnumerator which takes the
// Address instances returned by the AddressEnumerator and wraps them in Address
// instances, using the given AddressEnumerator:proxy-resolver.
//
// This enumerator will be returned (for example, by
// g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
// there should be no need to manually wrap a AddressEnumerator instance with
// one.
type ProxyAddressEnumerator interface {
	SocketAddressEnumerator
}

// proxyAddressEnumerator implements the ProxyAddressEnumerator interface.
type proxyAddressEnumerator struct {
	SocketAddressEnumerator
}

// WrapProxyAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapProxyAddressEnumerator(obj *externglib.Object) ProxyAddressEnumerator {
	return ProxyAddressEnumerator{
		SocketAddressEnumerator: WrapSocketAddressEnumerator(obj),
	}
}

func marshalProxyAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProxyAddressEnumerator(obj), nil
}

// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver interface {
	gextras.Objector

	// LookupByAddress: synchronously reverse-resolves @address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	LookupByAddress(address InetAddress, cancellable Cancellable) string
	// LookupByAddressAsync begins asynchronously reverse-resolving @address to
	// determine its associated hostname, and eventually calls @callback, which
	// must call g_resolver_lookup_by_address_finish() to get the final result.
	LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupByName: synchronously resolves @hostname to determine its
	// associated IP address(es). @hostname may be an ASCII-only or UTF-8
	// hostname, or the textual form of an IP address (in which case this just
	// becomes a wrapper around g_inet_address_new_from_string()).
	//
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// Address, sorted in order of preference and guaranteed to not contain
	// duplicates. That is, if using the result to connect to @hostname, you
	// should attempt to connect to the first address first, then the second if
	// the first fails, etc. If you are using the result to listen on a socket,
	// it is appropriate to add each result using e.g.
	// g_socket_listener_add_address().
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to a socket on the resolved IP address, it
	// may be easier to create a Address and use its Connectable interface.
	LookupByName(hostname string, cancellable Cancellable) *glib.List
	// LookupByNameAsync begins asynchronously resolving @hostname to determine
	// its associated IP address(es), and eventually calls @callback, which must
	// call g_resolver_lookup_by_name_finish() to get the result. See
	// g_resolver_lookup_by_name() for more details.
	LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in
	// that you can modify the lookup behavior with @flags. For example this can
	// be used to limit results with RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) *glib.List
	// LookupByNameWithFlagsAsync begins asynchronously resolving @hostname to
	// determine its associated IP address(es), and eventually calls @callback,
	// which must call g_resolver_lookup_by_name_with_flags_finish() to get the
	// result. See g_resolver_lookup_by_name() for more details.
	LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupRecords: synchronously performs a DNS record lookup for the given
	// @rrname and returns a list of records as #GVariant tuples. See RecordType
	// for information on what the records contain for each @record_type.
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	LookupRecords(rrname string, recordType ResolverRecordType, cancellable Cancellable) *glib.List
	// LookupRecordsAsync begins asynchronously performing a DNS lookup for the
	// given @rrname, and eventually calls @callback, which must call
	// g_resolver_lookup_records_finish() to get the final result. See
	// g_resolver_lookup_records() for more details.
	LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupService: synchronously performs a DNS SRV lookup for the given
	// @service and @protocol in the given @domain and returns an array of
	// Target. @domain may be an ASCII-only or UTF-8 hostname. Note also that
	// the @service and @protocol arguments do not include the leading
	// underscore that appears in the actual DNS entry.
	//
	// On success, g_resolver_lookup_service() will return a non-empty #GList of
	// Target, sorted in order of preference. (That is, you should attempt to
	// connect to the first target first, then the second if the first fails,
	// etc.)
	//
	// If the DNS resolution fails, @error (if non-nil) will be set to a value
	// from Error and nil will be returned.
	//
	// If @cancellable is non-nil, it can be used to cancel the operation, in
	// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to the service, it is usually easier to
	// create a Service and use its Connectable interface.
	LookupService(service string, protocol string, domain string, cancellable Cancellable) *glib.List
	// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for
	// the given @service and @protocol in the given @domain, and eventually
	// calls @callback, which must call g_resolver_lookup_service_finish() to
	// get the final result. See g_resolver_lookup_service() for more details.
	LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback)
	// SetDefault sets @resolver to be the application's default resolver
	// (reffing @resolver, and unreffing the previous default resolver, if any).
	// Future calls to g_resolver_get_default() will return this resolver.
	//
	// This can be used if an application wants to perform any sort of DNS
	// caching or "pinning"; it can implement its own #GResolver that calls the
	// original default resolver for DNS operations, and implements its own
	// cache policies on top of that, and then set itself as the default
	// resolver for all later code to use.
	SetDefault()
}

// resolver implements the Resolver interface.
type resolver struct {
	gextras.Objector
}

// WrapResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapResolver(obj *externglib.Object) Resolver {
	return Resolver{
		gextras.Objector: (obj),
	}
}

func marshalResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapResolver(obj), nil
}

// LookupByAddress: synchronously reverse-resolves @address to determine its
// associated hostname.
//
// If the DNS resolution fails, @error (if non-nil) will be set to a value
// from Error.
//
// If @cancellable is non-nil, it can be used to cancel the operation, in
// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
func (resolver resolver) LookupByAddress(address InetAddress, cancellable Cancellable) string {
	var arg0 *C.GResolver
	var arg1 *C.GInetAddress
	var arg2 *C.GCancellable

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.GInetAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_resolver_lookup_by_address(arg0, arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// LookupByAddressAsync begins asynchronously reverse-resolving @address to
// determine its associated hostname, and eventually calls @callback, which
// must call g_resolver_lookup_by_address_finish() to get the final result.
func (resolver resolver) LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GResolver
	var arg1 *C.GInetAddress
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.GInetAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_resolver_lookup_by_address_async(arg0, arg1, arg2, arg3)
}

// LookupByName: synchronously resolves @hostname to determine its
// associated IP address(es). @hostname may be an ASCII-only or UTF-8
// hostname, or the textual form of an IP address (in which case this just
// becomes a wrapper around g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to @hostname, you
// should attempt to connect to the first address first, then the second if
// the first fails, etc. If you are using the result to listen on a socket,
// it is appropriate to add each result using e.g.
// g_socket_listener_add_address().
//
// If the DNS resolution fails, @error (if non-nil) will be set to a value
// from Error and nil will be returned.
//
// If @cancellable is non-nil, it can be used to cancel the operation, in
// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address, it
// may be easier to create a Address and use its Connectable interface.
func (resolver resolver) LookupByName(hostname string, cancellable Cancellable) *glib.List {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 *C.GCancellable

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_resolver_lookup_by_name(arg0, arg1, arg2)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LookupByNameAsync begins asynchronously resolving @hostname to determine
// its associated IP address(es), and eventually calls @callback, which must
// call g_resolver_lookup_by_name_finish() to get the result. See
// g_resolver_lookup_by_name() for more details.
func (resolver resolver) LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_resolver_lookup_by_name_async(arg0, arg1, arg2, arg3)
}

// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in
// that you can modify the lookup behavior with @flags. For example this can
// be used to limit results with RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
func (resolver resolver) LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) *glib.List {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 C.GResolverNameLookupFlags
	var arg3 *C.GCancellable

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResolverNameLookupFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_resolver_lookup_by_name_with_flags(arg0, arg1, arg2, arg3)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LookupByNameWithFlagsAsync begins asynchronously resolving @hostname to
// determine its associated IP address(es), and eventually calls @callback,
// which must call g_resolver_lookup_by_name_with_flags_finish() to get the
// result. See g_resolver_lookup_by_name() for more details.
func (resolver resolver) LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 C.GResolverNameLookupFlags
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(hostname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResolverNameLookupFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_resolver_lookup_by_name_with_flags_async(arg0, arg1, arg2, arg3, arg4)
}

// LookupRecords: synchronously performs a DNS record lookup for the given
// @rrname and returns a list of records as #GVariant tuples. See RecordType
// for information on what the records contain for each @record_type.
//
// If the DNS resolution fails, @error (if non-nil) will be set to a value
// from Error and nil will be returned.
//
// If @cancellable is non-nil, it can be used to cancel the operation, in
// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
func (resolver resolver) LookupRecords(rrname string, recordType ResolverRecordType, cancellable Cancellable) *glib.List {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 C.GResolverRecordType
	var arg3 *C.GCancellable

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(rrname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResolverRecordType)(recordType)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_resolver_lookup_records(arg0, arg1, arg2, arg3)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LookupRecordsAsync begins asynchronously performing a DNS lookup for the
// given @rrname, and eventually calls @callback, which must call
// g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
func (resolver resolver) LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 C.GResolverRecordType
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(rrname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GResolverRecordType)(recordType)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_resolver_lookup_records_async(arg0, arg1, arg2, arg3, arg4)
}

// LookupService: synchronously performs a DNS SRV lookup for the given
// @service and @protocol in the given @domain and returns an array of
// Target. @domain may be an ASCII-only or UTF-8 hostname. Note also that
// the @service and @protocol arguments do not include the leading
// underscore that appears in the actual DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// Target, sorted in order of preference. (That is, you should attempt to
// connect to the first target first, then the second if the first fails,
// etc.)
//
// If the DNS resolution fails, @error (if non-nil) will be set to a value
// from Error and nil will be returned.
//
// If @cancellable is non-nil, it can be used to cancel the operation, in
// which case @error (if non-nil) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier to
// create a Service and use its Connectable interface.
func (resolver resolver) LookupService(service string, protocol string, domain string, cancellable Cancellable) *glib.List {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.GCancellable

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_resolver_lookup_service(arg0, arg1, arg2, arg3, arg4)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for
// the given @service and @protocol in the given @domain, and eventually
// calls @callback, which must call g_resolver_lookup_service_finish() to
// get the final result. See g_resolver_lookup_service() for more details.
func (resolver resolver) LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GResolver
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_resolver_lookup_service_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetDefault sets @resolver to be the application's default resolver
// (reffing @resolver, and unreffing the previous default resolver, if any).
// Future calls to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS
// caching or "pinning"; it can implement its own #GResolver that calls the
// original default resolver for DNS operations, and implements its own
// cache policies on top of that, and then set itself as the default
// resolver for all later code to use.
func (resolver resolver) SetDefault() {
	var arg0 *C.GResolver

	arg0 = (*C.GResolver)(resolver.Native())

	C.g_resolver_set_default(arg0)
}

// Settings: the #GSettings class provides a convenient API for storing and
// retrieving application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the `gettext-domain` attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// `l10n` attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the <default> element — it is recommended to
// add these comments to aid translators understand the meaning and implications
// of the default value. An optional translation `context` attribute can be set
// on the <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//
//     <!-- Translators: A list of words which are not allowed to be typed, in
//          GVariant serialization syntax.
//          See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//     <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//    ]|
//
//    Translations of default values must remain syntactically valid serialized
//    #GVariants (e.g. retaining any surrounding quotation marks) or runtime
//    errors will occur.
//
//    GSettings uses schemas in a compact binary form that is created
//    by the [glib-compile-schemas][glib-compile-schemas]
//    utility. The input is a schema description in an XML format.
//
//    A DTD for the gschema XML format can be found here:
//    gschema.dtd (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
//    The [glib-compile-schemas][glib-compile-schemas] tool expects schema
//    files to have the extension `.gschema.xml`.
//
//    At runtime, schemas are identified by their id (as specified in the
//    id attribute of the <schema> element). The convention for schema
//    ids is to use a dotted name, similar in style to a D-Bus bus name,
//    e.g. "org.gnome.SessionManager". In particular, if the settings are
//    for a specific service that owns a D-Bus bus name, the D-Bus bus name
//    and schema id should match. For schemas which deal with settings not
//    associated with one named application, the id should not use
//    StudlyCaps, e.g. "org.gnome.font-rendering".
//
//    In addition to #GVariant types, keys can have types that have
//    enumerated types. These can be described by a <choice>,
//    <enum> or <flags> element, as seen in the
//    [example][schema-enumerated]. The underlying type of such a key
//    is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
//    g_settings_get_flags(), g_settings_set_flags() access the numeric values
//    corresponding to the string value of enum and flags keys.
//
//    An example for default value:
//    |[
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
//
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
//
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
//
//      </schema>
//    </schemalist>
//    ]|
//
//    An example for ranges, choices and enumerated types:
//    |[
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//    ]|
//
//
//
// Vendor overrides
//
//
//    Default values are defined in the schemas that get installed by
//    an application. Sometimes, it is necessary for a vendor or distributor
//    to adjust these defaults. Since patching the XML source for the schema
//    is inconvenient and error-prone,
//    [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
//    override' files. These are keyfiles in the same directory as the XML
//    schema sources which can override default values. The schema id serves
//    as the group name in the key file, and the values are expected in
//    serialized GVariant form, as in the following example:
//    |[
//        [org.gtk.Example]
//        key1='string'
//        key2=1.5
//    ]|
//
//    glib-compile-schemas expects schema files to have the extension
//    `.gschema.override`.
//
//
//
// Binding
//
//
//    A very convenient feature of GSettings lets you bind #GObject properties
//    directly to settings, using g_settings_bind(). Once a GObject property
//    has been bound to a setting, changes on either side are automatically
//    propagated to the other side. GSettings handles details like mapping
//    between GObject and GVariant types, and preventing infinite cycles.
//
//    This makes it very easy to hook up a preferences dialog to the
//    underlying settings. To make this even more convenient, GSettings
//    looks for a boolean property with the name "sensitivity" and
//    automatically binds it to the writability of the bound setting.
//    If this 'magic' gets in the way, it can be suppressed with the
//    SETTINGS_BIND_NO_SENSITIVITY flag.
//
//
//
// Relocatable schemas
//
//
//    A relocatable schema is one with no `path` attribute specified on its
//    <schema> element. By using g_settings_new_with_path(), a #GSettings object
//    can be instantiated for a relocatable schema, assigning a path to the
//    instance. Paths passed to g_settings_new_with_path() will typically be
//    constructed dynamically from a constant prefix plus some form of instance
//    identifier; but they must still be valid GSettings paths. Paths could also
//    be constant and used with a globally installed schema originating from a
//    dependency library.
//
//    For example, a relocatable schema could be used to store geometry information
//    for different windows in an application. If the schema ID was
//    `org.foo.MyApp.Window`, it could be instantiated for paths
//    `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
//    `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
//    they can be specified as <child> elements in the parent schema, e.g.:
//    |[
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//    ]|
//
//
//
// Build system integration
//
//
//    GSettings comes with autotools integration to simplify compiling and
//    installing schemas. To add GSettings support to an application, add the
//    following to your `configure.ac`:
//    |[
//    GLIB_GSETTINGS
//    ]|
//
//    In the appropriate `Makefile.am`, use the following snippet to compile and
//    install the named schema:
//    |[
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    @GSETTINGS_RULES@
//    ]|
//
//    No changes are needed to the build system to mark a schema XML file for
//    translation. Assuming it sets the `gettext-domain` attribute, a schema may
//    be marked for translation by adding it to `POTFILES.in`, assuming gettext
//    0.19 is in use (the preferred method for translation):
//    |[
//    data/org.foo.MyApp.gschema.xml
//    ]|
//
//    Alternatively, if intltool 0.50.1 is in use:
//    |[
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//    ]|
//
//    GSettings will use gettext to look up translations for the <summary> and
//    <description> elements, and also any <default> elements which have a `l10n`
//    attribute set. Translations must not be included in the `.gschema.xml` file
//    by the build system, for example by using intltool XML rules with a
//    `.gschema.xml.in` template.
//
//    If an enumerated type defined in a C header file is to be used in a GSettings
//    schema, it can either be defined manually using an <enum> element in the
//    schema XML, or it can be extracted automatically from the C header. This
//    approach is preferred, as it ensures the two representations are always
//    synchronised. To do so, add the following to the relevant `Makefile.am`:
//    |[
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
//
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
type Settings interface {
	gextras.Objector

	// Apply applies any changes that have been made to the settings. This
	// function does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	Apply()
	// Bind: create a binding between the @key in the @settings object and the
	// property @property of @object.
	//
	// The binding uses the default GIO mapping functions to map between the
	// settings and property values. These functions handle booleans, numeric
	// types and string types in a straightforward way. Use
	// g_settings_bind_with_mapping() if you need a custom mapping, or map
	// between types that are not supported by the default mapping functions.
	//
	// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
	// also establishes a binding between the writability of @key and the
	// "sensitive" property of @object (if @object has a boolean property by
	// that name). See g_settings_bind_writable() for more details about
	// writable bindings.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags)
	// BindWithMapping: create a binding between the @key in the @settings
	// object and the property @property of @object.
	//
	// The binding uses the provided mapping functions to map between settings
	// and property values.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWithMapping(key string, object gextras.Objector, property string, flags SettingsBindFlags, getMapping SettingsBindGetMapping, setMapping SettingsBindSetMapping)
	// BindWritable: create a binding between the writability of @key in the
	// @settings object and the property @property of @object. The property must
	// be boolean; "sensitive" or "visible" properties of widgets are the most
	// likely candidates.
	//
	// Writable bindings are always uni-directional; changes of the writability
	// of the setting will be propagated to the object property, not the other
	// way.
	//
	// When the @inverted argument is true, the binding inverts the value as it
	// passes from the setting to the object, i.e. @property will be set to true
	// if the key is not writable.
	//
	// Note that the lifecycle of the binding is tied to @object, and that you
	// can have only one binding per object property. If you bind the same
	// property twice on the same object, the second binding overrides the first
	// one.
	BindWritable(key string, object gextras.Objector, property string, inverted bool)
	// Delay changes the #GSettings object into 'delay-apply' mode. In this
	// mode, changes to @settings are not immediately propagated to the backend,
	// but kept locally until g_settings_apply() is called.
	Delay()
	// Boolean gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	Boolean(key string) bool
	// Child creates a child settings object which has a base path of
	// `base-path/@name`, where `base-path` is the base path of @settings.
	//
	// The schema for the child settings object must have been declared in the
	// schema of @settings using a <child> element.
	Child(name string) Settings
	// DefaultValue gets the "default value" of a key.
	//
	// This is the value that would be read if g_settings_reset() were to be
	// called on the key.
	//
	// Note that this may be a different value than returned by
	// g_settings_schema_key_get_default_value() if the system administrator has
	// provided a default value.
	//
	// Comparing the return values of g_settings_get_default_value() and
	// g_settings_get_value() is not sufficient for determining if a value has
	// been set because the user may have explicitly set the value to something
	// that happens to be equal to the default. The difference here is that if
	// the default changes in the future, the user's key will still be set.
	//
	// This function may be useful for adding an indication to a UI of what the
	// default value was before the user set it.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	DefaultValue(key string) *glib.Variant
	// Double gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	Double(key string) float64
	// Enum gets the value that is stored in @settings for @key and converts it
	// to the enum value that it represents.
	//
	// In order to use this function the type of the value must be a string and
	// it must be marked in the schema file as an enumerated type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the enumerated type then this function will return the default value.
	Enum(key string) int
	// Flags gets the value that is stored in @settings for @key and converts it
	// to the flags value that it represents.
	//
	// In order to use this function the type of the value must be an array of
	// strings and it must be marked in the schema file as a flags type.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type.
	//
	// If the value stored in the configuration database is not a valid value
	// for the flags type then this function will return the default value.
	Flags(key string) uint
	// HasUnapplied returns whether the #GSettings object has any unapplied
	// changes. This can only be the case if it is in 'delayed-apply' mode.
	HasUnapplied() bool
	// Int gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	Int(key string) int
	// Int64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	Int64(key string) int64
	// Mapped gets the value that is stored at @key in @settings, subject to
	// application-level validation/mapping.
	//
	// You should use this function when the application needs to perform some
	// processing on the value of the key (for example, parsing). The @mapping
	// function performs that processing. If the function indicates that the
	// processing was unsuccessful (due to a parse error, for example) then the
	// mapping is tried again with another value.
	//
	// This allows a robust 'fall back to defaults' behaviour to be implemented
	// somewhat automatically.
	//
	// The first value that is tried is the user's setting for the key. If the
	// mapping function fails to map this value, other values may be tried in an
	// unspecified order (system or site defaults, translated schema default
	// values, untranslated schema default values, etc).
	//
	// If the mapping function fails for all possible values, one additional
	// attempt is made: the mapping function is called with a nil value. If the
	// mapping function still indicates failure at this point then the
	// application will be aborted.
	//
	// The result parameter for the @mapping function is pointed to a #gpointer
	// which is initially set to nil. The same pointer is given to each
	// invocation of @mapping. The final value of that #gpointer is what is
	// returned by this function. nil is valid; it is returned just as any other
	// value would be.
	Mapped(key string, mapping SettingsGetMapping) interface{}
	// Range queries the range of a key.
	Range(key string) *glib.Variant
	// String gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	String(key string) string
	// Strv: a convenience variant of g_settings_get() for string arrays.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	Strv(key string) []string
	// Uint gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	Uint(key string) uint
	// Uint64 gets the value that is stored at @key in @settings.
	//
	// A convenience variant of g_settings_get() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	Uint64(key string) uint64
	// UserValue checks the "user value" of a key, if there is one.
	//
	// The user value of a key is the last value that was set by the user.
	//
	// After calling g_settings_reset() this function should always return nil
	// (assuming something is not wrong with the system configuration).
	//
	// It is possible that g_settings_get_value() will return a different value
	// than this function. This can happen in the case that the user set a value
	// for a key that was subsequently locked down by the system administrator
	// -- this function will return the user's old value.
	//
	// This function may be useful for adding a "reset" option to a UI or for
	// providing indication that a particular value has been changed.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	UserValue(key string) *glib.Variant
	// Value gets the value that is stored in @settings for @key.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings.
	Value(key string) *glib.Variant
	// IsWritable finds out if a key can be written or not
	IsWritable(name string) bool
	// ListChildren gets the list of children on @settings.
	//
	// The list is exactly the list of strings for which it is not an error to
	// call g_settings_get_child().
	//
	// There is little reason to call this function from "normal" code, since
	// you should already know what children are in your schema. This function
	// may still be useful there for introspection reasons, however.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListChildren() []string
	// ListKeys introspects the list of keys on @settings.
	//
	// You should probably not be calling this function from "normal" code
	// (since you should already know what keys are in your schema). This
	// function is intended for introspection reasons.
	//
	// You should free the return value with g_strfreev() when you are done with
	// it.
	ListKeys() []string
	// RangeCheck checks if the given @value is of the correct type and within
	// the permitted range for @key.
	RangeCheck(key string, value *glib.Variant) bool
	// Reset resets @key to its default value.
	//
	// This call resets the key, as much as possible, to its default value. That
	// might be the value specified in the schema or the one set by the
	// administrator.
	Reset(key string)
	// Revert reverts all non-applied changes to the settings. This function
	// does nothing unless @settings is in 'delay-apply' mode; see
	// g_settings_delay(). In the normal case settings are always applied
	// immediately.
	//
	// Change notifications will be emitted for affected keys.
	Revert()
	// SetBoolean sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for booleans.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// boolean type in the schema for @settings.
	SetBoolean(key string, value bool) bool
	// SetDouble sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for doubles.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// 'double' type in the schema for @settings.
	SetDouble(key string, value float64) bool
	// SetEnum looks up the enumerated type nick for @value and writes it to
	// @key, within @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as an enumerated type, or for
	// @value not to be a valid value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_string() will return the 'nick' associated with @value.
	SetEnum(key string, value int) bool
	// SetFlags looks up the flags type nicks for the bits specified by @value,
	// puts them in an array of strings and writes the array to @key, within
	// @settings.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or is not marked as a flags type, or for @value to
	// contain any bits that are not value for the named type.
	//
	// After performing the write, accessing @key directly with
	// g_settings_get_strv() will return an array of 'nicks'; one for each bit
	// in @value.
	SetFlags(key string, value uint) bool
	// SetInt sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int32 type in the schema for @settings.
	SetInt(key string, value int) bool
	// SetInt64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// int64 type in the schema for @settings.
	SetInt64(key string, value int64) bool
	// SetString sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for strings.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// string type in the schema for @settings.
	SetString(key string, value string) bool
	// SetStrv sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for string arrays. If @value is
	// nil, then @key is set to be the empty array.
	//
	// It is a programmer error to give a @key that isn't specified as having an
	// array of strings type in the schema for @settings.
	SetStrv(key string, value []string) bool
	// SetUint sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 32-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint32 type in the schema for @settings.
	SetUint(key string, value uint) bool
	// SetUint64 sets @key in @settings to @value.
	//
	// A convenience variant of g_settings_set() for 64-bit unsigned integers.
	//
	// It is a programmer error to give a @key that isn't specified as having a
	// uint64 type in the schema for @settings.
	SetUint64(key string, value uint64) bool
	// SetValue sets @key in @settings to @value.
	//
	// It is a programmer error to give a @key that isn't contained in the
	// schema for @settings or for @value to have the incorrect type, per the
	// schema.
	//
	// If @value is floating then this function consumes the reference.
	SetValue(key string, value *glib.Variant) bool
}

// settings implements the Settings interface.
type settings struct {
	gextras.Objector
}

// WrapSettings wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettings(obj *externglib.Object) Settings {
	return Settings{
		gextras.Objector: (obj),
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettings(obj), nil
}

// NewSettings constructs a class Settings.
func NewSettings(schemaID string) Settings {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaID))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_new(arg1)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSettingsFull constructs a class Settings.
func NewSettingsFull(schema *SettingsSchema, backend SettingsBackend, path string) Settings {
	var arg1 *C.GSettingsSchema
	var arg2 *C.GSettingsBackend
	var arg3 *C.gchar

	arg1 = (*C.GSettingsSchema)(schema.Native())
	arg2 = (*C.GSettingsBackend)(backend.Native())
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_settings_new_full(arg1, arg2, arg3)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSettingsWithBackend constructs a class Settings.
func NewSettingsWithBackend(schemaID string, backend SettingsBackend) Settings {
	var arg1 *C.gchar
	var arg2 *C.GSettingsBackend

	arg1 = (*C.gchar)(C.CString(schemaID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GSettingsBackend)(backend.Native())

	ret := C.g_settings_new_with_backend(arg1, arg2)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSettingsWithBackendAndPath constructs a class Settings.
func NewSettingsWithBackendAndPath(schemaID string, backend SettingsBackend, path string) Settings {
	var arg1 *C.gchar
	var arg2 *C.GSettingsBackend
	var arg3 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GSettingsBackend)(backend.Native())
	arg3 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_settings_new_with_backend_and_path(arg1, arg2, arg3)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSettingsWithPath constructs a class Settings.
func NewSettingsWithPath(schemaID string, path string) Settings {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(schemaID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_settings_new_with_path(arg1, arg2)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Apply applies any changes that have been made to the settings. This
// function does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
func (settings settings) Apply() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	C.g_settings_apply(arg0)
}

// Bind: create a binding between the @key in the @settings object and the
// property @property of @object.
//
// The binding uses the default GIO mapping functions to map between the
// settings and property values. These functions handle booleans, numeric
// types and string types in a straightforward way. Use
// g_settings_bind_with_mapping() if you need a custom mapping, or map
// between types that are not supported by the default mapping functions.
//
// Unless the @flags include G_SETTINGS_BIND_NO_SENSITIVITY, this function
// also establishes a binding between the writability of @key and the
// "sensitive" property of @object (if @object has a boolean property by
// that name). See g_settings_bind_writable() for more details about
// writable bindings.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (settings settings) Bind(key string, object gextras.Objector, property string, flags SettingsBindFlags) {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar
	var arg4 C.GSettingsBindFlags

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())
	arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GSettingsBindFlags)(flags)

	C.g_settings_bind(arg0, arg1, arg2, arg3, arg4)
}

// BindWithMapping: create a binding between the @key in the @settings
// object and the property @property of @object.
//
// The binding uses the provided mapping functions to map between settings
// and property values.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (settings settings) BindWithMapping(key string, object gextras.Objector, property string, flags SettingsBindFlags, getMapping SettingsBindGetMapping, setMapping SettingsBindSetMapping) {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar
	var arg4 C.GSettingsBindFlags
	var arg5 C.GSettingsBindGetMapping
	var arg6 C.GSettingsBindSetMapping
	arg7 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())
	arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GSettingsBindFlags)(flags)
	arg5 = (*[0]byte)(C.gotk4_SettingsBindGetMapping)
	arg6 = (*[0]byte)(C.gotk4_SettingsBindSetMapping)

	C.g_settings_bind_with_mapping(arg0, arg1, arg2, arg3, arg4, arg5, arg6, (*[0]byte)(C.callbackDelete))
}

// BindWritable: create a binding between the writability of @key in the
// @settings object and the property @property of @object. The property must
// be boolean; "sensitive" or "visible" properties of widgets are the most
// likely candidates.
//
// Writable bindings are always uni-directional; changes of the writability
// of the setting will be propagated to the object property, not the other
// way.
//
// When the @inverted argument is true, the binding inverts the value as it
// passes from the setting to the object, i.e. @property will be set to true
// if the key is not writable.
//
// Note that the lifecycle of the binding is tied to @object, and that you
// can have only one binding per object property. If you bind the same
// property twice on the same object, the second binding overrides the first
// one.
func (settings settings) BindWritable(key string, object gextras.Objector, property string, inverted bool) {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gpointer
	var arg3 *C.gchar
	var arg4 C.gboolean

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(object.Native())
	arg3 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = gextras.Cbool(inverted)

	C.g_settings_bind_writable(arg0, arg1, arg2, arg3, arg4)
}

// Delay changes the #GSettings object into 'delay-apply' mode. In this
// mode, changes to @settings are not immediately propagated to the backend,
// but kept locally until g_settings_apply() is called.
func (settings settings) Delay() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	C.g_settings_delay(arg0)
}

// Boolean gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for booleans.
//
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
func (settings settings) Boolean(key string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_boolean(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Child creates a child settings object which has a base path of
// `base-path/@name`, where `base-path` is the base path of @settings.
//
// The schema for the child settings object must have been declared in the
// schema of @settings using a <child> element.
func (settings settings) Child(name string) Settings {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_child(arg0, arg1)

	var ret0 Settings

	ret0 = WrapSettings(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// DefaultValue gets the "default value" of a key.
//
// This is the value that would be read if g_settings_reset() were to be
// called on the key.
//
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator has
// provided a default value.
//
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value has
// been set because the user may have explicitly set the value to something
// that happens to be equal to the default. The difference here is that if
// the default changes in the future, the user's key will still be set.
//
// This function may be useful for adding an indication to a UI of what the
// default value was before the user set it.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (settings settings) DefaultValue(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_default_value(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Double gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for doubles.
//
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
func (settings settings) Double(key string) float64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_double(arg0, arg1)

	var ret0 float64

	ret0 = float64(ret)

	return ret0
}

// Enum gets the value that is stored in @settings for @key and converts it
// to the enum value that it represents.
//
// In order to use this function the type of the value must be a string and
// it must be marked in the schema file as an enumerated type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type.
//
// If the value stored in the configuration database is not a valid value
// for the enumerated type then this function will return the default value.
func (settings settings) Enum(key string) int {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_enum(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Flags gets the value that is stored in @settings for @key and converts it
// to the flags value that it represents.
//
// In order to use this function the type of the value must be an array of
// strings and it must be marked in the schema file as a flags type.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type.
//
// If the value stored in the configuration database is not a valid value
// for the flags type then this function will return the default value.
func (settings settings) Flags(key string) uint {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_flags(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// HasUnapplied returns whether the #GSettings object has any unapplied
// changes. This can only be the case if it is in 'delayed-apply' mode.
func (settings settings) HasUnapplied() bool {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	ret := C.g_settings_get_has_unapplied(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Int gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
func (settings settings) Int(key string) int {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_int(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Int64 gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
func (settings settings) Int64(key string) int64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_int64(arg0, arg1)

	var ret0 int64

	ret0 = int64(ret)

	return ret0
}

// Mapped gets the value that is stored at @key in @settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform some
// processing on the value of the key (for example, parsing). The @mapping
// function performs that processing. If the function indicates that the
// processing was unsuccessful (due to a parse error, for example) then the
// mapping is tried again with another value.
//
// This allows a robust 'fall back to defaults' behaviour to be implemented
// somewhat automatically.
//
// The first value that is tried is the user's setting for the key. If the
// mapping function fails to map this value, other values may be tried in an
// unspecified order (system or site defaults, translated schema default
// values, untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional
// attempt is made: the mapping function is called with a nil value. If the
// mapping function still indicates failure at this point then the
// application will be aborted.
//
// The result parameter for the @mapping function is pointed to a #gpointer
// which is initially set to nil. The same pointer is given to each
// invocation of @mapping. The final value of that #gpointer is what is
// returned by this function. nil is valid; it is returned just as any other
// value would be.
func (settings settings) Mapped(key string, mapping SettingsGetMapping) interface{} {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.GSettingsGetMapping
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_SettingsGetMapping)

	ret := C.g_settings_get_mapped(arg0, arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Range queries the range of a key.
func (settings settings) Range(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_range(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// String gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for strings.
//
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
func (settings settings) String(key string) string {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_string(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Strv: a convenience variant of g_settings_get() for string arrays.
//
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
func (settings settings) Strv(key string) []string {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_strv(arg0, arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// Uint gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 32-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
func (settings settings) Uint(key string) uint {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_uint(arg0, arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Uint64 gets the value that is stored at @key in @settings.
//
// A convenience variant of g_settings_get() for 64-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
func (settings settings) Uint64(key string) uint64 {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_uint64(arg0, arg1)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// UserValue checks the "user value" of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling g_settings_reset() this function should always return nil
// (assuming something is not wrong with the system configuration).
//
// It is possible that g_settings_get_value() will return a different value
// than this function. This can happen in the case that the user set a value
// for a key that was subsequently locked down by the system administrator
// -- this function will return the user's old value.
//
// This function may be useful for adding a "reset" option to a UI or for
// providing indication that a particular value has been changed.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (settings settings) UserValue(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_user_value(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// Value gets the value that is stored in @settings for @key.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings.
func (settings settings) Value(key string) *glib.Variant {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_get_value(arg0, arg1)

	var ret0 *glib.Variant

	ret0 = glib.WrapVariant(ret)

	return ret0
}

// IsWritable finds out if a key can be written or not
func (settings settings) IsWritable(name string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_settings_is_writable(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListChildren gets the list of children on @settings.
//
// The list is exactly the list of strings for which it is not an error to
// call g_settings_get_child().
//
// There is little reason to call this function from "normal" code, since
// you should already know what children are in your schema. This function
// may still be useful there for introspection reasons, however.
//
// You should free the return value with g_strfreev() when you are done with
// it.
func (settings settings) ListChildren() []string {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	ret := C.g_settings_list_children(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ListKeys introspects the list of keys on @settings.
//
// You should probably not be calling this function from "normal" code
// (since you should already know what keys are in your schema). This
// function is intended for introspection reasons.
//
// You should free the return value with g_strfreev() when you are done with
// it.
func (settings settings) ListKeys() []string {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	ret := C.g_settings_list_keys(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// RangeCheck checks if the given @value is of the correct type and within
// the permitted range for @key.
func (settings settings) RangeCheck(key string, value *glib.Variant) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	ret := C.g_settings_range_check(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Reset resets @key to its default value.
//
// This call resets the key, as much as possible, to its default value. That
// might be the value specified in the schema or the one set by the
// administrator.
func (settings settings) Reset(key string) {
	var arg0 *C.GSettings
	var arg1 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.g_settings_reset(arg0, arg1)
}

// Revert reverts all non-applied changes to the settings. This function
// does nothing unless @settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
//
// Change notifications will be emitted for affected keys.
func (settings settings) Revert() {
	var arg0 *C.GSettings

	arg0 = (*C.GSettings)(settings.Native())

	C.g_settings_revert(arg0)
}

// SetBoolean sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for booleans.
//
// It is a programmer error to give a @key that isn't specified as having a
// boolean type in the schema for @settings.
func (settings settings) SetBoolean(key string, value bool) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = gextras.Cbool(value)

	ret := C.g_settings_set_boolean(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetDouble sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for doubles.
//
// It is a programmer error to give a @key that isn't specified as having a
// 'double' type in the schema for @settings.
func (settings settings) SetDouble(key string, value float64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gdouble

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gdouble(value)

	ret := C.g_settings_set_double(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetEnum looks up the enumerated type nick for @value and writes it to
// @key, within @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as an enumerated type, or for
// @value not to be a valid value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_string() will return the 'nick' associated with @value.
func (settings settings) SetEnum(key string, value int) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	ret := C.g_settings_set_enum(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetFlags looks up the flags type nicks for the bits specified by @value,
// puts them in an array of strings and writes the array to @key, within
// @settings.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or is not marked as a flags type, or for @value to
// contain any bits that are not value for the named type.
//
// After performing the write, accessing @key directly with
// g_settings_get_strv() will return an array of 'nicks'; one for each bit
// in @value.
func (settings settings) SetFlags(key string, value uint) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(value)

	ret := C.g_settings_set_flags(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetInt sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int32 type in the schema for @settings.
func (settings settings) SetInt(key string, value int) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint(value)

	ret := C.g_settings_set_int(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetInt64 sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// int64 type in the schema for @settings.
func (settings settings) SetInt64(key string, value int64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.gint64

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint64(value)

	ret := C.g_settings_set_int64(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetString sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for strings.
//
// It is a programmer error to give a @key that isn't specified as having a
// string type in the schema for @settings.
func (settings settings) SetString(key string, value string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_settings_set_string(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetStrv sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for string arrays. If @value is
// nil, then @key is set to be the empty array.
//
// It is a programmer error to give a @key that isn't specified as having an
// array of strings type in the schema for @settings.
func (settings settings) SetStrv(key string, value []string) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 **C.gchar

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	{

	}

	ret := C.g_settings_set_strv(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetUint sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 32-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint32 type in the schema for @settings.
func (settings settings) SetUint(key string, value uint) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint(value)

	ret := C.g_settings_set_uint(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetUint64 sets @key in @settings to @value.
//
// A convenience variant of g_settings_set() for 64-bit unsigned integers.
//
// It is a programmer error to give a @key that isn't specified as having a
// uint64 type in the schema for @settings.
func (settings settings) SetUint64(key string, value uint64) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 C.guint64

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(value)

	ret := C.g_settings_set_uint64(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetValue sets @key in @settings to @value.
//
// It is a programmer error to give a @key that isn't contained in the
// schema for @settings or for @value to have the incorrect type, per the
// schema.
//
// If @value is floating then this function consumes the reference.
func (settings settings) SetValue(key string, value *glib.Variant) bool {
	var arg0 *C.GSettings
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GSettings)(settings.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	ret := C.g_settings_set_value(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend interface {
	gextras.Objector

	// Changed signals that a single key has possibly changed. Backend
	// implementations should call this if a key has possibly changed its value.
	//
	// @key must be a valid key (ie starting with a slash, not containing '//',
	// and not ending with a slash).
	//
	// The implementation must call this function during any call to
	// g_settings_backend_write(), before the call returns (except in the case
	// that no keys are actually changed and it cares to detect this fact). It
	// may not rely on the existence of a mainloop for dispatching the signal
	// later.
	//
	// The implementation may call this function at any other time it likes in
	// response to other events (such as changes occurring outside of the
	// program). These calls may originate from a mainloop or may originate in
	// response to any other action (including from calls to
	// g_settings_backend_write()).
	//
	// In the case that this call is in response to a call to
	// g_settings_backend_write() then @origin_tag must be set to the same value
	// that was passed to that call.
	Changed(key string, originTag interface{})
	// ChangedTree: this call is a convenience wrapper. It gets the list of
	// changes from @tree, computes the longest common prefix and calls
	// g_settings_backend_changed().
	ChangedTree(tree *glib.Tree, originTag interface{})
	// KeysChanged signals that a list of keys have possibly changed. Backend
	// implementations should call this if keys have possibly changed their
	// values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//'). Each string in @items must form a valid key name when
	// @path is prefixed to it (ie: each item must not start or end with '/' and
	// must not contain '//').
	//
	// The meaning of this signal is that any of the key names resulting from
	// the contatenation of @path with each item in @items may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). These two calls can be used interchangeably
	// if exactly one item has changed (although in that case
	// g_settings_backend_changed() is definitely preferred).
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required.
	KeysChanged(path string, items []string, originTag interface{})
	// PathChanged signals that all keys below a given path may have possibly
	// changed. Backend implementations should call this if an entire path of
	// keys have possibly changed their values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//').
	//
	// The meaning of this signal is that any of the key which has a name
	// starting with @path may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). This call might be an appropriate reasponse
	// to a 'reset' call but implementations are also free to explicitly list
	// the keys that were affected by that call if they can easily do so.
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required. As an example, if
	// this function is called with the path of "/" then every single key in the
	// application will be notified of a possible change.
	PathChanged(path string, originTag interface{})
	// PathWritableChanged signals that the writability of all keys below a
	// given path may have changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	PathWritableChanged(path string)
	// WritableChanged signals that the writability of a single key has possibly
	// changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	WritableChanged(key string)
}

// settingsBackend implements the SettingsBackend interface.
type settingsBackend struct {
	gextras.Objector
}

// WrapSettingsBackend wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettingsBackend(obj *externglib.Object) SettingsBackend {
	return SettingsBackend{
		gextras.Objector: (obj),
	}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettingsBackend(obj), nil
}

// Changed signals that a single key has possibly changed. Backend
// implementations should call this if a key has possibly changed its value.
//
// @key must be a valid key (ie starting with a slash, not containing '//',
// and not ending with a slash).
//
// The implementation must call this function during any call to
// g_settings_backend_write(), before the call returns (except in the case
// that no keys are actually changed and it cares to detect this fact). It
// may not rely on the existence of a mainloop for dispatching the signal
// later.
//
// The implementation may call this function at any other time it likes in
// response to other events (such as changes occurring outside of the
// program). These calls may originate from a mainloop or may originate in
// response to any other action (including from calls to
// g_settings_backend_write()).
//
// In the case that this call is in response to a call to
// g_settings_backend_write() then @origin_tag must be set to the same value
// that was passed to that call.
func (backend settingsBackend) Changed(key string, originTag interface{}) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.gchar
	var arg2 C.gpointer

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gpointer(box.Assign(originTag))

	C.g_settings_backend_changed(arg0, arg1, arg2)
}

// ChangedTree: this call is a convenience wrapper. It gets the list of
// changes from @tree, computes the longest common prefix and calls
// g_settings_backend_changed().
func (backend settingsBackend) ChangedTree(tree *glib.Tree, originTag interface{}) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.GTree
	var arg2 C.gpointer

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.GTree)(tree.Native())
	arg2 = C.gpointer(box.Assign(originTag))

	C.g_settings_backend_changed_tree(arg0, arg1, arg2)
}

// KeysChanged signals that a list of keys have possibly changed. Backend
// implementations should call this if keys have possibly changed their
// values.
//
// @path must be a valid path (ie starting and ending with a slash and not
// containing '//'). Each string in @items must form a valid key name when
// @path is prefixed to it (ie: each item must not start or end with '/' and
// must not contain '//').
//
// The meaning of this signal is that any of the key names resulting from
// the contatenation of @path with each item in @items may have changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed(). These two calls can be used interchangeably
// if exactly one item has changed (although in that case
// g_settings_backend_changed() is definitely preferred).
//
// For efficiency reasons, the implementation should strive for @path to be
// as long as possible (ie: the longest common prefix of all of the keys
// that were changed) but this is not strictly required.
func (backend settingsBackend) KeysChanged(path string, items []string, originTag interface{}) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.gchar
	var arg2 **C.gchar
	var arg3 C.gpointer

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	{

	}
	arg3 = C.gpointer(box.Assign(originTag))

	C.g_settings_backend_keys_changed(arg0, arg1, arg2, arg3)
}

// PathChanged signals that all keys below a given path may have possibly
// changed. Backend implementations should call this if an entire path of
// keys have possibly changed their values.
//
// @path must be a valid path (ie starting and ending with a slash and not
// containing '//').
//
// The meaning of this signal is that any of the key which has a name
// starting with @path may have changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed(). This call might be an appropriate reasponse
// to a 'reset' call but implementations are also free to explicitly list
// the keys that were affected by that call if they can easily do so.
//
// For efficiency reasons, the implementation should strive for @path to be
// as long as possible (ie: the longest common prefix of all of the keys
// that were changed) but this is not strictly required. As an example, if
// this function is called with the path of "/" then every single key in the
// application will be notified of a possible change.
func (backend settingsBackend) PathChanged(path string, originTag interface{}) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.gchar
	var arg2 C.gpointer

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gpointer(box.Assign(originTag))

	C.g_settings_backend_path_changed(arg0, arg1, arg2)
}

// PathWritableChanged signals that the writability of all keys below a
// given path may have changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (backend settingsBackend) PathWritableChanged(path string) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.gchar

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_settings_backend_path_writable_changed(arg0, arg1)
}

// WritableChanged signals that the writability of a single key has possibly
// changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (backend settingsBackend) WritableChanged(key string) {
	var arg0 *C.GSettingsBackend
	var arg1 *C.gchar

	arg0 = (*C.GSettingsBackend)(backend.Native())
	arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(arg1))

	C.g_settings_backend_writable_changed(arg0, arg1)
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction interface.
type simpleAction struct {
	gextras.Objector
}

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return SimpleAction{
		gextras.Objector: (obj),
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

// NewSimpleAction constructs a class SimpleAction.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var arg1 *C.gchar
	var arg2 *C.GVariantType

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(parameterType.Native())

	ret := C.g_simple_action_new(arg1, arg2)

	var ret0 SimpleAction

	ret0 = WrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSimpleActionStateful constructs a class SimpleAction.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var arg1 *C.gchar
	var arg2 *C.GVariantType
	var arg3 *C.GVariant

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariantType)(parameterType.Native())
	arg3 = (*C.GVariant)(state.Native())

	ret := C.g_simple_action_new_stateful(arg1, arg2, arg3)

	var ret0 SimpleAction

	ret0 = WrapSimpleAction(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have
// its state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
func (simple simpleAction) SetEnabled(enabled bool) {
	var arg0 *C.GSimpleAction
	var arg1 C.gboolean

	arg0 = (*C.GSimpleAction)(simple.Native())
	arg1 = gextras.Cbool(enabled)

	C.g_simple_action_set_enabled(arg0, arg1)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property.
// Instead, they should call g_action_change_state() to request the change.
//
// If the @value GVariant is floating, it is consumed.
func (simple simpleAction) SetState(value *glib.Variant) {
	var arg0 *C.GSimpleAction
	var arg1 *C.GVariant

	arg0 = (*C.GSimpleAction)(simple.Native())
	arg1 = (*C.GVariant)(value.Native())

	C.g_simple_action_set_state(arg0, arg1)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state
// hints.
func (simple simpleAction) SetStateHint(stateHint *glib.Variant) {
	var arg0 *C.GSimpleAction
	var arg1 *C.GVariant

	arg0 = (*C.GSimpleAction)(simple.Native())
	arg1 = (*C.GVariant)(stateHint.Native())

	C.g_simple_action_set_state_hint(arg0, arg1)
}

// SimpleActionGroup is a hash table filled with #GAction objects, implementing
// the Group and Map interfaces.
type SimpleActionGroup interface {
	gextras.Objector

	// Remove removes the named action from the action group.
	//
	// If no action of this name is in the group then nothing happens.
	Remove(actionName string)
}

// simpleActionGroup implements the SimpleActionGroup interface.
type simpleActionGroup struct {
	gextras.Objector
}

// WrapSimpleActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleActionGroup(obj *externglib.Object) SimpleActionGroup {
	return SimpleActionGroup{
		gextras.Objector: (obj),
	}
}

func marshalSimpleActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleActionGroup(obj), nil
}

// NewSimpleActionGroup constructs a class SimpleActionGroup.
func NewSimpleActionGroup() SimpleActionGroup {

	ret := C.g_simple_action_group_new()

	var ret0 SimpleActionGroup

	ret0 = WrapSimpleActionGroup(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Remove removes the named action from the action group.
//
// If no action of this name is in the group then nothing happens.
func (simple simpleActionGroup) Remove(actionName string) {
	var arg0 *C.GSimpleActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GSimpleActionGroup)(simple.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_simple_action_group_remove(arg0, arg1)
}

// SimpleAsyncResult as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and false. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop — inadvisable, but some APIs do so —
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }
//
type SimpleAsyncResult interface {
	gextras.Objector

	// Complete completes an asynchronous I/O job immediately. Must be called in
	// the thread where the asynchronous result was to be delivered, as it
	// invokes the callback directly. If you are in a different thread use
	// g_simple_async_result_complete_in_idle().
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	Complete()
	// CompleteInIdle completes an asynchronous function in an idle handler in
	// the [thread-default main context][g-main-context-push-thread-default] of
	// the thread that @simple was initially created in (and re-pushes that
	// context around the invocation of the callback).
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to complete the call.
	CompleteInIdle()
	// OpResGboolean gets the operation result boolean from within the
	// asynchronous result.
	OpResGboolean() bool
	// OpResGpointer gets a pointer result as returned by the asynchronous
	// function.
	OpResGpointer() interface{}
	// OpResGssize gets a gssize from the asynchronous result.
	OpResGssize() int
	// SourceTag gets the source tag for the AsyncResult.
	SourceTag() interface{}
	// PropagateError propagates an error from within the simple asynchronous
	// result to a given destination.
	//
	// If the #GCancellable given to a prior call to
	// g_simple_async_result_set_check_cancellable() is cancelled then this
	// function will return true with @dest set appropriately.
	PropagateError() bool
	// RunInThread runs the asynchronous job in a separate thread and then calls
	// g_simple_async_result_complete_in_idle() on @simple to return the result
	// to the appropriate main loop.
	//
	// Calling this function takes a reference to @simple for as long as is
	// needed to run the job and report its completion.
	RunInThread(_func SimpleAsyncThreadFunc, ioPriority int, cancellable Cancellable)
	// SetCheckCancellable sets a #GCancellable to check before dispatching
	// results.
	//
	// This function has one very specific purpose: the provided cancellable is
	// checked at the time of g_simple_async_result_propagate_error() If it is
	// cancelled, these functions will return an "Operation was cancelled" error
	// (G_IO_ERROR_CANCELLED).
	//
	// Implementors of cancellable asynchronous functions should use this in
	// order to provide a guarantee to their callers that cancelling an async
	// operation will reliably result in an error being returned for that
	// operation (even if a positive result for the operation has already been
	// sent as an idle to the main context to be dispatched).
	//
	// The checking described above is done regardless of any call to the
	// unrelated g_simple_async_result_set_handle_cancellation() function.
	SetCheckCancellable(checkCancellable Cancellable)
	// SetFromError sets the result from a #GError.
	SetFromError(error *glib.Error)
	// SetHandleCancellation sets whether to handle cancellation within the
	// asynchronous operation.
	//
	// This function has nothing to do with
	// g_simple_async_result_set_check_cancellable(). It only refers to the
	// #GCancellable passed to g_simple_async_result_run_in_thread().
	SetHandleCancellation(handleCancellation bool)
	// SetOpResGboolean sets the operation result to a boolean within the
	// asynchronous result.
	SetOpResGboolean(opRes bool)
	// SetOpResGssize sets the operation result within the asynchronous result
	// to the given @op_res.
	SetOpResGssize(opRes int)
	// TakeError sets the result from @error, and takes over the caller's
	// ownership of @error, so the caller does not need to free it any more.
	TakeError(error *glib.Error)
}

// simpleAsyncResult implements the SimpleAsyncResult interface.
type simpleAsyncResult struct {
	gextras.Objector
}

// WrapSimpleAsyncResult wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAsyncResult(obj *externglib.Object) SimpleAsyncResult {
	return SimpleAsyncResult{
		gextras.Objector: (obj),
	}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAsyncResult(obj), nil
}

// NewSimpleAsyncResult constructs a class SimpleAsyncResult.
func NewSimpleAsyncResult(sourceObject gextras.Objector, callback AsyncReadyCallback, sourceTag interface{}) SimpleAsyncResult {
	var arg1 *C.GObject
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))
	var arg4 C.gpointer

	arg1 = (*C.GObject)(sourceObject.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(sourceTag))

	ret := C.g_simple_async_result_new(arg1, arg2, arg4)

	var ret0 SimpleAsyncResult

	ret0 = WrapSimpleAsyncResult(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSimpleAsyncResultFromError constructs a class SimpleAsyncResult.
func NewSimpleAsyncResultFromError(sourceObject gextras.Objector, callback AsyncReadyCallback, error *glib.Error) SimpleAsyncResult {
	var arg1 *C.GObject
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))
	var arg4 *C.GError

	arg1 = (*C.GObject)(sourceObject.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = (*C.GError)(error.Native())

	ret := C.g_simple_async_result_new_from_error(arg1, arg2, arg4)

	var ret0 SimpleAsyncResult

	ret0 = WrapSimpleAsyncResult(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSimpleAsyncResultTakeError constructs a class SimpleAsyncResult.
func NewSimpleAsyncResultTakeError(sourceObject gextras.Objector, callback AsyncReadyCallback, error *glib.Error) SimpleAsyncResult {
	var arg1 *C.GObject
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))
	var arg4 *C.GError

	arg1 = (*C.GObject)(sourceObject.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = (*C.GError)(error.Native())

	ret := C.g_simple_async_result_new_take_error(arg1, arg2, arg4)

	var ret0 SimpleAsyncResult

	ret0 = WrapSimpleAsyncResult(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Complete completes an asynchronous I/O job immediately. Must be called in
// the thread where the asynchronous result was to be delivered, as it
// invokes the callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
//
// Calling this function takes a reference to @simple for as long as is
// needed to complete the call.
func (simple simpleAsyncResult) Complete() {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	C.g_simple_async_result_complete(arg0)
}

// CompleteInIdle completes an asynchronous function in an idle handler in
// the [thread-default main context][g-main-context-push-thread-default] of
// the thread that @simple was initially created in (and re-pushes that
// context around the invocation of the callback).
//
// Calling this function takes a reference to @simple for as long as is
// needed to complete the call.
func (simple simpleAsyncResult) CompleteInIdle() {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	C.g_simple_async_result_complete_in_idle(arg0)
}

// OpResGboolean gets the operation result boolean from within the
// asynchronous result.
func (simple simpleAsyncResult) OpResGboolean() bool {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	ret := C.g_simple_async_result_get_op_res_gboolean(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// OpResGpointer gets a pointer result as returned by the asynchronous
// function.
func (simple simpleAsyncResult) OpResGpointer() interface{} {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	ret := C.g_simple_async_result_get_op_res_gpointer(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// OpResGssize gets a gssize from the asynchronous result.
func (simple simpleAsyncResult) OpResGssize() int {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	ret := C.g_simple_async_result_get_op_res_gssize(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SourceTag gets the source tag for the AsyncResult.
func (simple simpleAsyncResult) SourceTag() interface{} {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	ret := C.g_simple_async_result_get_source_tag(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// PropagateError propagates an error from within the simple asynchronous
// result to a given destination.
//
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this
// function will return true with @dest set appropriately.
func (simple simpleAsyncResult) PropagateError() bool {
	var arg0 *C.GSimpleAsyncResult

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())

	ret := C.g_simple_async_result_propagate_error(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RunInThread runs the asynchronous job in a separate thread and then calls
// g_simple_async_result_complete_in_idle() on @simple to return the result
// to the appropriate main loop.
//
// Calling this function takes a reference to @simple for as long as is
// needed to run the job and report its completion.
func (simple simpleAsyncResult) RunInThread(_func SimpleAsyncThreadFunc, ioPriority int, cancellable Cancellable) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 C.GSimpleAsyncThreadFunc
	var arg2 C.int
	var arg3 *C.GCancellable

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = (*[0]byte)(C.gotk4_SimpleAsyncThreadFunc)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())

	C.g_simple_async_result_run_in_thread(arg0, arg1, arg2, arg3)
}

// SetCheckCancellable sets a #GCancellable to check before dispatching
// results.
//
// This function has one very specific purpose: the provided cancellable is
// checked at the time of g_simple_async_result_propagate_error() If it is
// cancelled, these functions will return an "Operation was cancelled" error
// (G_IO_ERROR_CANCELLED).
//
// Implementors of cancellable asynchronous functions should use this in
// order to provide a guarantee to their callers that cancelling an async
// operation will reliably result in an error being returned for that
// operation (even if a positive result for the operation has already been
// sent as an idle to the main context to be dispatched).
//
// The checking described above is done regardless of any call to the
// unrelated g_simple_async_result_set_handle_cancellation() function.
func (simple simpleAsyncResult) SetCheckCancellable(checkCancellable Cancellable) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 *C.GCancellable

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = (*C.GCancellable)(checkCancellable.Native())

	C.g_simple_async_result_set_check_cancellable(arg0, arg1)
}

// SetFromError sets the result from a #GError.
func (simple simpleAsyncResult) SetFromError(error *glib.Error) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 *C.GError

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_simple_async_result_set_from_error(arg0, arg1)
}

// SetHandleCancellation sets whether to handle cancellation within the
// asynchronous operation.
//
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable(). It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
func (simple simpleAsyncResult) SetHandleCancellation(handleCancellation bool) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 C.gboolean

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = gextras.Cbool(handleCancellation)

	C.g_simple_async_result_set_handle_cancellation(arg0, arg1)
}

// SetOpResGboolean sets the operation result to a boolean within the
// asynchronous result.
func (simple simpleAsyncResult) SetOpResGboolean(opRes bool) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 C.gboolean

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = gextras.Cbool(opRes)

	C.g_simple_async_result_set_op_res_gboolean(arg0, arg1)
}

// SetOpResGssize sets the operation result within the asynchronous result
// to the given @op_res.
func (simple simpleAsyncResult) SetOpResGssize(opRes int) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 C.gssize

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = C.gssize(opRes)

	C.g_simple_async_result_set_op_res_gssize(arg0, arg1)
}

// TakeError sets the result from @error, and takes over the caller's
// ownership of @error, so the caller does not need to free it any more.
func (simple simpleAsyncResult) TakeError(error *glib.Error) {
	var arg0 *C.GSimpleAsyncResult
	var arg1 *C.GError

	arg0 = (*C.GSimpleAsyncResult)(simple.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_simple_async_result_take_error(arg0, arg1)
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

// simpleIOStream implements the SimpleIOStream interface.
type simpleIOStream struct {
	IOStream
}

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return SimpleIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream constructs a class SimpleIOStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var arg1 *C.GInputStream
	var arg2 *C.GOutputStream

	arg1 = (*C.GInputStream)(inputStream.Native())
	arg2 = (*C.GOutputStream)(outputStream.Native())

	ret := C.g_simple_io_stream_new(arg1, arg2)

	var ret0 SimpleIOStream

	ret0 = WrapSimpleIOStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

// simplePermission implements the SimplePermission interface.
type simplePermission struct {
	Permission
}

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return SimplePermission{
		Permission: WrapPermission(obj),
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

// NewSimplePermission constructs a class SimplePermission.
func NewSimplePermission(allowed bool) SimplePermission {
	var arg1 C.gboolean

	arg1 = gextras.Cbool(allowed)

	ret := C.g_simple_permission_new(arg1)

	var ret0 SimplePermission

	ret0 = WrapSimplePermission(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SimpleProxyResolver is a simple Resolver implementation that handles a single
// default proxy, multiple URI-scheme-specific proxies, and a list of hosts that
// proxies should not be used for.
//
// ProxyResolver is never the default proxy resolver, but it can be used as the
// base class for another proxy resolver implementation, or it can be created
// and used manually, such as with g_socket_client_set_proxy_resolver().
type SimpleProxyResolver interface {
	gextras.Objector

	// SetDefaultProxy sets the default proxy on @resolver, to be used for any
	// URIs that don't match ProxyResolver:ignore-hosts or a proxy set via
	// g_simple_proxy_resolver_set_uri_proxy().
	//
	// If @default_proxy starts with "socks://", ProxyResolver will treat it as
	// referring to all three of the socks5, socks4a, and socks4 proxy types.
	SetDefaultProxy(defaultProxy string)
	// SetIgnoreHosts sets the list of ignored hosts.
	//
	// See ProxyResolver:ignore-hosts for more details on how the @ignore_hosts
	// argument is interpreted.
	SetIgnoreHosts(ignoreHosts string)
	// SetURIProxy adds a URI-scheme-specific proxy to @resolver; URIs whose
	// scheme matches @uri_scheme (and which don't match
	// ProxyResolver:ignore-hosts) will be proxied via @proxy.
	//
	// As with ProxyResolver:default-proxy, if @proxy starts with "socks://",
	// ProxyResolver will treat it as referring to all three of the socks5,
	// socks4a, and socks4 proxy types.
	SetURIProxy(uriScheme string, proxy string)
}

// simpleProxyResolver implements the SimpleProxyResolver interface.
type simpleProxyResolver struct {
	gextras.Objector
}

// WrapSimpleProxyResolver wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleProxyResolver(obj *externglib.Object) SimpleProxyResolver {
	return SimpleProxyResolver{
		gextras.Objector: (obj),
	}
}

func marshalSimpleProxyResolver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleProxyResolver(obj), nil
}

// SetDefaultProxy sets the default proxy on @resolver, to be used for any
// URIs that don't match ProxyResolver:ignore-hosts or a proxy set via
// g_simple_proxy_resolver_set_uri_proxy().
//
// If @default_proxy starts with "socks://", ProxyResolver will treat it as
// referring to all three of the socks5, socks4a, and socks4 proxy types.
func (resolver simpleProxyResolver) SetDefaultProxy(defaultProxy string) {
	var arg0 *C.GSimpleProxyResolver
	var arg1 *C.gchar

	arg0 = (*C.GSimpleProxyResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(defaultProxy))
	defer C.free(unsafe.Pointer(arg1))

	C.g_simple_proxy_resolver_set_default_proxy(arg0, arg1)
}

// SetIgnoreHosts sets the list of ignored hosts.
//
// See ProxyResolver:ignore-hosts for more details on how the @ignore_hosts
// argument is interpreted.
func (resolver simpleProxyResolver) SetIgnoreHosts(ignoreHosts string) {
	var arg0 *C.GSimpleProxyResolver
	var arg1 **C.gchar

	arg0 = (*C.GSimpleProxyResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(ignoreHosts))
	defer C.free(unsafe.Pointer(arg1))

	C.g_simple_proxy_resolver_set_ignore_hosts(arg0, arg1)
}

// SetURIProxy adds a URI-scheme-specific proxy to @resolver; URIs whose
// scheme matches @uri_scheme (and which don't match
// ProxyResolver:ignore-hosts) will be proxied via @proxy.
//
// As with ProxyResolver:default-proxy, if @proxy starts with "socks://",
// ProxyResolver will treat it as referring to all three of the socks5,
// socks4a, and socks4 proxy types.
func (resolver simpleProxyResolver) SetURIProxy(uriScheme string, proxy string) {
	var arg0 *C.GSimpleProxyResolver
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg0 = (*C.GSimpleProxyResolver)(resolver.Native())
	arg1 = (*C.gchar)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(proxy))
	defer C.free(unsafe.Pointer(arg2))

	C.g_simple_proxy_resolver_set_uri_proxy(arg0, arg1, arg2)
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which don’t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	gextras.Objector

	// Accept: accept incoming connections on a connection-based socket. This
	// removes the first outstanding connection request from the listening
	// socket and creates a #GSocket object for it.
	//
	// The @socket must be bound to a local address with g_socket_bind() and
	// must be listening for incoming connections (g_socket_listen()).
	//
	// If there are no outstanding connections then the operation will block or
	// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
	// notified of an incoming connection, wait for the G_IO_IN condition.
	Accept(cancellable Cancellable) Socket
	// Bind: when a socket is created it is attached to an address family, but
	// it doesn't have an address in this family. g_socket_bind() assigns the
	// address (sometimes called name) of the socket.
	//
	// It is generally required to bind to a local address before you can
	// receive connections. (See g_socket_listen() and g_socket_accept() ). In
	// certain situations, you may also want to bind a socket that will be used
	// to initiate connections, though this is not normally required.
	//
	// If @socket is a TCP socket, then @allow_reuse controls the setting of the
	// `SO_REUSEADDR` socket option; normally it should be true for server
	// sockets (sockets that you will eventually call g_socket_accept() on), and
	// false for client sockets. (Failing to set this flag on a server socket
	// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
	// server program is stopped and then immediately restarted.)
	//
	// If @socket is a UDP socket, then @allow_reuse determines whether or not
	// other UDP sockets can be bound to the same address at the same time. In
	// particular, you can have several UDP sockets bound to the same address,
	// and they will all receive all of the multicast and broadcast packets sent
	// to that address. (The behavior of unicast UDP packets to an address with
	// multiple listeners is not defined.)
	Bind(address SocketAddress, allowReuse bool) bool
	// CheckConnectResult checks and resets the pending connect error for the
	// socket. This is used to check for errors when g_socket_connect() is used
	// in non-blocking mode.
	CheckConnectResult() bool
	// Close closes the socket, shutting down any active connection.
	//
	// Closing a socket does not wait for all outstanding I/O operations to
	// finish, so the caller should not rely on them to be guaranteed to
	// complete even if the close returns with no error.
	//
	// Once the socket is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
	// error.
	//
	// Sockets will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Beware that due to the way that TCP works, it is possible for
	// recently-sent data to be lost if either you close a socket while the
	// G_IO_IN condition is set, or else if the remote connection tries to send
	// something to you after you close the socket but before it has finished
	// reading all of the data you sent. There is no easy generic way to avoid
	// this problem; the easiest fix is to design the network protocol such that
	// the client will never send data "out of turn". Another solution is for
	// the server to half-close the connection by calling g_socket_shutdown()
	// with only the @shutdown_write flag set, and then wait for the client to
	// notice this and close its side of the connection, after which the server
	// can safely call g_socket_close(). (This is what Connection does if you
	// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
	// works if the client will close its connection after the server does.)
	Close() bool
	// ConditionCheck checks on the readiness of @socket to perform operations.
	// The operations specified in @condition are checked for and masked against
	// the currently-satisfied conditions on @socket. The result is returned.
	//
	// Note that on Windows, it is possible for an operation to return
	// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
	// has claimed that the socket is ready for writing. Rather than calling
	// g_socket_condition_check() and then writing to the socket if it succeeds,
	// it is generally better to simply try writing to the socket right away,
	// and try again later if the initial attempt returns
	// G_IO_ERROR_WOULD_BLOCK.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
	// conditions will always be set in the output if they are true.
	//
	// This call never blocks.
	ConditionCheck(condition glib.IOCondition) glib.IOCondition
	// ConditionTimedWait waits for up to @timeout_us microseconds for
	// @condition to become true on @socket. If the condition is met, true is
	// returned.
	//
	// If @cancellable is cancelled before the condition is met, or if
	// @timeout_us (or the socket's #GSocket:timeout) is reached before the
	// condition is met, then false is returned and @error, if non-nil, is set
	// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// If you don't want a timeout, use g_socket_condition_wait().
	// (Alternatively, you can pass -1 for @timeout_us.)
	//
	// Note that although @timeout_us is in microseconds for consistency with
	// other GLib APIs, this function actually only has millisecond resolution,
	// and the behavior is undefined if @timeout_us is not an exact number of
	// milliseconds.
	ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) bool
	// ConditionWait waits for @condition to become true on @socket. When the
	// condition is met, true is returned.
	//
	// If @cancellable is cancelled before the condition is met, or if the
	// socket has a timeout set and it is reached before the condition is met,
	// then false is returned and @error, if non-nil, is set to the appropriate
	// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
	//
	// See also g_socket_condition_timed_wait().
	ConditionWait(condition glib.IOCondition, cancellable Cancellable) bool
	// Connect: connect the socket to the specified remote address.
	//
	// For connection oriented socket this generally means we attempt to make a
	// connection to the @address. For a connection-less socket it sets the
	// default address for g_socket_send() and discards all incoming datagrams
	// from other sources.
	//
	// Generally connection oriented sockets can only connect once, but
	// connection-less sockets can connect multiple times to change the default
	// address.
	//
	// If the connect call needs to do network I/O it will block, unless
	// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
	// user can be notified of the connection finishing by waiting for the
	// G_IO_OUT condition. The result of the connection must then be checked
	// with g_socket_check_connect_result().
	Connect(address SocketAddress, cancellable Cancellable) bool
	// ConnectionFactoryCreateConnection creates a Connection subclass of the
	// right type for @socket.
	ConnectionFactoryCreateConnection() SocketConnection
	// CreateSource creates a #GSource that can be attached to a GMainContext to
	// monitor for the availability of the specified @condition on the socket.
	// The #GSource keeps a reference to the @socket.
	//
	// The callback on the source is of the SourceFunc type.
	//
	// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
	// conditions will always be reported output if they are true.
	//
	// @cancellable if not nil can be used to cancel the source, which will
	// cause the source to trigger, reporting the current condition (which is
	// likely 0 unless cancellation happened at the same time as a condition
	// change). You can check for this in the callback using
	// g_cancellable_is_cancelled().
	//
	// If @socket has a timeout set, and it is reached before @condition occurs,
	// the source will then trigger anyway, reporting G_IO_IN or G_IO_OUT
	// depending on @condition. However, @socket will have been marked as having
	// had a timeout, and so the next #GSocket I/O method you call will then
	// fail with a G_IO_ERROR_TIMED_OUT.
	CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source
	// AvailableBytes: get the amount of data pending in the OS input buffer,
	// without blocking.
	//
	// If @socket is a UDP or SCTP socket, this will return the size of just the
	// next packet, even if additional packets are buffered after that one.
	//
	// Note that on Windows, this function is rather inefficient in the UDP
	// case, and so if you know any plausible upper bound on the size of the
	// incoming packet, it is better to just do a g_socket_receive() with a
	// buffer of that size, rather than calling g_socket_get_available_bytes()
	// first and then doing a receive of exactly the right size.
	AvailableBytes() int
	// Blocking gets the blocking mode of the socket. For details on blocking
	// I/O, see g_socket_set_blocking().
	Blocking() bool
	// Broadcast gets the broadcast setting on @socket; if true, it is possible
	// to send packets to broadcast addresses.
	Broadcast() bool
	// Credentials returns the credentials of the foreign process connected to
	// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
	// sockets).
	//
	// If this operation isn't supported on the OS, the method fails with the
	// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
	// the SO_PEERCRED option on the underlying socket.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
	// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
	// since GLib 2.66
	//
	// Other ways to obtain credentials from a foreign peer includes the
	// CredentialsMessage type and g_unix_connection_send_credentials() /
	// g_unix_connection_receive_credentials() functions.
	Credentials() Credentials
	// Family gets the socket family of the socket.
	Family() SocketFamily
	// Fd returns the underlying OS socket object. On unix this is a socket file
	// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
	// useful for doing platform specific or otherwise unusual operations on the
	// socket.
	Fd() int
	// Keepalive gets the keepalive mode of the socket. For details on this, see
	// g_socket_set_keepalive().
	Keepalive() bool
	// ListenBacklog gets the listen backlog setting of the socket. For details
	// on this, see g_socket_set_listen_backlog().
	ListenBacklog() int
	// LocalAddress: try to get the local address of a bound socket. This is
	// only useful if the socket has been bound to a local address, either
	// explicitly or implicitly when connecting.
	LocalAddress() SocketAddress
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
	// (the default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	MulticastLoopback() bool
	// MulticastTtl gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	MulticastTtl() uint
	// Option gets the value of an integer-valued option on @socket, as with
	// getsockopt(). (If you need to fetch a non-integer-valued option, you will
	// need to call getsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	//
	// Note that even for socket options that are a single byte in size, @value
	// is still a pointer to a #gint variable, not a #guchar;
	// g_socket_get_option() will handle the conversion internally.
	Option(level int, optname int) (value int, ok bool)
	// Protocol gets the socket protocol id the socket was created with. In case
	// the protocol is unknown, -1 is returned.
	Protocol() SocketProtocol
	// RemoteAddress: try to get the remote address of a connected socket. This
	// is only useful for connection oriented sockets that have been connected.
	RemoteAddress() SocketAddress
	// SocketType gets the socket type of the socket.
	SocketType() SocketType
	// Timeout gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	Timeout() uint
	// Ttl gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	Ttl() uint
	// IsClosed checks whether a socket is closed.
	IsClosed() bool
	// IsConnected: check whether the socket is connected. This is only useful
	// for connection-oriented sockets.
	//
	// If using g_socket_shutdown(), this function will return true until the
	// socket has been shut down for reading and writing. If you do a
	// non-blocking connect, this function will not return true until after you
	// call g_socket_check_connect_result().
	IsConnected() bool
	// JoinMulticastGroup registers @socket to receive multicast messages sent
	// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is true, source-specific multicast as defined in RFC
	// 4604 is used. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// To bind to a given source-specific multicast address, use
	// g_socket_join_multicast_group_ssm() instead.
	JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool
	// JoinMulticastGroupSsm registers @socket to receive multicast messages
	// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
	// have been bound to an appropriate interface and port with
	// g_socket_bind().
	//
	// If @iface is nil, the system will automatically pick an interface to bind
	// to based on @group.
	//
	// If @source_specific is not nil, use source-specific multicast as defined
	// in RFC 4604. Note that on older platforms this may fail with a
	// G_IO_ERROR_NOT_SUPPORTED error.
	//
	// Note that this function can be called multiple times for the same @group
	// with different @source_specific in order to receive multicast packets
	// from more than one source.
	JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool
	// LeaveMulticastGroup removes @socket from the multicast group defined by
	// @group, @iface, and @source_specific (which must all have the same values
	// they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	//
	// To unbind to a given source-specific multicast address, use
	// g_socket_leave_multicast_group_ssm() instead.
	LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool
	// LeaveMulticastGroupSsm removes @socket from the multicast group defined
	// by @group, @iface, and @source_specific (which must all have the same
	// values they had when you joined the group).
	//
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool
	// Listen marks the socket as a server socket, i.e. a socket that is used to
	// accept incoming requests using g_socket_accept().
	//
	// Before calling this the socket must be bound to a local address using
	// g_socket_bind().
	//
	// To set the maximum amount of outstanding clients, use
	// g_socket_set_listen_backlog().
	Listen() bool
	// Receive: receive data (up to @size bytes) from a socket. This is mainly
	// used by connection-oriented sockets; it is identical to
	// g_socket_receive_from() with @address set to nil.
	//
	// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
	// g_socket_receive() will always read either 0 or 1 complete messages from
	// the socket. If the received message is too large to fit in @buffer, then
	// the data beyond @size bytes will be discarded, without any explicit
	// indication that this has occurred.
	//
	// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
	// number of bytes, up to @size. If more than @size bytes have been
	// received, the additional data will be returned in future calls to
	// g_socket_receive().
	//
	// If the socket is in blocking mode the call will block until there is some
	// data to receive, the connection is closed, or there is an error. If there
	// is no data available and the socket is in non-blocking mode, a
	// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
	// is available, wait for the G_IO_IN condition.
	//
	// On error -1 is returned and @error is set accordingly.
	Receive(cancellable Cancellable) (buffer []byte, size uint, gssize int)
	// ReceiveFrom: receive data (up to @size bytes) from a socket.
	//
	// If @address is non-nil then @address will be set equal to the source
	// address of the received packet. @address is owned by the caller.
	//
	// See g_socket_receive() for additional information.
	ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []byte, size uint, gssize int)
	// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
	// except that the choice of blocking or non-blocking behavior is determined
	// by the @blocking argument rather than by @socket's properties.
	ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []byte, size uint, gssize int)
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
	// operations (which don’t take an explicit blocking parameter) block until
	// they succeed or there is an error. In non-blocking mode all functions
	// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
	//
	// All sockets are created in blocking mode. However, note that the platform
	// level socket is always non-blocking, and blocking mode is a GSocket level
	// feature.
	SetBlocking(blocking bool)
	// SetBroadcast sets whether @socket should allow sending to broadcast
	// addresses. This is false by default.
	SetBroadcast(broadcast bool)
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
	// socket. When this flag is set on a socket, the system will attempt to
	// verify that the remote socket endpoint is still present if a sufficiently
	// long period of time passes with no data being exchanged. If the system is
	// unable to verify the presence of the remote endpoint, it will
	// automatically close the connection.
	//
	// This option is only functional on certain kinds of sockets. (Notably,
	// G_SOCKET_PROTOCOL_TCP sockets.)
	//
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag on
	// a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(keepalive bool)
	// SetListenBacklog sets the maximum number of outstanding connections
	// allowed when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them on time
	// then the new connections will be refused.
	//
	// Note that this must be called before g_socket_listen() and has no effect
	// if called after that.
	SetListenBacklog(backlog int)
	// SetMulticastLoopback sets whether outgoing multicast packets will be
	// received by sockets listening on that multicast address on the same host.
	// This is true by default.
	SetMulticastLoopback(loopback bool)
	// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
	// @socket. By default, this is 1, meaning that multicast packets will not
	// leave the local network.
	SetMulticastTtl(ttl uint)
	// SetOption sets the value of an integer-valued option on @socket, as with
	// setsockopt(). (If you need to set a non-integer-valued option, you will
	// need to call setsockopt() directly.)
	//
	// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
	// headers that will define most of the standard/portable socket options.
	// For unusual socket protocols or platform-dependent options, you may need
	// to include additional headers.
	SetOption(level int, optname int, value int) bool
	// SetTimeout sets the time in seconds after which I/O operations on @socket
	// will time out if they have not yet completed.
	//
	// On a blocking socket, this means that any blocking #GSocket operation
	// will time out after @timeout seconds of inactivity, returning
	// G_IO_ERROR_TIMED_OUT.
	//
	// On a non-blocking socket, calls to g_socket_condition_wait() will also
	// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
	// g_socket_create_source() will trigger after @timeout seconds of
	// inactivity, with the requested condition set, at which point calling
	// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
	// etc, will fail with G_IO_ERROR_TIMED_OUT.
	//
	// If @timeout is 0 (the default), operations will never time out on their
	// own.
	//
	// Note that if an I/O operation is interrupted by a signal, this may cause
	// the timeout to be reset.
	SetTimeout(timeout uint)
	// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
	// default the platform-specific default value is used.
	SetTtl(ttl uint)
	// Shutdown: shut down part or all of a full-duplex connection.
	//
	// If @shutdown_read is true then the receiving side of the connection is
	// shut down, and further reading is disallowed.
	//
	// If @shutdown_write is true then the sending side of the connection is
	// shut down, and further writing is disallowed.
	//
	// It is allowed for both @shutdown_read and @shutdown_write to be true.
	//
	// One example where it is useful to shut down only one side of a connection
	// is graceful disconnect for TCP connections where you close the sending
	// side, then wait for the other side to close the connection, thus ensuring
	// that the other side saw all sent data.
	Shutdown(shutdownRead bool, shutdownWrite bool) bool
	// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
	//
	// IPv4 sockets are capable of speaking IPv4. On some operating systems and
	// under some combinations of circumstances IPv6 sockets are also capable of
	// speaking IPv4. See RFC 3493 section 3.7 for more information.
	//
	// No other types of sockets are currently considered as being capable of
	// speaking IPv4.
	SpeaksIpv4() bool
}

// socket implements the Socket interface.
type socket struct {
	gextras.Objector
}

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return Socket{
		gextras.Objector: (obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

// NewSocket constructs a class Socket.
func NewSocket(family SocketFamily, _type SocketType, protocol SocketProtocol) Socket {
	var arg1 C.GSocketFamily
	var arg2 C.GSocketType
	var arg3 C.GSocketProtocol

	arg1 = (C.GSocketFamily)(family)
	arg2 = (C.GSocketType)(_type)
	arg3 = (C.GSocketProtocol)(protocol)

	ret := C.g_socket_new(arg1, arg2, arg3)

	var ret0 Socket

	ret0 = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewSocketFromFd constructs a class Socket.
func NewSocketFromFd(fd int) Socket {
	var arg1 C.gint

	arg1 = C.gint(fd)

	ret := C.g_socket_new_from_fd(arg1)

	var ret0 Socket

	ret0 = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Accept: accept incoming connections on a connection-based socket. This
// removes the first outstanding connection request from the listening
// socket and creates a #GSocket object for it.
//
// The @socket must be bound to a local address with g_socket_bind() and
// must be listening for incoming connections (g_socket_listen()).
//
// If there are no outstanding connections then the operation will block or
// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be
// notified of an incoming connection, wait for the G_IO_IN condition.
func (socket socket) Accept(cancellable Cancellable) Socket {
	var arg0 *C.GSocket
	var arg1 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_accept(arg0, arg1)

	var ret0 Socket

	ret0 = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Bind: when a socket is created it is attached to an address family, but
// it doesn't have an address in this family. g_socket_bind() assigns the
// address (sometimes called name) of the socket.
//
// It is generally required to bind to a local address before you can
// receive connections. (See g_socket_listen() and g_socket_accept() ). In
// certain situations, you may also want to bind a socket that will be used
// to initiate connections, though this is not normally required.
//
// If @socket is a TCP socket, then @allow_reuse controls the setting of the
// `SO_REUSEADDR` socket option; normally it should be true for server
// sockets (sockets that you will eventually call g_socket_accept() on), and
// false for client sockets. (Failing to set this flag on a server socket
// may cause g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the
// server program is stopped and then immediately restarted.)
//
// If @socket is a UDP socket, then @allow_reuse determines whether or not
// other UDP sockets can be bound to the same address at the same time. In
// particular, you can have several UDP sockets bound to the same address,
// and they will all receive all of the multicast and broadcast packets sent
// to that address. (The behavior of unicast UDP packets to an address with
// multiple listeners is not defined.)
func (socket socket) Bind(address SocketAddress, allowReuse bool) bool {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = gextras.Cbool(allowReuse)

	ret := C.g_socket_bind(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// CheckConnectResult checks and resets the pending connect error for the
// socket. This is used to check for errors when g_socket_connect() is used
// in non-blocking mode.
func (socket socket) CheckConnectResult() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_check_connect_result(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Close closes the socket, shutting down any active connection.
//
// Closing a socket does not wait for all outstanding I/O operations to
// finish, so the caller should not rely on them to be guaranteed to
// complete even if the close returns with no error.
//
// Once the socket is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an
// error.
//
// Sockets will be automatically closed when the last reference is dropped,
// but you might want to call this function to make sure resources are
// released as early as possible.
//
// Beware that due to the way that TCP works, it is possible for
// recently-sent data to be lost if either you close a socket while the
// G_IO_IN condition is set, or else if the remote connection tries to send
// something to you after you close the socket but before it has finished
// reading all of the data you sent. There is no easy generic way to avoid
// this problem; the easiest fix is to design the network protocol such that
// the client will never send data "out of turn". Another solution is for
// the server to half-close the connection by calling g_socket_shutdown()
// with only the @shutdown_write flag set, and then wait for the client to
// notice this and close its side of the connection, after which the server
// can safely call g_socket_close(). (This is what Connection does if you
// call g_tcp_connection_set_graceful_disconnect(). But of course, this only
// works if the client will close its connection after the server does.)
func (socket socket) Close() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_close(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ConditionCheck checks on the readiness of @socket to perform operations.
// The operations specified in @condition are checked for and masked against
// the currently-satisfied conditions on @socket. The result is returned.
//
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check()
// has claimed that the socket is ready for writing. Rather than calling
// g_socket_condition_check() and then writing to the socket if it succeeds,
// it is generally better to simply try writing to the socket right away,
// and try again later if the initial attempt returns
// G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true.
//
// This call never blocks.
func (socket socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (C.GIOCondition)(condition)

	ret := C.g_socket_condition_check(arg0, arg1)

	var ret0 glib.IOCondition

	ret0 = glib.IOCondition(ret)

	return ret0
}

// ConditionTimedWait waits for up to @timeout_us microseconds for
// @condition to become true on @socket. If the condition is met, true is
// returned.
//
// If @cancellable is cancelled before the condition is met, or if
// @timeout_us (or the socket's #GSocket:timeout) is reached before the
// condition is met, then false is returned and @error, if non-nil, is set
// to the appropriate value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// If you don't want a timeout, use g_socket_condition_wait().
// (Alternatively, you can pass -1 for @timeout_us.)
//
// Note that although @timeout_us is in microseconds for consistency with
// other GLib APIs, this function actually only has millisecond resolution,
// and the behavior is undefined if @timeout_us is not an exact number of
// milliseconds.
func (socket socket) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) bool {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 C.gint64
	var arg3 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = C.gint64(timeoutUs)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_condition_timed_wait(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ConditionWait waits for @condition to become true on @socket. When the
// condition is met, true is returned.
//
// If @cancellable is cancelled before the condition is met, or if the
// socket has a timeout set and it is reached before the condition is met,
// then false is returned and @error, if non-nil, is set to the appropriate
// value (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// See also g_socket_condition_timed_wait().
func (socket socket) ConditionWait(condition glib.IOCondition, cancellable Cancellable) bool {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_condition_wait(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Connect: connect the socket to the specified remote address.
//
// For connection oriented socket this generally means we attempt to make a
// connection to the @address. For a connection-less socket it sets the
// default address for g_socket_send() and discards all incoming datagrams
// from other sources.
//
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the default
// address.
//
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the
// user can be notified of the connection finishing by waiting for the
// G_IO_OUT condition. The result of the connection must then be checked
// with g_socket_check_connect_result().
func (socket socket) Connect(address SocketAddress, cancellable Cancellable) bool {
	var arg0 *C.GSocket
	var arg1 *C.GSocketAddress
	var arg2 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_connect(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ConnectionFactoryCreateConnection creates a Connection subclass of the
// right type for @socket.
func (socket socket) ConnectionFactoryCreateConnection() SocketConnection {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_connection_factory_create_connection(arg0)

	var ret0 SocketConnection

	ret0 = WrapSocketConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CreateSource creates a #GSource that can be attached to a GMainContext to
// monitor for the availability of the specified @condition on the socket.
// The #GSource keeps a reference to the @socket.
//
// The callback on the source is of the SourceFunc type.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in @condition; these
// conditions will always be reported output if they are true.
//
// @cancellable if not nil can be used to cancel the source, which will
// cause the source to trigger, reporting the current condition (which is
// likely 0 unless cancellation happened at the same time as a condition
// change). You can check for this in the callback using
// g_cancellable_is_cancelled().
//
// If @socket has a timeout set, and it is reached before @condition occurs,
// the source will then trigger anyway, reporting G_IO_IN or G_IO_OUT
// depending on @condition. However, @socket will have been marked as having
// had a timeout, and so the next #GSocket I/O method you call will then
// fail with a G_IO_ERROR_TIMED_OUT.
func (socket socket) CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source {
	var arg0 *C.GSocket
	var arg1 C.GIOCondition
	var arg2 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (C.GIOCondition)(condition)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_create_source(arg0, arg1, arg2)

	var ret0 *glib.Source

	ret0 = glib.WrapSource(ret)

	return ret0
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If @socket is a UDP or SCTP socket, this will return the size of just the
// next packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP
// case, and so if you know any plausible upper bound on the size of the
// incoming packet, it is better to just do a g_socket_receive() with a
// buffer of that size, rather than calling g_socket_get_available_bytes()
// first and then doing a receive of exactly the right size.
func (socket socket) AvailableBytes() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_available_bytes(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Blocking gets the blocking mode of the socket. For details on blocking
// I/O, see g_socket_set_blocking().
func (socket socket) Blocking() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_blocking(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Broadcast gets the broadcast setting on @socket; if true, it is possible
// to send packets to broadcast addresses.
func (socket socket) Broadcast() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_broadcast(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Credentials returns the credentials of the foreign process connected to
// this socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX
// sockets).
//
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading
// the SO_PEERCRED option on the underlying socket.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26 - OpenBSD since GLib 2.30 - Solaris, Illumos and
// OpenSolaris since GLib 2.40 - NetBSD since GLib 2.42 - macOS, tvOS, iOS
// since GLib 2.66
//
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
func (socket socket) Credentials() Credentials {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_credentials(arg0)

	var ret0 Credentials

	ret0 = WrapCredentials(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Family gets the socket family of the socket.
func (socket socket) Family() SocketFamily {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
func (socket socket) Fd() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Keepalive gets the keepalive mode of the socket. For details on this, see
// g_socket_set_keepalive().
func (socket socket) Keepalive() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_keepalive(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ListenBacklog gets the listen backlog setting of the socket. For details
// on this, see g_socket_set_listen_backlog().
func (socket socket) ListenBacklog() int {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_listen_backlog(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// LocalAddress: try to get the local address of a bound socket. This is
// only useful if the socket has been bound to a local address, either
// explicitly or implicitly when connecting.
func (socket socket) LocalAddress() SocketAddress {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_local_address(arg0)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// MulticastLoopback gets the multicast loopback setting on @socket; if true
// (the default), outgoing multicast packets will be looped back to
// multicast listeners on the same host.
func (socket socket) MulticastLoopback() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_multicast_loopback(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// MulticastTtl gets the multicast time-to-live setting on @socket; see
// g_socket_set_multicast_ttl() for more details.
func (socket socket) MulticastTtl() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_multicast_ttl(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Option gets the value of an integer-valued option on @socket, as with
// getsockopt(). (If you need to fetch a non-integer-valued option, you will
// need to call getsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
// headers that will define most of the standard/portable socket options.
// For unusual socket protocols or platform-dependent options, you may need
// to include additional headers.
//
// Note that even for socket options that are a single byte in size, @value
// is still a pointer to a #gint variable, not a #guchar;
// g_socket_get_option() will handle the conversion internally.
func (socket socket) Option(level int, optname int) (value int, ok bool) {
	var arg0 *C.GSocket
	var arg1 C.gint
	var arg2 C.gint
	var arg3 *C.gint // out

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.gint(level)
	arg2 = C.gint(optname)

	ret := C.g_socket_get_option(arg0, arg1, arg2, &arg3)

	var ret0 int
	var ret1 bool

	ret0 = int(arg3)

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Protocol gets the socket protocol id the socket was created with. In case
// the protocol is unknown, -1 is returned.
func (socket socket) Protocol() SocketProtocol {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_protocol(arg0)

	var ret0 SocketProtocol

	ret0 = SocketProtocol(ret)

	return ret0
}

// RemoteAddress: try to get the remote address of a connected socket. This
// is only useful for connection oriented sockets that have been connected.
func (socket socket) RemoteAddress() SocketAddress {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_remote_address(arg0)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SocketType gets the socket type of the socket.
func (socket socket) SocketType() SocketType {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_socket_type(arg0)

	var ret0 SocketType

	ret0 = SocketType(ret)

	return ret0
}

// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
func (socket socket) Timeout() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_timeout(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Ttl gets the unicast time-to-live setting on @socket; see
// g_socket_set_ttl() for more details.
func (socket socket) Ttl() uint {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_get_ttl(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsClosed checks whether a socket is closed.
func (socket socket) IsClosed() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_is_closed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IsConnected: check whether the socket is connected. This is only useful
// for connection-oriented sockets.
//
// If using g_socket_shutdown(), this function will return true until the
// socket has been shut down for reading and writing. If you do a
// non-blocking connect, this function will not return true until after you
// call g_socket_check_connect_result().
func (socket socket) IsConnected() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_is_connected(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// JoinMulticastGroup registers @socket to receive multicast messages sent
// to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have
// been bound to an appropriate interface and port with g_socket_bind().
//
// If @iface is nil, the system will automatically pick an interface to bind
// to based on @group.
//
// If @source_specific is true, source-specific multicast as defined in RFC
// 4604 is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
func (socket socket) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 C.gboolean
	var arg3 *C.gchar

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = gextras.Cbool(sourceSpecific)
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_join_multicast_group(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// JoinMulticastGroupSsm registers @socket to receive multicast messages
// sent to @group. @socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must
// have been bound to an appropriate interface and port with
// g_socket_bind().
//
// If @iface is nil, the system will automatically pick an interface to bind
// to based on @group.
//
// If @source_specific is not nil, use source-specific multicast as defined
// in RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// Note that this function can be called multiple times for the same @group
// with different @source_specific in order to receive multicast packets
// from more than one source.
func (socket socket) JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 *C.GInetAddress
	var arg3 *C.gchar

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = (*C.GInetAddress)(sourceSpecific.Native())
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_join_multicast_group_ssm(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LeaveMulticastGroup removes @socket from the multicast group defined by
// @group, @iface, and @source_specific (which must all have the same values
// they had when you joined the group).
//
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
//
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
func (socket socket) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) bool {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 C.gboolean
	var arg3 *C.gchar

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = gextras.Cbool(sourceSpecific)
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_leave_multicast_group(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// LeaveMulticastGroupSsm removes @socket from the multicast group defined
// by @group, @iface, and @source_specific (which must all have the same
// values they had when you joined the group).
//
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
func (socket socket) LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) bool {
	var arg0 *C.GSocket
	var arg1 *C.GInetAddress
	var arg2 *C.GInetAddress
	var arg3 *C.gchar

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = (*C.GInetAddress)(group.Native())
	arg2 = (*C.GInetAddress)(sourceSpecific.Native())
	arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(arg3))

	ret := C.g_socket_leave_multicast_group_ssm(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Listen marks the socket as a server socket, i.e. a socket that is used to
// accept incoming requests using g_socket_accept().
//
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
//
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
func (socket socket) Listen() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_listen(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Receive: receive data (up to @size bytes) from a socket. This is mainly
// used by connection-oriented sockets; it is identical to
// g_socket_receive_from() with @address set to nil.
//
// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
// g_socket_receive() will always read either 0 or 1 complete messages from
// the socket. If the received message is too large to fit in @buffer, then
// the data beyond @size bytes will be discarded, without any explicit
// indication that this has occurred.
//
// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
// number of bytes, up to @size. If more than @size bytes have been
// received, the additional data will be returned in future calls to
// g_socket_receive().
//
// If the socket is in blocking mode the call will block until there is some
// data to receive, the connection is closed, or there is an error. If there
// is no data available and the socket is in non-blocking mode, a
// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data
// is available, wait for the G_IO_IN condition.
//
// On error -1 is returned and @error is set accordingly.
func (socket socket) Receive(cancellable Cancellable) (buffer []byte, size uint, gssize int) {
	var arg0 *C.GSocket
	var arg1 *C.gchar // out
	var arg2 C.gsize  // out
	var arg3 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive(arg0, &arg1, &arg2, arg3)

	var ret0 []byte
	var ret1 uint
	var ret2 int

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	ret2 = int(ret)

	return ret0, ret1, ret2
}

// ReceiveFrom: receive data (up to @size bytes) from a socket.
//
// If @address is non-nil then @address will be set equal to the source
// address of the received packet. @address is owned by the caller.
//
// See g_socket_receive() for additional information.
func (socket socket) ReceiveFrom(cancellable Cancellable) (address SocketAddress, buffer []byte, size uint, gssize int) {
	var arg0 *C.GSocket
	var arg1 **C.GSocketAddress // out
	var arg2 *C.gchar           // out
	var arg3 C.gsize            // out
	var arg4 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_from(arg0, &arg1, &arg2, &arg3, arg4)

	var ret0 SocketAddress
	var ret1 []byte
	var ret2 uint
	var ret3 int

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native())))

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret2 = uint(arg3)

	ret3 = int(ret)

	return ret0, ret1, ret2, ret3
}

// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined
// by the @blocking argument rather than by @socket's properties.
func (socket socket) ReceiveWithBlocking(blocking bool, cancellable Cancellable) (buffer []byte, size uint, gssize int) {
	var arg0 *C.GSocket
	var arg1 *C.gchar // out
	var arg2 C.gsize  // out
	var arg3 C.gboolean
	var arg4 *C.GCancellable

	arg0 = (*C.GSocket)(socket.Native())
	arg3 = gextras.Cbool(blocking)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_receive_with_blocking(arg0, &arg1, &arg2, arg3, arg4)

	var ret0 []byte
	var ret1 uint
	var ret2 int

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg1))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&arg1, func() {
			C.free(unsafe.Pointer(arg1))
		})
		defer runtime.KeepAlive(arg1)
	}

	ret1 = uint(arg2)

	ret2 = int(ret)

	return ret0, ret1, ret2
}

// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which don’t take an explicit blocking parameter) block until
// they succeed or there is an error. In non-blocking mode all functions
// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
//
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
func (socket socket) SetBlocking(blocking bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = gextras.Cbool(blocking)

	C.g_socket_set_blocking(arg0, arg1)
}

// SetBroadcast sets whether @socket should allow sending to broadcast
// addresses. This is false by default.
func (socket socket) SetBroadcast(broadcast bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = gextras.Cbool(broadcast)

	C.g_socket_set_broadcast(arg0, arg1)
}

// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
// socket. When this flag is set on a socket, the system will attempt to
// verify that the remote socket endpoint is still present if a sufficiently
// long period of time passes with no data being exchanged. If the system is
// unable to verify the presence of the remote endpoint, it will
// automatically close the connection.
//
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
//
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag on
// a server socket if you want to allow clients to remain idle for long
// periods of time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
func (socket socket) SetKeepalive(keepalive bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = gextras.Cbool(keepalive)

	C.g_socket_set_keepalive(arg0, arg1)
}

// SetListenBacklog sets the maximum number of outstanding connections
// allowed when listening on this socket. If more clients than this are
// connecting to the socket and the application is not handling them on time
// then the new connections will be refused.
//
// Note that this must be called before g_socket_listen() and has no effect
// if called after that.
func (socket socket) SetListenBacklog(backlog int) {
	var arg0 *C.GSocket
	var arg1 C.gint

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(arg0, arg1)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be
// received by sockets listening on that multicast address on the same host.
// This is true by default.
func (socket socket) SetMulticastLoopback(loopback bool) {
	var arg0 *C.GSocket
	var arg1 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = gextras.Cbool(loopback)

	C.g_socket_set_multicast_loopback(arg0, arg1)
}

// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
// @socket. By default, this is 1, meaning that multicast packets will not
// leave the local network.
func (socket socket) SetMulticastTtl(ttl uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(arg0, arg1)
}

// SetOption sets the value of an integer-valued option on @socket, as with
// setsockopt(). (If you need to set a non-integer-valued option, you will
// need to call setsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system
// headers that will define most of the standard/portable socket options.
// For unusual socket protocols or platform-dependent options, you may need
// to include additional headers.
func (socket socket) SetOption(level int, optname int, value int) bool {
	var arg0 *C.GSocket
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.gint(level)
	arg2 = C.gint(optname)
	arg3 = C.gint(value)

	ret := C.g_socket_set_option(arg0, arg1, arg2, arg3)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetTimeout sets the time in seconds after which I/O operations on @socket
// will time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation
// will time out after @timeout seconds of inactivity, returning
// G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also
// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after @timeout seconds of
// inactivity, with the requested condition set, at which point calling
// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
// etc, will fail with G_IO_ERROR_TIMED_OUT.
//
// If @timeout is 0 (the default), operations will never time out on their
// own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause
// the timeout to be reset.
func (socket socket) SetTimeout(timeout uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.guint(timeout)

	C.g_socket_set_timeout(arg0, arg1)
}

// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
// default the platform-specific default value is used.
func (socket socket) SetTtl(ttl uint) {
	var arg0 *C.GSocket
	var arg1 C.guint

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = C.guint(ttl)

	C.g_socket_set_ttl(arg0, arg1)
}

// Shutdown: shut down part or all of a full-duplex connection.
//
// If @shutdown_read is true then the receiving side of the connection is
// shut down, and further reading is disallowed.
//
// If @shutdown_write is true then the sending side of the connection is
// shut down, and further writing is disallowed.
//
// It is allowed for both @shutdown_read and @shutdown_write to be true.
//
// One example where it is useful to shut down only one side of a connection
// is graceful disconnect for TCP connections where you close the sending
// side, then wait for the other side to close the connection, thus ensuring
// that the other side saw all sent data.
func (socket socket) Shutdown(shutdownRead bool, shutdownWrite bool) bool {
	var arg0 *C.GSocket
	var arg1 C.gboolean
	var arg2 C.gboolean

	arg0 = (*C.GSocket)(socket.Native())
	arg1 = gextras.Cbool(shutdownRead)
	arg2 = gextras.Cbool(shutdownWrite)

	ret := C.g_socket_shutdown(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
//
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
//
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
func (socket socket) SpeaksIpv4() bool {
	var arg0 *C.GSocket

	arg0 = (*C.GSocket)(socket.Native())

	ret := C.g_socket_speaks_ipv4(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SocketAddress is the equivalent of struct sockaddr in the BSD sockets API.
// This is an abstract class; use SocketAddress for internet sockets, or
// SocketAddress for UNIX domain sockets.
type SocketAddress interface {
	gextras.Objector

	// Family gets the socket family type of @address.
	Family() SocketFamily
	// NativeSize gets the size of @address's native struct sockaddr. You can
	// use this to allocate memory to pass to g_socket_address_to_native().
	NativeSize() int
	// ToNative converts a Address to a native struct sockaddr, which can be
	// passed to low-level functions like connect() or bind().
	//
	// If not enough space is available, a G_IO_ERROR_NO_SPACE error is
	// returned. If the address type is not known on the system then a
	// G_IO_ERROR_NOT_SUPPORTED error is returned.
	ToNative(dest interface{}, destlen uint) bool
}

// socketAddress implements the SocketAddress interface.
type socketAddress struct {
	gextras.Objector
}

// WrapSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddress(obj *externglib.Object) SocketAddress {
	return SocketAddress{
		gextras.Objector: (obj),
	}
}

func marshalSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddress(obj), nil
}

// NewSocketAddressFromNative constructs a class SocketAddress.
func NewSocketAddressFromNative(native interface{}, len uint) SocketAddress {
	var arg1 C.gpointer
	var arg2 C.gsize

	arg1 = C.gpointer(box.Assign(native))
	arg2 = C.gsize(len)

	ret := C.g_socket_address_new_from_native(arg1, arg2)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Family gets the socket family type of @address.
func (address socketAddress) Family() SocketFamily {
	var arg0 *C.GSocketAddress

	arg0 = (*C.GSocketAddress)(address.Native())

	ret := C.g_socket_address_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// NativeSize gets the size of @address's native struct sockaddr. You can
// use this to allocate memory to pass to g_socket_address_to_native().
func (address socketAddress) NativeSize() int {
	var arg0 *C.GSocketAddress

	arg0 = (*C.GSocketAddress)(address.Native())

	ret := C.g_socket_address_get_native_size(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ToNative converts a Address to a native struct sockaddr, which can be
// passed to low-level functions like connect() or bind().
//
// If not enough space is available, a G_IO_ERROR_NO_SPACE error is
// returned. If the address type is not known on the system then a
// G_IO_ERROR_NOT_SUPPORTED error is returned.
func (address socketAddress) ToNative(dest interface{}, destlen uint) bool {
	var arg0 *C.GSocketAddress
	var arg1 C.gpointer
	var arg2 C.gsize

	arg0 = (*C.GSocketAddress)(address.Native())
	arg1 = C.gpointer(box.Assign(dest))
	arg2 = C.gsize(destlen)

	ret := C.g_socket_address_to_native(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SocketAddressEnumerator is an enumerator type for Address instances. It is
// returned by enumeration functions such as g_socket_connectable_enumerate(),
// which returns a AddressEnumerator to list each Address which could be used to
// connect to that Connectable.
//
// Enumeration is typically a blocking operation, so the asynchronous methods
// g_socket_address_enumerator_next_async() and
// g_socket_address_enumerator_next_finish() should be used where possible.
//
// Each AddressEnumerator can only be enumerated once. Once
// g_socket_address_enumerator_next() has returned nil, further enumeration with
// that AddressEnumerator is not possible, and it can be unreffed.
type SocketAddressEnumerator interface {
	gextras.Objector

	// Next retrieves the next Address from @enumerator. Note that this may
	// block for some amount of time. (Eg, a Address may need to do a DNS lookup
	// before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid blocking.
	//
	// If @enumerator is expected to yield addresses, but for some reason is
	// unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error in
	// *@error. However, if the first call to g_socket_address_enumerator_next()
	// succeeds, then any further internal errors (other than @cancellable being
	// triggered) will be ignored.
	Next(cancellable Cancellable) SocketAddress
	// NextAsync: asynchronously retrieves the next Address from @enumerator and
	// then calls @callback, which must call
	// g_socket_address_enumerator_next_finish() to get the result.
	//
	// It is an error to call this multiple times before the previous callback
	// has finished.
	NextAsync(cancellable Cancellable, callback AsyncReadyCallback)
}

// socketAddressEnumerator implements the SocketAddressEnumerator interface.
type socketAddressEnumerator struct {
	gextras.Objector
}

// WrapSocketAddressEnumerator wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketAddressEnumerator(obj *externglib.Object) SocketAddressEnumerator {
	return SocketAddressEnumerator{
		gextras.Objector: (obj),
	}
}

func marshalSocketAddressEnumerator(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketAddressEnumerator(obj), nil
}

// Next retrieves the next Address from @enumerator. Note that this may
// block for some amount of time. (Eg, a Address may need to do a DNS lookup
// before it can return an address.) Use
// g_socket_address_enumerator_next_async() if you need to avoid blocking.
//
// If @enumerator is expected to yield addresses, but for some reason is
// unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error in
// *@error. However, if the first call to g_socket_address_enumerator_next()
// succeeds, then any further internal errors (other than @cancellable being
// triggered) will be ignored.
func (enumerator socketAddressEnumerator) Next(cancellable Cancellable) SocketAddress {
	var arg0 *C.GSocketAddressEnumerator
	var arg1 *C.GCancellable

	arg0 = (*C.GSocketAddressEnumerator)(enumerator.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_address_enumerator_next(arg0, arg1)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NextAsync: asynchronously retrieves the next Address from @enumerator and
// then calls @callback, which must call
// g_socket_address_enumerator_next_finish() to get the result.
//
// It is an error to call this multiple times before the previous callback
// has finished.
func (enumerator socketAddressEnumerator) NextAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketAddressEnumerator
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketAddressEnumerator)(enumerator.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_address_enumerator_next_async(arg0, arg1, arg2)
}

// SocketClient is a lightweight high-level utility class for connecting to a
// network host using a connection oriented socket type.
//
// You create a Client object, set any options you want, and then call a sync or
// async connect operation, which returns a Connection subclass on success.
//
// The type of the Connection object returned depends on the type of the
// underlying socket that is in use. For instance, for a TCP/IP connection it
// will be a Connection.
//
// As Client is a lightweight object, you don't need to cache it. You can just
// create a new one any time you need one.
type SocketClient interface {
	gextras.Objector

	// AddApplicationProxy: enable proxy protocols to be handled by the
	// application. When the indicated proxy protocol is returned by the
	// Resolver, Client will consider this protocol as supported but will not
	// try to find a #GProxy instance to handle handshaking. The application
	// must check for this case by calling
	// g_socket_connection_get_remote_address() on the returned Connection, and
	// seeing if it's a Address of the appropriate type, to determine whether or
	// not it needs to handle the proxy handshaking itself.
	//
	// This should be used for proxy protocols that are dialects of another
	// protocol such as HTTP proxy. It also allows cohabitation of proxy
	// protocols that are reused between protocols. A good example is HTTP. It
	// can be used to proxy HTTP, FTP and Gopher and can also be use as generic
	// socket proxy through the HTTP CONNECT method.
	//
	// When the proxy is detected as being an application proxy, TLS handshake
	// will be skipped. This is required to let the application do the proxy
	// specific handshake.
	AddApplicationProxy(protocol string)
	// ConnectToHost: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection to the named host.
	//
	// @host_and_port may be in any of a number of recognized formats; an IPv6
	// address, an IPv4 address, or a domain name (in which case a DNS lookup is
	// performed). Quoting with [] is supported for all address types. A port
	// override may be specified in the usual way with a colon. Ports may be
	// given as decimal numbers or symbolic names (in which case an
	// /etc/services lookup is performed).
	//
	// If no port override is given in @host_and_port then @default_port will be
	// used as the port number to connect to.
	//
	// In general, @host_and_port is expected to be provided by the user
	// (allowing them to give the hostname, and a port override if necessary)
	// and @default_port is expected to be provided by the application.
	//
	// In the case that an IP address is given, a single connection attempt is
	// made. In the case that a name is given, multiple connection attempts may
	// be made, in turn and according to the number of address records in DNS,
	// until a connection succeeds.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) SocketConnection
	// ConnectToHostAsync: this is the asynchronous version of
	// g_socket_client_connect_to_host().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_client_connect_to_host_finish() to get the result of the
	// operation.
	ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectToService attempts to create a TCP connection to a service.
	//
	// This call looks up the SRV record for @service at @domain for the "tcp"
	// protocol. It then attempts to connect, in turn, to each of the hosts
	// providing the service until either a connection succeeds or there are no
	// hosts remaining.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToService(domain string, service string, cancellable Cancellable) SocketConnection
	// ConnectToServiceAsync: this is the asynchronous version of
	// g_socket_client_connect_to_service().
	ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback)
	// ConnectToURI: this is a helper function for g_socket_client_connect().
	//
	// Attempts to create a TCP connection with a network URI.
	//
	// @uri may be any valid URI containing an "authority" (hostname/port)
	// component. If a port is not specified in the URI, @default_port will be
	// used. TLS will be negotiated if Client:tls is true. (Client does not know
	// to automatically assume TLS for certain URI schemes.)
	//
	// Using this rather than g_socket_client_connect() or
	// g_socket_client_connect_to_host() allows Client to determine when to use
	// application-specific proxy protocols.
	//
	// Upon a successful connection, a new Connection is constructed and
	// returned. The caller owns this new object and must drop their reference
	// to it when finished with it.
	//
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) nil is returned and @error (if non-nil) is set accordingly.
	ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) SocketConnection
	// ConnectToURIAsync: this is the asynchronous version of
	// g_socket_client_connect_to_uri().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_client_connect_to_uri_finish() to get the result of the
	// operation.
	ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback)
	// EnableProxy gets the proxy enable state; see
	// g_socket_client_set_enable_proxy()
	EnableProxy() bool
	// Family gets the socket family of the socket client.
	//
	// See g_socket_client_set_family() for details.
	Family() SocketFamily
	// LocalAddress gets the local address of the socket client.
	//
	// See g_socket_client_set_local_address() for details.
	LocalAddress() SocketAddress
	// Protocol gets the protocol name type of the socket client.
	//
	// See g_socket_client_set_protocol() for details.
	Protocol() SocketProtocol
	// SocketType gets the socket type of the socket client.
	//
	// See g_socket_client_set_socket_type() for details.
	SocketType() SocketType
	// Timeout gets the I/O timeout time for sockets created by @client.
	//
	// See g_socket_client_set_timeout() for details.
	Timeout() uint
	// TLS gets whether @client creates TLS connections. See
	// g_socket_client_set_tls() for details.
	TLS() bool
	// TLSValidationFlags gets the TLS validation flags used creating TLS
	// connections via @client.
	TLSValidationFlags() TLSCertificateFlags
	// SetEnableProxy sets whether or not @client attempts to make connections
	// via a proxy server. When enabled (the default), Client will use a
	// Resolver to determine if a proxy protocol such as SOCKS is needed, and
	// automatically do the necessary proxy negotiation.
	//
	// See also g_socket_client_set_proxy_resolver().
	SetEnableProxy(enable bool)
	// SetFamily sets the socket family of the socket client. If this is set to
	// something other than G_SOCKET_FAMILY_INVALID then the sockets created by
	// this object will be of the specified family.
	//
	// This might be useful for instance if you want to force the local
	// connection to be an ipv4 socket, even though the address might be an ipv6
	// mapped to ipv4 address.
	SetFamily(family SocketFamily)
	// SetLocalAddress sets the local address of the socket client. The sockets
	// created by this object will bound to the specified address (if not nil)
	// before connecting.
	//
	// This is useful if you want to ensure that the local side of the
	// connection is on a specific port, or on a specific interface.
	SetLocalAddress(address SocketAddress)
	// SetProtocol sets the protocol of the socket client. The sockets created
	// by this object will use of the specified protocol.
	//
	// If @protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
	// protocol for the socket family and type.
	SetProtocol(protocol SocketProtocol)
	// SetProxyResolver overrides the Resolver used by @client. You can call
	// this if you want to use specific proxies, rather than using the system
	// default proxy settings.
	//
	// Note that whether or not the proxy resolver is actually used depends on
	// the setting of Client:enable-proxy, which is not changed by this function
	// (but which is true by default)
	SetProxyResolver(proxyResolver ProxyResolver)
	// SetSocketType sets the socket type of the socket client. The sockets
	// created by this object will be of the specified type.
	//
	// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM, as
	// GSocketClient is used for connection oriented services.
	SetSocketType(_type SocketType)
	// SetTimeout sets the I/O timeout for sockets created by @client. @timeout
	// is a time in seconds, or 0 for no timeout (the default).
	//
	// The timeout value affects the initial connection attempt as well, so
	// setting this may cause calls to g_socket_client_connect(), etc, to fail
	// with G_IO_ERROR_TIMED_OUT.
	SetTimeout(timeout uint)
	// SetTLS sets whether @client creates TLS (aka SSL) connections. If @tls is
	// true, @client will wrap its connections in a ClientConnection and perform
	// a TLS handshake when connecting.
	//
	// Note that since Client must return a Connection, but ClientConnection is
	// not a Connection, this actually wraps the resulting ClientConnection in a
	// WrapperConnection when returning it. You can use
	// g_tcp_wrapper_connection_get_base_io_stream() on the return value to
	// extract the ClientConnection.
	//
	// If you need to modify the behavior of the TLS handshake (eg, by setting a
	// client-side certificate to use, or connecting to the
	// Connection::accept-certificate signal), you can connect to @client's
	// Client::event signal and wait for it to be emitted with
	// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
	// ClientConnection before the handshake starts.
	SetTLS(tls bool)
	// SetTLSValidationFlags sets the TLS validation flags used when creating
	// TLS connections via @client. The default value is
	// G_TLS_CERTIFICATE_VALIDATE_ALL.
	SetTLSValidationFlags(flags TLSCertificateFlags)
}

// socketClient implements the SocketClient interface.
type socketClient struct {
	gextras.Objector
}

// WrapSocketClient wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketClient(obj *externglib.Object) SocketClient {
	return SocketClient{
		gextras.Objector: (obj),
	}
}

func marshalSocketClient(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketClient(obj), nil
}

// NewSocketClient constructs a class SocketClient.
func NewSocketClient() SocketClient {

	ret := C.g_socket_client_new()

	var ret0 SocketClient

	ret0 = WrapSocketClient(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddApplicationProxy: enable proxy protocols to be handled by the
// application. When the indicated proxy protocol is returned by the
// Resolver, Client will consider this protocol as supported but will not
// try to find a #GProxy instance to handle handshaking. The application
// must check for this case by calling
// g_socket_connection_get_remote_address() on the returned Connection, and
// seeing if it's a Address of the appropriate type, to determine whether or
// not it needs to handle the proxy handshaking itself.
//
// This should be used for proxy protocols that are dialects of another
// protocol such as HTTP proxy. It also allows cohabitation of proxy
// protocols that are reused between protocols. A good example is HTTP. It
// can be used to proxy HTTP, FTP and Gopher and can also be use as generic
// socket proxy through the HTTP CONNECT method.
//
// When the proxy is detected as being an application proxy, TLS handshake
// will be skipped. This is required to let the application do the proxy
// specific handshake.
func (client socketClient) AddApplicationProxy(protocol string) {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(protocol))
	defer C.free(unsafe.Pointer(arg1))

	C.g_socket_client_add_application_proxy(arg0, arg1)
}

// ConnectToHost: this is a helper function for g_socket_client_connect().
//
// Attempts to create a TCP connection to the named host.
//
// @host_and_port may be in any of a number of recognized formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS lookup is
// performed). Quoting with [] is supported for all address types. A port
// override may be specified in the usual way with a colon. Ports may be
// given as decimal numbers or symbolic names (in which case an
// /etc/services lookup is performed).
//
// If no port override is given in @host_and_port then @default_port will be
// used as the port number to connect to.
//
// In general, @host_and_port is expected to be provided by the user
// (allowing them to give the hostname, and a port override if necessary)
// and @default_port is expected to be provided by the application.
//
// In the case that an IP address is given, a single connection attempt is
// made. In the case that a name is given, multiple connection attempts may
// be made, in turn and according to the number of address records in DNS,
// until a connection succeeds.
//
// Upon a successful connection, a new Connection is constructed and
// returned. The caller owns this new object and must drop their reference
// to it when finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
func (client socketClient) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) SocketConnection {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 C.guint16
	var arg3 *C.GCancellable

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(hostAndPort))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(defaultPort)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_client_connect_to_host(arg0, arg1, arg2, arg3)

	var ret0 SocketConnection

	ret0 = WrapSocketConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ConnectToHostAsync: this is the asynchronous version of
// g_socket_client_connect_to_host().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_client_connect_to_host_finish() to get the result of the
// operation.
func (client socketClient) ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 C.guint16
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(hostAndPort))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(defaultPort)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_client_connect_to_host_async(arg0, arg1, arg2, arg3, arg4)
}

// ConnectToService attempts to create a TCP connection to a service.
//
// This call looks up the SRV record for @service at @domain for the "tcp"
// protocol. It then attempts to connect, in turn, to each of the hosts
// providing the service until either a connection succeeds or there are no
// hosts remaining.
//
// Upon a successful connection, a new Connection is constructed and
// returned. The caller owns this new object and must drop their reference
// to it when finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
func (client socketClient) ConnectToService(domain string, service string, cancellable Cancellable) SocketConnection {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.GCancellable

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_client_connect_to_service(arg0, arg1, arg2, arg3)

	var ret0 SocketConnection

	ret0 = WrapSocketConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ConnectToServiceAsync: this is the asynchronous version of
// g_socket_client_connect_to_service().
func (client socketClient) ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(domain))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(service))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_client_connect_to_service_async(arg0, arg1, arg2, arg3, arg4)
}

// ConnectToURI: this is a helper function for g_socket_client_connect().
//
// Attempts to create a TCP connection with a network URI.
//
// @uri may be any valid URI containing an "authority" (hostname/port)
// component. If a port is not specified in the URI, @default_port will be
// used. TLS will be negotiated if Client:tls is true. (Client does not know
// to automatically assume TLS for certain URI schemes.)
//
// Using this rather than g_socket_client_connect() or
// g_socket_client_connect_to_host() allows Client to determine when to use
// application-specific proxy protocols.
//
// Upon a successful connection, a new Connection is constructed and
// returned. The caller owns this new object and must drop their reference
// to it when finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) nil is returned and @error (if non-nil) is set accordingly.
func (client socketClient) ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) SocketConnection {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 C.guint16
	var arg3 *C.GCancellable

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(defaultPort)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_client_connect_to_uri(arg0, arg1, arg2, arg3)

	var ret0 SocketConnection

	ret0 = WrapSocketConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ConnectToURIAsync: this is the asynchronous version of
// g_socket_client_connect_to_uri().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_client_connect_to_uri_finish() to get the result of the
// operation.
func (client socketClient) ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketClient
	var arg1 *C.gchar
	var arg2 C.guint16
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint16(defaultPort)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_client_connect_to_uri_async(arg0, arg1, arg2, arg3, arg4)
}

// EnableProxy gets the proxy enable state; see
// g_socket_client_set_enable_proxy()
func (client socketClient) EnableProxy() bool {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_enable_proxy(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Family gets the socket family of the socket client.
//
// See g_socket_client_set_family() for details.
func (client socketClient) Family() SocketFamily {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// LocalAddress gets the local address of the socket client.
//
// See g_socket_client_set_local_address() for details.
func (client socketClient) LocalAddress() SocketAddress {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_local_address(arg0)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Protocol gets the protocol name type of the socket client.
//
// See g_socket_client_set_protocol() for details.
func (client socketClient) Protocol() SocketProtocol {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_protocol(arg0)

	var ret0 SocketProtocol

	ret0 = SocketProtocol(ret)

	return ret0
}

// SocketType gets the socket type of the socket client.
//
// See g_socket_client_set_socket_type() for details.
func (client socketClient) SocketType() SocketType {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_socket_type(arg0)

	var ret0 SocketType

	ret0 = SocketType(ret)

	return ret0
}

// Timeout gets the I/O timeout time for sockets created by @client.
//
// See g_socket_client_set_timeout() for details.
func (client socketClient) Timeout() uint {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_timeout(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TLS gets whether @client creates TLS connections. See
// g_socket_client_set_tls() for details.
func (client socketClient) TLS() bool {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_tls(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TLSValidationFlags gets the TLS validation flags used creating TLS
// connections via @client.
func (client socketClient) TLSValidationFlags() TLSCertificateFlags {
	var arg0 *C.GSocketClient

	arg0 = (*C.GSocketClient)(client.Native())

	ret := C.g_socket_client_get_tls_validation_flags(arg0)

	var ret0 TLSCertificateFlags

	ret0 = TLSCertificateFlags(ret)

	return ret0
}

// SetEnableProxy sets whether or not @client attempts to make connections
// via a proxy server. When enabled (the default), Client will use a
// Resolver to determine if a proxy protocol such as SOCKS is needed, and
// automatically do the necessary proxy negotiation.
//
// See also g_socket_client_set_proxy_resolver().
func (client socketClient) SetEnableProxy(enable bool) {
	var arg0 *C.GSocketClient
	var arg1 C.gboolean

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = gextras.Cbool(enable)

	C.g_socket_client_set_enable_proxy(arg0, arg1)
}

// SetFamily sets the socket family of the socket client. If this is set to
// something other than G_SOCKET_FAMILY_INVALID then the sockets created by
// this object will be of the specified family.
//
// This might be useful for instance if you want to force the local
// connection to be an ipv4 socket, even though the address might be an ipv6
// mapped to ipv4 address.
func (client socketClient) SetFamily(family SocketFamily) {
	var arg0 *C.GSocketClient
	var arg1 C.GSocketFamily

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (C.GSocketFamily)(family)

	C.g_socket_client_set_family(arg0, arg1)
}

// SetLocalAddress sets the local address of the socket client. The sockets
// created by this object will bound to the specified address (if not nil)
// before connecting.
//
// This is useful if you want to ensure that the local side of the
// connection is on a specific port, or on a specific interface.
func (client socketClient) SetLocalAddress(address SocketAddress) {
	var arg0 *C.GSocketClient
	var arg1 *C.GSocketAddress

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (*C.GSocketAddress)(address.Native())

	C.g_socket_client_set_local_address(arg0, arg1)
}

// SetProtocol sets the protocol of the socket client. The sockets created
// by this object will use of the specified protocol.
//
// If @protocol is G_SOCKET_PROTOCOL_DEFAULT that means to use the default
// protocol for the socket family and type.
func (client socketClient) SetProtocol(protocol SocketProtocol) {
	var arg0 *C.GSocketClient
	var arg1 C.GSocketProtocol

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (C.GSocketProtocol)(protocol)

	C.g_socket_client_set_protocol(arg0, arg1)
}

// SetProxyResolver overrides the Resolver used by @client. You can call
// this if you want to use specific proxies, rather than using the system
// default proxy settings.
//
// Note that whether or not the proxy resolver is actually used depends on
// the setting of Client:enable-proxy, which is not changed by this function
// (but which is true by default)
func (client socketClient) SetProxyResolver(proxyResolver ProxyResolver) {
	var arg0 *C.GSocketClient
	var arg1 *C.GProxyResolver

	arg0 = (*C.GSocketClient)(client.Native())

	C.g_socket_client_set_proxy_resolver(arg0, arg1)
}

// SetSocketType sets the socket type of the socket client. The sockets
// created by this object will be of the specified type.
//
// It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM, as
// GSocketClient is used for connection oriented services.
func (client socketClient) SetSocketType(_type SocketType) {
	var arg0 *C.GSocketClient
	var arg1 C.GSocketType

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (C.GSocketType)(_type)

	C.g_socket_client_set_socket_type(arg0, arg1)
}

// SetTimeout sets the I/O timeout for sockets created by @client. @timeout
// is a time in seconds, or 0 for no timeout (the default).
//
// The timeout value affects the initial connection attempt as well, so
// setting this may cause calls to g_socket_client_connect(), etc, to fail
// with G_IO_ERROR_TIMED_OUT.
func (client socketClient) SetTimeout(timeout uint) {
	var arg0 *C.GSocketClient
	var arg1 C.guint

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = C.guint(timeout)

	C.g_socket_client_set_timeout(arg0, arg1)
}

// SetTLS sets whether @client creates TLS (aka SSL) connections. If @tls is
// true, @client will wrap its connections in a ClientConnection and perform
// a TLS handshake when connecting.
//
// Note that since Client must return a Connection, but ClientConnection is
// not a Connection, this actually wraps the resulting ClientConnection in a
// WrapperConnection when returning it. You can use
// g_tcp_wrapper_connection_get_base_io_stream() on the return value to
// extract the ClientConnection.
//
// If you need to modify the behavior of the TLS handshake (eg, by setting a
// client-side certificate to use, or connecting to the
// Connection::accept-certificate signal), you can connect to @client's
// Client::event signal and wait for it to be emitted with
// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
// ClientConnection before the handshake starts.
func (client socketClient) SetTLS(tls bool) {
	var arg0 *C.GSocketClient
	var arg1 C.gboolean

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = gextras.Cbool(tls)

	C.g_socket_client_set_tls(arg0, arg1)
}

// SetTLSValidationFlags sets the TLS validation flags used when creating
// TLS connections via @client. The default value is
// G_TLS_CERTIFICATE_VALIDATE_ALL.
func (client socketClient) SetTLSValidationFlags(flags TLSCertificateFlags) {
	var arg0 *C.GSocketClient
	var arg1 C.GTlsCertificateFlags

	arg0 = (*C.GSocketClient)(client.Native())
	arg1 = (C.GTlsCertificateFlags)(flags)

	C.g_socket_client_set_tls_validation_flags(arg0, arg1)
}

// SocketConnection is a OStream for a connected socket. They can be created
// either by Client when connecting to a host, or by Listener when accepting a
// new client.
//
// The type of the Connection object returned from these calls depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a Connection.
//
// Choosing what type of object to construct is done with the socket connection
// factory, and it is possible for 3rd parties to register custom socket
// connection types for specific combination of socket family/type/protocol
// using g_socket_connection_factory_register_type().
//
// To close a Connection, use g_io_stream_close(). Closing both substreams of
// the OStream separately will not close the underlying #GSocket.
type SocketConnection interface {
	IOStream

	// Connect: connect @connection to the specified remote address.
	Connect(address SocketAddress, cancellable Cancellable) bool
	// ConnectAsync: asynchronously connect @connection to the specified remote
	// address.
	//
	// This clears the #GSocket:blocking flag on @connection's underlying socket
	// if it is currently set.
	//
	// Use g_socket_connection_connect_finish() to retrieve the result.
	ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback)
	// LocalAddress: try to get the local address of a socket connection.
	LocalAddress() SocketAddress
	// RemoteAddress: try to get the remote address of a socket connection.
	//
	// Since GLib 2.40, when used with g_socket_client_connect() or
	// g_socket_client_connect_async(), during emission of
	// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address
	// that will be used for the connection. This allows applications to print
	// e.g. "Connecting to example.com (10.42.77.3)...".
	RemoteAddress() SocketAddress
	// Socket gets the underlying #GSocket object of the connection. This can be
	// useful if you want to do something unusual on it not supported by the
	// Connection APIs.
	Socket() Socket
	// IsConnected checks if @connection is connected. This is equivalent to
	// calling g_socket_is_connected() on @connection's underlying #GSocket.
	IsConnected() bool
}

// socketConnection implements the SocketConnection interface.
type socketConnection struct {
	IOStream
}

// WrapSocketConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketConnection(obj *externglib.Object) SocketConnection {
	return SocketConnection{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSocketConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketConnection(obj), nil
}

// Connect: connect @connection to the specified remote address.
func (connection socketConnection) Connect(address SocketAddress, cancellable Cancellable) bool {
	var arg0 *C.GSocketConnection
	var arg1 *C.GSocketAddress
	var arg2 *C.GCancellable

	arg0 = (*C.GSocketConnection)(connection.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_connection_connect(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ConnectAsync: asynchronously connect @connection to the specified remote
// address.
//
// This clears the #GSocket:blocking flag on @connection's underlying socket
// if it is currently set.
//
// Use g_socket_connection_connect_finish() to retrieve the result.
func (connection socketConnection) ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketConnection
	var arg1 *C.GSocketAddress
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketConnection)(connection.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_connection_connect_async(arg0, arg1, arg2, arg3)
}

// LocalAddress: try to get the local address of a socket connection.
func (connection socketConnection) LocalAddress() SocketAddress {
	var arg0 *C.GSocketConnection

	arg0 = (*C.GSocketConnection)(connection.Native())

	ret := C.g_socket_connection_get_local_address(arg0)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// RemoteAddress: try to get the remote address of a socket connection.
//
// Since GLib 2.40, when used with g_socket_client_connect() or
// g_socket_client_connect_async(), during emission of
// G_SOCKET_CLIENT_CONNECTING, this function will return the remote address
// that will be used for the connection. This allows applications to print
// e.g. "Connecting to example.com (10.42.77.3)...".
func (connection socketConnection) RemoteAddress() SocketAddress {
	var arg0 *C.GSocketConnection

	arg0 = (*C.GSocketConnection)(connection.Native())

	ret := C.g_socket_connection_get_remote_address(arg0)

	var ret0 SocketAddress

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Socket gets the underlying #GSocket object of the connection. This can be
// useful if you want to do something unusual on it not supported by the
// Connection APIs.
func (connection socketConnection) Socket() Socket {
	var arg0 *C.GSocketConnection

	arg0 = (*C.GSocketConnection)(connection.Native())

	ret := C.g_socket_connection_get_socket(arg0)

	var ret0 Socket

	ret0 = WrapSocket(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsConnected checks if @connection is connected. This is equivalent to
// calling g_socket_is_connected() on @connection's underlying #GSocket.
func (connection socketConnection) IsConnected() bool {
	var arg0 *C.GSocketConnection

	arg0 = (*C.GSocketConnection)(connection.Native())

	ret := C.g_socket_connection_is_connected(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SocketControlMessage: a ControlMessage is a special-purpose utility message
// that can be sent to or received from a #GSocket. These types of messages are
// often called "ancillary data".
//
// The message can represent some sort of special instruction to or information
// from the socket or can represent a special kind of transfer to the peer (for
// example, sending a file descriptor over a UNIX socket).
//
// These messages are sent with g_socket_send_message() and received with
// g_socket_receive_message().
//
// To extend the set of control message that can be sent, subclass this class
// and override the get_size, get_level, get_type and serialize methods.
//
// To extend the set of control messages that can be received, subclass this
// class and implement the deserialize method. Also, make sure your class is
// registered with the GType typesystem before calling
// g_socket_receive_message() to read such a message.
type SocketControlMessage interface {
	gextras.Objector

	// Level returns the "level" (i.e. the originating protocol) of the control
	// message. This is often SOL_SOCKET.
	Level() int
	// MsgType returns the protocol specific type of the control message. For
	// instance, for UNIX fd passing this would be SCM_RIGHTS.
	MsgType() int
	// Size returns the space required for the control message, not including
	// headers or alignment.
	Size() uint
	// Serialize converts the data in the message to bytes placed in the
	// message.
	//
	// @data is guaranteed to have enough space to fit the size returned by
	// g_socket_control_message_get_size() on this object.
	Serialize(data interface{})
}

// socketControlMessage implements the SocketControlMessage interface.
type socketControlMessage struct {
	gextras.Objector
}

// WrapSocketControlMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketControlMessage(obj *externglib.Object) SocketControlMessage {
	return SocketControlMessage{
		gextras.Objector: (obj),
	}
}

func marshalSocketControlMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketControlMessage(obj), nil
}

// Level returns the "level" (i.e. the originating protocol) of the control
// message. This is often SOL_SOCKET.
func (message socketControlMessage) Level() int {
	var arg0 *C.GSocketControlMessage

	arg0 = (*C.GSocketControlMessage)(message.Native())

	ret := C.g_socket_control_message_get_level(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// MsgType returns the protocol specific type of the control message. For
// instance, for UNIX fd passing this would be SCM_RIGHTS.
func (message socketControlMessage) MsgType() int {
	var arg0 *C.GSocketControlMessage

	arg0 = (*C.GSocketControlMessage)(message.Native())

	ret := C.g_socket_control_message_get_msg_type(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Size returns the space required for the control message, not including
// headers or alignment.
func (message socketControlMessage) Size() uint {
	var arg0 *C.GSocketControlMessage

	arg0 = (*C.GSocketControlMessage)(message.Native())

	ret := C.g_socket_control_message_get_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Serialize converts the data in the message to bytes placed in the
// message.
//
// @data is guaranteed to have enough space to fit the size returned by
// g_socket_control_message_get_size() on this object.
func (message socketControlMessage) Serialize(data interface{}) {
	var arg0 *C.GSocketControlMessage
	var arg1 C.gpointer

	arg0 = (*C.GSocketControlMessage)(message.Native())
	arg1 = C.gpointer(box.Assign(data))

	C.g_socket_control_message_serialize(arg0, arg1)
}

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener interface {
	gextras.Objector

	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection)
	// AcceptAsync: this is the asynchronous version of
	// g_socket_listener_accept().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket() to get the result of the
	// operation.
	AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket)
	// AcceptSocketAsync: this is the asynchronous version of
	// g_socket_listener_accept_socket().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket_finish() to get the result of the
	// operation.
	AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	AddAddress(address SocketAddress, _type SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, ok bool)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	AddAnyInetPort(sourceObject gextras.Objector) uint16
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddInetPort(port uint16, sourceObject gextras.Objector) bool
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	AddSocket(socket Socket, sourceObject gextras.Objector) bool
	// Close closes all the sockets in the listener.
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	SetBacklog(listenBacklog int)
}

// socketListener implements the SocketListener interface.
type socketListener struct {
	gextras.Objector
}

// WrapSocketListener wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketListener(obj *externglib.Object) SocketListener {
	return SocketListener{
		gextras.Objector: (obj),
	}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketListener(obj), nil
}

// NewSocketListener constructs a class SocketListener.
func NewSocketListener() SocketListener {

	ret := C.g_socket_listener_new()

	var ret0 SocketListener

	ret0 = WrapSocketListener(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Accept blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns a Connection for the socket that was accepted.
//
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the
// listener.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (listener socketListener) Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection) {
	var arg0 *C.GSocketListener
	var arg1 **C.GObject // out
	var arg2 *C.GCancellable

	arg0 = (*C.GSocketListener)(listener.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_listener_accept(arg0, &arg1, arg2)

	var ret0 gextras.Objector
	var ret1 SocketConnection

	ret0 = externglib.Take(unsafe.Pointer(arg1.Native()))

	ret1 = WrapSocketConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// AcceptAsync: this is the asynchronous version of
// g_socket_listener_accept().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_listener_accept_socket() to get the result of the
// operation.
func (listener socketListener) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketListener
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_listener_accept_async(arg0, arg1, arg2)
}

// AcceptSocket blocks waiting for a client to connect to any of the sockets
// added to the listener. Returns the #GSocket that was accepted.
//
// If you want to accept the high-level Connection, not a #GSocket, which is
// often the case, then you should use g_socket_listener_accept() instead.
//
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the
// listener.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (listener socketListener) AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket) {
	var arg0 *C.GSocketListener
	var arg1 **C.GObject // out
	var arg2 *C.GCancellable

	arg0 = (*C.GSocketListener)(listener.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_socket_listener_accept_socket(arg0, &arg1, arg2)

	var ret0 gextras.Objector
	var ret1 Socket

	ret0 = externglib.Take(unsafe.Pointer(arg1.Native()))

	ret1 = WrapSocket(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0, ret1
}

// AcceptSocketAsync: this is the asynchronous version of
// g_socket_listener_accept_socket().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_listener_accept_socket_finish() to get the result of the
// operation.
func (listener socketListener) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketListener
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_socket_listener_accept_socket_async(arg0, arg1, arg2)
}

// AddAddress creates a socket of type @type and protocol @protocol, binds
// it to @address and adds it to the set of sockets we're accepting sockets
// from.
//
// Note that adding an IPv6 address, depending on the platform, may or may
// not result in a listener that also accepts IPv4 connections. For more
// deterministic behavior, see g_socket_listener_add_inet_port().
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// If successful and @effective_address is non-nil then it will be set to
// the address that the binding actually occurred at. This is helpful for
// determining the port number that was used for when requesting a binding
// to port 0 (ie: "any port"). This address, if requested, belongs to the
// caller and must be freed.
//
// Call g_socket_listener_close() to stop listening on @address; this will
// not be done automatically when you drop your final reference to
// @listener, as references may be held internally.
func (listener socketListener) AddAddress(address SocketAddress, _type SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, ok bool) {
	var arg0 *C.GSocketListener
	var arg1 *C.GSocketAddress
	var arg2 C.GSocketType
	var arg3 C.GSocketProtocol
	var arg4 *C.GObject
	var arg5 **C.GSocketAddress // out

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = (*C.GSocketAddress)(address.Native())
	arg2 = (C.GSocketType)(_type)
	arg3 = (C.GSocketProtocol)(protocol)
	arg4 = (*C.GObject)(sourceObject.Native())

	ret := C.g_socket_listener_add_address(arg0, arg1, arg2, arg3, arg4, &arg5)

	var ret0 SocketAddress
	var ret1 bool

	ret0 = WrapSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(arg5.Native())))

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// AddAnyInetPort listens for TCP connections on any available port number
// for both IPv6 and IPv4 (if each is available).
//
// This is useful if you need to have a socket for incoming connections but
// don't care about the specific port number.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
func (listener socketListener) AddAnyInetPort(sourceObject gextras.Objector) uint16 {
	var arg0 *C.GSocketListener
	var arg1 *C.GObject

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = (*C.GObject)(sourceObject.Native())

	ret := C.g_socket_listener_add_any_inet_port(arg0, arg1)

	var ret0 uint16

	ret0 = uint16(ret)

	return ret0
}

// AddInetPort: helper function for g_socket_listener_add_address() that
// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
// specified port on all interfaces.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// Call g_socket_listener_close() to stop listening on @port; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (listener socketListener) AddInetPort(port uint16, sourceObject gextras.Objector) bool {
	var arg0 *C.GSocketListener
	var arg1 C.guint16
	var arg2 *C.GObject

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = C.guint16(port)
	arg2 = (*C.GObject)(sourceObject.Native())

	ret := C.g_socket_listener_add_inet_port(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// AddSocket adds @socket to the set of sockets that we try to accept new
// clients from. The socket must be bound to a local address and listened
// to.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// The @socket will not be automatically closed when the @listener is
// finalized unless the listener held the final reference to the socket.
// Before GLib 2.42, the @socket was automatically closed on finalization of
// the @listener, even if references to it were held elsewhere.
func (listener socketListener) AddSocket(socket Socket, sourceObject gextras.Objector) bool {
	var arg0 *C.GSocketListener
	var arg1 *C.GSocket
	var arg2 *C.GObject

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = (*C.GSocket)(socket.Native())
	arg2 = (*C.GObject)(sourceObject.Native())

	ret := C.g_socket_listener_add_socket(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Close closes all the sockets in the listener.
func (listener socketListener) Close() {
	var arg0 *C.GSocketListener

	arg0 = (*C.GSocketListener)(listener.Native())

	C.g_socket_listener_close(arg0)
}

// SetBacklog sets the listen backlog on the sockets in the listener. This
// must be called before adding any sockets, addresses or ports to the
// Listener (for example, by calling g_socket_listener_add_inet_port()) to
// be effective.
//
// See g_socket_set_listen_backlog() for details
func (listener socketListener) SetBacklog(listenBacklog int) {
	var arg0 *C.GSocketListener
	var arg1 C.int

	arg0 = (*C.GSocketListener)(listener.Native())
	arg1 = C.int(listenBacklog)

	C.g_socket_listener_set_backlog(arg0, arg1)
}

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	SocketListener

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	Stop()
}

// socketService implements the SocketService interface.
type socketService struct {
	SocketListener
}

// WrapSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketService(obj *externglib.Object) SocketService {
	return SocketService{
		SocketListener: WrapSocketListener(obj),
	}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketService(obj), nil
}

// NewSocketService constructs a class SocketService.
func NewSocketService() SocketService {

	ret := C.g_socket_service_new()

	var ret0 SocketService

	ret0 = WrapSocketService(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsActive: check whether the service is active or not. An active service
// will accept new clients that connect, while a non-active service will let
// connecting clients queue up until the service is started.
func (service socketService) IsActive() bool {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(service.Native())

	ret := C.g_socket_service_is_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Start restarts the service, i.e. start accepting connections from the
// added sockets when the mainloop runs. This only needs to be called after
// the service has been stopped from g_socket_service_stop().
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
func (service socketService) Start() {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(service.Native())

	C.g_socket_service_start(arg0)
}

// Stop stops the service, i.e. stops accepting connections from the added
// sockets when the mainloop runs.
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
//
// Note that this only stops accepting new connections; it does not close
// the listening sockets, and you can call g_socket_service_start() again
// later to begin listening again. To close the listening sockets, call
// g_socket_listener_close(). (This will happen automatically when the
// Service is finalized.)
//
// This must be called before calling g_socket_listener_close() as the
// socket service will start accepting connections immediately when a new
// socket is added.
func (service socketService) Stop() {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(service.Native())

	C.g_socket_service_stop(arg0)
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector

	// Communicate: communicate with the subprocess until it terminates, and all
	// input and output has been completed.
	//
	// If @stdin_buf is given, the subprocess must have been created with
	// G_SUBPROCESS_FLAGS_STDIN_PIPE. The given data is fed to the stdin of the
	// subprocess and the pipe is closed (ie: EOF).
	//
	// At the same time (as not to cause blocking when dealing with large
	// amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
	// G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those streams. The
	// data that was read is returned in @stdout and/or the @stderr.
	//
	// If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// @stdout_buf will contain the data read from stdout. Otherwise, for
	// subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE, @stdout_buf
	// will be set to nil. Similar provisions apply to @stderr_buf and
	// G_SUBPROCESS_FLAGS_STDERR_PIPE.
	//
	// As usual, any output variable may be given as nil to ignore it.
	//
	// If you desire the stdout and stderr data to be interleaved, create the
	// subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
	// G_SUBPROCESS_FLAGS_STDERR_MERGE. The merged result will be returned in
	// @stdout_buf and @stderr_buf will be set to nil.
	//
	// In case of any error (including cancellation), false will be returned
	// with @error set. Some or all of the stdin data may have been written. Any
	// stdout or stderr data that has been read will be discarded. None of the
	// out variables (aside from @error) will have been set to anything in
	// particular and should not be inspected.
	//
	// In the case that true is returned, the subprocess has exited and the exit
	// status inspection APIs (eg: g_subprocess_get_if_exited(),
	// g_subprocess_get_exit_status()) may be used.
	//
	// You should not attempt to use any of the subprocess pipes after starting
	// this function, since they may be left in strange states, even if the
	// operation was cancelled. You should especially not attempt to interact
	// with the pipes while the operation is in progress (either from another
	// thread or if using the asynchronous version).
	Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool)
	// CommunicateAsync asynchronous version of g_subprocess_communicate().
	// Complete invocation with g_subprocess_communicate_finish().
	CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, ok bool)
	// CommunicateUTF8Async asynchronous version of
	// g_subprocess_communicate_utf8(). Complete invocation with
	// g_subprocess_communicate_utf8_finish().
	CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) bool
	// WaitAsync: wait for the subprocess to terminate.
	//
	// This is the asynchronous version of g_subprocess_wait().
	WaitAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) bool
	// WaitCheckAsync combines g_subprocess_wait_async() with
	// g_spawn_check_exit_status().
	//
	// This is the asynchronous version of g_subprocess_wait_check().
	WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback)
}

// subprocess implements the Subprocess interface.
type subprocess struct {
	gextras.Objector
}

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return Subprocess{
		gextras.Objector: (obj),
	}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

// NewSubprocessV constructs a class Subprocess.
func NewSubprocessV(argv []string, flags SubprocessFlags) Subprocess {
	var arg1 **C.gchar
	var arg2 C.GSubprocessFlags

	{

	}
	arg2 = (C.GSubprocessFlags)(flags)

	ret := C.g_subprocess_newv(arg1, arg2)

	var ret0 Subprocess

	ret0 = WrapSubprocess(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Communicate: communicate with the subprocess until it terminates, and all
// input and output has been completed.
//
// If @stdin_buf is given, the subprocess must have been created with
// G_SUBPROCESS_FLAGS_STDIN_PIPE. The given data is fed to the stdin of the
// subprocess and the pipe is closed (ie: EOF).
//
// At the same time (as not to cause blocking when dealing with large
// amounts of data), if G_SUBPROCESS_FLAGS_STDOUT_PIPE or
// G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those streams. The
// data that was read is returned in @stdout and/or the @stderr.
//
// If the subprocess was created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// @stdout_buf will contain the data read from stdout. Otherwise, for
// subprocesses not created with G_SUBPROCESS_FLAGS_STDOUT_PIPE, @stdout_buf
// will be set to nil. Similar provisions apply to @stderr_buf and
// G_SUBPROCESS_FLAGS_STDERR_PIPE.
//
// As usual, any output variable may be given as nil to ignore it.
//
// If you desire the stdout and stderr data to be interleaved, create the
// subprocess with G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDERR_MERGE. The merged result will be returned in
// @stdout_buf and @stderr_buf will be set to nil.
//
// In case of any error (including cancellation), false will be returned
// with @error set. Some or all of the stdin data may have been written. Any
// stdout or stderr data that has been read will be discarded. None of the
// out variables (aside from @error) will have been set to anything in
// particular and should not be inspected.
//
// In the case that true is returned, the subprocess has exited and the exit
// status inspection APIs (eg: g_subprocess_get_if_exited(),
// g_subprocess_get_exit_status()) may be used.
//
// You should not attempt to use any of the subprocess pipes after starting
// this function, since they may be left in strange states, even if the
// operation was cancelled. You should especially not attempt to interact
// with the pipes while the operation is in progress (either from another
// thread or if using the asynchronous version).
func (subprocess subprocess) Communicate(stdinBuf *glib.Bytes, cancellable Cancellable) (stdoutBuf *glib.Bytes, stderrBuf *glib.Bytes, ok bool) {
	var arg0 *C.GSubprocess
	var arg1 *C.GBytes
	var arg2 *C.GCancellable
	var arg3 **C.GBytes // out
	var arg4 **C.GBytes // out

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GBytes)(stdinBuf.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_subprocess_communicate(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 **glib.Bytes
	var ret1 **glib.Bytes
	var ret2 bool

	ret0 = glib.WrapBytes(arg3)

	ret1 = glib.WrapBytes(arg4)

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// CommunicateAsync asynchronous version of g_subprocess_communicate().
// Complete invocation with g_subprocess_communicate_finish().
func (subprocess subprocess) CommunicateAsync(stdinBuf *glib.Bytes, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess
	var arg1 *C.GBytes
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GBytes)(stdinBuf.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_subprocess_communicate_async(arg0, arg1, arg2, arg3)
}

// CommunicateUTF8: like g_subprocess_communicate(), but validates the
// output of the process as UTF-8, and returns it as a regular NUL
// terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (subprocess subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, ok bool) {
	var arg0 *C.GSubprocess
	var arg1 *C.char
	var arg2 *C.GCancellable
	var arg3 **C.char // out
	var arg4 **C.char // out

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.gchar)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_subprocess_communicate_utf8(arg0, arg1, arg2, &arg3, &arg4)

	var ret0 string
	var ret1 string
	var ret2 bool

	ret0 = C.GoString(arg3)
	C.free(unsafe.Pointer(arg3))

	ret1 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	ret2 = gextras.Gobool(ret)

	return ret0, ret1, ret2
}

// CommunicateUTF8Async asynchronous version of
// g_subprocess_communicate_utf8(). Complete invocation with
// g_subprocess_communicate_utf8_finish().
func (subprocess subprocess) CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess
	var arg1 *C.char
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.gchar)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_subprocess_communicate_utf8_async(arg0, arg1, arg2, arg3)
}

// ForceExit: use an operating-system specific method to attempt an
// immediate, forceful termination of the process. There is no mechanism to
// determine whether or not the request itself was successful; however, you
// can use g_subprocess_wait() to monitor the status of the process after
// calling this function.
//
// On Unix, this function sends SIGKILL.
func (subprocess subprocess) ForceExit() {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	C.g_subprocess_force_exit(arg0)
}

// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the
// return value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_exited() returned true.
func (subprocess subprocess) ExitStatus() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_exit_status(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Identifier: on UNIX, returns the process ID as a decimal string. On
// Windows, returns the result of GetProcessId() also as a string. If the
// subprocess has terminated, this will return nil.
func (subprocess subprocess) Identifier() string {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_identifier(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IfExited: check if the given subprocess exited normally (ie: by way of
// exit() or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (subprocess subprocess) IfExited() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_if_exited(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// IfSignaled: check if the given subprocess terminated in response to a
// signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (subprocess subprocess) IfSignaled() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_if_signaled(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Status gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited()
// followed by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (subprocess subprocess) Status() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_status(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// StderrPipe gets the Stream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE.
func (subprocess subprocess) StderrPipe() InputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_stderr_pipe(arg0)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// StdinPipe gets the Stream that you can write to in order to give data to
// the stdin of @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE.
func (subprocess subprocess) StdinPipe() OutputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_stdin_pipe(arg0)

	var ret0 OutputStream

	ret0 = WrapOutputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// StdoutPipe gets the Stream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE.
func (subprocess subprocess) StdoutPipe() InputStream {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_stdout_pipe(arg0)

	var ret0 InputStream

	ret0 = WrapInputStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Successful checks if the process was "successful". A process is
// considered successful if it exited cleanly with an exit status of 0,
// either by way of the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (subprocess subprocess) Successful() bool {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_successful(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// TermSig: get the signal number that caused the subprocess to terminate,
// given that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_signaled() returned true.
func (subprocess subprocess) TermSig() int {
	var arg0 *C.GSubprocess

	arg0 = (*C.GSubprocess)(subprocess.Native())

	ret := C.g_subprocess_get_term_sig(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
// still running.
//
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
//
// This API is not available on Windows.
func (subprocess subprocess) SendSignal(signalNum int) {
	var arg0 *C.GSubprocess
	var arg1 C.gint

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(arg0, arg1)
}

// Wait: synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
func (subprocess subprocess) Wait(cancellable Cancellable) bool {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_subprocess_wait(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WaitAsync: wait for the subprocess to terminate.
//
// This is the asynchronous version of g_subprocess_wait().
func (subprocess subprocess) WaitAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_subprocess_wait_async(arg0, arg1, arg2)
}

// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
func (subprocess subprocess) WaitCheck(cancellable Cancellable) bool {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_subprocess_wait_check(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// WaitCheckAsync combines g_subprocess_wait_async() with
// g_spawn_check_exit_status().
//
// This is the asynchronous version of g_subprocess_wait_check().
func (subprocess subprocess) WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSubprocess
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSubprocess)(subprocess.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_subprocess_wait_check_async(arg0, arg1, arg2)
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetChildSetup sets up a child setup function.
	//
	// The child setup function will be called after fork() but before exec() on
	// the child's side.
	//
	// @destroy_notify will not be automatically called on the child's side of
	// the fork(). It will only be called when the last reference on the
	// Launcher is dropped or when a new child setup function is given.
	//
	// nil can be given as @child_setup to disable the functionality.
	//
	// Child setup functions are only available on UNIX.
	SetChildSetup(childSetup glib.SpawnChildSetupFunc)
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process’ environment. As of GLib 2.54, the parent process’
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) Subprocess
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes "ownership" of the fd; it will be closed in
	// the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom pipe() or
	// socketpair() before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// --passphrase-fd providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

// subprocessLauncher implements the SubprocessLauncher interface.
type subprocessLauncher struct {
	gextras.Objector
}

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return SubprocessLauncher{
		gextras.Objector: (obj),
	}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher constructs a class SubprocessLauncher.
func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var arg1 C.GSubprocessFlags

	arg1 = (C.GSubprocessFlags)(flags)

	ret := C.g_subprocess_launcher_new(arg1)

	var ret0 SubprocessLauncher

	ret0 = WrapSubprocessLauncher(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// env returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string. On Windows,
// it will be UTF-8.
func (self subprocessLauncher) env(variable string) string {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_subprocess_launcher_getenv(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetChildSetup sets up a child setup function.
//
// The child setup function will be called after fork() but before exec() on
// the child's side.
//
// @destroy_notify will not be automatically called on the child's side of
// the fork(). It will only be called when the last reference on the
// Launcher is dropped or when a new child setup function is given.
//
// nil can be given as @child_setup to disable the functionality.
//
// Child setup functions are only available on UNIX.
func (self subprocessLauncher) SetChildSetup(childSetup glib.SpawnChildSetupFunc) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.GSpawnChildSetupFunc
	arg2 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*[0]byte)(C.gotk4_SpawnChildSetupFunc)

	C.g_subprocess_launcher_set_child_setup(arg0, arg1, (*[0]byte)(C.callbackDelete))
}

// SetCwd sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory of
// the launching process at the time of launch.
func (self subprocessLauncher) SetCwd(cwd string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_cwd(arg0, arg1)
}

// SetEnviron: replace the entire environment of processes launched from
// this launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass nil to inherit the
// parent process’ environment. As of GLib 2.54, the parent process’
// environment will be copied when g_subprocess_launcher_set_environ() is
// called. Previously, it was copied when the subprocess was executed. This
// means the copied environment may now be modified (using
// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings. On
// Windows, they should be in UTF-8.
func (self subprocessLauncher) SetEnviron(env []string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 **C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	{

	}

	C.g_subprocess_launcher_set_environ(arg0, arg1)
}

// SetFlags sets the flags on the launcher.
//
// The default flags are G_SUBPROCESS_FLAGS_NONE.
//
// You may not set flags that specify conflicting options for how to handle
// a particular stdio stream (eg: specifying both
// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
//
// You may also not set a flag that conflicts with a previous call to a
// function like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
func (self subprocessLauncher) SetFlags(flags SubprocessFlags) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.GSubprocessFlags

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (C.GSubprocessFlags)(flags)

	C.g_subprocess_launcher_set_flags(arg0, arg1)
}

// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '2>' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) SetStderrFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stderr_file_path(arg0, arg1)
}

// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) SetStdinFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stdin_file_path(arg0, arg1)
}

// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '>' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) SetStdoutFilePath(path string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_set_stdout_file_path(arg0, arg1)
}

// Setenv sets the environment variable @variable in the environment of
// processes launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte
// strings, except that the variable's name cannot contain '='. On Windows,
// they should be in UTF-8.
func (self subprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 C.gboolean

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = gextras.Cbool(overwrite)

	C.g_subprocess_launcher_setenv(arg0, arg1, arg2, arg3)
}

// Spawnv creates a #GSubprocess given a provided array of arguments.
func (self subprocessLauncher) Spawnv(argv []string) Subprocess {
	var arg0 *C.GSubprocessLauncher
	var arg1 **C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	{

	}

	ret := C.g_subprocess_launcher_spawnv(arg0, arg1)

	var ret0 Subprocess

	ret0 = WrapSubprocess(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes "ownership" of the fd; it will be closed in
// the parent when @self is freed.
//
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom pipe() or
// socketpair() before launching the process, and choose the target
// descriptor in the child.
//
// An example use case is GNUPG, which has a command line argument
// --passphrase-fd providing a file descriptor number where it expects the
// passphrase to be written.
func (self subprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = C.gint(sourceFd)
	arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(arg0, arg1, arg2)
}

// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the stderr
// of the parent process.
//
// The passed @fd belongs to the Launcher. It will be automatically closed
// when the launcher is finalized. The file descriptor will also be closed
// on the child side when executing the spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) TakeStderrFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(arg0, arg1)
}

// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
// way to go about doing that.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) TakeStdinFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(arg0, arg1)
}

// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the stdout
// of the parent process.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdout fd if a stdout file path is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (self subprocessLauncher) TakeStdoutFd(fd int) {
	var arg0 *C.GSubprocessLauncher
	var arg1 C.gint

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(arg0, arg1)
}

// Unsetenv removes the environment variable @variable from the environment
// of processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not
// containing '='. On Windows, it should be in UTF-8.
func (self subprocessLauncher) Unsetenv(variable string) {
	var arg0 *C.GSubprocessLauncher
	var arg1 *C.gchar

	arg0 = (*C.GSubprocessLauncher)(self.Native())
	arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(arg1))

	C.g_subprocess_launcher_unsetenv(arg0, arg1)
}

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult:
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
type Task interface {
	gextras.Objector

	// AttachSource: a utility function for dealing with async operations where
	// you need to wait for a #GSource to trigger. Attaches @source to @task's
	// Context with @task's [priority][io-priority], and sets @source's callback
	// to @callback, with @task as the callback's `user_data`.
	//
	// It will set the @source’s name to the task’s name (as set with
	// g_task_set_name()), if one has been set.
	//
	// This takes a reference on @task until @source is destroyed.
	AttachSource(source *glib.Source, callback glib.SourceFunc)
	// Cancellable gets @task's #GCancellable
	Cancellable() Cancellable
	// CheckCancellable gets @task's check-cancellable flag. See
	// g_task_set_check_cancellable() for more details.
	CheckCancellable() bool
	// Completed gets the value of #GTask:completed. This changes from false to
	// true after the task’s callback is invoked, and will return false if
	// called from inside the callback.
	Completed() bool
	// Context gets the Context that @task will return its result in (that is,
	// the context that was the [thread-default main
	// context][g-main-context-push-thread-default] at the point when @task was
	// created).
	//
	// This will always return a non-nil value, even if the task's context is
	// the default Context.
	Context() *glib.MainContext
	// Name gets @task’s name. See g_task_set_name().
	Name() string
	// Priority gets @task's priority
	Priority() int
	// ReturnOnCancel gets @task's return-on-cancel flag. See
	// g_task_set_return_on_cancel() for more details.
	ReturnOnCancel() bool
	// SourceObject gets the source object from @task. Like
	// g_async_result_get_source_object(), but does not ref the object.
	SourceObject() gextras.Objector
	// SourceTag gets @task's source tag. See g_task_set_source_tag().
	SourceTag() interface{}
	// TaskData gets @task's `task_data`.
	TaskData() interface{}
	// HadError tests if @task resulted in an error.
	HadError() bool
	// PropagateBoolean gets the result of @task as a #gboolean.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return false and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateBoolean() bool
	// PropagateInt gets the result of @task as an integer (#gssize).
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return -1 and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateInt() int
	// PropagatePointer gets the result of @task as a pointer, and transfers
	// ownership of that value to the caller.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return nil and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagatePointer() interface{}
	// ReturnBoolean sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnBoolean(result bool)
	// ReturnError sets @task's result to @error (which @task assumes ownership
	// of) and completes the task (see g_task_return_pointer() for more
	// discussion of exactly what this means).
	//
	// Note that since the task takes ownership of @error, and since the task
	// may be completed before returning from g_task_return_error(), you cannot
	// assume that @error is still valid after calling this. Call g_error_copy()
	// on the error if you need to keep a local copy as well.
	//
	// See also g_task_return_new_error().
	ReturnError(error *glib.Error)
	// ReturnErrorIfCancelled checks if @task's #GCancellable has been
	// cancelled, and if so, sets @task's error accordingly and completes the
	// task (see g_task_return_pointer() for more discussion of exactly what
	// this means).
	ReturnErrorIfCancelled() bool
	// ReturnInt sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnInt(result int)
	// ReturnPointer sets @task's result to @result and completes the task. If
	// @result is not nil, then @result_destroy will be used to free @result if
	// the caller does not take ownership of it with g_task_propagate_pointer().
	//
	// "Completes the task" means that for an ordinary asynchronous task it will
	// either invoke the task's callback, or else queue that callback to be
	// invoked in the proper Context, or in the next iteration of the current
	// Context. For a task run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync(), calling this method will save @result to be
	// returned to the caller later, but the task will not actually be completed
	// until the ThreadFunc exits.
	//
	// Note that since the task may be completed before returning from
	// g_task_return_pointer(), you cannot assume that @result is still valid
	// after calling this, unless you are still holding another reference on it.
	ReturnPointer(result interface{})
	// ReturnValue sets @task's result to @result (by copying it) and completes
	// the task.
	//
	// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
	// will be used for the result.
	//
	// This is a very generic low-level method intended primarily for use by
	// language bindings; for C code, g_task_return_pointer() and the like will
	// normally be much easier to use.
	ReturnValue(result *externglib.Value)
	// RunInThread runs @task_func in another thread. When @task_func returns,
	// @task's ReadyCallback will be invoked in @task's Context.
	//
	// This takes a ref on @task until the task completes.
	//
	// See ThreadFunc for more details about how @task_func is handled.
	//
	// Although GLib currently rate-limits the tasks queued via
	// g_task_run_in_thread(), you should not assume that it will always do
	// this. If you have a very large number of tasks to run, but don't want
	// them to all run at once, you should only queue a limited number of them
	// at a time.
	RunInThread(taskFunc TaskThreadFunc)
	// RunInThreadSync runs @task_func in another thread, and waits for it to
	// return or be cancelled. You can use g_task_propagate_pointer(), etc,
	// afterward to get the result of @task_func.
	//
	// See ThreadFunc for more details about how @task_func is handled.
	//
	// Normally this is used with tasks created with a nil `callback`, but note
	// that even if the task does have a callback, it will not be invoked when
	// @task_func returns. #GTask:completed will be set to true just before this
	// function returns.
	//
	// Although GLib currently rate-limits the tasks queued via
	// g_task_run_in_thread_sync(), you should not assume that it will always do
	// this. If you have a very large number of tasks to run, but don't want
	// them to all run at once, you should only queue a limited number of them
	// at a time.
	RunInThreadSync(taskFunc TaskThreadFunc)
	// SetCheckCancellable sets or clears @task's check-cancellable flag. If
	// this is true (the default), then g_task_propagate_pointer(), etc, and
	// g_task_had_error() will check the task's #GCancellable first, and if it
	// has been cancelled, then they will consider the task to have returned an
	// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
	// other error or return value the task may have had.
	//
	// If @check_cancellable is false, then the #GTask will not check the
	// cancellable itself, and it is up to @task's owner to do this (eg, via
	// g_task_return_error_if_cancelled()).
	//
	// If you are using g_task_set_return_on_cancel() as well, then you must
	// leave check-cancellable set true.
	SetCheckCancellable(checkCancellable bool)
	// SetName sets @task’s name, used in debugging and profiling. The name
	// defaults to nil.
	//
	// The task name should describe in a human readable way what the task does.
	// For example, ‘Open file’ or ‘Connect to network host’. It is used to set
	// the name of the #GSource used for idle completion of the task.
	//
	// This function may only be called before the @task is first used in a
	// thread other than the one it was constructed in.
	SetName(name string)
	// SetPriority sets @task's priority. If you do not call this, it will
	// default to G_PRIORITY_DEFAULT.
	//
	// This will affect the priority of #GSources created with
	// g_task_attach_source() and the scheduling of tasks run in threads, and
	// can also be explicitly retrieved later via g_task_get_priority().
	SetPriority(priority int)
	// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
	// only meaningful for tasks run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync().
	//
	// If @return_on_cancel is true, then cancelling @task's #GCancellable will
	// immediately cause it to return, as though the task's ThreadFunc had
	// called g_task_return_error_if_cancelled() and then returned.
	//
	// This allows you to create a cancellable wrapper around an uninterruptible
	// function. The ThreadFunc just needs to be careful that it does not modify
	// any externally-visible state after it has been cancelled. To do that, the
	// thread should call g_task_set_return_on_cancel() again to (atomically)
	// set return-on-cancel false before making externally-visible changes; if
	// the task gets cancelled before the return-on-cancel flag could be
	// changed, g_task_set_return_on_cancel() will indicate this by returning
	// false.
	//
	// You can disable and re-enable this flag multiple times if you wish. If
	// the task's #GCancellable is cancelled while return-on-cancel is false,
	// then calling g_task_set_return_on_cancel() to set it true again will
	// cause the task to be cancelled at that point.
	//
	// If the task's #GCancellable is already cancelled before you call
	// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
	// will still be run (for consistency), but the task will also be completed
	// right away.
	SetReturnOnCancel(returnOnCancel bool) bool
	// SetSourceTag sets @task's source tag. You can use this to tag a task
	// return value with a particular pointer (usually a pointer to the function
	// doing the tagging) and then later check it using g_task_get_source_tag()
	// (or g_async_result_is_tagged()) in the task's "finish" function, to
	// figure out if the response came from a particular place.
	SetSourceTag(sourceTag interface{})
	// SetTaskData sets @task's task data (freeing the existing task data, if
	// any).
	SetTaskData(taskData interface{})
}

// task implements the Task interface.
type task struct {
	gextras.Objector
}

// WrapTask wraps a GObject to the right type. It is
// primarily used internally.
func WrapTask(obj *externglib.Object) Task {
	return Task{
		gextras.Objector: (obj),
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTask(obj), nil
}

// NewTask constructs a class Task.
func NewTask(sourceObject gextras.Objector, cancellable Cancellable, callback AsyncReadyCallback) Task {
	var arg1 C.gpointer
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(callbackData))

	arg1 = (*C.GObject)(sourceObject.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	ret := C.g_task_new(arg1, arg2, arg3)

	var ret0 Task

	ret0 = WrapTask(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AttachSource: a utility function for dealing with async operations where
// you need to wait for a #GSource to trigger. Attaches @source to @task's
// Context with @task's [priority][io-priority], and sets @source's callback
// to @callback, with @task as the callback's `user_data`.
//
// It will set the @source’s name to the task’s name (as set with
// g_task_set_name()), if one has been set.
//
// This takes a reference on @task until @source is destroyed.
func (task task) AttachSource(source *glib.Source, callback glib.SourceFunc) {
	var arg0 *C.GTask
	var arg1 *C.GSource
	var arg2 C.GSourceFunc

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*C.GSource)(source.Native())
	arg2 = (*[0]byte)(C.gotk4_SourceFunc)

	C.g_task_attach_source(arg0, arg1, arg2)
}

// Cancellable gets @task's #GCancellable
func (task task) Cancellable() Cancellable {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_cancellable(arg0)

	var ret0 Cancellable

	ret0 = WrapCancellable(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// CheckCancellable gets @task's check-cancellable flag. See
// g_task_set_check_cancellable() for more details.
func (task task) CheckCancellable() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_check_cancellable(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Completed gets the value of #GTask:completed. This changes from false to
// true after the task’s callback is invoked, and will return false if
// called from inside the callback.
func (task task) Completed() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_completed(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Context gets the Context that @task will return its result in (that is,
// the context that was the [thread-default main
// context][g-main-context-push-thread-default] at the point when @task was
// created).
//
// This will always return a non-nil value, even if the task's context is
// the default Context.
func (task task) Context() *glib.MainContext {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_context(arg0)

	var ret0 *glib.MainContext

	ret0 = glib.WrapMainContext(ret)

	return ret0
}

// Name gets @task’s name. See g_task_set_name().
func (task task) Name() string {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Priority gets @task's priority
func (task task) Priority() int {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ReturnOnCancel gets @task's return-on-cancel flag. See
// g_task_set_return_on_cancel() for more details.
func (task task) ReturnOnCancel() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_return_on_cancel(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SourceObject gets the source object from @task. Like
// g_async_result_get_source_object(), but does not ref the object.
func (task task) SourceObject() gextras.Objector {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_source_object(arg0)

	var ret0 gextras.Objector

	ret0 = externglib.Take(unsafe.Pointer(ret.Native()))

	return ret0
}

// SourceTag gets @task's source tag. See g_task_set_source_tag().
func (task task) SourceTag() interface{} {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_source_tag(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TaskData gets @task's `task_data`.
func (task task) TaskData() interface{} {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_get_task_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// HadError tests if @task resulted in an error.
func (task task) HadError() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_had_error(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PropagateBoolean gets the result of @task as a #gboolean.
//
// If the task resulted in an error, or was cancelled, then this will
// instead return false and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (task task) PropagateBoolean() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_propagate_boolean(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// PropagateInt gets the result of @task as an integer (#gssize).
//
// If the task resulted in an error, or was cancelled, then this will
// instead return -1 and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (task task) PropagateInt() int {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_propagate_int(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PropagatePointer gets the result of @task as a pointer, and transfers
// ownership of that value to the caller.
//
// If the task resulted in an error, or was cancelled, then this will
// instead return nil and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (task task) PropagatePointer() interface{} {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_propagate_pointer(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// ReturnBoolean sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
func (task task) ReturnBoolean(result bool) {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(task.Native())
	arg1 = gextras.Cbool(result)

	C.g_task_return_boolean(arg0, arg1)
}

// ReturnError sets @task's result to @error (which @task assumes ownership
// of) and completes the task (see g_task_return_pointer() for more
// discussion of exactly what this means).
//
// Note that since the task takes ownership of @error, and since the task
// may be completed before returning from g_task_return_error(), you cannot
// assume that @error is still valid after calling this. Call g_error_copy()
// on the error if you need to keep a local copy as well.
//
// See also g_task_return_new_error().
func (task task) ReturnError(error *glib.Error) {
	var arg0 *C.GTask
	var arg1 *C.GError

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_task_return_error(arg0, arg1)
}

// ReturnErrorIfCancelled checks if @task's #GCancellable has been
// cancelled, and if so, sets @task's error accordingly and completes the
// task (see g_task_return_pointer() for more discussion of exactly what
// this means).
func (task task) ReturnErrorIfCancelled() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(task.Native())

	ret := C.g_task_return_error_if_cancelled(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// ReturnInt sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
func (task task) ReturnInt(result int) {
	var arg0 *C.GTask
	var arg1 C.gssize

	arg0 = (*C.GTask)(task.Native())
	arg1 = C.gssize(result)

	C.g_task_return_int(arg0, arg1)
}

// ReturnPointer sets @task's result to @result and completes the task. If
// @result is not nil, then @result_destroy will be used to free @result if
// the caller does not take ownership of it with g_task_propagate_pointer().
//
// "Completes the task" means that for an ordinary asynchronous task it will
// either invoke the task's callback, or else queue that callback to be
// invoked in the proper Context, or in the next iteration of the current
// Context. For a task run via g_task_run_in_thread() or
// g_task_run_in_thread_sync(), calling this method will save @result to be
// returned to the caller later, but the task will not actually be completed
// until the ThreadFunc exits.
//
// Note that since the task may be completed before returning from
// g_task_return_pointer(), you cannot assume that @result is still valid
// after calling this, unless you are still holding another reference on it.
func (task task) ReturnPointer(result interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer
	var arg2 C.GDestroyNotify

	arg0 = (*C.GTask)(task.Native())
	arg1 = C.gpointer(box.Assign(result))

	C.g_task_return_pointer(arg0, arg1, arg2)
}

// ReturnValue sets @task's result to @result (by copying it) and completes
// the task.
//
// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
// will be used for the result.
//
// This is a very generic low-level method intended primarily for use by
// language bindings; for C code, g_task_return_pointer() and the like will
// normally be much easier to use.
func (task task) ReturnValue(result *externglib.Value) {
	var arg0 *C.GTask
	var arg1 *C.GValue

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*C.GValue)(result.GValue)

	C.g_task_return_value(arg0, arg1)
}

// RunInThread runs @task_func in another thread. When @task_func returns,
// @task's ReadyCallback will be invoked in @task's Context.
//
// This takes a ref on @task until the task completes.
//
// See ThreadFunc for more details about how @task_func is handled.
//
// Although GLib currently rate-limits the tasks queued via
// g_task_run_in_thread(), you should not assume that it will always do
// this. If you have a very large number of tasks to run, but don't want
// them to all run at once, you should only queue a limited number of them
// at a time.
func (task task) RunInThread(taskFunc TaskThreadFunc) {
	var arg0 *C.GTask
	var arg1 C.GTaskThreadFunc

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*[0]byte)(C.gotk4_TaskThreadFunc)

	C.g_task_run_in_thread(arg0, arg1)
}

// RunInThreadSync runs @task_func in another thread, and waits for it to
// return or be cancelled. You can use g_task_propagate_pointer(), etc,
// afterward to get the result of @task_func.
//
// See ThreadFunc for more details about how @task_func is handled.
//
// Normally this is used with tasks created with a nil `callback`, but note
// that even if the task does have a callback, it will not be invoked when
// @task_func returns. #GTask:completed will be set to true just before this
// function returns.
//
// Although GLib currently rate-limits the tasks queued via
// g_task_run_in_thread_sync(), you should not assume that it will always do
// this. If you have a very large number of tasks to run, but don't want
// them to all run at once, you should only queue a limited number of them
// at a time.
func (task task) RunInThreadSync(taskFunc TaskThreadFunc) {
	var arg0 *C.GTask
	var arg1 C.GTaskThreadFunc

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*[0]byte)(C.gotk4_TaskThreadFunc)

	C.g_task_run_in_thread_sync(arg0, arg1)
}

// SetCheckCancellable sets or clears @task's check-cancellable flag. If
// this is true (the default), then g_task_propagate_pointer(), etc, and
// g_task_had_error() will check the task's #GCancellable first, and if it
// has been cancelled, then they will consider the task to have returned an
// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
// other error or return value the task may have had.
//
// If @check_cancellable is false, then the #GTask will not check the
// cancellable itself, and it is up to @task's owner to do this (eg, via
// g_task_return_error_if_cancelled()).
//
// If you are using g_task_set_return_on_cancel() as well, then you must
// leave check-cancellable set true.
func (task task) SetCheckCancellable(checkCancellable bool) {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(task.Native())
	arg1 = gextras.Cbool(checkCancellable)

	C.g_task_set_check_cancellable(arg0, arg1)
}

// SetName sets @task’s name, used in debugging and profiling. The name
// defaults to nil.
//
// The task name should describe in a human readable way what the task does.
// For example, ‘Open file’ or ‘Connect to network host’. It is used to set
// the name of the #GSource used for idle completion of the task.
//
// This function may only be called before the @task is first used in a
// thread other than the one it was constructed in.
func (task task) SetName(name string) {
	var arg0 *C.GTask
	var arg1 *C.gchar

	arg0 = (*C.GTask)(task.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_task_set_name(arg0, arg1)
}

// SetPriority sets @task's priority. If you do not call this, it will
// default to G_PRIORITY_DEFAULT.
//
// This will affect the priority of #GSources created with
// g_task_attach_source() and the scheduling of tasks run in threads, and
// can also be explicitly retrieved later via g_task_get_priority().
func (task task) SetPriority(priority int) {
	var arg0 *C.GTask
	var arg1 C.gint

	arg0 = (*C.GTask)(task.Native())
	arg1 = C.gint(priority)

	C.g_task_set_priority(arg0, arg1)
}

// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
// only meaningful for tasks run via g_task_run_in_thread() or
// g_task_run_in_thread_sync().
//
// If @return_on_cancel is true, then cancelling @task's #GCancellable will
// immediately cause it to return, as though the task's ThreadFunc had
// called g_task_return_error_if_cancelled() and then returned.
//
// This allows you to create a cancellable wrapper around an uninterruptible
// function. The ThreadFunc just needs to be careful that it does not modify
// any externally-visible state after it has been cancelled. To do that, the
// thread should call g_task_set_return_on_cancel() again to (atomically)
// set return-on-cancel false before making externally-visible changes; if
// the task gets cancelled before the return-on-cancel flag could be
// changed, g_task_set_return_on_cancel() will indicate this by returning
// false.
//
// You can disable and re-enable this flag multiple times if you wish. If
// the task's #GCancellable is cancelled while return-on-cancel is false,
// then calling g_task_set_return_on_cancel() to set it true again will
// cause the task to be cancelled at that point.
//
// If the task's #GCancellable is already cancelled before you call
// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
// will still be run (for consistency), but the task will also be completed
// right away.
func (task task) SetReturnOnCancel(returnOnCancel bool) bool {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(task.Native())
	arg1 = gextras.Cbool(returnOnCancel)

	ret := C.g_task_set_return_on_cancel(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetSourceTag sets @task's source tag. You can use this to tag a task
// return value with a particular pointer (usually a pointer to the function
// doing the tagging) and then later check it using g_task_get_source_tag()
// (or g_async_result_is_tagged()) in the task's "finish" function, to
// figure out if the response came from a particular place.
func (task task) SetSourceTag(sourceTag interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer

	arg0 = (*C.GTask)(task.Native())
	arg1 = C.gpointer(box.Assign(sourceTag))

	C.g_task_set_source_tag(arg0, arg1)
}

// SetTaskData sets @task's task data (freeing the existing task data, if
// any).
func (task task) SetTaskData(taskData interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer
	var arg2 C.GDestroyNotify

	arg0 = (*C.GTask)(task.Native())
	arg1 = C.gpointer(box.Assign(taskData))

	C.g_task_set_task_data(arg0, arg1, arg2)
}

// TcpConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TcpConnection interface {
	SocketConnection

	// GracefulDisconnect checks if graceful disconnects are used. See
	// g_tcp_connection_set_graceful_disconnect().
	GracefulDisconnect() bool
	// SetGracefulDisconnect: this enables graceful disconnects on close. A
	// graceful disconnect means that we signal the receiving end that the
	// connection is terminated and wait for it to close the connection before
	// closing the connection.
	//
	// A graceful disconnect means that we can be sure that we successfully sent
	// all the outstanding data to the other end, or get an error reported.
	// However, it also means we have to wait for all the data to reach the
	// other side and for it to acknowledge this by closing the socket, which
	// may take a while. For this reason it is disabled by default.
	SetGracefulDisconnect(gracefulDisconnect bool)
}

// tcpConnection implements the TcpConnection interface.
type tcpConnection struct {
	SocketConnection
}

// WrapTcpConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTcpConnection(obj *externglib.Object) TcpConnection {
	return TcpConnection{
		SocketConnection: WrapSocketConnection(obj),
	}
}

func marshalTcpConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTcpConnection(obj), nil
}

// GracefulDisconnect checks if graceful disconnects are used. See
// g_tcp_connection_set_graceful_disconnect().
func (connection tcpConnection) GracefulDisconnect() bool {
	var arg0 *C.GTcpConnection

	arg0 = (*C.GTcpConnection)(connection.Native())

	ret := C.g_tcp_connection_get_graceful_disconnect(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SetGracefulDisconnect: this enables graceful disconnects on close. A
// graceful disconnect means that we signal the receiving end that the
// connection is terminated and wait for it to close the connection before
// closing the connection.
//
// A graceful disconnect means that we can be sure that we successfully sent
// all the outstanding data to the other end, or get an error reported.
// However, it also means we have to wait for all the data to reach the
// other side and for it to acknowledge this by closing the socket, which
// may take a while. For this reason it is disabled by default.
func (connection tcpConnection) SetGracefulDisconnect(gracefulDisconnect bool) {
	var arg0 *C.GTcpConnection
	var arg1 C.gboolean

	arg0 = (*C.GTcpConnection)(connection.Native())
	arg1 = gextras.Cbool(gracefulDisconnect)

	C.g_tcp_connection_set_graceful_disconnect(arg0, arg1)
}

// TcpWrapperConnection: a WrapperConnection can be used to wrap a OStream that
// is based on a #GSocket, but which is not actually a Connection. This is used
// by Client so that it can always return a Connection, even when the connection
// it has actually created is not directly a Connection.
type TcpWrapperConnection interface {
	TcpConnection

	// BaseIOStream gets @conn's base OStream
	BaseIOStream() IOStream
}

// tcpWrapperConnection implements the TcpWrapperConnection interface.
type tcpWrapperConnection struct {
	TcpConnection
}

// WrapTcpWrapperConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTcpWrapperConnection(obj *externglib.Object) TcpWrapperConnection {
	return TcpWrapperConnection{
		TcpConnection: WrapTcpConnection(obj),
	}
}

func marshalTcpWrapperConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTcpWrapperConnection(obj), nil
}

// NewTcpWrapperConnection constructs a class TcpWrapperConnection.
func NewTcpWrapperConnection(baseIOStream IOStream, socket Socket) TcpWrapperConnection {
	var arg1 *C.GIOStream
	var arg2 *C.GSocket

	arg1 = (*C.GIOStream)(baseIOStream.Native())
	arg2 = (*C.GSocket)(socket.Native())

	ret := C.g_tcp_wrapper_connection_new(arg1, arg2)

	var ret0 TcpWrapperConnection

	ret0 = WrapTcpWrapperConnection(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// BaseIOStream gets @conn's base OStream
func (conn tcpWrapperConnection) BaseIOStream() IOStream {
	var arg0 *C.GTcpWrapperConnection

	arg0 = (*C.GTcpWrapperConnection)(conn.Native())

	ret := C.g_tcp_wrapper_connection_get_base_io_stream(arg0)

	var ret0 IOStream

	ret0 = WrapIOStream(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the user’s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//
//        [D-BUS Service]
//        Name=org.gtk.GDBus.Examples.ObjectManager
//        Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//    ]|
//    You will also need to indicate this service directory in your test
//    fixtures, so you will need to pass the path while compiling your
//    test cases. Typically this is done with autotools with an added
//    preprocessor flag specified to compile your tests such as:
//    |[
//        -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//    ]|
//        Once you have a service definition file which is local to your source tree,
//    you can proceed to set up a GTest fixture using the DBus scaffolding.
//
//    An example of a test fixture for D-Bus services can be found
//    here:
//    gdbus-test-fixture.c (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
//    Note that these examples only deal with isolating the D-Bus aspect of your
//    service. To successfully run isolated unit tests on your service you may need
//    some additional modifications to your test case fixture. For example; if your
//    service uses GSettings and installs a schema then it is important that your test service
//    not load the schema in the ordinary installed location (chances are that your service
//    and schema files are not yet installed, or worse; there is an older version of the
//    schema file sitting in the install location).
//
//    Most of the time we can work around these obstacles using the
//    environment. Since the environment is inherited by the D-Bus daemon
//    created by DBus and then in turn inherited by any services the
//    D-Bus daemon activates, using the setup routine for your fixture is
//    a practical place to help sandbox your runtime environment. For the
//    rather typical GSettings case we can work around this by setting
//    `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
//    in the above fixture_setup() routine.
//
//    The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
//    by compiling the schemas locally as a step before running test cases, an autotools setup might
//    do the following in the directory holding schemas:
//    |[
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
//
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop: stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

// testDBus implements the TestDBus interface.
type testDBus struct {
	gextras.Objector
}

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return TestDBus{
		gextras.Objector: (obj),
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

// NewTestDBus constructs a class TestDBus.
func NewTestDBus(flags TestDBusFlags) TestDBus {
	var arg1 C.GTestDBusFlags

	arg1 = (C.GTestDBusFlags)(flags)

	ret := C.g_test_dbus_new(arg1)

	var ret0 TestDBus

	ret0 = WrapTestDBus(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddServiceDir: add a path where dbus-daemon will look up .service files.
// This can't be called after g_test_dbus_up().
func (self testDBus) AddServiceDir(path string) {
	var arg0 *C.GTestDBus
	var arg1 *C.gchar

	arg0 = (*C.GTestDBus)(self.Native())
	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	C.g_test_dbus_add_service_dir(arg0, arg1)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or
// g_bus_get_sync() to be destroyed. This is done to ensure that the next
// unit test won't get a leaked singleton from this test.
func (self testDBus) Down() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(self.Native())

	C.g_test_dbus_down(arg0)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, nil is returned. This can be
// used with g_dbus_connection_new_for_address().
func (self testDBus) BusAddress() string {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(self.Native())

	ret := C.g_test_dbus_get_bus_address(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags: get the flags of the DBus object.
func (self testDBus) Flags() TestDBusFlags {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(self.Native())

	ret := C.g_test_dbus_get_flags(arg0)

	var ret0 TestDBusFlags

	ret0 = TestDBusFlags(ret)

	return ret0
}

// Stop: stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
// wanting to verify behaviour after the session bus has been stopped can
// use this function but should still call g_test_dbus_down() when done.
func (self testDBus) Stop() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(self.Native())

	C.g_test_dbus_stop(arg0)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
// this call, it is safe for unit tests to start sending messages on the
// session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then
// g_test_dbus_down() must be called after g_test_run().
func (self testDBus) Up() {
	var arg0 *C.GTestDBus

	arg0 = (*C.GTestDBus)(self.Native())

	C.g_test_dbus_up(arg0)
}

// ThemedIcon is an implementation of #GIcon that supports icon themes. Icon
// contains a list of all of the icons present in an icon theme, so that icons
// can be looked up quickly. Icon does not provide actual pixmaps for icons,
// just the icon names. Ideally something like gtk_icon_theme_choose_icon()
// should be used to resolve the list of names so that fallback icons work
// nicely with themes that inherit other themes.
type ThemedIcon interface {
	gextras.Objector

	// AppendName: append a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	AppendName(iconname string)
	// Names gets the names of icons from within @icon.
	Names() []string
	// PrependName: prepend a name to the list of icons from within @icon.
	//
	// Note that doing so invalidates the hash computed by prior calls to
	// g_icon_hash().
	PrependName(iconname string)
}

// themedIcon implements the ThemedIcon interface.
type themedIcon struct {
	gextras.Objector
}

// WrapThemedIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapThemedIcon(obj *externglib.Object) ThemedIcon {
	return ThemedIcon{
		gextras.Objector: (obj),
	}
}

func marshalThemedIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThemedIcon(obj), nil
}

// NewThemedIcon constructs a class ThemedIcon.
func NewThemedIcon(iconname string) ThemedIcon {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(iconname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_themed_icon_new(arg1)

	var ret0 ThemedIcon

	ret0 = WrapThemedIcon(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewThemedIconWithDefaultFallbacks constructs a class ThemedIcon.
func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(iconname))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_themed_icon_new_with_default_fallbacks(arg1)

	var ret0 ThemedIcon

	ret0 = WrapThemedIcon(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendName: append a name to the list of icons from within @icon.
//
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
func (icon themedIcon) AppendName(iconname string) {
	var arg0 *C.GThemedIcon
	var arg1 *C.char

	arg0 = (*C.GThemedIcon)(icon.Native())
	arg1 = (*C.gchar)(C.CString(iconname))
	defer C.free(unsafe.Pointer(arg1))

	C.g_themed_icon_append_name(arg0, arg1)
}

// Names gets the names of icons from within @icon.
func (icon themedIcon) Names() []string {
	var arg0 *C.GThemedIcon

	arg0 = (*C.GThemedIcon)(icon.Native())

	ret := C.g_themed_icon_get_names(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// PrependName: prepend a name to the list of icons from within @icon.
//
// Note that doing so invalidates the hash computed by prior calls to
// g_icon_hash().
func (icon themedIcon) PrependName(iconname string) {
	var arg0 *C.GThemedIcon
	var arg1 *C.char

	arg0 = (*C.GThemedIcon)(icon.Native())
	arg1 = (*C.gchar)(C.CString(iconname))
	defer C.free(unsafe.Pointer(arg1))

	C.g_themed_icon_prepend_name(arg0, arg1)
}

// ThreadedSocketService: a SocketService is a simple subclass of Service that
// handles incoming connections by creating a worker thread and dispatching the
// connection to it by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService interface {
	SocketService
}

// threadedSocketService implements the ThreadedSocketService interface.
type threadedSocketService struct {
	SocketService
}

// WrapThreadedSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapThreadedSocketService(obj *externglib.Object) ThreadedSocketService {
	return ThreadedSocketService{
		SocketService: WrapSocketService(obj),
	}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThreadedSocketService(obj), nil
}

// NewThreadedSocketService constructs a class ThreadedSocketService.
func NewThreadedSocketService(maxThreads int) ThreadedSocketService {
	var arg1 C.int

	arg1 = C.int(maxThreads)

	ret := C.g_threaded_socket_service_new(arg1)

	var ret0 ThreadedSocketService

	ret0 = WrapThreadedSocketService(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// TLSCertificate: a certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate received by
// a client from a server), or the combination of a certificate and a private
// key (which is needed when acting as a ServerConnection).
type TLSCertificate interface {
	gextras.Objector

	// Issuer gets the Certificate representing @cert's issuer, if known
	Issuer() TLSCertificate
	// IsSame: check if two Certificate objects represent the same certificate.
	// The raw DER byte data of the two certificates are checked for equality.
	// This has the effect that two certificates may compare equal even if their
	// Certificate:issuer, Certificate:private-key, or
	// Certificate:private-key-pem properties differ.
	IsSame(certTwo TLSCertificate) bool
	// Verify: this verifies @cert and returns a set of CertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to check a
	// certificate against a CA that is not part of the system CA database.
	//
	// If @identity is not nil, @cert's name(s) will be compared against it, and
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does
	// not match. If @identity is nil, that bit will never be set in the return
	// value.
	//
	// If @trusted_ca is not nil, then @cert (or one of the certificates in its
	// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be
	// set in the return value. If @trusted_ca is nil, that bit will never be
	// set in the return value.
	//
	// (All other CertificateFlags values will always be set or unset as
	// appropriate.)
	Verify(identity SocketConnectable, trustedCa TLSCertificate) TLSCertificateFlags
}

// tlsCertificate implements the TLSCertificate interface.
type tlsCertificate struct {
	gextras.Objector
}

// WrapTLSCertificate wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSCertificate(obj *externglib.Object) TLSCertificate {
	return TLSCertificate{
		gextras.Objector: (obj),
	}
}

func marshalTLSCertificate(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSCertificate(obj), nil
}

// NewTLSCertificateFromFile constructs a class TLSCertificate.
func NewTLSCertificateFromFile(file string) TLSCertificate {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(file))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_tls_certificate_new_from_file(arg1)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTLSCertificateFromFiles constructs a class TLSCertificate.
func NewTLSCertificateFromFiles(certFile string, keyFile string) TLSCertificate {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(certFile))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(keyFile))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_tls_certificate_new_from_files(arg1, arg2)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewTLSCertificateFromPem constructs a class TLSCertificate.
func NewTLSCertificateFromPem(data string, length int) TLSCertificate {
	var arg1 *C.gchar
	var arg2 C.gssize

	arg1 = (*C.gchar)(C.CString(data))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gssize(length)

	ret := C.g_tls_certificate_new_from_pem(arg1, arg2)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Issuer gets the Certificate representing @cert's issuer, if known
func (cert tlsCertificate) Issuer() TLSCertificate {
	var arg0 *C.GTlsCertificate

	arg0 = (*C.GTlsCertificate)(cert.Native())

	ret := C.g_tls_certificate_get_issuer(arg0)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// IsSame: check if two Certificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if their
// Certificate:issuer, Certificate:private-key, or
// Certificate:private-key-pem properties differ.
func (certOne tlsCertificate) IsSame(certTwo TLSCertificate) bool {
	var arg0 *C.GTlsCertificate
	var arg1 *C.GTlsCertificate

	arg0 = (*C.GTlsCertificate)(certOne.Native())
	arg1 = (*C.GTlsCertificate)(certTwo.Native())

	ret := C.g_tls_certificate_is_same(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Verify: this verifies @cert and returns a set of CertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to check a
// certificate against a CA that is not part of the system CA database.
//
// If @identity is not nil, @cert's name(s) will be compared against it, and
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value if it does
// not match. If @identity is nil, that bit will never be set in the return
// value.
//
// If @trusted_ca is not nil, then @cert (or one of the certificates in its
// chain) must be signed by it, or else G_TLS_CERTIFICATE_UNKNOWN_CA will be
// set in the return value. If @trusted_ca is nil, that bit will never be
// set in the return value.
//
// (All other CertificateFlags values will always be set or unset as
// appropriate.)
func (cert tlsCertificate) Verify(identity SocketConnectable, trustedCa TLSCertificate) TLSCertificateFlags {
	var arg0 *C.GTlsCertificate
	var arg1 *C.GSocketConnectable
	var arg2 *C.GTlsCertificate

	arg0 = (*C.GTlsCertificate)(cert.Native())
	arg2 = (*C.GTlsCertificate)(trustedCa.Native())

	ret := C.g_tls_certificate_verify(arg0, arg1, arg2)

	var ret0 TLSCertificateFlags

	ret0 = TLSCertificateFlags(ret)

	return ret0
}

// TLSConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TLSConnection interface {
	IOStream

	// EmitAcceptCertificate: used by Connection implementations to emit the
	// Connection::accept-certificate signal.
	EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool
	// Certificate gets @conn's certificate, as set by
	// g_tls_connection_set_certificate().
	Certificate() TLSCertificate
	// ChannelBindingData: query the TLS backend for TLS channel binding data of
	// @type for @conn.
	//
	// This call retrieves TLS channel binding data as specified in RFC 5056
	// (https://tools.ietf.org/html/rfc5056), RFC 5929
	// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data
	// is returned in @data. The @data is resized by the callee using Array
	// buffer management and will be freed when the @data is destroyed by
	// g_byte_array_unref(). If @data is nil, it will only check whether TLS
	// backend is able to fetch the data (e.g. whether @type is supported by the
	// TLS backend). It does not guarantee that the data will be available
	// though. That could happen if TLS connection does not support @type or the
	// binding data is not available yet due to additional negotiation or input
	// required.
	ChannelBindingData(_type TLSChannelBindingType) (data []byte, ok bool)
	// Database gets the certificate database that @conn uses to verify peer
	// certificates. See g_tls_connection_set_database().
	Database() TLSDatabase
	// Interaction: get the object that will be used to interact with the user.
	// It will be used for things like prompting the user for passwords. If nil
	// is returned, then no user interaction will occur for this connection.
	Interaction() TLSInteraction
	// NegotiatedProtocol gets the name of the application-layer protocol
	// negotiated during the handshake.
	//
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend does
	// not support ALPN, then this will be nil. See
	// g_tls_connection_set_advertised_protocols().
	NegotiatedProtocol() string
	// PeerCertificate gets @conn's peer's certificate after the handshake has
	// completed or failed. (It is not set during the emission of
	// Connection::accept-certificate.)
	PeerCertificate() TLSCertificate
	// PeerCertificateErrors gets the errors associated with validating @conn's
	// peer's certificate, after the handshake has completed or failed. (It is
	// not set during the emission of Connection::accept-certificate.)
	PeerCertificateErrors() TLSCertificateFlags
	// RehandshakeMode gets @conn rehandshaking mode. See
	// g_tls_connection_set_rehandshake_mode() for details.
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify tests whether or not @conn expects a proper TLS close
	// notification when the connection is closed. See
	// g_tls_connection_set_require_close_notify() for details.
	RequireCloseNotify() bool
	// UseSystemCertdb gets whether @conn uses the system certificate database
	// to verify peer certificates. See
	// g_tls_connection_set_use_system_certdb().
	UseSystemCertdb() bool
	// Handshake attempts a TLS handshake on @conn.
	//
	// On the client side, it is never necessary to call this method; although
	// the connection needs to perform a handshake after connecting (or after
	// sending a "STARTTLS"-type command), Connection will handle this for you
	// automatically when you try to send or receive data on the connection. You
	// can call g_tls_connection_handshake() manually if you want to know
	// whether the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case, if it
	// fails, it may not be possible to tell if it failed before or after
	// completing the handshake), but beware that servers may reject client
	// authentication after the handshake has completed, so a successful
	// handshake does not indicate the connection will be usable.
	//
	// Likewise, on the server side, although a handshake is necessary at the
	// beginning of the communication, you do not need to call this function
	// explicitly unless you want clearer error reporting.
	//
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was deprecated
	// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
	// TLS 1.3. Since GLib 2.64, calling this function after the initial
	// handshake will no longer do anything.
	//
	// When using a Connection created by Client, the Client performs the
	// initial handshake, so calling this function manually is not recommended.
	//
	// Connection::accept_certificate may be emitted during the handshake.
	Handshake(cancellable Cancellable) bool
	// HandshakeAsync: asynchronously performs a TLS handshake on @conn. See
	// g_tls_connection_handshake() for more information.
	HandshakeAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetAdvertisedProtocols sets the list of application-layer protocols to
	// advertise that the caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be used to
	// negotiate a compatible protocol with the peer; use
	// g_tls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake. Specifying nil for the the value of
	// @protocols will disable ALPN negotiation.
	//
	// See IANA TLS ALPN Protocol IDs
	// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: this sets the certificate that @conn will present to its
	// peer during the TLS handshake. For a ServerConnection, it is mandatory to
	// set this, and that will normally be done at construct time.
	//
	// For a ClientConnection, this is optional. If a handshake fails with
	// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
	// certificate, and if you try connecting again, you should call this method
	// first. You can call g_tls_client_connection_get_accepted_cas() on the
	// failed connection to get a list of Certificate Authorities that the
	// server will accept certificates from.
	//
	// (It is also possible that a server will allow the connection with or
	// without a certificate; in that case, if you don't provide a certificate,
	// you can tell that the server requested one by the fact that
	// g_tls_client_connection_get_accepted_cas() will return non-nil.)
	SetCertificate(certificate TLSCertificate)
	// SetDatabase sets the certificate database that is used to verify peer
	// certificates. This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to nil, then peer
	// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
	// error (meaning Connection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetDatabase(database TLSDatabase)
	// SetInteraction: set the object that will be used to interact with the
	// user. It will be used for things like prompting the user for passwords.
	//
	// The @interaction argument will normally be a derived subclass of
	// Interaction. nil can also be provided if no user interaction should occur
	// for this connection.
	SetInteraction(interaction TLSInteraction)
	// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
	// longer supported and will have no effect. With TLS 1.3, rehandshaking has
	// been removed from the TLS protocol, replaced by separate post-handshake
	// authentication and rekey operations.
	SetRehandshakeMode(mode TLSRehandshakeMode)
	// SetRequireCloseNotify sets whether or not @conn expects a proper TLS
	// close notification before the connection is closed. If this is true (the
	// default), then @conn will expect to receive a TLS close notification from
	// its peer before the connection is closed, and will return a
	// G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	//
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data (because
	// the application-level data includes a length field, or is somehow
	// self-delimiting); in this case, the close notify is redundant and
	// sometimes omitted. (TLS 1.1 explicitly allows this; in TLS 1.0 it is
	// technically an error, but often done anyway.) You can use
	// g_tls_connection_set_require_close_notify() to tell @conn to allow an
	// "unannounced" connection close, in which case the close will show up as a
	// 0-length read, as in a non-TLS Connection, and it is up to the
	// application to check that the data has been fully received.
	//
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_io_stream_close() itself on
	// @conn, this will send a close notification regardless of the setting of
	// this property. If you explicitly want to do an unclean close, you can
	// close @conn's Connection:base-io-stream rather than closing @conn itself,
	// but note that this may only be done when no other operations are pending
	// on @conn or the base I/O stream.
	SetRequireCloseNotify(requireCloseNotify bool)
	// SetUseSystemCertdb sets whether @conn uses the system certificate
	// database to verify peer certificates. This is true by default. If set to
	// false, then peer certificate validation will always set the
	// G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// Connection::accept-certificate will always be emitted on client-side
	// connections, unless that bit is not set in
	// ClientConnection:validation-flags).
	SetUseSystemCertdb(useSystemCertdb bool)
}

// tlsConnection implements the TLSConnection interface.
type tlsConnection struct {
	IOStream
}

// WrapTLSConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSConnection(obj *externglib.Object) TLSConnection {
	return TLSConnection{
		IOStream: WrapIOStream(obj),
	}
}

func marshalTLSConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSConnection(obj), nil
}

// EmitAcceptCertificate: used by Connection implementations to emit the
// Connection::accept-certificate signal.
func (conn tlsConnection) EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool {
	var arg0 *C.GTlsConnection
	var arg1 *C.GTlsCertificate
	var arg2 C.GTlsCertificateFlags

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (*C.GTlsCertificate)(peerCert.Native())
	arg2 = (C.GTlsCertificateFlags)(errors)

	ret := C.g_tls_connection_emit_accept_certificate(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Certificate gets @conn's certificate, as set by
// g_tls_connection_set_certificate().
func (conn tlsConnection) Certificate() TLSCertificate {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_certificate(arg0)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// ChannelBindingData: query the TLS backend for TLS channel binding data of
// @type for @conn.
//
// This call retrieves TLS channel binding data as specified in RFC 5056
// (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data
// is returned in @data. The @data is resized by the callee using Array
// buffer management and will be freed when the @data is destroyed by
// g_byte_array_unref(). If @data is nil, it will only check whether TLS
// backend is able to fetch the data (e.g. whether @type is supported by the
// TLS backend). It does not guarantee that the data will be available
// though. That could happen if TLS connection does not support @type or the
// binding data is not available yet due to additional negotiation or input
// required.
func (conn tlsConnection) ChannelBindingData(_type TLSChannelBindingType) (data []byte, ok bool) {
	var arg0 *C.GTlsConnection
	var arg1 C.GTlsChannelBindingType
	var arg2 *C.GByteArray // out

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (C.GTlsChannelBindingType)(_type)

	ret := C.g_tls_connection_get_channel_binding_data(arg0, arg1, &arg2)

	var ret0 []byte
	var ret1 bool

	{
		var length uint
		for p := unsafe.Pointer(arg2); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(arg2)) + i))
			ret0[i] = byte(src)
		}
	}

	ret1 = gextras.Gobool(ret)

	return ret0, ret1
}

// Database gets the certificate database that @conn uses to verify peer
// certificates. See g_tls_connection_set_database().
func (conn tlsConnection) Database() TLSDatabase {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_database(arg0)

	var ret0 TLSDatabase

	ret0 = WrapTLSDatabase(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// Interaction: get the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords. If nil
// is returned, then no user interaction will occur for this connection.
func (conn tlsConnection) Interaction() TLSInteraction {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_interaction(arg0)

	var ret0 TLSInteraction

	ret0 = WrapTLSInteraction(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// NegotiatedProtocol gets the name of the application-layer protocol
// negotiated during the handshake.
//
// If the peer did not use the ALPN extension, or did not advertise a
// protocol that matched one of @conn's protocols, or the TLS backend does
// not support ALPN, then this will be nil. See
// g_tls_connection_set_advertised_protocols().
func (conn tlsConnection) NegotiatedProtocol() string {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_negotiated_protocol(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PeerCertificate gets @conn's peer's certificate after the handshake has
// completed or failed. (It is not set during the emission of
// Connection::accept-certificate.)
func (conn tlsConnection) PeerCertificate() TLSCertificate {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_peer_certificate(arg0)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// PeerCertificateErrors gets the errors associated with validating @conn's
// peer's certificate, after the handshake has completed or failed. (It is
// not set during the emission of Connection::accept-certificate.)
func (conn tlsConnection) PeerCertificateErrors() TLSCertificateFlags {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_peer_certificate_errors(arg0)

	var ret0 TLSCertificateFlags

	ret0 = TLSCertificateFlags(ret)

	return ret0
}

// RehandshakeMode gets @conn rehandshaking mode. See
// g_tls_connection_set_rehandshake_mode() for details.
func (conn tlsConnection) RehandshakeMode() TLSRehandshakeMode {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_rehandshake_mode(arg0)

	var ret0 TLSRehandshakeMode

	ret0 = TLSRehandshakeMode(ret)

	return ret0
}

// RequireCloseNotify tests whether or not @conn expects a proper TLS close
// notification when the connection is closed. See
// g_tls_connection_set_require_close_notify() for details.
func (conn tlsConnection) RequireCloseNotify() bool {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_require_close_notify(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UseSystemCertdb gets whether @conn uses the system certificate database
// to verify peer certificates. See
// g_tls_connection_set_use_system_certdb().
func (conn tlsConnection) UseSystemCertdb() bool {
	var arg0 *C.GTlsConnection

	arg0 = (*C.GTlsConnection)(conn.Native())

	ret := C.g_tls_connection_get_use_system_certdb(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Handshake attempts a TLS handshake on @conn.
//
// On the client side, it is never necessary to call this method; although
// the connection needs to perform a handshake after connecting (or after
// sending a "STARTTLS"-type command), Connection will handle this for you
// automatically when you try to send or receive data on the connection. You
// can call g_tls_connection_handshake() manually if you want to know
// whether the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case, if it
// fails, it may not be possible to tell if it failed before or after
// completing the handshake), but beware that servers may reject client
// authentication after the handshake has completed, so a successful
// handshake does not indicate the connection will be usable.
//
// Likewise, on the server side, although a handshake is necessary at the
// beginning of the communication, you do not need to call this function
// explicitly unless you want clearer error reporting.
//
// Previously, calling g_tls_connection_handshake() after the initial
// handshake would trigger a rehandshake; however, this usage was deprecated
// in GLib 2.60 because rehandshaking was removed from the TLS protocol in
// TLS 1.3. Since GLib 2.64, calling this function after the initial
// handshake will no longer do anything.
//
// When using a Connection created by Client, the Client performs the
// initial handshake, so calling this function manually is not recommended.
//
// Connection::accept_certificate may be emitted during the handshake.
func (conn tlsConnection) Handshake(cancellable Cancellable) bool {
	var arg0 *C.GTlsConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_connection_handshake(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// HandshakeAsync: asynchronously performs a TLS handshake on @conn. See
// g_tls_connection_handshake() for more information.
func (conn tlsConnection) HandshakeAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsConnection
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_connection_handshake_async(arg0, arg1, arg2, arg3)
}

// SetAdvertisedProtocols sets the list of application-layer protocols to
// advertise that the caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be used to
// negotiate a compatible protocol with the peer; use
// g_tls_connection_get_negotiated_protocol() to find the negotiated
// protocol after the handshake. Specifying nil for the the value of
// @protocols will disable ALPN negotiation.
//
// See IANA TLS ALPN Protocol IDs
// (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
func (conn tlsConnection) SetAdvertisedProtocols(protocols []string) {
	var arg0 *C.GTlsConnection
	var arg1 **C.gchar

	arg0 = (*C.GTlsConnection)(conn.Native())
	{

	}

	C.g_tls_connection_set_advertised_protocols(arg0, arg1)
}

// SetCertificate: this sets the certificate that @conn will present to its
// peer during the TLS handshake. For a ServerConnection, it is mandatory to
// set this, and that will normally be done at construct time.
//
// For a ClientConnection, this is optional. If a handshake fails with
// G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server requires a
// certificate, and if you try connecting again, you should call this method
// first. You can call g_tls_client_connection_get_accepted_cas() on the
// failed connection to get a list of Certificate Authorities that the
// server will accept certificates from.
//
// (It is also possible that a server will allow the connection with or
// without a certificate; in that case, if you don't provide a certificate,
// you can tell that the server requested one by the fact that
// g_tls_client_connection_get_accepted_cas() will return non-nil.)
func (conn tlsConnection) SetCertificate(certificate TLSCertificate) {
	var arg0 *C.GTlsConnection
	var arg1 *C.GTlsCertificate

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (*C.GTlsCertificate)(certificate.Native())

	C.g_tls_connection_set_certificate(arg0, arg1)
}

// SetDatabase sets the certificate database that is used to verify peer
// certificates. This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to nil, then peer
// certificate validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA
// error (meaning Connection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// ClientConnection:validation-flags).
func (conn tlsConnection) SetDatabase(database TLSDatabase) {
	var arg0 *C.GTlsConnection
	var arg1 *C.GTlsDatabase

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (*C.GTlsDatabase)(database.Native())

	C.g_tls_connection_set_database(arg0, arg1)
}

// SetInteraction: set the object that will be used to interact with the
// user. It will be used for things like prompting the user for passwords.
//
// The @interaction argument will normally be a derived subclass of
// Interaction. nil can also be provided if no user interaction should occur
// for this connection.
func (conn tlsConnection) SetInteraction(interaction TLSInteraction) {
	var arg0 *C.GTlsConnection
	var arg1 *C.GTlsInteraction

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (*C.GTlsInteraction)(interaction.Native())

	C.g_tls_connection_set_interaction(arg0, arg1)
}

// SetRehandshakeMode: since GLib 2.64, changing the rehandshake mode is no
// longer supported and will have no effect. With TLS 1.3, rehandshaking has
// been removed from the TLS protocol, replaced by separate post-handshake
// authentication and rekey operations.
func (conn tlsConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var arg0 *C.GTlsConnection
	var arg1 C.GTlsRehandshakeMode

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = (C.GTlsRehandshakeMode)(mode)

	C.g_tls_connection_set_rehandshake_mode(arg0, arg1)
}

// SetRequireCloseNotify sets whether or not @conn expects a proper TLS
// close notification before the connection is closed. If this is true (the
// default), then @conn will expect to receive a TLS close notification from
// its peer before the connection is closed, and will return a
// G_TLS_ERROR_EOF error if the connection is closed without proper
// notification (since this may indicate a network error, or
// man-in-the-middle attack).
//
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data (because
// the application-level data includes a length field, or is somehow
// self-delimiting); in this case, the close notify is redundant and
// sometimes omitted. (TLS 1.1 explicitly allows this; in TLS 1.0 it is
// technically an error, but often done anyway.) You can use
// g_tls_connection_set_require_close_notify() to tell @conn to allow an
// "unannounced" connection close, in which case the close will show up as a
// 0-length read, as in a non-TLS Connection, and it is up to the
// application to check that the data has been fully received.
//
// Note that this only affects the behavior when the peer closes the
// connection; when the application calls g_io_stream_close() itself on
// @conn, this will send a close notification regardless of the setting of
// this property. If you explicitly want to do an unclean close, you can
// close @conn's Connection:base-io-stream rather than closing @conn itself,
// but note that this may only be done when no other operations are pending
// on @conn or the base I/O stream.
func (conn tlsConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var arg0 *C.GTlsConnection
	var arg1 C.gboolean

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = gextras.Cbool(requireCloseNotify)

	C.g_tls_connection_set_require_close_notify(arg0, arg1)
}

// SetUseSystemCertdb sets whether @conn uses the system certificate
// database to verify peer certificates. This is true by default. If set to
// false, then peer certificate validation will always set the
// G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// Connection::accept-certificate will always be emitted on client-side
// connections, unless that bit is not set in
// ClientConnection:validation-flags).
func (conn tlsConnection) SetUseSystemCertdb(useSystemCertdb bool) {
	var arg0 *C.GTlsConnection
	var arg1 C.gboolean

	arg0 = (*C.GTlsConnection)(conn.Native())
	arg1 = gextras.Cbool(useSystemCertdb)

	C.g_tls_connection_set_use_system_certdb(arg0, arg1)
}

// TLSDatabase is used to look up certificates and other information from a
// certificate or key store. It is an abstract base class which TLS library
// specific subtypes override.
//
// A Database may be accessed from multiple threads by the TLS backend. All
// implementations are required to be fully thread-safe.
//
// Most common client applications will not directly interact with Database. It
// is used internally by Connection.
type TLSDatabase interface {
	gextras.Objector

	// CreateCertificateHandle: create a handle string for the certificate. The
	// database will only be able to create a handle for certificates that
	// originate from the database. In cases where the database cannot create a
	// handle for a certificate, nil will be returned.
	//
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	CreateCertificateHandle(certificate TLSCertificate) string
	// LookupCertificateForHandle: look up a certificate by its handle.
	//
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a Database object of the
	// same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	//
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then nil will be returned.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_for_handle_async() to perform the
	// lookup operation asynchronously.
	LookupCertificateForHandle(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) TLSCertificate
	// LookupCertificateForHandleAsync: asynchronously look up a certificate by
	// its handle in the database. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	LookupCertificateForHandleAsync(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupCertificateIssuer: look up the issuer of @certificate in the
	// database.
	//
	// The Certificate:issuer property of @certificate is not modified, and the
	// two certificates are not hooked into a chain.
	//
	// This function can block, use
	// g_tls_database_lookup_certificate_issuer_async() to perform the lookup
	// operation asynchronously.
	LookupCertificateIssuer(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) TLSCertificate
	// LookupCertificateIssuerAsync: asynchronously look up the issuer of
	// @certificate in the database. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	LookupCertificateIssuerAsync(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// LookupCertificatesIssuedBy: look up certificates issued by this issuer in
	// the database.
	//
	// This function can block, use
	// g_tls_database_lookup_certificates_issued_by_async() to perform the
	// lookup operation asynchronously.
	LookupCertificatesIssuedBy(issuerRawDn []byte, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) *glib.List
	// LookupCertificatesIssuedByAsync: asynchronously look up certificates
	// issued by this issuer in the database. See
	// g_tls_database_lookup_certificates_issued_by() for more information.
	//
	// The database may choose to hold a reference to the issuer byte array for
	// the duration of of this asynchronous operation. The byte array should not
	// be modified during this time.
	LookupCertificatesIssuedByAsync(issuerRawDn []byte, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// VerifyChain determines the validity of a certificate chain after looking
	// up and adding any missing certificates to the chain.
	//
	// @chain is a chain of Certificate objects each pointing to the next
	// certificate in the chain by its Certificate:issuer property. The chain
	// may initially consist of one or more certificates. After the verification
	// process is complete, @chain may be modified by adding missing
	// certificates, or removing extra certificates. If a certificate anchor was
	// found, then it is added to the @chain.
	//
	// @purpose describes the purpose (or usage) for which the certificate is
	// being used. Typically @purpose will be set to
	// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
	// is being used to authenticate a server (and we are acting as the client).
	//
	// The @identity is used to ensure the server certificate is valid for the
	// expected peer identity. If the identity does not match the certificate,
	// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If
	// @identity is nil, that bit will never be set in the return value. The
	// peer identity may also be used to check for pinned certificates (trust
	// exceptions) in the database. These may override the normal verification
	// process on a host-by-host basis.
	//
	// Currently there are no @flags, and G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	//
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate the
	// problems found. If the function is unable to determine whether @chain is
	// valid or not (eg, because @cancellable is triggered before it completes)
	// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
	// will be set accordingly. @error is not set when @chain is successfully
	// analyzed but found to be invalid.
	//
	// This function can block, use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	VerifyChain(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable) TLSCertificateFlags
	// VerifyChainAsync: asynchronously determines the validity of a certificate
	// chain after looking up and adding any missing certificates to the chain.
	// See g_tls_database_verify_chain() for more information.
	VerifyChainAsync(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback)
}

// tlsDatabase implements the TLSDatabase interface.
type tlsDatabase struct {
	gextras.Objector
}

// WrapTLSDatabase wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSDatabase(obj *externglib.Object) TLSDatabase {
	return TLSDatabase{
		gextras.Objector: (obj),
	}
}

func marshalTLSDatabase(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSDatabase(obj), nil
}

// CreateCertificateHandle: create a handle string for the certificate. The
// database will only be able to create a handle for certificates that
// originate from the database. In cases where the database cannot create a
// handle for a certificate, nil will be returned.
//
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
func (self tlsDatabase) CreateCertificateHandle(certificate TLSCertificate) string {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GTlsCertificate

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.GTlsCertificate)(certificate.Native())

	ret := C.g_tls_database_create_certificate_handle(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// LookupCertificateForHandle: look up a certificate by its handle.
//
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a Database object of the
// same TLS backend. The handle is designed to remain valid across
// instantiations of the database.
//
// If the handle is no longer valid, or does not point to a certificate in
// this database, then nil will be returned.
//
// This function can block, use
// g_tls_database_lookup_certificate_for_handle_async() to perform the
// lookup operation asynchronously.
func (self tlsDatabase) LookupCertificateForHandle(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) TLSCertificate {
	var arg0 *C.GTlsDatabase
	var arg1 *C.gchar
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.gchar)(C.CString(handle))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_database_lookup_certificate_for_handle(arg0, arg1, arg2, arg3, arg4)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LookupCertificateForHandleAsync: asynchronously look up a certificate by
// its handle in the database. See
// g_tls_database_lookup_certificate_for_handle() for more information.
func (self tlsDatabase) LookupCertificateForHandleAsync(handle string, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsDatabase
	var arg1 *C.gchar
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.gchar)(C.CString(handle))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_database_lookup_certificate_for_handle_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// LookupCertificateIssuer: look up the issuer of @certificate in the
// database.
//
// The Certificate:issuer property of @certificate is not modified, and the
// two certificates are not hooked into a chain.
//
// This function can block, use
// g_tls_database_lookup_certificate_issuer_async() to perform the lookup
// operation asynchronously.
func (self tlsDatabase) LookupCertificateIssuer(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) TLSCertificate {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GTlsCertificate
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.GTlsCertificate)(certificate.Native())
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_database_lookup_certificate_issuer(arg0, arg1, arg2, arg3, arg4)

	var ret0 TLSCertificate

	ret0 = WrapTLSCertificate(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// LookupCertificateIssuerAsync: asynchronously look up the issuer of
// @certificate in the database. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (self tlsDatabase) LookupCertificateIssuerAsync(certificate TLSCertificate, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GTlsCertificate
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.GTlsCertificate)(certificate.Native())
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_database_lookup_certificate_issuer_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// LookupCertificatesIssuedBy: look up certificates issued by this issuer in
// the database.
//
// This function can block, use
// g_tls_database_lookup_certificates_issued_by_async() to perform the
// lookup operation asynchronously.
func (self tlsDatabase) LookupCertificatesIssuedBy(issuerRawDn []byte, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable) *glib.List {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GByteArray
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable

	arg0 = (*C.GTlsDatabase)(self.Native())
	{

	}
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_database_lookup_certificates_issued_by(arg0, arg1, arg2, arg3, arg4)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// LookupCertificatesIssuedByAsync: asynchronously look up certificates
// issued by this issuer in the database. See
// g_tls_database_lookup_certificates_issued_by() for more information.
//
// The database may choose to hold a reference to the issuer byte array for
// the duration of of this asynchronous operation. The byte array should not
// be modified during this time.
func (self tlsDatabase) LookupCertificatesIssuedByAsync(issuerRawDn []byte, interaction TLSInteraction, flags TLSDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GByteArray
	var arg2 *C.GTlsInteraction
	var arg3 C.GTlsDatabaseLookupFlags
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	arg6 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsDatabase)(self.Native())
	{

	}
	arg2 = (*C.GTlsInteraction)(interaction.Native())
	arg3 = (C.GTlsDatabaseLookupFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_database_lookup_certificates_issued_by_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// VerifyChain determines the validity of a certificate chain after looking
// up and adding any missing certificates to the chain.
//
// @chain is a chain of Certificate objects each pointing to the next
// certificate in the chain by its Certificate:issuer property. The chain
// may initially consist of one or more certificates. After the verification
// process is complete, @chain may be modified by adding missing
// certificates, or removing extra certificates. If a certificate anchor was
// found, then it is added to the @chain.
//
// @purpose describes the purpose (or usage) for which the certificate is
// being used. Typically @purpose will be set to
// TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER which means that the certificate
// is being used to authenticate a server (and we are acting as the client).
//
// The @identity is used to ensure the server certificate is valid for the
// expected peer identity. If the identity does not match the certificate,
// G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return value. If
// @identity is nil, that bit will never be set in the return value. The
// peer identity may also be used to check for pinned certificates (trust
// exceptions) in the database. These may override the normal verification
// process on a host-by-host basis.
//
// Currently there are no @flags, and G_TLS_DATABASE_VERIFY_NONE should be
// used.
//
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate the
// problems found. If the function is unable to determine whether @chain is
// valid or not (eg, because @cancellable is triggered before it completes)
// then the return value will be G_TLS_CERTIFICATE_GENERIC_ERROR and @error
// will be set accordingly. @error is not set when @chain is successfully
// analyzed but found to be invalid.
//
// This function can block, use g_tls_database_verify_chain_async() to
// perform the verification operation asynchronously.
func (self tlsDatabase) VerifyChain(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable) TLSCertificateFlags {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GTlsCertificate
	var arg2 *C.gchar
	var arg3 *C.GSocketConnectable
	var arg4 *C.GTlsInteraction
	var arg5 C.GTlsDatabaseVerifyFlags
	var arg6 *C.GCancellable

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.GTlsCertificate)(chain.Native())
	arg2 = (*C.gchar)(C.CString(purpose))
	defer C.free(unsafe.Pointer(arg2))
	arg4 = (*C.GTlsInteraction)(interaction.Native())
	arg5 = (C.GTlsDatabaseVerifyFlags)(flags)
	arg6 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_database_verify_chain(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 TLSCertificateFlags

	ret0 = TLSCertificateFlags(ret)

	return ret0
}

// VerifyChainAsync: asynchronously determines the validity of a certificate
// chain after looking up and adding any missing certificates to the chain.
// See g_tls_database_verify_chain() for more information.
func (self tlsDatabase) VerifyChainAsync(chain TLSCertificate, purpose string, identity SocketConnectable, interaction TLSInteraction, flags TLSDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsDatabase
	var arg1 *C.GTlsCertificate
	var arg2 *C.gchar
	var arg3 *C.GSocketConnectable
	var arg4 *C.GTlsInteraction
	var arg5 C.GTlsDatabaseVerifyFlags
	var arg6 *C.GCancellable
	var arg7 C.GAsyncReadyCallback
	arg8 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsDatabase)(self.Native())
	arg1 = (*C.GTlsCertificate)(chain.Native())
	arg2 = (*C.gchar)(C.CString(purpose))
	defer C.free(unsafe.Pointer(arg2))
	arg4 = (*C.GTlsInteraction)(interaction.Native())
	arg5 = (C.GTlsDatabaseVerifyFlags)(flags)
	arg6 = (*C.GCancellable)(cancellable.Native())
	arg7 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_database_verify_chain_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// TLSInteraction provides a mechanism for the TLS connection and database code
// to interact with the user. It can be used to ask the user for passwords.
//
// To use a Interaction with a TLS connection use
// g_tls_connection_set_interaction().
//
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
//
// Callers should use the 'invoke' functions like
// g_tls_interaction_invoke_ask_password() to run interaction methods. These
// functions make sure that the interaction is invoked in the main loop and not
// in the current thread, if the current thread is not running the main loop.
//
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TLSInteraction interface {
	gextras.Objector

	// AskPassword: run synchronous interaction to ask the user for a password.
	// In general, g_tls_interaction_invoke_ask_password() should be used
	// instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	AskPassword(password TLSPassword, cancellable Cancellable) TLSInteractionResult
	// AskPasswordAsync: run asynchronous interaction to ask the user for a
	// password. In general, g_tls_interaction_invoke_ask_password() should be
	// used instead of this function.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	//
	// Certain implementations may not support immediate cancellation.
	AskPasswordAsync(password TLSPassword, cancellable Cancellable, callback AsyncReadyCallback)
	// InvokeAskPassword: invoke the interaction to ask the user for a password.
	// It invokes this interaction in the main loop, specifically the Context
	// returned by g_main_context_get_thread_default() when the interaction is
	// created. This is called by called by Connection or Database to ask the
	// user for a password.
	//
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value
	// will be filled in and then @callback will be called. Alternatively the
	// user may abort this password request, which will usually abort the TLS
	// connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeAskPassword(password TLSPassword, cancellable Cancellable) TLSInteractionResult
	// InvokeRequestCertificate: invoke the interaction to ask the user to
	// choose a certificate to use with the connection. It invokes this
	// interaction in the main loop, specifically the Context returned by
	// g_main_context_get_thread_default() when the interaction is created. This
	// is called by called by Connection when the peer requests a certificate
	// during the handshake.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which may or
	// may not abort the TLS connection.
	//
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeRequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) TLSInteractionResult
	// RequestCertificate: run synchronous interaction to ask the user to choose
	// a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere.
	// Alternatively the user may abort this certificate request, which will
	// usually abort the TLS connection.
	//
	// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
	// g_tls_interaction_request_certificate() will have had its
	// Connection:certificate filled in.
	//
	// If the interaction is cancelled by the cancellation object, or by the
	// user then G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	RequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) TLSInteractionResult
	// RequestCertificateAsync: run asynchronous interaction to ask the user for
	// a certificate to use with the connection. In general,
	// g_tls_interaction_invoke_request_certificate() should be used instead of
	// this function.
	//
	// Derived subclasses usually implement a certificate selector, although
	// they may also choose to provide a certificate from elsewhere. @callback
	// will be called when the operation completes. Alternatively the user may
	// abort this certificate request, which will usually abort the TLS
	// connection.
	RequestCertificateAsync(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback)
}

// tlsInteraction implements the TLSInteraction interface.
type tlsInteraction struct {
	gextras.Objector
}

// WrapTLSInteraction wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSInteraction(obj *externglib.Object) TLSInteraction {
	return TLSInteraction{
		gextras.Objector: (obj),
	}
}

func marshalTLSInteraction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSInteraction(obj), nil
}

// AskPassword: run synchronous interaction to ask the user for a password.
// In general, g_tls_interaction_invoke_ask_password() should be used
// instead of this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value
// will be filled in and then @callback will be called. Alternatively the
// user may abort this password request, which will usually abort the TLS
// connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction tlsInteraction) AskPassword(password TLSPassword, cancellable Cancellable) TLSInteractionResult {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsPassword
	var arg2 *C.GCancellable

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsPassword)(password.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_interaction_ask_password(arg0, arg1, arg2)

	var ret0 TLSInteractionResult

	ret0 = TLSInteractionResult(ret)

	return ret0
}

// AskPasswordAsync: run asynchronous interaction to ask the user for a
// password. In general, g_tls_interaction_invoke_ask_password() should be
// used instead of this function.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value
// will be filled in and then @callback will be called. Alternatively the
// user may abort this password request, which will usually abort the TLS
// connection.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
//
// Certain implementations may not support immediate cancellation.
func (interaction tlsInteraction) AskPasswordAsync(password TLSPassword, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsPassword
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	arg4 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsPassword)(password.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_interaction_ask_password_async(arg0, arg1, arg2, arg3)
}

// InvokeAskPassword: invoke the interaction to ask the user for a password.
// It invokes this interaction in the main loop, specifically the Context
// returned by g_main_context_get_thread_default() when the interaction is
// created. This is called by called by Connection or Database to ask the
// user for a password.
//
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value
// will be filled in and then @callback will be called. Alternatively the
// user may abort this password request, which will usually abort the TLS
// connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction tlsInteraction) InvokeAskPassword(password TLSPassword, cancellable Cancellable) TLSInteractionResult {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsPassword
	var arg2 *C.GCancellable

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsPassword)(password.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_interaction_invoke_ask_password(arg0, arg1, arg2)

	var ret0 TLSInteractionResult

	ret0 = TLSInteractionResult(ret)

	return ret0
}

// InvokeRequestCertificate: invoke the interaction to ask the user to
// choose a certificate to use with the connection. It invokes this
// interaction in the main loop, specifically the Context returned by
// g_main_context_get_thread_default() when the interaction is created. This
// is called by called by Connection when the peer requests a certificate
// during the handshake.
//
// Derived subclasses usually implement a certificate selector, although
// they may also choose to provide a certificate from elsewhere.
// Alternatively the user may abort this certificate request, which may or
// may not abort the TLS connection.
//
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction tlsInteraction) InvokeRequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) TLSInteractionResult {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsConnection
	var arg2 C.GTlsCertificateRequestFlags
	var arg3 *C.GCancellable

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsConnection)(connection.Native())
	arg2 = (C.GTlsCertificateRequestFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_interaction_invoke_request_certificate(arg0, arg1, arg2, arg3)

	var ret0 TLSInteractionResult

	ret0 = TLSInteractionResult(ret)

	return ret0
}

// RequestCertificate: run synchronous interaction to ask the user to choose
// a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of
// this function.
//
// Derived subclasses usually implement a certificate selector, although
// they may also choose to provide a certificate from elsewhere.
// Alternatively the user may abort this certificate request, which will
// usually abort the TLS connection.
//
// If G_TLS_INTERACTION_HANDLED is returned, then the Connection passed to
// g_tls_interaction_request_certificate() will have had its
// Connection:certificate filled in.
//
// If the interaction is cancelled by the cancellation object, or by the
// user then G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction tlsInteraction) RequestCertificate(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable) TLSInteractionResult {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsConnection
	var arg2 C.GTlsCertificateRequestFlags
	var arg3 *C.GCancellable

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsConnection)(connection.Native())
	arg2 = (C.GTlsCertificateRequestFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_tls_interaction_request_certificate(arg0, arg1, arg2, arg3)

	var ret0 TLSInteractionResult

	ret0 = TLSInteractionResult(ret)

	return ret0
}

// RequestCertificateAsync: run asynchronous interaction to ask the user for
// a certificate to use with the connection. In general,
// g_tls_interaction_invoke_request_certificate() should be used instead of
// this function.
//
// Derived subclasses usually implement a certificate selector, although
// they may also choose to provide a certificate from elsewhere. @callback
// will be called when the operation completes. Alternatively the user may
// abort this certificate request, which will usually abort the TLS
// connection.
func (interaction tlsInteraction) RequestCertificateAsync(connection TLSConnection, flags TLSCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GTlsInteraction
	var arg1 *C.GTlsConnection
	var arg2 C.GTlsCertificateRequestFlags
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	arg5 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GTlsInteraction)(interaction.Native())
	arg1 = (*C.GTlsConnection)(connection.Native())
	arg2 = (C.GTlsCertificateRequestFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_tls_interaction_request_certificate_async(arg0, arg1, arg2, arg3, arg4)
}

// TLSPassword holds a password used in TLS.
type TLSPassword interface {
	gextras.Objector

	// Description: get a description string about what the password will be
	// used for.
	Description() string
	// Flags: get flags about the password.
	Flags() TLSPasswordFlags
	// Value: get the password value. If @length is not nil then it will be
	// filled in with the length of the password value. (Note that the password
	// value is not nul-terminated, so you can only pass nil for @length in
	// contexts where you know the password will have a certain fixed length.)
	Value(length uint) byte
	// Warning: get a user readable translated warning. Usually this warning is
	// a representation of the password flags returned from
	// g_tls_password_get_flags().
	Warning() string
	// SetDescription: set a description string about what the password will be
	// used for.
	SetDescription(description string)
	// SetFlags: set flags about the password.
	SetFlags(flags TLSPasswordFlags)
	// SetWarning: set a user readable translated warning. Usually this warning
	// is a representation of the password flags returned from
	// g_tls_password_get_flags().
	SetWarning(warning string)
}

// tlsPassword implements the TLSPassword interface.
type tlsPassword struct {
	gextras.Objector
}

// WrapTLSPassword wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSPassword(obj *externglib.Object) TLSPassword {
	return TLSPassword{
		gextras.Objector: (obj),
	}
}

func marshalTLSPassword(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSPassword(obj), nil
}

// NewTLSPassword constructs a class TLSPassword.
func NewTLSPassword(flags TLSPasswordFlags, description string) TLSPassword {
	var arg1 C.GTlsPasswordFlags
	var arg2 *C.gchar

	arg1 = (C.GTlsPasswordFlags)(flags)
	arg2 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_tls_password_new(arg1, arg2)

	var ret0 TLSPassword

	ret0 = WrapTLSPassword(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Description: get a description string about what the password will be
// used for.
func (password tlsPassword) Description() string {
	var arg0 *C.GTlsPassword

	arg0 = (*C.GTlsPassword)(password.Native())

	ret := C.g_tls_password_get_description(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags: get flags about the password.
func (password tlsPassword) Flags() TLSPasswordFlags {
	var arg0 *C.GTlsPassword

	arg0 = (*C.GTlsPassword)(password.Native())

	ret := C.g_tls_password_get_flags(arg0)

	var ret0 TLSPasswordFlags

	ret0 = TLSPasswordFlags(ret)

	return ret0
}

// Value: get the password value. If @length is not nil then it will be
// filled in with the length of the password value. (Note that the password
// value is not nul-terminated, so you can only pass nil for @length in
// contexts where you know the password will have a certain fixed length.)
func (password tlsPassword) Value(length uint) byte {
	var arg0 *C.GTlsPassword
	var arg1 *C.gsize

	arg0 = (*C.GTlsPassword)(password.Native())
	arg1 = (*C.gsize)(length)

	ret := C.g_tls_password_get_value(arg0, arg1)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// Warning: get a user readable translated warning. Usually this warning is
// a representation of the password flags returned from
// g_tls_password_get_flags().
func (password tlsPassword) Warning() string {
	var arg0 *C.GTlsPassword

	arg0 = (*C.GTlsPassword)(password.Native())

	ret := C.g_tls_password_get_warning(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SetDescription: set a description string about what the password will be
// used for.
func (password tlsPassword) SetDescription(description string) {
	var arg0 *C.GTlsPassword
	var arg1 *C.gchar

	arg0 = (*C.GTlsPassword)(password.Native())
	arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg1))

	C.g_tls_password_set_description(arg0, arg1)
}

// SetFlags: set flags about the password.
func (password tlsPassword) SetFlags(flags TLSPasswordFlags) {
	var arg0 *C.GTlsPassword
	var arg1 C.GTlsPasswordFlags

	arg0 = (*C.GTlsPassword)(password.Native())
	arg1 = (C.GTlsPasswordFlags)(flags)

	C.g_tls_password_set_flags(arg0, arg1)
}

// SetWarning: set a user readable translated warning. Usually this warning
// is a representation of the password flags returned from
// g_tls_password_get_flags().
func (password tlsPassword) SetWarning(warning string) {
	var arg0 *C.GTlsPassword
	var arg1 *C.gchar

	arg0 = (*C.GTlsPassword)(password.Native())
	arg1 = (*C.gchar)(C.CString(warning))
	defer C.free(unsafe.Pointer(arg1))

	C.g_tls_password_set_warning(arg0, arg1)
}

// UnixConnection: this is the subclass of Connection that is created for UNIX
// domain sockets.
//
// It contains functions to do some of the UNIX socket specific functionality
// like passing file descriptors.
//
// Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixConnection interface {
	SocketConnection

	// ReceiveCredentials receives credentials from the sending end of the
	// connection. The sending end has to call
	// g_unix_connection_send_credentials() (or similar) for this to work.
	//
	// As well as reading the credentials this also reads (and discards) a
	// single byte from the stream, as this is required for credentials passing
	// to work on some implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	ReceiveCredentials(cancellable Cancellable) Credentials
	// ReceiveCredentialsAsync: asynchronously receive credentials.
	//
	// For more details, see g_unix_connection_receive_credentials() which is
	// the synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_unix_connection_receive_credentials_finish() to get the result of
	// the operation.
	ReceiveCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// ReceiveFd receives a file descriptor from the sending end of the
	// connection. The sending end has to call g_unix_connection_send_fd() for
	// this to work.
	//
	// As well as reading the fd this also reads a single byte from the stream,
	// as this is required for fd passing to work on some implementations.
	ReceiveFd(cancellable Cancellable) int
	// SendCredentials passes the credentials of the current user the receiving
	// side of the connection. The receiving end has to call
	// g_unix_connection_receive_credentials() (or similar) to accept the
	// credentials.
	//
	// As well as sending the credentials this also writes a single NUL byte to
	// the stream, as this is required for credentials passing to work on some
	// implementations.
	//
	// This method can be expected to be available on the following platforms:
	//
	// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
	// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
	// since GLib 2.40
	//
	// Other ways to exchange credentials with a foreign peer includes the
	// CredentialsMessage type and g_socket_get_credentials() function.
	SendCredentials(cancellable Cancellable) bool
	// SendCredentialsAsync: asynchronously send credentials.
	//
	// For more details, see g_unix_connection_send_credentials() which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_unix_connection_send_credentials_finish() to get the result of the
	// operation.
	SendCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// SendFd passes a file descriptor to the receiving side of the connection.
	// The receiving end has to call g_unix_connection_receive_fd() to accept
	// the file descriptor.
	//
	// As well as sending the fd this also writes a single byte to the stream,
	// as this is required for fd passing to work on some implementations.
	SendFd(fd int, cancellable Cancellable) bool
}

// unixConnection implements the UnixConnection interface.
type unixConnection struct {
	SocketConnection
}

// WrapUnixConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixConnection(obj *externglib.Object) UnixConnection {
	return UnixConnection{
		SocketConnection: WrapSocketConnection(obj),
	}
}

func marshalUnixConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixConnection(obj), nil
}

// ReceiveCredentials receives credentials from the sending end of the
// connection. The sending end has to call
// g_unix_connection_send_credentials() (or similar) for this to work.
//
// As well as reading the credentials this also reads (and discards) a
// single byte from the stream, as this is required for credentials passing
// to work on some implementations.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
// since GLib 2.40
//
// Other ways to exchange credentials with a foreign peer includes the
// CredentialsMessage type and g_socket_get_credentials() function.
func (connection unixConnection) ReceiveCredentials(cancellable Cancellable) Credentials {
	var arg0 *C.GUnixConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_unix_connection_receive_credentials(arg0, arg1)

	var ret0 Credentials

	ret0 = WrapCredentials(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// ReceiveCredentialsAsync: asynchronously receive credentials.
//
// For more details, see g_unix_connection_receive_credentials() which is
// the synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_unix_connection_receive_credentials_finish() to get the result of
// the operation.
func (connection unixConnection) ReceiveCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GUnixConnection
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_unix_connection_receive_credentials_async(arg0, arg1, arg2)
}

// ReceiveFd receives a file descriptor from the sending end of the
// connection. The sending end has to call g_unix_connection_send_fd() for
// this to work.
//
// As well as reading the fd this also reads a single byte from the stream,
// as this is required for fd passing to work on some implementations.
func (connection unixConnection) ReceiveFd(cancellable Cancellable) int {
	var arg0 *C.GUnixConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_unix_connection_receive_fd(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SendCredentials passes the credentials of the current user the receiving
// side of the connection. The receiving end has to call
// g_unix_connection_receive_credentials() (or similar) to accept the
// credentials.
//
// As well as sending the credentials this also writes a single NUL byte to
// the stream, as this is required for credentials passing to work on some
// implementations.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26 - FreeBSD since GLib 2.26 - GNU/kFreeBSD since
// GLib 2.36 - Solaris, Illumos and OpenSolaris since GLib 2.40 - GNU/Hurd
// since GLib 2.40
//
// Other ways to exchange credentials with a foreign peer includes the
// CredentialsMessage type and g_socket_get_credentials() function.
func (connection unixConnection) SendCredentials(cancellable Cancellable) bool {
	var arg0 *C.GUnixConnection
	var arg1 *C.GCancellable

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_unix_connection_send_credentials(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// SendCredentialsAsync: asynchronously send credentials.
//
// For more details, see g_unix_connection_send_credentials() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_unix_connection_send_credentials_finish() to get the result of the
// operation.
func (connection unixConnection) SendCredentialsAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GUnixConnection
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	arg3 := C.gpointer(box.Assign(userData))

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)

	C.g_unix_connection_send_credentials_async(arg0, arg1, arg2)
}

// SendFd passes a file descriptor to the receiving side of the connection.
// The receiving end has to call g_unix_connection_receive_fd() to accept
// the file descriptor.
//
// As well as sending the fd this also writes a single byte to the stream,
// as this is required for fd passing to work on some implementations.
func (connection unixConnection) SendFd(fd int, cancellable Cancellable) bool {
	var arg0 *C.GUnixConnection
	var arg1 C.gint
	var arg2 *C.GCancellable

	arg0 = (*C.GUnixConnection)(connection.Native())
	arg1 = C.gint(fd)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_unix_connection_send_fd(arg0, arg1, arg2)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnixCredentialsMessage: this ControlMessage contains a #GCredentials
// instance. It may be sent using g_socket_send_message() and received using
// g_socket_receive_message() over UNIX sockets (ie: sockets in the
// G_SOCKET_FAMILY_UNIX family).
//
// For an easier way to send and receive credentials over stream-oriented UNIX
// sockets, see g_unix_connection_send_credentials() and
// g_unix_connection_receive_credentials(). To receive credentials of a foreign
// process connected to a socket, use g_socket_get_credentials().
type UnixCredentialsMessage interface {
	SocketControlMessage

	// Credentials gets the credentials stored in @message.
	Credentials() Credentials
}

// unixCredentialsMessage implements the UnixCredentialsMessage interface.
type unixCredentialsMessage struct {
	SocketControlMessage
}

// WrapUnixCredentialsMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixCredentialsMessage(obj *externglib.Object) UnixCredentialsMessage {
	return UnixCredentialsMessage{
		SocketControlMessage: WrapSocketControlMessage(obj),
	}
}

func marshalUnixCredentialsMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixCredentialsMessage(obj), nil
}

// NewUnixCredentialsMessage constructs a class UnixCredentialsMessage.
func NewUnixCredentialsMessage() UnixCredentialsMessage {

	ret := C.g_unix_credentials_message_new()

	var ret0 UnixCredentialsMessage

	ret0 = WrapUnixCredentialsMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewUnixCredentialsMessageWithCredentials constructs a class UnixCredentialsMessage.
func NewUnixCredentialsMessageWithCredentials(credentials Credentials) UnixCredentialsMessage {
	var arg1 *C.GCredentials

	arg1 = (*C.GCredentials)(credentials.Native())

	ret := C.g_unix_credentials_message_new_with_credentials(arg1)

	var ret0 UnixCredentialsMessage

	ret0 = WrapUnixCredentialsMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Credentials gets the credentials stored in @message.
func (message unixCredentialsMessage) Credentials() Credentials {
	var arg0 *C.GUnixCredentialsMessage

	arg0 = (*C.GUnixCredentialsMessage)(message.Native())

	ret := C.g_unix_credentials_message_get_credentials(arg0)

	var ret0 Credentials

	ret0 = WrapCredentials(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// UnixFDList: a FDList contains a list of file descriptors. It owns the file
// descriptors that it contains, closing them when finalized.
//
// It may be wrapped in a FDMessage and sent over a #GSocket in the
// G_SOCKET_FAMILY_UNIX family by using g_socket_send_message() and received
// using g_socket_receive_message().
//
// Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO interfaces,
// thus you have to use the `gio-unix-2.0.pc` pkg-config file when using it.
type UnixFDList interface {
	gextras.Objector

	// Append adds a file descriptor to @list.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @list will be closed when @list is
	// finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	//
	// The index of the file descriptor in the list is returned. If you use this
	// index with g_unix_fd_list_get() then you will receive back a duplicated
	// copy of the same file descriptor.
	Append(fd int) int
	// Get gets a file descriptor out of @list.
	//
	// @index_ specifies the index of the file descriptor to get. It is a
	// programmer error for @index_ to be out of range; see
	// g_unix_fd_list_get_length().
	//
	// The file descriptor is duplicated using dup() and set as close-on-exec
	// before being returned. You must call close() on it when you are done.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	Get(index_ int) int
	// Length gets the length of @list (ie: the number of file descriptors
	// contained within).
	Length() int
	// PeekFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors remain the property of @list. The caller
	// must not close them and must not free the array. The array is valid only
	// until @list is changed in any way.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @list, an empty array is returned.
	PeekFds() (length int, gints []int)
	// StealFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors are no longer contained in @list.
	// Further calls will return an empty list (unless more descriptors have
	// been added).
	//
	// The return result of this function must be freed with g_free(). The
	// caller is also responsible for closing all of the file descriptors. The
	// file descriptors in the array are set to close-on-exec.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @list, an empty array is returned.
	StealFds() (length int, gints []int)
}

// unixFDList implements the UnixFDList interface.
type unixFDList struct {
	gextras.Objector
}

// WrapUnixFDList wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDList(obj *externglib.Object) UnixFDList {
	return UnixFDList{
		gextras.Objector: (obj),
	}
}

func marshalUnixFDList(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDList(obj), nil
}

// NewUnixFDList constructs a class UnixFDList.
func NewUnixFDList() UnixFDList {

	ret := C.g_unix_fd_list_new()

	var ret0 UnixFDList

	ret0 = WrapUnixFDList(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// Append adds a file descriptor to @list.
//
// The file descriptor is duplicated using dup(). You keep your copy of the
// descriptor and the copy contained in @list will be closed when @list is
// finalized.
//
// A possible cause of failure is exceeding the per-process or system-wide
// file descriptor limit.
//
// The index of the file descriptor in the list is returned. If you use this
// index with g_unix_fd_list_get() then you will receive back a duplicated
// copy of the same file descriptor.
func (list unixFDList) Append(fd int) int {
	var arg0 *C.GUnixFDList
	var arg1 C.gint

	arg0 = (*C.GUnixFDList)(list.Native())
	arg1 = C.gint(fd)

	ret := C.g_unix_fd_list_append(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Get gets a file descriptor out of @list.
//
// @index_ specifies the index of the file descriptor to get. It is a
// programmer error for @index_ to be out of range; see
// g_unix_fd_list_get_length().
//
// The file descriptor is duplicated using dup() and set as close-on-exec
// before being returned. You must call close() on it when you are done.
//
// A possible cause of failure is exceeding the per-process or system-wide
// file descriptor limit.
func (list unixFDList) Get(index_ int) int {
	var arg0 *C.GUnixFDList
	var arg1 C.gint

	arg0 = (*C.GUnixFDList)(list.Native())
	arg1 = C.gint(index_)

	ret := C.g_unix_fd_list_get(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Length gets the length of @list (ie: the number of file descriptors
// contained within).
func (list unixFDList) Length() int {
	var arg0 *C.GUnixFDList

	arg0 = (*C.GUnixFDList)(list.Native())

	ret := C.g_unix_fd_list_get_length(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PeekFds returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors remain the property of @list. The caller
// must not close them and must not free the array. The array is valid only
// until @list is changed in any way.
//
// If @length is non-nil then it is set to the number of file descriptors in
// the returned array. The returned array is also terminated with -1.
//
// This function never returns nil. In case there are no file descriptors
// contained in @list, an empty array is returned.
func (list unixFDList) PeekFds() (length int, gints []int) {
	var arg0 *C.GUnixFDList
	var arg1 *C.gint // out

	arg0 = (*C.GUnixFDList)(list.Native())

	ret := C.g_unix_fd_list_peek_fds(arg0, &arg1)

	var ret0 int
	var ret1 []int

	ret0 = int(arg1)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg1
		sliceHeader.Cap = arg1
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// StealFds returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors are no longer contained in @list.
// Further calls will return an empty list (unless more descriptors have
// been added).
//
// The return result of this function must be freed with g_free(). The
// caller is also responsible for closing all of the file descriptors. The
// file descriptors in the array are set to close-on-exec.
//
// If @length is non-nil then it is set to the number of file descriptors in
// the returned array. The returned array is also terminated with -1.
//
// This function never returns nil. In case there are no file descriptors
// contained in @list, an empty array is returned.
func (list unixFDList) StealFds() (length int, gints []int) {
	var arg0 *C.GUnixFDList
	var arg1 *C.gint // out

	arg0 = (*C.GUnixFDList)(list.Native())

	ret := C.g_unix_fd_list_steal_fds(arg0, &arg1)

	var ret0 int
	var ret1 []int

	ret0 = int(arg1)

	{
		ret1 = make([]int, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = int(src)
		}
	}

	return ret0, ret1
}

// UnixFDMessage: this ControlMessage contains a FDList. It may be sent using
// g_socket_send_message() and received using g_socket_receive_message() over
// UNIX sockets (ie: sockets in the G_SOCKET_FAMILY_UNIX family). The file
// descriptors are copied between processes by the kernel.
//
// For an easier way to send and receive file descriptors over stream-oriented
// UNIX sockets, see g_unix_connection_send_fd() and
// g_unix_connection_receive_fd().
//
// Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixFDMessage interface {
	SocketControlMessage

	// AppendFd adds a file descriptor to @message.
	//
	// The file descriptor is duplicated using dup(). You keep your copy of the
	// descriptor and the copy contained in @message will be closed when
	// @message is finalized.
	//
	// A possible cause of failure is exceeding the per-process or system-wide
	// file descriptor limit.
	AppendFd(fd int) bool
	// FdList gets the FDList contained in @message. This function does not
	// return a reference to the caller, but the returned list is valid for the
	// lifetime of @message.
	FdList() UnixFDList
	// StealFds returns the array of file descriptors that is contained in this
	// object.
	//
	// After this call, the descriptors are no longer contained in @message.
	// Further calls will return an empty list (unless more descriptors have
	// been added).
	//
	// The return result of this function must be freed with g_free(). The
	// caller is also responsible for closing all of the file descriptors.
	//
	// If @length is non-nil then it is set to the number of file descriptors in
	// the returned array. The returned array is also terminated with -1.
	//
	// This function never returns nil. In case there are no file descriptors
	// contained in @message, an empty array is returned.
	StealFds() (length int, gints []int)
}

// unixFDMessage implements the UnixFDMessage interface.
type unixFDMessage struct {
	SocketControlMessage
}

// WrapUnixFDMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixFDMessage(obj *externglib.Object) UnixFDMessage {
	return UnixFDMessage{
		SocketControlMessage: WrapSocketControlMessage(obj),
	}
}

func marshalUnixFDMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixFDMessage(obj), nil
}

// NewUnixFDMessage constructs a class UnixFDMessage.
func NewUnixFDMessage() UnixFDMessage {

	ret := C.g_unix_fd_message_new()

	var ret0 UnixFDMessage

	ret0 = WrapUnixFDMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// NewUnixFDMessageWithFdList constructs a class UnixFDMessage.
func NewUnixFDMessageWithFdList(fdList UnixFDList) UnixFDMessage {
	var arg1 *C.GUnixFDList

	arg1 = (*C.GUnixFDList)(fdList.Native())

	ret := C.g_unix_fd_message_new_with_fd_list(arg1)

	var ret0 UnixFDMessage

	ret0 = WrapUnixFDMessage(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AppendFd adds a file descriptor to @message.
//
// The file descriptor is duplicated using dup(). You keep your copy of the
// descriptor and the copy contained in @message will be closed when
// @message is finalized.
//
// A possible cause of failure is exceeding the per-process or system-wide
// file descriptor limit.
func (message unixFDMessage) AppendFd(fd int) bool {
	var arg0 *C.GUnixFDMessage
	var arg1 C.gint

	arg0 = (*C.GUnixFDMessage)(message.Native())
	arg1 = C.gint(fd)

	ret := C.g_unix_fd_message_append_fd(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// FdList gets the FDList contained in @message. This function does not
// return a reference to the caller, but the returned list is valid for the
// lifetime of @message.
func (message unixFDMessage) FdList() UnixFDList {
	var arg0 *C.GUnixFDMessage

	arg0 = (*C.GUnixFDMessage)(message.Native())

	ret := C.g_unix_fd_message_get_fd_list(arg0)

	var ret0 UnixFDList

	ret0 = WrapUnixFDList(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// StealFds returns the array of file descriptors that is contained in this
// object.
//
// After this call, the descriptors are no longer contained in @message.
// Further calls will return an empty list (unless more descriptors have
// been added).
//
// The return result of this function must be freed with g_free(). The
// caller is also responsible for closing all of the file descriptors.
//
// If @length is non-nil then it is set to the number of file descriptors in
// the returned array. The returned array is also terminated with -1.
//
// This function never returns nil. In case there are no file descriptors
// contained in @message, an empty array is returned.
func (message unixFDMessage) StealFds() (length int, gints []int) {
	var arg0 *C.GUnixFDMessage
	var arg1 *C.gint // out

	arg0 = (*C.GUnixFDMessage)(message.Native())

	ret := C.g_unix_fd_message_steal_fds(arg0, &arg1)

	var ret0 int
	var ret1 []int

	ret0 = int(arg1)

	{
		ret1 = make([]int, arg1)
		for i := 0; i < uintptr(arg1); i++ {
			src := (C.gint)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = int(src)
		}
	}

	return ret0, ret1
}

// UnixInputStream implements Stream for reading from a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixInputStream interface {
	InputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream reads from.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

// unixInputStream implements the UnixInputStream interface.
type unixInputStream struct {
	InputStream
}

// WrapUnixInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixInputStream(obj *externglib.Object) UnixInputStream {
	return UnixInputStream{
		InputStream: WrapInputStream(obj),
	}
}

func marshalUnixInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixInputStream(obj), nil
}

// NewUnixInputStream constructs a class UnixInputStream.
func NewUnixInputStream(fd int, closeFd bool) UnixInputStream {
	var arg1 C.gint
	var arg2 C.gboolean

	arg1 = C.gint(fd)
	arg2 = gextras.Cbool(closeFd)

	ret := C.g_unix_input_stream_new(arg1, arg2)

	var ret0 UnixInputStream

	ret0 = WrapUnixInputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CloseFd returns whether the file descriptor of @stream will be closed
// when the stream is closed.
func (stream unixInputStream) CloseFd() bool {
	var arg0 *C.GUnixInputStream

	arg0 = (*C.GUnixInputStream)(stream.Native())

	ret := C.g_unix_input_stream_get_close_fd(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Fd: return the UNIX file descriptor that the stream reads from.
func (stream unixInputStream) Fd() int {
	var arg0 *C.GUnixInputStream

	arg0 = (*C.GUnixInputStream)(stream.Native())

	ret := C.g_unix_input_stream_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetCloseFd sets whether the file descriptor of @stream shall be closed
// when the stream is closed.
func (stream unixInputStream) SetCloseFd(closeFd bool) {
	var arg0 *C.GUnixInputStream
	var arg1 C.gboolean

	arg0 = (*C.GUnixInputStream)(stream.Native())
	arg1 = gextras.Cbool(closeFd)

	C.g_unix_input_stream_set_close_fd(arg0, arg1)
}

// UnixMountMonitor watches Mounts for changes.
type UnixMountMonitor interface {
	gextras.Objector

	// SetRateLimit: this function does nothing.
	//
	// Before 2.44, this was a partially-effective way of controlling the rate
	// at which events would be reported under some uncommon circumstances.
	// Since @mount_monitor is a singleton, it also meant that calling this
	// function would have side effects for other users of the monitor.
	SetRateLimit(limitMsec int)
}

// unixMountMonitor implements the UnixMountMonitor interface.
type unixMountMonitor struct {
	gextras.Objector
}

// WrapUnixMountMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixMountMonitor(obj *externglib.Object) UnixMountMonitor {
	return UnixMountMonitor{
		gextras.Objector: (obj),
	}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixMountMonitor(obj), nil
}

// NewUnixMountMonitor constructs a class UnixMountMonitor.
func NewUnixMountMonitor() UnixMountMonitor {

	ret := C.g_unix_mount_monitor_new()

	var ret0 UnixMountMonitor

	ret0 = WrapUnixMountMonitor(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetRateLimit: this function does nothing.
//
// Before 2.44, this was a partially-effective way of controlling the rate
// at which events would be reported under some uncommon circumstances.
// Since @mount_monitor is a singleton, it also meant that calling this
// function would have side effects for other users of the monitor.
func (mountMonitor unixMountMonitor) SetRateLimit(limitMsec int) {
	var arg0 *C.GUnixMountMonitor
	var arg1 C.int

	arg0 = (*C.GUnixMountMonitor)(mountMonitor.Native())
	arg1 = C.int(limitMsec)

	C.g_unix_mount_monitor_set_rate_limit(arg0, arg1)
}

// UnixOutputStream implements Stream for writing to a UNIX file descriptor,
// including asynchronous operations. (If the file descriptor refers to a socket
// or pipe, this will use poll() to do asynchronous I/O. If it refers to a
// regular file, it will fall back to doing asynchronous I/O in another thread.)
//
// Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixOutputStream interface {
	OutputStream

	// CloseFd returns whether the file descriptor of @stream will be closed
	// when the stream is closed.
	CloseFd() bool
	// Fd: return the UNIX file descriptor that the stream writes to.
	Fd() int
	// SetCloseFd sets whether the file descriptor of @stream shall be closed
	// when the stream is closed.
	SetCloseFd(closeFd bool)
}

// unixOutputStream implements the UnixOutputStream interface.
type unixOutputStream struct {
	OutputStream
}

// WrapUnixOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixOutputStream(obj *externglib.Object) UnixOutputStream {
	return UnixOutputStream{
		OutputStream: WrapOutputStream(obj),
	}
}

func marshalUnixOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixOutputStream(obj), nil
}

// NewUnixOutputStream constructs a class UnixOutputStream.
func NewUnixOutputStream(fd int, closeFd bool) UnixOutputStream {
	var arg1 C.gint
	var arg2 C.gboolean

	arg1 = C.gint(fd)
	arg2 = gextras.Cbool(closeFd)

	ret := C.g_unix_output_stream_new(arg1, arg2)

	var ret0 UnixOutputStream

	ret0 = WrapUnixOutputStream(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// CloseFd returns whether the file descriptor of @stream will be closed
// when the stream is closed.
func (stream unixOutputStream) CloseFd() bool {
	var arg0 *C.GUnixOutputStream

	arg0 = (*C.GUnixOutputStream)(stream.Native())

	ret := C.g_unix_output_stream_get_close_fd(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Fd: return the UNIX file descriptor that the stream writes to.
func (stream unixOutputStream) Fd() int {
	var arg0 *C.GUnixOutputStream

	arg0 = (*C.GUnixOutputStream)(stream.Native())

	ret := C.g_unix_output_stream_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SetCloseFd sets whether the file descriptor of @stream shall be closed
// when the stream is closed.
func (stream unixOutputStream) SetCloseFd(closeFd bool) {
	var arg0 *C.GUnixOutputStream
	var arg1 C.gboolean

	arg0 = (*C.GUnixOutputStream)(stream.Native())
	arg1 = gextras.Cbool(closeFd)

	C.g_unix_output_stream_set_close_fd(arg0, arg1)
}

// UnixSocketAddress: support for UNIX-domain (also known as local) sockets.
//
// UNIX domain sockets are generally visible in the filesystem. However, some
// systems support abstract socket names which are not visible in the filesystem
// and not affected by the filesystem permissions, visibility, etc. Currently
// this is only supported under Linux. If you attempt to use abstract sockets on
// other systems, function calls may return G_IO_ERROR_NOT_SUPPORTED errors. You
// can use g_unix_socket_address_abstract_names_supported() to see if abstract
// names are supported.
//
// Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
// interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file when
// using it.
type UnixSocketAddress interface {
	SocketAddress

	// AddressType gets @address's type.
	AddressType() UnixSocketAddressType
	// IsAbstract tests if @address is abstract.
	IsAbstract() bool
	// Path gets @address's path, or for abstract sockets the "name".
	//
	// Guaranteed to be zero-terminated, but an abstract socket may contain
	// embedded zeros, and thus you should use
	// g_unix_socket_address_get_path_len() to get the true length of this
	// string.
	Path() string
	// PathLen gets the length of @address's path.
	//
	// For details, see g_unix_socket_address_get_path().
	PathLen() uint
}

// unixSocketAddress implements the UnixSocketAddress interface.
type unixSocketAddress struct {
	SocketAddress
}

// WrapUnixSocketAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixSocketAddress(obj *externglib.Object) UnixSocketAddress {
	return UnixSocketAddress{
		SocketAddress: WrapSocketAddress(obj),
	}
}

func marshalUnixSocketAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixSocketAddress(obj), nil
}

// NewUnixSocketAddress constructs a class UnixSocketAddress.
func NewUnixSocketAddress(path string) UnixSocketAddress {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_socket_address_new(arg1)

	var ret0 UnixSocketAddress

	ret0 = WrapUnixSocketAddress(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// AddressType gets @address's type.
func (address unixSocketAddress) AddressType() UnixSocketAddressType {
	var arg0 *C.GUnixSocketAddress

	arg0 = (*C.GUnixSocketAddress)(address.Native())

	ret := C.g_unix_socket_address_get_address_type(arg0)

	var ret0 UnixSocketAddressType

	ret0 = UnixSocketAddressType(ret)

	return ret0
}

// IsAbstract tests if @address is abstract.
func (address unixSocketAddress) IsAbstract() bool {
	var arg0 *C.GUnixSocketAddress

	arg0 = (*C.GUnixSocketAddress)(address.Native())

	ret := C.g_unix_socket_address_get_is_abstract(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// Path gets @address's path, or for abstract sockets the "name".
//
// Guaranteed to be zero-terminated, but an abstract socket may contain
// embedded zeros, and thus you should use
// g_unix_socket_address_get_path_len() to get the true length of this
// string.
func (address unixSocketAddress) Path() string {
	var arg0 *C.GUnixSocketAddress

	arg0 = (*C.GUnixSocketAddress)(address.Native())

	ret := C.g_unix_socket_address_get_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PathLen gets the length of @address's path.
//
// For details, see g_unix_socket_address_get_path().
func (address unixSocketAddress) PathLen() uint {
	var arg0 *C.GUnixSocketAddress

	arg0 = (*C.GUnixSocketAddress)(address.Native())

	ret := C.g_unix_socket_address_get_path_len(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// Vfs: entry point for using GIO functionality.
type Vfs interface {
	gextras.Objector

	// SupportedURISchemes gets a list of URI schemes supported by @vfs.
	SupportedURISchemes() []string
	// IsActive checks if the VFS is active.
	IsActive() bool
	// RegisterURIScheme registers @uri_func and @parse_name_func as the #GFile
	// URI and parse name lookup functions for URIs with a scheme matching
	// @scheme. Note that @scheme is registered only within the running
	// application, as opposed to desktop-wide as it happens with GVfs backends.
	//
	// When a #GFile is requested with an URI containing @scheme (e.g. through
	// g_file_new_for_uri()), @uri_func will be called to allow a custom
	// constructor. The implementation of @uri_func should not be blocking, and
	// must not call g_vfs_register_uri_scheme() or
	// g_vfs_unregister_uri_scheme().
	//
	// When g_file_parse_name() is called with a parse name obtained from such
	// file, @parse_name_func will be called to allow the #GFile to be created
	// again. In that case, it's responsibility of @parse_name_func to make sure
	// the parse name matches what the custom #GFile implementation returned
	// when g_file_get_parse_name() was previously called. The implementation of
	// @parse_name_func should not be blocking, and must not call
	// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
	//
	// It's an error to call this function twice with the same scheme. To
	// unregister a custom URI scheme, use g_vfs_unregister_uri_scheme().
	RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool
	// UnregisterURIScheme unregisters the URI handler for @scheme previously
	// registered with g_vfs_register_uri_scheme().
	UnregisterURIScheme(scheme string) bool
}

// vfs implements the Vfs interface.
type vfs struct {
	gextras.Objector
}

// WrapVfs wraps a GObject to the right type. It is
// primarily used internally.
func WrapVfs(obj *externglib.Object) Vfs {
	return Vfs{
		gextras.Objector: (obj),
	}
}

func marshalVfs(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVfs(obj), nil
}

// SupportedURISchemes gets a list of URI schemes supported by @vfs.
func (vfs vfs) SupportedURISchemes() []string {
	var arg0 *C.GVfs

	arg0 = (*C.GVfs)(vfs.Native())

	ret := C.g_vfs_get_supported_uri_schemes(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (C.utf8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// IsActive checks if the VFS is active.
func (vfs vfs) IsActive() bool {
	var arg0 *C.GVfs

	arg0 = (*C.GVfs)(vfs.Native())

	ret := C.g_vfs_is_active(arg0)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// RegisterURIScheme registers @uri_func and @parse_name_func as the #GFile
// URI and parse name lookup functions for URIs with a scheme matching
// @scheme. Note that @scheme is registered only within the running
// application, as opposed to desktop-wide as it happens with GVfs backends.
//
// When a #GFile is requested with an URI containing @scheme (e.g. through
// g_file_new_for_uri()), @uri_func will be called to allow a custom
// constructor. The implementation of @uri_func should not be blocking, and
// must not call g_vfs_register_uri_scheme() or
// g_vfs_unregister_uri_scheme().
//
// When g_file_parse_name() is called with a parse name obtained from such
// file, @parse_name_func will be called to allow the #GFile to be created
// again. In that case, it's responsibility of @parse_name_func to make sure
// the parse name matches what the custom #GFile implementation returned
// when g_file_get_parse_name() was previously called. The implementation of
// @parse_name_func should not be blocking, and must not call
// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
//
// It's an error to call this function twice with the same scheme. To
// unregister a custom URI scheme, use g_vfs_unregister_uri_scheme().
func (vfs vfs) RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool {
	var arg0 *C.GVfs
	var arg1 *C.char
	var arg2 C.GVfsFileLookupFunc
	arg3 := C.gpointer(box.Assign(uriData))
	var arg5 C.GVfsFileLookupFunc
	arg6 := C.gpointer(box.Assign(parseNameData))

	arg0 = (*C.GVfs)(vfs.Native())
	arg1 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*[0]byte)(C.gotk4_VfsFileLookupFunc)
	arg5 = (*[0]byte)(C.gotk4_VfsFileLookupFunc)

	ret := C.g_vfs_register_uri_scheme(arg0, arg1, arg2, (*[0]byte)(C.callbackDelete), arg5, (*[0]byte)(C.callbackDelete))

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// UnregisterURIScheme unregisters the URI handler for @scheme previously
// registered with g_vfs_register_uri_scheme().
func (vfs vfs) UnregisterURIScheme(scheme string) bool {
	var arg0 *C.GVfs
	var arg1 *C.char

	arg0 = (*C.GVfs)(vfs.Native())
	arg1 = (*C.gchar)(C.CString(scheme))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_vfs_unregister_uri_scheme(arg0, arg1)

	var ret0 bool

	ret0 = gextras.Gobool(ret)

	return ret0
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor interface {
	gextras.Objector

	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	ConnectedDrives() *glib.List
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	Mounts() *glib.List
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	Volumes() *glib.List
}

// volumeMonitor implements the VolumeMonitor interface.
type volumeMonitor struct {
	gextras.Objector
}

// WrapVolumeMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapVolumeMonitor(obj *externglib.Object) VolumeMonitor {
	return VolumeMonitor{
		gextras.Objector: (obj),
	}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVolumeMonitor(obj), nil
}

// ConnectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements
// have been unreffed with g_object_unref().
func (volumeMonitor volumeMonitor) ConnectedDrives() *glib.List {
	var arg0 *C.GVolumeMonitor

	arg0 = (*C.GVolumeMonitor)(volumeMonitor.Native())

	ret := C.g_volume_monitor_get_connected_drives(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements
// have been unreffed with g_object_unref().
func (volumeMonitor volumeMonitor) Mounts() *glib.List {
	var arg0 *C.GVolumeMonitor

	arg0 = (*C.GVolumeMonitor)(volumeMonitor.Native())

	ret := C.g_volume_monitor_get_mounts(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements
// have been unreffed with g_object_unref().
func (volumeMonitor volumeMonitor) Volumes() *glib.List {
	var arg0 *C.GVolumeMonitor

	arg0 = (*C.GVolumeMonitor)(volumeMonitor.Native())

	ret := C.g_volume_monitor_get_volumes(arg0)

	var ret0 *glib.List

	ret0 = glib.WrapList(ret)

	return ret0
}

// ZlibCompressor: zlib decompression
type ZlibCompressor interface {
	gextras.Objector

	// FileInfo returns the Compressor:file-info property.
	FileInfo() FileInfo
	// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
	// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
	// used to set the file name and modification time in the GZIP header of the
	// compressed data.
	//
	// Note: it is an error to call this function while a compression is in
	// progress; it may only be called immediately after creation of
	// @compressor, or after resetting it with g_converter_reset().
	SetFileInfo(fileInfo FileInfo)
}

// zlibCompressor implements the ZlibCompressor interface.
type zlibCompressor struct {
	gextras.Objector
}

// WrapZlibCompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibCompressor(obj *externglib.Object) ZlibCompressor {
	return ZlibCompressor{
		gextras.Objector: (obj),
	}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibCompressor(obj), nil
}

// NewZlibCompressor constructs a class ZlibCompressor.
func NewZlibCompressor(format ZlibCompressorFormat, level int) ZlibCompressor {
	var arg1 C.GZlibCompressorFormat
	var arg2 C.int

	arg1 = (C.GZlibCompressorFormat)(format)
	arg2 = C.int(level)

	ret := C.g_zlib_compressor_new(arg1, arg2)

	var ret0 ZlibCompressor

	ret0 = WrapZlibCompressor(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// FileInfo returns the Compressor:file-info property.
func (compressor zlibCompressor) FileInfo() FileInfo {
	var arg0 *C.GZlibCompressor

	arg0 = (*C.GZlibCompressor)(compressor.Native())

	ret := C.g_zlib_compressor_get_file_info(arg0)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}

// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
// used to set the file name and modification time in the GZIP header of the
// compressed data.
//
// Note: it is an error to call this function while a compression is in
// progress; it may only be called immediately after creation of
// @compressor, or after resetting it with g_converter_reset().
func (compressor zlibCompressor) SetFileInfo(fileInfo FileInfo) {
	var arg0 *C.GZlibCompressor
	var arg1 *C.GFileInfo

	arg0 = (*C.GZlibCompressor)(compressor.Native())
	arg1 = (*C.GFileInfo)(fileInfo.Native())

	C.g_zlib_compressor_set_file_info(arg0, arg1)
}

// ZlibDecompressor: zlib decompression
type ZlibDecompressor interface {
	gextras.Objector

	// FileInfo retrieves the Info constructed from the GZIP header data of
	// compressed data processed by @compressor, or nil if @decompressor's
	// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
	// header data was not fully processed yet, or it not present in the data
	// stream at all.
	FileInfo() FileInfo
}

// zlibDecompressor implements the ZlibDecompressor interface.
type zlibDecompressor struct {
	gextras.Objector
}

// WrapZlibDecompressor wraps a GObject to the right type. It is
// primarily used internally.
func WrapZlibDecompressor(obj *externglib.Object) ZlibDecompressor {
	return ZlibDecompressor{
		gextras.Objector: (obj),
	}
}

func marshalZlibDecompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibDecompressor(obj), nil
}

// NewZlibDecompressor constructs a class ZlibDecompressor.
func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor {
	var arg1 C.GZlibCompressorFormat

	arg1 = (C.GZlibCompressorFormat)(format)

	ret := C.g_zlib_decompressor_new(arg1)

	var ret0 ZlibDecompressor

	ret0 = WrapZlibDecompressor(externglib.AssumeOwnership(unsafe.Pointer(ret.Native())))

	return ret0
}

// FileInfo retrieves the Info constructed from the GZIP header data of
// compressed data processed by @compressor, or nil if @decompressor's
// Decompressor:format property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP, or the
// header data was not fully processed yet, or it not present in the data
// stream at all.
func (decompressor zlibDecompressor) FileInfo() FileInfo {
	var arg0 *C.GZlibDecompressor

	arg0 = (*C.GZlibDecompressor)(decompressor.Native())

	ret := C.g_zlib_decompressor_get_file_info(arg0)

	var ret0 FileInfo

	ret0 = WrapFileInfo(externglib.Take(unsafe.Pointer(ret.Native())))

	return ret0
}
