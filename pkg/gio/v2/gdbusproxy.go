// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_dbus_proxy_get_type()), F: marshalDBusProxy},
	})
}

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c)
type DBusProxy interface {
	gextras.Objector
	AsyncInitable
	DBusInterface
	Initable

	// Call: asynchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is closed then the operation
	// will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
	// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
	// value not compatible with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_proxy_call (proxy,
	//                       "TwoStrings",
	//                       g_variant_new ("(ss)",
	//                                      "Thing One",
	//                                      "Thing Two"),
	//                       G_DBUS_CALL_FLAGS_NONE,
	//                       -1,
	//                       NULL,
	//                       (GAsyncReadyCallback) two_strings_done,
	//                       &data);
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call g_dbus_proxy_call_finish() to
	// get the result of the operation. See g_dbus_proxy_call_sync() for the
	// synchronous version of this method.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallFinish finishes an operation started with g_dbus_proxy_call().
	CallFinish(res AsyncResult) (variant *glib.Variant, err error)
	// CallSync: synchronously invokes the @method_name method on @proxy.
	//
	// If @method_name contains any dots, then @name is split into interface and
	// method name parts. This allows using @proxy for invoking methods on other
	// interfaces.
	//
	// If the BusConnection associated with @proxy is disconnected then the
	// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
	// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
	// contains a value not compatible with the D-Bus protocol, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_proxy_call_sync (proxy,
	//                            "TwoStrings",
	//                            g_variant_new ("(ss)",
	//                                           "Thing One",
	//                                           "Thing Two"),
	//                            G_DBUS_CALL_FLAGS_NONE,
	//                            -1,
	//                            NULL,
	//                            &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_proxy_call() for the asynchronous version of this method.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @method_name is referenced by it, then the return value is checked
	// against the return type.
	CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (variant *glib.Variant, err error)
	// CallWithUnixFdList: like g_dbus_proxy_call() but also takes a FDList
	// object.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_proxy_call_with_unix_fd_list().
	CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant, err error)
	// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
	// returns FDList objects.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant, err error)
	// CachedProperty looks up the value for a property from the cache. This
	// call does no blocking IO.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	CachedProperty(propertyName string) *glib.Variant
	// CachedPropertyNames gets the names of all cached properties on @proxy.
	CachedPropertyNames() []string
	// Connection gets the connection @proxy is for.
	Connection() DBusConnection
	// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
	// is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	DefaultTimeout() int
	// Flags gets the flags that @proxy was constructed with.
	Flags() DBusProxyFlags
	// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
	// interface that @proxy conforms to. See the BusProxy:g-interface-info
	// property for more details.
	InterfaceInfo() *DBusInterfaceInfo
	// InterfaceName gets the D-Bus interface name @proxy is for.
	InterfaceName() string
	// Name gets the name that @proxy was constructed for.
	Name() string
	// NameOwner: the unique name that owns the name that @proxy is for or nil
	// if no-one currently owns that name. You may connect to the
	// #GObject::notify signal to track changes to the BusProxy:g-name-owner
	// property.
	NameOwner() string
	// ObjectPath gets the object path @proxy is for.
	ObjectPath() string
	// SetCachedProperty: if @value is not nil, sets the cached value for the
	// property with name @property_name to the value in @value.
	//
	// If @value is nil, then the cached value is removed from the property
	// cache.
	//
	// If @proxy has an expected interface (see BusProxy:g-interface-info) and
	// @property_name is referenced by it, then @value is checked against the
	// type of the property.
	//
	// If the @value #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.
	//
	//    g_dbus_proxy_set_cached_property (proxy,
	//                                      "SomeProperty",
	//                                      g_variant_new ("(si)",
	//                                                    "A String",
	//                                                    42));
	//
	// Normally you will not need to use this method since @proxy is tracking
	// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
	// D-Bus signal. However, for performance reasons an object may decide to
	// not use this signal for some properties and instead use a proprietary
	// out-of-band mechanism to transmit changes.
	//
	// As a concrete example, consider an object with a property
	// `ChatroomParticipants` which is an array of strings. Instead of
	// transmitting the same (long) array every time the property changes, it is
	// more efficient to only transmit the delta using e.g. signals
	// `ChatroomParticipantJoined(String name)` and
	// `ChatroomParticipantParted(String name)`.
	SetCachedProperty(propertyName string, value *glib.Variant)
	// SetDefaultTimeout sets the timeout to use if -1 (specifying default
	// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
	// g_dbus_proxy_call_sync() functions.
	//
	// See the BusProxy:g-default-timeout property for more details.
	SetDefaultTimeout(timeoutMsec int)
	// SetInterfaceInfo: ensure that interactions with @proxy conform to the
	// given interface. See the BusProxy:g-interface-info property for more
	// details.
	SetInterfaceInfo(info *DBusInterfaceInfo)
}

// dBusProxy implements the DBusProxy interface.
type dBusProxy struct {
	gextras.Objector
	AsyncInitable
	DBusInterface
	Initable
}

var _ DBusProxy = (*dBusProxy)(nil)

// WrapDBusProxy wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusProxy(obj *externglib.Object) DBusProxy {
	return DBusProxy{
		Objector:      obj,
		AsyncInitable: WrapAsyncInitable(obj),
		DBusInterface: WrapDBusInterface(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusProxy(obj), nil
}

// NewDBusProxyFinish constructs a class DBusProxy.
func NewDBusProxyFinish(res AsyncResult) (dBusProxy DBusProxy, err error) {
	var arg1 *C.GAsyncResult
	var errout *C.GError

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var cret C.GDBusProxy
	var goret1 DBusProxy
	var goerr error

	cret = C.g_dbus_proxy_new_finish(res, &errout)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusProxy)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// NewDBusProxyForBusFinish constructs a class DBusProxy.
func NewDBusProxyForBusFinish(res AsyncResult) (dBusProxy DBusProxy, err error) {
	var arg1 *C.GAsyncResult
	var errout *C.GError

	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var cret C.GDBusProxy
	var goret1 DBusProxy
	var goerr error

	cret = C.g_dbus_proxy_new_for_bus_finish(res, &errout)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusProxy)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// NewDBusProxyForBusSync constructs a class DBusProxy.
func NewDBusProxyForBusSync(busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) (dBusProxy DBusProxy, err error) {
	var arg1 C.GBusType
	var arg2 C.GDBusProxyFlags
	var arg3 *C.GDBusInterfaceInfo
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 *C.GCancellable
	var errout *C.GError

	arg1 = (C.GBusType)(busType)
	arg2 = (C.GDBusProxyFlags)(flags)
	arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
	arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var cret C.GDBusProxy
	var goret1 DBusProxy
	var goerr error

	cret = C.g_dbus_proxy_new_for_bus_sync(busType, flags, info, name, objectPath, interfaceName, cancellable, &errout)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusProxy)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// NewDBusProxySync constructs a class DBusProxy.
func NewDBusProxySync(connection DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable Cancellable) (dBusProxy DBusProxy, err error) {
	var arg1 *C.GDBusConnection
	var arg2 C.GDBusProxyFlags
	var arg3 *C.GDBusInterfaceInfo
	var arg4 *C.gchar
	var arg5 *C.gchar
	var arg6 *C.gchar
	var arg7 *C.GCancellable
	var errout *C.GError

	arg1 = (*C.GDBusConnection)(unsafe.Pointer(connection.Native()))
	arg2 = (C.GDBusProxyFlags)(flags)
	arg3 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))
	arg4 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(arg6))
	arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var cret C.GDBusProxy
	var goret1 DBusProxy
	var goerr error

	cret = C.g_dbus_proxy_new_sync(connection, flags, info, name, objectPath, interfaceName, cancellable, &errout)

	goret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(DBusProxy)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// Call: asynchronously invokes the @method_name method on @proxy.
//
// If @method_name contains any dots, then @name is split into interface and
// method name parts. This allows using @proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with @proxy is closed then the operation
// will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled, the
// operation will fail with G_IO_ERROR_CANCELLED. If @parameters contains a
// value not compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_proxy_call (proxy,
//                       "TwoStrings",
//                       g_variant_new ("(ss)",
//                                      "Thing One",
//                                      "Thing Two"),
//                       G_DBUS_CALL_FLAGS_NONE,
//                       -1,
//                       NULL,
//                       (GAsyncReadyCallback) two_strings_done,
//                       &data);
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @method_name is referenced by it, then the return value is checked
// against the return type.
//
// This is an asynchronous method. When the operation is finished, @callback
// will be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are
// calling this method from. You can then call g_dbus_proxy_call_finish() to
// get the result of the operation. See g_dbus_proxy_call_sync() for the
// synchronous version of this method.
//
// If @callback is nil then the D-Bus method call message will be sent with
// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
func (p dBusProxy) Call(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	C.g_dbus_proxy_call(arg0, methodName, parameters, flags, timeoutMsec, cancellable, callback, userData)
}

// CallFinish finishes an operation started with g_dbus_proxy_call().
func (p dBusProxy) CallFinish(res AsyncResult) (variant *glib.Variant, err error) {
	var arg0 *C.GDBusProxy
	var arg1 *C.GAsyncResult
	var errout *C.GError

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var cret *C.GVariant
	var goret1 *glib.Variant
	var goerr error

	cret = C.g_dbus_proxy_call_finish(arg0, res, &errout)

	goret1 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// CallSync: synchronously invokes the @method_name method on @proxy.
//
// If @method_name contains any dots, then @name is split into interface and
// method name parts. This allows using @proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with @proxy is disconnected then the
// operation will fail with G_IO_ERROR_CLOSED. If @cancellable is canceled,
// the operation will fail with G_IO_ERROR_CANCELLED. If @parameters
// contains a value not compatible with the D-Bus protocol, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_proxy_call_sync (proxy,
//                            "TwoStrings",
//                            g_variant_new ("(ss)",
//                                           "Thing One",
//                                           "Thing Two"),
//                            G_DBUS_CALL_FLAGS_NONE,
//                            -1,
//                            NULL,
//                            &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_proxy_call() for the asynchronous version of this method.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @method_name is referenced by it, then the return value is checked
// against the return type.
func (p dBusProxy) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (variant *glib.Variant, err error) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GCancellable
	var errout *C.GError

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var cret *C.GVariant
	var goret1 *glib.Variant
	var goerr error

	cret = C.g_dbus_proxy_call_sync(arg0, methodName, parameters, flags, timeoutMsec, cancellable, &errout)

	goret1 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return goret1, goerr
}

// CallWithUnixFdList: like g_dbus_proxy_call() but also takes a FDList
// object.
//
// This method is only available on UNIX.
func (p dBusProxy) CallWithUnixFdList(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	C.g_dbus_proxy_call_with_unix_fd_list(arg0, methodName, parameters, flags, timeoutMsec, fdList, cancellable, callback, userData)
}

// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_proxy_call_with_unix_fd_list().
func (p dBusProxy) CallWithUnixFdListFinish(res AsyncResult) (outFdList UnixFDList, variant *glib.Variant, err error) {
	var arg0 *C.GDBusProxy
	var arg2 *C.GAsyncResult
	var errout *C.GError

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var arg1 **C.GUnixFDList
	var ret1 UnixFDList
	var cret *C.GVariant
	var goret2 *glib.Variant
	var goerr error

	cret = C.g_dbus_proxy_call_with_unix_fd_list_finish(arg0, &arg1, res, &errout)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native()))).(UnixFDList)
	goret2 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret2, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goret2, goerr
}

// CallWithUnixFdListSync: like g_dbus_proxy_call_sync() but also takes and
// returns FDList objects.
//
// This method is only available on UNIX.
func (p dBusProxy) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (outFdList UnixFDList, variant *glib.Variant, err error) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant
	var arg3 C.GDBusCallFlags
	var arg4 C.gint
	var arg5 *C.GUnixFDList
	var arg7 *C.GCancellable
	var errout *C.GError

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	arg3 = (C.GDBusCallFlags)(flags)
	arg4 = C.gint(timeoutMsec)
	arg5 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg6 **C.GUnixFDList
	var ret6 UnixFDList
	var cret *C.GVariant
	var goret2 *glib.Variant
	var goerr error

	cret = C.g_dbus_proxy_call_with_unix_fd_list_sync(arg0, methodName, parameters, flags, timeoutMsec, fdList, &arg6, cancellable, &errout)

	ret6 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg6.Native()))).(UnixFDList)
	goret2 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret2, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret6, goret2, goerr
}

// CachedProperty looks up the value for a property from the cache. This
// call does no blocking IO.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the
// type of the property.
func (p dBusProxy) CachedProperty(propertyName string) *glib.Variant {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GVariant
	var goret1 *glib.Variant

	cret = C.g_dbus_proxy_get_cached_property(arg0, propertyName)

	goret1 = glib.WrapVariant(unsafe.Pointer(cret))
	runtime.SetFinalizer(goret1, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goret1
}

// CachedPropertyNames gets the names of all cached properties on @proxy.
func (p dBusProxy) CachedPropertyNames() []string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret **C.gchar
	var goret1 []string

	cret = C.g_dbus_proxy_get_cached_property_names(arg0)

	{
		var length int
		for p := cret; *p != 0; p = (**C.gchar)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		goret1 = make([]string, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.gchar)(ptr.Add(unsafe.Pointer(cret), i))
			goret1[i] = C.GoString(src)
			defer C.free(unsafe.Pointer(src))
		}
	}

	return goret1
}

// Connection gets the connection @proxy is for.
func (p dBusProxy) Connection() DBusConnection {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.GDBusConnection
	var goret1 DBusConnection

	cret = C.g_dbus_proxy_get_connection(arg0)

	goret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(DBusConnection)

	return goret1
}

// DefaultTimeout gets the timeout to use if -1 (specifying default timeout)
// is passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
func (p dBusProxy) DefaultTimeout() int {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret C.gint
	var goret1 int

	cret = C.g_dbus_proxy_get_default_timeout(arg0)

	goret1 = C.gint(cret)

	return goret1
}

// Flags gets the flags that @proxy was constructed with.
func (p dBusProxy) Flags() DBusProxyFlags {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret C.GDBusProxyFlags
	var goret1 DBusProxyFlags

	cret = C.g_dbus_proxy_get_flags(arg0)

	goret1 = DBusProxyFlags(cret)

	return goret1
}

// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the
// interface that @proxy conforms to. See the BusProxy:g-interface-info
// property for more details.
func (p dBusProxy) InterfaceInfo() *DBusInterfaceInfo {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.GDBusInterfaceInfo
	var goret1 *DBusInterfaceInfo

	cret = C.g_dbus_proxy_get_interface_info(arg0)

	goret1 = WrapDBusInterfaceInfo(unsafe.Pointer(cret))

	return goret1
}

// InterfaceName gets the D-Bus interface name @proxy is for.
func (p dBusProxy) InterfaceName() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.g_dbus_proxy_get_interface_name(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// Name gets the name that @proxy was constructed for.
func (p dBusProxy) Name() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.g_dbus_proxy_get_name(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// NameOwner: the unique name that owns the name that @proxy is for or nil
// if no-one currently owns that name. You may connect to the
// #GObject::notify signal to track changes to the BusProxy:g-name-owner
// property.
func (p dBusProxy) NameOwner() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.g_dbus_proxy_get_name_owner(arg0)

	goret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return goret1
}

// ObjectPath gets the object path @proxy is for.
func (p dBusProxy) ObjectPath() string {
	var arg0 *C.GDBusProxy

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))

	var cret *C.gchar
	var goret1 string

	cret = C.g_dbus_proxy_get_object_path(arg0)

	goret1 = C.GoString(cret)

	return goret1
}

// SetCachedProperty: if @value is not nil, sets the cached value for the
// property with name @property_name to the value in @value.
//
// If @value is nil, then the cached value is removed from the property
// cache.
//
// If @proxy has an expected interface (see BusProxy:g-interface-info) and
// @property_name is referenced by it, then @value is checked against the
// type of the property.
//
// If the @value #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.
//
//    g_dbus_proxy_set_cached_property (proxy,
//                                      "SomeProperty",
//                                      g_variant_new ("(si)",
//                                                    "A String",
//                                                    42));
//
// Normally you will not need to use this method since @proxy is tracking
// changes using the `org.freedesktop.DBus.Properties.PropertiesChanged`
// D-Bus signal. However, for performance reasons an object may decide to
// not use this signal for some properties and instead use a proprietary
// out-of-band mechanism to transmit changes.
//
// As a concrete example, consider an object with a property
// `ChatroomParticipants` which is an array of strings. Instead of
// transmitting the same (long) array every time the property changes, it is
// more efficient to only transmit the delta using e.g. signals
// `ChatroomParticipantJoined(String name)` and
// `ChatroomParticipantParted(String name)`.
func (p dBusProxy) SetCachedProperty(propertyName string, value *glib.Variant) {
	var arg0 *C.GDBusProxy
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_proxy_set_cached_property(arg0, propertyName, value)
}

// SetDefaultTimeout sets the timeout to use if -1 (specifying default
// timeout) is passed as @timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
func (p dBusProxy) SetDefaultTimeout(timeoutMsec int) {
	var arg0 *C.GDBusProxy
	var arg1 C.gint

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = C.gint(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout(arg0, timeoutMsec)
}

// SetInterfaceInfo: ensure that interactions with @proxy conform to the
// given interface. See the BusProxy:g-interface-info property for more
// details.
func (p dBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo) {
	var arg0 *C.GDBusProxy
	var arg1 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusProxy)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(info.Native()))

	C.g_dbus_proxy_set_interface_info(arg0, info)
}

type DBusProxyPrivate struct {
	native C.GDBusProxyPrivate
}

// WrapDBusProxyPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusProxyPrivate(ptr unsafe.Pointer) *DBusProxyPrivate {
	if ptr == nil {
		return nil
	}

	return (*DBusProxyPrivate)(ptr)
}

func marshalDBusProxyPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusProxyPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusProxyPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}
