// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_tls_connection_get_type()), F: marshalTLSConnection},
	})
}

// TLSConnection is the base TLS connection class type, which wraps a OStream
// and provides TLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side TLS,
// respectively.
//
// For DTLS (Datagram TLS) support, see Connection.
type TLSConnection interface {
	IOStream

	// EmitAcceptCertificateTLSConnection:
	EmitAcceptCertificateTLSConnection(peerCert TLSCertificate, errors TLSCertificateFlags) bool
	// Certificate:
	Certificate() TLSCertificate
	// ChannelBindingData:
	ChannelBindingData(typ TLSChannelBindingType) ([]byte, error)
	// Database:
	Database() TLSDatabase
	// Interaction:
	Interaction() TLSInteraction
	// NegotiatedProtocol:
	NegotiatedProtocol() string
	// PeerCertificate:
	PeerCertificate() TLSCertificate
	// PeerCertificateErrors:
	PeerCertificateErrors() TLSCertificateFlags
	// RehandshakeMode:
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify:
	RequireCloseNotify() bool
	// UseSystemCertdb:
	UseSystemCertdb() bool
	// HandshakeTLSConnection:
	HandshakeTLSConnection(cancellable Cancellable) error
	// HandshakeFinishTLSConnection:
	HandshakeFinishTLSConnection(result AsyncResult) error
	// SetAdvertisedProtocolsTLSConnection:
	SetAdvertisedProtocolsTLSConnection(protocols []string)
	// SetCertificateTLSConnection:
	SetCertificateTLSConnection(certificate TLSCertificate)
	// SetDatabaseTLSConnection:
	SetDatabaseTLSConnection(database TLSDatabase)
	// SetInteractionTLSConnection:
	SetInteractionTLSConnection(interaction TLSInteraction)
	// SetRehandshakeModeTLSConnection:
	SetRehandshakeModeTLSConnection(mode TLSRehandshakeMode)
	// SetRequireCloseNotifyTLSConnection:
	SetRequireCloseNotifyTLSConnection(requireCloseNotify bool)
	// SetUseSystemCertdbTLSConnection:
	SetUseSystemCertdbTLSConnection(useSystemCertdb bool)
}

// tlsConnection implements the TLSConnection class.
type tlsConnection struct {
	IOStream
}

// WrapTLSConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTLSConnection(obj *externglib.Object) TLSConnection {
	return tlsConnection{
		IOStream: WrapIOStream(obj),
	}
}

func marshalTLSConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSConnection(obj), nil
}

func (c tlsConnection) EmitAcceptCertificateTLSConnection(peerCert TLSCertificate, errors TLSCertificateFlags) bool {
	var _arg0 *C.GTlsConnection      // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C.g_tls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) Certificate() TLSCertificate {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c tlsConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GTlsConnection        // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray
	var _cerr *C.GError // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.GTlsChannelBindingType(typ)

	C.g_tls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

	var _data []byte
	var _goerr error // out

	_data = make([]byte, _arg2.len)
	copy(_data, unsafe.Slice((*byte)(_arg2.data), _arg2.len))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _data, _goerr
}

func (c tlsConnection) Database() TLSDatabase {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.GTlsDatabase   // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_database(_arg0)

	var _tlsDatabase TLSDatabase // out

	_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

	return _tlsDatabase
}

func (c tlsConnection) Interaction() TLSInteraction {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_interaction(_arg0)

	var _tlsInteraction TLSInteraction // out

	_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

	return _tlsInteraction
}

func (c tlsConnection) NegotiatedProtocol() string {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.gchar          // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_negotiated_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c tlsConnection) PeerCertificate() TLSCertificate {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_peer_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c tlsConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GTlsConnection      // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_peer_certificate_errors(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c tlsConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GTlsConnection     // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_rehandshake_mode(_arg0)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

func (c tlsConnection) RequireCloseNotify() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_require_close_notify(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) UseSystemCertdb() bool {
	var _arg0 *C.GTlsConnection // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_tls_connection_get_use_system_certdb(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c tlsConnection) HandshakeTLSConnection(cancellable Cancellable) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_tls_connection_handshake(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c tlsConnection) HandshakeFinishTLSConnection(result AsyncResult) error {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GAsyncResult   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_tls_connection_handshake_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c tlsConnection) SetAdvertisedProtocolsTLSConnection(protocols []string) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 **C.gchar

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(protocols))
		for i := range protocols {
			out[i] = (*C.gchar)(C.CString(protocols[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_tls_connection_set_advertised_protocols(_arg0, _arg1)
}

func (c tlsConnection) SetCertificateTLSConnection(certificate TLSCertificate) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

	C.g_tls_connection_set_certificate(_arg0, _arg1)
}

func (c tlsConnection) SetDatabaseTLSConnection(database TLSDatabase) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GTlsDatabase   // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

	C.g_tls_connection_set_database(_arg0, _arg1)
}

func (c tlsConnection) SetInteractionTLSConnection(interaction TLSInteraction) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

	C.g_tls_connection_set_interaction(_arg0, _arg1)
}

func (c tlsConnection) SetRehandshakeModeTLSConnection(mode TLSRehandshakeMode) {
	var _arg0 *C.GTlsConnection     // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.GTlsRehandshakeMode(mode)

	C.g_tls_connection_set_rehandshake_mode(_arg0, _arg1)
}

func (c tlsConnection) SetRequireCloseNotifyTLSConnection(requireCloseNotify bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_require_close_notify(_arg0, _arg1)
}

func (c tlsConnection) SetUseSystemCertdbTLSConnection(useSystemCertdb bool) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(c.Native()))
	if useSystemCertdb {
		_arg1 = C.TRUE
	}

	C.g_tls_connection_set_use_system_certdb(_arg0, _arg1)
}
