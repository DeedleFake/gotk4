// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
//
// extern void callbackDelete(gpointer);
import "C"

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// IOSchedulerCancelAllJobs cancels all cancellable I/O jobs.
//
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
func IOSchedulerCancelAllJobs() {
	C.g_io_scheduler_cancel_all_jobs()
}

// IOSchedulerPushJob schedules the I/O job to run in another thread.
//
// @notify will be called on @user_data after @job_func has returned, regardless
// whether the job was cancelled or has run to completion.
//
// If @cancellable is not nil, it can be used to cancel the I/O job by calling
// g_cancellable_cancel() or by calling g_io_scheduler_cancel_all_jobs().
func IOSchedulerPushJob(jobFunc IOSchedulerJobFunc, ioPriority int, cancellable Cancellable) {
	var arg1 C.GIOSchedulerJobFunc
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify
	var arg4 C.gint
	var arg5 *C.GCancellable

	arg1 = (*[0]byte)(C.gotk4_IOSchedulerJobFunc)
	arg2 = C.gpointer(box.Assign(jobFunc))
	arg3 = (*[0]byte)(C.callbackDelete)
	arg4 = C.gint(ioPriority)
	arg5 = (*C.GCancellable)(cancellable.Native())

	C.g_io_scheduler_push_job(arg1, arg2, arg3, arg4, arg5)
}
