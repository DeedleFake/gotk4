// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
	})
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which don’t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	gextras.Objector
	DatagramBased
	Initable

	// AvailableBytes: get the amount of data pending in the OS input buffer,
	// without blocking.
	//
	// If @socket is a UDP or SCTP socket, this will return the size of just the
	// next packet, even if additional packets are buffered after that one.
	//
	// Note that on Windows, this function is rather inefficient in the UDP
	// case, and so if you know any plausible upper bound on the size of the
	// incoming packet, it is better to just do a g_socket_receive() with a
	// buffer of that size, rather than calling g_socket_get_available_bytes()
	// first and then doing a receive of exactly the right size.
	AvailableBytes() int
	// Blocking gets the blocking mode of the socket. For details on blocking
	// I/O, see g_socket_set_blocking().
	Blocking() bool
	// Broadcast gets the broadcast setting on @socket; if true, it is possible
	// to send packets to broadcast addresses.
	Broadcast() bool
	// Fd returns the underlying OS socket object. On unix this is a socket file
	// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
	// useful for doing platform specific or otherwise unusual operations on the
	// socket.
	Fd() int
	// Keepalive gets the keepalive mode of the socket. For details on this, see
	// g_socket_set_keepalive().
	Keepalive() bool
	// ListenBacklog gets the listen backlog setting of the socket. For details
	// on this, see g_socket_set_listen_backlog().
	ListenBacklog() int
	// MulticastLoopback gets the multicast loopback setting on @socket; if true
	// (the default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	MulticastLoopback() bool
	// MulticastTtl gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	MulticastTtl() uint
	// Timeout gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	Timeout() uint
	// Ttl gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	Ttl() uint
	// IsClosed checks whether a socket is closed.
	IsClosed() bool
	// IsConnected: check whether the socket is connected. This is only useful
	// for connection-oriented sockets.
	//
	// If using g_socket_shutdown(), this function will return true until the
	// socket has been shut down for reading and writing. If you do a
	// non-blocking connect, this function will not return true until after you
	// call g_socket_check_connect_result().
	IsConnected() bool
	// SetBlocking sets the blocking mode of the socket. In blocking mode all
	// operations (which don’t take an explicit blocking parameter) block until
	// they succeed or there is an error. In non-blocking mode all functions
	// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
	//
	// All sockets are created in blocking mode. However, note that the platform
	// level socket is always non-blocking, and blocking mode is a GSocket level
	// feature.
	SetBlocking(blocking bool)
	// SetBroadcast sets whether @socket should allow sending to broadcast
	// addresses. This is false by default.
	SetBroadcast(broadcast bool)
	// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
	// socket. When this flag is set on a socket, the system will attempt to
	// verify that the remote socket endpoint is still present if a sufficiently
	// long period of time passes with no data being exchanged. If the system is
	// unable to verify the presence of the remote endpoint, it will
	// automatically close the connection.
	//
	// This option is only functional on certain kinds of sockets. (Notably,
	// G_SOCKET_PROTOCOL_TCP sockets.)
	//
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag on
	// a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(keepalive bool)
	// SetListenBacklog sets the maximum number of outstanding connections
	// allowed when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them on time
	// then the new connections will be refused.
	//
	// Note that this must be called before g_socket_listen() and has no effect
	// if called after that.
	SetListenBacklog(backlog int)
	// SetMulticastLoopback sets whether outgoing multicast packets will be
	// received by sockets listening on that multicast address on the same host.
	// This is true by default.
	SetMulticastLoopback(loopback bool)
	// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
	// @socket. By default, this is 1, meaning that multicast packets will not
	// leave the local network.
	SetMulticastTtl(ttl uint)
	// SetTimeout sets the time in seconds after which I/O operations on @socket
	// will time out if they have not yet completed.
	//
	// On a blocking socket, this means that any blocking #GSocket operation
	// will time out after @timeout seconds of inactivity, returning
	// G_IO_ERROR_TIMED_OUT.
	//
	// On a non-blocking socket, calls to g_socket_condition_wait() will also
	// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
	// g_socket_create_source() will trigger after @timeout seconds of
	// inactivity, with the requested condition set, at which point calling
	// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
	// etc, will fail with G_IO_ERROR_TIMED_OUT.
	//
	// If @timeout is 0 (the default), operations will never time out on their
	// own.
	//
	// Note that if an I/O operation is interrupted by a signal, this may cause
	// the timeout to be reset.
	SetTimeout(timeout uint)
	// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
	// default the platform-specific default value is used.
	SetTtl(ttl uint)
	// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
	//
	// IPv4 sockets are capable of speaking IPv4. On some operating systems and
	// under some combinations of circumstances IPv6 sockets are also capable of
	// speaking IPv4. See RFC 3493 section 3.7 for more information.
	//
	// No other types of sockets are currently considered as being capable of
	// speaking IPv4.
	SpeaksIpv4() bool
}

// socket implements the Socket class.
type socket struct {
	gextras.Objector
	DatagramBased
	Initable
}

var _ Socket = (*socket)(nil)

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{
		Objector:      obj,
		DatagramBased: WrapDatagramBased(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If @socket is a UDP or SCTP socket, this will return the size of just the
// next packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP
// case, and so if you know any plausible upper bound on the size of the
// incoming packet, it is better to just do a g_socket_receive() with a
// buffer of that size, rather than calling g_socket_get_available_bytes()
// first and then doing a receive of exactly the right size.
func (s socket) AvailableBytes() int {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gssize // in

	_cret = C.g_socket_get_available_bytes(_arg0)

	var _gssize int // out

	_gssize = (int)(_cret)

	return _gssize
}

// Blocking gets the blocking mode of the socket. For details on blocking
// I/O, see g_socket_set_blocking().
func (s socket) Blocking() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_get_blocking(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Broadcast gets the broadcast setting on @socket; if true, it is possible
// to send packets to broadcast addresses.
func (s socket) Broadcast() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_get_broadcast(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
func (s socket) Fd() int {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.int // in

	_cret = C.g_socket_get_fd(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Keepalive gets the keepalive mode of the socket. For details on this, see
// g_socket_set_keepalive().
func (s socket) Keepalive() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_get_keepalive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListenBacklog gets the listen backlog setting of the socket. For details
// on this, see g_socket_set_listen_backlog().
func (s socket) ListenBacklog() int {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gint // in

	_cret = C.g_socket_get_listen_backlog(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// MulticastLoopback gets the multicast loopback setting on @socket; if true
// (the default), outgoing multicast packets will be looped back to
// multicast listeners on the same host.
func (s socket) MulticastLoopback() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_get_multicast_loopback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MulticastTtl gets the multicast time-to-live setting on @socket; see
// g_socket_set_multicast_ttl() for more details.
func (s socket) MulticastTtl() uint {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.guint // in

	_cret = C.g_socket_get_multicast_ttl(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
func (s socket) Timeout() uint {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.guint // in

	_cret = C.g_socket_get_timeout(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Ttl gets the unicast time-to-live setting on @socket; see
// g_socket_set_ttl() for more details.
func (s socket) Ttl() uint {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.guint // in

	_cret = C.g_socket_get_ttl(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsClosed checks whether a socket is closed.
func (s socket) IsClosed() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsConnected: check whether the socket is connected. This is only useful
// for connection-oriented sockets.
//
// If using g_socket_shutdown(), this function will return true until the
// socket has been shut down for reading and writing. If you do a
// non-blocking connect, this function will not return true until after you
// call g_socket_check_connect_result().
func (s socket) IsConnected() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_is_connected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which don’t take an explicit blocking parameter) block until
// they succeed or there is an error. In non-blocking mode all functions
// return results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
//
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
func (s socket) SetBlocking(blocking bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if blocking {
		_arg1 = C.TRUE
	}

	C.g_socket_set_blocking(_arg0, _arg1)
}

// SetBroadcast sets whether @socket should allow sending to broadcast
// addresses. This is false by default.
func (s socket) SetBroadcast(broadcast bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if broadcast {
		_arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(_arg0, _arg1)
}

// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying
// socket. When this flag is set on a socket, the system will attempt to
// verify that the remote socket endpoint is still present if a sufficiently
// long period of time passes with no data being exchanged. If the system is
// unable to verify the presence of the remote endpoint, it will
// automatically close the connection.
//
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
//
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag on
// a server socket if you want to allow clients to remain idle for long
// periods of time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
func (s socket) SetKeepalive(keepalive bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if keepalive {
		_arg1 = C.TRUE
	}

	C.g_socket_set_keepalive(_arg0, _arg1)
}

// SetListenBacklog sets the maximum number of outstanding connections
// allowed when listening on this socket. If more clients than this are
// connecting to the socket and the application is not handling them on time
// then the new connections will be refused.
//
// Note that this must be called before g_socket_listen() and has no effect
// if called after that.
func (s socket) SetListenBacklog(backlog int) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(_arg0, _arg1)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be
// received by sockets listening on that multicast address on the same host.
// This is true by default.
func (s socket) SetMulticastLoopback(loopback bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if loopback {
		_arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(_arg0, _arg1)
}

// SetMulticastTtl sets the time-to-live for outgoing multicast datagrams on
// @socket. By default, this is 1, meaning that multicast packets will not
// leave the local network.
func (s socket) SetMulticastTtl(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(_arg0, _arg1)
}

// SetTimeout sets the time in seconds after which I/O operations on @socket
// will time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation
// will time out after @timeout seconds of inactivity, returning
// G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also
// fail with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after @timeout seconds of
// inactivity, with the requested condition set, at which point calling
// g_socket_receive(), g_socket_send(), g_socket_check_connect_result(),
// etc, will fail with G_IO_ERROR_TIMED_OUT.
//
// If @timeout is 0 (the default), operations will never time out on their
// own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause
// the timeout to be reset.
func (s socket) SetTimeout(timeout uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_set_timeout(_arg0, _arg1)
}

// SetTtl sets the time-to-live for outgoing unicast packets on @socket. By
// default the platform-specific default value is used.
func (s socket) SetTtl(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_ttl(_arg0, _arg1)
}

// SpeaksIpv4 checks if a socket is capable of speaking IPv4.
//
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
//
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
func (s socket) SpeaksIpv4() bool {
	var _arg0 *C.GSocket // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_socket_speaks_ipv4(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
