// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_get_type()), F: marshalSocket},
	})
}

// Socket: a #GSocket is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API. It
// supports both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return nil.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which donâ€™t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket interface {
	DatagramBased
	Initable

	AcceptSocket(cancellable Cancellable) (Socket, error)

	BindSocket(address SocketAddress, allowReuse bool) error

	CheckConnectResultSocket() error

	CloseSocket() error

	ConditionCheckSocket(condition glib.IOCondition) glib.IOCondition

	ConditionTimedWaitSocket(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error

	ConditionWaitSocket(condition glib.IOCondition, cancellable Cancellable) error

	ConnectSocket(address SocketAddress, cancellable Cancellable) error

	ConnectionFactoryCreateConnectionSocket() SocketConnection

	AvailableBytes() int

	Blocking() bool

	Broadcast() bool

	Credentials() (Credentials, error)

	Family() SocketFamily

	Fd() int

	Keepalive() bool

	ListenBacklog() int

	LocalAddress() (SocketAddress, error)

	MulticastLoopback() bool

	MulticastTTL() uint

	Option(level int, optname int) (int, error)

	Protocol() SocketProtocol

	RemoteAddress() (SocketAddress, error)

	SocketType() SocketType

	Timeout() uint

	TTL() uint

	IsClosedSocket() bool

	IsConnectedSocket() bool

	JoinMulticastGroupSocket(group InetAddress, sourceSpecific bool, iface string) error

	JoinMulticastGroupSSMSocket(group InetAddress, sourceSpecific InetAddress, iface string) error

	LeaveMulticastGroupSocket(group InetAddress, sourceSpecific bool, iface string) error

	LeaveMulticastGroupSSMSocket(group InetAddress, sourceSpecific InetAddress, iface string) error

	ListenSocket() error

	ReceiveMessagesSocket(messages []InputMessage, flags int, cancellable Cancellable) (int, error)

	SendSocket(buffer []byte, cancellable Cancellable) (int, error)

	SendMessageSocket(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (int, error)

	SendMessageWithTimeoutSocket(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error)

	SendMessagesSocket(messages []OutputMessage, flags int, cancellable Cancellable) (int, error)

	SendToSocket(address SocketAddress, buffer []byte, cancellable Cancellable) (int, error)

	SendWithBlockingSocket(buffer []byte, blocking bool, cancellable Cancellable) (int, error)

	SetBlockingSocket(blocking bool)

	SetBroadcastSocket(broadcast bool)

	SetKeepaliveSocket(keepalive bool)

	SetListenBacklogSocket(backlog int)

	SetMulticastLoopbackSocket(loopback bool)

	SetMulticastTTLSocket(ttl uint)

	SetOptionSocket(level int, optname int, value int) error

	SetTimeoutSocket(timeout uint)

	SetTTLSocket(ttl uint)

	ShutdownSocket(shutdownRead bool, shutdownWrite bool) error

	SpeaksIPv4Socket() bool
}

// socket implements the Socket class.
type socket struct {
	gextras.Objector
}

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{
		Objector: obj,
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (Socket, error) {
	var _arg1 C.GSocketFamily   // out
	var _arg2 C.GSocketType     // out
	var _arg3 C.GSocketProtocol // out
	var _cret *C.GSocket        // in
	var _cerr *C.GError         // in

	_arg1 = C.GSocketFamily(family)
	_arg2 = C.GSocketType(typ)
	_arg3 = C.GSocketProtocol(protocol)

	_cret = C.g_socket_new(_arg1, _arg2, _arg3, &_cerr)

	var _socket Socket // out
	var _goerr error   // out

	_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socket, _goerr
}

func NewSocketFromFd(fd int) (Socket, error) {
	var _arg1 C.gint     // out
	var _cret *C.GSocket // in
	var _cerr *C.GError  // in

	_arg1 = C.gint(fd)

	_cret = C.g_socket_new_from_fd(_arg1, &_cerr)

	var _socket Socket // out
	var _goerr error   // out

	_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socket, _goerr
}

func (s socket) AcceptSocket(cancellable Cancellable) (Socket, error) {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GCancellable // out
	var _cret *C.GSocket      // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_accept(_arg0, _arg1, &_cerr)

	var _ret Socket  // out
	var _goerr error // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _ret, _goerr
}

func (s socket) BindSocket(address SocketAddress, allowReuse bool) error {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 C.gboolean        // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	if allowReuse {
		_arg2 = C.TRUE
	}

	C.g_socket_bind(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) CheckConnectResultSocket() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_check_connect_result(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) CloseSocket() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_close(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConditionCheckSocket(condition glib.IOCondition) glib.IOCondition {
	var _arg0 *C.GSocket     // out
	var _arg1 C.GIOCondition // out
	var _cret C.GIOCondition // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.GIOCondition(condition)

	_cret = C.g_socket_condition_check(_arg0, _arg1)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(_cret)

	return _ioCondition
}

func (s socket) ConditionTimedWaitSocket(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) error {
	var _arg0 *C.GSocket      // out
	var _arg1 C.GIOCondition  // out
	var _arg2 C.gint64        // out
	var _arg3 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.GIOCondition(condition)
	_arg2 = C.gint64(timeoutUs)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_condition_timed_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConditionWaitSocket(condition glib.IOCondition, cancellable Cancellable) error {
	var _arg0 *C.GSocket      // out
	var _arg1 C.GIOCondition  // out
	var _arg2 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.GIOCondition(condition)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_condition_wait(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConnectSocket(address SocketAddress, cancellable Cancellable) error {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GCancellable   // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_socket_connect(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ConnectionFactoryCreateConnectionSocket() SocketConnection {
	var _arg0 *C.GSocket           // out
	var _cret *C.GSocketConnection // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_connection_factory_create_connection(_arg0)

	var _socketConnection SocketConnection // out

	_socketConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketConnection)

	return _socketConnection
}

func (s socket) AvailableBytes() int {
	var _arg0 *C.GSocket // out
	var _cret C.gssize   // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_available_bytes(_arg0)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

func (s socket) Blocking() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_blocking(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) Broadcast() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_broadcast(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) Credentials() (Credentials, error) {
	var _arg0 *C.GSocket      // out
	var _cret *C.GCredentials // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_credentials(_arg0, &_cerr)

	var _credentials Credentials // out
	var _goerr error             // out

	_credentials = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Credentials)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _credentials, _goerr
}

func (s socket) Family() SocketFamily {
	var _arg0 *C.GSocket      // out
	var _cret C.GSocketFamily // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_family(_arg0)

	var _socketFamily SocketFamily // out

	_socketFamily = SocketFamily(_cret)

	return _socketFamily
}

func (s socket) Fd() int {
	var _arg0 *C.GSocket // out
	var _cret C.int      // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_fd(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s socket) Keepalive() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_keepalive(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) ListenBacklog() int {
	var _arg0 *C.GSocket // out
	var _cret C.gint     // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_listen_backlog(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s socket) LocalAddress() (SocketAddress, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_local_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (s socket) MulticastLoopback() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_multicast_loopback(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) MulticastTTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_multicast_ttl(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (s socket) Option(level int, optname int) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(level)
	_arg2 = C.gint(optname)

	C.g_socket_get_option(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _value int   // out
	var _goerr error // out

	_value = int(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (s socket) Protocol() SocketProtocol {
	var _arg0 *C.GSocket        // out
	var _cret C.GSocketProtocol // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_protocol(_arg0)

	var _socketProtocol SocketProtocol // out

	_socketProtocol = SocketProtocol(_cret)

	return _socketProtocol
}

func (s socket) RemoteAddress() (SocketAddress, error) {
	var _arg0 *C.GSocket        // out
	var _cret *C.GSocketAddress // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_remote_address(_arg0, &_cerr)

	var _socketAddress SocketAddress // out
	var _goerr error                 // out

	_socketAddress = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketAddress)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _socketAddress, _goerr
}

func (s socket) SocketType() SocketType {
	var _arg0 *C.GSocket    // out
	var _cret C.GSocketType // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_socket_type(_arg0)

	var _socketType SocketType // out

	_socketType = SocketType(_cret)

	return _socketType
}

func (s socket) Timeout() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_timeout(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (s socket) TTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_get_ttl(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (s socket) IsClosedSocket() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) IsConnectedSocket() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_is_connected(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socket) JoinMulticastGroupSocket(group InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_join_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) JoinMulticastGroupSSMSocket(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_join_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) LeaveMulticastGroupSocket(group InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_leave_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) LeaveMulticastGroupSSMSocket(group InetAddress, sourceSpecific InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(group.Native()))
	_arg2 = (*C.GInetAddress)(unsafe.Pointer(sourceSpecific.Native()))
	_arg3 = (*C.gchar)(C.CString(iface))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_socket_leave_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ListenSocket() error {
	var _arg0 *C.GSocket // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	C.g_socket_listen(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) ReceiveMessagesSocket(messages []InputMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.GInputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GInputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = C.gint(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (s socket) SendSocket(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendMessageSocket(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage
	var _arg5 C.gint
	var _arg6 C.gint          // out
	var _arg7 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gint(len(vectors))
	_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg5 = C.gint(len(messages))
	_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(messages))
		for i := range messages {
			out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
		}
	}
	_arg6 = C.gint(flags)
	_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_message(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendMessageWithTimeoutSocket(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.GOutputVector
	var _arg3 C.gint
	var _arg4 **C.GSocketControlMessage
	var _arg5 C.gint
	var _arg6 C.gint            // out
	var _arg7 C.gint64          // out
	var _arg8 C.gsize           // in
	var _arg9 *C.GCancellable   // out
	var _cret C.GPollableReturn // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gint(len(vectors))
	_arg2 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg5 = C.gint(len(messages))
	_arg4 = (**C.GSocketControlMessage)(C.malloc(C.ulong(len(messages)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice(_arg4, len(messages))
		for i := range messages {
			out[i] = (*C.GSocketControlMessage)(unsafe.Pointer(messages[i].Native()))
		}
	}
	_arg6 = C.gint(flags)
	_arg7 = C.gint64(timeoutUs)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_message_with_timeout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8, _arg9, &_cerr)

	var _bytesWritten uint             // out
	var _pollableReturn PollableReturn // out
	var _goerr error                   // out

	_bytesWritten = uint(_arg8)
	_pollableReturn = PollableReturn(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _pollableReturn, _goerr
}

func (s socket) SendMessagesSocket(messages []OutputMessage, flags int, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.GOutputMessage
	var _arg2 C.guint
	var _arg3 C.gint          // out
	var _arg4 *C.GCancellable // out
	var _cret C.gint          // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.guint(len(messages))
	_arg1 = (*C.GOutputMessage)(unsafe.Pointer(&messages[0]))
	_arg3 = C.gint(flags)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gint, _goerr
}

func (s socket) SendToSocket(address SocketAddress, buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg1 *C.GSocketAddress // out
	var _arg2 *C.gchar
	var _arg3 C.gsize
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	_arg3 = C.gsize(len(buffer))
	_arg2 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_to(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SendWithBlockingSocket(buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var _arg0 *C.GSocket // out
	var _arg1 *C.gchar
	var _arg2 C.gsize
	var _arg3 C.gboolean      // out
	var _arg4 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.gchar)(unsafe.Pointer(&buffer[0]))
	if blocking {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_socket_send_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s socket) SetBlockingSocket(blocking bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if blocking {
		_arg1 = C.TRUE
	}

	C.g_socket_set_blocking(_arg0, _arg1)
}

func (s socket) SetBroadcastSocket(broadcast bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if broadcast {
		_arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(_arg0, _arg1)
}

func (s socket) SetKeepaliveSocket(keepalive bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if keepalive {
		_arg1 = C.TRUE
	}

	C.g_socket_set_keepalive(_arg0, _arg1)
}

func (s socket) SetListenBacklogSocket(backlog int) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(_arg0, _arg1)
}

func (s socket) SetMulticastLoopbackSocket(loopback bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if loopback {
		_arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(_arg0, _arg1)
}

func (s socket) SetMulticastTTLSocket(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(_arg0, _arg1)
}

func (s socket) SetOptionSocket(level int, optname int, value int) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(level)
	_arg2 = C.gint(optname)
	_arg3 = C.gint(value)

	C.g_socket_set_option(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) SetTimeoutSocket(timeout uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_set_timeout(_arg0, _arg1)
}

func (s socket) SetTTLSocket(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_ttl(_arg0, _arg1)
}

func (s socket) ShutdownSocket(shutdownRead bool, shutdownWrite bool) error {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out
	var _arg2 C.gboolean // out
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}

	C.g_socket_shutdown(_arg0, _arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s socket) SpeaksIPv4Socket() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_speaks_ipv4(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	return WrapDatagramBased(gextras.InternObject(d)).ConditionCheck(condition)
}

func (d socket) ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) error {
	return WrapDatagramBased(gextras.InternObject(d)).ConditionWait(condition, timeout, cancellable)
}

func (d socket) CreateSource(condition glib.IOCondition, cancellable Cancellable) *glib.Source {
	return WrapDatagramBased(gextras.InternObject(d)).CreateSource(condition, cancellable)
}

func (d socket) ReceiveMessages(messages []InputMessage, flags int, timeout int64, cancellable Cancellable) (int, error) {
	return WrapDatagramBased(gextras.InternObject(d)).ReceiveMessages(messages, flags, timeout, cancellable)
}

func (d socket) SendMessages(messages []OutputMessage, flags int, timeout int64, cancellable Cancellable) (int, error) {
	return WrapDatagramBased(gextras.InternObject(d)).SendMessages(messages, flags, timeout, cancellable)
}

func (i socket) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}
