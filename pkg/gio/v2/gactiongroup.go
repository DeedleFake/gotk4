// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_action_group_get_type()), F: marshalActionGroup},
	})
}

// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
type ActionGroup interface {
	gextras.Objector

	// ActionAdded queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionAdded(actionName string)
	// ActionEnabledChanged queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionRemoved(actionName string)
	// ActionStateChanged queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	HasAction(actionName string) bool
	// ListActions queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// actionGroup implements the ActionGroup interface.
type actionGroup struct {
	gextras.Objector
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to a type that implements
// interface ActionGroup. It is primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return actionGroup{
		Objector: obj,
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

func (a actionGroup) ActionAdded(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_added(_arg0, _arg1)
}

func (a actionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActionRemoved(actionName string) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_action_group_action_removed(_arg0, _arg1)
}

func (a actionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	C.g_action_group_action_state_changed(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(parameter.Native()))

	C.g_action_group_activate_action(_arg0, _arg1, _arg2)
}

func (a actionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariant     // out

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_action_group_change_action_state(_arg0, _arg1, _arg2)
}

func (a actionGroup) ActionEnabled(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_enabled(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a actionGroup) ActionParameterType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_parameter_type(_arg0, _arg1)

	var _variantType *glib.VariantType // out

	_variantType = (*glib.VariantType)(unsafe.Pointer(_cret))

	return _variantType
}

func (a actionGroup) ActionState(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

func (a actionGroup) ActionStateHint(actionName string) *glib.Variant {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_hint(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

func (a actionGroup) ActionStateType(actionName string) *glib.VariantType {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_get_action_state_type(_arg0, _arg1)

	var _variantType *glib.VariantType // out

	_variantType = (*glib.VariantType)(unsafe.Pointer(_cret))

	return _variantType
}

func (a actionGroup) HasAction(actionName string) bool {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_has_action(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a actionGroup) ListActions() []string {
	var _arg0 *C.GActionGroup // out
	var _cret **C.gchar

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))

	_cret = C.g_action_group_list_actions(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

func (a actionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	var _arg0 *C.GActionGroup // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _arg3 *C.GVariantType // in
	var _arg4 *C.GVariantType // in
	var _arg5 *C.GVariant     // in
	var _arg6 *C.GVariant     // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GActionGroup)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_action_group_query_action(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)

	var _enabled bool                    // out
	var _parameterType *glib.VariantType // out
	var _stateType *glib.VariantType     // out
	var _stateHint *glib.Variant         // out
	var _state *glib.Variant             // out
	var _ok bool                         // out

	if _arg2 != 0 {
		_enabled = true
	}
	_parameterType = (*glib.VariantType)(unsafe.Pointer(_arg3))
	runtime.SetFinalizer(&_parameterType, func(v **glib.VariantType) {
		C.free(unsafe.Pointer(v))
	})
	_stateType = (*glib.VariantType)(unsafe.Pointer(_arg4))
	runtime.SetFinalizer(&_stateType, func(v **glib.VariantType) {
		C.free(unsafe.Pointer(v))
	})
	_stateHint = (*glib.Variant)(unsafe.Pointer(_arg5))
	runtime.SetFinalizer(&_stateHint, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	_state = (*glib.Variant)(unsafe.Pointer(_arg6))
	runtime.SetFinalizer(&_state, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	if _cret != 0 {
		_ok = true
	}

	return _enabled, _parameterType, _stateType, _stateHint, _state, _ok
}
