// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_action_group_get_type()), F: marshalActionGroup},
	})
}

// ActionGroupOverrider contains methods that are overridable. This
// interface is a subset of the interface ActionGroup.
type ActionGroupOverrider interface {
	// ActionAdded emits the Group::action-added signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on @action_group.
	//
	// This function should only be called by Group implementations.
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within @action_group.
	//
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	//
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	//
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	//
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	//
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	//
	//    g_debug ("application has been terminated. exiting.");
	//
	//    exit (0);
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled checks if the named action within @action_group is
	// currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within @action_group.
	//
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries the current state of the named action within
	// @action_group.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within @action_group.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries the type of the state of the named action within
	// @action_group.
	//
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	//
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	//
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within @action_group.
	HasAction(actionName string) bool
	// ListActions lists the actions contained within @action_group.
	//
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
type ActionGroup interface {
	gextras.Objector
	ActionGroupOverrider
}

// actionGroup implements the ActionGroup interface.
type actionGroup struct {
	gextras.Objector
}

var _ ActionGroup = (*actionGroup)(nil)

// WrapActionGroup wraps a GObject to a type that implements interface
// ActionGroup. It is primarily used internally.
func WrapActionGroup(obj *externglib.Object) ActionGroup {
	return ActionGroup{
		Objector: obj,
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapActionGroup(obj), nil
}

// ActionAdded emits the Group::action-added signal on @action_group.
//
// This function should only be called by Group implementations.
func (a actionGroup) ActionAdded(actionName string) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_action_group_action_added(arg0, arg1)
}

// ActionEnabledChanged emits the Group::action-enabled-changed signal on
// @action_group.
//
// This function should only be called by Group implementations.
func (a actionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	if enabled {
		arg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(arg0, arg1, arg2)
}

// ActionRemoved emits the Group::action-removed signal on @action_group.
//
// This function should only be called by Group implementations.
func (a actionGroup) ActionRemoved(actionName string) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_action_group_action_removed(arg0, arg1)
}

// ActionStateChanged emits the Group::action-state-changed signal on
// @action_group.
//
// This function should only be called by Group implementations.
func (a actionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(state.Native())

	C.g_action_group_action_state_changed(arg0, arg1, arg2)
}

// ActivateAction: activate the named action within @action_group.
//
// If the action is expecting a parameter, then the correct type of
// parameter must be given as @parameter. If the action is expecting no
// parameters then @parameter must be nil. See
// g_action_group_get_action_parameter_type().
//
// If the Group implementation supports asynchronous remote activation over
// D-Bus, this call may return before the relevant D-Bus traffic has been
// sent, or any replies have been received. In order to block on such
// asynchronous activation calls, g_dbus_connection_flush() should be called
// prior to the code, which depends on the result of the action activation.
// Without flushing the D-Bus connection, there is no guarantee that the
// action would have been activated.
//
// The following code which runs in a remote app instance, shows an example
// of a "quit" action being activated on the primary app instance over
// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
// g_dbus_connection_flush(), the "quit" action may fail to be activated on
// the primary instance.
//
//    // call "quit" action on primary instance
//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
//    // make sure the action is activated now
//    g_dbus_connection_flush (...);
//
//    g_debug ("application has been terminated. exiting.");
//
//    exit (0);
func (a actionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(parameter.Native())

	C.g_action_group_activate_action(arg0, arg1, arg2)
}

// ChangeActionState: request for the state of the named action within
// @action_group to be changed to @value.
//
// The action must be stateful and @value must be of the correct type. See
// g_action_group_get_action_state_type().
//
// This call merely requests a change. The action may refuse to change its
// state or may change its state to something other than @value. See
// g_action_group_get_action_state_hint().
//
// If the @value GVariant is floating, it is consumed.
func (a actionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar
	var arg2 *C.GVariant

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GVariant)(value.Native())

	C.g_action_group_change_action_state(arg0, arg1, arg2)
}

// ActionEnabled checks if the named action within @action_group is
// currently enabled.
//
// An action must be enabled in order to be activated or in order to have
// its state changed from outside callers.
func (a actionGroup) ActionEnabled(actionName string) bool {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_get_action_enabled(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ActionParameterType queries the type of the parameter that must be given
// when activating the named action within @action_group.
//
// When activating the action using g_action_group_activate_action(), the
// #GVariant given to that function must be of the type returned by this
// function.
//
// In the case that this function returns nil, you must not give any
// #GVariant, but nil instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (a actionGroup) ActionParameterType(actionName string) *glib.VariantType {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_get_action_parameter_type(arg0, arg1)

	var ret0 *glib.VariantType

	{
		ret0 = glib.WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// ActionState queries the current state of the named action within
// @action_group.
//
// If the action is not stateful then nil will be returned. If the action is
// stateful then the type of the return value is the type given by
// g_action_group_get_action_state_type().
//
// The return value (if non-nil) should be freed with g_variant_unref() when
// it is no longer required.
func (a actionGroup) ActionState(actionName string) *glib.Variant {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_get_action_state(arg0, arg1)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ActionStateHint requests a hint about the valid range of values for the
// state of the named action within @action_group.
//
// If nil is returned it either means that the action is not stateful or
// that there is no hint about the valid range of values for the state of
// the action.
//
// If a #GVariant array is returned then each item in the array is a
// possible value for the state. If a #GVariant pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound of
// valid values for the state.
//
// In any case, the information is merely a hint. It may be possible to have
// a state value outside of the hinted range and setting a value within the
// range may fail.
//
// The return value (if non-nil) should be freed with g_variant_unref() when
// it is no longer required.
func (a actionGroup) ActionStateHint(actionName string) *glib.Variant {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_get_action_state_hint(arg0, arg1)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ActionStateType queries the type of the state of the named action within
// @action_group.
//
// If the action is stateful then this function returns the Type of the
// state. All calls to g_action_group_change_action_state() must give a
// #GVariant of this type and g_action_group_get_action_state() will return
// a #GVariant of the same type.
//
// If the action is not stateful then this function will return nil. In that
// case, g_action_group_get_action_state() will return nil and you must not
// call g_action_group_change_action_state().
//
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (a actionGroup) ActionStateType(actionName string) *glib.VariantType {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_get_action_state_type(arg0, arg1)

	var ret0 *glib.VariantType

	{
		ret0 = glib.WrapVariantType(unsafe.Pointer(ret))
	}

	return ret0
}

// HasAction checks if the named action exists within @action_group.
func (a actionGroup) HasAction(actionName string) bool {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_has_action(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ListActions lists the actions contained within @action_group.
//
// The caller is responsible for freeing the list with g_strfreev() when it
// is no longer required.
func (a actionGroup) ListActions() []string {
	var arg0 *C.GActionGroup

	arg0 = (*C.GActionGroup)(a.Native())

	ret := C.g_action_group_list_actions(arg0)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// QueryAction queries all aspects of the named action within an
// @action_group.
//
// This function acquires the information available from
// g_action_group_has_action(), g_action_group_get_action_enabled(),
// g_action_group_get_action_parameter_type(),
// g_action_group_get_action_state_type(),
// g_action_group_get_action_state_hint() and
// g_action_group_get_action_state() with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having to
// perform repeated lookups of the action in order to discover different
// things about it. The second is that implementing Group can now be done by
// only overriding this one virtual function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the information.
// The interface also provides default implementations of those functions
// that call this function. All implementations, therefore, must override
// either this function or all of the others.
//
// If the action exists, true is returned and any of the requested fields
// (as indicated by having a non-nil reference passed in) are filled. If the
// action doesn't exist, false is returned and the fields may or may not
// have been modified.
func (a actionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	var arg0 *C.GActionGroup
	var arg1 *C.gchar
	var arg2 *C.gboolean      // out
	var arg3 **C.GVariantType // out
	var arg4 **C.GVariantType // out
	var arg5 **C.GVariant     // out
	var arg6 **C.GVariant     // out

	arg0 = (*C.GActionGroup)(a.Native())
	arg1 = (*C.gchar)(C.CString(actionName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_action_group_query_action(arg0, arg1, &arg2, &arg3, &arg4, &arg5, &arg6)

	var ret0 bool
	var ret1 **glib.VariantType
	var ret2 **glib.VariantType
	var ret3 **glib.Variant
	var ret4 **glib.Variant
	var ret5 bool

	ret0 = C.bool(arg2) != 0

	{
		ret1 = glib.WrapVariantType(unsafe.Pointer(arg3))
		runtime.SetFinalizer(ret1, func(v **glib.VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret2 = glib.WrapVariantType(unsafe.Pointer(arg4))
		runtime.SetFinalizer(ret2, func(v **glib.VariantType) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret3 = glib.WrapVariant(unsafe.Pointer(arg5))
		runtime.SetFinalizer(ret3, func(v **glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	{
		ret4 = glib.WrapVariant(unsafe.Pointer(arg6))
		runtime.SetFinalizer(ret4, func(v **glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret5 = C.bool(ret) != 0

	return ret0, ret1, ret2, ret3, ret4, ret5
}
