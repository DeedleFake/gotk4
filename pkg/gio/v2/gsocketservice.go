// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
	})
}

// SocketService is an object that represents a service that is provided to the
// network or over local sockets. When a new connection is made to the service
// the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	gextras.Objector

	// AsSocketListener casts the class to the SocketListener interface.
	AsSocketListener() SocketListener

	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// This method is inherited from SocketListener
	Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error)
	// AcceptAsync: this is the asynchronous version of
	// g_socket_listener_accept().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket() to get the result of the
	// operation.
	//
	// This method is inherited from SocketListener
	AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptFinish finishes an async accept operation. See
	// g_socket_listener_accept_async()
	//
	// This method is inherited from SocketListener
	AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// This method is inherited from SocketListener
	AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error)
	// AcceptSocketAsync: this is the asynchronous version of
	// g_socket_listener_accept_socket().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket_finish() to get the result of the
	// operation.
	//
	// This method is inherited from SocketListener
	AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptSocketFinish finishes an async accept operation. See
	// g_socket_listener_accept_socket_async()
	//
	// This method is inherited from SocketListener
	AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	//
	// This method is inherited from SocketListener
	AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// This method is inherited from SocketListener
	AddAnyInetPort(sourceObject gextras.Objector) (uint16, error)
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	//
	// This method is inherited from SocketListener
	AddInetPort(port uint16, sourceObject gextras.Objector) error
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	//
	// This method is inherited from SocketListener
	AddSocket(socket Socket, sourceObject gextras.Objector) error
	// Close closes all the sockets in the listener.
	//
	// This method is inherited from SocketListener
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	//
	// This method is inherited from SocketListener
	SetBacklog(listenBacklog int)

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	Stop()
}

// socketService implements the SocketService interface.
type socketService struct {
	*externglib.Object
}

var _ SocketService = (*socketService)(nil)

// WrapSocketService wraps a GObject to a type that implements
// interface SocketService. It is primarily used internally.
func WrapSocketService(obj *externglib.Object) SocketService {
	return socketService{obj}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketService(obj), nil
}

// NewSocketService creates a new Service with no sockets to listen for. New
// listeners can be added with e.g. g_socket_listener_add_address() or
// g_socket_listener_add_inet_port().
//
// New services are created active, there is no need to call
// g_socket_service_start(), unless g_socket_service_stop() has been called
// before.
func NewSocketService() SocketService {
	var _cret *C.GSocketService // in

	_cret = C.g_socket_service_new()

	var _socketService SocketService // out

	_socketService = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SocketService)

	return _socketService
}

func (s socketService) AsSocketListener() SocketListener {
	return WrapSocketListener(gextras.InternObject(s))
}

func (l socketService) Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error) {
	return WrapSocketListener(gextras.InternObject(l)).Accept(cancellable)
}

func (l socketService) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapSocketListener(gextras.InternObject(l)).AcceptAsync(cancellable, callback)
}

func (l socketService) AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptFinish(result)
}

func (l socketService) AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptSocket(cancellable)
}

func (l socketService) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapSocketListener(gextras.InternObject(l)).AcceptSocketAsync(cancellable, callback)
}

func (l socketService) AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptSocketFinish(result)
}

func (l socketService) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error) {
	return WrapSocketListener(gextras.InternObject(l)).AddAddress(address, typ, protocol, sourceObject)
}

func (l socketService) AddAnyInetPort(sourceObject gextras.Objector) (uint16, error) {
	return WrapSocketListener(gextras.InternObject(l)).AddAnyInetPort(sourceObject)
}

func (l socketService) AddInetPort(port uint16, sourceObject gextras.Objector) error {
	return WrapSocketListener(gextras.InternObject(l)).AddInetPort(port, sourceObject)
}

func (l socketService) AddSocket(socket Socket, sourceObject gextras.Objector) error {
	return WrapSocketListener(gextras.InternObject(l)).AddSocket(socket, sourceObject)
}

func (l socketService) Close() {
	WrapSocketListener(gextras.InternObject(l)).Close()
}

func (l socketService) SetBacklog(listenBacklog int) {
	WrapSocketListener(gextras.InternObject(l)).SetBacklog(listenBacklog)
}

func (s socketService) IsActive() bool {
	var _arg0 *C.GSocketService // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	_cret = C.g_socket_service_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s socketService) Start() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	C.g_socket_service_start(_arg0)
}

func (s socketService) Stop() {
	var _arg0 *C.GSocketService // out

	_arg0 = (*C.GSocketService)(unsafe.Pointer(s.Native()))

	C.g_socket_service_stop(_arg0)
}
