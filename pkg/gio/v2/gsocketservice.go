// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_service_get_type()), F: marshalSocketService},
	})
}

// SocketService: a Service is an object that represents a service that is
// provided to the network or over local sockets. When a new connection is made
// to the service the Service::incoming signal is emitted.
//
// A Service is a subclass of Listener and you need to add the addresses you
// want to accept connections on with the Listener APIs.
//
// There are two options for implementing a network service based on Service.
// The first is to create the service using g_socket_service_new() and to
// connect to the Service::incoming signal. The second is to subclass Service
// and override the default signal handler implementation.
//
// In either case, the handler must immediately return, or else it will block
// additional incoming connections from being serviced. If you are interested in
// writing connection handlers that contain blocking code then see
// SocketService.
//
// The socket service runs on the main loop of the [thread-default
// context][g-main-context-push-thread-default-context] of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	SocketListener

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	Stop()
}

// socketService implements the SocketService interface.
type socketService struct {
	SocketListener
}

var _ SocketService = (*socketService)(nil)

// WrapSocketService wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketService(obj *externglib.Object) SocketService {
	return SocketService{
		SocketListener: WrapSocketListener(obj),
	}
}

func marshalSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketService(obj), nil
}

// NewSocketService constructs a class SocketService.
func NewSocketService() SocketService {
	ret := C.g_socket_service_new()

	var ret0 SocketService

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(SocketService)

	return ret0
}

// IsActive: check whether the service is active or not. An active service
// will accept new clients that connect, while a non-active service will let
// connecting clients queue up until the service is started.
func (s socketService) IsActive() bool {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(s.Native())

	ret := C.g_socket_service_is_active(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Start restarts the service, i.e. start accepting connections from the
// added sockets when the mainloop runs. This only needs to be called after
// the service has been stopped from g_socket_service_stop().
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
func (s socketService) Start() {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(s.Native())

	C.g_socket_service_start(arg0)
}

// Stop stops the service, i.e. stops accepting connections from the added
// sockets when the mainloop runs.
//
// This call is thread-safe, so it may be called from a thread handling an
// incoming client request.
//
// Note that this only stops accepting new connections; it does not close
// the listening sockets, and you can call g_socket_service_start() again
// later to begin listening again. To close the listening sockets, call
// g_socket_listener_close(). (This will happen automatically when the
// Service is finalized.)
//
// This must be called before calling g_socket_listener_close() as the
// socket service will start accepting connections immediately when a new
// socket is added.
func (s socketService) Stop() {
	var arg0 *C.GSocketService

	arg0 = (*C.GSocketService)(s.Native())

	C.g_socket_service_stop(arg0)
}

type SocketServicePrivate struct {
	native C.GSocketServicePrivate
}

// WrapSocketServicePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSocketServicePrivate(ptr unsafe.Pointer) *SocketServicePrivate {
	if ptr == nil {
		return nil
	}

	return (*SocketServicePrivate)(ptr)
}

func marshalSocketServicePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSocketServicePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SocketServicePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}
