// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_application_get_type()), F: marshalApplication},
	})
}

// Application: a #GApplication is the foundation of an application. It wraps
// some low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as Application or
// Application. In general, you should not use this class outside of a higher
// level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`,
// `org.example.internal_apps.Calculator`, `org._7_zip.Archiver`. For details on
// valid application identifiers, see g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some ‘platform data’ from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the @before_emit or @after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// @add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application interface {
	gextras.Objector
	ActionGroup
	ActionMap

	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate()
	// AddMainOption: add an option to be handled by @application.
	//
	// Calling this function is the equivalent of calling
	// g_application_add_main_option_entries() with a single Entry that has its
	// arg_data member set to nil.
	//
	// The parsed arguments will be packed into a Dict which is passed to
	// #GApplication::handle-local-options. If
	// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
	// the primary instance. See g_application_add_main_option_entries() for
	// more details.
	//
	// See Entry for more documentation of the arguments.
	AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string)
	// AddOptionGroup adds a Group to the commandline handling of @application.
	//
	// This function is comparable to g_option_context_add_group().
	//
	// Unlike g_application_add_main_option_entries(), this function does not
	// deal with nil @arg_data and never transmits options to the primary
	// instance.
	//
	// The reason for that is because, by the time the options arrive at the
	// primary instance, it is typically too late to do anything with them.
	// Taking the GTK option group as an example: GTK will already have been
	// initialised by the time the #GApplication::command-line handler runs. In
	// the case that this is not the first-running instance of the application,
	// the existing instance may already have been running for a very long time.
	//
	// This means that the options from Group are only really usable in the case
	// that the instance of the application being run is the first instance.
	// Passing options like `--display=` or `--gdk-debug=` on future runs will
	// have no effect on the existing primary instance.
	//
	// Calling this function will cause the options in the supplied option group
	// to be parsed, but it does not cause you to be "opted in" to the new
	// functionality whereby unrecognised options are rejected even if
	// G_APPLICATION_HANDLES_COMMAND_LINE was given.
	AddOptionGroup(group *glib.OptionGroup)
	// BindBusyProperty marks @application as busy (see
	// g_application_mark_busy()) while @property on @object is true.
	//
	// The binding holds a reference to @application while it is active, but not
	// to @object. Instead, the binding is destroyed when @object is finalized.
	BindBusyProperty(object gextras.Objector, property string)
	// ApplicationID gets the unique identifier for @application.
	ApplicationID() string
	// DBusConnection gets the BusConnection being used by the application, or
	// nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the BusConnection being used for uniqueness and communication with
	// the desktop environment and other instances of the application.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusConnection() DBusConnection
	// DBusObjectPath gets the D-Bus object path being used by the application,
	// or nil.
	//
	// If #GApplication is using its D-Bus backend then this function will
	// return the D-Bus object path that #GApplication is using. If the
	// application is the primary instance then there is an object published at
	// this path. If the application is not the primary instance then the result
	// of this function is undefined.
	//
	// If #GApplication is not using D-Bus then this function will return nil.
	// This includes the situation where the D-Bus backend would normally be in
	// use but we were unable to connect to the bus.
	//
	// This function must not be called before the application has been
	// registered. See g_application_get_is_registered().
	DBusObjectPath() string
	// Flags gets the flags for @application.
	//
	// See Flags.
	Flags() ApplicationFlags
	// InactivityTimeout gets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	InactivityTimeout() uint
	// IsBusy gets the application's current busy state, as set through
	// g_application_mark_busy() or g_application_bind_busy_property().
	IsBusy() bool
	// IsRegistered checks if @application is registered.
	//
	// An application is registered if g_application_register() has been
	// successfully called.
	IsRegistered() bool
	// IsRemote checks if @application is remote.
	//
	// If @application is remote then it means that another instance of
	// application already exists (the 'primary' instance). Calls to perform
	// actions on @application will result in the actions being performed by the
	// primary instance.
	//
	// The value of this property cannot be accessed before
	// g_application_register() has been called. See
	// g_application_get_is_registered().
	IsRemote() bool
	// ResourceBasePath gets the resource base path of @application.
	//
	// See g_application_set_resource_base_path() for more information.
	ResourceBasePath() string
	// Hold increases the use count of @application.
	//
	// Use this function to indicate that the application has a reason to
	// continue to run. For example, g_application_hold() is called by GTK+ when
	// a toplevel window is on the screen.
	//
	// To cancel the hold, call g_application_release().
	Hold()
	// MarkBusy increases the busy count of @application.
	//
	// Use this function to indicate that the application is busy, for instance
	// while a long running operation is pending.
	//
	// The busy state will be exposed to other processes, so a session shell
	// will use that information to indicate the state to the user (e.g. with a
	// spinner).
	//
	// To cancel the busy indication, use g_application_unmark_busy().
	MarkBusy()
	// Open opens the given files.
	//
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	//
	// @n_files must be greater than zero.
	//
	// @hint is simply passed through to the ::open signal. It is intended to be
	// used by applications that have multiple modes for opening files (eg:
	// "view" vs "edit", etc). Unless you have a need for this functionality,
	// you should use "".
	//
	// The application must be registered before calling this function and it
	// must have the G_APPLICATION_HANDLES_OPEN flag set.
	Open(files []File, hint string)
	// Quit: immediately quits the application.
	//
	// Upon return to the mainloop, g_application_run() will return, calling
	// only the 'shutdown' function before doing so.
	//
	// The hold count is ignored. Take care if your code has called
	// g_application_hold() on the application and is therefore still expecting
	// it to exist. (Note that you may have called g_application_hold()
	// indirectly, for example through gtk_application_add_window().)
	//
	// The result of calling g_application_run() again after it returns is
	// unspecified.
	Quit()
	// Register attempts registration of the application.
	//
	// This is the point at which the application discovers if it is the primary
	// instance or merely acting as a remote for an already-existing primary
	// instance. This is implemented by attempting to acquire the application
	// identifier as a unique bus name on the session bus using GDBus.
	//
	// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
	// then this process will always become the primary instance.
	//
	// Due to the internal architecture of GDBus, method calls can be dispatched
	// at any time (even if a main loop is not running). For this reason, you
	// must ensure that any object paths that you wish to register are
	// registered before calling this function.
	//
	// If the application has already been registered then true is returned with
	// no work performed.
	//
	// The #GApplication::startup signal is emitted if registration succeeds and
	// @application is the primary instance (including the non-unique case).
	//
	// In the event of an error (such as @cancellable being cancelled, or a
	// failure to connect to the session bus), false is returned and @error is
	// set appropriately.
	//
	// Note: the return value of this function is not an indicator that this
	// instance is or is not the primary instance of the application. See
	// g_application_get_is_remote() for that.
	Register(cancellable Cancellable) error
	// Release: decrease the use count of @application.
	//
	// When the use count reaches zero, the application will stop running.
	//
	// Never call this function except to cancel the effect of a previous call
	// to g_application_hold().
	Release()
	// Run runs the application.
	//
	// This function is intended to be run from main() and its return value is
	// intended to be returned by main(). Although you are expected to pass the
	// @argc, @argv parameters from main() to this function, it is possible to
	// pass nil if @argv is not available or commandline handling is not
	// required. Note that on Windows, @argc and @argv are ignored, and
	// g_win32_get_command_line() is called internally (for proper support of
	// Unicode commandline arguments).
	//
	// #GApplication will attempt to parse the commandline arguments. You can
	// add commandline flags to the list of recognised options by way of
	// g_application_add_main_option_entries(). After this, the
	// #GApplication::handle-local-options signal is emitted, from which the
	// application can inspect the values of its Entrys.
	//
	// #GApplication::handle-local-options is a good place to handle options
	// such as `--version`, where an immediate reply from the local process is
	// desired (instead of communicating with an already-running instance). A
	// #GApplication::handle-local-options handler can stop further processing
	// by returning a non-negative value, which then becomes the exit status of
	// the process.
	//
	// What happens next depends on the flags: if
	// G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
	// commandline arguments are sent to the primary instance, where a
	// #GApplication::command-line signal is emitted. Otherwise, the remaining
	// commandline arguments are assumed to be a list of files. If there are no
	// files listed, the application is activated via the
	// #GApplication::activate signal. If there are one or more files, and
	// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via
	// the #GApplication::open signal.
	//
	// If you are interested in doing more complicated local handling of the
	// commandline then you should implement your own #GApplication subclass and
	// override local_command_line(). In this case, you most likely want to
	// return true from your local_command_line() implementation to suppress the
	// default handling. See
	// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
	// example.
	//
	// If, after the above is done, the use count of the application is zero
	// then the exit status is returned immediately. If the use count is
	// non-zero then the default main context is iterated until the use count
	// falls to zero, at which point 0 is returned.
	//
	// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run
	// for as much as 10 seconds with a use count of zero while waiting for the
	// message that caused the activation to arrive. After that, if the use
	// count falls to zero the application will exit immediately, except in the
	// case that g_application_set_inactivity_timeout() is in use.
	//
	// This function sets the prgname (g_set_prgname()), if not already set, to
	// the basename of argv[0].
	//
	// Much like g_main_loop_run(), this function will acquire the main context
	// for the duration that the application is running.
	//
	// Since 2.40, applications that are not explicitly flagged as services or
	// launchers (ie: neither G_APPLICATION_IS_SERVICE or
	// G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
	// default handler for local_command_line) if "--gapplication-service" was
	// given in the command line. If this flag is present then normal
	// commandline processing is interrupted and the G_APPLICATION_IS_SERVICE
	// flag is set. This provides a "compromise" solution whereby running an
	// application directly from the commandline will invoke it in the normal
	// way (which can be useful for debugging) while still allowing applications
	// to be D-Bus activated in service mode. The D-Bus service file should
	// invoke the executable with "--gapplication-service" as the sole
	// commandline argument. This approach is suitable for use by most graphical
	// applications but should not be used from applications like editors that
	// need precise control over when processes invoked via the commandline will
	// exit and what their exit status will be.
	Run(argc int, argv []string) int
	// SendNotification sends a notification on behalf of @application to the
	// desktop shell. There is no guarantee that the notification is displayed
	// immediately, or even at all.
	//
	// Notifications may persist after the application exits. It will be
	// D-Bus-activated when the notification or one of its actions is activated.
	//
	// Modifying @notification after this call has no effect. However, the
	// object can be reused for a later call to this function.
	//
	// @id may be any string that uniquely identifies the event for the
	// application. It does not need to be in any special format. For example,
	// "new-message" might be appropriate for a notification about new messages.
	//
	// If a previous notification was sent with the same @id, it will be
	// replaced with @notification and shown again as if it was a new
	// notification. This works even for notifications sent from a previous
	// execution of the application, as long as @id is the same string.
	//
	// @id may be nil, but it is impossible to replace or withdraw notifications
	// without an id.
	//
	// If @notification is no longer relevant, it can be withdrawn with
	// g_application_withdraw_notification().
	SendNotification(id string, notification Notification)
	// SetActionGroup: this used to be how actions were associated with a
	// #GApplication. Now there is Map for that.
	SetActionGroup(actionGroup ActionGroup)
	// SetApplicationID sets the unique identifier for @application.
	//
	// The application id can only be modified if @application has not yet been
	// registered.
	//
	// If non-nil, the application id must be valid. See
	// g_application_id_is_valid().
	SetApplicationID(applicationID string)
	// SetDefault sets or unsets the default application for the process, as
	// returned by g_application_get_default().
	//
	// This function does not take its own reference on @application. If
	// @application is destroyed then the default application will revert back
	// to nil.
	SetDefault()
	// SetFlags sets the flags for @application.
	//
	// The flags can only be modified if @application has not yet been
	// registered.
	//
	// See Flags.
	SetFlags(flags ApplicationFlags)
	// SetInactivityTimeout sets the current inactivity timeout for the
	// application.
	//
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	//
	// This call has no side effects of its own. The value set here is only used
	// for next time g_application_release() drops the use count to zero. Any
	// timeouts currently in progress are not impacted.
	SetInactivityTimeout(inactivityTimeout uint)
	// SetOptionContextDescription adds a description to the @application option
	// context.
	//
	// See g_option_context_set_description() for more information.
	SetOptionContextDescription(description string)
	// SetOptionContextParameterString sets the parameter string to be used by
	// the commandline handling of @application.
	//
	// This function registers the argument to be passed to
	// g_option_context_new() when the internal Context of @application is
	// created.
	//
	// See g_option_context_new() for more information about @parameter_string.
	SetOptionContextParameterString(parameterString string)
	// SetOptionContextSummary adds a summary to the @application option
	// context.
	//
	// See g_option_context_set_summary() for more information.
	SetOptionContextSummary(summary string)
	// SetResourceBasePath sets (or unsets) the base resource path of
	// @application.
	//
	// The path is used to automatically load various [application
	// resources][gresource] such as menu layouts and action descriptions. The
	// various types of resources will be found at fixed names relative to the
	// given base path.
	//
	// By default, the resource base path is determined from the application ID
	// by prefixing '/' and replacing each '.' with '/'. This is done at the
	// time that the #GApplication object is constructed. Changes to the
	// application ID after that point will not have an impact on the resource
	// base path.
	//
	// As an example, if the application has an ID of "org.example.app" then the
	// default resource base path will be "/org/example/app". If this is a
	// Application (and you have not manually changed the path) then Gtk will
	// then search for the menus of the application at
	// "/org/example/app/gtk/menus.ui".
	//
	// See #GResource for more information about adding resources to your
	// application.
	//
	// You can disable automatic resource loading functionality by setting the
	// path to nil.
	//
	// Changing the resource base path once the application is running is not
	// recommended. The point at which the resource path is consulted for
	// forming paths for various purposes is unspecified. When writing a
	// sub-class of #GApplication you should either set the
	// #GApplication:resource-base-path property at construction time, or call
	// this function during the instance initialization. Alternatively, you can
	// call this function in the Class.startup virtual function, before chaining
	// up to the parent implementation.
	SetResourceBasePath(resourcePath string)
	// UnbindBusyProperty destroys a binding between @property and the busy
	// state of @application that was previously created with
	// g_application_bind_busy_property().
	UnbindBusyProperty(object gextras.Objector, property string)
	// UnmarkBusy decreases the busy count of @application.
	//
	// When the busy count reaches zero, the new state will be propagated to
	// other processes.
	//
	// This function must only be called to cancel the effect of a previous call
	// to g_application_mark_busy().
	UnmarkBusy()
	// WithdrawNotification withdraws a notification that was sent with
	// g_application_send_notification().
	//
	// This call does nothing if a notification with @id doesn't exist or the
	// notification was never sent.
	//
	// This function works even for notifications sent in previous executions of
	// this application, as long @id is the same as it was for the sent
	// notification.
	//
	// Note that notifications are dismissed when the user clicks on one of the
	// buttons in a notification or triggers its default action, so there is no
	// need to explicitly withdraw the notification in that case.
	WithdrawNotification(id string)
}

// application implements the Application interface.
type application struct {
	gextras.Objector
	ActionGroup
	ActionMap
}

var _ Application = (*application)(nil)

// WrapApplication wraps a GObject to the right type. It is
// primarily used internally.
func WrapApplication(obj *externglib.Object) Application {
	return Application{
		Objector:    obj,
		ActionGroup: WrapActionGroup(obj),
		ActionMap:   WrapActionMap(obj),
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapApplication(obj), nil
}

// NewApplication constructs a class Application.
func NewApplication(applicationID string, flags ApplicationFlags) Application {
	var arg1 *C.gchar
	var arg2 C.GApplicationFlags

	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GApplicationFlags)(flags)

	ret := C.g_application_new(arg1, arg2)

	var ret0 Application

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Application)

	return ret0
}

// Activate activates the application.
//
// In essence, this results in the #GApplication::activate signal being
// emitted in the primary instance.
//
// The application must be registered before calling this function.
func (a application) Activate() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_activate(arg0)
}

// AddMainOption: add an option to be handled by @application.
//
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single Entry that has its
// arg_data member set to nil.
//
// The parsed arguments will be packed into a Dict which is passed to
// #GApplication::handle-local-options. If
// G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also be sent to
// the primary instance. See g_application_add_main_option_entries() for
// more details.
//
// See Entry for more documentation of the arguments.
func (a application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string) {
	var arg0 *C.GApplication
	var arg1 *C.char
	var arg2 C.char
	var arg3 C.GOptionFlags
	var arg4 C.GOptionArg
	var arg5 *C.char
	var arg6 *C.char

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(longName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.char(shortName)
	arg3 = (C.GOptionFlags)(flags)
	arg4 = (C.GOptionArg)(arg)
	arg5 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg5))
	arg6 = (*C.gchar)(C.CString(argDescription))
	defer C.free(unsafe.Pointer(arg6))

	C.g_application_add_main_option(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// AddOptionGroup adds a Group to the commandline handling of @application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does not
// deal with nil @arg_data and never transmits options to the primary
// instance.
//
// The reason for that is because, by the time the options arrive at the
// primary instance, it is typically too late to do anything with them.
// Taking the GTK option group as an example: GTK will already have been
// initialised by the time the #GApplication::command-line handler runs. In
// the case that this is not the first-running instance of the application,
// the existing instance may already have been running for a very long time.
//
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance.
// Passing options like `--display=` or `--gdk-debug=` on future runs will
// have no effect on the existing primary instance.
//
// Calling this function will cause the options in the supplied option group
// to be parsed, but it does not cause you to be "opted in" to the new
// functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
func (a application) AddOptionGroup(group *glib.OptionGroup) {
	var arg0 *C.GApplication
	var arg1 *C.GOptionGroup

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.GOptionGroup)(group.Native())

	C.g_application_add_option_group(arg0, arg1)
}

// BindBusyProperty marks @application as busy (see
// g_application_mark_busy()) while @property on @object is true.
//
// The binding holds a reference to @application while it is active, but not
// to @object. Instead, the binding is destroyed when @object is finalized.
func (a application) BindBusyProperty(object gextras.Objector, property string) {
	var arg0 *C.GApplication
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.GObject)(object.Native())
	arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg2))

	C.g_application_bind_busy_property(arg0, arg1, arg2)
}

// ApplicationID gets the unique identifier for @application.
func (a application) ApplicationID() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_application_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// DBusConnection gets the BusConnection being used by the application, or
// nil.
//
// If #GApplication is using its D-Bus backend then this function will
// return the BusConnection being used for uniqueness and communication with
// the desktop environment and other instances of the application.
//
// If #GApplication is not using D-Bus then this function will return nil.
// This includes the situation where the D-Bus backend would normally be in
// use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered. See g_application_get_is_registered().
func (a application) DBusConnection() DBusConnection {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_dbus_connection(arg0)

	var ret0 DBusConnection

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(DBusConnection)

	return ret0
}

// DBusObjectPath gets the D-Bus object path being used by the application,
// or nil.
//
// If #GApplication is using its D-Bus backend then this function will
// return the D-Bus object path that #GApplication is using. If the
// application is the primary instance then there is an object published at
// this path. If the application is not the primary instance then the result
// of this function is undefined.
//
// If #GApplication is not using D-Bus then this function will return nil.
// This includes the situation where the D-Bus backend would normally be in
// use but we were unable to connect to the bus.
//
// This function must not be called before the application has been
// registered. See g_application_get_is_registered().
func (a application) DBusObjectPath() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_dbus_object_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Flags gets the flags for @application.
//
// See Flags.
func (a application) Flags() ApplicationFlags {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_flags(arg0)

	var ret0 ApplicationFlags

	ret0 = ApplicationFlags(ret)

	return ret0
}

// InactivityTimeout gets the current inactivity timeout for the
// application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
func (a application) InactivityTimeout() uint {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_inactivity_timeout(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsBusy gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
func (a application) IsBusy() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_is_busy(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsRegistered checks if @application is registered.
//
// An application is registered if g_application_register() has been
// successfully called.
func (a application) IsRegistered() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_is_registered(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsRemote checks if @application is remote.
//
// If @application is remote then it means that another instance of
// application already exists (the 'primary' instance). Calls to perform
// actions on @application will result in the actions being performed by the
// primary instance.
//
// The value of this property cannot be accessed before
// g_application_register() has been called. See
// g_application_get_is_registered().
func (a application) IsRemote() bool {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_is_remote(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ResourceBasePath gets the resource base path of @application.
//
// See g_application_set_resource_base_path() for more information.
func (a application) ResourceBasePath() string {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	ret := C.g_application_get_resource_base_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Hold increases the use count of @application.
//
// Use this function to indicate that the application has a reason to
// continue to run. For example, g_application_hold() is called by GTK+ when
// a toplevel window is on the screen.
//
// To cancel the hold, call g_application_release().
func (a application) Hold() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_hold(arg0)
}

// MarkBusy increases the busy count of @application.
//
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
//
// The busy state will be exposed to other processes, so a session shell
// will use that information to indicate the state to the user (e.g. with a
// spinner).
//
// To cancel the busy indication, use g_application_unmark_busy().
func (a application) MarkBusy() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_mark_busy(arg0)
}

// Open opens the given files.
//
// In essence, this results in the #GApplication::open signal being emitted
// in the primary instance.
//
// @n_files must be greater than zero.
//
// @hint is simply passed through to the ::open signal. It is intended to be
// used by applications that have multiple modes for opening files (eg:
// "view" vs "edit", etc). Unless you have a need for this functionality,
// you should use "".
//
// The application must be registered before calling this function and it
// must have the G_APPLICATION_HANDLES_OPEN flag set.
func (a application) Open(files []File, hint string) {
	var arg0 *C.GApplication
	var arg1 **C.GFile
	var arg2 C.gint
	var arg3 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	{
		var dst []*C.GFile
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(files))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(files)
		sliceHeader.Cap = len(files)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(files); i++ {
			src := files[i]
			dst[i] = (*C.GFile)(src.Native())
		}

		arg1 = (**C.GFile)(unsafe.Pointer(ptr))
		arg2 = len(files)
	}
	arg3 = (*C.gchar)(C.CString(hint))
	defer C.free(unsafe.Pointer(arg3))

	C.g_application_open(arg0, arg1, arg2, arg3)
}

// Quit: immediately quits the application.
//
// Upon return to the mainloop, g_application_run() will return, calling
// only the 'shutdown' function before doing so.
//
// The hold count is ignored. Take care if your code has called
// g_application_hold() on the application and is therefore still expecting
// it to exist. (Note that you may have called g_application_hold()
// indirectly, for example through gtk_application_add_window().)
//
// The result of calling g_application_run() again after it returns is
// unspecified.
func (a application) Quit() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_quit(arg0)
}

// Register attempts registration of the application.
//
// This is the point at which the application discovers if it is the primary
// instance or merely acting as a remote for an already-existing primary
// instance. This is implemented by attempting to acquire the application
// identifier as a unique bus name on the session bus using GDBus.
//
// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given,
// then this process will always become the primary instance.
//
// Due to the internal architecture of GDBus, method calls can be dispatched
// at any time (even if a main loop is not running). For this reason, you
// must ensure that any object paths that you wish to register are
// registered before calling this function.
//
// If the application has already been registered then true is returned with
// no work performed.
//
// The #GApplication::startup signal is emitted if registration succeeds and
// @application is the primary instance (including the non-unique case).
//
// In the event of an error (such as @cancellable being cancelled, or a
// failure to connect to the session bus), false is returned and @error is
// set appropriately.
//
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application. See
// g_application_get_is_remote() for that.
func (a application) Register(cancellable Cancellable) error {
	var arg0 *C.GApplication
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_application_register(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Release: decrease the use count of @application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous call
// to g_application_hold().
func (a application) Release() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_release(arg0)
}

// Run runs the application.
//
// This function is intended to be run from main() and its return value is
// intended to be returned by main(). Although you are expected to pass the
// @argc, @argv parameters from main() to this function, it is possible to
// pass nil if @argv is not available or commandline handling is not
// required. Note that on Windows, @argc and @argv are ignored, and
// g_win32_get_command_line() is called internally (for proper support of
// Unicode commandline arguments).
//
// #GApplication will attempt to parse the commandline arguments. You can
// add commandline flags to the list of recognised options by way of
// g_application_add_main_option_entries(). After this, the
// #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its Entrys.
//
// #GApplication::handle-local-options is a good place to handle options
// such as `--version`, where an immediate reply from the local process is
// desired (instead of communicating with an already-running instance). A
// #GApplication::handle-local-options handler can stop further processing
// by returning a non-negative value, which then becomes the exit status of
// the process.
//
// What happens next depends on the flags: if
// G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
// commandline arguments are sent to the primary instance, where a
// #GApplication::command-line signal is emitted. Otherwise, the remaining
// commandline arguments are assumed to be a list of files. If there are no
// files listed, the application is activated via the
// #GApplication::activate signal. If there are one or more files, and
// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via
// the #GApplication::open signal.
//
// If you are interested in doing more complicated local handling of the
// commandline then you should implement your own #GApplication subclass and
// override local_command_line(). In this case, you most likely want to
// return true from your local_command_line() implementation to suppress the
// default handling. See
// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
// example.
//
// If, after the above is done, the use count of the application is zero
// then the exit status is returned immediately. If the use count is
// non-zero then the default main context is iterated until the use count
// falls to zero, at which point 0 is returned.
//
// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run
// for as much as 10 seconds with a use count of zero while waiting for the
// message that caused the activation to arrive. After that, if the use
// count falls to zero the application will exit immediately, except in the
// case that g_application_set_inactivity_timeout() is in use.
//
// This function sets the prgname (g_set_prgname()), if not already set, to
// the basename of argv[0].
//
// Much like g_main_loop_run(), this function will acquire the main context
// for the duration that the application is running.
//
// Since 2.40, applications that are not explicitly flagged as services or
// launchers (ie: neither G_APPLICATION_IS_SERVICE or
// G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
// default handler for local_command_line) if "--gapplication-service" was
// given in the command line. If this flag is present then normal
// commandline processing is interrupted and the G_APPLICATION_IS_SERVICE
// flag is set. This provides a "compromise" solution whereby running an
// application directly from the commandline will invoke it in the normal
// way (which can be useful for debugging) while still allowing applications
// to be D-Bus activated in service mode. The D-Bus service file should
// invoke the executable with "--gapplication-service" as the sole
// commandline argument. This approach is suitable for use by most graphical
// applications but should not be used from applications like editors that
// need precise control over when processes invoked via the commandline will
// exit and what their exit status will be.
func (a application) Run(argc int, argv []string) int {
	var arg0 *C.GApplication
	var arg1 C.int
	var arg2 **C.char

	arg0 = (*C.GApplication)(a.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg2 = (**C.char)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	ret := C.g_application_run(arg0, arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// SendNotification sends a notification on behalf of @application to the
// desktop shell. There is no guarantee that the notification is displayed
// immediately, or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
//
// Modifying @notification after this call has no effect. However, the
// object can be reused for a later call to this function.
//
// @id may be any string that uniquely identifies the event for the
// application. It does not need to be in any special format. For example,
// "new-message" might be appropriate for a notification about new messages.
//
// If a previous notification was sent with the same @id, it will be
// replaced with @notification and shown again as if it was a new
// notification. This works even for notifications sent from a previous
// execution of the application, as long as @id is the same string.
//
// @id may be nil, but it is impossible to replace or withdraw notifications
// without an id.
//
// If @notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
func (a application) SendNotification(id string, notification Notification) {
	var arg0 *C.GApplication
	var arg1 *C.gchar
	var arg2 *C.GNotification

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GNotification)(notification.Native())

	C.g_application_send_notification(arg0, arg1, arg2)
}

// SetActionGroup: this used to be how actions were associated with a
// #GApplication. Now there is Map for that.
func (a application) SetActionGroup(actionGroup ActionGroup) {
	var arg0 *C.GApplication
	var arg1 *C.GActionGroup

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.GActionGroup)(actionGroup.Native())

	C.g_application_set_action_group(arg0, arg1)
}

// SetApplicationID sets the unique identifier for @application.
//
// The application id can only be modified if @application has not yet been
// registered.
//
// If non-nil, the application id must be valid. See
// g_application_id_is_valid().
func (a application) SetApplicationID(applicationID string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(applicationID))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_application_id(arg0, arg1)
}

// SetDefault sets or unsets the default application for the process, as
// returned by g_application_get_default().
//
// This function does not take its own reference on @application. If
// @application is destroyed then the default application will revert back
// to nil.
func (a application) SetDefault() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_set_default(arg0)
}

// SetFlags sets the flags for @application.
//
// The flags can only be modified if @application has not yet been
// registered.
//
// See Flags.
func (a application) SetFlags(flags ApplicationFlags) {
	var arg0 *C.GApplication
	var arg1 C.GApplicationFlags

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (C.GApplicationFlags)(flags)

	C.g_application_set_flags(arg0, arg1)
}

// SetInactivityTimeout sets the current inactivity timeout for the
// application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// This call has no side effects of its own. The value set here is only used
// for next time g_application_release() drops the use count to zero. Any
// timeouts currently in progress are not impacted.
func (a application) SetInactivityTimeout(inactivityTimeout uint) {
	var arg0 *C.GApplication
	var arg1 C.guint

	arg0 = (*C.GApplication)(a.Native())
	arg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(arg0, arg1)
}

// SetOptionContextDescription adds a description to the @application option
// context.
//
// See g_option_context_set_description() for more information.
func (a application) SetOptionContextDescription(description string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_description(arg0, arg1)
}

// SetOptionContextParameterString sets the parameter string to be used by
// the commandline handling of @application.
//
// This function registers the argument to be passed to
// g_option_context_new() when the internal Context of @application is
// created.
//
// See g_option_context_new() for more information about @parameter_string.
func (a application) SetOptionContextParameterString(parameterString string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(parameterString))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_parameter_string(arg0, arg1)
}

// SetOptionContextSummary adds a summary to the @application option
// context.
//
// See g_option_context_set_summary() for more information.
func (a application) SetOptionContextSummary(summary string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(summary))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_option_context_summary(arg0, arg1)
}

// SetResourceBasePath sets (or unsets) the base resource path of
// @application.
//
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions. The
// various types of resources will be found at fixed names relative to the
// given base path.
//
// By default, the resource base path is determined from the application ID
// by prefixing '/' and replacing each '.' with '/'. This is done at the
// time that the #GApplication object is constructed. Changes to the
// application ID after that point will not have an impact on the resource
// base path.
//
// As an example, if the application has an ID of "org.example.app" then the
// default resource base path will be "/org/example/app". If this is a
// Application (and you have not manually changed the path) then Gtk will
// then search for the menus of the application at
// "/org/example/app/gtk/menus.ui".
//
// See #GResource for more information about adding resources to your
// application.
//
// You can disable automatic resource loading functionality by setting the
// path to nil.
//
// Changing the resource base path once the application is running is not
// recommended. The point at which the resource path is consulted for
// forming paths for various purposes is unspecified. When writing a
// sub-class of #GApplication you should either set the
// #GApplication:resource-base-path property at construction time, or call
// this function during the instance initialization. Alternatively, you can
// call this function in the Class.startup virtual function, before chaining
// up to the parent implementation.
func (a application) SetResourceBasePath(resourcePath string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_set_resource_base_path(arg0, arg1)
}

// UnbindBusyProperty destroys a binding between @property and the busy
// state of @application that was previously created with
// g_application_bind_busy_property().
func (a application) UnbindBusyProperty(object gextras.Objector, property string) {
	var arg0 *C.GApplication
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.GObject)(object.Native())
	arg2 = (*C.gchar)(C.CString(property))
	defer C.free(unsafe.Pointer(arg2))

	C.g_application_unbind_busy_property(arg0, arg1, arg2)
}

// UnmarkBusy decreases the busy count of @application.
//
// When the busy count reaches zero, the new state will be propagated to
// other processes.
//
// This function must only be called to cancel the effect of a previous call
// to g_application_mark_busy().
func (a application) UnmarkBusy() {
	var arg0 *C.GApplication

	arg0 = (*C.GApplication)(a.Native())

	C.g_application_unmark_busy(arg0)
}

// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with @id doesn't exist or the
// notification was never sent.
//
// This function works even for notifications sent in previous executions of
// this application, as long @id is the same as it was for the sent
// notification.
//
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no
// need to explicitly withdraw the notification in that case.
func (a application) WithdrawNotification(id string) {
	var arg0 *C.GApplication
	var arg1 *C.gchar

	arg0 = (*C.GApplication)(a.Native())
	arg1 = (*C.gchar)(C.CString(id))
	defer C.free(unsafe.Pointer(arg1))

	C.g_application_withdraw_notification(arg0, arg1)
}

type ApplicationPrivate struct {
	native C.GApplicationPrivate
}

// WrapApplicationPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapApplicationPrivate(ptr unsafe.Pointer) *ApplicationPrivate {
	if ptr == nil {
		return nil
	}

	return (*ApplicationPrivate)(ptr)
}

func marshalApplicationPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapApplicationPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *ApplicationPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}
