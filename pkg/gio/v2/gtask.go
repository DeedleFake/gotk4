// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
	})
}

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult:
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
type Task interface {
	gextras.Objector
	AsyncResult

	// Cancellable gets @task's #GCancellable
	Cancellable() Cancellable
	// CheckCancellable gets @task's check-cancellable flag. See
	// g_task_set_check_cancellable() for more details.
	CheckCancellable() bool
	// Completed gets the value of #GTask:completed. This changes from false to
	// true after the task’s callback is invoked, and will return false if
	// called from inside the callback.
	Completed() bool
	// Context gets the Context that @task will return its result in (that is,
	// the context that was the [thread-default main
	// context][g-main-context-push-thread-default] at the point when @task was
	// created).
	//
	// This will always return a non-nil value, even if the task's context is
	// the default Context.
	Context() *glib.MainContext
	// Name gets @task’s name. See g_task_set_name().
	Name() string
	// Priority gets @task's priority
	Priority() int
	// ReturnOnCancel gets @task's return-on-cancel flag. See
	// g_task_set_return_on_cancel() for more details.
	ReturnOnCancel() bool
	// SourceObject gets the source object from @task. Like
	// g_async_result_get_source_object(), but does not ref the object.
	SourceObject() gextras.Objector
	// SourceTag gets @task's source tag. See g_task_set_source_tag().
	SourceTag() interface{}
	// TaskData gets @task's `task_data`.
	TaskData() interface{}
	// HadError tests if @task resulted in an error.
	HadError() bool
	// PropagateBoolean gets the result of @task as a #gboolean.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return false and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateBoolean() error
	// PropagateInt gets the result of @task as an integer (#gssize).
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return -1 and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateInt() (gssize int, err error)
	// PropagatePointer gets the result of @task as a pointer, and transfers
	// ownership of that value to the caller.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead return nil and set @error.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagatePointer() (gpointer interface{}, err error)
	// PropagateValue gets the result of @task as a #GValue, and transfers
	// ownership of that value to the caller. As with g_task_return_value(),
	// this is a generic low-level method; g_task_propagate_pointer() and the
	// like will usually be more useful for C code.
	//
	// If the task resulted in an error, or was cancelled, then this will
	// instead set @error and return false.
	//
	// Since this method transfers ownership of the return value (or error) to
	// the caller, you may only call it once.
	PropagateValue() (value externglib.Value, err error)
	// ReturnBoolean sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnBoolean(result bool)
	// ReturnError sets @task's result to @error (which @task assumes ownership
	// of) and completes the task (see g_task_return_pointer() for more
	// discussion of exactly what this means).
	//
	// Note that since the task takes ownership of @error, and since the task
	// may be completed before returning from g_task_return_error(), you cannot
	// assume that @error is still valid after calling this. Call g_error_copy()
	// on the error if you need to keep a local copy as well.
	//
	// See also g_task_return_new_error().
	ReturnError(error *glib.Error)
	// ReturnErrorIfCancelled checks if @task's #GCancellable has been
	// cancelled, and if so, sets @task's error accordingly and completes the
	// task (see g_task_return_pointer() for more discussion of exactly what
	// this means).
	ReturnErrorIfCancelled() bool
	// ReturnInt sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this means).
	ReturnInt(result int)
	// ReturnPointer sets @task's result to @result and completes the task. If
	// @result is not nil, then @result_destroy will be used to free @result if
	// the caller does not take ownership of it with g_task_propagate_pointer().
	//
	// "Completes the task" means that for an ordinary asynchronous task it will
	// either invoke the task's callback, or else queue that callback to be
	// invoked in the proper Context, or in the next iteration of the current
	// Context. For a task run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync(), calling this method will save @result to be
	// returned to the caller later, but the task will not actually be completed
	// until the ThreadFunc exits.
	//
	// Note that since the task may be completed before returning from
	// g_task_return_pointer(), you cannot assume that @result is still valid
	// after calling this, unless you are still holding another reference on it.
	ReturnPointer(result interface{})
	// ReturnValue sets @task's result to @result (by copying it) and completes
	// the task.
	//
	// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
	// will be used for the result.
	//
	// This is a very generic low-level method intended primarily for use by
	// language bindings; for C code, g_task_return_pointer() and the like will
	// normally be much easier to use.
	ReturnValue(result *externglib.Value)
	// SetCheckCancellable sets or clears @task's check-cancellable flag. If
	// this is true (the default), then g_task_propagate_pointer(), etc, and
	// g_task_had_error() will check the task's #GCancellable first, and if it
	// has been cancelled, then they will consider the task to have returned an
	// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
	// other error or return value the task may have had.
	//
	// If @check_cancellable is false, then the #GTask will not check the
	// cancellable itself, and it is up to @task's owner to do this (eg, via
	// g_task_return_error_if_cancelled()).
	//
	// If you are using g_task_set_return_on_cancel() as well, then you must
	// leave check-cancellable set true.
	SetCheckCancellable(checkCancellable bool)
	// SetName sets @task’s name, used in debugging and profiling. The name
	// defaults to nil.
	//
	// The task name should describe in a human readable way what the task does.
	// For example, ‘Open file’ or ‘Connect to network host’. It is used to set
	// the name of the #GSource used for idle completion of the task.
	//
	// This function may only be called before the @task is first used in a
	// thread other than the one it was constructed in.
	SetName(name string)
	// SetPriority sets @task's priority. If you do not call this, it will
	// default to G_PRIORITY_DEFAULT.
	//
	// This will affect the priority of #GSources created with
	// g_task_attach_source() and the scheduling of tasks run in threads, and
	// can also be explicitly retrieved later via g_task_get_priority().
	SetPriority(priority int)
	// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
	// only meaningful for tasks run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync().
	//
	// If @return_on_cancel is true, then cancelling @task's #GCancellable will
	// immediately cause it to return, as though the task's ThreadFunc had
	// called g_task_return_error_if_cancelled() and then returned.
	//
	// This allows you to create a cancellable wrapper around an uninterruptible
	// function. The ThreadFunc just needs to be careful that it does not modify
	// any externally-visible state after it has been cancelled. To do that, the
	// thread should call g_task_set_return_on_cancel() again to (atomically)
	// set return-on-cancel false before making externally-visible changes; if
	// the task gets cancelled before the return-on-cancel flag could be
	// changed, g_task_set_return_on_cancel() will indicate this by returning
	// false.
	//
	// You can disable and re-enable this flag multiple times if you wish. If
	// the task's #GCancellable is cancelled while return-on-cancel is false,
	// then calling g_task_set_return_on_cancel() to set it true again will
	// cause the task to be cancelled at that point.
	//
	// If the task's #GCancellable is already cancelled before you call
	// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
	// will still be run (for consistency), but the task will also be completed
	// right away.
	SetReturnOnCancel(returnOnCancel bool) bool
	// SetSourceTag sets @task's source tag. You can use this to tag a task
	// return value with a particular pointer (usually a pointer to the function
	// doing the tagging) and then later check it using g_task_get_source_tag()
	// (or g_async_result_is_tagged()) in the task's "finish" function, to
	// figure out if the response came from a particular place.
	SetSourceTag(sourceTag interface{})
	// SetTaskData sets @task's task data (freeing the existing task data, if
	// any).
	SetTaskData(taskData interface{})
}

// task implements the Task interface.
type task struct {
	gextras.Objector
	AsyncResult
}

var _ Task = (*task)(nil)

// WrapTask wraps a GObject to the right type. It is
// primarily used internally.
func WrapTask(obj *externglib.Object) Task {
	return Task{
		Objector:    obj,
		AsyncResult: WrapAsyncResult(obj),
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTask(obj), nil
}

// NewTask constructs a class Task.
func NewTask(sourceObject gextras.Objector, cancellable Cancellable, callback AsyncReadyCallback) Task {
	var arg1 C.gpointer
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg1 = (*C.GObject)(sourceObject.Native())
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	ret := C.g_task_new(arg1, arg2, arg3, arg4)

	var ret0 Task

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Task)

	return ret0
}

// Cancellable gets @task's #GCancellable
func (t task) Cancellable() Cancellable {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_cancellable(arg0)

	var ret0 Cancellable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Cancellable)

	return ret0
}

// CheckCancellable gets @task's check-cancellable flag. See
// g_task_set_check_cancellable() for more details.
func (t task) CheckCancellable() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_check_cancellable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Completed gets the value of #GTask:completed. This changes from false to
// true after the task’s callback is invoked, and will return false if
// called from inside the callback.
func (t task) Completed() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_completed(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Context gets the Context that @task will return its result in (that is,
// the context that was the [thread-default main
// context][g-main-context-push-thread-default] at the point when @task was
// created).
//
// This will always return a non-nil value, even if the task's context is
// the default Context.
func (t task) Context() *glib.MainContext {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_context(arg0)

	var ret0 *glib.MainContext

	{
		ret0 = glib.WrapMainContext(unsafe.Pointer(ret))
	}

	return ret0
}

// Name gets @task’s name. See g_task_set_name().
func (t task) Name() string {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Priority gets @task's priority
func (t task) Priority() int {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ReturnOnCancel gets @task's return-on-cancel flag. See
// g_task_set_return_on_cancel() for more details.
func (t task) ReturnOnCancel() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_return_on_cancel(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SourceObject gets the source object from @task. Like
// g_async_result_get_source_object(), but does not ref the object.
func (t task) SourceObject() gextras.Objector {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_source_object(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// SourceTag gets @task's source tag. See g_task_set_source_tag().
func (t task) SourceTag() interface{} {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_source_tag(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TaskData gets @task's `task_data`.
func (t task) TaskData() interface{} {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_get_task_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// HadError tests if @task resulted in an error.
func (t task) HadError() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_had_error(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PropagateBoolean gets the result of @task as a #gboolean.
//
// If the task resulted in an error, or was cancelled, then this will
// instead return false and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (t task) PropagateBoolean() error {
	var arg0 *C.GTask
	var gError *C.GError

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_propagate_boolean(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// PropagateInt gets the result of @task as an integer (#gssize).
//
// If the task resulted in an error, or was cancelled, then this will
// instead return -1 and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (t task) PropagateInt() (gssize int, err error) {
	var arg0 *C.GTask
	var gError *C.GError

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_propagate_int(arg0, &gError)

	var ret0 int
	var goError error

	ret0 = int(ret)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// PropagatePointer gets the result of @task as a pointer, and transfers
// ownership of that value to the caller.
//
// If the task resulted in an error, or was cancelled, then this will
// instead return nil and set @error.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (t task) PropagatePointer() (gpointer interface{}, err error) {
	var arg0 *C.GTask
	var gError *C.GError

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_propagate_pointer(arg0, &gError)

	var ret0 interface{}
	var goError error

	ret0 = box.Get(uintptr(ret)).(interface{})

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// PropagateValue gets the result of @task as a #GValue, and transfers
// ownership of that value to the caller. As with g_task_return_value(),
// this is a generic low-level method; g_task_propagate_pointer() and the
// like will usually be more useful for C code.
//
// If the task resulted in an error, or was cancelled, then this will
// instead set @error and return false.
//
// Since this method transfers ownership of the return value (or error) to
// the caller, you may only call it once.
func (t task) PropagateValue() (value externglib.Value, err error) {
	var arg0 *C.GTask
	var arg1 *C.GValue // out
	var gError *C.GError

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_propagate_value(arg0, &arg1, &gError)

	var ret0 *externglib.Value
	var goError error

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg1))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReturnBoolean sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
func (t task) ReturnBoolean(result bool) {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(t.Native())
	if result {
		arg1 = C.TRUE
	}

	C.g_task_return_boolean(arg0, arg1)
}

// ReturnError sets @task's result to @error (which @task assumes ownership
// of) and completes the task (see g_task_return_pointer() for more
// discussion of exactly what this means).
//
// Note that since the task takes ownership of @error, and since the task
// may be completed before returning from g_task_return_error(), you cannot
// assume that @error is still valid after calling this. Call g_error_copy()
// on the error if you need to keep a local copy as well.
//
// See also g_task_return_new_error().
func (t task) ReturnError(error *glib.Error) {
	var arg0 *C.GTask
	var arg1 *C.GError

	arg0 = (*C.GTask)(t.Native())
	arg1 = (*C.GError)(error.Native())

	C.g_task_return_error(arg0, arg1)
}

// ReturnErrorIfCancelled checks if @task's #GCancellable has been
// cancelled, and if so, sets @task's error accordingly and completes the
// task (see g_task_return_pointer() for more discussion of exactly what
// this means).
func (t task) ReturnErrorIfCancelled() bool {
	var arg0 *C.GTask

	arg0 = (*C.GTask)(t.Native())

	ret := C.g_task_return_error_if_cancelled(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ReturnInt sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this means).
func (t task) ReturnInt(result int) {
	var arg0 *C.GTask
	var arg1 C.gssize

	arg0 = (*C.GTask)(t.Native())
	arg1 = C.gssize(result)

	C.g_task_return_int(arg0, arg1)
}

// ReturnPointer sets @task's result to @result and completes the task. If
// @result is not nil, then @result_destroy will be used to free @result if
// the caller does not take ownership of it with g_task_propagate_pointer().
//
// "Completes the task" means that for an ordinary asynchronous task it will
// either invoke the task's callback, or else queue that callback to be
// invoked in the proper Context, or in the next iteration of the current
// Context. For a task run via g_task_run_in_thread() or
// g_task_run_in_thread_sync(), calling this method will save @result to be
// returned to the caller later, but the task will not actually be completed
// until the ThreadFunc exits.
//
// Note that since the task may be completed before returning from
// g_task_return_pointer(), you cannot assume that @result is still valid
// after calling this, unless you are still holding another reference on it.
func (t task) ReturnPointer(result interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer
	var arg2 C.GDestroyNotify

	arg0 = (*C.GTask)(t.Native())
	arg1 = C.gpointer(box.Assign(result))

	C.g_task_return_pointer(arg0, arg1, arg2)
}

// ReturnValue sets @task's result to @result (by copying it) and completes
// the task.
//
// If @result is nil then a #GValue of type TYPE_POINTER with a value of nil
// will be used for the result.
//
// This is a very generic low-level method intended primarily for use by
// language bindings; for C code, g_task_return_pointer() and the like will
// normally be much easier to use.
func (t task) ReturnValue(result *externglib.Value) {
	var arg0 *C.GTask
	var arg1 *C.GValue

	arg0 = (*C.GTask)(t.Native())
	arg1 = (*C.GValue)(result.GValue)

	C.g_task_return_value(arg0, arg1)
}

// SetCheckCancellable sets or clears @task's check-cancellable flag. If
// this is true (the default), then g_task_propagate_pointer(), etc, and
// g_task_had_error() will check the task's #GCancellable first, and if it
// has been cancelled, then they will consider the task to have returned an
// "Operation was cancelled" error (G_IO_ERROR_CANCELLED), regardless of any
// other error or return value the task may have had.
//
// If @check_cancellable is false, then the #GTask will not check the
// cancellable itself, and it is up to @task's owner to do this (eg, via
// g_task_return_error_if_cancelled()).
//
// If you are using g_task_set_return_on_cancel() as well, then you must
// leave check-cancellable set true.
func (t task) SetCheckCancellable(checkCancellable bool) {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(t.Native())
	if checkCancellable {
		arg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(arg0, arg1)
}

// SetName sets @task’s name, used in debugging and profiling. The name
// defaults to nil.
//
// The task name should describe in a human readable way what the task does.
// For example, ‘Open file’ or ‘Connect to network host’. It is used to set
// the name of the #GSource used for idle completion of the task.
//
// This function may only be called before the @task is first used in a
// thread other than the one it was constructed in.
func (t task) SetName(name string) {
	var arg0 *C.GTask
	var arg1 *C.gchar

	arg0 = (*C.GTask)(t.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_task_set_name(arg0, arg1)
}

// SetPriority sets @task's priority. If you do not call this, it will
// default to G_PRIORITY_DEFAULT.
//
// This will affect the priority of #GSources created with
// g_task_attach_source() and the scheduling of tasks run in threads, and
// can also be explicitly retrieved later via g_task_get_priority().
func (t task) SetPriority(priority int) {
	var arg0 *C.GTask
	var arg1 C.gint

	arg0 = (*C.GTask)(t.Native())
	arg1 = C.gint(priority)

	C.g_task_set_priority(arg0, arg1)
}

// SetReturnOnCancel sets or clears @task's return-on-cancel flag. This is
// only meaningful for tasks run via g_task_run_in_thread() or
// g_task_run_in_thread_sync().
//
// If @return_on_cancel is true, then cancelling @task's #GCancellable will
// immediately cause it to return, as though the task's ThreadFunc had
// called g_task_return_error_if_cancelled() and then returned.
//
// This allows you to create a cancellable wrapper around an uninterruptible
// function. The ThreadFunc just needs to be careful that it does not modify
// any externally-visible state after it has been cancelled. To do that, the
// thread should call g_task_set_return_on_cancel() again to (atomically)
// set return-on-cancel false before making externally-visible changes; if
// the task gets cancelled before the return-on-cancel flag could be
// changed, g_task_set_return_on_cancel() will indicate this by returning
// false.
//
// You can disable and re-enable this flag multiple times if you wish. If
// the task's #GCancellable is cancelled while return-on-cancel is false,
// then calling g_task_set_return_on_cancel() to set it true again will
// cause the task to be cancelled at that point.
//
// If the task's #GCancellable is already cancelled before you call
// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the ThreadFunc
// will still be run (for consistency), but the task will also be completed
// right away.
func (t task) SetReturnOnCancel(returnOnCancel bool) bool {
	var arg0 *C.GTask
	var arg1 C.gboolean

	arg0 = (*C.GTask)(t.Native())
	if returnOnCancel {
		arg1 = C.TRUE
	}

	ret := C.g_task_set_return_on_cancel(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetSourceTag sets @task's source tag. You can use this to tag a task
// return value with a particular pointer (usually a pointer to the function
// doing the tagging) and then later check it using g_task_get_source_tag()
// (or g_async_result_is_tagged()) in the task's "finish" function, to
// figure out if the response came from a particular place.
func (t task) SetSourceTag(sourceTag interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer

	arg0 = (*C.GTask)(t.Native())
	arg1 = C.gpointer(box.Assign(sourceTag))

	C.g_task_set_source_tag(arg0, arg1)
}

// SetTaskData sets @task's task data (freeing the existing task data, if
// any).
func (t task) SetTaskData(taskData interface{}) {
	var arg0 *C.GTask
	var arg1 C.gpointer
	var arg2 C.GDestroyNotify

	arg0 = (*C.GTask)(t.Native())
	arg1 = C.gpointer(box.Assign(taskData))

	C.g_task_set_task_data(arg0, arg1, arg2)
}
