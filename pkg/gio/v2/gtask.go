// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_task_get_type()), F: marshalTask},
	})
}

// Task: a #GTask represents and manages a cancellable "task".
//
//
// Asynchronous operations
//
// The most common usage of #GTask is as a Result, to manage data during an
// asynchronous operation. You call g_task_new() in the "start" method, followed
// by g_task_set_task_data() and the like if you need to keep some additional
// data associated with the task, and then pass the task object around through
// your asynchronous operation. Eventually, you will call a method such as
// g_task_return_pointer() or g_task_return_error(), which will save the value
// you give it and then invoke the task's callback function in the
// [thread-default main context][g-main-context-push-thread-default] where it
// was created (waiting until the next iteration of the main loop first, if
// necessary). The caller will pass the #GTask back to the operation's finish
// function (as a Result), and you can use g_task_propagate_pointer() or the
// like to extract the return value.
//
// Here is an example for using GTask as a GAsyncResult:
//
//        static void
//        bake_cake_thread (GTask         *task,
//                          gpointer       source_object,
//                          gpointer       task_data,
//                          GCancellable  *cancellable)
//        {
//          Baker *self = source_object;
//          CakeData *cake_data = task_data;
//          Cake *cake;
//          GError *error = NULL;
//
//          cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
//                            cake_data->frosting, cake_data->message,
//                            &error);
//          if (error)
//            {
//              g_task_return_error (task, error);
//              return;
//            }
//
//          // If the task has already been cancelled, then we don't want to add
//          // the cake to the cake cache. Likewise, we don't  want to have the
//          // task get cancelled in the middle of updating the cache.
//          // g_task_set_return_on_cancel() will return true here if it managed
//          // to disable return-on-cancel, or false if the task was cancelled
//          // before it could.
//          if (g_task_set_return_on_cancel (task, FALSE))
//            {
//              // If the caller cancels at this point, their
//              // GAsyncReadyCallback won't be invoked until we return,
//              // so we don't have to worry that this code will run at
//              // the same time as that code does. But if there were
//              // other functions that might look at the cake cache,
//              // then we'd probably need a GMutex here as well.
//              baker_add_cake_to_cache (baker, cake);
//              g_task_return_pointer (task, cake, g_object_unref);
//            }
//        }
//
//        void
//        baker_bake_cake_async (Baker               *self,
//                               guint                radius,
//                               CakeFlavor           flavor,
//                               CakeFrostingType     frosting,
//                               const char          *message,
//                               GCancellable        *cancellable,
//                               GAsyncReadyCallback  callback,
//                               gpointer             user_data)
//        {
//          CakeData *cake_data;
//          GTask *task;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, callback, user_data);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread (task, bake_cake_thread);
//        }
//
//        Cake *
//        baker_bake_cake_sync (Baker               *self,
//                              guint                radius,
//                              CakeFlavor           flavor,
//                              CakeFrostingType     frosting,
//                              const char          *message,
//                              GCancellable        *cancellable,
//                              GError             **error)
//        {
//          CakeData *cake_data;
//          GTask *task;
//          Cake *cake;
//
//          cake_data = g_slice_new (CakeData);
//
//          ...
//
//          task = g_task_new (self, cancellable, NULL, NULL);
//          g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//          g_task_set_return_on_cancel (task, TRUE);
//          g_task_run_in_thread_sync (task, bake_cake_thread);
//
//          cake = g_task_propagate_pointer (task, error);
//          g_object_unref (task);
//          return cake;
//        }
//
//
// Porting from GSimpleAsyncResult
//
// #GTask's API attempts to be simpler than AsyncResult's in several ways: - You
// can save task-specific data with g_task_set_task_data(), and retrieve it
// later with g_task_get_task_data(). This replaces the abuse of
// g_simple_async_result_set_op_res_gpointer() for the same purpose with
// AsyncResult. - In addition to the task data, #GTask also keeps track of the
// [priority][io-priority], #GCancellable, and Context associated with the task,
// so tasks that consist of a chain of simpler asynchronous operations will have
// easy access to those values when starting each sub-task. -
// g_task_return_error_if_cancelled() provides simplified handling for
// cancellation. In addition, cancellation overrides any other #GTask return
// value by default, like AsyncResult does when
// g_simple_async_result_set_check_cancellable() is called. (You can use
// g_task_set_check_cancellable() to turn off that behavior.) On the other hand,
// g_task_run_in_thread() guarantees that it will always run your `task_func`,
// even if the task's #GCancellable is already cancelled before the task gets a
// chance to run; you can start your `task_func` with a
// g_task_return_error_if_cancelled() check if you need the old behavior. - The
// "return" methods (eg, g_task_return_pointer()) automatically cause the task
// to be "completed" as well, and there is no need to worry about the "complete"
// vs "complete in idle" distinction. (#GTask automatically figures out whether
// the task's callback can be invoked directly, or if it needs to be sent to
// another Context, or delayed until the next iteration of the current Context.)
// - The "finish" functions for #GTask based operations are generally much
// simpler than AsyncResult ones, normally consisting of only a single call to
// g_task_propagate_pointer() or the like. Since g_task_propagate_pointer()
// "steals" the return value from the #GTask, it is not necessary to juggle
// pointers around to prevent it from being freed twice. - With AsyncResult, it
// was common to call g_simple_async_result_propagate_error() from the
// `_finish()` wrapper function, and have virtual method implementations only
// deal with successful returns. This behavior is deprecated, because it makes
// it difficult for a subclass to chain to a parent class's async methods.
// Instead, the wrapper function should just be a simple wrapper, and the
// virtual method should call an appropriate `g_task_propagate_` function. Note
// that wrapper methods can now use g_async_result_legacy_propagate_error() to
// do old-style AsyncResult error-returning behavior, and
// g_async_result_is_tagged() to check if a result is tagged as having come from
// the `_async()` wrapper function (for "short-circuit" results, such as when
// passing 0 to g_input_stream_read_async()).
type Task interface {
	AsyncResult

	Cancellable() Cancellable

	CheckCancellable() bool

	Completed() bool

	Context() *glib.MainContext

	Name() string

	Priority() int

	ReturnOnCancel() bool

	GetSourceObject() gextras.Objector

	SourceTag() interface{}

	TaskData() interface{}

	HadErrorTask() bool

	PropagateBooleanTask() error

	PropagateIntTask() (int, error)

	PropagatePointerTask() (interface{}, error)

	PropagateValueTask() (externglib.Value, error)

	ReturnBooleanTask(result bool)

	ReturnErrorTask(err error)

	ReturnErrorIfCancelledTask() bool

	ReturnIntTask(result int)

	ReturnValueTask(result externglib.Value)

	SetCheckCancellableTask(checkCancellable bool)

	SetNameTask(name string)

	SetPriorityTask(priority int)

	SetReturnOnCancelTask(returnOnCancel bool) bool

	SetSourceTagTask(sourceTag interface{})
}

// task implements the Task class.
type task struct {
	gextras.Objector
}

// WrapTask wraps a GObject to the right type. It is
// primarily used internally.
func WrapTask(obj *externglib.Object) Task {
	return task{
		Objector: obj,
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTask(obj), nil
}

func NewTask(sourceObject gextras.Objector, cancellable Cancellable, callback AsyncReadyCallback) Task {
	var _arg1 C.gpointer            // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer
	var _cret *C.GTask // in

	_arg1 = (C.gpointer)(unsafe.Pointer(sourceObject.Native()))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	_cret = C.g_task_new(_arg1, _arg2, _arg3, _arg4)

	var _task Task // out

	_task = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Task)

	return _task
}

func (t task) Cancellable() Cancellable {
	var _arg0 *C.GTask        // out
	var _cret *C.GCancellable // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_cancellable(_arg0)

	var _cancellable Cancellable // out

	_cancellable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cancellable)

	return _cancellable
}

func (t task) CheckCancellable() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_check_cancellable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) Completed() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_completed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) Context() *glib.MainContext {
	var _arg0 *C.GTask        // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_context(_arg0)

	var _mainContext *glib.MainContext // out

	_mainContext = (*glib.MainContext)(unsafe.Pointer(_cret))

	return _mainContext
}

func (t task) Name() string {
	var _arg0 *C.GTask // out
	var _cret *C.gchar // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (t task) Priority() int {
	var _arg0 *C.GTask // out
	var _cret C.gint   // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_priority(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t task) ReturnOnCancel() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_return_on_cancel(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) GetSourceObject() gextras.Objector {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_source_object(_arg0)

	var _object gextras.Objector // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gextras.Objector)

	return _object
}

func (t task) SourceTag() interface{} {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_source_tag(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

func (t task) TaskData() interface{} {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_get_task_data(_arg0)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

func (t task) HadErrorTask() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_had_error(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) PropagateBooleanTask() error {
	var _arg0 *C.GTask  // out
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	C.g_task_propagate_boolean(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (t task) PropagateIntTask() (int, error) {
	var _arg0 *C.GTask  // out
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_propagate_int(_arg0, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (t task) PropagatePointerTask() (interface{}, error) {
	var _arg0 *C.GTask   // out
	var _cret C.gpointer // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_propagate_pointer(_arg0, &_cerr)

	var _gpointer interface{} // out
	var _goerr error          // out

	_gpointer = box.Get(uintptr(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gpointer, _goerr
}

func (t task) PropagateValueTask() (externglib.Value, error) {
	var _arg0 *C.GTask  // out
	var _arg1 C.GValue  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	C.g_task_propagate_value(_arg0, &_arg1, &_cerr)

	var _value externglib.Value // out
	var _goerr error            // out

	{
		var refTmpIn *C.GValue
		var refTmpOut *externglib.Value

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = externglib.ValueFromNative(unsafe.Pointer(refTmpIn))

		_value = *refTmpOut
	}
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (t task) ReturnBooleanTask(result bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if result {
		_arg1 = C.TRUE
	}

	C.g_task_return_boolean(_arg0, _arg1)
}

func (t task) ReturnErrorTask(err error) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GError // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GError)(gerror.New(err))

	C.g_task_return_error(_arg0, _arg1)
}

func (t task) ReturnErrorIfCancelledTask() bool {
	var _arg0 *C.GTask   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))

	_cret = C.g_task_return_error_if_cancelled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) ReturnIntTask(result int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gssize // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = C.gssize(result)

	C.g_task_return_int(_arg0, _arg1)
}

func (t task) ReturnValueTask(result externglib.Value) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GValue // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GValue)(unsafe.Pointer(&result.GValue))

	C.g_task_return_value(_arg0, _arg1)
}

func (t task) SetCheckCancellableTask(checkCancellable bool) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if checkCancellable {
		_arg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(_arg0, _arg1)
}

func (t task) SetNameTask(name string) {
	var _arg0 *C.GTask // out
	var _arg1 *C.gchar // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_task_set_name(_arg0, _arg1)
}

func (t task) SetPriorityTask(priority int) {
	var _arg0 *C.GTask // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(priority)

	C.g_task_set_priority(_arg0, _arg1)
}

func (t task) SetReturnOnCancelTask(returnOnCancel bool) bool {
	var _arg0 *C.GTask   // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	if returnOnCancel {
		_arg1 = C.TRUE
	}

	_cret = C.g_task_set_return_on_cancel(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t task) SetSourceTagTask(sourceTag interface{}) {
	var _arg0 *C.GTask   // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GTask)(unsafe.Pointer(t.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(sourceTag)))

	C.g_task_set_source_tag(_arg0, _arg1)
}

func (r task) SourceObject() gextras.Objector {
	return WrapAsyncResult(gextras.InternObject(r)).SourceObject()
}

func (r task) UserData() interface{} {
	return WrapAsyncResult(gextras.InternObject(r)).UserData()
}

func (r task) IsTagged(sourceTag interface{}) bool {
	return WrapAsyncResult(gextras.InternObject(r)).IsTagged(sourceTag)
}

func (r task) LegacyPropagateError() error {
	return WrapAsyncResult(gextras.InternObject(r)).LegacyPropagateError()
}
