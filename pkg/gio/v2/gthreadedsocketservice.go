// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_threaded_socket_service_get_type()), F: marshalThreadedSocketService},
	})
}

// ThreadedSocketServiceOverrider contains methods that are overridable .
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ThreadedSocketServiceOverrider interface {
	Run(connection SocketConnection, sourceObject gextras.Objector) bool
}

// ThreadedSocketService is a simple subclass of Service that handles incoming
// connections by creating a worker thread and dispatching the connection to it
// by emitting the SocketService::run signal in the new thread.
//
// The signal handler may perform blocking IO and need not return until the
// connection is closed.
//
// The service is implemented using a thread pool, so there is a limited amount
// of threads available to serve incoming requests. The service automatically
// stops the Service from accepting new connections when all threads are busy.
//
// As with Service, you may connect to SocketService::run, or subclass and
// override the default handler.
type ThreadedSocketService interface {
	SocketService

	// AsSocketService casts the class to the SocketService interface.
	AsSocketService() SocketService

	// IsActive: check whether the service is active or not. An active service
	// will accept new clients that connect, while a non-active service will let
	// connecting clients queue up until the service is started.
	//
	// This method is inherited from SocketService
	IsActive() bool
	// Start restarts the service, i.e. start accepting connections from the
	// added sockets when the mainloop runs. This only needs to be called after
	// the service has been stopped from g_socket_service_stop().
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// This method is inherited from SocketService
	Start()
	// Stop stops the service, i.e. stops accepting connections from the added
	// sockets when the mainloop runs.
	//
	// This call is thread-safe, so it may be called from a thread handling an
	// incoming client request.
	//
	// Note that this only stops accepting new connections; it does not close
	// the listening sockets, and you can call g_socket_service_start() again
	// later to begin listening again. To close the listening sockets, call
	// g_socket_listener_close(). (This will happen automatically when the
	// Service is finalized.)
	//
	// This must be called before calling g_socket_listener_close() as the
	// socket service will start accepting connections immediately when a new
	// socket is added.
	//
	// This method is inherited from SocketService
	Stop()
	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// This method is inherited from SocketListener
	Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error)
	// AcceptAsync: this is the asynchronous version of
	// g_socket_listener_accept().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket() to get the result of the
	// operation.
	//
	// This method is inherited from SocketListener
	AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptFinish finishes an async accept operation. See
	// g_socket_listener_accept_async()
	//
	// This method is inherited from SocketListener
	AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// This method is inherited from SocketListener
	AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error)
	// AcceptSocketAsync: this is the asynchronous version of
	// g_socket_listener_accept_socket().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket_finish() to get the result of the
	// operation.
	//
	// This method is inherited from SocketListener
	AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptSocketFinish finishes an async accept operation. See
	// g_socket_listener_accept_socket_async()
	//
	// This method is inherited from SocketListener
	AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	//
	// This method is inherited from SocketListener
	AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// This method is inherited from SocketListener
	AddAnyInetPort(sourceObject gextras.Objector) (uint16, error)
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	//
	// This method is inherited from SocketListener
	AddInetPort(port uint16, sourceObject gextras.Objector) error
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	//
	// This method is inherited from SocketListener
	AddSocket(socket Socket, sourceObject gextras.Objector) error
	// Close closes all the sockets in the listener.
	//
	// This method is inherited from SocketListener
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	//
	// This method is inherited from SocketListener
	SetBacklog(listenBacklog int)
}

// threadedSocketService implements the ThreadedSocketService interface.
type threadedSocketService struct {
	*externglib.Object
}

var _ ThreadedSocketService = (*threadedSocketService)(nil)

// WrapThreadedSocketService wraps a GObject to a type that implements
// interface ThreadedSocketService. It is primarily used internally.
func WrapThreadedSocketService(obj *externglib.Object) ThreadedSocketService {
	return threadedSocketService{obj}
}

func marshalThreadedSocketService(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapThreadedSocketService(obj), nil
}

// NewThreadedSocketService creates a new SocketService with no listeners.
// Listeners must be added with one of the Listener "add" methods.
func NewThreadedSocketService(maxThreads int) ThreadedSocketService {
	var _arg1 C.int             // out
	var _cret *C.GSocketService // in

	_arg1 = C.int(maxThreads)

	_cret = C.g_threaded_socket_service_new(_arg1)

	var _threadedSocketService ThreadedSocketService // out

	_threadedSocketService = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ThreadedSocketService)

	return _threadedSocketService
}

func (t threadedSocketService) AsSocketService() SocketService {
	return WrapSocketService(gextras.InternObject(t))
}

func (s threadedSocketService) IsActive() bool {
	return WrapSocketService(gextras.InternObject(s)).IsActive()
}

func (s threadedSocketService) Start() {
	WrapSocketService(gextras.InternObject(s)).Start()
}

func (s threadedSocketService) Stop() {
	WrapSocketService(gextras.InternObject(s)).Stop()
}

func (l threadedSocketService) Accept(cancellable Cancellable) (gextras.Objector, SocketConnection, error) {
	return WrapSocketListener(gextras.InternObject(l)).Accept(cancellable)
}

func (l threadedSocketService) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapSocketListener(gextras.InternObject(l)).AcceptAsync(cancellable, callback)
}

func (l threadedSocketService) AcceptFinish(result AsyncResult) (gextras.Objector, SocketConnection, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptFinish(result)
}

func (l threadedSocketService) AcceptSocket(cancellable Cancellable) (gextras.Objector, Socket, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptSocket(cancellable)
}

func (l threadedSocketService) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapSocketListener(gextras.InternObject(l)).AcceptSocketAsync(cancellable, callback)
}

func (l threadedSocketService) AcceptSocketFinish(result AsyncResult) (gextras.Objector, Socket, error) {
	return WrapSocketListener(gextras.InternObject(l)).AcceptSocketFinish(result)
}

func (l threadedSocketService) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (SocketAddress, error) {
	return WrapSocketListener(gextras.InternObject(l)).AddAddress(address, typ, protocol, sourceObject)
}

func (l threadedSocketService) AddAnyInetPort(sourceObject gextras.Objector) (uint16, error) {
	return WrapSocketListener(gextras.InternObject(l)).AddAnyInetPort(sourceObject)
}

func (l threadedSocketService) AddInetPort(port uint16, sourceObject gextras.Objector) error {
	return WrapSocketListener(gextras.InternObject(l)).AddInetPort(port, sourceObject)
}

func (l threadedSocketService) AddSocket(socket Socket, sourceObject gextras.Objector) error {
	return WrapSocketListener(gextras.InternObject(l)).AddSocket(socket, sourceObject)
}

func (l threadedSocketService) Close() {
	WrapSocketListener(gextras.InternObject(l)).Close()
}

func (l threadedSocketService) SetBacklog(listenBacklog int) {
	WrapSocketListener(gextras.InternObject(l)).SetBacklog(listenBacklog)
}
