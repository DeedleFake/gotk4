// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gerror"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_dbus_annotation_info_get_type()), F: marshalDBusAnnotationInfo},
		{T: externglib.Type(C.g_dbus_arg_info_get_type()), F: marshalDBusArgInfo},
		{T: externglib.Type(C.g_dbus_interface_info_get_type()), F: marshalDBusInterfaceInfo},
		{T: externglib.Type(C.g_dbus_method_info_get_type()), F: marshalDBusMethodInfo},
		{T: externglib.Type(C.g_dbus_node_info_get_type()), F: marshalDBusNodeInfo},
		{T: externglib.Type(C.g_dbus_property_info_get_type()), F: marshalDBusPropertyInfo},
		{T: externglib.Type(C.g_dbus_signal_info_get_type()), F: marshalDBusSignalInfo},
	})
}

// DBusAnnotationInfoLookup looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
func DBusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string {
	var arg1 **C.GDBusAnnotationInfo
	var arg2 *C.gchar

	arg1 = C.malloc(len(annotations) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg1))

	{
		var out []*C.GDBusAnnotationInfo
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg1), int(len(annotations)))

		for i := range annotations {
			out[i] = (*C.GDBusAnnotationInfo)(unsafe.Pointer(annotations[i].Native()))
		}
	}
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret *C.gchar
	var ret1 string

	cret = C.g_dbus_annotation_info_lookup(annotations, name)

	ret1 = C.GoString(cret)

	return ret1
}

// DBusAnnotationInfo: information about an annotation.
type DBusAnnotationInfo struct {
	native C.GDBusAnnotationInfo
}

// WrapDBusAnnotationInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusAnnotationInfo(ptr unsafe.Pointer) *DBusAnnotationInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusAnnotationInfo)(ptr)
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusAnnotationInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusAnnotationInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusAnnotationInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Key gets the field inside the struct.
func (d *DBusAnnotationInfo) Key() string {
	v = C.GoString(d.native.key)
}

// Value gets the field inside the struct.
func (d *DBusAnnotationInfo) Value() string {
	v = C.GoString(d.native.value)
}

// Annotations gets the field inside the struct.
func (d *DBusAnnotationInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusAnnotationInfo) Ref() *DBusAnnotationInfo {
	var arg0 *C.GDBusAnnotationInfo

	arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusAnnotationInfo
	var ret1 *DBusAnnotationInfo

	cret = C.g_dbus_annotation_info_ref(arg0)

	ret1 = WrapDBusAnnotationInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusAnnotationInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusAnnotationInfo) Unref() {
	var arg0 *C.GDBusAnnotationInfo

	arg0 = (*C.GDBusAnnotationInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_annotation_info_unref(arg0)
}

// DBusArgInfo: information about an argument for a method or a signal.
type DBusArgInfo struct {
	native C.GDBusArgInfo
}

// WrapDBusArgInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusArgInfo(ptr unsafe.Pointer) *DBusArgInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusArgInfo)(ptr)
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusArgInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusArgInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusArgInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Name gets the field inside the struct.
func (d *DBusArgInfo) Name() string {
	v = C.GoString(d.native.name)
}

// Signature gets the field inside the struct.
func (d *DBusArgInfo) Signature() string {
	v = C.GoString(d.native.signature)
}

// Annotations gets the field inside the struct.
func (d *DBusArgInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusArgInfo) Ref() *DBusArgInfo {
	var arg0 *C.GDBusArgInfo

	arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusArgInfo
	var ret1 *DBusArgInfo

	cret = C.g_dbus_arg_info_ref(arg0)

	ret1 = WrapDBusArgInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusArgInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusArgInfo) Unref() {
	var arg0 *C.GDBusArgInfo

	arg0 = (*C.GDBusArgInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_arg_info_unref(arg0)
}

// DBusInterfaceInfo: information about a D-Bus interface.
type DBusInterfaceInfo struct {
	native C.GDBusInterfaceInfo
}

// WrapDBusInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusInterfaceInfo(ptr unsafe.Pointer) *DBusInterfaceInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusInterfaceInfo)(ptr)
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusInterfaceInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusInterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusInterfaceInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Name gets the field inside the struct.
func (d *DBusInterfaceInfo) Name() string {
	v = C.GoString(d.native.name)
}

// Methods gets the field inside the struct.
func (d *DBusInterfaceInfo) Methods() []*DBusMethodInfo {
	{
		var length int
		for p := d.native.methods; *p != 0; p = (**C.GDBusMethodInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusMethodInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusMethodInfo)(ptr.Add(unsafe.Pointer(d.native.methods), i))
			v[i] = WrapDBusMethodInfo(unsafe.Pointer(src))
		}
	}
}

// Signals gets the field inside the struct.
func (d *DBusInterfaceInfo) Signals() []*DBusSignalInfo {
	{
		var length int
		for p := d.native.signals; *p != 0; p = (**C.GDBusSignalInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusSignalInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusSignalInfo)(ptr.Add(unsafe.Pointer(d.native.signals), i))
			v[i] = WrapDBusSignalInfo(unsafe.Pointer(src))
		}
	}
}

// Properties gets the field inside the struct.
func (d *DBusInterfaceInfo) Properties() []*DBusPropertyInfo {
	{
		var length int
		for p := d.native.properties; *p != 0; p = (**C.GDBusPropertyInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusPropertyInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusPropertyInfo)(ptr.Add(unsafe.Pointer(d.native.properties), i))
			v[i] = WrapDBusPropertyInfo(unsafe.Pointer(src))
		}
	}
}

// Annotations gets the field inside the struct.
func (d *DBusInterfaceInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
//
// If this has already been called with @info, the existing cache is used and
// its use count is increased.
//
// Note that @info cannot be modified until
// g_dbus_interface_info_cache_release() is called.
func (i *DBusInterfaceInfo) CacheBuild() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_cache_build(arg0)
}

// CacheRelease decrements the usage count for the cache for @info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
func (i *DBusInterfaceInfo) CacheRelease() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_cache_release(arg0)
}

// GenerateXml appends an XML representation of @info (and its children) to
// @string_builder.
//
// This function is typically used for generating introspection XML documents at
// run-time for handling the `org.freedesktop.DBus.Introspectable.Introspect`
// method.
func (i *DBusInterfaceInfo) GenerateXml(indent uint, stringBuilder *glib.String) {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 C.guint
	var arg2 *C.GString

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	arg1 = C.guint(indent)
	arg2 = (*C.GString)(unsafe.Pointer(stringBuilder.Native()))

	C.g_dbus_interface_info_generate_xml(arg0, indent, stringBuilder)
}

// LookupMethod looks up information about a method.
//
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GDBusMethodInfo
	var ret1 *DBusMethodInfo

	cret = C.g_dbus_interface_info_lookup_method(arg0, name)

	ret1 = WrapDBusMethodInfo(unsafe.Pointer(cret))

	return ret1
}

// LookupProperty looks up information about a property.
//
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GDBusPropertyInfo
	var ret1 *DBusPropertyInfo

	cret = C.g_dbus_interface_info_lookup_property(arg0, name)

	ret1 = WrapDBusPropertyInfo(unsafe.Pointer(cret))

	return ret1
}

// LookupSignal looks up information about a signal.
//
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on @info.
func (i *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	var arg0 *C.GDBusInterfaceInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GDBusSignalInfo
	var ret1 *DBusSignalInfo

	cret = C.g_dbus_interface_info_lookup_signal(arg0, name)

	ret1 = WrapDBusSignalInfo(unsafe.Pointer(cret))

	return ret1
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusInterfaceInfo) Ref() *DBusInterfaceInfo {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusInterfaceInfo
	var ret1 *DBusInterfaceInfo

	cret = C.g_dbus_interface_info_ref(arg0)

	ret1 = WrapDBusInterfaceInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusInterfaceInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusInterfaceInfo) Unref() {
	var arg0 *C.GDBusInterfaceInfo

	arg0 = (*C.GDBusInterfaceInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_interface_info_unref(arg0)
}

// DBusMethodInfo: information about a method on an D-Bus interface.
type DBusMethodInfo struct {
	native C.GDBusMethodInfo
}

// WrapDBusMethodInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusMethodInfo(ptr unsafe.Pointer) *DBusMethodInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusMethodInfo)(ptr)
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusMethodInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusMethodInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusMethodInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Name gets the field inside the struct.
func (d *DBusMethodInfo) Name() string {
	v = C.GoString(d.native.name)
}

// InArgs gets the field inside the struct.
func (d *DBusMethodInfo) InArgs() []*DBusArgInfo {
	{
		var length int
		for p := d.native.in_args; *p != 0; p = (**C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusArgInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(d.native.in_args), i))
			v[i] = WrapDBusArgInfo(unsafe.Pointer(src))
		}
	}
}

// OutArgs gets the field inside the struct.
func (d *DBusMethodInfo) OutArgs() []*DBusArgInfo {
	{
		var length int
		for p := d.native.out_args; *p != 0; p = (**C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusArgInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(d.native.out_args), i))
			v[i] = WrapDBusArgInfo(unsafe.Pointer(src))
		}
	}
}

// Annotations gets the field inside the struct.
func (d *DBusMethodInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusMethodInfo) Ref() *DBusMethodInfo {
	var arg0 *C.GDBusMethodInfo

	arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusMethodInfo
	var ret1 *DBusMethodInfo

	cret = C.g_dbus_method_info_ref(arg0)

	ret1 = WrapDBusMethodInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusMethodInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusMethodInfo) Unref() {
	var arg0 *C.GDBusMethodInfo

	arg0 = (*C.GDBusMethodInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_method_info_unref(arg0)
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
type DBusNodeInfo struct {
	native C.GDBusNodeInfo
}

// WrapDBusNodeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusNodeInfo(ptr unsafe.Pointer) *DBusNodeInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusNodeInfo)(ptr)
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusNodeInfo(unsafe.Pointer(b)), nil
}

// NewDBusNodeInfoForXml constructs a struct DBusNodeInfo.
func NewDBusNodeInfoForXml(xmlData string) (dBusNodeInfo *DBusNodeInfo, err error) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(xmlData))
	defer C.free(unsafe.Pointer(arg1))

	var errout *C.GError
	var goerr error
	var cret *C.GDBusNodeInfo
	var ret2 *DBusNodeInfo

	cret = C.g_dbus_node_info_new_for_xml(xmlData, &errout)

	goerr = gerror.Take(unsafe.Pointer(errout))
	ret2 = WrapDBusNodeInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret2, func(v *DBusNodeInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return goerr, ret2
}

// Native returns the underlying C source pointer.
func (d *DBusNodeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusNodeInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Path gets the field inside the struct.
func (d *DBusNodeInfo) Path() string {
	v = C.GoString(d.native.path)
}

// Interfaces gets the field inside the struct.
func (d *DBusNodeInfo) Interfaces() []*DBusInterfaceInfo {
	{
		var length int
		for p := d.native.interfaces; *p != 0; p = (**C.GDBusInterfaceInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusInterfaceInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusInterfaceInfo)(ptr.Add(unsafe.Pointer(d.native.interfaces), i))
			v[i] = WrapDBusInterfaceInfo(unsafe.Pointer(src))
		}
	}
}

// Nodes gets the field inside the struct.
func (d *DBusNodeInfo) Nodes() []*DBusNodeInfo {
	{
		var length int
		for p := d.native.nodes; *p != 0; p = (**C.GDBusNodeInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusNodeInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusNodeInfo)(ptr.Add(unsafe.Pointer(d.native.nodes), i))
			v[i] = WrapDBusNodeInfo(unsafe.Pointer(src))
		}
	}
}

// Annotations gets the field inside the struct.
func (d *DBusNodeInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// GenerateXml appends an XML representation of @info (and its children) to
// @string_builder.
//
// This function is typically used for generating introspection XML documents at
// run-time for handling the `org.freedesktop.DBus.Introspectable.Introspect`
// method.
func (i *DBusNodeInfo) GenerateXml(indent uint, stringBuilder *glib.String) {
	var arg0 *C.GDBusNodeInfo
	var arg1 C.guint
	var arg2 *C.GString

	arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))
	arg1 = C.guint(indent)
	arg2 = (*C.GString)(unsafe.Pointer(stringBuilder.Native()))

	C.g_dbus_node_info_generate_xml(arg0, indent, stringBuilder)
}

// LookupInterface looks up information about an interface.
//
// The cost of this function is O(n) in number of interfaces.
func (i *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	var arg0 *C.GDBusNodeInfo
	var arg1 *C.gchar

	arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GDBusInterfaceInfo
	var ret1 *DBusInterfaceInfo

	cret = C.g_dbus_node_info_lookup_interface(arg0, name)

	ret1 = WrapDBusInterfaceInfo(unsafe.Pointer(cret))

	return ret1
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusNodeInfo) Ref() *DBusNodeInfo {
	var arg0 *C.GDBusNodeInfo

	arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusNodeInfo
	var ret1 *DBusNodeInfo

	cret = C.g_dbus_node_info_ref(arg0)

	ret1 = WrapDBusNodeInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusNodeInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusNodeInfo) Unref() {
	var arg0 *C.GDBusNodeInfo

	arg0 = (*C.GDBusNodeInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_node_info_unref(arg0)
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
type DBusPropertyInfo struct {
	native C.GDBusPropertyInfo
}

// WrapDBusPropertyInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusPropertyInfo(ptr unsafe.Pointer) *DBusPropertyInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusPropertyInfo)(ptr)
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusPropertyInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusPropertyInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusPropertyInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Name gets the field inside the struct.
func (d *DBusPropertyInfo) Name() string {
	v = C.GoString(d.native.name)
}

// Signature gets the field inside the struct.
func (d *DBusPropertyInfo) Signature() string {
	v = C.GoString(d.native.signature)
}

// Flags gets the field inside the struct.
func (d *DBusPropertyInfo) Flags() DBusPropertyInfoFlags {
	v = DBusPropertyInfoFlags(d.native.flags)
}

// Annotations gets the field inside the struct.
func (d *DBusPropertyInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusPropertyInfo) Ref() *DBusPropertyInfo {
	var arg0 *C.GDBusPropertyInfo

	arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusPropertyInfo
	var ret1 *DBusPropertyInfo

	cret = C.g_dbus_property_info_ref(arg0)

	ret1 = WrapDBusPropertyInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusPropertyInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusPropertyInfo) Unref() {
	var arg0 *C.GDBusPropertyInfo

	arg0 = (*C.GDBusPropertyInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_property_info_unref(arg0)
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
type DBusSignalInfo struct {
	native C.GDBusSignalInfo
}

// WrapDBusSignalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapDBusSignalInfo(ptr unsafe.Pointer) *DBusSignalInfo {
	if ptr == nil {
		return nil
	}

	return (*DBusSignalInfo)(ptr)
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapDBusSignalInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (d *DBusSignalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&d.native)
}

// RefCount gets the field inside the struct.
func (d *DBusSignalInfo) RefCount() int {
	v = C.gint(d.native.ref_count)
}

// Name gets the field inside the struct.
func (d *DBusSignalInfo) Name() string {
	v = C.GoString(d.native.name)
}

// Args gets the field inside the struct.
func (d *DBusSignalInfo) Args() []*DBusArgInfo {
	{
		var length int
		for p := d.native.args; *p != 0; p = (**C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusArgInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusArgInfo)(ptr.Add(unsafe.Pointer(d.native.args), i))
			v[i] = WrapDBusArgInfo(unsafe.Pointer(src))
		}
	}
}

// Annotations gets the field inside the struct.
func (d *DBusSignalInfo) Annotations() []*DBusAnnotationInfo {
	{
		var length int
		for p := d.native.annotations; *p != 0; p = (**C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		v = make([]*DBusAnnotationInfo, length)
		for i := uintptr(0); i < uintptr(length); i += unsafe.Sizeof(int(0)) {
			src := (*C.GDBusAnnotationInfo)(ptr.Add(unsafe.Pointer(d.native.annotations), i))
			v[i] = WrapDBusAnnotationInfo(unsafe.Pointer(src))
		}
	}
}

// Ref: if @info is statically allocated does nothing. Otherwise increases the
// reference count.
func (i *DBusSignalInfo) Ref() *DBusSignalInfo {
	var arg0 *C.GDBusSignalInfo

	arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

	var cret *C.GDBusSignalInfo
	var ret1 *DBusSignalInfo

	cret = C.g_dbus_signal_info_ref(arg0)

	ret1 = WrapDBusSignalInfo(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *DBusSignalInfo) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Unref: if @info is statically allocated, does nothing. Otherwise decreases
// the reference count of @info. When its reference count drops to 0, the memory
// used is freed.
func (i *DBusSignalInfo) Unref() {
	var arg0 *C.GDBusSignalInfo

	arg0 = (*C.GDBusSignalInfo)(unsafe.Pointer(i.Native()))

	C.g_dbus_signal_info_unref(arg0)
}
