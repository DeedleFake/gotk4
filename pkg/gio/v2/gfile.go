// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_file_get_type()), F: marshalFile},
	})
}

// FileNewForCommandlineArg creates a #GFile with the given argument from the
// command line. The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory. This
// operation never fails, but the returned object might not support any I/O
// operation if @arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
func FileNewForCommandlineArg(arg string) File {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(arg))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_new_for_commandline_arg(arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// FileNewForCommandlineArgAndCwd creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
func FileNewForCommandlineArgAndCwd(arg string, cwd string) File {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(arg))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_file_new_for_commandline_arg_and_cwd(arg1, arg2)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// FileNewForPath constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if @path
// is malformed.
func FileNewForPath(path string) File {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_new_for_path(arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// FileNewForURI constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if @uri is
// malformed or if the uri type is not supported.
func FileNewForURI(uri string) File {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(uri))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_new_for_uri(arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// FileNewTmp opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// @tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is nil,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return nil if a temporary
// file could not be created.
func FileNewTmp(tmpl string) (iostream FileIOStream, file File, err error) {
	var arg1 *C.char
	var arg2 **C.GFileIOStream // out
	var gError *C.GError

	arg1 = (*C.gchar)(C.CString(tmpl))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_new_tmp(arg1, &arg2, &gError)

	var ret0 FileIOStream
	var ret1 File
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg2.Native()))).(FileIOStream)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// FileParseName constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails, but the
// returned object might not support any I/O operation if the @parse_name cannot
// be parsed.
func FileParseName(parseName string) File {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(parseName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_parse_name(arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// FileOverrider contains methods that are overridable. This
// interface is a subset of the interface File.
type FileOverrider interface {
	// AppendTo gets an output stream for appending data to the file. If the
	// file doesn't already exist it is created.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// Some file systems don't allow all file names, and may return an
	// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
	// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
	// too, and depend on what kind of filesystem the file is on.
	AppendTo(flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error)
	// AppendToAsync: asynchronously opens @file for appending.
	//
	// For more details, see g_file_append_to() which is the synchronous version
	// of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_append_to_finish() to get the result of the operation.
	AppendToAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
	AppendToFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error)
	// Copy copies the file @source to the location specified by @destination.
	// Can not handle recursive copies of directories.
	//
	// If the flag FILE_COPY_OVERWRITE is specified an already existing
	// @destination file is overwritten.
	//
	// If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will
	// be copied as symlinks, otherwise the target of the @source symlink will
	// be copied.
	//
	// If the flag FILE_COPY_ALL_METADATA is specified then all the metadata
	// that is possible to copy is copied, not just the default subset (which,
	// for instance, does not include the owner, see Info).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @progress_callback is not nil, then the operation can be monitored by
	// setting this to a ProgressCallback function. @progress_callback_data will
	// be passed to this function. It is guaranteed that this callback will be
	// called after all data has been transferred with the total number of bytes
	// copied during the operation.
	//
	// If the @source file does not exist, then the G_IO_ERROR_NOT_FOUND error
	// is returned, independent on the status of the @destination.
	//
	// If FILE_COPY_OVERWRITE is not specified and the target exists, then the
	// error G_IO_ERROR_EXISTS is returned.
	//
	// If trying to overwrite a file over a directory, the
	// G_IO_ERROR_IS_DIRECTORY error is returned. If trying to overwrite a
	// directory with a directory the G_IO_ERROR_WOULD_MERGE error is returned.
	//
	// If the source is a directory and the target does not exist, or
	// FILE_COPY_OVERWRITE is specified and the target is a file, then the
	// G_IO_ERROR_WOULD_RECURSE error is returned.
	//
	// If you are interested in copying the #GFile object itself (not the
	// on-disk file), see g_file_dup().
	Copy(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) error
	// CopyAsync copies the file @source to the location specified by
	// @destination asynchronously. For details of the behaviour, see
	// g_file_copy().
	//
	// If @progress_callback is not nil, then that function that will be called
	// just like in g_file_copy(). The callback will run in the default main
	// context of the thread calling g_file_copy_async() â€” the same context as
	// @callback is run in.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_copy_finish() to get the result of the operation.
	CopyAsync(destination File, flags FileCopyFlags, ioPriority int, cancellable Cancellable, progressCallback FileProgressCallback, callback AsyncReadyCallback)
	// CopyFinish finishes copying the file started with g_file_copy_async().
	CopyFinish(res AsyncResult) error
	// Create creates a new file and returns an output stream for writing to it.
	// The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	Create(flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error)
	// CreateAsync: asynchronously creates a new file and returns an output
	// stream for writing to it. The file must not already exist.
	//
	// For more details, see g_file_create() which is the synchronous version of
	// this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_create_finish() to get the result of the operation.
	CreateAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error)
	// CreateReadwrite creates a new file and returns a stream for reading and
	// writing to it. The file must not already exist.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If a file or directory with this name already exists, the
	// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
	// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
	// if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned.
	// Other errors are possible too, and depend on what kind of filesystem the
	// file is on.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (fileIOStream FileIOStream, err error)
	// CreateReadwriteAsync: asynchronously creates a new file and returns a
	// stream for reading and writing to it. The file must not already exist.
	//
	// For more details, see g_file_create_readwrite() which is the synchronous
	// version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_create_readwrite_finish() to get the result of the operation.
	CreateReadwriteAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
	CreateReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error)
	// DeleteFile deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	//
	// If @file doesnâ€™t exist, G_IO_ERROR_NOT_FOUND will be returned. This
	// allows for deletion to be implemented avoiding time-of-check to
	// time-of-use races
	// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	//
	//    g_autoptr(GError) local_error = NULL;
	//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
	//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//      {
	//        // deletion failed for some reason other than the file not existing:
	//        // so report the error
	//        g_warning ("Failed to delete s: s",
	//                   g_file_peek_path (my_file), local_error->message);
	//      }
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	DeleteFile(cancellable Cancellable) error
	// DeleteFileAsync: asynchronously delete a file. If the @file is a
	// directory, it will only be deleted if it is empty. This has the same
	// semantics as g_unlink().
	DeleteFileAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// DeleteFileFinish finishes deleting a file started with
	// g_file_delete_async().
	DeleteFileFinish(result AsyncResult) error
	// Dup duplicates a #GFile handle. This operation does not duplicate the
	// actual file or directory represented by the #GFile; see g_file_copy() if
	// attempting to copy a file.
	//
	// g_file_dup() is useful when a second handle is needed to the same
	// underlying file, for use in a separate thread (#GFile is not
	// thread-safe). For use within the same thread, use g_object_ref() to
	// increment the existing objectâ€™s reference count.
	//
	// This call does no blocking I/O.
	Dup() File
	// EjectMountable starts an asynchronous eject on a mountable. When this
	// operation has completed, @callback will be called with @user_user data,
	// and the operation can be finalized with g_file_eject_mountable_finish().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	EjectMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	EjectMountableFinish(result AsyncResult) error
	// EjectMountableWithOperation starts an asynchronous eject on a mountable.
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_eject_mountable_with_operation_finish().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	EjectMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(result AsyncResult) error
	// EnumerateChildren gets the requested information about the files in a
	// directory. The result is a Enumerator object that will give out Info
	// objects for all the files in the directory.
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
	// error will be returned. Other errors are possible too.
	EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (fileEnumerator FileEnumerator, err error)
	// EnumerateChildrenAsync: asynchronously gets the requested information
	// about the files in a directory. The result is a Enumerator object that
	// will give out Info objects for all the files in the directory.
	//
	// For more details, see g_file_enumerate_children() which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_enumerate_children_finish() to get the result of the
	// operation.
	EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// EnumerateChildrenFinish finishes an async enumerate children operation.
	// See g_file_enumerate_children_async().
	EnumerateChildrenFinish(res AsyncResult) (fileEnumerator FileEnumerator, err error)
	// Equal checks if the two given #GFiles refer to the same file.
	//
	// Note that two #GFiles that differ can still refer to the same file on the
	// filesystem due to various forms of filename aliasing.
	//
	// This call does no blocking I/O.
	Equal(file2 File) bool
	// FindEnclosingMount gets a #GMount for the #GFile.
	//
	// #GMount is returned only for user interesting locations, see Monitor. If
	// the Iface for @file does not have a #mount, @error will be set to
	// G_IO_ERROR_NOT_FOUND and nil #will be returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	FindEnclosingMount(cancellable Cancellable) (mount Mount, err error)
	// FindEnclosingMountAsync: asynchronously gets the mount for the file.
	//
	// For more details, see g_file_find_enclosing_mount() which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_find_enclosing_mount_finish() to get the result of the
	// operation.
	FindEnclosingMountAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// FindEnclosingMountFinish finishes an asynchronous find mount request. See
	// g_file_find_enclosing_mount_async().
	FindEnclosingMountFinish(res AsyncResult) (mount Mount, err error)
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	//
	// If called for the top level of a system (such as the filesystem root or a
	// uri like sftp://host/) it will return a single directory separator (and
	// on Windows, possibly a drive letter).
	//
	// The base name is a byte string (not UTF-8). It has no defined encoding or
	// rules other than it may not contain zero bytes. If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	//
	// This call does no blocking I/O.
	Basename() string
	// ChildForDisplayName gets the child of @file for a given @display_name
	// (i.e. a UTF-8 version of the name). If this function fails, it returns
	// nil and @error will be set. This is very useful when constructing a
	// #GFile for a new file and the user entered the filename in the user
	// interface, for instance when you select a directory and type a filename
	// in the file selector.
	//
	// This call does no blocking I/O.
	ChildForDisplayName(displayName string) (file File, err error)
	// Parent gets the parent directory for the @file. If the @file represents
	// the root directory of the file system, then nil will be returned.
	//
	// This call does no blocking I/O.
	Parent() File
	// ParseName gets the parse name of the @file. A parse name is a UTF-8
	// string that describes the file such that one can get the #GFile back
	// using g_file_parse_name().
	//
	// This is generally used to show the #GFile as a nice full-pathname kind of
	// string in a user interface, like in a location entry.
	//
	// For local files with names that can safely be converted to UTF-8 the
	// pathname is used, otherwise the IRI is used (a form of URI that allows
	// UTF-8 characters unescaped).
	//
	// This call does no blocking I/O.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists. If non-nil, this
	// is guaranteed to be an absolute, canonical path. It might contain
	// symlinks.
	//
	// This call does no blocking I/O.
	Path() string
	// RelativePath gets the path for @descendant relative to @parent.
	//
	// This call does no blocking I/O.
	RelativePath(descendant File) string
	// URI gets the URI for the @file.
	//
	// This call does no blocking I/O.
	URI() string
	// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
	// as:
	//
	//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	//
	// Common schemes include "file", "http", "ftp", etc.
	//
	// The scheme can be different from the one used to construct the #GFile, in
	// that it might be replaced with one that is logically equivalent to the
	// #GFile.
	//
	// This call does no blocking I/O.
	URIScheme() string
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	//
	// This call does no blocking I/O.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	//
	// This call does no blocking I/O.
	Hash() uint
	// IsNative checks to see if a file is native to the platform.
	//
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	//
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return false, but g_file_get_path() will still return a native path.
	//
	// This call does no blocking I/O.
	IsNative() bool
	// MakeDirectory creates a directory. Note that this will only create a
	// child directory of the immediate parent directory of the path or URI
	// given by the #GFile. To recursively create directories, see
	// g_file_make_directory_with_parents(). This function will fail if the
	// parent directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND.
	// If the file system doesn't support creating directories, this function
	// will fail, setting @error to G_IO_ERROR_NOT_SUPPORTED.
	//
	// For a local #GFile the newly created directory will have the default
	// (current) ownership and permissions of the current process.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeDirectory(cancellable Cancellable) error
	// MakeDirectoryAsync: asynchronously creates a directory.
	MakeDirectoryAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
	MakeDirectoryFinish(result AsyncResult) error
	// MakeSymbolicLink creates a symbolic link named @file which contains the
	// string @symlink_value.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeSymbolicLink(symlinkValue string, cancellable Cancellable) error
	// MeasureDiskUsage: recursively measures the disk usage of @file.
	//
	// This is essentially an analog of the 'du' command, but it also reports
	// the number of directories and non-directory files encountered (including
	// things like symbolic links).
	//
	// By default, errors are only reported against the toplevel file itself.
	// Errors found while recursing are silently ignored, unless
	// G_FILE_MEASURE_REPORT_ANY_ERROR is given in @flags.
	//
	// The returned size, @disk_usage, is in bytes and should be formatted with
	// g_format_size() in order to get something reasonable for showing in a
	// user interface.
	//
	// @progress_callback and @progress_data can be given to request periodic
	// progress updates while scanning. See the documentation for
	// MeasureProgressCallback for information about when and how the callback
	// will be invoked.
	MeasureDiskUsage(flags FileMeasureFlags, cancellable Cancellable, progressCallback FileMeasureProgressCallback) (diskUsage uint64, numDirs uint64, numFiles uint64, err error)
	// MeasureDiskUsageAsync: recursively measures the disk usage of @file.
	//
	// This is the asynchronous version of g_file_measure_disk_usage(). See
	// there for more information.
	MeasureDiskUsageAsync(flags FileMeasureFlags, ioPriority int, cancellable Cancellable, progressCallback FileMeasureProgressCallback, callback AsyncReadyCallback)
	// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for
	// more information.
	MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, err error)
	// MonitorDir obtains a directory monitor for the given file. This may fail
	// if directory monitoring is not supported.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// It does not make sense for @flags to contain
	// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories. It is not possible to monitor all the files in a directory
	// for changes made via hard links; if you want to do this then you must
	// register individual watches with g_file_monitor().
	MonitorDir(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error)
	// MonitorFile obtains a file monitor for the given file. If no file
	// notification mechanism exists, then regular polling of the file is used.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
	// also attempt to report changes made to the file via another filename (ie,
	// a hard link). Without this flag, you can only rely on changes made
	// through the filename contained in @file to be reported. Using this flag
	// may result in an increase in resource usage, and may not have any effect
	// depending on the Monitor backend and/or filesystem type.
	MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error)
	// MountEnclosingVolume starts a @mount_operation, mounting the volume that
	// contains the file @location.
	//
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_mount_enclosing_volume_finish().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MountEnclosingVolume(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(result AsyncResult) error
	// MountMountable mounts a file of type G_FILE_TYPE_MOUNTABLE. Using
	// @mount_operation, you can request callbacks when, for instance, passwords
	// are needed during authentication.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_mount_mountable_finish() to get the result of the operation.
	MountMountable(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// MountMountableFinish finishes a mount operation. See
	// g_file_mount_mountable() for details.
	//
	// Finish an asynchronous mount operation that was started with
	// g_file_mount_mountable().
	MountMountableFinish(result AsyncResult) (file File, err error)
	// Move tries to move the file or directory @source to the location
	// specified by @destination. If native move operations are supported then
	// this is used, otherwise a copy + delete fallback is used. The native
	// implementation may support moving directories (for instance on moves
	// inside the same filesystem), but the fallback code does not.
	//
	// If the flag FILE_COPY_OVERWRITE is specified an already existing
	// @destination file is overwritten.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @progress_callback is not nil, then the operation can be monitored by
	// setting this to a ProgressCallback function. @progress_callback_data will
	// be passed to this function. It is guaranteed that this callback will be
	// called after all data has been transferred with the total number of bytes
	// copied during the operation.
	//
	// If the @source file does not exist, then the G_IO_ERROR_NOT_FOUND error
	// is returned, independent on the status of the @destination.
	//
	// If FILE_COPY_OVERWRITE is not specified and the target exists, then the
	// error G_IO_ERROR_EXISTS is returned.
	//
	// If trying to overwrite a file over a directory, the
	// G_IO_ERROR_IS_DIRECTORY error is returned. If trying to overwrite a
	// directory with a directory the G_IO_ERROR_WOULD_MERGE error is returned.
	//
	// If the source is a directory and the target does not exist, or
	// FILE_COPY_OVERWRITE is specified and the target is a file, then the
	// G_IO_ERROR_WOULD_RECURSE error may be returned (if the native move
	// operation isn't available).
	Move(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) error
	// OpenReadwrite opens an existing file for reading and writing. The result
	// is a IOStream that can be used to read and write the contents of the
	// file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on. Note that in many non-local file cases read
	// and write streams are not supported, so make sure you really need to do
	// read and write streaming, rather than just opening for reading or
	// writing.
	OpenReadwrite(cancellable Cancellable) (fileIOStream FileIOStream, err error)
	// OpenReadwriteAsync: asynchronously opens @file for reading and writing.
	//
	// For more details, see g_file_open_readwrite() which is the synchronous
	// version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_open_readwrite_finish() to get the result of the operation.
	OpenReadwriteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
	OpenReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error)
	// PollMountable polls a file of type FILE_TYPE_MOUNTABLE.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_mount_mountable_finish() to get the result of the operation.
	PollMountable(cancellable Cancellable, callback AsyncReadyCallback)
	// PollMountableFinish finishes a poll operation. See
	// g_file_poll_mountable() for details.
	//
	// Finish an asynchronous poll operation that was polled with
	// g_file_poll_mountable().
	PollMountableFinish(result AsyncResult) error
	// PrefixMatches checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	PrefixMatches(file File) bool
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the @file is on, rather than the file
	// itself. For instance the amount of space available and the type of the
	// filesystem.
	//
	// The @attributes value is a string that specifies the attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "filesystem::*" means all attributes in the filesystem namespace. The
	// standard namespace for filesystem attributes is "filesystem". Common
	// attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size
	// of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
	// bytes available), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the
	// filesystem).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryFilesystemInfo(attributes string, cancellable Cancellable) (fileInfo FileInfo, err error)
	// QueryFilesystemInfoAsync: asynchronously gets the requested information
	// about the filesystem that the specified @file is on. The result is a Info
	// object that contains key-value attributes (such as type or size for the
	// file).
	//
	// For more details, see g_file_query_filesystem_info() which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_query_info_finish() to get the result of the operation.
	QueryFilesystemInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	// See g_file_query_filesystem_info_async().
	QueryFilesystemInfoFinish(res AsyncResult) (fileInfo FileInfo, err error)
	// QueryInfo gets the requested information about specified @file. The
	// result is a Info object that contains key-value attributes (such as the
	// type or size of the file).
	//
	// The @attributes value is a string that specifies the file attributes that
	// should be gathered. It is not an error if it's not possible to read a
	// particular requested attribute from a file - it just won't be set.
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace. An example
	// attribute query be "standard::*,owner::user". The standard attributes are
	// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// For symlinks, normally the information about the target of the symlink is
	// returned, rather than information about the symlink itself. However if
	// you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information
	// about the symlink itself will be returned. Also, for symlinks that point
	// to non-existing files the information about the symlink itself will be
	// returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (fileInfo FileInfo, err error)
	// QueryInfoAsync: asynchronously gets the requested information about
	// specified @file. The result is a Info object that contains key-value
	// attributes (such as type or size for the file).
	//
	// For more details, see g_file_query_info() which is the synchronous
	// version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_query_info_finish() to get the result of the operation.
	QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryInfoFinish finishes an asynchronous file info query. See
	// g_file_query_info_async().
	QueryInfoFinish(res AsyncResult) (fileInfo FileInfo, err error)
	// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	//
	// Returns the type and full attribute name of all the attributes that can
	// be set on this file. This doesn't mean setting it will always succeed
	// though, you might get an access failure, or some specific file may not
	// support a specific attribute.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QuerySettableAttributes(cancellable Cancellable) (fileAttributeInfoList *FileAttributeInfoList, err error)
	// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user. An example of this is extended
	// attributes (in the "xattr" namespace).
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QueryWritableNamespaces(cancellable Cancellable) (fileAttributeInfoList *FileAttributeInfoList, err error)
	// ReadAsync: asynchronously opens @file for reading.
	//
	// For more details, see g_file_read() which is the synchronous version of
	// this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_read_finish() to get the result of the operation.
	ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(res AsyncResult) (fileInputStream FileInputStream, err error)
	// ReadFn opens a file for reading. The result is a InputStream that can be
	// used to read the contents of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
	ReadFn(cancellable Cancellable) (fileInputStream FileInputStream, err error)
	// Replace returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first. If the file doesn't exist, it
	// will be created.
	//
	// This will try to replace the file in the safest way possible so that any
	// errors during the writing will not affect an already existing copy of the
	// file. For instance, for local files it may write to a temporary file and
	// then atomically rename over the destination when the stream is closed.
	//
	// By default files created are generally readable by everyone, but if you
	// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
	// the current user, to the level that is supported on the target
	// filesystem.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If you pass in a non-nil @etag value and @file already exists, then this
	// value is compared to the current entity tag of the file, and if they
	// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
	// that the file has been changed since you last read it. You can get the
	// new etag from g_file_output_stream_get_etag() after you've finished
	// writing and closed the OutputStream. When you load a new file you can use
	// g_file_input_stream_query_info() to get the etag of the file.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// the current file before overwriting it. If this fails a
	// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to
	// replace anyway, try again with @make_backup set to false.
	//
	// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
	// returned, and if the file is some other form of non-regular file then a
	// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems
	// don't allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be
	// returned. Other errors are possible too, and depend on what kind of
	// filesystem the file is on.
	Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error)
	// ReplaceAsync: asynchronously overwrites the file, replacing the contents,
	// possibly creating a backup copy of the file first.
	//
	// For more details, see g_file_replace() which is the synchronous version
	// of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_replace_finish() to get the result of the operation.
	ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
	ReplaceFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error)
	// ReplaceReadwrite returns an output stream for overwriting the file in
	// readwrite mode, possibly creating a backup copy of the file first. If the
	// file doesn't exist, it will be created.
	//
	// For details about the behaviour, see g_file_replace() which does the same
	// thing but returns an output stream only.
	//
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (fileIOStream FileIOStream, err error)
	// ReplaceReadwriteAsync: asynchronously overwrites the file in read-write
	// mode, replacing the contents, possibly creating a backup copy of the file
	// first.
	//
	// For more details, see g_file_replace_readwrite() which is the synchronous
	// version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_replace_readwrite_finish() to get the result of the
	// operation.
	ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error)
	// ResolveRelativePath resolves a relative path for @file to an absolute
	// path.
	//
	// This call does no blocking I/O.
	ResolveRelativePath(relativePath string) File
	// SetAttribute sets an attribute in the file with attribute name @attribute
	// to @value_p.
	//
	// Some attributes can be unset by setting @type to
	// G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to nil.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttribute(attribute string, typ FileAttributeType, valueP interface{}, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributesAsync: asynchronously sets the attributes of @file with
	// @info.
	//
	// For more details, see g_file_set_attributes_from_info(), which is the
	// synchronous version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_set_attributes_finish() to get the result of the operation.
	SetAttributesAsync(info FileInfo, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
	SetAttributesFinish(result AsyncResult) (info FileInfo, err error)
	// SetAttributesFromInfo tries to set all attributes in the Info on the
	// target values, not stopping on the first error.
	//
	// If there is any error during this operation then @error will be set to
	// the first error. Error on particular fields are flagged by setting the
	// "status" field in the attribute value to
	// G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
	// further errors.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetDisplayName renames @file to the specified display name.
	//
	// The display name is converted from UTF-8 to the correct encoding for the
	// target filesystem if possible and the @file is renamed to this.
	//
	// If you want to implement a rename operation in the user interface the
	// edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
	// initial value in the rename widget, and then the result after editing
	// should be passed to g_file_set_display_name().
	//
	// On success the resulting converted filename is returned.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetDisplayName(displayName string, cancellable Cancellable) (file File, err error)
	// SetDisplayNameAsync: asynchronously sets the display name for a given
	// #GFile.
	//
	// For more details, see g_file_set_display_name() which is the synchronous
	// version of this call.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_set_display_name_finish() to get the result of the operation.
	SetDisplayNameAsync(displayName string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(res AsyncResult) (file File, err error)
	// StartMountable starts a file of type FILE_TYPE_MOUNTABLE. Using
	// @start_operation, you can request callbacks when, for instance, passwords
	// are needed during authentication.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_mount_mountable_finish() to get the result of the operation.
	StartMountable(flags DriveStartFlags, startOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// StartMountableFinish finishes a start operation. See
	// g_file_start_mountable() for details.
	//
	// Finish an asynchronous start operation that was started with
	// g_file_start_mountable().
	StartMountableFinish(result AsyncResult) error
	// StopMountable stops a file of type FILE_TYPE_MOUNTABLE.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_stop_mountable_finish() to get the result of the operation.
	StopMountable(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	//
	// Finish an asynchronous stop operation that was started with
	// g_file_stop_mountable().
	StopMountableFinish(result AsyncResult) error
	// Trash sends @file to the "Trashcan", if possible. This is similar to
	// deleting it, but the user can recover it before emptying the trashcan.
	// Not all file systems support trashing, so this call can return the
	// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash`
	// unix mount option can be used to disable g_file_trash() support for
	// certain mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in
	// that case.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Trash(cancellable Cancellable) error
	// TrashAsync: asynchronously sends @file to the Trash location, if
	// possible.
	TrashAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
	TrashFinish(result AsyncResult) error
	// UnmountMountable unmounts a file of type G_FILE_TYPE_MOUNTABLE.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_unmount_mountable_finish() to get the result of the
	// operation.
	UnmountMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable().
	UnmountMountableFinish(result AsyncResult) error
	// UnmountMountableWithOperation unmounts a file of type
	// FILE_TYPE_MOUNTABLE.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// When the operation is finished, @callback will be called. You can then
	// call g_file_unmount_mountable_finish() to get the result of the
	// operation.
	UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback)
	// UnmountMountableWithOperationFinish finishes an unmount operation, see
	// g_file_unmount_mountable_with_operation() for details.
	//
	// Finish an asynchronous unmount operation that was started with
	// g_file_unmount_mountable_with_operation().
	UnmountMountableWithOperationFinish(result AsyncResult) error
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
//
//
// Entity Tags
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
type File interface {
	gextras.Objector
	FileOverrider

	// BuildAttributeListForCopy prepares the file attribute query string for
	// copying to @file.
	//
	// This function prepares an attribute query string to be passed to
	// g_file_query_info() to get a list of attributes normally copied with the
	// file (see g_file_copy_attributes() for the detailed description). This
	// function is used by the implementation of g_file_copy_attributes() and is
	// useful when one needs to query and set the attributes in two stages
	// (e.g., for recursive move of a directory).
	BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (utf8 string, err error)
	// CopyAttributes copies the file attributes from @source to @destination.
	//
	// Normally only a subset of the file attributes are copied, those that are
	// copies in a normal file copy operation (which for instance does not
	// include e.g. owner). However if FILE_COPY_ALL_METADATA is specified in
	// @flags, then all the metadata that is possible to copy is copied. This is
	// useful when implementing move by copy + delete source.
	CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) error
	// Delete deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	//
	// If @file doesnâ€™t exist, G_IO_ERROR_NOT_FOUND will be returned. This
	// allows for deletion to be implemented avoiding time-of-check to
	// time-of-use races
	// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	//
	//    g_autoptr(GError) local_error = NULL;
	//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
	//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//      {
	//        // deletion failed for some reason other than the file not existing:
	//        // so report the error
	//        g_warning ("Failed to delete s: s",
	//                   g_file_peek_path (my_file), local_error->message);
	//      }
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Delete(cancellable Cancellable) error
	// DeleteAsync: asynchronously delete a file. If the @file is a directory,
	// it will only be deleted if it is empty. This has the same semantics as
	// g_unlink().
	DeleteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// DeleteFinish finishes deleting a file started with g_file_delete_async().
	DeleteFinish(result AsyncResult) error
	// Child gets a child of @file with basename equal to @name.
	//
	// Note that the file with that specific name might not exist, but you can
	// still have a #GFile that points to it. You can use this for instance to
	// create that file.
	//
	// This call does no blocking I/O.
	Child(name string) File
	// HasParent checks if @file has a parent, and optionally, if it is @parent.
	//
	// If @parent is nil then this function returns true if @file has any parent
	// at all. If @parent is non-nil then true is only returned if @file is an
	// immediate child of @parent.
	HasParent(parent File) bool
	// HasPrefix checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	HasPrefix(prefix File) bool
	// LoadBytes loads the contents of @file and returns it as #GBytes.
	//
	// If @file is a resource:// based URI, the resulting bytes will reference
	// the embedded resource instead of a copy. Otherwise, this is equivalent to
	// calling g_file_load_contents() and g_bytes_new_take().
	//
	// For resources, @etag_out will be set to nil.
	//
	// The data contained in the resulting #GBytes is always zero-terminated,
	// but this is not included in the #GBytes length. The resulting #GBytes
	// should be freed with g_bytes_unref() when no longer in use.
	LoadBytes(cancellable Cancellable) (etagOut string, bytes *glib.Bytes, err error)
	// LoadBytesAsync: asynchronously loads the contents of @file as #GBytes.
	//
	// If @file is a resource:// based URI, the resulting bytes will reference
	// the embedded resource instead of a copy. Otherwise, this is equivalent to
	// calling g_file_load_contents_async() and g_bytes_new_take().
	//
	// @callback should call g_file_load_bytes_finish() to get the result of
	// this asynchronous operation.
	//
	// See g_file_load_bytes() for more information.
	LoadBytesAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// LoadBytesFinish completes an asynchronous request to
	// g_file_load_bytes_async().
	//
	// For resources, @etag_out will be set to nil.
	//
	// The data contained in the resulting #GBytes is always zero-terminated,
	// but this is not included in the #GBytes length. The resulting #GBytes
	// should be freed with g_bytes_unref() when no longer in use.
	//
	// See g_file_load_bytes() for more information.
	LoadBytesFinish(result AsyncResult) (etagOut string, bytes *glib.Bytes, err error)
	// LoadContents loads the content of the file into memory. The data is
	// always zero-terminated, but this is not included in the resultant
	// @length. The returned @contents should be freed with g_free() when no
	// longer needed.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	LoadContents(cancellable Cancellable) (contents []byte, length uint, etagOut string, err error)
	// LoadContentsAsync starts an asynchronous load of the @file's contents.
	//
	// For more details, see g_file_load_contents() which is the synchronous
	// version of this call.
	//
	// When the load operation has completed, @callback will be called with
	// @user data. To finish the operation, call g_file_load_contents_finish()
	// with the Result returned by the @callback.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	LoadContentsAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// LoadContentsFinish finishes an asynchronous load of the @file's contents.
	// The contents are placed in @contents, and @length is set to the size of
	// the @contents string. The @contents should be freed with g_free() when no
	// longer needed. If @etag_out is present, it will be set to the new entity
	// tag for the @file.
	LoadContentsFinish(res AsyncResult) (contents []byte, length uint, etagOut string, err error)
	// LoadPartialContentsAsync reads the partial contents of a file. A
	// ReadMoreCallback should be used to stop reading from the file when
	// appropriate, else this function will behave exactly as
	// g_file_load_contents_async(). This operation can be finished by
	// g_file_load_partial_contents_finish().
	//
	// Users of this function should be aware that @user_data is passed to both
	// the @read_more_callback and the @callback.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	LoadPartialContentsAsync(cancellable Cancellable, readMoreCallback FileReadMoreCallback, callback AsyncReadyCallback)
	// LoadPartialContentsFinish finishes an asynchronous partial load operation
	// that was started with g_file_load_partial_contents_async(). The data is
	// always zero-terminated, but this is not included in the resultant
	// @length. The returned @contents should be freed with g_free() when no
	// longer needed.
	LoadPartialContentsFinish(res AsyncResult) (contents []byte, length uint, etagOut string, err error)
	// MakeDirectoryWithParents creates a directory and any parent directories
	// that may not exist similar to 'mkdir -p'. If the file system does not
	// support creating directories, this function will fail, setting @error to
	// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
	// function will fail setting @error to G_IO_ERROR_EXISTS, unlike the
	// similar g_mkdir_with_parents().
	//
	// For a local #GFile the newly created directories will have the default
	// (current) ownership and permissions of the current process.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	MakeDirectoryWithParents(cancellable Cancellable) error
	// Monitor obtains a file or directory monitor for the given file, depending
	// on the type of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Monitor(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error)
	// MonitorDirectory obtains a directory monitor for the given file. This may
	// fail if directory monitoring is not supported.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// It does not make sense for @flags to contain
	// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories. It is not possible to monitor all the files in a directory
	// for changes made via hard links; if you want to do this then you must
	// register individual watches with g_file_monitor().
	MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error)
	// PeekPath: exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full(). This is useful for example in C applications
	// which mix `g_file_*` APIs with native ones. It also avoids an extra
	// duplicated string when possible, so will be generally more efficient.
	//
	// This call does no blocking I/O.
	PeekPath() string
	// QueryDefaultHandler returns the Info that is registered as the default
	// application to handle the file specified by @file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	QueryDefaultHandler(cancellable Cancellable) (appInfo AppInfo, err error)
	// QueryDefaultHandlerAsync: async version of
	// g_file_query_default_handler().
	QueryDefaultHandlerAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
	// operation.
	QueryDefaultHandlerFinish(result AsyncResult) (appInfo AppInfo, err error)
	// QueryExists: utility function to check if a particular file exists. This
	// is implemented using g_file_query_info() and as such does blocking I/O.
	//
	// Note that in many cases it is racy to first check for file existence
	// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
	// execute something based on the outcome of that, because the file might
	// have been created or removed in between the operations. The general
	// approach to handling that is to not check, but just do the operation and
	// handle the errors as they come.
	//
	// As an example of race-free checking, take the case of reading a file, and
	// if it doesn't exist, creating it. There are two racy versions: read it,
	// and on error create it; and: check if it exists, if not create it. These
	// can both result in two processes creating the file (with perhaps a
	// partially written file as the result). The correct approach is to always
	// try to create the file with g_file_create() which will either atomically
	// create the file or fail with a G_IO_ERROR_EXISTS error.
	//
	// However, in many cases an existence check is useful in a user interface,
	// for instance to make a menu item sensitive/insensitive, so that you don't
	// have to fool users that something is possible and then just show an error
	// dialog. If you do this, you should make sure to also handle the errors
	// that can happen due to races when you execute the operation.
	QueryExists(cancellable Cancellable) bool
	// QueryFileType: utility function to inspect the Type of a file. This is
	// implemented using g_file_query_info() and as such does blocking I/O.
	//
	// The primary use case of this method is to check if a file is a regular
	// file, directory, or symlink.
	QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType
	// Read opens a file for reading. The result is a InputStream that can be
	// used to read the contents of the file.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
	// will be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
	Read(cancellable Cancellable) (fileInputStream FileInputStream, err error)
	// ReplaceContents replaces the contents of @file with @contents of @length
	// bytes.
	//
	// If @etag is specified (not nil), any existing file must have that etag,
	// or the error G_IO_ERROR_WRONG_ETAG will be returned.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// @file. Internally, it uses g_file_replace(), so will try to replace the
	// file contents in the safest way possible. For example, atomic renames are
	// used when replacing local filesâ€™ contents.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// The returned @new_etag can be used to verify that the file hasn't changed
	// the next time it is saved over.
	ReplaceContents(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (newEtag string, err error)
	// ReplaceContentsAsync starts an asynchronous replacement of @file with the
	// given @contents of @length bytes. @etag will replace the document's
	// current entity tag.
	//
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_replace_contents_finish().
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	//
	// If @make_backup is true, this function will attempt to make a backup of
	// @file.
	//
	// Note that no copy of @contents will be made, so it must stay valid until
	// @callback is called. See g_file_replace_contents_bytes_async() for a
	// #GBytes version that will automatically hold a reference to the contents
	// (without copying) for the duration of the call.
	ReplaceContentsAsync(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// ReplaceContentsBytesAsync: same as g_file_replace_contents_async() but
	// takes a #GBytes input instead. This function will keep a ref on @contents
	// until the operation is done. Unlike g_file_replace_contents_async() this
	// allows forgetting about the content without waiting for the callback.
	//
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_replace_contents_finish().
	ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback)
	// ReplaceContentsFinish finishes an asynchronous replace of the given
	// @file. See g_file_replace_contents_async(). Sets @new_etag to the new
	// entity tag for the document, if present.
	ReplaceContentsFinish(res AsyncResult) (newEtag string, err error)
	// SetAttributeByteString sets @attribute of type
	// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value. If @attribute is of a
	// different type, this operation will fail, returning false.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeInt32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
	// @value. If @attribute is of a different type, this operation will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeInt64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
	// @value. If @attribute is of a different type, this operation will fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeString sets @attribute of type G_FILE_ATTRIBUTE_TYPE_STRING
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeUint32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SetAttributeUint64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64
	// to @value. If @attribute is of a different type, this operation will
	// fail.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) error
	// SupportsThreadContexts checks if @file supports [thread-default
	// contexts][g-main-context-push-thread-default-context]. If this returns
	// false, you cannot perform asynchronous operations on @file in a thread
	// that has a thread-default context.
	SupportsThreadContexts() bool
}

// file implements the File interface.
type file struct {
	gextras.Objector
}

var _ File = (*file)(nil)

// WrapFile wraps a GObject to a type that implements interface
// File. It is primarily used internally.
func WrapFile(obj *externglib.Object) File {
	return File{
		Objector: obj,
	}
}

func marshalFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFile(obj), nil
}

// AppendTo gets an output stream for appending data to the file. If the
// file doesn't already exist it is created.
//
// By default files created are generally readable by everyone, but if you
// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
// the current user, to the level that is supported on the target
// filesystem.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// Some file systems don't allow all file names, and may return an
// G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible
// too, and depend on what kind of filesystem the file is on.
func (f file) AppendTo(flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_append_to(arg0, arg1, arg2, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AppendToAsync: asynchronously opens @file for appending.
//
// For more details, see g_file_append_to() which is the synchronous version
// of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_append_to_finish() to get the result of the operation.
func (f file) AppendToAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_append_to_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// AppendToFinish finishes an asynchronous file append operation started
// with g_file_append_to_async().
func (f file) AppendToFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_append_to_finish(arg0, arg1, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// BuildAttributeListForCopy prepares the file attribute query string for
// copying to @file.
//
// This function prepares an attribute query string to be passed to
// g_file_query_info() to get a list of attributes normally copied with the
// file (see g_file_copy_attributes() for the detailed description). This
// function is used by the implementation of g_file_copy_attributes() and is
// useful when one needs to query and set the attributes in two stages
// (e.g., for recursive move of a directory).
func (f file) BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (utf8 string, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileCopyFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCopyFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_build_attribute_list_for_copy(arg0, arg1, arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Copy copies the file @source to the location specified by @destination.
// Can not handle recursive copies of directories.
//
// If the flag FILE_COPY_OVERWRITE is specified an already existing
// @destination file is overwritten.
//
// If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will
// be copied as symlinks, otherwise the target of the @source symlink will
// be copied.
//
// If the flag FILE_COPY_ALL_METADATA is specified then all the metadata
// that is possible to copy is copied, not just the default subset (which,
// for instance, does not include the owner, see Info).
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not nil, then the operation can be monitored by
// setting this to a ProgressCallback function. @progress_callback_data will
// be passed to this function. It is guaranteed that this callback will be
// called after all data has been transferred with the total number of bytes
// copied during the operation.
//
// If the @source file does not exist, then the G_IO_ERROR_NOT_FOUND error
// is returned, independent on the status of the @destination.
//
// If FILE_COPY_OVERWRITE is not specified and the target exists, then the
// error G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the
// G_IO_ERROR_IS_DIRECTORY error is returned. If trying to overwrite a
// directory with a directory the G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// FILE_COPY_OVERWRITE is specified and the target is a file, then the
// G_IO_ERROR_WOULD_RECURSE error is returned.
//
// If you are interested in copying the #GFile object itself (not the
// on-disk file), see g_file_dup().
func (s file) Copy(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) error {
	var arg0 *C.GFile
	var arg1 *C.GFile
	var arg2 C.GFileCopyFlags
	var arg3 *C.GCancellable
	var arg4 C.GFileProgressCallback
	var arg5 C.gpointer
	var gError *C.GError

	arg0 = (*C.GFile)(s.Native())
	arg1 = (*C.GFile)(destination.Native())
	arg2 = (C.GFileCopyFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_FileProgressCallback)
	arg5 = C.gpointer(box.Assign(progressCallback))

	ret := C.g_file_copy(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// CopyAsync copies the file @source to the location specified by
// @destination asynchronously. For details of the behaviour, see
// g_file_copy().
//
// If @progress_callback is not nil, then that function that will be called
// just like in g_file_copy(). The callback will run in the default main
// context of the thread calling g_file_copy_async() â€” the same context as
// @callback is run in.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_copy_finish() to get the result of the operation.
func (s file) CopyAsync(destination File, flags FileCopyFlags, ioPriority int, cancellable Cancellable, progressCallback FileProgressCallback, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GFile
	var arg2 C.GFileCopyFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GFileProgressCallback
	var arg6 C.gpointer
	var arg7 C.GAsyncReadyCallback
	var arg8 C.gpointer

	arg0 = (*C.GFile)(s.Native())
	arg1 = (*C.GFile)(destination.Native())
	arg2 = (C.GFileCopyFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())

	C.g_file_copy_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// CopyAttributes copies the file attributes from @source to @destination.
//
// Normally only a subset of the file attributes are copied, those that are
// copies in a normal file copy operation (which for instance does not
// include e.g. owner). However if FILE_COPY_ALL_METADATA is specified in
// @flags, then all the metadata that is possible to copy is copied. This is
// useful when implementing move by copy + delete source.
func (s file) CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GFile
	var arg2 C.GFileCopyFlags
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(s.Native())
	arg1 = (*C.GFile)(destination.Native())
	arg2 = (C.GFileCopyFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_copy_attributes(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// CopyFinish finishes copying the file started with g_file_copy_async().
func (f file) CopyFinish(res AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_copy_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Create creates a new file and returns an output stream for writing to it.
// The file must not already exist.
//
// By default files created are generally readable by everyone, but if you
// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
// the current user, to the level that is supported on the target
// filesystem.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists the
// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
// if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
// Other errors are possible too, and depend on what kind of filesystem the
// file is on.
func (f file) Create(flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_create(arg0, arg1, arg2, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CreateAsync: asynchronously creates a new file and returns an output
// stream for writing to it. The file must not already exist.
//
// For more details, see g_file_create() which is the synchronous version of
// this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_create_finish() to get the result of the operation.
func (f file) CreateAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_create_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// CreateFinish finishes an asynchronous file create operation started with
// g_file_create_async().
func (f file) CreateFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_create_finish(arg0, arg1, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CreateReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone, but if you
// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
// the current user, to the level that is supported on the target
// filesystem.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists, the
// G_IO_ERROR_EXISTS error will be returned. Some file systems don't allow
// all file names, and may return an G_IO_ERROR_INVALID_FILENAME error, and
// if the name is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned.
// Other errors are possible too, and depend on what kind of filesystem the
// file is on.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
func (f file) CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_create_readwrite(arg0, arg1, arg2, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// CreateReadwriteAsync: asynchronously creates a new file and returns a
// stream for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_create_readwrite_finish() to get the result of the operation.
func (f file) CreateReadwriteAsync(flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GFileCreateFlags
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileCreateFlags)(flags)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_create_readwrite_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// CreateReadwriteFinish finishes an asynchronous file create operation
// started with g_file_create_readwrite_async().
func (f file) CreateReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_create_readwrite_finish(arg0, arg1, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Delete deletes a file. If the @file is a directory, it will only be
// deleted if it is empty. This has the same semantics as g_unlink().
//
// If @file doesnâ€™t exist, G_IO_ERROR_NOT_FOUND will be returned. This
// allows for deletion to be implemented avoiding time-of-check to
// time-of-use races
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
//
//    g_autoptr(GError) local_error = NULL;
//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//      {
//        // deletion failed for some reason other than the file not existing:
//        // so report the error
//        g_warning ("Failed to delete s: s",
//                   g_file_peek_path (my_file), local_error->message);
//      }
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) Delete(cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_delete(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// DeleteAsync: asynchronously delete a file. If the @file is a directory,
// it will only be deleted if it is empty. This has the same semantics as
// g_unlink().
func (f file) DeleteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_delete_async(arg0, arg1, arg2, arg3, arg4)
}

// DeleteFinish finishes deleting a file started with g_file_delete_async().
func (f file) DeleteFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_delete_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// Dup duplicates a #GFile handle. This operation does not duplicate the
// actual file or directory represented by the #GFile; see g_file_copy() if
// attempting to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same
// underlying file, for use in a separate thread (#GFile is not
// thread-safe). For use within the same thread, use g_object_ref() to
// increment the existing objectâ€™s reference count.
//
// This call does no blocking I/O.
func (f file) Dup() File {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_dup(arg0)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// EjectMountable starts an asynchronous eject on a mountable. When this
// operation has completed, @callback will be called with @user_user data,
// and the operation can be finalized with g_file_eject_mountable_finish().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) EjectMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountUnmountFlags
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountUnmountFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_eject_mountable(arg0, arg1, arg2, arg3, arg4)
}

// EjectMountableFinish finishes an asynchronous eject operation started by
// g_file_eject_mountable().
func (f file) EjectMountableFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_eject_mountable_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// EjectMountableWithOperation starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) EjectMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountUnmountFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountUnmountFlags)(flags)
	arg2 = (*C.GMountOperation)(mountOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_eject_mountable_with_operation(arg0, arg1, arg2, arg3, arg4, arg5)
}

// EjectMountableWithOperationFinish finishes an asynchronous eject
// operation started by g_file_eject_mountable_with_operation().
func (f file) EjectMountableWithOperationFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_eject_mountable_with_operation_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// EnumerateChildren gets the requested information about the files in a
// directory. The result is a Enumerator object that will give out Info
// objects for all the files in the directory.
//
// The @attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set.
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace. An example
// attribute query be "standard::*,owner::user". The standard attributes are
// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is not a directory, the G_IO_ERROR_NOT_DIRECTORY
// error will be returned. Other errors are possible too.
func (f file) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (fileEnumerator FileEnumerator, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.GFileQueryInfoFlags
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_enumerate_children(arg0, arg1, arg2, arg3, &gError)

	var ret0 FileEnumerator
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileEnumerator)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// EnumerateChildrenAsync: asynchronously gets the requested information
// about the files in a directory. The result is a Enumerator object that
// will give out Info objects for all the files in the directory.
//
// For more details, see g_file_enumerate_children() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_enumerate_children_finish() to get the result of the
// operation.
func (f file) EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.GFileQueryInfoFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	var arg6 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg6 = C.gpointer(box.Assign(callback))

	C.g_file_enumerate_children_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// EnumerateChildrenFinish finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
func (f file) EnumerateChildrenFinish(res AsyncResult) (fileEnumerator FileEnumerator, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_enumerate_children_finish(arg0, arg1, &gError)

	var ret0 FileEnumerator
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileEnumerator)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Equal checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
//
// This call does no blocking I/O.
func (f file) Equal(file2 File) bool {
	var arg0 *C.GFile
	var arg1 *C.GFile

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GFile)(file2.Native())

	ret := C.g_file_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// FindEnclosingMount gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see Monitor. If
// the Iface for @file does not have a #mount, @error will be set to
// G_IO_ERROR_NOT_FOUND and nil #will be returned.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) FindEnclosingMount(cancellable Cancellable) (mount Mount, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_find_enclosing_mount(arg0, arg1, &gError)

	var ret0 Mount
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Mount)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// FindEnclosingMountAsync: asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_find_enclosing_mount_finish() to get the result of the
// operation.
func (f file) FindEnclosingMountAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_find_enclosing_mount_async(arg0, arg1, arg2, arg3, arg4)
}

// FindEnclosingMountFinish finishes an asynchronous find mount request. See
// g_file_find_enclosing_mount_async().
func (f file) FindEnclosingMountFinish(res AsyncResult) (mount Mount, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_find_enclosing_mount_finish(arg0, arg1, &gError)

	var ret0 Mount
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Mount)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Basename gets the base name (the last component of the path) for a given
// #GFile.
//
// If called for the top level of a system (such as the filesystem root or a
// uri like sftp://host/) it will return a single directory separator (and
// on Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding or
// rules other than it may not contain zero bytes. If you want to use
// filenames in a user interface you should use the display name that you
// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// attribute with g_file_query_info().
//
// This call does no blocking I/O.
func (f file) Basename() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_basename(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Child gets a child of @file with basename equal to @name.
//
// Note that the file with that specific name might not exist, but you can
// still have a #GFile that points to it. You can use this for instance to
// create that file.
//
// This call does no blocking I/O.
func (f file) Child(name string) File {
	var arg0 *C.GFile
	var arg1 *C.char

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_get_child(arg0, arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// ChildForDisplayName gets the child of @file for a given @display_name
// (i.e. a UTF-8 version of the name). If this function fails, it returns
// nil and @error will be set. This is very useful when constructing a
// #GFile for a new file and the user entered the filename in the user
// interface, for instance when you select a directory and type a filename
// in the file selector.
//
// This call does no blocking I/O.
func (f file) ChildForDisplayName(displayName string) (file File, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_get_child_for_display_name(arg0, arg1, &gError)

	var ret0 File
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Parent gets the parent directory for the @file. If the @file represents
// the root directory of the file system, then nil will be returned.
//
// This call does no blocking I/O.
func (f file) Parent() File {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_parent(arg0)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// ParseName gets the parse name of the @file. A parse name is a UTF-8
// string that describes the file such that one can get the #GFile back
// using g_file_parse_name().
//
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
//
// For local files with names that can safely be converted to UTF-8 the
// pathname is used, otherwise the IRI is used (a form of URI that allows
// UTF-8 characters unescaped).
//
// This call does no blocking I/O.
func (f file) ParseName() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_parse_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// Path gets the local pathname for #GFile, if one exists. If non-nil, this
// is guaranteed to be an absolute, canonical path. It might contain
// symlinks.
//
// This call does no blocking I/O.
func (f file) Path() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// RelativePath gets the path for @descendant relative to @parent.
//
// This call does no blocking I/O.
func (p file) RelativePath(descendant File) string {
	var arg0 *C.GFile
	var arg1 *C.GFile

	arg0 = (*C.GFile)(p.Native())
	arg1 = (*C.GFile)(descendant.Native())

	ret := C.g_file_get_relative_path(arg0, arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URI gets the URI for the @file.
//
// This call does no blocking I/O.
func (f file) URI() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_uri(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
// as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile, in
// that it might be replaced with one that is logically equivalent to the
// #GFile.
//
// This call does no blocking I/O.
func (f file) URIScheme() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_get_uri_scheme(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// HasParent checks if @file has a parent, and optionally, if it is @parent.
//
// If @parent is nil then this function returns true if @file has any parent
// at all. If @parent is non-nil then true is only returned if @file is an
// immediate child of @parent.
func (f file) HasParent(parent File) bool {
	var arg0 *C.GFile
	var arg1 *C.GFile

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GFile)(parent.Native())

	ret := C.g_file_has_parent(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// HasPrefix checks whether @file has the prefix specified by @prefix.
//
// In other words, if the names of initial elements of @file's pathname
// match @prefix. Only full pathname elements are matched, so a path like
// /foo is not considered a prefix of /foobar, only of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for equality,
// use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can
// sometimes return false even if @file is inside a @prefix (from a
// filesystem point of view), because the prefix of @file is an alias of
// @prefix.
func (f file) HasPrefix(prefix File) bool {
	var arg0 *C.GFile
	var arg1 *C.GFile

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GFile)(prefix.Native())

	ret := C.g_file_has_prefix(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// HasURIScheme checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
func (f file) HasURIScheme(uriScheme string) bool {
	var arg0 *C.GFile
	var arg1 *C.char

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_has_uri_scheme(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Hash creates a hash value for a #GFile.
//
// This call does no blocking I/O.
func (f file) Hash() uint {
	var arg0 C.gpointer

	arg0 = (C.gpointer)(f.Native())

	ret := C.g_file_hash(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// IsNative checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native
// filesystem via a userspace filesystem (FUSE), in these cases this call
// will return false, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
func (f file) IsNative() bool {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_is_native(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// LoadBytes loads the contents of @file and returns it as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference
// the embedded resource instead of a copy. Otherwise, this is equivalent to
// calling g_file_load_contents() and g_bytes_new_take().
//
// For resources, @etag_out will be set to nil.
//
// The data contained in the resulting #GBytes is always zero-terminated,
// but this is not included in the #GBytes length. The resulting #GBytes
// should be freed with g_bytes_unref() when no longer in use.
func (f file) LoadBytes(cancellable Cancellable) (etagOut string, bytes *glib.Bytes, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_load_bytes(arg0, arg1, &arg2, &gError)

	var ret0 string
	var ret1 *glib.Bytes
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	{
		ret1 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadBytesAsync: asynchronously loads the contents of @file as #GBytes.
//
// If @file is a resource:// based URI, the resulting bytes will reference
// the embedded resource instead of a copy. Otherwise, this is equivalent to
// calling g_file_load_contents_async() and g_bytes_new_take().
//
// @callback should call g_file_load_bytes_finish() to get the result of
// this asynchronous operation.
//
// See g_file_load_bytes() for more information.
func (f file) LoadBytesAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.g_file_load_bytes_async(arg0, arg1, arg2, arg3)
}

// LoadBytesFinish completes an asynchronous request to
// g_file_load_bytes_async().
//
// For resources, @etag_out will be set to nil.
//
// The data contained in the resulting #GBytes is always zero-terminated,
// but this is not included in the #GBytes length. The resulting #GBytes
// should be freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
func (f file) LoadBytesFinish(result AsyncResult) (etagOut string, bytes *glib.Bytes, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 **C.gchar // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_load_bytes_finish(arg0, arg1, &arg2, &gError)

	var ret0 string
	var ret1 *glib.Bytes
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	{
		ret1 = glib.WrapBytes(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *glib.Bytes) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// LoadContents loads the content of the file into memory. The data is
// always zero-terminated, but this is not included in the resultant
// @length. The returned @contents should be freed with g_free() when no
// longer needed.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) LoadContents(cancellable Cancellable) (contents []byte, length uint, etagOut string, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 **C.char // out
	var arg3 *C.gsize // out
	var arg4 **C.char // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_load_contents(arg0, arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 string
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret1 = uint(arg3)

	ret2 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// LoadContentsAsync starts an asynchronous load of the @file's contents.
//
// For more details, see g_file_load_contents() which is the synchronous
// version of this call.
//
// When the load operation has completed, @callback will be called with
// @user data. To finish the operation, call g_file_load_contents_finish()
// with the Result returned by the @callback.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) LoadContentsAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.g_file_load_contents_async(arg0, arg1, arg2, arg3)
}

// LoadContentsFinish finishes an asynchronous load of the @file's contents.
// The contents are placed in @contents, and @length is set to the size of
// the @contents string. The @contents should be freed with g_free() when no
// longer needed. If @etag_out is present, it will be set to the new entity
// tag for the @file.
func (f file) LoadContentsFinish(res AsyncResult) (contents []byte, length uint, etagOut string, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 **C.char // out
	var arg3 *C.gsize // out
	var arg4 **C.char // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_load_contents_finish(arg0, arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 string
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret1 = uint(arg3)

	ret2 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// LoadPartialContentsAsync reads the partial contents of a file. A
// ReadMoreCallback should be used to stop reading from the file when
// appropriate, else this function will behave exactly as
// g_file_load_contents_async(). This operation can be finished by
// g_file_load_partial_contents_finish().
//
// Users of this function should be aware that @user_data is passed to both
// the @read_more_callback and the @callback.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) LoadPartialContentsAsync(cancellable Cancellable, readMoreCallback FileReadMoreCallback, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 C.GFileReadMoreCallback
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_FileReadMoreCallback)
	arg4 = C.gpointer(box.Assign(readMoreCallback))
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_load_partial_contents_async(arg0, arg1, arg2, arg3, arg4)
}

// LoadPartialContentsFinish finishes an asynchronous partial load operation
// that was started with g_file_load_partial_contents_async(). The data is
// always zero-terminated, but this is not included in the resultant
// @length. The returned @contents should be freed with g_free() when no
// longer needed.
func (f file) LoadPartialContentsFinish(res AsyncResult) (contents []byte, length uint, etagOut string, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 **C.char // out
	var arg3 *C.gsize // out
	var arg4 **C.char // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_load_partial_contents_finish(arg0, arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 []byte
	var ret1 uint
	var ret2 string
	var goError error

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret0))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg2))
		sliceHeader.Len = arg3
		sliceHeader.Cap = arg3
		runtime.SetFinalizer(&arg2, func() {
			C.free(unsafe.Pointer(arg2))
		})
		defer runtime.KeepAlive(arg2)
	}

	ret1 = uint(arg3)

	ret2 = C.GoString(arg4)
	C.free(unsafe.Pointer(arg4))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// MakeDirectory creates a directory. Note that this will only create a
// child directory of the immediate parent directory of the path or URI
// given by the #GFile. To recursively create directories, see
// g_file_make_directory_with_parents(). This function will fail if the
// parent directory does not exist, setting @error to G_IO_ERROR_NOT_FOUND.
// If the file system doesn't support creating directories, this function
// will fail, setting @error to G_IO_ERROR_NOT_SUPPORTED.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) MakeDirectory(cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_make_directory(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MakeDirectoryAsync: asynchronously creates a directory.
func (f file) MakeDirectoryAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_make_directory_async(arg0, arg1, arg2, arg3, arg4)
}

// MakeDirectoryFinish finishes an asynchronous directory creation, started
// with g_file_make_directory_async().
func (f file) MakeDirectoryFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_make_directory_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MakeDirectoryWithParents creates a directory and any parent directories
// that may not exist similar to 'mkdir -p'. If the file system does not
// support creating directories, this function will fail, setting @error to
// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
// function will fail setting @error to G_IO_ERROR_EXISTS, unlike the
// similar g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) MakeDirectoryWithParents(cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_make_directory_with_parents(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MakeSymbolicLink creates a symbolic link named @file which contains the
// string @symlink_value.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) MakeSymbolicLink(symlinkValue string, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(symlinkValue))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_make_symbolic_link(arg0, arg1, arg2, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MeasureDiskUsage: recursively measures the disk usage of @file.
//
// This is essentially an analog of the 'du' command, but it also reports
// the number of directories and non-directory files encountered (including
// things like symbolic links).
//
// By default, errors are only reported against the toplevel file itself.
// Errors found while recursing are silently ignored, unless
// G_FILE_MEASURE_REPORT_ANY_ERROR is given in @flags.
//
// The returned size, @disk_usage, is in bytes and should be formatted with
// g_format_size() in order to get something reasonable for showing in a
// user interface.
//
// @progress_callback and @progress_data can be given to request periodic
// progress updates while scanning. See the documentation for
// MeasureProgressCallback for information about when and how the callback
// will be invoked.
func (f file) MeasureDiskUsage(flags FileMeasureFlags, cancellable Cancellable, progressCallback FileMeasureProgressCallback) (diskUsage uint64, numDirs uint64, numFiles uint64, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileMeasureFlags
	var arg2 *C.GCancellable
	var arg3 C.GFileMeasureProgressCallback
	var arg4 C.gpointer
	var arg5 *C.guint64 // out
	var arg6 *C.guint64 // out
	var arg7 *C.guint64 // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileMeasureFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_FileMeasureProgressCallback)
	arg4 = C.gpointer(box.Assign(progressCallback))

	ret := C.g_file_measure_disk_usage(arg0, arg1, arg2, arg3, arg4, &arg5, &arg6, &arg7, &gError)

	var ret0 uint64
	var ret1 uint64
	var ret2 uint64
	var goError error

	ret0 = uint64(arg5)

	ret1 = uint64(arg6)

	ret2 = uint64(arg7)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// MeasureDiskUsageAsync: recursively measures the disk usage of @file.
//
// This is the asynchronous version of g_file_measure_disk_usage(). See
// there for more information.
func (f file) MeasureDiskUsageAsync(flags FileMeasureFlags, ioPriority int, cancellable Cancellable, progressCallback FileMeasureProgressCallback, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GFileMeasureFlags
	var arg2 C.gint
	var arg3 *C.GCancellable
	var arg4 C.GFileMeasureProgressCallback
	var arg5 C.gpointer
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileMeasureFlags)(flags)
	arg2 = C.gint(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_FileMeasureProgressCallback)
	arg5 = C.gpointer(box.Assign(progressCallback))
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.g_file_measure_disk_usage_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// MeasureDiskUsageFinish collects the results from an earlier call to
// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for
// more information.
func (f file) MeasureDiskUsageFinish(result AsyncResult) (diskUsage uint64, numDirs uint64, numFiles uint64, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 *C.guint64 // out
	var arg3 *C.guint64 // out
	var arg4 *C.guint64 // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_measure_disk_usage_finish(arg0, arg1, &arg2, &arg3, &arg4, &gError)

	var ret0 uint64
	var ret1 uint64
	var ret2 uint64
	var goError error

	ret0 = uint64(arg2)

	ret1 = uint64(arg3)

	ret2 = uint64(arg4)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, ret2, goError
}

// Monitor obtains a file or directory monitor for the given file, depending
// on the type of the file.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) Monitor(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileMonitorFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileMonitorFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_monitor(arg0, arg1, arg2, &gError)

	var ret0 FileMonitor
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileMonitor)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MonitorDirectory obtains a directory monitor for the given file. This may
// fail if directory monitoring is not supported.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// It does not make sense for @flags to contain
// G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
// directories. It is not possible to monitor all the files in a directory
// for changes made via hard links; if you want to do this then you must
// register individual watches with g_file_monitor().
func (f file) MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileMonitorFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileMonitorFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_monitor_directory(arg0, arg1, arg2, &gError)

	var ret0 FileMonitor
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileMonitor)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MonitorFile obtains a file monitor for the given file. If no file
// notification mechanism exists, then regular polling of the file is used.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If @flags contains G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor will
// also attempt to report changes made to the file via another filename (ie,
// a hard link). Without this flag, you can only rely on changes made
// through the filename contained in @file to be reported. Using this flag
// may result in an increase in resource usage, and may not have any effect
// depending on the Monitor backend and/or filesystem type.
func (f file) MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (fileMonitor FileMonitor, err error) {
	var arg0 *C.GFile
	var arg1 C.GFileMonitorFlags
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileMonitorFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_monitor_file(arg0, arg1, arg2, &gError)

	var ret0 FileMonitor
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileMonitor)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// MountEnclosingVolume starts a @mount_operation, mounting the volume that
// contains the file @location.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (l file) MountEnclosingVolume(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountMountFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(l.Native())
	arg1 = (C.GMountMountFlags)(flags)
	arg2 = (*C.GMountOperation)(mountOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_mount_enclosing_volume(arg0, arg1, arg2, arg3, arg4, arg5)
}

// MountEnclosingVolumeFinish finishes a mount operation started by
// g_file_mount_enclosing_volume().
func (l file) MountEnclosingVolumeFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(l.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_mount_enclosing_volume_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// MountMountable mounts a file of type G_FILE_TYPE_MOUNTABLE. Using
// @mount_operation, you can request callbacks when, for instance, passwords
// are needed during authentication.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_mount_mountable_finish() to get the result of the operation.
func (f file) MountMountable(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountMountFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountMountFlags)(flags)
	arg2 = (*C.GMountOperation)(mountOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_mount_mountable(arg0, arg1, arg2, arg3, arg4, arg5)
}

// MountMountableFinish finishes a mount operation. See
// g_file_mount_mountable() for details.
//
// Finish an asynchronous mount operation that was started with
// g_file_mount_mountable().
func (f file) MountMountableFinish(result AsyncResult) (file File, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_mount_mountable_finish(arg0, arg1, &gError)

	var ret0 File
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Move tries to move the file or directory @source to the location
// specified by @destination. If native move operations are supported then
// this is used, otherwise a copy + delete fallback is used. The native
// implementation may support moving directories (for instance on moves
// inside the same filesystem), but the fallback code does not.
//
// If the flag FILE_COPY_OVERWRITE is specified an already existing
// @destination file is overwritten.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If @progress_callback is not nil, then the operation can be monitored by
// setting this to a ProgressCallback function. @progress_callback_data will
// be passed to this function. It is guaranteed that this callback will be
// called after all data has been transferred with the total number of bytes
// copied during the operation.
//
// If the @source file does not exist, then the G_IO_ERROR_NOT_FOUND error
// is returned, independent on the status of the @destination.
//
// If FILE_COPY_OVERWRITE is not specified and the target exists, then the
// error G_IO_ERROR_EXISTS is returned.
//
// If trying to overwrite a file over a directory, the
// G_IO_ERROR_IS_DIRECTORY error is returned. If trying to overwrite a
// directory with a directory the G_IO_ERROR_WOULD_MERGE error is returned.
//
// If the source is a directory and the target does not exist, or
// FILE_COPY_OVERWRITE is specified and the target is a file, then the
// G_IO_ERROR_WOULD_RECURSE error may be returned (if the native move
// operation isn't available).
func (s file) Move(destination File, flags FileCopyFlags, cancellable Cancellable, progressCallback FileProgressCallback) error {
	var arg0 *C.GFile
	var arg1 *C.GFile
	var arg2 C.GFileCopyFlags
	var arg3 *C.GCancellable
	var arg4 C.GFileProgressCallback
	var arg5 C.gpointer
	var gError *C.GError

	arg0 = (*C.GFile)(s.Native())
	arg1 = (*C.GFile)(destination.Native())
	arg2 = (C.GFileCopyFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_FileProgressCallback)
	arg5 = C.gpointer(box.Assign(progressCallback))

	ret := C.g_file_move(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// OpenReadwrite opens an existing file for reading and writing. The result
// is a IOStream that can be used to read and write the contents of the
// file.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
// will be returned. Other errors are possible too, and depend on what kind
// of filesystem the file is on. Note that in many non-local file cases read
// and write streams are not supported, so make sure you really need to do
// read and write streaming, rather than just opening for reading or
// writing.
func (f file) OpenReadwrite(cancellable Cancellable) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_open_readwrite(arg0, arg1, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// OpenReadwriteAsync: asynchronously opens @file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_open_readwrite_finish() to get the result of the operation.
func (f file) OpenReadwriteAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_open_readwrite_async(arg0, arg1, arg2, arg3, arg4)
}

// OpenReadwriteFinish finishes an asynchronous file read operation started
// with g_file_open_readwrite_async().
func (f file) OpenReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_open_readwrite_finish(arg0, arg1, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications
// which mix `g_file_*` APIs with native ones. It also avoids an extra
// duplicated string when possible, so will be generally more efficient.
//
// This call does no blocking I/O.
func (f file) PeekPath() string {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_peek_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PollMountable polls a file of type FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_mount_mountable_finish() to get the result of the operation.
func (f file) PollMountable(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.g_file_poll_mountable(arg0, arg1, arg2, arg3)
}

// PollMountableFinish finishes a poll operation. See
// g_file_poll_mountable() for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
func (f file) PollMountableFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_poll_mountable_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// QueryDefaultHandler returns the Info that is registered as the default
// application to handle the file specified by @file.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) QueryDefaultHandler(cancellable Cancellable) (appInfo AppInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_default_handler(arg0, arg1, &gError)

	var ret0 AppInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(AppInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryDefaultHandlerAsync: async version of
// g_file_query_default_handler().
func (f file) QueryDefaultHandlerAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_query_default_handler_async(arg0, arg1, arg2, arg3, arg4)
}

// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
// operation.
func (f file) QueryDefaultHandlerFinish(result AsyncResult) (appInfo AppInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_query_default_handler_finish(arg0, arg1, &gError)

	var ret0 AppInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(AppInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryExists: utility function to check if a particular file exists. This
// is implemented using g_file_query_info() and as such does blocking I/O.
//
// Note that in many cases it is racy to first check for file existence
// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
// execute something based on the outcome of that, because the file might
// have been created or removed in between the operations. The general
// approach to handling that is to not check, but just do the operation and
// handle the errors as they come.
//
// As an example of race-free checking, take the case of reading a file, and
// if it doesn't exist, creating it. There are two racy versions: read it,
// and on error create it; and: check if it exists, if not create it. These
// can both result in two processes creating the file (with perhaps a
// partially written file as the result). The correct approach is to always
// try to create the file with g_file_create() which will either atomically
// create the file or fail with a G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface,
// for instance to make a menu item sensitive/insensitive, so that you don't
// have to fool users that something is possible and then just show an error
// dialog. If you do this, you should make sure to also handle the errors
// that can happen due to races when you execute the operation.
func (f file) QueryExists(cancellable Cancellable) bool {
	var arg0 *C.GFile
	var arg1 *C.GCancellable

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_exists(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// QueryFileType: utility function to inspect the Type of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// The primary use case of this method is to check if a file is a regular
// file, directory, or symlink.
func (f file) QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType {
	var arg0 *C.GFile
	var arg1 C.GFileQueryInfoFlags
	var arg2 *C.GCancellable

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GFileQueryInfoFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_file_type(arg0, arg1, arg2)

	var ret0 FileType

	ret0 = FileType(ret)

	return ret0
}

// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
// information about the filesystem the @file is on, rather than the file
// itself. For instance the amount of space available and the type of the
// filesystem.
//
// The @attributes value is a string that specifies the attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set.
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard "*" means all attributes, and a wildcard like
// "filesystem::*" means all attributes in the filesystem namespace. The
// standard namespace for filesystem attributes is "filesystem". Common
// attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size
// of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
// bytes available), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the
// filesystem).
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
func (f file) QueryFilesystemInfo(attributes string, cancellable Cancellable) (fileInfo FileInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_filesystem_info(arg0, arg1, arg2, &gError)

	var ret0 FileInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryFilesystemInfoAsync: asynchronously gets the requested information
// about the filesystem that the specified @file is on. The result is a Info
// object that contains key-value attributes (such as type or size for the
// file).
//
// For more details, see g_file_query_filesystem_info() which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_query_info_finish() to get the result of the operation.
func (f file) QueryFilesystemInfoAsync(attributes string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_query_filesystem_info_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
func (f file) QueryFilesystemInfoFinish(res AsyncResult) (fileInfo FileInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_query_filesystem_info_finish(arg0, arg1, &gError)

	var ret0 FileInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryInfo gets the requested information about specified @file. The
// result is a Info object that contains key-value attributes (such as the
// type or size of the file).
//
// The @attributes value is a string that specifies the file attributes that
// should be gathered. It is not an error if it's not possible to read a
// particular requested attribute from a file - it just won't be set.
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace. An example
// attribute query be "standard::*,owner::user". The standard attributes are
// available as defines, like FILE_ATTRIBUTE_STANDARD_NAME.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// For symlinks, normally the information about the target of the symlink is
// returned, rather than information about the symlink itself. However if
// you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the information
// about the symlink itself will be returned. Also, for symlinks that point
// to non-existing files the information about the symlink itself will be
// returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
func (f file) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (fileInfo FileInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.GFileQueryInfoFlags
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_info(arg0, arg1, arg2, arg3, &gError)

	var ret0 FileInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryInfoAsync: asynchronously gets the requested information about
// specified @file. The result is a Info object that contains key-value
// attributes (such as type or size for the file).
//
// For more details, see g_file_query_info() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_query_info_finish() to get the result of the operation.
func (f file) QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.GFileQueryInfoFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	var arg6 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attributes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg6 = C.gpointer(box.Assign(callback))

	C.g_file_query_info_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// QueryInfoFinish finishes an asynchronous file info query. See
// g_file_query_info_async().
func (f file) QueryInfoFinish(res AsyncResult) (fileInfo FileInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_query_info_finish(arg0, arg1, &gError)

	var ret0 FileInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QuerySettableAttributes: obtain the list of settable attributes for the
// file.
//
// Returns the type and full attribute name of all the attributes that can
// be set on this file. This doesn't mean setting it will always succeed
// though, you might get an access failure, or some specific file may not
// support a specific attribute.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) QuerySettableAttributes(cancellable Cancellable) (fileAttributeInfoList *FileAttributeInfoList, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_settable_attributes(arg0, arg1, &gError)

	var ret0 *FileAttributeInfoList
	var goError error

	{
		ret0 = WrapFileAttributeInfoList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *FileAttributeInfoList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// QueryWritableNamespaces: obtain the list of attribute namespaces where
// new attributes can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) QueryWritableNamespaces(cancellable Cancellable) (fileAttributeInfoList *FileAttributeInfoList, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_query_writable_namespaces(arg0, arg1, &gError)

	var ret0 *FileAttributeInfoList
	var goError error

	{
		ret0 = WrapFileAttributeInfoList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *FileAttributeInfoList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Read opens a file for reading. The result is a InputStream that can be
// used to read the contents of the file.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error
// will be returned. Other errors are possible too, and depend on what kind
// of filesystem the file is on.
func (f file) Read(cancellable Cancellable) (fileInputStream FileInputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_read(arg0, arg1, &gError)

	var ret0 FileInputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReadAsync: asynchronously opens @file for reading.
//
// For more details, see g_file_read() which is the synchronous version of
// this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_read_finish() to get the result of the operation.
func (f file) ReadAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_read_async(arg0, arg1, arg2, arg3, arg4)
}

// ReadFinish finishes an asynchronous file read operation started with
// g_file_read_async().
func (f file) ReadFinish(res AsyncResult) (fileInputStream FileInputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_read_finish(arg0, arg1, &gError)

	var ret0 FileInputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileInputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Replace returns an output stream for overwriting the file, possibly
// creating a backup copy of the file first. If the file doesn't exist, it
// will be created.
//
// This will try to replace the file in the safest way possible so that any
// errors during the writing will not affect an already existing copy of the
// file. For instance, for local files it may write to a temporary file and
// then atomically rename over the destination when the stream is closed.
//
// By default files created are generally readable by everyone, but if you
// pass FILE_CREATE_PRIVATE in @flags the file will be made readable only to
// the current user, to the level that is supported on the target
// filesystem.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If you pass in a non-nil @etag value and @file already exists, then this
// value is compared to the current entity tag of the file, and if they
// differ an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
// that the file has been changed since you last read it. You can get the
// new etag from g_file_output_stream_get_etag() after you've finished
// writing and closed the OutputStream. When you load a new file you can use
// g_file_input_stream_query_info() to get the etag of the file.
//
// If @make_backup is true, this function will attempt to make a backup of
// the current file before overwriting it. If this fails a
// G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you want to
// replace anyway, try again with @make_backup set to false.
//
// If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be
// returned, and if the file is some other form of non-regular file then a
// G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file systems
// don't allow all file names, and may return an G_IO_ERROR_INVALID_FILENAME
// error, and if the name is to long G_IO_ERROR_FILENAME_TOO_LONG will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
func (f file) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gboolean
	var arg3 C.GFileCreateFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg1))
	if makeBackup {
		arg2 = C.TRUE
	}
	arg3 = (C.GFileCreateFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_replace(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceAsync: asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace() which is the synchronous version
// of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_replace_finish() to get the result of the operation.
func (f file) ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gboolean
	var arg3 C.GFileCreateFlags
	var arg4 C.int
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg1))
	if makeBackup {
		arg2 = C.TRUE
	}
	arg3 = (C.GFileCreateFlags)(flags)
	arg4 = C.int(ioPriority)
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.g_file_replace_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// ReplaceContents replaces the contents of @file with @contents of @length
// bytes.
//
// If @etag is specified (not nil), any existing file must have that etag,
// or the error G_IO_ERROR_WRONG_ETAG will be returned.
//
// If @make_backup is true, this function will attempt to make a backup of
// @file. Internally, it uses g_file_replace(), so will try to replace the
// file contents in the safest way possible. For example, atomic renames are
// used when replacing local filesâ€™ contents.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// The returned @new_etag can be used to verify that the file hasn't changed
// the next time it is saved over.
func (f file) ReplaceContents(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (newEtag string, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gsize
	var arg3 *C.char
	var arg4 C.gboolean
	var arg5 C.GFileCreateFlags
	var arg6 **C.char // out
	var arg7 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.char)(unsafe.Pointer(&contents[0]))
	arg2 = len(contents)
	defer runtime.KeepAlive(contents)
	arg3 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg3))
	if makeBackup {
		arg4 = C.TRUE
	}
	arg5 = (C.GFileCreateFlags)(flags)
	arg7 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_replace_contents(arg0, arg1, arg2, arg3, arg4, arg5, &arg6, arg7, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg6)
	C.free(unsafe.Pointer(arg6))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceContentsAsync starts an asynchronous replacement of @file with the
// given @contents of @length bytes. @etag will replace the document's
// current entity tag.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// If @make_backup is true, this function will attempt to make a backup of
// @file.
//
// Note that no copy of @contents will be made, so it must stay valid until
// @callback is called. See g_file_replace_contents_bytes_async() for a
// #GBytes version that will automatically hold a reference to the contents
// (without copying) for the duration of the call.
func (f file) ReplaceContentsAsync(contents []byte, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gsize
	var arg3 *C.char
	var arg4 C.gboolean
	var arg5 C.GFileCreateFlags
	var arg6 *C.GCancellable
	var arg7 C.GAsyncReadyCallback
	var arg8 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.char)(unsafe.Pointer(&contents[0]))
	arg2 = len(contents)
	defer runtime.KeepAlive(contents)
	arg3 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg3))
	if makeBackup {
		arg4 = C.TRUE
	}
	arg5 = (C.GFileCreateFlags)(flags)
	arg6 = (*C.GCancellable)(cancellable.Native())
	arg7 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg8 = C.gpointer(box.Assign(callback))

	C.g_file_replace_contents_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
}

// ReplaceContentsBytesAsync: same as g_file_replace_contents_async() but
// takes a #GBytes input instead. This function will keep a ref on @contents
// until the operation is done. Unlike g_file_replace_contents_async() this
// allows forgetting about the content without waiting for the callback.
//
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
func (f file) ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GBytes
	var arg2 *C.char
	var arg3 C.gboolean
	var arg4 C.GFileCreateFlags
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GBytes)(contents.Native())
	arg2 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg2))
	if makeBackup {
		arg3 = C.TRUE
	}
	arg4 = (C.GFileCreateFlags)(flags)
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.g_file_replace_contents_bytes_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// ReplaceContentsFinish finishes an asynchronous replace of the given
// @file. See g_file_replace_contents_async(). Sets @new_etag to the new
// entity tag for the document, if present.
func (f file) ReplaceContentsFinish(res AsyncResult) (newEtag string, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 **C.char // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_replace_contents_finish(arg0, arg1, &arg2, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceFinish finishes an asynchronous file replace operation started
// with g_file_replace_async().
func (f file) ReplaceFinish(res AsyncResult) (fileOutputStream FileOutputStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_replace_finish(arg0, arg1, &gError)

	var ret0 FileOutputStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileOutputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
func (f file) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gboolean
	var arg3 C.GFileCreateFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg1))
	if makeBackup {
		arg2 = C.TRUE
	}
	arg3 = (C.GFileCreateFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_replace_readwrite(arg0, arg1, arg2, arg3, arg4, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReplaceReadwriteAsync: asynchronously overwrites the file in read-write
// mode, replacing the contents, possibly creating a backup copy of the file
// first.
//
// For more details, see g_file_replace_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_replace_readwrite_finish() to get the result of the
// operation.
func (f file) ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gboolean
	var arg3 C.GFileCreateFlags
	var arg4 C.int
	var arg5 *C.GCancellable
	var arg6 C.GAsyncReadyCallback
	var arg7 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(etag))
	defer C.free(unsafe.Pointer(arg1))
	if makeBackup {
		arg2 = C.TRUE
	}
	arg3 = (C.GFileCreateFlags)(flags)
	arg4 = C.int(ioPriority)
	arg5 = (*C.GCancellable)(cancellable.Native())
	arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg7 = C.gpointer(box.Assign(callback))

	C.g_file_replace_readwrite_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// ReplaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
func (f file) ReplaceReadwriteFinish(res AsyncResult) (fileIOStream FileIOStream, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_replace_readwrite_finish(arg0, arg1, &gError)

	var ret0 FileIOStream
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(FileIOStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ResolveRelativePath resolves a relative path for @file to an absolute
// path.
//
// This call does no blocking I/O.
func (f file) ResolveRelativePath(relativePath string) File {
	var arg0 *C.GFile
	var arg1 *C.char

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(relativePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_file_resolve_relative_path(arg0, arg1)

	var ret0 File

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	return ret0
}

// SetAttribute sets an attribute in the file with attribute name @attribute
// to @value_p.
//
// Some attributes can be unset by setting @type to
// G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to nil.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttribute(attribute string, typ FileAttributeType, valueP interface{}, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.GFileAttributeType
	var arg3 C.gpointer
	var arg4 C.GFileQueryInfoFlags
	var arg5 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeType)(typ)
	arg3 = C.gpointer(box.Assign(valueP))
	arg4 = (C.GFileQueryInfoFlags)(flags)
	arg5 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeByteString sets @attribute of type
// G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value. If @attribute is of a
// different type, this operation will fail, returning false.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_byte_string(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeInt32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to
// @value. If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gint32
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint32(value)
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_int32(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeInt64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to
// @value. If @attribute is of a different type, this operation will fail.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.gint64
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint64(value)
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_int64(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeString sets @attribute of type G_FILE_ATTRIBUTE_TYPE_STRING
// to @value. If @attribute is of a different type, this operation will
// fail.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 *C.char
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_string(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeUint32 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32
// to @value. If @attribute is of a different type, this operation will
// fail.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.guint32
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint32(value)
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_uint32(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributeUint64 sets @attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64
// to @value. If @attribute is of a different type, this operation will
// fail.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.guint64
	var arg3 C.GFileQueryInfoFlags
	var arg4 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(value)
	arg3 = (C.GFileQueryInfoFlags)(flags)
	arg4 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attribute_uint64(arg0, arg1, arg2, arg3, arg4, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetAttributesAsync: asynchronously sets the attributes of @file with
// @info.
//
// For more details, see g_file_set_attributes_from_info(), which is the
// synchronous version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_set_attributes_finish() to get the result of the operation.
func (f file) SetAttributesAsync(info FileInfo, flags FileQueryInfoFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.GFileInfo
	var arg2 C.GFileQueryInfoFlags
	var arg3 C.int
	var arg4 *C.GCancellable
	var arg5 C.GAsyncReadyCallback
	var arg6 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GFileInfo)(info.Native())
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = C.int(ioPriority)
	arg4 = (*C.GCancellable)(cancellable.Native())
	arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg6 = C.gpointer(box.Assign(callback))

	C.g_file_set_attributes_async(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// SetAttributesFinish finishes setting an attribute started in
// g_file_set_attributes_async().
func (f file) SetAttributesFinish(result AsyncResult) (info FileInfo, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var arg2 **C.GFileInfo // out
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_set_attributes_finish(arg0, arg1, &arg2, &gError)

	var ret0 FileInfo
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg2.Native()))).(FileInfo)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetAttributesFromInfo tries to set all attributes in the Info on the
// target values, not stopping on the first error.
//
// If there is any error during this operation then @error will be set to
// the first error. Error on particular fields are flagged by setting the
// "status" field in the attribute value to
// G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
// further errors.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GFileInfo
	var arg2 C.GFileQueryInfoFlags
	var arg3 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GFileInfo)(info.Native())
	arg2 = (C.GFileQueryInfoFlags)(flags)
	arg3 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_attributes_from_info(arg0, arg1, arg2, arg3, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDisplayName renames @file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding for the
// target filesystem if possible and the @file is renamed to this.
//
// If you want to implement a rename operation in the user interface the
// edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
// initial value in the rename widget, and then the result after editing
// should be passed to g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) SetDisplayName(displayName string, cancellable Cancellable) (file File, err error) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_set_display_name(arg0, arg1, arg2, &gError)

	var ret0 File
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetDisplayNameAsync: asynchronously sets the display name for a given
// #GFile.
//
// For more details, see g_file_set_display_name() which is the synchronous
// version of this call.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_set_display_name_finish() to get the result of the operation.
func (f file) SetDisplayNameAsync(displayName string, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 *C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.gchar)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_set_display_name_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// SetDisplayNameFinish finishes setting a display name started with
// g_file_set_display_name_async().
func (f file) SetDisplayNameFinish(res AsyncResult) (file File, err error) {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(res.Native())

	ret := C.g_file_set_display_name_finish(arg0, arg1, &gError)

	var ret0 File
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(File)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// StartMountable starts a file of type FILE_TYPE_MOUNTABLE. Using
// @start_operation, you can request callbacks when, for instance, passwords
// are needed during authentication.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_mount_mountable_finish() to get the result of the operation.
func (f file) StartMountable(flags DriveStartFlags, startOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GDriveStartFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GDriveStartFlags)(flags)
	arg2 = (*C.GMountOperation)(startOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_start_mountable(arg0, arg1, arg2, arg3, arg4, arg5)
}

// StartMountableFinish finishes a start operation. See
// g_file_start_mountable() for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
func (f file) StartMountableFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_start_mountable_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// StopMountable stops a file of type FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_stop_mountable_finish() to get the result of the operation.
func (f file) StopMountable(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountUnmountFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountUnmountFlags)(flags)
	arg2 = (*C.GMountOperation)(mountOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_stop_mountable(arg0, arg1, arg2, arg3, arg4, arg5)
}

// StopMountableFinish finishes a stop operation, see
// g_file_stop_mountable() for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
func (f file) StopMountableFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_stop_mountable_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SupportsThreadContexts checks if @file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns
// false, you cannot perform asynchronous operations on @file in a thread
// that has a thread-default context.
func (f file) SupportsThreadContexts() bool {
	var arg0 *C.GFile

	arg0 = (*C.GFile)(f.Native())

	ret := C.g_file_supports_thread_contexts(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Trash sends @file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Not all file systems support trashing, so this call can return the
// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash`
// unix mount option can be used to disable g_file_trash() support for
// certain mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in
// that case.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (f file) Trash(cancellable Cancellable) error {
	var arg0 *C.GFile
	var arg1 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())

	ret := C.g_file_trash(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// TrashAsync: asynchronously sends @file to the Trash location, if
// possible.
func (f file) TrashAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_trash_async(arg0, arg1, arg2, arg3, arg4)
}

// TrashFinish finishes an asynchronous file trashing operation, started
// with g_file_trash_async().
func (f file) TrashFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_trash_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// UnmountMountable unmounts a file of type G_FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_unmount_mountable_finish() to get the result of the
// operation.
func (f file) UnmountMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountUnmountFlags
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountUnmountFlags)(flags)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.g_file_unmount_mountable(arg0, arg1, arg2, arg3, arg4)
}

// UnmountMountableFinish finishes an unmount operation, see
// g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable().
func (f file) UnmountMountableFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_unmount_mountable_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// UnmountMountableWithOperation unmounts a file of type
// FILE_TYPE_MOUNTABLE.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, @callback will be called. You can then
// call g_file_unmount_mountable_finish() to get the result of the
// operation.
func (f file) UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GFile
	var arg1 C.GMountUnmountFlags
	var arg2 *C.GMountOperation
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GFile)(f.Native())
	arg1 = (C.GMountUnmountFlags)(flags)
	arg2 = (*C.GMountOperation)(mountOperation.Native())
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.g_file_unmount_mountable_with_operation(arg0, arg1, arg2, arg3, arg4, arg5)
}

// UnmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
func (f file) UnmountMountableWithOperationFinish(result AsyncResult) error {
	var arg0 *C.GFile
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GFile)(f.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.g_file_unmount_mountable_with_operation_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}
