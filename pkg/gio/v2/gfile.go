// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_file_get_type()), F: marshalFile},
	})
}

// FileOverrider contains methods that are overridable. This
// interface is a subset of the interface File.
type FileOverrider interface {
	// Equal checks if the two given #GFiles refer to the same file.
	//
	// Note that two #GFiles that differ can still refer to the same file on the
	// filesystem due to various forms of filename aliasing.
	//
	// This call does no blocking I/O.
	Equal(file2 File) bool
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	//
	// If called for the top level of a system (such as the filesystem root or a
	// uri like sftp://host/) it will return a single directory separator (and
	// on Windows, possibly a drive letter).
	//
	// The base name is a byte string (not UTF-8). It has no defined encoding or
	// rules other than it may not contain zero bytes. If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	//
	// This call does no blocking I/O.
	Basename() string
	// ParseName gets the parse name of the @file. A parse name is a UTF-8
	// string that describes the file such that one can get the #GFile back
	// using g_file_parse_name().
	//
	// This is generally used to show the #GFile as a nice full-pathname kind of
	// string in a user interface, like in a location entry.
	//
	// For local files with names that can safely be converted to UTF-8 the
	// pathname is used, otherwise the IRI is used (a form of URI that allows
	// UTF-8 characters unescaped).
	//
	// This call does no blocking I/O.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists. If non-nil, this
	// is guaranteed to be an absolute, canonical path. It might contain
	// symlinks.
	//
	// This call does no blocking I/O.
	Path() string
	// RelativePath gets the path for @descendant relative to @parent.
	//
	// This call does no blocking I/O.
	RelativePath(descendant File) string
	// URI gets the URI for the @file.
	//
	// This call does no blocking I/O.
	URI() string
	// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
	// as:
	//
	//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	//
	// Common schemes include "file", "http", "ftp", etc.
	//
	// The scheme can be different from the one used to construct the #GFile, in
	// that it might be replaced with one that is logically equivalent to the
	// #GFile.
	//
	// This call does no blocking I/O.
	URIScheme() string
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	//
	// This call does no blocking I/O.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	//
	// This call does no blocking I/O.
	Hash() uint
	// IsNative checks to see if a file is native to the platform.
	//
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	//
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return false, but g_file_get_path() will still return a native path.
	//
	// This call does no blocking I/O.
	IsNative() bool
	// PrefixMatches checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	PrefixMatches(file File) bool
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use: - g_file_new_for_path() if you have a
// path. - g_file_new_for_uri() if you have a URI. -
// g_file_new_for_commandline_arg() for a command line argument. -
// g_file_new_tmp() to create a temporary file from a template. -
// g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include: -
// g_file_mount_mountable() to mount a mountable file. -
// g_file_unmount_mountable_with_operation() to unmount a mountable file. -
// g_file_eject_mountable_with_operation() to eject a mountable file.
//
//
// Entity Tags
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
type File interface {
	gextras.Objector
	FileOverrider

	// HasParent checks if @file has a parent, and optionally, if it is @parent.
	//
	// If @parent is nil then this function returns true if @file has any parent
	// at all. If @parent is non-nil then true is only returned if @file is an
	// immediate child of @parent.
	HasParent(parent File) bool
	// HasPrefix checks whether @file has the prefix specified by @prefix.
	//
	// In other words, if the names of initial elements of @file's pathname
	// match @prefix. Only full pathname elements are matched, so a path like
	// /foo is not considered a prefix of /foobar, only of /foo/bar.
	//
	// A #GFile is not a prefix of itself. If you want to check for equality,
	// use g_file_equal().
	//
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return false even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias of
	// @prefix.
	HasPrefix(prefix File) bool
	// PeekPath: exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full(). This is useful for example in C applications
	// which mix `g_file_*` APIs with native ones. It also avoids an extra
	// duplicated string when possible, so will be generally more efficient.
	//
	// This call does no blocking I/O.
	PeekPath() string
	// QueryExists: utility function to check if a particular file exists. This
	// is implemented using g_file_query_info() and as such does blocking I/O.
	//
	// Note that in many cases it is racy to first check for file existence
	// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
	// execute something based on the outcome of that, because the file might
	// have been created or removed in between the operations. The general
	// approach to handling that is to not check, but just do the operation and
	// handle the errors as they come.
	//
	// As an example of race-free checking, take the case of reading a file, and
	// if it doesn't exist, creating it. There are two racy versions: read it,
	// and on error create it; and: check if it exists, if not create it. These
	// can both result in two processes creating the file (with perhaps a
	// partially written file as the result). The correct approach is to always
	// try to create the file with g_file_create() which will either atomically
	// create the file or fail with a G_IO_ERROR_EXISTS error.
	//
	// However, in many cases an existence check is useful in a user interface,
	// for instance to make a menu item sensitive/insensitive, so that you don't
	// have to fool users that something is possible and then just show an error
	// dialog. If you do this, you should make sure to also handle the errors
	// that can happen due to races when you execute the operation.
	QueryExists(cancellable Cancellable) bool
	// SupportsThreadContexts checks if @file supports [thread-default
	// contexts][g-main-context-push-thread-default-context]. If this returns
	// false, you cannot perform asynchronous operations on @file in a thread
	// that has a thread-default context.
	SupportsThreadContexts() bool
}

// file implements the File interface.
type file struct {
	gextras.Objector
}

var _ File = (*file)(nil)

// WrapFile wraps a GObject to a type that implements interface
// File. It is primarily used internally.
func WrapFile(obj *externglib.Object) File {
	return File{
		Objector: obj,
	}
}

func marshalFile(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFile(obj), nil
}

// Equal checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
//
// This call does no blocking I/O.
func (f file) Equal(file2 File) bool {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(file2.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Basename gets the base name (the last component of the path) for a given
// #GFile.
//
// If called for the top level of a system (such as the filesystem root or a
// uri like sftp://host/) it will return a single directory separator (and
// on Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding or
// rules other than it may not contain zero bytes. If you want to use
// filenames in a user interface you should use the display name that you
// can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// attribute with g_file_query_info().
//
// This call does no blocking I/O.
func (f file) Basename() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_basename(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// ParseName gets the parse name of the @file. A parse name is a UTF-8
// string that describes the file such that one can get the #GFile back
// using g_file_parse_name().
//
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
//
// For local files with names that can safely be converted to UTF-8 the
// pathname is used, otherwise the IRI is used (a form of URI that allows
// UTF-8 characters unescaped).
//
// This call does no blocking I/O.
func (f file) ParseName() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_parse_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Path gets the local pathname for #GFile, if one exists. If non-nil, this
// is guaranteed to be an absolute, canonical path. It might contain
// symlinks.
//
// This call does no blocking I/O.
func (f file) Path() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// RelativePath gets the path for @descendant relative to @parent.
//
// This call does no blocking I/O.
func (p file) RelativePath(descendant File) string {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(descendant.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_relative_path(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _filename
}

// URI gets the URI for the @file.
//
// This call does no blocking I/O.
func (f file) URI() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_uri(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme
// as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile, in
// that it might be replaced with one that is logically equivalent to the
// #GFile.
//
// This call does no blocking I/O.
func (f file) URIScheme() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_get_uri_scheme(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasParent checks if @file has a parent, and optionally, if it is @parent.
//
// If @parent is nil then this function returns true if @file has any parent
// at all. If @parent is non-nil then true is only returned if @file is an
// immediate child of @parent.
func (f file) HasParent(parent File) bool {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(parent.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_has_parent(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasPrefix checks whether @file has the prefix specified by @prefix.
//
// In other words, if the names of initial elements of @file's pathname
// match @prefix. Only full pathname elements are matched, so a path like
// /foo is not considered a prefix of /foobar, only of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for equality,
// use g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can
// sometimes return false even if @file is inside a @prefix (from a
// filesystem point of view), because the prefix of @file is an alias of
// @prefix.
func (f file) HasPrefix(prefix File) bool {
	var _arg0 *C.GFile // out
	var _arg1 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(prefix.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_has_prefix(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasURIScheme checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
func (f file) HasURIScheme(uriScheme string) bool {
	var _arg0 *C.GFile // out
	var _arg1 *C.char  // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(uriScheme))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.g_file_has_uri_scheme(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash creates a hash value for a #GFile.
//
// This call does no blocking I/O.
func (f file) Hash() uint {
	var _arg0 C.gpointer // out

	_arg0 = (C.gpointer)(unsafe.Pointer(f.Native()))

	var _cret C.guint // in

	_cret = C.g_file_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// IsNative checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native
// filesystem via a userspace filesystem (FUSE), in these cases this call
// will return false, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
func (f file) IsNative() bool {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_is_native(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications
// which mix `g_file_*` APIs with native ones. It also avoids an extra
// duplicated string when possible, so will be generally more efficient.
//
// This call does no blocking I/O.
func (f file) PeekPath() string {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.g_file_peek_path(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// QueryExists: utility function to check if a particular file exists. This
// is implemented using g_file_query_info() and as such does blocking I/O.
//
// Note that in many cases it is racy to first check for file existence
// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then
// execute something based on the outcome of that, because the file might
// have been created or removed in between the operations. The general
// approach to handling that is to not check, but just do the operation and
// handle the errors as they come.
//
// As an example of race-free checking, take the case of reading a file, and
// if it doesn't exist, creating it. There are two racy versions: read it,
// and on error create it; and: check if it exists, if not create it. These
// can both result in two processes creating the file (with perhaps a
// partially written file as the result). The correct approach is to always
// try to create the file with g_file_create() which will either atomically
// create the file or fail with a G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface,
// for instance to make a menu item sensitive/insensitive, so that you don't
// have to fool users that something is possible and then just show an error
// dialog. If you do this, you should make sure to also handle the errors
// that can happen due to races when you execute the operation.
func (f file) QueryExists(cancellable Cancellable) bool {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_query_exists(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsThreadContexts checks if @file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns
// false, you cannot perform asynchronous operations on @file in a thread
// that has a thread-default context.
func (f file) SupportsThreadContexts() bool {
	var _arg0 *C.GFile // out

	_arg0 = (*C.GFile)(unsafe.Pointer(f.Native()))

	var _cret C.gboolean // in

	_cret = C.g_file_supports_thread_contexts(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
