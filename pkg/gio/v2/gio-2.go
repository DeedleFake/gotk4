// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/box"
	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
	})
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor class.
type appInfoMonitor struct {
	gextras.Objector
}

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return appInfoMonitor{
		Objector: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	LoadableIcon
}

// bytesIcon implements the BytesIcon class.
type bytesIcon struct {
	gextras.Objector
}

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return bytesIcon{
		Objector: obj,
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

func (i bytesIcon) Load(size int, cancellable Cancellable) (string, InputStream, error) {
	return WrapLoadableIcon(gextras.InternObject(i)).Load(size, cancellable)
}

func (i bytesIcon) LoadAsync(size int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapLoadableIcon(gextras.InternObject(i)).LoadAsync(size, cancellable, callback)
}

func (i bytesIcon) LoadFinish(res AsyncResult) (string, InputStream, error) {
	return WrapLoadableIcon(gextras.InternObject(i)).LoadFinish(res)
}

func (i bytesIcon) Equal(icon2 Icon) bool {
	return WrapIcon(gextras.InternObject(i)).Equal(icon2)
}

func (i bytesIcon) Serialize() *glib.Variant {
	return WrapIcon(gextras.InternObject(i)).Serialize()
}

func (i bytesIcon) String() string {
	return WrapIcon(gextras.InternObject(i)).String()
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	RemoteActionGroup
}

// dBusActionGroup implements the DBusActionGroup class.
type dBusActionGroup struct {
	gextras.Objector
}

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return dBusActionGroup{
		Objector: obj,
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

func (r dBusActionGroup) ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant) {
	WrapRemoteActionGroup(gextras.InternObject(r)).ActivateActionFull(actionName, parameter, platformData)
}

func (r dBusActionGroup) ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant) {
	WrapRemoteActionGroup(gextras.InternObject(r)).ChangeActionStateFull(actionName, value, platformData)
}

func (a dBusActionGroup) ActionAdded(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionAdded(actionName)
}

func (a dBusActionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	WrapActionGroup(gextras.InternObject(a)).ActionEnabledChanged(actionName, enabled)
}

func (a dBusActionGroup) ActionRemoved(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionRemoved(actionName)
}

func (a dBusActionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActionStateChanged(actionName, state)
}

func (a dBusActionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActivateAction(actionName, parameter)
}

func (a dBusActionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ChangeActionState(actionName, value)
}

func (a dBusActionGroup) ActionEnabled(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).ActionEnabled(actionName)
}

func (a dBusActionGroup) ActionParameterType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).ActionParameterType(actionName)
}

func (a dBusActionGroup) ActionState(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).ActionState(actionName)
}

func (a dBusActionGroup) ActionStateHint(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).ActionStateHint(actionName)
}

func (a dBusActionGroup) ActionStateType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).ActionStateType(actionName)
}

func (a dBusActionGroup) HasAction(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).HasAction(actionName)
}

func (a dBusActionGroup) ListActions() []string {
	return WrapActionGroup(gextras.InternObject(a)).ListActions()
}

func (a dBusActionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	return WrapActionGroup(gextras.InternObject(a)).QueryAction(actionName)
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver interface {
	gextras.Objector

	AllowMechanismDBusAuthObserver(mechanism string) bool

	AuthorizeAuthenticatedPeerDBusAuthObserver(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver class.
type dBusAuthObserver struct {
	gextras.Objector
}

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return dBusAuthObserver{
		Objector: obj,
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

func NewDBusAuthObserver() DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver DBusAuthObserver // out

	_dBusAuthObserver = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusAuthObserver)

	return _dBusAuthObserver
}

func (o dBusAuthObserver) AllowMechanismDBusAuthObserver(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o dBusAuthObserver) AuthorizeAuthenticatedPeerDBusAuthObserver(stream IOStream, credentials Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	AsyncInitable
	Initable

	CallDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)

	CallFinishDBusConnection(res AsyncResult) (*glib.Variant, error)

	CallSyncDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error)

	CallWithUnixFdListDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)

	CallWithUnixFdListFinishDBusConnection(res AsyncResult) (UnixFDList, *glib.Variant, error)

	CallWithUnixFdListSyncDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error)

	CloseDBusConnection(cancellable Cancellable, callback AsyncReadyCallback)

	CloseFinishDBusConnection(res AsyncResult) error

	CloseSyncDBusConnection(cancellable Cancellable) error

	EmitSignalDBusConnection(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error

	ExportActionGroupDBusConnection(objectPath string, actionGroup ActionGroup) (uint, error)

	ExportMenuModelDBusConnection(objectPath string, menu MenuModel) (uint, error)

	FlushDBusConnection(cancellable Cancellable, callback AsyncReadyCallback)

	FlushFinishDBusConnection(res AsyncResult) error

	FlushSyncDBusConnection(cancellable Cancellable) error

	Capabilities() DBusCapabilityFlags

	ExitOnClose() bool

	Flags() DBusConnectionFlags

	Guid() string

	LastSerial() uint32

	PeerCredentials() Credentials

	Stream() IOStream

	UniqueName() string

	IsClosedDBusConnection() bool

	RemoveFilterDBusConnection(filterId uint)

	SendMessageDBusConnection(message DBusMessage, flags DBusSendMessageFlags) (uint32, error)

	SendMessageWithReplyDBusConnection(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32

	SendMessageWithReplyFinishDBusConnection(res AsyncResult) (DBusMessage, error)

	SendMessageWithReplySyncDBusConnection(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error)

	SetExitOnCloseDBusConnection(exitOnClose bool)

	SignalUnsubscribeDBusConnection(subscriptionId uint)

	StartMessageProcessingDBusConnection()

	UnexportActionGroupDBusConnection(exportId uint)

	UnexportMenuModelDBusConnection(exportId uint)

	UnregisterObjectDBusConnection(registrationId uint) bool

	UnregisterSubtreeDBusConnection(registrationId uint) bool
}

// dBusConnection implements the DBusConnection class.
type dBusConnection struct {
	gextras.Objector
}

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return dBusConnection{
		Objector: obj,
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

func NewDBusConnectionFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func NewDBusConnectionForAddressFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _arg4 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusConnectionFlags(flags)
	_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _arg5 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GDBusConnectionFlags(flags)
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func (c dBusConnection) CallDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg9 *C.GCancellable        // out
	var _arg10 C.GAsyncReadyCallback // out
	var _arg11 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg10 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg11 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

func (c dBusConnection) CallFinishDBusConnection(res AsyncResult) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallSyncDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GCancellable    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdListDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg9 *C.GUnixFDList         // out
	var _arg10 *C.GCancellable       // out
	var _arg11 C.GAsyncReadyCallback // out
	var _arg12 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg10 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg11 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg12 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_call_with_unix_fd_list(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12)
}

func (c dBusConnection) CallWithUnixFdListFinishDBusConnection(res AsyncResult) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GUnixFDList     // in
	var _arg2 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdListSyncDBusConnection(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GUnixFDList     // out
	var _arg10 *C.GUnixFDList    // in
	var _arg11 *C.GCancellable   // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_arg10, _arg11, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg10))).(UnixFDList)
	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) CloseDBusConnection(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_close(_arg0, _arg1, _arg2, _arg3)
}

func (c dBusConnection) CloseFinishDBusConnection(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) CloseSyncDBusConnection(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) EmitSignalDBusConnection(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) ExportActionGroupDBusConnection(objectPath string, actionGroup ActionGroup) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) ExportMenuModelDBusConnection(objectPath string, menu MenuModel) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) FlushDBusConnection(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_flush(_arg0, _arg1, _arg2, _arg3)
}

func (c dBusConnection) FlushFinishDBusConnection(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) FlushSyncDBusConnection(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

func (c dBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

func (c dBusConnection) Guid() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (c dBusConnection) PeerCredentials() Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials Credentials // out

	_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

	return _credentials
}

func (c dBusConnection) Stream() IOStream {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream IOStream // out

	_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

	return _ioStream
}

func (c dBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) IsClosedDBusConnection() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) RemoveFilterDBusConnection(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

func (c dBusConnection) SendMessageDBusConnection(message DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.guint32               // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = uint32(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _goerr
}

func (c dBusConnection) SendMessageWithReplyDBusConnection(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32 {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg5 *C.GCancellable         // out
	var _arg6 C.GAsyncReadyCallback   // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg7 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_send_message_with_reply(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, _arg6, _arg7)

	var _outSerial uint32 // out

	_outSerial = uint32(_arg4)

	return _outSerial
}

func (c dBusConnection) SendMessageWithReplyFinishDBusConnection(res AsyncResult) (DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (c dBusConnection) SendMessageWithReplySyncDBusConnection(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg5 *C.GCancellable         // out
	var _cret *C.GDBusMessage         // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)

	var _outSerial uint32        // out
	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_outSerial = uint32(_arg4)
	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _dBusMessage, _goerr
}

func (c dBusConnection) SetExitOnCloseDBusConnection(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

func (c dBusConnection) SignalUnsubscribeDBusConnection(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

func (c dBusConnection) StartMessageProcessingDBusConnection() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

func (c dBusConnection) UnexportActionGroupDBusConnection(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

func (c dBusConnection) UnexportMenuModelDBusConnection(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

func (c dBusConnection) UnregisterObjectDBusConnection(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) UnregisterSubtreeDBusConnection(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (i dBusConnection) InitAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapAsyncInitable(gextras.InternObject(i)).InitAsync(ioPriority, cancellable, callback)
}

func (i dBusConnection) InitFinish(res AsyncResult) error {
	return WrapAsyncInitable(gextras.InternObject(i)).InitFinish(res)
}

func (i dBusConnection) NewFinish(res AsyncResult) (gextras.Objector, error) {
	return WrapAsyncInitable(gextras.InternObject(i)).NewFinish(res)
}

func (i dBusConnection) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

// dBusMenuModel implements the DBusMenuModel class.
type dBusMenuModel struct {
	MenuModel
}

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return dBusMenuModel{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	CopyDBusMessage() (DBusMessage, error)

	Arg0() string

	Body() *glib.Variant

	ByteOrder() DBusMessageByteOrder

	Destination() string

	ErrorName() string

	Flags() DBusMessageFlags

	Header(headerField DBusMessageHeaderField) *glib.Variant

	HeaderFields() []byte

	Interface() string

	Locked() bool

	Member() string

	MessageType() DBusMessageType

	NumUnixFds() uint32

	Path() string

	ReplySerial() uint32

	Sender() string

	Serial() uint32

	Signature() string

	UnixFdList() UnixFDList

	LockDBusMessage()

	NewMethodErrorLiteralDBusMessage(errorName string, errorMessage string) DBusMessage

	NewMethodReplyDBusMessage() DBusMessage

	PrintDBusMessage(indent uint) string

	SetBodyDBusMessage(body *glib.Variant)

	SetByteOrderDBusMessage(byteOrder DBusMessageByteOrder)

	SetDestinationDBusMessage(value string)

	SetErrorNameDBusMessage(value string)

	SetFlagsDBusMessage(flags DBusMessageFlags)

	SetHeaderDBusMessage(headerField DBusMessageHeaderField, value *glib.Variant)

	SetInterfaceDBusMessage(value string)

	SetMemberDBusMessage(value string)

	SetMessageTypeDBusMessage(typ DBusMessageType)

	SetNumUnixFdsDBusMessage(value uint32)

	SetPathDBusMessage(value string)

	SetReplySerialDBusMessage(value uint32)

	SetSenderDBusMessage(value string)

	SetSerialDBusMessage(serial uint32)

	SetSignatureDBusMessage(value string)

	SetUnixFdListDBusMessage(fdList UnixFDList)

	ToGerrorDBusMessage() error
}

// dBusMessage implements the DBusMessage class.
type dBusMessage struct {
	gextras.Objector
}

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return dBusMessage{
		Objector: obj,
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

func NewDBusMessage() DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (DBusMessage, error) {
	var _arg1 *C.guchar
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out
	var _cret *C.GDBusMessage        // in
	var _cerr *C.GError              // in

	_arg2 = C.gsize(len(blob))
	_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	_arg3 = C.GDBusCapabilityFlags(capabilities)

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) CopyDBusMessage() (DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (m dBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))

	return _variant
}

func (m dBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

func (m dBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

func (m dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))

	return _variant
}

func (m dBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

func (m dBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m dBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

func (m dBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) UnixFdList() UnixFDList {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GUnixFDList  // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList UnixFDList // out

	_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

	return _unixFDList
}

func (m dBusMessage) LockDBusMessage() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_lock(_arg0)
}

func (m dBusMessage) NewMethodErrorLiteralDBusMessage(errorName string, errorMessage string) DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) NewMethodReplyDBusMessage() DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) PrintDBusMessage(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (m dBusMessage) SetBodyDBusMessage(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(body.Native()))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

func (m dBusMessage) SetByteOrderDBusMessage(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageByteOrder(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
}

func (m dBusMessage) SetDestinationDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

func (m dBusMessage) SetErrorNameDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

func (m dBusMessage) SetFlagsDBusMessage(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageFlags(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
}

func (m dBusMessage) SetHeaderDBusMessage(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}

func (m dBusMessage) SetInterfaceDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

func (m dBusMessage) SetMemberDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_member(_arg0, _arg1)
}

func (m dBusMessage) SetMessageTypeDBusMessage(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageType(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
}

func (m dBusMessage) SetNumUnixFdsDBusMessage(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

func (m dBusMessage) SetPathDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_path(_arg0, _arg1)
}

func (m dBusMessage) SetReplySerialDBusMessage(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSenderDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

func (m dBusMessage) SetSerialDBusMessage(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSignatureDBusMessage(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

func (m dBusMessage) SetUnixFdListDBusMessage(fdList UnixFDList) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

func (m dBusMessage) ToGerrorDBusMessage() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	Connection() DBusConnection

	InterfaceName() string

	Message() DBusMessage

	MethodInfo() *DBusMethodInfo

	MethodName() string

	ObjectPath() string

	Parameters() *glib.Variant

	PropertyInfo() *DBusPropertyInfo

	Sender() string

	ReturnDBusErrorDBusMethodInvocation(errorName string, errorMessage string)

	ReturnGerrorDBusMethodInvocation(err error)

	ReturnValueDBusMethodInvocation(parameters *glib.Variant)

	ReturnValueWithUnixFdListDBusMethodInvocation(parameters *glib.Variant, fdList UnixFDList)
}

// dBusMethodInvocation implements the DBusMethodInvocation class.
type dBusMethodInvocation struct {
	gextras.Objector
}

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return dBusMethodInvocation{
		Objector: obj,
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

func (i dBusMethodInvocation) Connection() DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (i dBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Message() DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (i dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = (*DBusMethodInfo)(unsafe.Pointer(_cret))

	return _dBusMethodInfo
}

func (i dBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))

	return _variant
}

func (i dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = (*DBusPropertyInfo)(unsafe.Pointer(_cret))

	return _dBusPropertyInfo
}

func (i dBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ReturnDBusErrorDBusMethodInvocation(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

func (i dBusMethodInvocation) ReturnGerrorDBusMethodInvocation(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GError)(gerror.New(err))
	defer C.g_error_free(_arg1)

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValueDBusMethodInvocation(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValueWithUnixFdListDBusMethodInvocation(parameters *glib.Variant, fdList UnixFDList) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer interface {
	Initable

	ClientAddress() string

	Flags() DBusServerFlags

	Guid() string

	IsActiveDBusServer() bool

	StartDBusServer()

	StopDBusServer()
}

// dBusServer implements the DBusServer class.
type dBusServer struct {
	gextras.Objector
}

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return dBusServer{
		Objector: obj,
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) (DBusServer, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _arg5 *C.GCancellable      // out
	var _cret *C.GDBusServer       // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusServerFlags(flags)
	_arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusServer DBusServer // out
	var _goerr error           // out

	_dBusServer = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusServer)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusServer, _goerr
}

func (s dBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

func (s dBusServer) Guid() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) IsActiveDBusServer() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dBusServer) StartDBusServer() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_start(_arg0)
}

func (s dBusServer) StopDBusServer() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_stop(_arg0)
}

func (i dBusServer) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	AppendMenu(label string, detailedAction string)

	AppendItemMenu(item MenuItem)

	AppendSectionMenu(label string, section MenuModel)

	AppendSubmenuMenu(label string, submenu MenuModel)

	FreezeMenu()

	InsertMenu(position int, label string, detailedAction string)

	InsertItemMenu(position int, item MenuItem)

	InsertSectionMenu(position int, label string, section MenuModel)

	InsertSubmenuMenu(position int, label string, submenu MenuModel)

	PrependMenu(label string, detailedAction string)

	PrependItemMenu(item MenuItem)

	PrependSectionMenu(label string, section MenuModel)

	PrependSubmenuMenu(label string, submenu MenuModel)

	RemoveMenu(position int)

	RemoveAllMenu()
}

// menu implements the Menu class.
type menu struct {
	MenuModel
}

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

func NewMenu() Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu Menu // out

	_menu = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Menu)

	return _menu
}

func (m menu) AppendMenu(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_append(_arg0, _arg1, _arg2)
}

func (m menu) AppendItemMenu(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

func (m menu) AppendSectionMenu(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

func (m menu) AppendSubmenuMenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

func (m menu) FreezeMenu() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_freeze(_arg0)
}

func (m menu) InsertMenu(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertItemMenu(position int, item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

func (m menu) InsertSectionMenu(position int, label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertSubmenuMenu(position int, label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) PrependMenu(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

func (m menu) PrependItemMenu(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

func (m menu) PrependSectionMenu(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

func (m menu) PrependSubmenuMenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

func (m menu) RemoveMenu(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
}

func (m menu) RemoveAllMenu() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant

	Link(link string) MenuModel

	SetActionAndTargetValueMenuItem(action string, targetValue *glib.Variant)

	SetAttributeValueMenuItem(attribute string, value *glib.Variant)

	SetDetailedActionMenuItem(detailedAction string)

	SetIconMenuItem(icon Icon)

	SetLabelMenuItem(label string)

	SetLinkMenuItem(link string, model MenuModel)

	SetSectionMenuItem(section MenuModel)

	SetSubmenuMenuItem(submenu MenuModel)
}

// menuItem implements the MenuItem class.
type menuItem struct {
	gextras.Objector
}

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{
		Objector: obj,
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

func NewMenuItem(label string, detailedAction string) MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = C.gint(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

func (m menuItem) Link(link string) MenuModel {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

	return _menuModel
}

func (m menuItem) SetActionAndTargetValueMenuItem(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetAttributeValueMenuItem(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetDetailedActionMenuItem(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

func (m menuItem) SetIconMenuItem(icon Icon) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

func (m menuItem) SetLabelMenuItem(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_label(_arg0, _arg1)
}

func (m menuItem) SetLinkMenuItem(link string, model MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

func (m menuItem) SetSectionMenuItem(section MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

func (m menuItem) SetSubmenuMenuItem(submenu MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	AddButtonNotification(label string, detailedAction string)

	AddButtonWithTargetValueNotification(label string, action string, target *glib.Variant)

	SetBodyNotification(body string)

	SetDefaultActionNotification(detailedAction string)

	SetDefaultActionAndTargetValueNotification(action string, target *glib.Variant)

	SetIconNotification(icon Icon)

	SetPriorityNotification(priority NotificationPriority)

	SetTitleNotification(title string)

	SetUrgentNotification(urgent bool)
}

// notification implements the Notification class.
type notification struct {
	gextras.Objector
}

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return notification{
		Objector: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

func NewNotification(title string) Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)

	var _notification Notification // out

	_notification = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Notification)

	return _notification
}

func (n notification) AddButtonNotification(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

func (n notification) AddButtonWithTargetValueNotification(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

func (n notification) SetBodyNotification(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_body(_arg0, _arg1)
}

func (n notification) SetDefaultActionNotification(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

func (n notification) SetDefaultActionAndTargetValueNotification(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

func (n notification) SetIconNotification(icon Icon) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

func (n notification) SetPriorityNotification(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(_arg0, _arg1)
}

func (n notification) SetTitleNotification(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

func (n notification) SetUrgentNotification(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	Action
}

// propertyAction implements the PropertyAction class.
type propertyAction struct {
	gextras.Objector
}

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return propertyAction{
		Objector: obj,
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gpointer)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction PropertyAction // out

	_propertyAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PropertyAction)

	return _propertyAction
}

func (a propertyAction) Activate(parameter *glib.Variant) {
	WrapAction(gextras.InternObject(a)).Activate(parameter)
}

func (a propertyAction) ChangeState(value *glib.Variant) {
	WrapAction(gextras.InternObject(a)).ChangeState(value)
}

func (a propertyAction) Enabled() bool {
	return WrapAction(gextras.InternObject(a)).Enabled()
}

func (a propertyAction) Name() string {
	return WrapAction(gextras.InternObject(a)).Name()
}

func (a propertyAction) ParameterType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).ParameterType()
}

func (a propertyAction) State() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).State()
}

func (a propertyAction) StateHint() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).StateHint()
}

func (a propertyAction) StateType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).StateType()
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	Action

	SetEnabledSimpleAction(enabled bool)

	SetStateSimpleAction(value *glib.Variant)

	SetStateHintSimpleAction(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction class.
type simpleAction struct {
	gextras.Objector
}

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return simpleAction{
		Objector: obj,
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleAction)

	return _simpleAction
}

func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleAction)

	return _simpleAction
}

func (s simpleAction) SetEnabledSimpleAction(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

func (s simpleAction) SetStateSimpleAction(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_simple_action_set_state(_arg0, _arg1)
}

func (s simpleAction) SetStateHintSimpleAction(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint.Native()))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

func (a simpleAction) Activate(parameter *glib.Variant) {
	WrapAction(gextras.InternObject(a)).Activate(parameter)
}

func (a simpleAction) ChangeState(value *glib.Variant) {
	WrapAction(gextras.InternObject(a)).ChangeState(value)
}

func (a simpleAction) Enabled() bool {
	return WrapAction(gextras.InternObject(a)).Enabled()
}

func (a simpleAction) Name() string {
	return WrapAction(gextras.InternObject(a)).Name()
}

func (a simpleAction) ParameterType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).ParameterType()
}

func (a simpleAction) State() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).State()
}

func (a simpleAction) StateHint() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).StateHint()
}

func (a simpleAction) StateType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).StateType()
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

// simpleIOStream implements the SimpleIOStream class.
type simpleIOStream struct {
	IOStream
}

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return simpleIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream SimpleIOStream // out

	_simpleIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleIOStream)

	return _simpleIOStream
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

// simplePermission implements the SimplePermission class.
type simplePermission struct {
	Permission
}

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return simplePermission{
		Permission: WrapPermission(obj),
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

func NewSimplePermission(allowed bool) SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission SimplePermission // out

	_simplePermission = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimplePermission)

	return _simplePermission
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	Initable

	CommunicateUTF8Subprocess(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error)

	CommunicateUTF8AsyncSubprocess(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)

	CommunicateUTF8FinishSubprocess(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error)

	ForceExitSubprocess()

	ExitStatus() int

	Identifier() string

	IfExited() bool

	IfSignaled() bool

	Status() int

	StderrPipe() InputStream

	StdinPipe() OutputStream

	StdoutPipe() InputStream

	Successful() bool

	TermSig() int

	SendSignalSubprocess(signalNum int)

	WaitSubprocess(cancellable Cancellable) error

	WaitAsyncSubprocess(cancellable Cancellable, callback AsyncReadyCallback)

	WaitCheckSubprocess(cancellable Cancellable) error

	WaitCheckAsyncSubprocess(cancellable Cancellable, callback AsyncReadyCallback)

	WaitCheckFinishSubprocess(result AsyncResult) error

	WaitFinishSubprocess(result AsyncResult) error
}

// subprocess implements the Subprocess class.
type subprocess struct {
	gextras.Objector
}

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return subprocess{
		Objector: obj,
	}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

func NewSubprocessV(argv []string, flags SubprocessFlags) (Subprocess, error) {
	var _arg1 **C.gchar
	var _arg2 C.GSubprocessFlags // out
	var _cret *C.GSubprocess     // in
	var _cerr *C.GError          // in

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocess) CommunicateUTF8Subprocess(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _arg3 *C.char         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_stderrBuf = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) CommunicateUTF8AsyncSubprocess(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.char               // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_subprocess_communicate_utf8_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s subprocess) CommunicateUTF8FinishSubprocess(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_stderrBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) ForceExitSubprocess() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_force_exit(_arg0)
}

func (s subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) Status() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) StderrPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) StdinPipe() OutputStream {
	var _arg0 *C.GSubprocess   // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

	return _outputStream
}

func (s subprocess) StdoutPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) SendSignalSubprocess(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

func (s subprocess) WaitSubprocess(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitAsyncSubprocess(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_async(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocess) WaitCheckSubprocess(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitCheckAsyncSubprocess(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_check_async(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocess) WaitCheckFinishSubprocess(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitFinishSubprocess(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (i subprocess) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	CloseSubprocessLauncher()

	env(variable string) string

	SetCwdSubprocessLauncher(cwd string)

	SetEnvironSubprocessLauncher(env []string)

	SetFlagsSubprocessLauncher(flags SubprocessFlags)

	SetStderrFilePathSubprocessLauncher(path string)

	SetStdinFilePathSubprocessLauncher(path string)

	SetStdoutFilePathSubprocessLauncher(path string)

	SetenvSubprocessLauncher(variable string, value string, overwrite bool)

	SpawnvSubprocessLauncher(argv []string) (Subprocess, error)

	TakeFdSubprocessLauncher(sourceFd int, targetFd int)

	TakeStderrFdSubprocessLauncher(fd int)

	TakeStdinFdSubprocessLauncher(fd int)

	TakeStdoutFdSubprocessLauncher(fd int)

	UnsetenvSubprocessLauncher(variable string)
}

// subprocessLauncher implements the SubprocessLauncher class.
type subprocessLauncher struct {
	gextras.Objector
}

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return subprocessLauncher{
		Objector: obj,
	}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var _arg1 C.GSubprocessFlags     // out
	var _cret *C.GSubprocessLauncher // in

	_arg1 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_launcher_new(_arg1)

	var _subprocessLauncher SubprocessLauncher // out

	_subprocessLauncher = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SubprocessLauncher)

	return _subprocessLauncher
}

func (s subprocessLauncher) CloseSubprocessLauncher() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

func (s subprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (s subprocessLauncher) SetCwdSubprocessLauncher(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

func (s subprocessLauncher) SetEnvironSubprocessLauncher(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(env))
		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

func (s subprocessLauncher) SetFlagsSubprocessLauncher(flags SubprocessFlags) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.GSubprocessFlags     // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.GSubprocessFlags(flags)

	C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}

func (s subprocessLauncher) SetStderrFilePathSubprocessLauncher(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdinFilePathSubprocessLauncher(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdoutFilePathSubprocessLauncher(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetenvSubprocessLauncher(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocessLauncher) SpawnvSubprocessLauncher(argv []string) (Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar
	var _cret *C.GSubprocess // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocessLauncher) TakeFdSubprocessLauncher(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(sourceFd)
	_arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

func (s subprocessLauncher) TakeStderrFdSubprocessLauncher(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdinFdSubprocessLauncher(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdoutFdSubprocessLauncher(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

func (s subprocessLauncher) UnsetenvSubprocessLauncher(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the user’s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus interface {
	gextras.Objector

	AddServiceDirTestDBus(path string)

	DownTestDBus()

	BusAddress() string

	Flags() TestDBusFlags

	StopTestDBus()

	UpTestDBus()
}

// testDBus implements the TestDBus class.
type testDBus struct {
	gextras.Objector
}

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return testDBus{
		Objector: obj,
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

func NewTestDBus(flags TestDBusFlags) TestDBus {
	var _arg1 C.GTestDBusFlags // out
	var _cret *C.GTestDBus     // in

	_arg1 = C.GTestDBusFlags(flags)

	_cret = C.g_test_dbus_new(_arg1)

	var _testDBus TestDBus // out

	_testDBus = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TestDBus)

	return _testDBus
}

func (s testDBus) AddServiceDirTestDBus(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

func (s testDBus) DownTestDBus() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_down(_arg0)
}

func (s testDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s testDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

func (s testDBus) StopTestDBus() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_stop(_arg0)
}

func (s testDBus) UpTestDBus() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_up(_arg0)
}
