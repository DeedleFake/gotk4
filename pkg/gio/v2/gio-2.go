// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_bytes_icon_get_type()), F: marshalBytesIcon},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
	})
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor interface.
type appInfoMonitor struct {
	*externglib.Object
}

var _ AppInfoMonitor = (*appInfoMonitor)(nil)

// WrapAppInfoMonitor wraps a GObject to a type that implements
// interface AppInfoMonitor. It is primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return appInfoMonitor{obj}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector

	// AsIcon casts the class to the Icon interface.
	AsIcon() Icon
	// AsLoadableIcon casts the class to the LoadableIcon interface.
	AsLoadableIcon() LoadableIcon

	// Equal checks if two icons are equal.
	//
	// This method is inherited from Icon
	Equal(icon2 Icon) bool
	// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
	// be retrieved back by calling g_icon_deserialize() on the returned value.
	// As serialization will avoid using raw icon data when possible, it only
	// makes sense to transfer the #GVariant between processes on the same
	// machine, (as opposed to over the network), and within the same file
	// system namespace.
	//
	// This method is inherited from Icon
	Serialize() *glib.Variant
	// ToString generates a textual representation of @icon that can be used for
	// serialization such as when passing @icon to a different process or saving
	// it to persistent storage. Use g_icon_new_for_string() to get @icon back
	// from the returned string.
	//
	// The encoding of the returned string is proprietary to #GIcon except in
	// the following two cases
	//
	// - If @icon is a Icon, the returned string is a native path (such as
	// `/path/to/my icon.png`) without escaping if the #GFile for @icon is a
	// native file. If the file is not native, the returned string is the result
	// of g_file_get_uri() (such as `sftp://path/to/my20icon.png`).
	//
	// - If @icon is a Icon with exactly one name and no fallbacks, the encoding
	// is simply the name (such as `network-server`).
	//
	// This method is inherited from Icon
	ToString() string
	// Load loads a loadable icon. For the asynchronous version of this
	// function, see g_loadable_icon_load_async().
	//
	// This method is inherited from LoadableIcon
	Load(size int, cancellable Cancellable) (string, InputStream, error)
	// LoadAsync loads an icon asynchronously. To finish this function, see
	// g_loadable_icon_load_finish(). For the synchronous, blocking version of
	// this function, see g_loadable_icon_load().
	//
	// This method is inherited from LoadableIcon
	LoadAsync(size int, cancellable Cancellable, callback AsyncReadyCallback)
	// LoadFinish finishes an asynchronous icon load started in
	// g_loadable_icon_load_async().
	//
	// This method is inherited from LoadableIcon
	LoadFinish(res AsyncResult) (string, InputStream, error)
	// Equal checks if two icons are equal.
	//
	// This method is inherited from Icon
	Equal(icon2 Icon) bool
	// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can
	// be retrieved back by calling g_icon_deserialize() on the returned value.
	// As serialization will avoid using raw icon data when possible, it only
	// makes sense to transfer the #GVariant between processes on the same
	// machine, (as opposed to over the network), and within the same file
	// system namespace.
	//
	// This method is inherited from Icon
	Serialize() *glib.Variant
	// ToString generates a textual representation of @icon that can be used for
	// serialization such as when passing @icon to a different process or saving
	// it to persistent storage. Use g_icon_new_for_string() to get @icon back
	// from the returned string.
	//
	// The encoding of the returned string is proprietary to #GIcon except in
	// the following two cases
	//
	// - If @icon is a Icon, the returned string is a native path (such as
	// `/path/to/my icon.png`) without escaping if the #GFile for @icon is a
	// native file. If the file is not native, the returned string is the result
	// of g_file_get_uri() (such as `sftp://path/to/my20icon.png`).
	//
	// - If @icon is a Icon with exactly one name and no fallbacks, the encoding
	// is simply the name (such as `network-server`).
	//
	// This method is inherited from Icon
	ToString() string
}

// bytesIcon implements the BytesIcon interface.
type bytesIcon struct {
	*externglib.Object
}

var _ BytesIcon = (*bytesIcon)(nil)

// WrapBytesIcon wraps a GObject to a type that implements
// interface BytesIcon. It is primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return bytesIcon{obj}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

func (b bytesIcon) AsIcon() Icon {
	return WrapIcon(gextras.InternObject(b))
}

func (b bytesIcon) AsLoadableIcon() LoadableIcon {
	return WrapLoadableIcon(gextras.InternObject(b))
}

func (i bytesIcon) Equal(icon2 Icon) bool {
	return WrapIcon(gextras.InternObject(i)).Equal(icon2)
}

func (i bytesIcon) Serialize() *glib.Variant {
	return WrapIcon(gextras.InternObject(i)).Serialize()
}

func (i bytesIcon) ToString() string {
	return WrapIcon(gextras.InternObject(i)).ToString()
}

func (i bytesIcon) Load(size int, cancellable Cancellable) (string, InputStream, error) {
	return WrapLoadableIcon(gextras.InternObject(i)).Load(size, cancellable)
}

func (i bytesIcon) LoadAsync(size int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapLoadableIcon(gextras.InternObject(i)).LoadAsync(size, cancellable, callback)
}

func (i bytesIcon) LoadFinish(res AsyncResult) (string, InputStream, error) {
	return WrapLoadableIcon(gextras.InternObject(i)).LoadFinish(res)
}

func (i bytesIcon) Equal(icon2 Icon) bool {
	return WrapIcon(gextras.InternObject(i)).Equal(icon2)
}

func (i bytesIcon) Serialize() *glib.Variant {
	return WrapIcon(gextras.InternObject(i)).Serialize()
}

func (i bytesIcon) ToString() string {
	return WrapIcon(gextras.InternObject(i)).ToString()
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector

	// AsActionGroup casts the class to the ActionGroup interface.
	AsActionGroup() ActionGroup
	// AsRemoteActionGroup casts the class to the RemoteActionGroup interface.
	AsRemoteActionGroup() RemoteActionGroup

	// ActionAdded emits the Group::action-added signal on @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within @action_group.
	//
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	//
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	//
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	//
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	//
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	//
	//    g_debug ("application has been terminated. exiting.");
	//
	//    exit (0);
	//
	// This method is inherited from ActionGroup
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	//
	// This method is inherited from ActionGroup
	ChangeActionState(actionName string, value *glib.Variant)
	// GetActionEnabled checks if the named action within @action_group is
	// currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This method is inherited from ActionGroup
	GetActionEnabled(actionName string) bool
	// GetActionParameterType queries the type of the parameter that must be
	// given when activating the named action within @action_group.
	//
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	//
	// This method is inherited from ActionGroup
	GetActionParameterType(actionName string) *glib.VariantType
	// GetActionState queries the current state of the named action within
	// @action_group.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from ActionGroup
	GetActionState(actionName string) *glib.Variant
	// GetActionStateHint requests a hint about the valid range of values for
	// the state of the named action within @action_group.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from ActionGroup
	GetActionStateHint(actionName string) *glib.Variant
	// GetActionStateType queries the type of the state of the named action
	// within @action_group.
	//
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	//
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	//
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	//
	// This method is inherited from ActionGroup
	GetActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within @action_group.
	//
	// This method is inherited from ActionGroup
	HasAction(actionName string) bool
	// ListActions lists the actions contained within @action_group.
	//
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
	//
	// This method is inherited from ActionGroup
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	//
	// This method is inherited from ActionGroup
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
	// ActivateActionFull activates the remote action.
	//
	// This is the same as g_action_group_activate_action() except that it
	// allows for provision of "platform data" to be sent along with the
	// activation request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	//
	// This method is inherited from RemoteActionGroup
	ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant)
	// ChangeActionStateFull changes the state of a remote action.
	//
	// This is the same as g_action_group_change_action_state() except that it
	// allows for provision of "platform data" to be sent along with the state
	// change request. This typically contains details such as the user
	// interaction timestamp or startup notification information.
	//
	// @platform_data must be non-nil and must have the type
	// G_VARIANT_TYPE_VARDICT. If it is floating, it will be consumed.
	//
	// This method is inherited from RemoteActionGroup
	ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant)
	// ActionAdded emits the Group::action-added signal on @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// @action_group.
	//
	// This function should only be called by Group implementations.
	//
	// This method is inherited from ActionGroup
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within @action_group.
	//
	// If the action is expecting a parameter, then the correct type of
	// parameter must be given as @parameter. If the action is expecting no
	// parameters then @parameter must be nil. See
	// g_action_group_get_action_parameter_type().
	//
	// If the Group implementation supports asynchronous remote activation over
	// D-Bus, this call may return before the relevant D-Bus traffic has been
	// sent, or any replies have been received. In order to block on such
	// asynchronous activation calls, g_dbus_connection_flush() should be called
	// prior to the code, which depends on the result of the action activation.
	// Without flushing the D-Bus connection, there is no guarantee that the
	// action would have been activated.
	//
	// The following code which runs in a remote app instance, shows an example
	// of a "quit" action being activated on the primary app instance over
	// D-Bus. Here g_dbus_connection_flush() is called before `exit()`. Without
	// g_dbus_connection_flush(), the "quit" action may fail to be activated on
	// the primary instance.
	//
	//    // call "quit" action on primary instance
	//    g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
	//
	//    // make sure the action is activated now
	//    g_dbus_connection_flush (...);
	//
	//    g_debug ("application has been terminated. exiting.");
	//
	//    exit (0);
	//
	// This method is inherited from ActionGroup
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// @action_group to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_group_get_action_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_group_get_action_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	//
	// This method is inherited from ActionGroup
	ChangeActionState(actionName string, value *glib.Variant)
	// GetActionEnabled checks if the named action within @action_group is
	// currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This method is inherited from ActionGroup
	GetActionEnabled(actionName string) bool
	// GetActionParameterType queries the type of the parameter that must be
	// given when activating the named action within @action_group.
	//
	// When activating the action using g_action_group_activate_action(), the
	// #GVariant given to that function must be of the type returned by this
	// function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	//
	// This method is inherited from ActionGroup
	GetActionParameterType(actionName string) *glib.VariantType
	// GetActionState queries the current state of the named action within
	// @action_group.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_group_get_action_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from ActionGroup
	GetActionState(actionName string) *glib.Variant
	// GetActionStateHint requests a hint about the valid range of values for
	// the state of the named action within @action_group.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from ActionGroup
	GetActionStateHint(actionName string) *glib.Variant
	// GetActionStateType queries the type of the state of the named action
	// within @action_group.
	//
	// If the action is stateful then this function returns the Type of the
	// state. All calls to g_action_group_change_action_state() must give a
	// #GVariant of this type and g_action_group_get_action_state() will return
	// a #GVariant of the same type.
	//
	// If the action is not stateful then this function will return nil. In that
	// case, g_action_group_get_action_state() will return nil and you must not
	// call g_action_group_change_action_state().
	//
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	//
	// This method is inherited from ActionGroup
	GetActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within @action_group.
	//
	// This method is inherited from ActionGroup
	HasAction(actionName string) bool
	// ListActions lists the actions contained within @action_group.
	//
	// The caller is responsible for freeing the list with g_strfreev() when it
	// is no longer required.
	//
	// This method is inherited from ActionGroup
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// @action_group.
	//
	// This function acquires the information available from
	// g_action_group_has_action(), g_action_group_get_action_enabled(),
	// g_action_group_get_action_parameter_type(),
	// g_action_group_get_action_state_type(),
	// g_action_group_get_action_state_hint() and
	// g_action_group_get_action_state() with a single function call.
	//
	// This provides two main benefits.
	//
	// The first is the improvement in efficiency that comes with not having to
	// perform repeated lookups of the action in order to discover different
	// things about it. The second is that implementing Group can now be done by
	// only overriding this one virtual function.
	//
	// The interface provides a default implementation of this function that
	// calls the individual functions, as required, to fetch the information.
	// The interface also provides default implementations of those functions
	// that call this function. All implementations, therefore, must override
	// either this function or all of the others.
	//
	// If the action exists, true is returned and any of the requested fields
	// (as indicated by having a non-nil reference passed in) are filled. If the
	// action doesn't exist, false is returned and the fields may or may not
	// have been modified.
	//
	// This method is inherited from ActionGroup
	QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool)
}

// dBusActionGroup implements the DBusActionGroup interface.
type dBusActionGroup struct {
	*externglib.Object
}

var _ DBusActionGroup = (*dBusActionGroup)(nil)

// WrapDBusActionGroup wraps a GObject to a type that implements
// interface DBusActionGroup. It is primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return dBusActionGroup{obj}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

func (d dBusActionGroup) AsActionGroup() ActionGroup {
	return WrapActionGroup(gextras.InternObject(d))
}

func (d dBusActionGroup) AsRemoteActionGroup() RemoteActionGroup {
	return WrapRemoteActionGroup(gextras.InternObject(d))
}

func (a dBusActionGroup) ActionAdded(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionAdded(actionName)
}

func (a dBusActionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	WrapActionGroup(gextras.InternObject(a)).ActionEnabledChanged(actionName, enabled)
}

func (a dBusActionGroup) ActionRemoved(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionRemoved(actionName)
}

func (a dBusActionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActionStateChanged(actionName, state)
}

func (a dBusActionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActivateAction(actionName, parameter)
}

func (a dBusActionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ChangeActionState(actionName, value)
}

func (a dBusActionGroup) GetActionEnabled(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).GetActionEnabled(actionName)
}

func (a dBusActionGroup) GetActionParameterType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).GetActionParameterType(actionName)
}

func (a dBusActionGroup) GetActionState(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).GetActionState(actionName)
}

func (a dBusActionGroup) GetActionStateHint(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).GetActionStateHint(actionName)
}

func (a dBusActionGroup) GetActionStateType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).GetActionStateType(actionName)
}

func (a dBusActionGroup) HasAction(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).HasAction(actionName)
}

func (a dBusActionGroup) ListActions() []string {
	return WrapActionGroup(gextras.InternObject(a)).ListActions()
}

func (a dBusActionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	return WrapActionGroup(gextras.InternObject(a)).QueryAction(actionName)
}

func (r dBusActionGroup) ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant) {
	WrapRemoteActionGroup(gextras.InternObject(r)).ActivateActionFull(actionName, parameter, platformData)
}

func (r dBusActionGroup) ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant) {
	WrapRemoteActionGroup(gextras.InternObject(r)).ChangeActionStateFull(actionName, value, platformData)
}

func (a dBusActionGroup) ActionAdded(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionAdded(actionName)
}

func (a dBusActionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	WrapActionGroup(gextras.InternObject(a)).ActionEnabledChanged(actionName, enabled)
}

func (a dBusActionGroup) ActionRemoved(actionName string) {
	WrapActionGroup(gextras.InternObject(a)).ActionRemoved(actionName)
}

func (a dBusActionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActionStateChanged(actionName, state)
}

func (a dBusActionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ActivateAction(actionName, parameter)
}

func (a dBusActionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	WrapActionGroup(gextras.InternObject(a)).ChangeActionState(actionName, value)
}

func (a dBusActionGroup) GetActionEnabled(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).GetActionEnabled(actionName)
}

func (a dBusActionGroup) GetActionParameterType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).GetActionParameterType(actionName)
}

func (a dBusActionGroup) GetActionState(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).GetActionState(actionName)
}

func (a dBusActionGroup) GetActionStateHint(actionName string) *glib.Variant {
	return WrapActionGroup(gextras.InternObject(a)).GetActionStateHint(actionName)
}

func (a dBusActionGroup) GetActionStateType(actionName string) *glib.VariantType {
	return WrapActionGroup(gextras.InternObject(a)).GetActionStateType(actionName)
}

func (a dBusActionGroup) HasAction(actionName string) bool {
	return WrapActionGroup(gextras.InternObject(a)).HasAction(actionName)
}

func (a dBusActionGroup) ListActions() []string {
	return WrapActionGroup(gextras.InternObject(a)).ListActions()
}

func (a dBusActionGroup) QueryAction(actionName string) (enabled bool, parameterType *glib.VariantType, stateType *glib.VariantType, stateHint *glib.Variant, state *glib.Variant, ok bool) {
	return WrapActionGroup(gextras.InternObject(a)).QueryAction(actionName)
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver interface.
type dBusAuthObserver struct {
	*externglib.Object
}

var _ DBusAuthObserver = (*dBusAuthObserver)(nil)

// WrapDBusAuthObserver wraps a GObject to a type that implements
// interface DBusAuthObserver. It is primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return dBusAuthObserver{obj}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver creates a new BusAuthObserver object.
func NewDBusAuthObserver() DBusAuthObserver {
	var _cret *C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver DBusAuthObserver // out

	_dBusAuthObserver = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusAuthObserver)

	return _dBusAuthObserver
}

func (o dBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (o dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector

	// AsAsyncInitable casts the class to the AsyncInitable interface.
	AsAsyncInitable() AsyncInitable
	// AsInitable casts the class to the Initable interface.
	AsInitable() Initable

	// InitAsync starts asynchronous initialization of the object implementing
	// the interface. This must be done before any real use of the object after
	// initial construction. If the object also implements #GInitable you can
	// optionally call g_initable_init() instead.
	//
	// This method is intended for language bindings. If writing in C,
	// g_async_initable_new_async() should typically be used instead.
	//
	// When the initialization is finished, @callback will be called. You can
	// then call g_async_initable_init_finish() to get the result of the
	// initialization.
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil, and
	// the object doesn't support cancellable initialization, the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// As with #GInitable, if the object is not initialized, or initialization
	// returns with an error, then all operations on the object except
	// g_object_ref() and g_object_unref() are considered to be invalid, and
	// have undefined behaviour. They will often fail with g_critical() or
	// g_warning(), but this must not be relied on.
	//
	// Callers should not assume that a class which implements Initable can be
	// initialized multiple times; for more information, see g_initable_init().
	// If a class explicitly supports being initialized multiple times,
	// implementation requires yielding all subsequent calls to init_async() on
	// the results of the first call.
	//
	// For classes that also support the #GInitable interface, the default
	// implementation of this method will run the g_initable_init() function in
	// a thread, so if you want to support asynchronous initialization via
	// threads, just implement the Initable interface without overriding any
	// interface methods.
	//
	// This method is inherited from AsyncInitable
	InitAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// InitFinish finishes asynchronous initialization and returns the result.
	// See g_async_initable_init_async().
	//
	// This method is inherited from AsyncInitable
	InitFinish(res AsyncResult) error
	// NewFinish finishes the async construction for the various
	// g_async_initable_new calls, returning the created object or nil on error.
	//
	// This method is inherited from AsyncInitable
	NewFinish(res AsyncResult) (gextras.Objector, error)
	// Init initializes the object implementing the interface.
	//
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	//
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	//
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class’ implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	//
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	//
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	//
	// This method is inherited from Initable
	Init(cancellable Cancellable) error

	// Call: asynchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type. Unless it’s G_VARIANT_TYPE_UNIT, the @reply_type will be a tuple
	// containing one or more values.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call (connection,
	//                            "org.freedesktop.StringThings",
	//                            "/org/freedesktop/StringThings",
	//                            "org.freedesktop.StringThings",
	//                            "TwoStrings",
	//                            g_variant_new ("(ss)",
	//                                           "Thing One",
	//                                           "Thing Two"),
	//                            NULL,
	//                            G_DBUS_CALL_FLAGS_NONE,
	//                            -1,
	//                            NULL,
	//                            (GAsyncReadyCallback) two_strings_done,
	//                            NULL);
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_call_finish() to get the result of the operation. See
	// g_dbus_connection_call_sync() for the synchronous version of this
	// function.
	//
	// If @callback is nil then the D-Bus method call message will be sent with
	// the G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
	Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback)
	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResult) (*glib.Variant, error)
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call_sync (connection,
	//                                 "org.freedesktop.StringThings",
	//                                 "/org/freedesktop/StringThings",
	//                                 "org.freedesktop.StringThings",
	//                                 "TwoStrings",
	//                                 g_variant_new ("(ss)",
	//                                                "Thing One",
	//                                                "Thing Two"),
	//                                 NULL,
	//                                 G_DBUS_CALL_FLAGS_NONE,
	//                                 -1,
	//                                 NULL,
	//                                 &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error)
	// CallWithUnixFdList: like g_dbus_connection_call() but also takes a FDList
	// object.
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if a message contains two file
	// descriptors, @fd_list would have length 2, and `g_variant_new_handle (0)`
	// and `g_variant_new_handle (1)` would appear somewhere in the body of the
	// message (not necessarily in that order!) to represent the file
	// descriptors at indexes 0 and 1 respectively.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced in this way by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	//
	// This method is only available on UNIX.
	CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced in this way by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects. See
	// g_dbus_connection_call_with_unix_fd_list() and
	// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error)
	// Close closes @connection. Note that this never causes the process to exit
	// (this might only happen if the other end of a shared message bus
	// connection disconnects, see BusConnection:exit-on-close).
	//
	// Once the connection is closed, operations such as sending a message will
	// return with the error G_IO_ERROR_CLOSED. Closing a connection will not
	// automatically flush the connection so queued messages may be lost. Use
	// g_dbus_connection_flush() if you need such guarantees.
	//
	// If @connection is already closed, this method fails with
	// G_IO_ERROR_CLOSED.
	//
	// When @connection has been closed, the BusConnection::closed signal is
	// emitted in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread that
	// @connection was constructed in.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_close_finish() to get the result of the operation. See
	// g_dbus_connection_close_sync() for the synchronous version.
	Close(cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResult) error
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) error
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error
	// ExportActionGroup exports @action_group on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// A given object path can only have one action group exported on it. If
	// this constraint is violated, the export will fail and 0 will be returned
	// (with @error set accordingly).
	//
	// You can unexport the action group using
	// g_dbus_connection_unexport_action_group() with the return value of this
	// function.
	//
	// The thread default main context is taken at the time of this call. All
	// incoming action activations and state change requests are reported from
	// this context. Any changes on the action group that cause it to emit
	// signals must also come from this same context. Since incoming action
	// activations and state change requests are rather likely to cause changes
	// on the action group, this effectively limits a given action group to
	// being exported from only one main context.
	ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error)
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) (uint, error)
	// Flush: asynchronously flushes @connection, that is, writes all queued
	// outgoing message to the transport and then flushes the transport (using
	// g_output_stream_flush_async()). This is useful in programs that wants to
	// emit a D-Bus signal and then exit immediately. Without flushing the
	// connection, there is no guaranteed that the message has been sent to the
	// networking buffers in the OS kernel.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_flush_finish() to get the result of the operation. See
	// g_dbus_connection_flush_sync() for the synchronous version.
	Flush(cancellable Cancellable, callback AsyncReadyCallback)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResult) error
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) error
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterId uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error)
	// SendMessageWithReply: asynchronously sends @message to the peer
	// represented by @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// This is an asynchronous method. When the operation is finished, @callback
	// will be invoked in the [thread-default main
	// context][g-main-context-push-thread-default] of the thread you are
	// calling this method from. You can then call
	// g_dbus_connection_send_message_with_reply_finish() to get the result of
	// the operation. See g_dbus_connection_send_message_with_reply_sync() for
	// the synchronous version.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error)
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after it’s stopped being iterated.
	SignalUnsubscribe(subscriptionId uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportId uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportId uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationId uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationId uint) bool
}

// dBusConnection implements the DBusConnection interface.
type dBusConnection struct {
	*externglib.Object
}

var _ DBusConnection = (*dBusConnection)(nil)

// WrapDBusConnection wraps a GObject to a type that implements
// interface DBusConnection. It is primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return dBusConnection{obj}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish finishes an operation started with
// g_dbus_connection_new().
func NewDBusConnectionFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish finishes an operation started with
// g_dbus_connection_new_for_address().
func NewDBusConnectionForAddressFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusConnection // in
	var _cerr *C.GError          // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressSync: synchronously connects and sets up a D-Bus
// client connection for exchanging D-Bus messages with an endpoint specified by
// @address which must be in the D-Bus address format
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
//
// This constructor can only be used to initiate client-side connections - use
// g_dbus_connection_new_sync() if you need to act as the server. In particular,
// @flags cannot contain the G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
//
// This is a synchronous failable constructor. See
// g_dbus_connection_new_for_address() for the asynchronous version.
//
// If @observer is not nil it may be used to control the authentication process.
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _arg4 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusConnectionFlags(flags)
	_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionSync: synchronously sets up a D-Bus connection for
// exchanging D-Bus messages with the end represented by @stream.
//
// If @stream is a Connection, then the corresponding #GSocket will be put into
// non-blocking mode.
//
// The D-Bus connection will interact with @stream from a worker thread. As a
// result, the caller should not interact with @stream after this method has
// been called, except by calling g_object_unref() on it.
//
// If @observer is not nil it may be used to control the authentication process.
//
// This is a synchronous failable constructor. See g_dbus_connection_new() for
// the asynchronous version.
func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _arg5 *C.GCancellable        // out
	var _cret *C.GDBusConnection     // in
	var _cerr *C.GError              // in

	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GDBusConnectionFlags(flags)
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

func (d dBusConnection) AsAsyncInitable() AsyncInitable {
	return WrapAsyncInitable(gextras.InternObject(d))
}

func (d dBusConnection) AsInitable() Initable {
	return WrapInitable(gextras.InternObject(d))
}

func (i dBusConnection) InitAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapAsyncInitable(gextras.InternObject(i)).InitAsync(ioPriority, cancellable, callback)
}

func (i dBusConnection) InitFinish(res AsyncResult) error {
	return WrapAsyncInitable(gextras.InternObject(i)).InitFinish(res)
}

func (i dBusConnection) NewFinish(res AsyncResult) (gextras.Objector, error) {
	return WrapAsyncInitable(gextras.InternObject(i)).NewFinish(res)
}

func (i dBusConnection) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

func (c dBusConnection) Call(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg9 *C.GCancellable        // out
	var _arg10 C.GAsyncReadyCallback // out
	var _arg11 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg10 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg11 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
}

func (c dBusConnection) CallFinish(res AsyncResult) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GCancellable    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdList(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection     // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 *C.GVariant            // out
	var _arg6 *C.GVariantType        // out
	var _arg7 C.GDBusCallFlags       // out
	var _arg8 C.gint                 // out
	var _arg9 *C.GUnixFDList         // out
	var _arg10 *C.GCancellable       // out
	var _arg11 C.GAsyncReadyCallback // out
	var _arg12 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg10 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg11 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg12 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_call_with_unix_fd_list(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12)
}

func (c dBusConnection) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GUnixFDList     // in
	var _arg2 *C.GAsyncResult    // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, &_arg1, _arg2, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1))).(UnixFDList)
	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GUnixFDList     // out
	var _arg10 *C.GUnixFDList    // in
	var _arg11 *C.GCancellable   // out
	var _cret *C.GVariant        // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType))
	_arg7 = C.GDBusCallFlags(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_arg10, _arg11, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg10))).(UnixFDList)
	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

func (c dBusConnection) Close(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_close(_arg0, _arg1, _arg2, _arg3)
}

func (c dBusConnection) CloseFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) CloseSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters))

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out
	var _cret C.guint            // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

func (c dBusConnection) Flush(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusConnection    // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_flush(_arg0, _arg1, _arg2, _arg3)
}

func (c dBusConnection) FlushFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) FlushSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusCapabilityFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

func (c dBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection     // out
	var _cret C.GDBusConnectionFlags // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

func (c dBusConnection) Guid() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out
	var _cret C.guint32          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (c dBusConnection) PeerCredentials() Credentials {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GCredentials    // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials Credentials // out

	_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Credentials)

	return _credentials
}

func (c dBusConnection) Stream() IOStream {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.GIOStream       // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream IOStream // out

	_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IOStream)

	return _ioStream
}

func (c dBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

func (c dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.guint32               // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = uint32(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _goerr
}

func (c dBusConnection) SendMessageWithReply(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable, callback AsyncReadyCallback) uint32 {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg5 *C.GCancellable         // out
	var _arg6 C.GAsyncReadyCallback   // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg6 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg7 = C.gpointer(box.Assign(callback))

	C.g_dbus_connection_send_message_with_reply(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, _arg6, _arg7)

	var _outSerial uint32 // out

	_outSerial = uint32(_arg4)

	return _outSerial
}

func (c dBusConnection) SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cret *C.GDBusMessage    // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (c dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg4 C.guint32               // in
	var _arg5 *C.GCancellable         // out
	var _cret *C.GDBusMessage         // in
	var _cerr *C.GError               // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = C.GDBusSendMessageFlags(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, &_arg4, _arg5, &_cerr)

	var _outSerial uint32        // out
	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_outSerial = uint32(_arg4)
	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _dBusMessage, _goerr
}

func (c dBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

func (c dBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

func (c dBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

func (c dBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

func (c dBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

func (c dBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	gextras.Objector

	// AsMenuModel casts the class to the MenuModel interface.
	AsMenuModel() MenuModel

	// GetItemAttributeValue queries the item at position @item_index in @model
	// for the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	//
	// This method is inherited from MenuModel
	GetItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// GetItemLink queries the item at position @item_index in @model for the
	// link specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	//
	// This method is inherited from MenuModel
	GetItemLink(itemIndex int, link string) MenuModel
	// GetNItems: query the number of items in @model.
	//
	// This method is inherited from MenuModel
	GetNItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	//
	// This method is inherited from MenuModel
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	//
	// This method is inherited from MenuModel
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// This method is inherited from MenuModel
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// This method is inherited from MenuModel
	IterateItemLinks(itemIndex int) MenuLinkIter
}

// dBusMenuModel implements the DBusMenuModel interface.
type dBusMenuModel struct {
	*externglib.Object
}

var _ DBusMenuModel = (*dBusMenuModel)(nil)

// WrapDBusMenuModel wraps a GObject to a type that implements
// interface DBusMenuModel. It is primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return dBusMenuModel{obj}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

func (d dBusMenuModel) AsMenuModel() MenuModel {
	return WrapMenuModel(gextras.InternObject(d))
}

func (m dBusMenuModel) GetItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	return WrapMenuModel(gextras.InternObject(m)).GetItemAttributeValue(itemIndex, attribute, expectedType)
}

func (m dBusMenuModel) GetItemLink(itemIndex int, link string) MenuModel {
	return WrapMenuModel(gextras.InternObject(m)).GetItemLink(itemIndex, link)
}

func (m dBusMenuModel) GetNItems() int {
	return WrapMenuModel(gextras.InternObject(m)).GetNItems()
}

func (m dBusMenuModel) IsMutable() bool {
	return WrapMenuModel(gextras.InternObject(m)).IsMutable()
}

func (m dBusMenuModel) ItemsChanged(position int, removed int, added int) {
	WrapMenuModel(gextras.InternObject(m)).ItemsChanged(position, removed, added)
}

func (m dBusMenuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter {
	return WrapMenuModel(gextras.InternObject(m)).IterateItemAttributes(itemIndex)
}

func (m dBusMenuModel) IterateItemLinks(itemIndex int) MenuLinkIter {
	return WrapMenuModel(gextras.InternObject(m)).IterateItemLinks(itemIndex)
}

// DBusMessage: type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() (DBusMessage, error)
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (list, 5, ...)`.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//
	// or
	//
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(typ DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	SetUnixFdList(fdList UnixFDList)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() error
}

// dBusMessage implements the DBusMessage interface.
type dBusMessage struct {
	*externglib.Object
}

var _ DBusMessage = (*dBusMessage)(nil)

// WrapDBusMessage wraps a GObject to a type that implements
// interface DBusMessage. It is primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return dBusMessage{obj}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

// NewDBusMessage creates a new empty BusMessage.
func NewDBusMessage() DBusMessage {
	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

// NewDBusMessageFromBlob creates a new BusMessage from the data stored at
// @blob. The byte order that the message was in can be retrieved using
// g_dbus_message_get_byte_order().
//
// If the @blob cannot be parsed, contains invalid fields, or contains invalid
// headers, G_IO_ERROR_INVALID_ARGUMENT will be returned.
func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (DBusMessage, error) {
	var _arg1 *C.guchar
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out
	var _cret *C.GDBusMessage        // in
	var _cerr *C.GError              // in

	_arg2 = C.gsize(len(blob))
	_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	_arg3 = C.GDBusCapabilityFlags(capabilities)

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// NewDBusMessageMethodCall creates a new BusMessage for a method call.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

// NewDBusMessageSignal creates a new BusMessage for a signal emission.
func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) Copy() (DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

func (m dBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

func (m dBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage         // out
	var _cret C.GDBusMessageByteOrder // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

func (m dBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage     // out
	var _cret C.GDBusMessageFlags // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

func (m dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _cret *C.GVariant               // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

func (m dBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.guchar

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte

	{
		var i int
		var z C.guchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = byte(src[i])
		}
	}

	return _guint8s
}

func (m dBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (m dBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage    // out
	var _cret C.GDBusMessageType // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

func (m dBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out
	var _cret C.guint32       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (m dBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m dBusMessage) UnixFdList() UnixFDList {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GUnixFDList  // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList UnixFDList // out

	_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(UnixFDList)

	return _unixFDList
}

func (m dBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_lock(_arg0)
}

func (m dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) NewMethodReply() DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _cret *C.GDBusMessage // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (m dBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint(indent)

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (m dBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(body))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

func (m dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageByteOrder(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
}

func (m dBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

func (m dBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

func (m dBusMessage) SetFlags(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageFlags(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
}

func (m dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageHeaderField(headerField)
	_arg2 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}

func (m dBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

func (m dBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_member(_arg0, _arg1)
}

func (m dBusMessage) SetMessageType(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.GDBusMessageType(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
}

func (m dBusMessage) SetNumUnixFds(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

func (m dBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_path(_arg0, _arg1)
}

func (m dBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

func (m dBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

func (m dBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

func (m dBusMessage) SetUnixFdList(fdList UnixFDList) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

func (m dBusMessage) ToGerror() error {
	var _arg0 *C.GDBusMessage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(err error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
}

// dBusMethodInvocation implements the DBusMethodInvocation interface.
type dBusMethodInvocation struct {
	*externglib.Object
}

var _ DBusMethodInvocation = (*dBusMethodInvocation)(nil)

// WrapDBusMethodInvocation wraps a GObject to a type that implements
// interface DBusMethodInvocation. It is primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return dBusMethodInvocation{obj}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

func (i dBusMethodInvocation) Connection() DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusConnection       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusConnection)

	return _dBusConnection
}

func (i dBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Message() DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMessage          // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DBusMessage)

	return _dBusMessage
}

func (i dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusMethodInfo       // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = (*DBusMethodInfo)(unsafe.Pointer(_cret))
	C.g_dbus_method_info_ref(_cret)
	runtime.SetFinalizer(_dBusMethodInfo, func(v *DBusMethodInfo) {
		C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(unsafe.Pointer(v)))
	})

	return _dBusMethodInfo
}

func (i dBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GVariant              // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

func (i dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.GDBusPropertyInfo     // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = (*DBusPropertyInfo)(unsafe.Pointer(_cret))
	C.g_dbus_property_info_ref(_cret)
	runtime.SetFinalizer(_dBusPropertyInfo, func(v *DBusPropertyInfo) {
		C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(unsafe.Pointer(v)))
	})

	return _dBusPropertyInfo
}

func (i dBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (i dBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

func (i dBusMethodInvocation) ReturnGerror(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GError)(gerror.New(err))
	if _arg1 != nil {
		defer C.g_error_free(_arg1)
	}

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

func (i dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer interface {
	gextras.Objector

	// AsInitable casts the class to the Initable interface.
	AsInitable() Initable

	// Init initializes the object implementing the interface.
	//
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	//
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	//
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class’ implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	//
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	//
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	//
	// This method is inherited from Initable
	Init(cancellable Cancellable) error

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// dBusServer implements the DBusServer interface.
type dBusServer struct {
	*externglib.Object
}

var _ DBusServer = (*dBusServer)(nil)

// WrapDBusServer wraps a GObject to a type that implements
// interface DBusServer. It is primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return dBusServer{obj}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

// NewDBusServerSync creates a new D-Bus server that listens on the first
// address in @address that works.
//
// Once constructed, you can use g_dbus_server_get_client_address() to get a
// D-Bus address string that clients can use to connect.
//
// To have control over the available authentication mechanisms and the users
// that are authorized to connect, it is strongly recommended to provide a
// non-nil BusAuthObserver.
//
// Connect to the BusServer::new-connection signal to handle incoming
// connections.
//
// The returned BusServer isn't active - you have to start it with
// g_dbus_server_start().
//
// BusServer is used in this [example][gdbus-peer-to-peer].
//
// This is a synchronous failable constructor. There is currently no
// asynchronous version.
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) (DBusServer, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _arg5 *C.GCancellable      // out
	var _cret *C.GDBusServer       // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GDBusServerFlags(flags)
	_arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusServer DBusServer // out
	var _goerr error           // out

	_dBusServer = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(DBusServer)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusServer, _goerr
}

func (d dBusServer) AsInitable() Initable {
	return WrapInitable(gextras.InternObject(d))
}

func (i dBusServer) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

func (s dBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer     // out
	var _cret C.GDBusServerFlags // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

func (s dBusServer) Guid() string {
	var _arg0 *C.GDBusServer // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s dBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s dBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_start(_arg0)
}

func (s dBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_stop(_arg0)
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	gextras.Objector

	// AsMenuModel casts the class to the MenuModel interface.
	AsMenuModel() MenuModel

	// GetItemAttributeValue queries the item at position @item_index in @model
	// for the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	//
	// This method is inherited from MenuModel
	GetItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// GetItemLink queries the item at position @item_index in @model for the
	// link specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	//
	// This method is inherited from MenuModel
	GetItemLink(itemIndex int, link string) MenuModel
	// GetNItems: query the number of items in @model.
	//
	// This method is inherited from MenuModel
	GetNItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	//
	// This method is inherited from MenuModel
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	//
	// This method is inherited from MenuModel
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// This method is inherited from MenuModel
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// This method is inherited from MenuModel
	IterateItemLinks(itemIndex int) MenuLinkIter

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// menu implements the Menu interface.
type menu struct {
	*externglib.Object
}

var _ Menu = (*menu)(nil)

// WrapMenu wraps a GObject to a type that implements
// interface Menu. It is primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{obj}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu creates a new #GMenu.
//
// The new menu has no items.
func NewMenu() Menu {
	var _cret *C.GMenu // in

	_cret = C.g_menu_new()

	var _menu Menu // out

	_menu = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Menu)

	return _menu
}

func (m menu) AsMenuModel() MenuModel {
	return WrapMenuModel(gextras.InternObject(m))
}

func (m menu) GetItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	return WrapMenuModel(gextras.InternObject(m)).GetItemAttributeValue(itemIndex, attribute, expectedType)
}

func (m menu) GetItemLink(itemIndex int, link string) MenuModel {
	return WrapMenuModel(gextras.InternObject(m)).GetItemLink(itemIndex, link)
}

func (m menu) GetNItems() int {
	return WrapMenuModel(gextras.InternObject(m)).GetNItems()
}

func (m menu) IsMutable() bool {
	return WrapMenuModel(gextras.InternObject(m)).IsMutable()
}

func (m menu) ItemsChanged(position int, removed int, added int) {
	WrapMenuModel(gextras.InternObject(m)).ItemsChanged(position, removed, added)
}

func (m menu) IterateItemAttributes(itemIndex int) MenuAttributeIter {
	return WrapMenuModel(gextras.InternObject(m)).IterateItemAttributes(itemIndex)
}

func (m menu) IterateItemLinks(itemIndex int) MenuLinkIter {
	return WrapMenuModel(gextras.InternObject(m)).IterateItemLinks(itemIndex)
}

func (m menu) Append(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_append(_arg0, _arg1, _arg2)
}

func (m menu) AppendItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

func (m menu) AppendSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

func (m menu) AppendSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

func (m menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_freeze(_arg0)
}

func (m menu) Insert(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertItem(position int, item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

func (m menu) InsertSection(position int, label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) InsertSubmenu(position int, label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

func (m menu) Prepend(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

func (m menu) PrependItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

func (m menu) PrependSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

func (m menu) PrependSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

func (m menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
}

func (m menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	//
	// This call is the same as calling g_icon_serialize() and using the result
	// as the value to g_menu_item_set_attribute_value() for
	// G_MENU_ATTRIBUTE_ICON.
	//
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu. Don't use it on menu
	// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
	//
	// If @icon is nil then the icon is unset.
	SetIcon(icon Icon)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

// menuItem implements the MenuItem interface.
type menuItem struct {
	*externglib.Object
}

var _ MenuItem = (*menuItem)(nil)

// WrapMenuItem wraps a GObject to a type that implements
// interface MenuItem. It is primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{obj}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem creates a new Item.
//
// If @label is non-nil it is used to set the "label" attribute of the new item.
//
// If @detailed_action is non-nil it is used to set the "action" and possibly
// the "target" attribute of the new item. See g_menu_item_set_detailed_action()
// for more information.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret *C.GMenuItem // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

// NewMenuItemFromModel creates a Item as an exact copy of an existing menu item
// in a Model.
//
// @item_index must be valid (ie: be sure to call g_menu_model_get_n_items()
// first).
func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = C.gint(itemIndex)

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

// NewMenuItemSection creates a new Item representing a section.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
//
// The effect of having one menu appear as a section of another is exactly as it
// sounds: the items from @section become a direct part of the menu that
// @menu_item is added to.
//
// Visual separation is typically displayed between two non-empty sections. If
// @label is non-nil then it will be encorporated into this visual indication.
// This allows for labeled subsections of a menu.
//
// As a simple example, consider a typical "Edit" menu from a simple program. It
// probably contains an "Undo" and "Redo" item, followed by a separator,
// followed by "Cut", "Copy" and "Paste".
//
// This would be accomplished by creating three #GMenu instances. The first
// would be populated with the "Undo" and "Redo" items, and the second with the
// "Cut", "Copy" and "Paste" items. The first and second menus would then be
// added as submenus of the third. In XML format, this would look something like
// the following:
//
//    <menu id='edit-menu'>
//      <section>
//        <item label='Undo'/>
//        <item label='Redo'/>
//      </section>
//      <section>
//        <item label='Cut'/>
//        <item label='Copy'/>
//        <item label='Paste'/>
//      </section>
//    </menu>
//
// The following example is exactly equivalent. It is more illustrative of the
// exact relationship between the menus and items (keeping in mind that the
// 'link' element defines a new menu that is linked to the containing one). The
// style of the second example is more verbose and difficult to read (and
// therefore not recommended except for the purpose of understanding what is
// really going on).
//
//    <menu id='edit-menu'>
//      <item>
//        <link name='section'>
//          <item label='Undo'/>
//          <item label='Redo'/>
//        </link>
//      </item>
//      <item>
//        <link name='section'>
//          <item label='Cut'/>
//          <item label='Copy'/>
//          <item label='Paste'/>
//        </link>
//      </item>
//    </menu>
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

// NewMenuItemSubmenu creates a new Item representing a submenu.
//
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out
	var _cret *C.GMenuItem  // in

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuItem)

	return _menuItem
}

func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType))

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.g_variant_unref((*C.GVariant)(unsafe.Pointer(v)))
	})

	return _variant
}

func (m menuItem) Link(link string) MenuModel {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(MenuModel)

	return _menuModel
}

func (m menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

func (m menuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

func (m menuItem) SetIcon(icon Icon) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

func (m menuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_label(_arg0, _arg1)
}

func (m menuItem) SetLink(link string, model MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

func (m menuItem) SetSection(section MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

func (m menuItem) SetSubmenu(submenu MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Icon)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	//
	// Deprecated: since version 2.42.
	SetUrgent(urgent bool)
}

// notification implements the Notification interface.
type notification struct {
	*externglib.Object
}

var _ Notification = (*notification)(nil)

// WrapNotification wraps a GObject to a type that implements
// interface Notification. It is primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return notification{obj}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

// NewNotification creates a new #GNotification with @title as its title.
//
// After populating @notification with more details, it can be sent to the
// desktop shell with g_application_send_notification(). Changing any properties
// after this call will not have any effect until resending @notification.
func NewNotification(title string) Notification {
	var _arg1 *C.gchar         // out
	var _cret *C.GNotification // in

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_notification_new(_arg1)

	var _notification Notification // out

	_notification = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Notification)

	return _notification
}

func (n notification) AddButton(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

func (n notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(target))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

func (n notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_body(_arg0, _arg1)
}

func (n notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

func (n notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(target))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

func (n notification) SetIcon(icon Icon) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

func (n notification) SetPriority(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(_arg0, _arg1)
}

func (n notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

func (n notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// PropertyAction is a way to get a #GAction with a state value reflecting and
// controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector

	// AsAction casts the class to the Action interface.
	AsAction() Action

	// Activate activates the action.
	//
	// @parameter must be the correct type of parameter for the action (ie: the
	// parameter type given at construction time). If the parameter type was nil
	// then @parameter must also be nil.
	//
	// If the @parameter GVariant is floating, it is consumed.
	//
	// This method is inherited from Action
	Activate(parameter *glib.Variant)
	// ChangeState: request for the state of @action to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_get_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_get_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	//
	// This method is inherited from Action
	ChangeState(value *glib.Variant)
	// GetEnabled checks if @action is currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This method is inherited from Action
	GetEnabled() bool
	// GetName queries the name of @action.
	//
	// This method is inherited from Action
	GetName() string
	// GetParameterType queries the type of the parameter that must be given
	// when activating @action.
	//
	// When activating the action using g_action_activate(), the #GVariant given
	// to that function must be of the type returned by this function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// This method is inherited from Action
	GetParameterType() *glib.VariantType
	// GetState queries the current state of @action.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_get_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from Action
	GetState() *glib.Variant
	// GetStateHint requests a hint about the valid range of values for the
	// state of @action.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from Action
	GetStateHint() *glib.Variant
	// GetStateType queries the type of the state of @action.
	//
	// If the action is stateful (e.g. created with
	// g_simple_action_new_stateful()) then this function returns the Type of
	// the state. This is the type of the initial value given as the state. All
	// calls to g_action_change_state() must give a #GVariant of this type and
	// g_action_get_state() will return a #GVariant of the same type.
	//
	// If the action is not stateful (e.g. created with g_simple_action_new())
	// then this function will return nil. In that case, g_action_get_state()
	// will return nil and you must not call g_action_change_state().
	//
	// This method is inherited from Action
	GetStateType() *glib.VariantType
}

// propertyAction implements the PropertyAction interface.
type propertyAction struct {
	*externglib.Object
}

var _ PropertyAction = (*propertyAction)(nil)

// WrapPropertyAction wraps a GObject to a type that implements
// interface PropertyAction. It is primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return propertyAction{obj}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

// NewPropertyAction creates a #GAction corresponding to the value of property
// @property_name on @object.
//
// The property must be existent and readable and writable (and not
// construct-only).
//
// This function takes a reference on @object and doesn't release it until the
// action is destroyed.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var _arg1 *C.gchar           // out
	var _arg2 C.gpointer         // out
	var _arg3 *C.gchar           // out
	var _cret *C.GPropertyAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gpointer)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction PropertyAction // out

	_propertyAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PropertyAction)

	return _propertyAction
}

func (p propertyAction) AsAction() Action {
	return WrapAction(gextras.InternObject(p))
}

func (a propertyAction) Activate(parameter *glib.Variant) {
	WrapAction(gextras.InternObject(a)).Activate(parameter)
}

func (a propertyAction) ChangeState(value *glib.Variant) {
	WrapAction(gextras.InternObject(a)).ChangeState(value)
}

func (a propertyAction) GetEnabled() bool {
	return WrapAction(gextras.InternObject(a)).GetEnabled()
}

func (a propertyAction) GetName() string {
	return WrapAction(gextras.InternObject(a)).GetName()
}

func (a propertyAction) GetParameterType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).GetParameterType()
}

func (a propertyAction) GetState() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).GetState()
}

func (a propertyAction) GetStateHint() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).GetStateHint()
}

func (a propertyAction) GetStateType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).GetStateType()
}

// SimpleAction is the obvious simple implementation of the #GAction interface.
// This is the easiest way to create an action for purposes of adding it to a
// ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector

	// AsAction casts the class to the Action interface.
	AsAction() Action

	// Activate activates the action.
	//
	// @parameter must be the correct type of parameter for the action (ie: the
	// parameter type given at construction time). If the parameter type was nil
	// then @parameter must also be nil.
	//
	// If the @parameter GVariant is floating, it is consumed.
	//
	// This method is inherited from Action
	Activate(parameter *glib.Variant)
	// ChangeState: request for the state of @action to be changed to @value.
	//
	// The action must be stateful and @value must be of the correct type. See
	// g_action_get_state_type().
	//
	// This call merely requests a change. The action may refuse to change its
	// state or may change its state to something other than @value. See
	// g_action_get_state_hint().
	//
	// If the @value GVariant is floating, it is consumed.
	//
	// This method is inherited from Action
	ChangeState(value *glib.Variant)
	// GetEnabled checks if @action is currently enabled.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This method is inherited from Action
	GetEnabled() bool
	// GetName queries the name of @action.
	//
	// This method is inherited from Action
	GetName() string
	// GetParameterType queries the type of the parameter that must be given
	// when activating @action.
	//
	// When activating the action using g_action_activate(), the #GVariant given
	// to that function must be of the type returned by this function.
	//
	// In the case that this function returns nil, you must not give any
	// #GVariant, but nil instead.
	//
	// This method is inherited from Action
	GetParameterType() *glib.VariantType
	// GetState queries the current state of @action.
	//
	// If the action is not stateful then nil will be returned. If the action is
	// stateful then the type of the return value is the type given by
	// g_action_get_state_type().
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from Action
	GetState() *glib.Variant
	// GetStateHint requests a hint about the valid range of values for the
	// state of @action.
	//
	// If nil is returned it either means that the action is not stateful or
	// that there is no hint about the valid range of values for the state of
	// the action.
	//
	// If a #GVariant array is returned then each item in the array is a
	// possible value for the state. If a #GVariant pair (ie: two-tuple) is
	// returned then the tuple specifies the inclusive lower and upper bound of
	// valid values for the state.
	//
	// In any case, the information is merely a hint. It may be possible to have
	// a state value outside of the hinted range and setting a value within the
	// range may fail.
	//
	// The return value (if non-nil) should be freed with g_variant_unref() when
	// it is no longer required.
	//
	// This method is inherited from Action
	GetStateHint() *glib.Variant
	// GetStateType queries the type of the state of @action.
	//
	// If the action is stateful (e.g. created with
	// g_simple_action_new_stateful()) then this function returns the Type of
	// the state. This is the type of the initial value given as the state. All
	// calls to g_action_change_state() must give a #GVariant of this type and
	// g_action_get_state() will return a #GVariant of the same type.
	//
	// If the action is not stateful (e.g. created with g_simple_action_new())
	// then this function will return nil. In that case, g_action_get_state()
	// will return nil and you must not call g_action_change_state().
	//
	// This method is inherited from Action
	GetStateType() *glib.VariantType

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction interface.
type simpleAction struct {
	*externglib.Object
}

var _ SimpleAction = (*simpleAction)(nil)

// WrapSimpleAction wraps a GObject to a type that implements
// interface SimpleAction. It is primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return simpleAction{obj}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

// NewSimpleAction creates a new action.
//
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType))

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleAction)

	return _simpleAction
}

// NewSimpleActionStateful creates a new stateful action.
//
// All future state values must have the same Type as the initial @state.
//
// If the @state #GVariant is floating, it is consumed.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariantType  // out
	var _arg3 *C.GVariant      // out
	var _cret *C.GSimpleAction // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType))
	_arg3 = (*C.GVariant)(unsafe.Pointer(state))

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleAction)

	return _simpleAction
}

func (s simpleAction) AsAction() Action {
	return WrapAction(gextras.InternObject(s))
}

func (a simpleAction) Activate(parameter *glib.Variant) {
	WrapAction(gextras.InternObject(a)).Activate(parameter)
}

func (a simpleAction) ChangeState(value *glib.Variant) {
	WrapAction(gextras.InternObject(a)).ChangeState(value)
}

func (a simpleAction) GetEnabled() bool {
	return WrapAction(gextras.InternObject(a)).GetEnabled()
}

func (a simpleAction) GetName() string {
	return WrapAction(gextras.InternObject(a)).GetName()
}

func (a simpleAction) GetParameterType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).GetParameterType()
}

func (a simpleAction) GetState() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).GetState()
}

func (a simpleAction) GetStateHint() *glib.Variant {
	return WrapAction(gextras.InternObject(a)).GetStateHint()
}

func (a simpleAction) GetStateType() *glib.VariantType {
	return WrapAction(gextras.InternObject(a)).GetStateType()
}

func (s simpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

func (s simpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value))

	C.g_simple_action_set_state(_arg0, _arg1)
}

func (s simpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

// SimpleIOStream creates a OStream from an arbitrary Stream and Stream. This
// allows any pair of input and output streams to be used with OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	gextras.Objector

	// AsIOStream casts the class to the IOStream interface.
	AsIOStream() IOStream

	// ClearPending clears the pending flag on @stream.
	//
	// This method is inherited from IOStream
	ClearPending()
	// Close closes the stream, releasing resources related to it. This will
	// also close the individual input and output streams, if they are not
	// already closed.
	//
	// Once the stream is closed, all other operations will return
	// G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an
	// error.
	//
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	//
	// Streams will be automatically closed when the last reference is dropped,
	// but you might want to call this function to make sure resources are
	// released as early as possible.
	//
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	//
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to close
	// will still return G_IO_ERROR_CLOSED for all operations. Still, it is
	// important to check and report the error to the user, otherwise there
	// might be a loss of data as all data might not be written.
	//
	// If @cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	//
	// The default implementation of this method just calls close on the
	// individual input/output streams.
	//
	// This method is inherited from IOStream
	Close(cancellable Cancellable) error
	// CloseAsync requests an asynchronous close of the stream, releasing
	// resources related to it. When the operation is finished @callback will be
	// called. You can then call g_io_stream_close_finish() to get the result of
	// the operation.
	//
	// For behaviour details see g_io_stream_close().
	//
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one you must override all.
	//
	// This method is inherited from IOStream
	CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
	// CloseFinish closes a stream.
	//
	// This method is inherited from IOStream
	CloseFinish(result AsyncResult) error
	// GetInputStream gets the input stream for this object. This is used for
	// reading.
	//
	// This method is inherited from IOStream
	GetInputStream() InputStream
	// GetOutputStream gets the output stream for this object. This is used for
	// writing.
	//
	// This method is inherited from IOStream
	GetOutputStream() OutputStream
	// HasPending checks if a stream has pending actions.
	//
	// This method is inherited from IOStream
	HasPending() bool
	// IsClosed checks if a stream is closed.
	//
	// This method is inherited from IOStream
	IsClosed() bool
	// SetPending sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return false and set @error.
	//
	// This method is inherited from IOStream
	SetPending() error
	// SpliceAsync: asynchronously splice the output stream of @stream1 to the
	// input stream of @stream2, and splice the output stream of @stream2 to the
	// input stream of @stream1.
	//
	// When the operation is finished @callback will be called. You can then
	// call g_io_stream_splice_finish() to get the result of the operation.
	//
	// This method is inherited from IOStream
	SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)
}

// simpleIOStream implements the SimpleIOStream interface.
type simpleIOStream struct {
	*externglib.Object
}

var _ SimpleIOStream = (*simpleIOStream)(nil)

// WrapSimpleIOStream wraps a GObject to a type that implements
// interface SimpleIOStream. It is primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return simpleIOStream{obj}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream creates a new IOStream wrapping @input_stream and
// @output_stream. See also OStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out
	var _cret *C.GIOStream     // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream SimpleIOStream // out

	_simpleIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimpleIOStream)

	return _simpleIOStream
}

func (s simpleIOStream) AsIOStream() IOStream {
	return WrapIOStream(gextras.InternObject(s))
}

func (s simpleIOStream) ClearPending() {
	WrapIOStream(gextras.InternObject(s)).ClearPending()
}

func (s simpleIOStream) Close(cancellable Cancellable) error {
	return WrapIOStream(gextras.InternObject(s)).Close(cancellable)
}

func (s simpleIOStream) CloseAsync(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapIOStream(gextras.InternObject(s)).CloseAsync(ioPriority, cancellable, callback)
}

func (s simpleIOStream) CloseFinish(result AsyncResult) error {
	return WrapIOStream(gextras.InternObject(s)).CloseFinish(result)
}

func (s simpleIOStream) GetInputStream() InputStream {
	return WrapIOStream(gextras.InternObject(s)).GetInputStream()
}

func (s simpleIOStream) GetOutputStream() OutputStream {
	return WrapIOStream(gextras.InternObject(s)).GetOutputStream()
}

func (s simpleIOStream) HasPending() bool {
	return WrapIOStream(gextras.InternObject(s)).HasPending()
}

func (s simpleIOStream) IsClosed() bool {
	return WrapIOStream(gextras.InternObject(s)).IsClosed()
}

func (s simpleIOStream) SetPending() error {
	return WrapIOStream(gextras.InternObject(s)).SetPending()
}

func (s simpleIOStream) SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	WrapIOStream(gextras.InternObject(s)).SpliceAsync(stream2, flags, ioPriority, cancellable, callback)
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	gextras.Objector

	// AsPermission casts the class to the Permission interface.
	AsPermission() Permission

	// Acquire attempts to acquire the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. A simple example is that a
	// dialog may appear asking the user to enter their password.
	//
	// You should check with g_permission_get_can_acquire() before calling this
	// function.
	//
	// If the permission is acquired then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_acquire_async() for the
	// non-blocking version.
	//
	// This method is inherited from Permission
	Acquire(cancellable Cancellable) error
	// AcquireAsync attempts to acquire the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_acquire().
	//
	// This method is inherited from Permission
	AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcquireFinish collects the result of attempting to acquire the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	//
	// This method is inherited from Permission
	AcquireFinish(result AsyncResult) error
	// GetAllowed gets the value of the 'allowed' property. This property is
	// true if the caller currently has permission to perform the action that
	// @permission represents the permission to perform.
	//
	// This method is inherited from Permission
	GetAllowed() bool
	// GetCanAcquire gets the value of the 'can-acquire' property. This property
	// is true if it is generally possible to acquire the permission by calling
	// g_permission_acquire().
	//
	// This method is inherited from Permission
	GetCanAcquire() bool
	// GetCanRelease gets the value of the 'can-release' property. This property
	// is true if it is generally possible to release the permission by calling
	// g_permission_release().
	//
	// This method is inherited from Permission
	GetCanRelease() bool
	// ImplUpdate: this function is called by the #GPermission implementation to
	// update the properties of the permission. You should never call this
	// function except from a #GPermission implementation.
	//
	// GObject notify signals are generated, as appropriate.
	//
	// This method is inherited from Permission
	ImplUpdate(allowed bool, canAcquire bool, canRelease bool)
	// Release attempts to release the permission represented by @permission.
	//
	// The precise method by which this happens depends on the permission and
	// the underlying authentication mechanism. In most cases the permission
	// will be dropped immediately without further action.
	//
	// You should check with g_permission_get_can_release() before calling this
	// function.
	//
	// If the permission is released then true is returned. Otherwise, false is
	// returned and @error is set appropriately.
	//
	// This call is blocking, likely for a very long time (in the case that user
	// interaction is required). See g_permission_release_async() for the
	// non-blocking version.
	//
	// This method is inherited from Permission
	Release(cancellable Cancellable) error
	// ReleaseAsync attempts to release the permission represented by
	// @permission.
	//
	// This is the first half of the asynchronous version of
	// g_permission_release().
	//
	// This method is inherited from Permission
	ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// ReleaseFinish collects the result of attempting to release the permission
	// represented by @permission.
	//
	// This is the second half of the asynchronous version of
	// g_permission_release().
	//
	// This method is inherited from Permission
	ReleaseFinish(result AsyncResult) error
}

// simplePermission implements the SimplePermission interface.
type simplePermission struct {
	*externglib.Object
}

var _ SimplePermission = (*simplePermission)(nil)

// WrapSimplePermission wraps a GObject to a type that implements
// interface SimplePermission. It is primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return simplePermission{obj}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

// NewSimplePermission creates a new #GPermission instance that represents an
// action that is either always or never allowed.
func NewSimplePermission(allowed bool) SimplePermission {
	var _arg1 C.gboolean     // out
	var _cret *C.GPermission // in

	if allowed {
		_arg1 = C.TRUE
	}

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission SimplePermission // out

	_simplePermission = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SimplePermission)

	return _simplePermission
}

func (s simplePermission) AsPermission() Permission {
	return WrapPermission(gextras.InternObject(s))
}

func (p simplePermission) Acquire(cancellable Cancellable) error {
	return WrapPermission(gextras.InternObject(p)).Acquire(cancellable)
}

func (p simplePermission) AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapPermission(gextras.InternObject(p)).AcquireAsync(cancellable, callback)
}

func (p simplePermission) AcquireFinish(result AsyncResult) error {
	return WrapPermission(gextras.InternObject(p)).AcquireFinish(result)
}

func (p simplePermission) GetAllowed() bool {
	return WrapPermission(gextras.InternObject(p)).GetAllowed()
}

func (p simplePermission) GetCanAcquire() bool {
	return WrapPermission(gextras.InternObject(p)).GetCanAcquire()
}

func (p simplePermission) GetCanRelease() bool {
	return WrapPermission(gextras.InternObject(p)).GetCanRelease()
}

func (p simplePermission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	WrapPermission(gextras.InternObject(p)).ImplUpdate(allowed, canAcquire, canRelease)
}

func (p simplePermission) Release(cancellable Cancellable) error {
	return WrapPermission(gextras.InternObject(p)).Release(cancellable)
}

func (p simplePermission) ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	WrapPermission(gextras.InternObject(p)).ReleaseAsync(cancellable, callback)
}

func (p simplePermission) ReleaseFinish(result AsyncResult) error {
	return WrapPermission(gextras.InternObject(p)).ReleaseFinish(result)
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector

	// AsInitable casts the class to the Initable interface.
	AsInitable() Initable

	// Init initializes the object implementing the interface.
	//
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	//
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	//
	// Implementations may also support cancellation. If @cancellable is not
	// nil, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// G_IO_ERROR_CANCELLED will be returned. If @cancellable is not nil and the
	// object doesn't support cancellable initialization the error
	// G_IO_ERROR_NOT_SUPPORTED will be returned.
	//
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [introduction][ginitable] for more details.
	//
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself
	// as supporting this. Generally, a class’ implementation of init() can
	// assume (and assert) that it will only be called once. Previously, this
	// documentation recommended all #GInitable implementations should be
	// idempotent; that recommendation was relaxed in GLib 2.54.
	//
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	//
	// One reason why a class might need to support idempotent initialization is
	// if it is designed to be used via the singleton pattern, with a
	// Class.constructor that sometimes returns an existing instance. In this
	// pattern, a caller would expect to be able to call g_initable_init() on
	// the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	//
	// This method is inherited from Initable
	Init(cancellable Cancellable) error

	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error)
	// CommunicateUTF8Async asynchronous version of
	// g_subprocess_communicate_utf8(). Complete invocation with
	// g_subprocess_communicate_utf8_finish().
	CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
	// otherwise nil will be returned.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and
	// not G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// otherwise nil will be returned.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) error
	// WaitAsync: wait for the subprocess to terminate.
	//
	// This is the asynchronous version of g_subprocess_wait().
	WaitAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) error
	// WaitCheckAsync combines g_subprocess_wait_async() with
	// g_spawn_check_exit_status().
	//
	// This is the asynchronous version of g_subprocess_wait_check().
	WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResult) error
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResult) error
}

// subprocess implements the Subprocess interface.
type subprocess struct {
	*externglib.Object
}

var _ Subprocess = (*subprocess)(nil)

// WrapSubprocess wraps a GObject to a type that implements
// interface Subprocess. It is primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return subprocess{obj}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

// NewSubprocessV: create a new process with the given flags and argument list.
//
// The argument list is expected to be nil-terminated.
func NewSubprocessV(argv []string, flags SubprocessFlags) (Subprocess, error) {
	var _arg1 **C.gchar
	var _arg2 C.GSubprocessFlags // out
	var _cret *C.GSubprocess     // in
	var _cerr *C.GError          // in

	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocess) AsInitable() Initable {
	return WrapInitable(gextras.InternObject(s))
}

func (i subprocess) Init(cancellable Cancellable) error {
	return WrapInitable(gextras.InternObject(i)).Init(cancellable)
}

func (s subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out
	var _arg3 *C.char         // in
	var _arg4 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_stderrBuf = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) CommunicateUTF8Async(stdinBuf string, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.char               // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_subprocess_communicate_utf8_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _arg3 *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_stderrBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

func (s subprocess) ForceExit() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_force_exit(_arg0)
}

func (s subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) Status() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) StderrPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) StdinPipe() OutputStream {
	var _arg0 *C.GSubprocess   // out
	var _cret *C.GOutputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(OutputStream)

	return _outputStream
}

func (s subprocess) StdoutPipe() InputStream {
	var _arg0 *C.GSubprocess  // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(InputStream)

	return _inputStream
}

func (s subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out
	var _cret C.gint         // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s subprocess) SendSignal(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

func (s subprocess) Wait(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_async(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocess) WaitCheck(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitCheckAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GSubprocess        // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg3 = C.gpointer(box.Assign(callback))

	C.g_subprocess_wait_check_async(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocess) WaitCheckFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s subprocess) WaitFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// Close closes all the file descriptors previously passed to the object
	// with g_subprocess_launcher_take_fd(),
	// g_subprocess_launcher_take_stderr_fd(), etc.
	//
	// After calling this method, any subsequent calls to
	// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
	// return G_IO_ERROR_CLOSED. This method is idempotent if called more than
	// once.
	//
	// This function is called automatically when the Launcher is disposed, but
	// is provided separately so that garbage collected language bindings can
	// call it earlier to guarantee when FDs are closed.
	Close()
	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process’ environment. As of GLib 2.54, the parent process’
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) (Subprocess, error)
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes ownership of the @source_fd; it will be closed
	// in the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom `pipe()` or
	// `socketpair()` before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// `--passphrase-fd` providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

// subprocessLauncher implements the SubprocessLauncher interface.
type subprocessLauncher struct {
	*externglib.Object
}

var _ SubprocessLauncher = (*subprocessLauncher)(nil)

// WrapSubprocessLauncher wraps a GObject to a type that implements
// interface SubprocessLauncher. It is primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return subprocessLauncher{obj}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher creates a new Launcher.
//
// The launcher is created with the default options. A copy of the environment
// of the calling process is made at the time of this call and will be used as
// the environment that the process is launched in.
func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var _arg1 C.GSubprocessFlags     // out
	var _cret *C.GSubprocessLauncher // in

	_arg1 = C.GSubprocessFlags(flags)

	_cret = C.g_subprocess_launcher_new(_arg1)

	var _subprocessLauncher SubprocessLauncher // out

	_subprocessLauncher = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SubprocessLauncher)

	return _subprocessLauncher
}

func (s subprocessLauncher) Close() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

func (s subprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (s subprocessLauncher) SetCwd(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

func (s subprocessLauncher) SetEnviron(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(env)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(env))
		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

func (s subprocessLauncher) SetFlags(flags SubprocessFlags) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.GSubprocessFlags     // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.GSubprocessFlags(flags)

	C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}

func (s subprocessLauncher) SetStderrFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdinFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) SetStdoutFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

func (s subprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

func (s subprocessLauncher) Spawnv(argv []string) (Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar
	var _cret *C.GSubprocess // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(argv)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

func (s subprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(sourceFd)
	_arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

func (s subprocessLauncher) TakeStderrFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdinFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

func (s subprocessLauncher) TakeStdoutFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

func (s subprocessLauncher) Unsetenv(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// TestDBus: helper class for testing code which uses D-Bus without touching the
// user's session bus.
//
// Note that DBus modifies the user’s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

// testDBus implements the TestDBus interface.
type testDBus struct {
	*externglib.Object
}

var _ TestDBus = (*testDBus)(nil)

// WrapTestDBus wraps a GObject to a type that implements
// interface TestDBus. It is primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return testDBus{obj}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

// NewTestDBus: create a new DBus object.
func NewTestDBus(flags TestDBusFlags) TestDBus {
	var _arg1 C.GTestDBusFlags // out
	var _cret *C.GTestDBus     // in

	_arg1 = C.GTestDBusFlags(flags)

	_cret = C.g_test_dbus_new(_arg1)

	var _testDBus TestDBus // out

	_testDBus = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TestDBus)

	return _testDBus
}

func (s testDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

func (s testDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_down(_arg0)
}

func (s testDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s testDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus     // out
	var _cret C.GTestDBusFlags // in

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

func (s testDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_stop(_arg0)
}

func (s testDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_up(_arg0)
}
