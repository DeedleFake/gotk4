// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
//
// extern void callbackDelete(gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_cancellable_get_type()), F: marshalCancellable},
	})
}

//export callbackDelete
func callbackDelete(ptr C.gpointer) {
	box.Delete(box.Callback, uintptr(ptr))
}

// Cancellable: GCancellable is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and asynchronous
// operations.
type Cancellable interface {
	gextras.Objector

	// Cancel: will set @cancellable to cancelled, and will emit the
	// #GCancellable::cancelled signal. (However, see the warning about race
	// conditions in the documentation for that signal if you are planning to
	// connect to it.)
	//
	// This function is thread-safe. In other words, you can safely call it from
	// a thread other than the one running the operation that was passed the
	// @cancellable.
	//
	// If @cancellable is nil, this function returns immediately for
	// convenience.
	//
	// The convention within GIO is that cancelling an asynchronous operation
	// causes it to complete asynchronously. That is, if you cancel the
	// operation from the same thread in which it is running, then the
	// operation's ReadyCallback will not be invoked until the application
	// returns to the main loop.
	Cancel()
	// Connect: convenience function to connect to the #GCancellable::cancelled
	// signal. Also handles the race condition that may happen if the
	// cancellable is cancelled right before connecting.
	//
	// @callback is called at most once, either directly at the time of the
	// connect if @cancellable is already cancelled, or when @cancellable is
	// cancelled in some thread.
	//
	// @data_destroy_func will be called when the handler is disconnected, or
	// immediately if the cancellable is already cancelled.
	//
	// See #GCancellable::cancelled for details on how to use this.
	//
	// Since GLib 2.40, the lock protecting @cancellable is not held when
	// @callback is invoked. This lifts a restriction in place for earlier GLib
	// versions which now makes it easier to write cleanup code that
	// unconditionally invokes e.g. g_cancellable_cancel().
	Connect(callback gobject.Callback) uint32
	// Disconnect disconnects a handler from a cancellable instance similar to
	// g_signal_handler_disconnect(). Additionally, in the event that a signal
	// handler is currently running, this call will block until the handler has
	// finished. Calling this function from a #GCancellable::cancelled signal
	// handler will therefore result in a deadlock.
	//
	// This avoids a race condition where a thread cancels at the same time as
	// the cancellable operation is finished and the signal handler is removed.
	// See #GCancellable::cancelled for details on how to use this.
	//
	// If @cancellable is nil or @handler_id is `0` this function does nothing.
	Disconnect(handlerID uint32)
	// Fd gets the file descriptor for a cancellable job. This can be used to
	// implement cancellable operations on Unix systems. The returned fd will
	// turn readable when @cancellable is cancelled.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	//
	// After a successful return from this function, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// returned file descriptor.
	//
	// See also g_cancellable_make_pollfd().
	Fd() int
	// IsCancelled checks if a cancellable job has been cancelled.
	IsCancelled() bool
	// MakePollfd creates a FD corresponding to @cancellable; this can be passed
	// to g_poll() and used to poll for cancellation. This is useful both for
	// unix systems without a native poll and for portability to windows.
	//
	// When this function returns true, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// @pollfd. After a false return, do not call g_cancellable_release_fd().
	//
	// If this function returns false, either no @cancellable was given or
	// resource limits prevent this function from allocating the necessary
	// structures for polling. (On Linux, you will likely have reached the
	// maximum number of file descriptors.) The suggested way to handle these
	// cases is to ignore the @cancellable.
	//
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done with
	// g_cancellable_reset().
	MakePollfd(pollfd *glib.PollFD) bool
	// PopCurrent pops @cancellable off the cancellable stack (verifying that
	// @cancellable is on the top of the stack).
	PopCurrent()
	// PushCurrent pushes @cancellable onto the cancellable stack. The current
	// cancellable can then be received using g_cancellable_get_current().
	//
	// This is useful when implementing cancellable operations in code that does
	// not allow you to pass down the cancellable object.
	//
	// This is typically called automatically by e.g. #GFile operations, so you
	// rarely have to call this yourself.
	PushCurrent()
	// ReleaseFd releases a resources previously allocated by
	// g_cancellable_get_fd() or g_cancellable_make_pollfd().
	//
	// For compatibility reasons with older releases, calling this function is
	// not strictly required, the resources will be automatically freed when the
	// @cancellable is finalized. However, the @cancellable will block scarce
	// file descriptors until it is finalized if this function is not called.
	// This can cause the application to run out of file descriptors when many
	// #GCancellables are used at the same time.
	ReleaseFd()
	// Reset resets @cancellable to its uncancelled state.
	//
	// If cancellable is currently in use by any cancellable operation then the
	// behavior of this function is undefined.
	//
	// Note that it is generally not a good idea to reuse an existing
	// cancellable for more operations after it has been cancelled once, as this
	// function might tempt you to do. The recommended practice is to drop the
	// reference to a cancellable after cancelling it, and let it die with the
	// outstanding async operations. You should create a fresh cancellable for
	// further async operations.
	Reset()
	// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
	// notify that the operation was cancelled.
	SetErrorIfCancelled() error
	// NewSource creates a source that triggers if @cancellable is cancelled and
	// calls its callback of type SourceFunc. This is primarily useful for
	// attaching to another (non-cancellable) source with
	// g_source_add_child_source() to add cancellability to it.
	//
	// For convenience, you can call this with a nil #GCancellable, in which
	// case the source will never trigger.
	//
	// The new #GSource will hold a reference to the #GCancellable.
	NewSource() *glib.Source
}

// cancellable implements the Cancellable interface.
type cancellable struct {
	gextras.Objector
}

var _ Cancellable = (*cancellable)(nil)

// WrapCancellable wraps a GObject to the right type. It is
// primarily used internally.
func WrapCancellable(obj *externglib.Object) Cancellable {
	return Cancellable{
		Objector: obj,
	}
}

func marshalCancellable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCancellable(obj), nil
}

// NewCancellable constructs a class Cancellable.
func NewCancellable() Cancellable {
	ret := C.g_cancellable_new()

	var ret0 Cancellable

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Cancellable)

	return ret0
}

// Cancel: will set @cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about race
// conditions in the documentation for that signal if you are planning to
// connect to it.)
//
// This function is thread-safe. In other words, you can safely call it from
// a thread other than the one running the operation that was passed the
// @cancellable.
//
// If @cancellable is nil, this function returns immediately for
// convenience.
//
// The convention within GIO is that cancelling an asynchronous operation
// causes it to complete asynchronously. That is, if you cancel the
// operation from the same thread in which it is running, then the
// operation's ReadyCallback will not be invoked until the application
// returns to the main loop.
func (c cancellable) Cancel() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	C.g_cancellable_cancel(arg0)
}

// Connect: convenience function to connect to the #GCancellable::cancelled
// signal. Also handles the race condition that may happen if the
// cancellable is cancelled right before connecting.
//
// @callback is called at most once, either directly at the time of the
// connect if @cancellable is already cancelled, or when @cancellable is
// cancelled in some thread.
//
// @data_destroy_func will be called when the handler is disconnected, or
// immediately if the cancellable is already cancelled.
//
// See #GCancellable::cancelled for details on how to use this.
//
// Since GLib 2.40, the lock protecting @cancellable is not held when
// @callback is invoked. This lifts a restriction in place for earlier GLib
// versions which now makes it easier to write cleanup code that
// unconditionally invokes e.g. g_cancellable_cancel().
func (c cancellable) Connect(callback gobject.Callback) uint32 {
	var arg0 *C.GCancellable
	var arg1 C.GCallback
	var arg2 C.gpointer
	var arg3 C.GDestroyNotify

	arg0 = (*C.GCancellable)(c.Native())
	arg1 = (*[0]byte)(C.gotk4_Callback)
	arg2 = C.gpointer(box.Assign(callback))
	arg3 = (*[0]byte)(C.callbackDelete)

	ret := C.g_cancellable_connect(arg0, arg1, arg2, arg3)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// Disconnect disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect(). Additionally, in the event that a signal
// handler is currently running, this call will block until the handler has
// finished. Calling this function from a #GCancellable::cancelled signal
// handler will therefore result in a deadlock.
//
// This avoids a race condition where a thread cancels at the same time as
// the cancellable operation is finished and the signal handler is removed.
// See #GCancellable::cancelled for details on how to use this.
//
// If @cancellable is nil or @handler_id is `0` this function does nothing.
func (c cancellable) Disconnect(handlerID uint32) {
	var arg0 *C.GCancellable
	var arg1 C.gulong

	arg0 = (*C.GCancellable)(c.Native())
	arg1 = C.gulong(handlerID)

	C.g_cancellable_disconnect(arg0, arg1)
}

// Fd gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will
// turn readable when @cancellable is cancelled.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done with
// g_cancellable_reset().
//
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// returned file descriptor.
//
// See also g_cancellable_make_pollfd().
func (c cancellable) Fd() int {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	ret := C.g_cancellable_get_fd(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsCancelled checks if a cancellable job has been cancelled.
func (c cancellable) IsCancelled() bool {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	ret := C.g_cancellable_is_cancelled(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// MakePollfd creates a FD corresponding to @cancellable; this can be passed
// to g_poll() and used to poll for cancellation. This is useful both for
// unix systems without a native poll and for portability to windows.
//
// When this function returns true, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// @pollfd. After a false return, do not call g_cancellable_release_fd().
//
// If this function returns false, either no @cancellable was given or
// resource limits prevent this function from allocating the necessary
// structures for polling. (On Linux, you will likely have reached the
// maximum number of file descriptors.) The suggested way to handle these
// cases is to ignore the @cancellable.
//
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done with
// g_cancellable_reset().
func (c cancellable) MakePollfd(pollfd *glib.PollFD) bool {
	var arg0 *C.GCancellable
	var arg1 *C.GPollFD

	arg0 = (*C.GCancellable)(c.Native())
	arg1 = (*C.GPollFD)(pollfd.Native())

	ret := C.g_cancellable_make_pollfd(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// PopCurrent pops @cancellable off the cancellable stack (verifying that
// @cancellable is on the top of the stack).
func (c cancellable) PopCurrent() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	C.g_cancellable_pop_current(arg0)
}

// PushCurrent pushes @cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
//
// This is useful when implementing cancellable operations in code that does
// not allow you to pass down the cancellable object.
//
// This is typically called automatically by e.g. #GFile operations, so you
// rarely have to call this yourself.
func (c cancellable) PushCurrent() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	C.g_cancellable_push_current(arg0)
}

// ReleaseFd releases a resources previously allocated by
// g_cancellable_get_fd() or g_cancellable_make_pollfd().
//
// For compatibility reasons with older releases, calling this function is
// not strictly required, the resources will be automatically freed when the
// @cancellable is finalized. However, the @cancellable will block scarce
// file descriptors until it is finalized if this function is not called.
// This can cause the application to run out of file descriptors when many
// #GCancellables are used at the same time.
func (c cancellable) ReleaseFd() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	C.g_cancellable_release_fd(arg0)
}

// Reset resets @cancellable to its uncancelled state.
//
// If cancellable is currently in use by any cancellable operation then the
// behavior of this function is undefined.
//
// Note that it is generally not a good idea to reuse an existing
// cancellable for more operations after it has been cancelled once, as this
// function might tempt you to do. The recommended practice is to drop the
// reference to a cancellable after cancelling it, and let it die with the
// outstanding async operations. You should create a fresh cancellable for
// further async operations.
func (c cancellable) Reset() {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	C.g_cancellable_reset(arg0)
}

// SetErrorIfCancelled: if the @cancellable is cancelled, sets the error to
// notify that the operation was cancelled.
func (c cancellable) SetErrorIfCancelled() error {
	var arg0 *C.GCancellable
	var gError *C.GError

	arg0 = (*C.GCancellable)(c.Native())

	ret := C.g_cancellable_set_error_if_cancelled(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// NewSource creates a source that triggers if @cancellable is cancelled and
// calls its callback of type SourceFunc. This is primarily useful for
// attaching to another (non-cancellable) source with
// g_source_add_child_source() to add cancellability to it.
//
// For convenience, you can call this with a nil #GCancellable, in which
// case the source will never trigger.
//
// The new #GSource will hold a reference to the #GCancellable.
func (c cancellable) NewSource() *glib.Source {
	var arg0 *C.GCancellable

	arg0 = (*C.GCancellable)(c.Native())

	ret := C.g_cancellable_source_new(arg0)

	var ret0 *glib.Source

	{
		ret0 = glib.WrapSource(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Source) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

type CancellablePrivate struct {
	native C.GCancellablePrivate
}

// WrapCancellablePrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCancellablePrivate(ptr unsafe.Pointer) *CancellablePrivate {
	if ptr == nil {
		return nil
	}

	return (*CancellablePrivate)(ptr)
}

func marshalCancellablePrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCancellablePrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CancellablePrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}
