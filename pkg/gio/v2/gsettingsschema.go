// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_settings_schema_get_type()), F: marshalSettingsSchema},
		{T: externglib.Type(C.g_settings_schema_key_get_type()), F: marshalSettingsSchemaKey},
		{T: externglib.Type(C.g_settings_schema_source_get_type()), F: marshalSettingsSchemaSource},
	})
}

// SettingsSchema: the SchemaSource and Schema APIs provide a mechanism for
// advanced control over the loading of schemas and a mechanism for
// introspecting their content.
//
// Plugin loading systems that wish to provide plugins a way to access settings
// face the problem of how to make the schemas for these settings visible to
// GSettings. Typically, a plugin will want to ship the schema along with itself
// and it won't be installed into the standard system directories for schemas.
//
// SchemaSource provides a mechanism for dealing with this by allowing the
// creation of a new 'schema source' from which schemas can be acquired. This
// schema source can then become part of the metadata associated with the plugin
// and queried whenever the plugin requires access to some settings.
//
// Consider the following example:
//
//    {
//      GSettings *settings;
//      gint some_value;
//
//      settings = plugin_get_settings (self, NULL);
//      some_value = g_settings_get_int (settings, "some-value");
//      ...
//    }
//
// It's also possible that the plugin system expects the schema source files
// (ie: .gschema.xml files) instead of a gschemas.compiled file. In that case,
// the plugin loading system must compile the schemas for itself before
// attempting to create the settings source.
type SettingsSchema C.GSettingsSchema

// WrapSettingsSchema wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchema(ptr unsafe.Pointer) *SettingsSchema {
	return (*SettingsSchema)(ptr)
}

func marshalSettingsSchema(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*SettingsSchema)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsSchema) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// ID: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) ID() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_get_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Key: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) Key(name string) *SettingsSchemaKey {
	var _arg0 *C.GSettingsSchema    // out
	var _arg1 *C.gchar              // out
	var _cret *C.GSettingsSchemaKey // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_get_key(_arg0, _arg1)

	var _settingsSchemaKey *SettingsSchemaKey // out

	_settingsSchemaKey = (*SettingsSchemaKey)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchemaKey, func(v **SettingsSchemaKey) {
		C.free(unsafe.Pointer(v))
	})

	return _settingsSchemaKey
}

// Path: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) Path() string {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// HasKey: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) HasKey(name string) bool {
	var _arg0 *C.GSettingsSchema // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_schema_has_key(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListChildren: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) ListChildren() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_list_children(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ListKeys: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) ListKeys() []string {
	var _arg0 *C.GSettingsSchema // out
	var _cret **C.gchar

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_list_keys(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Ref: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) Ref() *SettingsSchema {
	var _arg0 *C.GSettingsSchema // out
	var _cret *C.GSettingsSchema // in

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_ref(_arg0)

	var _settingsSchema *SettingsSchema // out

	_settingsSchema = (*SettingsSchema)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchema, func(v **SettingsSchema) {
		C.free(unsafe.Pointer(v))
	})

	return _settingsSchema
}

// Unref: decrease the reference count of @schema, possibly freeing it.
func (s *SettingsSchema) Unref() {
	var _arg0 *C.GSettingsSchema // out

	_arg0 = (*C.GSettingsSchema)(unsafe.Pointer(s.Native()))

	C.g_settings_schema_unref(_arg0)
}

// SettingsSchemaKey is an opaque data structure and can only be accessed using
// the following functions.
type SettingsSchemaKey C.GSettingsSchemaKey

// WrapSettingsSchemaKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaKey(ptr unsafe.Pointer) *SettingsSchemaKey {
	return (*SettingsSchemaKey)(ptr)
}

func marshalSettingsSchemaKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*SettingsSchemaKey)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaKey) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// DefaultValue: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) DefaultValue() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_default_value(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Description: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Description() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Name: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Name() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Range: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Range() *glib.Variant {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariant           // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_range(_arg0)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_variant, func(v **glib.Variant) {
		C.free(unsafe.Pointer(v))
	})

	return _variant
}

// Summary: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Summary() string {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_summary(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ValueType: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) ValueType() *glib.VariantType {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GVariantType       // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_get_value_type(_arg0)

	var _variantType *glib.VariantType // out

	_variantType = (*glib.VariantType)(unsafe.Pointer(_cret))

	return _variantType
}

// RangeCheck: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) RangeCheck(value *glib.Variant) bool {
	var _arg0 *C.GSettingsSchemaKey // out
	var _arg1 *C.GVariant           // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	_cret = C.g_settings_schema_key_range_check(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Ref() *SettingsSchemaKey {
	var _arg0 *C.GSettingsSchemaKey // out
	var _cret *C.GSettingsSchemaKey // in

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	_cret = C.g_settings_schema_key_ref(_arg0)

	var _settingsSchemaKey *SettingsSchemaKey // out

	_settingsSchemaKey = (*SettingsSchemaKey)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchemaKey, func(v **SettingsSchemaKey) {
		C.free(unsafe.Pointer(v))
	})

	return _settingsSchemaKey
}

// Unref: decrease the reference count of @key, possibly freeing it.
func (k *SettingsSchemaKey) Unref() {
	var _arg0 *C.GSettingsSchemaKey // out

	_arg0 = (*C.GSettingsSchemaKey)(unsafe.Pointer(k.Native()))

	C.g_settings_schema_key_unref(_arg0)
}

// SettingsSchemaSource: this is an opaque structure type. You may not access it
// directly.
type SettingsSchemaSource C.GSettingsSchemaSource

// WrapSettingsSchemaSource wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSettingsSchemaSource(ptr unsafe.Pointer) *SettingsSchemaSource {
	return (*SettingsSchemaSource)(ptr)
}

func marshalSettingsSchemaSource(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*SettingsSchemaSource)(unsafe.Pointer(b)), nil
}

// NewSettingsSchemaSourceFromDirectory constructs a struct SettingsSchemaSource.
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	var _arg1 *C.gchar                 // out
	var _arg2 *C.GSettingsSchemaSource // out
	var _arg3 C.gboolean               // out
	var _cret *C.GSettingsSchemaSource // in
	var _cerr *C.GError                // in

	_arg1 = (*C.gchar)(C.CString(directory))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GSettingsSchemaSource)(unsafe.Pointer(parent.Native()))
	if trusted {
		_arg3 = C.TRUE
	}

	_cret = C.g_settings_schema_source_new_from_directory(_arg1, _arg2, _arg3, &_cerr)

	var _settingsSchemaSource *SettingsSchemaSource // out
	var _goerr error                                // out

	_settingsSchemaSource = (*SettingsSchemaSource)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchemaSource, func(v **SettingsSchemaSource) {
		C.free(unsafe.Pointer(v))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _settingsSchemaSource, _goerr
}

// Native returns the underlying C source pointer.
func (s *SettingsSchemaSource) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// ListSchemas: decrease the reference count of @source, possibly freeing it.
func (s *SettingsSchemaSource) ListSchemas(recursive bool) (nonRelocatable []string, relocatable []string) {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 C.gboolean               // out
	var _arg2 **C.gchar
	var _arg3 **C.gchar

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
	if recursive {
		_arg1 = C.TRUE
	}

	C.g_settings_schema_source_list_schemas(_arg0, _arg1, &_arg2, &_arg3)

	var _nonRelocatable []string
	var _relocatable []string

	{
		var i int
		var z *C.gchar
		for p := _arg2; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg2, i)
		_nonRelocatable = make([]string, i)
		for i := range src {
			_nonRelocatable[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	{
		var i int
		var z *C.gchar
		for p := _arg3; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_arg3, i)
		_relocatable = make([]string, i)
		for i := range src {
			_relocatable[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _nonRelocatable, _relocatable
}

// Lookup: decrease the reference count of @source, possibly freeing it.
func (s *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	var _arg0 *C.GSettingsSchemaSource // out
	var _arg1 *C.gchar                 // out
	var _arg2 C.gboolean               // out
	var _cret *C.GSettingsSchema       // in

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(schemaId))
	defer C.free(unsafe.Pointer(_arg1))
	if recursive {
		_arg2 = C.TRUE
	}

	_cret = C.g_settings_schema_source_lookup(_arg0, _arg1, _arg2)

	var _settingsSchema *SettingsSchema // out

	_settingsSchema = (*SettingsSchema)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchema, func(v **SettingsSchema) {
		C.free(unsafe.Pointer(v))
	})

	return _settingsSchema
}

// Ref: decrease the reference count of @source, possibly freeing it.
func (s *SettingsSchemaSource) Ref() *SettingsSchemaSource {
	var _arg0 *C.GSettingsSchemaSource // out
	var _cret *C.GSettingsSchemaSource // in

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

	_cret = C.g_settings_schema_source_ref(_arg0)

	var _settingsSchemaSource *SettingsSchemaSource // out

	_settingsSchemaSource = (*SettingsSchemaSource)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_settingsSchemaSource, func(v **SettingsSchemaSource) {
		C.free(unsafe.Pointer(v))
	})

	return _settingsSchemaSource
}

// Unref: decrease the reference count of @source, possibly freeing it.
func (s *SettingsSchemaSource) Unref() {
	var _arg0 *C.GSettingsSchemaSource // out

	_arg0 = (*C.GSettingsSchemaSource)(unsafe.Pointer(s.Native()))

	C.g_settings_schema_source_unref(_arg0)
}
