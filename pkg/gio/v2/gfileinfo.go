// Code generated by girgen. DO NOT EDIT.

package gio

import (
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_file_info_get_type()), F: marshalFileInfo},
	})
}

// FileInfo: functionality for manipulating basic metadata for files. Info
// implements methods for getting information that all files should contain, and
// allows for manipulation of extended attributes.
//
// See [GFileAttribute][gio-GFileAttribute] for more information on how GIO
// handles file attributes.
//
// To obtain a Info for a #GFile, use g_file_query_info() (or its async
// variant). To obtain a Info for a file input or output stream, use
// g_file_input_stream_query_info() or g_file_output_stream_query_info() (or
// their async variants).
//
// To change the actual attributes of a file, you should then set the attribute
// in the Info and call g_file_set_attributes_from_info() or
// g_file_set_attributes_async() on a GFile.
//
// However, not all attributes can be changed in the file. For instance, the
// actual size of a file cannot be changed via g_file_info_set_size(). You may
// call g_file_query_settable_attributes() and
// g_file_query_writable_namespaces() to discover the settable attributes of a
// particular file at runtime.
//
// AttributeMatcher allows for searching through a Info for attributes.
type FileInfo interface {
	gextras.Objector

	// ClearStatus clears the status information from @info.
	ClearStatus(i FileInfo)
	// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
	// @dest_info, and then copies all of the file attributes from @src_info to
	// @dest_info.
	CopyInto(s FileInfo, destInfo FileInfo)
	// Dup duplicates a file info structure.
	Dup(o FileInfo)
	// AttributeAsString gets the value of a attribute, formatted as a string.
	// This escapes things as needed to make the string valid UTF-8.
	AttributeAsString(i FileInfo, attribute string)
	// AttributeBoolean gets the value of a boolean attribute. If the attribute
	// does not contain a boolean value, false will be returned.
	AttributeBoolean(i FileInfo, attribute string) bool
	// AttributeByteString gets the value of a byte string attribute. If the
	// attribute does not contain a byte string, nil will be returned.
	AttributeByteString(i FileInfo, attribute string)
	// AttributeData gets the attribute type, value and status for an attribute
	// key.
	AttributeData(i FileInfo, attribute string) (typ *FileAttributeType, valuePp interface{}, status *FileAttributeStatus, ok bool)
	// AttributeInt32 gets a signed 32-bit integer contained within the
	// attribute. If the attribute does not contain a signed 32-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt32(i FileInfo, attribute string)
	// AttributeInt64 gets a signed 64-bit integer contained within the
	// attribute. If the attribute does not contain a signed 64-bit integer, or
	// is invalid, 0 will be returned.
	AttributeInt64(i FileInfo, attribute string)
	// AttributeObject gets the value of a #GObject attribute. If the attribute
	// does not contain a #GObject, nil will be returned.
	AttributeObject(i FileInfo, attribute string)
	// AttributeStatus gets the attribute status for an attribute key.
	AttributeStatus(i FileInfo, attribute string)
	// AttributeString gets the value of a string attribute. If the attribute
	// does not contain a string, nil will be returned.
	AttributeString(i FileInfo, attribute string)
	// AttributeStringv gets the value of a stringv attribute. If the attribute
	// does not contain a stringv, nil will be returned.
	AttributeStringv(i FileInfo, attribute string)
	// AttributeType gets the attribute type for an attribute key.
	AttributeType(i FileInfo, attribute string)
	// AttributeUint32 gets an unsigned 32-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 32-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint32(i FileInfo, attribute string)
	// AttributeUint64 gets a unsigned 64-bit integer contained within the
	// attribute. If the attribute does not contain an unsigned 64-bit integer,
	// or is invalid, 0 will be returned.
	AttributeUint64(i FileInfo, attribute string)
	// ContentType gets the file's content type.
	ContentType(i FileInfo)
	// DeletionDate returns the Time representing the deletion date of the file,
	// as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
	// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, nil is returned.
	DeletionDate(i FileInfo)
	// DisplayName gets a display name for a file. This is guaranteed to always
	// be set.
	DisplayName(i FileInfo)
	// EditName gets the edit name for a file.
	EditName(i FileInfo)
	// Etag gets the [entity tag][gfile-etag] for a given Info. See
	// G_FILE_ATTRIBUTE_ETAG_VALUE.
	Etag(i FileInfo)
	// FileType gets a file's type (whether it is a regular file, symlink, etc).
	// This is different from the file's content type, see
	// g_file_info_get_content_type().
	FileType(i FileInfo)
	// Icon gets the icon for a file.
	Icon(i FileInfo)
	// IsBackup checks if a file is a backup file.
	IsBackup(i FileInfo) bool
	// IsHidden checks if a file is hidden.
	IsHidden(i FileInfo) bool
	// IsSymlink checks if a file is a symlink.
	IsSymlink(i FileInfo) bool
	// ModificationDateTime gets the modification time of the current @info and
	// returns it as a Time.
	//
	// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will
	// have microsecond precision.
	ModificationDateTime(i FileInfo)
	// ModificationTime gets the modification time of the current @info and sets
	// it in @result.
	ModificationTime(i FileInfo) *glib.TimeVal
	// Name gets the name for a file. This is guaranteed to always be set.
	Name(i FileInfo)
	// Size gets the file's size.
	Size(i FileInfo)
	// SortOrder gets the value of the sort_order attribute from the Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SortOrder(i FileInfo)
	// SymbolicIcon gets the symbolic icon for a file.
	SymbolicIcon(i FileInfo)
	// SymlinkTarget gets the symlink target for a given Info.
	SymlinkTarget(i FileInfo)
	// HasAttribute checks if a file info structure has an attribute named
	// @attribute.
	HasAttribute(i FileInfo, attribute string) bool
	// HasNamespace checks if a file info structure has an attribute in the
	// specified @name_space.
	HasNamespace(i FileInfo, nameSpace string) bool
	// ListAttributes lists the file info structure's attributes.
	ListAttributes(i FileInfo, nameSpace string)
	// RemoveAttribute removes all cases of @attribute from @info if it exists.
	RemoveAttribute(i FileInfo, attribute string)
	// SetAttribute sets the @attribute to contain the given value, if possible.
	// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for @type.
	SetAttribute(i FileInfo, attribute string, typ FileAttributeType, valueP interface{})
	// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeBoolean(i FileInfo, attribute string, attrValue bool)
	// SetAttributeByteString sets the @attribute to contain the given
	// @attr_value, if possible.
	SetAttributeByteString(i FileInfo, attribute string, attrValue string)
	// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt32(i FileInfo, attribute string, attrValue int32)
	// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt64(i FileInfo, attribute string, attrValue int64)
	// SetAttributeMask sets @mask on @info to match specific attribute types.
	SetAttributeMask(i FileInfo, mask *FileAttributeMatcher)
	// SetAttributeObject sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeObject(i FileInfo, attribute string, attrValue gextras.Objector)
	// SetAttributeStatus sets the attribute status for an attribute key. This
	// is only needed by external code that implement
	// g_file_set_attributes_from_info() or similar functions.
	//
	// The attribute must exist in @info for this to work. Otherwise false is
	// returned and @info is unchanged.
	SetAttributeStatus(i FileInfo, attribute string, status FileAttributeStatus) bool
	// SetAttributeString sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeString(i FileInfo, attribute string, attrValue string)
	// SetAttributeStringv sets the @attribute to contain the given @attr_value,
	// if possible.
	//
	// Sinze: 2.22
	SetAttributeStringv(i FileInfo, attribute string, attrValue []string)
	// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint32(i FileInfo, attribute string, attrValue uint32)
	// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint64(i FileInfo, attribute string, attrValue uint64)
	// SetContentType sets the content type attribute for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	SetContentType(i FileInfo, contentType string)
	// SetDisplayName sets the display name for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	SetDisplayName(i FileInfo, displayName string)
	// SetEditName sets the edit name for the current file. See
	// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	SetEditName(i FileInfo, editName string)
	// SetFileType sets the file type in a Info to @type. See
	// G_FILE_ATTRIBUTE_STANDARD_TYPE.
	SetFileType(i FileInfo, typ FileType)
	// SetIcon sets the icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_ICON.
	SetIcon(i FileInfo, icon Icon)
	// SetIsHidden sets the "is_hidden" attribute in a Info according to
	// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	SetIsHidden(i FileInfo, isHidden bool)
	// SetIsSymlink sets the "is_symlink" attribute in a Info according to
	// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	SetIsSymlink(i FileInfo, isSymlink bool)
	// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given date/time value.
	SetModificationDateTime(i FileInfo, mtime *glib.DateTime)
	// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
	// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
	// given time value.
	SetModificationTime(i FileInfo, mtime *glib.TimeVal)
	// SetName sets the name attribute for the current Info. See
	// G_FILE_ATTRIBUTE_STANDARD_NAME.
	SetName(i FileInfo, name string)
	// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
	// info to the given size.
	SetSize(i FileInfo, size int64)
	// SetSortOrder sets the sort order attribute in the file info structure.
	// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SetSortOrder(i FileInfo, sortOrder int32)
	// SetSymbolicIcon sets the symbolic icon for a given Info. See
	// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	SetSymbolicIcon(i FileInfo, icon Icon)
	// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
	// attribute in the file info to the given symlink target.
	SetSymlinkTarget(i FileInfo, symlinkTarget string)
	// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
	// if one is set.
	UnsetAttributeMask(i FileInfo)
}

// fileInfo implements the FileInfo interface.
type fileInfo struct {
	gextras.Objector
}

var _ FileInfo = (*fileInfo)(nil)

// WrapFileInfo wraps a GObject to the right type. It is
// primarily used internally.
func WrapFileInfo(obj *externglib.Object) FileInfo {
	return FileInfo{
		Objector: obj,
	}
}

func marshalFileInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFileInfo(obj), nil
}

// NewFileInfo constructs a class FileInfo.
func NewFileInfo() {
	C.g_file_info_new()
}

// ClearStatus clears the status information from @info.
func (i fileInfo) ClearStatus(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_clear_status(arg0)
}

// CopyInto: first clears all of the [GFileAttribute][gio-GFileAttribute] of
// @dest_info, and then copies all of the file attributes from @src_info to
// @dest_info.
func (s fileInfo) CopyInto(s FileInfo, destInfo FileInfo) {
	var arg0 *C.GFileInfo
	var arg1 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GFileInfo)(unsafe.Pointer(destInfo.Native()))

	C.g_file_info_copy_into(arg0, arg1)
}

// Dup duplicates a file info structure.
func (o fileInfo) Dup(o FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(o.Native()))

	C.g_file_info_dup(arg0)
}

// AttributeAsString gets the value of a attribute, formatted as a string.
// This escapes things as needed to make the string valid UTF-8.
func (i fileInfo) AttributeAsString(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_as_string(arg0, arg1)
}

// AttributeBoolean gets the value of a boolean attribute. If the attribute
// does not contain a boolean value, false will be returned.
func (i fileInfo) AttributeBoolean(i FileInfo, attribute string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_get_attribute_boolean(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// AttributeByteString gets the value of a byte string attribute. If the
// attribute does not contain a byte string, nil will be returned.
func (i fileInfo) AttributeByteString(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_byte_string(arg0, arg1)
}

// AttributeData gets the attribute type, value and status for an attribute
// key.
func (i fileInfo) AttributeData(i FileInfo, attribute string) (typ *FileAttributeType, valuePp interface{}, status *FileAttributeStatus, ok bool) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	var arg2 C.GFileAttributeType
	var typ *FileAttributeType
	var arg3 C.gpointer
	var valuePp interface{}
	var arg4 C.GFileAttributeStatus
	var status *FileAttributeStatus
	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_get_attribute_data(arg0, arg1, &arg2, &arg3, &arg4)

	typ = *FileAttributeType(&arg2)
	valuePp = interface{}(&arg3)
	status = *FileAttributeStatus(&arg4)
	if cret {
		ok = true
	}

	return typ, valuePp, status, ok
}

// AttributeInt32 gets a signed 32-bit integer contained within the
// attribute. If the attribute does not contain a signed 32-bit integer, or
// is invalid, 0 will be returned.
func (i fileInfo) AttributeInt32(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_int32(arg0, arg1)
}

// AttributeInt64 gets a signed 64-bit integer contained within the
// attribute. If the attribute does not contain a signed 64-bit integer, or
// is invalid, 0 will be returned.
func (i fileInfo) AttributeInt64(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_int64(arg0, arg1)
}

// AttributeObject gets the value of a #GObject attribute. If the attribute
// does not contain a #GObject, nil will be returned.
func (i fileInfo) AttributeObject(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_object(arg0, arg1)
}

// AttributeStatus gets the attribute status for an attribute key.
func (i fileInfo) AttributeStatus(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_status(arg0, arg1)
}

// AttributeString gets the value of a string attribute. If the attribute
// does not contain a string, nil will be returned.
func (i fileInfo) AttributeString(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_string(arg0, arg1)
}

// AttributeStringv gets the value of a stringv attribute. If the attribute
// does not contain a stringv, nil will be returned.
func (i fileInfo) AttributeStringv(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_stringv(arg0, arg1)
}

// AttributeType gets the attribute type for an attribute key.
func (i fileInfo) AttributeType(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_type(arg0, arg1)
}

// AttributeUint32 gets an unsigned 32-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 32-bit integer,
// or is invalid, 0 will be returned.
func (i fileInfo) AttributeUint32(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_uint32(arg0, arg1)
}

// AttributeUint64 gets a unsigned 64-bit integer contained within the
// attribute. If the attribute does not contain an unsigned 64-bit integer,
// or is invalid, 0 will be returned.
func (i fileInfo) AttributeUint64(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_get_attribute_uint64(arg0, arg1)
}

// ContentType gets the file's content type.
func (i fileInfo) ContentType(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_content_type(arg0)
}

// DeletionDate returns the Time representing the deletion date of the file,
// as available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
// G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, nil is returned.
func (i fileInfo) DeletionDate(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_deletion_date(arg0)
}

// DisplayName gets a display name for a file. This is guaranteed to always
// be set.
func (i fileInfo) DisplayName(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_display_name(arg0)
}

// EditName gets the edit name for a file.
func (i fileInfo) EditName(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_edit_name(arg0)
}

// Etag gets the [entity tag][gfile-etag] for a given Info. See
// G_FILE_ATTRIBUTE_ETAG_VALUE.
func (i fileInfo) Etag(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_etag(arg0)
}

// FileType gets a file's type (whether it is a regular file, symlink, etc).
// This is different from the file's content type, see
// g_file_info_get_content_type().
func (i fileInfo) FileType(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_file_type(arg0)
}

// Icon gets the icon for a file.
func (i fileInfo) Icon(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_icon(arg0)
}

// IsBackup checks if a file is a backup file.
func (i fileInfo) IsBackup(i FileInfo) bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_get_is_backup(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsHidden checks if a file is hidden.
func (i fileInfo) IsHidden(i FileInfo) bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_get_is_hidden(arg0)

	if cret {
		ok = true
	}

	return ok
}

// IsSymlink checks if a file is a symlink.
func (i fileInfo) IsSymlink(i FileInfo) bool {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_get_is_symlink(arg0)

	if cret {
		ok = true
	}

	return ok
}

// ModificationDateTime gets the modification time of the current @info and
// returns it as a Time.
//
// This requires the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting Time will
// have microsecond precision.
func (i fileInfo) ModificationDateTime(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_modification_date_time(arg0)
}

// ModificationTime gets the modification time of the current @info and sets
// it in @result.
func (i fileInfo) ModificationTime(i FileInfo) *glib.TimeVal {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	var arg1 C.GTimeVal
	var result *glib.TimeVal

	C.g_file_info_get_modification_time(arg0, &arg1)

	result = glib.WrapTimeVal(unsafe.Pointer(&arg1))

	return result
}

// Name gets the name for a file. This is guaranteed to always be set.
func (i fileInfo) Name(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_name(arg0)
}

// Size gets the file's size.
func (i fileInfo) Size(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_size(arg0)
}

// SortOrder gets the value of the sort_order attribute from the Info. See
// G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (i fileInfo) SortOrder(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_sort_order(arg0)
}

// SymbolicIcon gets the symbolic icon for a file.
func (i fileInfo) SymbolicIcon(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_symbolic_icon(arg0)
}

// SymlinkTarget gets the symlink target for a given Info.
func (i fileInfo) SymlinkTarget(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_get_symlink_target(arg0)
}

// HasAttribute checks if a file info structure has an attribute named
// @attribute.
func (i fileInfo) HasAttribute(i FileInfo, attribute string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_has_attribute(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// HasNamespace checks if a file info structure has an attribute in the
// specified @name_space.
func (i fileInfo) HasNamespace(i FileInfo, nameSpace string) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_has_namespace(arg0, arg1)

	if cret {
		ok = true
	}

	return ok
}

// ListAttributes lists the file info structure's attributes.
func (i fileInfo) ListAttributes(i FileInfo, nameSpace string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(nameSpace))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_list_attributes(arg0, arg1)
}

// RemoveAttribute removes all cases of @attribute from @info if it exists.
func (i fileInfo) RemoveAttribute(i FileInfo, attribute string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_remove_attribute(arg0, arg1)
}

// SetAttribute sets the @attribute to contain the given value, if possible.
// To unset the attribute, use G_FILE_ATTRIBUTE_TYPE_INVALID for @type.
func (i fileInfo) SetAttribute(i FileInfo, attribute string, typ FileAttributeType, valueP interface{}) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.GFileAttributeType
	var arg3 C.gpointer

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeType)(typ)
	arg3 = C.gpointer(valueP)

	C.g_file_info_set_attribute(arg0, arg1, arg2, arg3)
}

// SetAttributeBoolean sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeBoolean(i FileInfo, attribute string, attrValue bool) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gboolean

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	if attrValue {
		arg2 = C.gboolean(1)
	}

	C.g_file_info_set_attribute_boolean(arg0, arg1, arg2)
}

// SetAttributeByteString sets the @attribute to contain the given
// @attr_value, if possible.
func (i fileInfo) SetAttributeByteString(i FileInfo, attribute string, attrValue string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(arg2))

	C.g_file_info_set_attribute_byte_string(arg0, arg1, arg2)
}

// SetAttributeInt32 sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeInt32(i FileInfo, attribute string, attrValue int32) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gint32

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(arg0, arg1, arg2)
}

// SetAttributeInt64 sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeInt64(i FileInfo, attribute string, attrValue int64) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.gint64

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(arg0, arg1, arg2)
}

// SetAttributeMask sets @mask on @info to match specific attribute types.
func (i fileInfo) SetAttributeMask(i FileInfo, mask *FileAttributeMatcher) {
	var arg0 *C.GFileInfo
	var arg1 *C.GFileAttributeMatcher

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GFileAttributeMatcher)(unsafe.Pointer(mask.Native()))

	C.g_file_info_set_attribute_mask(arg0, arg1)
}

// SetAttributeObject sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeObject(i FileInfo, attribute string, attrValue gextras.Objector) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.GObject

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GObject)(unsafe.Pointer(attrValue.Native()))

	C.g_file_info_set_attribute_object(arg0, arg1, arg2)
}

// SetAttributeStatus sets the attribute status for an attribute key. This
// is only needed by external code that implement
// g_file_set_attributes_from_info() or similar functions.
//
// The attribute must exist in @info for this to work. Otherwise false is
// returned and @info is unchanged.
func (i fileInfo) SetAttributeStatus(i FileInfo, attribute string, status FileAttributeStatus) bool {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.GFileAttributeStatus

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GFileAttributeStatus)(status)

	var cret C.gboolean
	var ok bool

	cret = C.g_file_info_set_attribute_status(arg0, arg1, arg2)

	if cret {
		ok = true
	}

	return ok
}

// SetAttributeString sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeString(i FileInfo, attribute string, attrValue string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.char)(C.CString(attrValue))
	defer C.free(unsafe.Pointer(arg2))

	C.g_file_info_set_attribute_string(arg0, arg1, arg2)
}

// SetAttributeStringv sets the @attribute to contain the given @attr_value,
// if possible.
//
// Sinze: 2.22
func (i fileInfo) SetAttributeStringv(i FileInfo, attribute string, attrValue []string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 **C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.malloc(len(attrValue) * (unsafe.Sizeof(int(0)) + 1))
	defer C.free(unsafe.Pointer(arg2))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(arg2), int(len(attrValue)))

		for i := range attrValue {
			out[i] = (*C.gchar)(C.CString(attrValue[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_file_info_set_attribute_stringv(arg0, arg1, arg2)
}

// SetAttributeUint32 sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeUint32(i FileInfo, attribute string, attrValue uint32) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.guint32

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(arg0, arg1, arg2)
}

// SetAttributeUint64 sets the @attribute to contain the given @attr_value,
// if possible.
func (i fileInfo) SetAttributeUint64(i FileInfo, attribute string, attrValue uint64) {
	var arg0 *C.GFileInfo
	var arg1 *C.char
	var arg2 C.guint64

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(arg0, arg1, arg2)
}

// SetContentType sets the content type attribute for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
func (i fileInfo) SetContentType(i FileInfo, contentType string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_content_type(arg0, arg1)
}

// SetDisplayName sets the display name for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
func (i fileInfo) SetDisplayName(i FileInfo, displayName string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(displayName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_display_name(arg0, arg1)
}

// SetEditName sets the edit name for the current file. See
// G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
func (i fileInfo) SetEditName(i FileInfo, editName string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(editName))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_edit_name(arg0, arg1)
}

// SetFileType sets the file type in a Info to @type. See
// G_FILE_ATTRIBUTE_STANDARD_TYPE.
func (i fileInfo) SetFileType(i FileInfo, typ FileType) {
	var arg0 *C.GFileInfo
	var arg1 C.GFileType

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (C.GFileType)(typ)

	C.g_file_info_set_file_type(arg0, arg1)
}

// SetIcon sets the icon for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_ICON.
func (i fileInfo) SetIcon(i FileInfo, icon Icon) {
	var arg0 *C.GFileInfo
	var arg1 *C.GIcon

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_file_info_set_icon(arg0, arg1)
}

// SetIsHidden sets the "is_hidden" attribute in a Info according to
// @is_hidden. See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
func (i fileInfo) SetIsHidden(i FileInfo, isHidden bool) {
	var arg0 *C.GFileInfo
	var arg1 C.gboolean

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	if isHidden {
		arg1 = C.gboolean(1)
	}

	C.g_file_info_set_is_hidden(arg0, arg1)
}

// SetIsSymlink sets the "is_symlink" attribute in a Info according to
// @is_symlink. See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
func (i fileInfo) SetIsSymlink(i FileInfo, isSymlink bool) {
	var arg0 *C.GFileInfo
	var arg1 C.gboolean

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	if isSymlink {
		arg1 = C.gboolean(1)
	}

	C.g_file_info_set_is_symlink(arg0, arg1)
}

// SetModificationDateTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
// given date/time value.
func (i fileInfo) SetModificationDateTime(i FileInfo, mtime *glib.DateTime) {
	var arg0 *C.GFileInfo
	var arg1 *C.GDateTime

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GDateTime)(unsafe.Pointer(mtime.Native()))

	C.g_file_info_set_modification_date_time(arg0, arg1)
}

// SetModificationTime sets the G_FILE_ATTRIBUTE_TIME_MODIFIED and
// G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
// given time value.
func (i fileInfo) SetModificationTime(i FileInfo, mtime *glib.TimeVal) {
	var arg0 *C.GFileInfo
	var arg1 *C.GTimeVal

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GTimeVal)(unsafe.Pointer(mtime.Native()))

	C.g_file_info_set_modification_time(arg0, arg1)
}

// SetName sets the name attribute for the current Info. See
// G_FILE_ATTRIBUTE_STANDARD_NAME.
func (i fileInfo) SetName(i FileInfo, name string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_name(arg0, arg1)
}

// SetSize sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file
// info to the given size.
func (i fileInfo) SetSize(i FileInfo, size int64) {
	var arg0 *C.GFileInfo
	var arg1 C.goffset

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = C.goffset(size)

	C.g_file_info_set_size(arg0, arg1)
}

// SetSortOrder sets the sort order attribute in the file info structure.
// See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (i fileInfo) SetSortOrder(i FileInfo, sortOrder int32) {
	var arg0 *C.GFileInfo
	var arg1 C.gint32

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(arg0, arg1)
}

// SetSymbolicIcon sets the symbolic icon for a given Info. See
// G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
func (i fileInfo) SetSymbolicIcon(i FileInfo, icon Icon) {
	var arg0 *C.GFileInfo
	var arg1 *C.GIcon

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_file_info_set_symbolic_icon(arg0, arg1)
}

// SetSymlinkTarget sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
// attribute in the file info to the given symlink target.
func (i fileInfo) SetSymlinkTarget(i FileInfo, symlinkTarget string) {
	var arg0 *C.GFileInfo
	var arg1 *C.char

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))
	arg1 = (*C.char)(C.CString(symlinkTarget))
	defer C.free(unsafe.Pointer(arg1))

	C.g_file_info_set_symlink_target(arg0, arg1)
}

// UnsetAttributeMask unsets a mask set by g_file_info_set_attribute_mask(),
// if one is set.
func (i fileInfo) UnsetAttributeMask(i FileInfo) {
	var arg0 *C.GFileInfo

	arg0 = (*C.GFileInfo)(unsafe.Pointer(i.Native()))

	C.g_file_info_unset_attribute_mask(arg0)
}
