// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
	})
}

// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress interface {
	gextras.Objector

	// Equal checks if two Address instances are equal, e.g. the same address.
	Equal(otherAddress InetAddress) bool
	// Family gets @address's family
	Family() SocketFamily
	// IsAny tests whether @address is the "any" address for its family.
	IsAny() bool
	// IsLinkLocal tests whether @address is a link-local address (that is, if
	// it identifies a host on a local network that is not connected to the
	// Internet).
	IsLinkLocal() bool
	// IsLoopback tests whether @address is the loopback address for its family.
	IsLoopback() bool
	// IsMcGlobal tests whether @address is a global multicast address.
	IsMcGlobal() bool
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	IsMcLinkLocal() bool
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	IsMcNodeLocal() bool
	// IsMcOrgLocal tests whether @address is an organization-local multicast
	// address.
	IsMcOrgLocal() bool
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	IsMcSiteLocal() bool
	// IsMulticast tests whether @address is a multicast address.
	IsMulticast() bool
	// IsSiteLocal tests whether @address is a site-local address such as
	// 10.0.0.1 (that is, the address identifies a host on a local network that
	// can not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	IsSiteLocal() bool
	// NativeSize gets the size of the native raw binary address for @address.
	// This is the size of the data that you get from g_inet_address_to_bytes().
	NativeSize() uint
	// ToBytes gets the raw binary address data from @address.
	ToBytes() byte
	// String converts @address to string form.
	String() string
}

// inetAddress implements the InetAddress interface.
type inetAddress struct {
	gextras.Objector
}

var _ InetAddress = (*inetAddress)(nil)

// WrapInetAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddress(obj *externglib.Object) InetAddress {
	return InetAddress{
		Objector: obj,
	}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddress(obj), nil
}

// NewInetAddressAny constructs a class InetAddress.
func NewInetAddressAny(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	ret := C.g_inet_address_new_any(arg1)

	var ret0 InetAddress

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(InetAddress)

	return ret0
}

// NewInetAddressFromString constructs a class InetAddress.
func NewInetAddressFromString(string string) InetAddress {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_inet_address_new_from_string(arg1)

	var ret0 InetAddress

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(InetAddress)

	return ret0
}

// NewInetAddressLoopback constructs a class InetAddress.
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	ret := C.g_inet_address_new_loopback(arg1)

	var ret0 InetAddress

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(InetAddress)

	return ret0
}

// Equal checks if two Address instances are equal, e.g. the same address.
func (a inetAddress) Equal(otherAddress InetAddress) bool {
	var arg0 *C.GInetAddress
	var arg1 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())
	arg1 = (*C.GInetAddress)(otherAddress.Native())

	ret := C.g_inet_address_equal(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Family gets @address's family
func (a inetAddress) Family() SocketFamily {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_family(arg0)

	var ret0 SocketFamily

	ret0 = SocketFamily(ret)

	return ret0
}

// IsAny tests whether @address is the "any" address for its family.
func (a inetAddress) IsAny() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_any(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsLinkLocal tests whether @address is a link-local address (that is, if
// it identifies a host on a local network that is not connected to the
// Internet).
func (a inetAddress) IsLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_link_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsLoopback tests whether @address is the loopback address for its family.
func (a inetAddress) IsLoopback() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_loopback(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMcGlobal tests whether @address is a global multicast address.
func (a inetAddress) IsMcGlobal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_mc_global(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMcLinkLocal tests whether @address is a link-local multicast address.
func (a inetAddress) IsMcLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_mc_link_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMcNodeLocal tests whether @address is a node-local multicast address.
func (a inetAddress) IsMcNodeLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_mc_node_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMcOrgLocal tests whether @address is an organization-local multicast
// address.
func (a inetAddress) IsMcOrgLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_mc_org_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMcSiteLocal tests whether @address is a site-local multicast address.
func (a inetAddress) IsMcSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_mc_site_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsMulticast tests whether @address is a multicast address.
func (a inetAddress) IsMulticast() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_multicast(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsSiteLocal tests whether @address is a site-local address such as
// 10.0.0.1 (that is, the address identifies a host on a local network that
// can not be reached directly from the Internet, but which may have
// outgoing Internet connectivity via a NAT or firewall).
func (a inetAddress) IsSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_is_site_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// NativeSize gets the size of the native raw binary address for @address.
// This is the size of the data that you get from g_inet_address_to_bytes().
func (a inetAddress) NativeSize() uint {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_get_native_size(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ToBytes gets the raw binary address data from @address.
func (a inetAddress) ToBytes() byte {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_to_bytes(arg0)

	var ret0 byte

	ret0 = byte(ret)

	return ret0
}

// String converts @address to string form.
func (a inetAddress) String() string {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(a.Native())

	ret := C.g_inet_address_to_string(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

type InetAddressPrivate struct {
	native C.GInetAddressPrivate
}

// WrapInetAddressPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInetAddressPrivate(ptr unsafe.Pointer) *InetAddressPrivate {
	if ptr == nil {
		return nil
	}

	return (*InetAddressPrivate)(ptr)
}

func marshalInetAddressPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInetAddressPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *InetAddressPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}
