// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_inet_address_get_type()), F: marshalInetAddress},
	})
}

// InetAddress represents an IPv4 or IPv6 internet address. Use
// g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to look up
// the Address for a hostname. Use g_resolver_lookup_by_address() or
// g_resolver_lookup_by_address_async() to look up the hostname for a Address.
//
// To actually connect to a remote host, you will need a SocketAddress (which
// includes a Address as well as a port number).
type InetAddress interface {
	gextras.Objector

	// Equal checks if two Address instances are equal, e.g. the same address.
	Equal(otherAddress InetAddress) bool
	// Family gets @address's family
	Family() SocketFamily
	// IsAny tests whether @address is the "any" address for its family.
	IsAny() bool
	// IsLinkLocal tests whether @address is a link-local address (that is, if
	// it identifies a host on a local network that is not connected to the
	// Internet).
	IsLinkLocal() bool
	// IsLoopback tests whether @address is the loopback address for its family.
	IsLoopback() bool
	// IsMcGlobal tests whether @address is a global multicast address.
	IsMcGlobal() bool
	// IsMcLinkLocal tests whether @address is a link-local multicast address.
	IsMcLinkLocal() bool
	// IsMcNodeLocal tests whether @address is a node-local multicast address.
	IsMcNodeLocal() bool
	// IsMcOrgLocal tests whether @address is an organization-local multicast
	// address.
	IsMcOrgLocal() bool
	// IsMcSiteLocal tests whether @address is a site-local multicast address.
	IsMcSiteLocal() bool
	// IsMulticast tests whether @address is a multicast address.
	IsMulticast() bool
	// IsSiteLocal tests whether @address is a site-local address such as
	// 10.0.0.1 (that is, the address identifies a host on a local network that
	// can not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	IsSiteLocal() bool
	// NativeSize gets the size of the native raw binary address for @address.
	// This is the size of the data that you get from g_inet_address_to_bytes().
	NativeSize() uint
	// ToBytes gets the raw binary address data from @address.
	ToBytes() byte
	// String converts @address to string form.
	String() string
}

// inetAddress implements the InetAddress interface.
type inetAddress struct {
	gextras.Objector
}

var _ InetAddress = (*inetAddress)(nil)

// WrapInetAddress wraps a GObject to the right type. It is
// primarily used internally.
func WrapInetAddress(obj *externglib.Object) InetAddress {
	return InetAddress{
		Objector: obj,
	}
}

func marshalInetAddress(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInetAddress(obj), nil
}

// NewInetAddressAny constructs a class InetAddress.
func NewInetAddressAny(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	var cret C.GInetAddress
	var ret1 InetAddress

	cret = C.g_inet_address_new_any(family)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(InetAddress)

	return ret1
}

// NewInetAddressFromString constructs a class InetAddress.
func NewInetAddressFromString(string string) InetAddress {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GInetAddress
	var ret1 InetAddress

	cret = C.g_inet_address_new_from_string(string)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(InetAddress)

	return ret1
}

// NewInetAddressLoopback constructs a class InetAddress.
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var arg1 C.GSocketFamily

	arg1 = (C.GSocketFamily)(family)

	var cret C.GInetAddress
	var ret1 InetAddress

	cret = C.g_inet_address_new_loopback(family)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(InetAddress)

	return ret1
}

// Equal checks if two Address instances are equal, e.g. the same address.
func (a inetAddress) Equal(otherAddress InetAddress) bool {
	var arg0 *C.GInetAddress
	var arg1 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))
	arg1 = (*C.GInetAddress)(unsafe.Pointer(otherAddress.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_equal(arg0, otherAddress)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Family gets @address's family
func (a inetAddress) Family() SocketFamily {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.GSocketFamily
	var ret1 SocketFamily

	cret = C.g_inet_address_get_family(arg0)

	ret1 = SocketFamily(cret)

	return ret1
}

// IsAny tests whether @address is the "any" address for its family.
func (a inetAddress) IsAny() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_any(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsLinkLocal tests whether @address is a link-local address (that is, if
// it identifies a host on a local network that is not connected to the
// Internet).
func (a inetAddress) IsLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_link_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsLoopback tests whether @address is the loopback address for its family.
func (a inetAddress) IsLoopback() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_loopback(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMcGlobal tests whether @address is a global multicast address.
func (a inetAddress) IsMcGlobal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_mc_global(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMcLinkLocal tests whether @address is a link-local multicast address.
func (a inetAddress) IsMcLinkLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_mc_link_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMcNodeLocal tests whether @address is a node-local multicast address.
func (a inetAddress) IsMcNodeLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_mc_node_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMcOrgLocal tests whether @address is an organization-local multicast
// address.
func (a inetAddress) IsMcOrgLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_mc_org_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMcSiteLocal tests whether @address is a site-local multicast address.
func (a inetAddress) IsMcSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_mc_site_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsMulticast tests whether @address is a multicast address.
func (a inetAddress) IsMulticast() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_multicast(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsSiteLocal tests whether @address is a site-local address such as
// 10.0.0.1 (that is, the address identifies a host on a local network that
// can not be reached directly from the Internet, but which may have
// outgoing Internet connectivity via a NAT or firewall).
func (a inetAddress) IsSiteLocal() bool {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_inet_address_get_is_site_local(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// NativeSize gets the size of the native raw binary address for @address.
// This is the size of the data that you get from g_inet_address_to_bytes().
func (a inetAddress) NativeSize() uint {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret C.gsize
	var ret1 uint

	cret = C.g_inet_address_get_native_size(arg0)

	ret1 = C.gsize(cret)

	return ret1
}

// ToBytes gets the raw binary address data from @address.
func (a inetAddress) ToBytes() byte {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret *C.guint8
	var ret1 byte

	cret = C.g_inet_address_to_bytes(arg0)

	ret1 = *C.guint8(cret)

	return ret1
}

// String converts @address to string form.
func (a inetAddress) String() string {
	var arg0 *C.GInetAddress

	arg0 = (*C.GInetAddress)(unsafe.Pointer(a.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_inet_address_to_string(arg0)

	ret1 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return ret1
}
