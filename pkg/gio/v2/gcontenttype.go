// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

// ContentTypeCanBeExecutable checks if a content type can be executable. Note
// that for instance things like text files can be executables (i.e. scripts and
// batch files).
func ContentTypeCanBeExecutable(typ string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_can_be_executable(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ContentTypeEquals compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(type1))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(type2))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_equals(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
func ContentTypeFromMIMEType(mimeType string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_from_mime_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetDescription gets the human readable description of the content
// type.
func ContentTypeGetDescription(typ string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_description(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetGenericIconName gets the generic icon name for a content type.
//
// See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(typ string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_generic_icon_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetIcon gets the icon for a content type.
func ContentTypeGetIcon(typ string) Icon {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_icon(arg1)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// ContentTypeGetMIMEDirs: get the list of directories which MIME data is loaded
// from. See g_content_type_set_mime_dirs() for details.
func ContentTypeGetMIMEDirs() []string {
	ret := C.g_content_type_get_mime_dirs()

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
		}
	}

	return ret0
}

// ContentTypeGetMIMEType gets the mime type for the content type, if one is
// registered.
func ContentTypeGetMIMEType(typ string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_mime_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// ContentTypeGetSymbolicIcon gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(typ string) Icon {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_get_symbolic_icon(arg1)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// ContentTypeGuess guesses the content type based on example data. If the
// function is uncertain, @result_uncertain will be set to true. Either
// @filename or @data may be nil, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []byte) (resultUncertain bool, utf8 string) {
	var arg1 *C.gchar
	var arg2 *C.guchar
	var arg3 C.gsize
	var arg4 *C.gboolean // out

	arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.guchar)(unsafe.Pointer(&data[0]))
	arg3 = len(data)
	defer runtime.KeepAlive(data)

	ret := C.g_content_type_guess(arg1, arg2, arg3, &arg4)

	var ret0 bool
	var ret1 string

	ret0 = C.bool(arg4) != 0

	ret1 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0, ret1
}

// ContentTypeGuessForTree tries to guess the type of the tree with root @root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g. x-content/audio-cdda
// (for audio CDs) or x-content/image-dcf (for a camera memory card). See the
// shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string {
	var arg1 *C.GFile

	arg1 = (*C.GFile)(root.Native())

	ret := C.g_content_type_guess_for_tree(arg1)

	var ret0 []string

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (*C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	return ret0
}

// ContentTypeIsA determines if @type is a subset of @supertype.
func ContentTypeIsA(typ string, supertype string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(supertype))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_is_a(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ContentTypeIsMIMEType determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMIMEType(typ string, mimeType string) bool {
	var arg1 *C.gchar
	var arg2 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_content_type_is_mime_type(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ContentTypeIsUnknown checks if the content type is the generic "unknown"
// type. On UNIX this is the "application/octet-stream" mimetype, while on win32
// it is "*" and on OSX it is a dynamic type or octet-stream.
func ContentTypeIsUnknown(typ string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(typ))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_content_type_is_unknown(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ContentTypeSetMIMEDirs: set the list of directories used by GIO to load the
// MIME database. If @dirs is nil, the directories used are the default:
//
//    - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//    - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
//
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
//
// Typically, in case your tests use G_TEST_OPTION_ISOLATE_DIRS, but they depend
// on the system’s MIME database, you should call this function with @dirs set
// to nil before calling g_test_init(), for instance:
//
//      // Load MIME data from the system
//      g_content_type_set_mime_dirs (NULL);
//      // Isolate the environment
//      g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
//
//      …
//
//      return g_test_run ();
func ContentTypeSetMIMEDirs(dirs []string) {
	var arg1 **C.gchar

	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(dirs) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(dirs)
		sliceHeader.Cap = len(dirs)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(dirs); i++ {
			src := dirs[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.gchar)(unsafe.Pointer(ptr))
	}

	C.g_content_type_set_mime_dirs(arg1)
}

// ContentTypesGetRegistered gets a list of strings containing all the
// registered content types known to the system. The list and its data should be
// freed using `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() *glib.List {
	ret := C.g_content_types_get_registered()

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}
