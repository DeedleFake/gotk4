// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_get_type()), F: marshalAppInfo},
		{T: externglib.Type(C.g_app_launch_context_get_type()), F: marshalAppLaunchContext},
	})
}

// AppInfo: Info and LaunchContext are used for describing and launching
// applications installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key `totem U` and a single URI, `sftp://foo/file.avi`,
// then `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only
// work if a set of suitable GIO extensions (such as gvfs 2.26 compiled with
// FUSE support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
type AppInfo interface {
	gextras.Objector

	// AddSupportsType checks if the application supports reading files and
	// directories from URIs.
	AddSupportsType(contentType string) error
	// CanDelete checks if the application supports reading files and
	// directories from URIs.
	CanDelete() bool
	// CanRemoveSupportsType checks if the application supports reading files
	// and directories from URIs.
	CanRemoveSupportsType() bool
	// Delete checks if the application supports reading files and directories
	// from URIs.
	Delete() bool
	// Dup checks if the application supports reading files and directories from
	// URIs.
	Dup() AppInfo
	// Equal checks if the application supports reading files and directories
	// from URIs.
	Equal(appinfo2 AppInfo) bool
	// Commandline checks if the application supports reading files and
	// directories from URIs.
	Commandline() string
	// Description checks if the application supports reading files and
	// directories from URIs.
	Description() string
	// DisplayName checks if the application supports reading files and
	// directories from URIs.
	DisplayName() string
	// Executable checks if the application supports reading files and
	// directories from URIs.
	Executable() string
	// Icon checks if the application supports reading files and directories
	// from URIs.
	Icon() Icon
	// ID checks if the application supports reading files and directories from
	// URIs.
	ID() string
	// Name checks if the application supports reading files and directories
	// from URIs.
	Name() string
	// SupportedTypes checks if the application supports reading files and
	// directories from URIs.
	SupportedTypes() []string
	// LaunchUrisFinish checks if the application supports reading files and
	// directories from URIs.
	LaunchUrisFinish(result AsyncResult) error
	// RemoveSupportsType checks if the application supports reading files and
	// directories from URIs.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension checks if the application supports reading files
	// and directories from URIs.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType checks if the application supports reading files and
	// directories from URIs.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType checks if the application supports reading files and
	// directories from URIs.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application supports reading files and
	// directories from URIs.
	ShouldShow() bool
	// SupportsFiles checks if the application supports reading files and
	// directories from URIs.
	SupportsFiles() bool
	// SupportsUris checks if the application supports reading files and
	// directories from URIs.
	SupportsUris() bool
}

// appInfo implements the AppInfo interface.
type appInfo struct {
	gextras.Objector
}

var _ AppInfo = (*appInfo)(nil)

// WrapAppInfo wraps a GObject to a type that implements
// interface AppInfo. It is primarily used internally.
func WrapAppInfo(obj *externglib.Object) AppInfo {
	return appInfo{
		Objector: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfo(obj), nil
}

func (a appInfo) AddSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) CanDelete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_can_delete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) CanRemoveSupportsType() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_can_remove_supports_type(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Delete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_delete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Dup() AppInfo {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_dup(_arg0)

	var _appInfo AppInfo // out

	_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppInfo)

	return _appInfo
}

func (a appInfo) Equal(appinfo2 AppInfo) bool {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(appinfo2.Native()))

	_cret = C.g_app_info_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) Commandline() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_commandline(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (a appInfo) Description() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) DisplayName() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_display_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) Executable() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_executable(_arg0)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

func (a appInfo) Icon() Icon {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_icon(_arg0)

	var _icon Icon // out

	_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Icon)

	return _icon
}

func (a appInfo) ID() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) Name() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a appInfo) SupportedTypes() []string {
	var _arg0 *C.GAppInfo // out
	var _cret **C.char

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_get_supported_types(_arg0)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

func (a appInfo) LaunchUrisFinish(result AsyncResult) error {
	var _arg0 *C.GAppInfo     // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_app_info_launch_uris_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) RemoveSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsDefaultForExtension(extension string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(extension))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsDefaultForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) SetAsLastUsedForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.char)(C.CString(contentType))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (a appInfo) ShouldShow() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_should_show(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) SupportsFiles() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_supports_files(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a appInfo) SupportsUris() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(a.Native()))

	_cret = C.g_app_info_supports_uris(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext interface {
	gextras.Objector

	Environment() []string

	LaunchFailedAppLaunchContext(startupNotifyId string)

	SetenvAppLaunchContext(variable string, value string)

	UnsetenvAppLaunchContext(variable string)
}

// appLaunchContext implements the AppLaunchContext class.
type appLaunchContext struct {
	gextras.Objector
}

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return appLaunchContext{
		Objector: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

func NewAppLaunchContext() AppLaunchContext {
	var _cret *C.GAppLaunchContext // in

	_cret = C.g_app_launch_context_new()

	var _appLaunchContext AppLaunchContext // out

	_appLaunchContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppLaunchContext)

	return _appLaunchContext
}

func (c appLaunchContext) Environment() []string {
	var _arg0 *C.GAppLaunchContext // out
	var _cret **C.char

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))

	_cret = C.g_app_launch_context_get_environment(_arg0)

	var _filenames []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_filenames = make([]string, i)
		for i := range src {
			_filenames[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _filenames
}

func (c appLaunchContext) LaunchFailedAppLaunchContext(startupNotifyId string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(startupNotifyId))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_launch_failed(_arg0, _arg1)
}

func (c appLaunchContext) SetenvAppLaunchContext(variable string, value string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out
	var _arg2 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_app_launch_context_setenv(_arg0, _arg1, _arg2)
}

func (c appLaunchContext) UnsetenvAppLaunchContext(variable string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_unsetenv(_arg0, _arg1)
}
