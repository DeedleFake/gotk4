// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_zlib_compressor_get_type()), F: marshalZlibCompressor},
	})
}

// ZlibCompressor: zlib decompression
type ZlibCompressor interface {
	gextras.Objector

	// AsConverter casts the class to the Converter interface.
	AsConverter() Converter

	// Convert: this is the main operation used when converting data. It is to
	// be called multiple times in a loop, and each time it will do some work,
	// i.e. producing some output (in @outbuf) or consuming some input (from
	// @inbuf) or both. If its not possible to do any work an error is returned.
	//
	// Note that a single call may not consume all input (or any input at all).
	// Also a call may produce output even if given no input, due to state
	// stored in the converter producing output.
	//
	// If any data was either produced or consumed, and then an error happens,
	// then only the successful conversion is reported and the error is returned
	// on the next call.
	//
	// A full conversion loop involves calling this method repeatedly, each time
	// giving it new input and space output space. When there is no more input
	// data after the data in @inbuf, the flag G_CONVERTER_INPUT_AT_END must be
	// set. The loop will be (unless some error happens) returning
	// G_CONVERTER_CONVERTED each time until all data is consumed and all output
	// is produced, then G_CONVERTER_FINISHED is returned instead. Note, that
	// G_CONVERTER_FINISHED may be returned even if G_CONVERTER_INPUT_AT_END is
	// not set, for instance in a decompression converter where the end of data
	// is detectable from the data (and there might even be other data after the
	// end of the compressed data).
	//
	// When some data has successfully been converted @bytes_read and is set to
	// the number of bytes read from @inbuf, and @bytes_written is set to
	// indicate how many bytes was written to @outbuf. If there are more data to
	// output or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified)
	// then G_CONVERTER_CONVERTED is returned, and if no more data is to be
	// output then G_CONVERTER_FINISHED is returned.
	//
	// On error G_CONVERTER_ERROR is returned and @error is set accordingly.
	// Some errors need special handling:
	//
	// G_IO_ERROR_NO_SPACE is returned if there is not enough space to write the
	// resulting converted data, the application should call the function again
	// with a larger @outbuf to continue.
	//
	// G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough input to
	// fully determine what the conversion should produce, and the
	// G_CONVERTER_INPUT_AT_END flag is not set. This happens for example with
	// an incomplete multibyte sequence when converting text, or when a regexp
	// matches up to the end of the input (and may match further input). It may
	// also happen when @inbuf_size is zero and there is no more data to
	// produce.
	//
	// When this happens the application should read more input and then call
	// the function again. If further input shows that there is no more data
	// call the function again with the same data but with the
	// G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion to
	// finish as e.g. in the regexp match case (or, to fail again with
	// G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the input is
	// actually partial).
	//
	// After g_converter_convert() has returned G_CONVERTER_FINISHED the
	// converter object is in an invalid state where its not allowed to call
	// g_converter_convert() anymore. At this time you can only free the object
	// or call g_converter_reset() to reset it to the initial state.
	//
	// If the flag G_CONVERTER_FLUSH is set then conversion is modified to try
	// to write out all internal state to the output. The application has to
	// call the function multiple times with the flag set, and when the
	// available input has been consumed and all internal state has been
	// produced then G_CONVERTER_FLUSHED (or G_CONVERTER_FINISHED if really at
	// the end) is returned instead of G_CONVERTER_CONVERTED. This is somewhat
	// similar to what happens at the end of the input stream, but done in the
	// middle of the data.
	//
	// This has different meanings for different conversions. For instance in a
	// compression converter it would mean that we flush all the compression
	// state into output such that if you uncompress the compressed data you get
	// back all the input data. Doing this may make the final file larger due to
	// padding though. Another example is a regexp conversion, where if you at
	// the end of the flushed data have a match, but there is also a potential
	// longer match. In the non-flushed case we would ask for more input, but
	// when flushing we treat this as the end of input and do the match.
	//
	// Flushing is not always possible (like if a charset converter flushes at a
	// partial multibyte sequence). Converters are supposed to try to produce as
	// much output as possible and then return an error (typically
	// G_IO_ERROR_PARTIAL_INPUT).
	//
	// This method is inherited from Converter
	Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error)
	// Reset resets all internal state in the converter, making it behave as if
	// it was just created. If the converter has any internal state that would
	// produce output then that output is lost.
	//
	// This method is inherited from Converter
	Reset()

	// FileInfo returns the Compressor:file-info property.
	FileInfo() FileInfo
	// SetFileInfo sets @file_info in @compressor. If non-nil, and @compressor's
	// Compressor:format property is G_ZLIB_COMPRESSOR_FORMAT_GZIP, it will be
	// used to set the file name and modification time in the GZIP header of the
	// compressed data.
	//
	// Note: it is an error to call this function while a compression is in
	// progress; it may only be called immediately after creation of
	// @compressor, or after resetting it with g_converter_reset().
	SetFileInfo(fileInfo FileInfo)
}

// zlibCompressor implements the ZlibCompressor interface.
type zlibCompressor struct {
	*externglib.Object
}

var _ ZlibCompressor = (*zlibCompressor)(nil)

// WrapZlibCompressor wraps a GObject to a type that implements
// interface ZlibCompressor. It is primarily used internally.
func WrapZlibCompressor(obj *externglib.Object) ZlibCompressor {
	return zlibCompressor{obj}
}

func marshalZlibCompressor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapZlibCompressor(obj), nil
}

// NewZlibCompressor creates a new Compressor.
func NewZlibCompressor(format ZlibCompressorFormat, level int) ZlibCompressor {
	var _arg1 C.GZlibCompressorFormat // out
	var _arg2 C.int                   // out
	var _cret *C.GZlibCompressor      // in

	_arg1 = C.GZlibCompressorFormat(format)
	_arg2 = C.int(level)

	_cret = C.g_zlib_compressor_new(_arg1, _arg2)

	var _zlibCompressor ZlibCompressor // out

	_zlibCompressor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ZlibCompressor)

	return _zlibCompressor
}

func (z zlibCompressor) AsConverter() Converter {
	return WrapConverter(gextras.InternObject(z))
}

func (c zlibCompressor) Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (bytesRead uint, bytesWritten uint, converterResult ConverterResult, goerr error) {
	return WrapConverter(gextras.InternObject(c)).Convert(inbuf, outbuf, flags)
}

func (c zlibCompressor) Reset() {
	WrapConverter(gextras.InternObject(c)).Reset()
}

func (c zlibCompressor) FileInfo() FileInfo {
	var _arg0 *C.GZlibCompressor // out
	var _cret *C.GFileInfo       // in

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))

	_cret = C.g_zlib_compressor_get_file_info(_arg0)

	var _fileInfo FileInfo // out

	_fileInfo = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileInfo)

	return _fileInfo
}

func (c zlibCompressor) SetFileInfo(fileInfo FileInfo) {
	var _arg0 *C.GZlibCompressor // out
	var _arg1 *C.GFileInfo       // out

	_arg0 = (*C.GZlibCompressor)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GFileInfo)(unsafe.Pointer(fileInfo.Native()))

	C.g_zlib_compressor_set_file_info(_arg0, _arg1)
}
