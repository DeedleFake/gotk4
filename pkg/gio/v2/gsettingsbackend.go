// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
	})
}

// NewKeyfileSettingsBackend creates a keyfile-backed Backend.
//
// The filename of the keyfile to use is given by @filename.
//
// All settings read to or written from the backend must fall under the path
// given in @root_path (which must start and end with a slash and not contain
// two consecutive slashes). @root_path may be "/".
//
// If @root_group is non-nil then it specifies the name of the keyfile group
// used for keys that are written directly below @root_path. For example, if
// @root_path is "/apps/example/" and @root_group is "toplevel", then settings
// the key "/apps/example/enabled" to a value of true will cause the following
// to appear in the keyfile:
//
//    [toplevel]
//    enabled=true
//
// If @root_group is nil then it is not permitted to store keys directly below
// the @root_path.
//
// For keys not stored directly below @root_path (ie: in a sub-path), the name
// of the subpath (with the final slash stripped) is used as the name of the
// keyfile group. To continue the example, if
// "/apps/example/profiles/default/font-size" were set to 12 then the following
// would appear in the keyfile:
//
//    [profiles/default]
//    font-size=12
//
// The backend will refuse writes (and return writability as being false) for
// keys outside of @root_path and, in the event that @root_group is nil, also
// for keys directly under @root_path. Writes will also be refused if the
// backend detects that it has the inability to rewrite the keyfile (ie: the
// containing directory is not writable).
//
// There is no checking done for your key namespace clashing with the syntax of
// the key file format. For example, if you have '[' or ']' characters in your
// path names or '=' in your key names you may be in trouble.
//
// The backend reads default values from a keyfile called `defaults` in the
// directory specified by the SettingsBackend:defaults-dir property, and a list
// of locked keys from a text file with the name `locks` in the same location.
func NewKeyfileSettingsBackend(filename string, rootPath string, rootGroup string) SettingsBackend {
	var _arg1 *C.gchar            // out
	var _arg2 *C.gchar            // out
	var _arg3 *C.gchar            // out
	var _cret *C.GSettingsBackend // in

	_arg1 = (*C.gchar)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(rootPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(rootGroup))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_keyfile_settings_backend_new(_arg1, _arg2, _arg3)

	var _settingsBackend SettingsBackend // out

	_settingsBackend = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SettingsBackend)

	return _settingsBackend
}

// NewMemorySettingsBackend creates a memory-backed Backend.
//
// This backend allows changes to settings, but does not write them to any
// backing storage, so the next time you run your application, the memory
// backend will start out with the default values again.
func NewMemorySettingsBackend() SettingsBackend {
	var _cret *C.GSettingsBackend // in

	_cret = C.g_memory_settings_backend_new()

	var _settingsBackend SettingsBackend // out

	_settingsBackend = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SettingsBackend)

	return _settingsBackend
}

// NewNullSettingsBackend creates a readonly Backend.
//
// This backend does not allow changes to settings, so all settings will always
// have their default values.
func NewNullSettingsBackend() SettingsBackend {
	var _cret *C.GSettingsBackend // in

	_cret = C.g_null_settings_backend_new()

	var _settingsBackend SettingsBackend // out

	_settingsBackend = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SettingsBackend)

	return _settingsBackend
}

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend interface {
	gextras.Objector

	// PathWritableChanged signals that the writability of all keys below a
	// given path may have changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	PathWritableChanged(path string)
	// WritableChanged signals that the writability of a single key has possibly
	// changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	WritableChanged(key string)
}

// settingsBackend implements the SettingsBackend class.
type settingsBackend struct {
	gextras.Objector
}

var _ SettingsBackend = (*settingsBackend)(nil)

// WrapSettingsBackend wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettingsBackend(obj *externglib.Object) SettingsBackend {
	return settingsBackend{
		Objector: obj,
	}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettingsBackend(obj), nil
}

// PathWritableChanged signals that the writability of all keys below a
// given path may have changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (b settingsBackend) PathWritableChanged(path string) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_backend_path_writable_changed(_arg0, _arg1)
}

// WritableChanged signals that the writability of a single key has possibly
// changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (b settingsBackend) WritableChanged(key string) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_backend_writable_changed(_arg0, _arg1)
}
