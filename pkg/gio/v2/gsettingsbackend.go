// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_settings_backend_get_type()), F: marshalSettingsBackend},
	})
}

// SettingsBackend: the Backend interface defines a generic interface for
// non-strictly-typed data that is stored in a hierarchy. To implement an
// alternative storage backend for #GSettings, you need to implement the Backend
// interface and then make it implement the extension point
// SETTINGS_BACKEND_EXTENSION_POINT_NAME.
//
// The interface defines methods for reading and writing values, a method for
// determining if writing of certain values will fail (lockdown) and a change
// notification mechanism.
//
// The semantics of the interface are very precisely defined and implementations
// must carefully adhere to the expectations of callers that are documented on
// each of the interface methods.
//
// Some of the Backend functions accept or return a #GTree. These trees always
// have strings as keys and #GVariant as values.
// g_settings_backend_create_tree() is a convenience function to create suitable
// trees.
//
// The Backend API is exported to allow third-party implementations, but does
// not carry the same stability guarantees as the public GIO API. For this
// reason, you have to define the C preprocessor symbol
// G_SETTINGS_ENABLE_BACKEND before including `gio/gsettingsbackend.h`.
type SettingsBackend interface {
	gextras.Objector

	// Changed signals that a single key has possibly changed. Backend
	// implementations should call this if a key has possibly changed its value.
	//
	// @key must be a valid key (ie starting with a slash, not containing '//',
	// and not ending with a slash).
	//
	// The implementation must call this function during any call to
	// g_settings_backend_write(), before the call returns (except in the case
	// that no keys are actually changed and it cares to detect this fact). It
	// may not rely on the existence of a mainloop for dispatching the signal
	// later.
	//
	// The implementation may call this function at any other time it likes in
	// response to other events (such as changes occurring outside of the
	// program). These calls may originate from a mainloop or may originate in
	// response to any other action (including from calls to
	// g_settings_backend_write()).
	//
	// In the case that this call is in response to a call to
	// g_settings_backend_write() then @origin_tag must be set to the same value
	// that was passed to that call.
	Changed(key string, originTag interface{})
	// ChangedTree: this call is a convenience wrapper. It gets the list of
	// changes from @tree, computes the longest common prefix and calls
	// g_settings_backend_changed().
	ChangedTree(tree *glib.Tree, originTag interface{})
	// KeysChanged signals that a list of keys have possibly changed. Backend
	// implementations should call this if keys have possibly changed their
	// values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//'). Each string in @items must form a valid key name when
	// @path is prefixed to it (ie: each item must not start or end with '/' and
	// must not contain '//').
	//
	// The meaning of this signal is that any of the key names resulting from
	// the contatenation of @path with each item in @items may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). These two calls can be used interchangeably
	// if exactly one item has changed (although in that case
	// g_settings_backend_changed() is definitely preferred).
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required.
	KeysChanged(path string, items []string, originTag interface{})
	// PathChanged signals that all keys below a given path may have possibly
	// changed. Backend implementations should call this if an entire path of
	// keys have possibly changed their values.
	//
	// @path must be a valid path (ie starting and ending with a slash and not
	// containing '//').
	//
	// The meaning of this signal is that any of the key which has a name
	// starting with @path may have changed.
	//
	// The same rules for when notifications must occur apply as per
	// g_settings_backend_changed(). This call might be an appropriate reasponse
	// to a 'reset' call but implementations are also free to explicitly list
	// the keys that were affected by that call if they can easily do so.
	//
	// For efficiency reasons, the implementation should strive for @path to be
	// as long as possible (ie: the longest common prefix of all of the keys
	// that were changed) but this is not strictly required. As an example, if
	// this function is called with the path of "/" then every single key in the
	// application will be notified of a possible change.
	PathChanged(path string, originTag interface{})
	// PathWritableChanged signals that the writability of all keys below a
	// given path may have changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	PathWritableChanged(path string)
	// WritableChanged signals that the writability of a single key has possibly
	// changed.
	//
	// Since GSettings performs no locking operations for itself, this call will
	// always be made in response to external events.
	WritableChanged(key string)
}

// settingsBackend implements the SettingsBackend interface.
type settingsBackend struct {
	gextras.Objector
}

var _ SettingsBackend = (*settingsBackend)(nil)

// WrapSettingsBackend wraps a GObject to the right type. It is
// primarily used internally.
func WrapSettingsBackend(obj *externglib.Object) SettingsBackend {
	return SettingsBackend{
		Objector: obj,
	}
}

func marshalSettingsBackend(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSettingsBackend(obj), nil
}

// Changed signals that a single key has possibly changed. Backend
// implementations should call this if a key has possibly changed its value.
//
// @key must be a valid key (ie starting with a slash, not containing '//',
// and not ending with a slash).
//
// The implementation must call this function during any call to
// g_settings_backend_write(), before the call returns (except in the case
// that no keys are actually changed and it cares to detect this fact). It
// may not rely on the existence of a mainloop for dispatching the signal
// later.
//
// The implementation may call this function at any other time it likes in
// response to other events (such as changes occurring outside of the
// program). These calls may originate from a mainloop or may originate in
// response to any other action (including from calls to
// g_settings_backend_write()).
//
// In the case that this call is in response to a call to
// g_settings_backend_write() then @origin_tag must be set to the same value
// that was passed to that call.
func (b settingsBackend) Changed(key string, originTag interface{}) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gpointer          // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(originTag)

	C.g_settings_backend_changed(_arg0, _arg1, _arg2)
}

// ChangedTree: this call is a convenience wrapper. It gets the list of
// changes from @tree, computes the longest common prefix and calls
// g_settings_backend_changed().
func (b settingsBackend) ChangedTree(tree *glib.Tree, originTag interface{}) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.GTree            // out
	var _arg2 C.gpointer          // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GTree)(unsafe.Pointer(tree.Native()))
	_arg2 = C.gpointer(originTag)

	C.g_settings_backend_changed_tree(_arg0, _arg1, _arg2)
}

// KeysChanged signals that a list of keys have possibly changed. Backend
// implementations should call this if keys have possibly changed their
// values.
//
// @path must be a valid path (ie starting and ending with a slash and not
// containing '//'). Each string in @items must form a valid key name when
// @path is prefixed to it (ie: each item must not start or end with '/' and
// must not contain '//').
//
// The meaning of this signal is that any of the key names resulting from
// the contatenation of @path with each item in @items may have changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed(). These two calls can be used interchangeably
// if exactly one item has changed (although in that case
// g_settings_backend_changed() is definitely preferred).
//
// For efficiency reasons, the implementation should strive for @path to be
// as long as possible (ie: the longest common prefix of all of the keys
// that were changed) but this is not strictly required.
func (b settingsBackend) KeysChanged(path string, items []string, originTag interface{}) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out
	var _arg2 **C.gchar
	var _arg3 C.gpointer // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (**C.gchar)(C.malloc((len(items) + 1) * unsafe.Sizeof(int(0))))
	defer C.free(unsafe.Pointer(_arg2))

	{
		var out []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg2), int(len(items)))

		for i := range items {
			_arg2 = (*C.gchar)(C.CString(items))
			defer C.free(unsafe.Pointer(_arg2))
		}
	}
	_arg3 = C.gpointer(originTag)

	C.g_settings_backend_keys_changed(_arg0, _arg1, _arg2, _arg3)
}

// PathChanged signals that all keys below a given path may have possibly
// changed. Backend implementations should call this if an entire path of
// keys have possibly changed their values.
//
// @path must be a valid path (ie starting and ending with a slash and not
// containing '//').
//
// The meaning of this signal is that any of the key which has a name
// starting with @path may have changed.
//
// The same rules for when notifications must occur apply as per
// g_settings_backend_changed(). This call might be an appropriate reasponse
// to a 'reset' call but implementations are also free to explicitly list
// the keys that were affected by that call if they can easily do so.
//
// For efficiency reasons, the implementation should strive for @path to be
// as long as possible (ie: the longest common prefix of all of the keys
// that were changed) but this is not strictly required. As an example, if
// this function is called with the path of "/" then every single key in the
// application will be notified of a possible change.
func (b settingsBackend) PathChanged(path string, originTag interface{}) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gpointer          // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gpointer(originTag)

	C.g_settings_backend_path_changed(_arg0, _arg1, _arg2)
}

// PathWritableChanged signals that the writability of all keys below a
// given path may have changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (b settingsBackend) PathWritableChanged(path string) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_backend_path_writable_changed(_arg0, _arg1)
}

// WritableChanged signals that the writability of a single key has possibly
// changed.
//
// Since GSettings performs no locking operations for itself, this call will
// always be made in response to external events.
func (b settingsBackend) WritableChanged(key string) {
	var _arg0 *C.GSettingsBackend // out
	var _arg1 *C.gchar            // out

	_arg0 = (*C.GSettingsBackend)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.gchar)(C.CString(key))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_backend_writable_changed(_arg0, _arg1)
}
