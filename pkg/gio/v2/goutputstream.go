// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_output_stream_get_type()), F: marshalOutputStream},
	})
}

// OutputStream has functions to write to a stream (g_output_stream_write()), to
// close a stream (g_output_stream_close()) and to flush pending writes
// (g_output_stream_flush()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type OutputStream interface {
	gextras.Objector

	ClearPendingOutputStream()

	CloseOutputStream(cancellable Cancellable) error

	CloseAsyncOutputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	CloseFinishOutputStream(result AsyncResult) error

	FlushOutputStream(cancellable Cancellable) error

	FlushAsyncOutputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	FlushFinishOutputStream(result AsyncResult) error

	HasPendingOutputStream() bool

	IsClosedOutputStream() bool

	IsClosingOutputStream() bool

	SetPendingOutputStream() error

	SpliceOutputStream(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error)

	SpliceAsyncOutputStream(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	SpliceFinishOutputStream(result AsyncResult) (int, error)

	WriteOutputStream(buffer []byte, cancellable Cancellable) (int, error)

	WriteAllOutputStream(buffer []byte, cancellable Cancellable) (uint, error)

	WriteAllAsyncOutputStream(buffer []byte, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	WriteAllFinishOutputStream(result AsyncResult) (uint, error)

	WriteAsyncOutputStream(buffer []byte, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	WriteBytesFinishOutputStream(result AsyncResult) (int, error)

	WriteFinishOutputStream(result AsyncResult) (int, error)

	WritevOutputStream(vectors []OutputVector, cancellable Cancellable) (uint, error)

	WritevAllOutputStream(vectors []OutputVector, cancellable Cancellable) (uint, error)

	WritevAllAsyncOutputStream(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	WritevAllFinishOutputStream(result AsyncResult) (uint, error)

	WritevAsyncOutputStream(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	WritevFinishOutputStream(result AsyncResult) (uint, error)
}

// outputStream implements the OutputStream class.
type outputStream struct {
	gextras.Objector
}

// WrapOutputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapOutputStream(obj *externglib.Object) OutputStream {
	return outputStream{
		Objector: obj,
	}
}

func marshalOutputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapOutputStream(obj), nil
}

func (s outputStream) ClearPendingOutputStream() {
	var _arg0 *C.GOutputStream // out

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	C.g_output_stream_clear_pending(_arg0)
}

func (s outputStream) CloseOutputStream(cancellable Cancellable) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) CloseAsyncOutputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream      // out
	var _arg1 C.int                 // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(ioPriority)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_output_stream_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s outputStream) CloseFinishOutputStream(result AsyncResult) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) FlushOutputStream(cancellable Cancellable) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GCancellable  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_flush(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) FlushAsyncOutputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream      // out
	var _arg1 C.int                 // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(ioPriority)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_output_stream_flush_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s outputStream) FlushFinishOutputStream(result AsyncResult) error {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) HasPendingOutputStream() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) IsClosedOutputStream() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) IsClosingOutputStream() bool {
	var _arg0 *C.GOutputStream // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_output_stream_is_closing(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s outputStream) SetPendingOutputStream() error {
	var _arg0 *C.GOutputStream // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))

	C.g_output_stream_set_pending(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s outputStream) SpliceOutputStream(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var _arg0 *C.GOutputStream           // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _arg3 *C.GCancellable            // out
	var _cret C.gssize                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInputStream)(unsafe.Pointer(source.Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_output_stream_splice(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) SpliceAsyncOutputStream(source InputStream, flags OutputStreamSpliceFlags, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream           // out
	var _arg1 *C.GInputStream            // out
	var _arg2 C.GOutputStreamSpliceFlags // out
	var _arg3 C.int                      // out
	var _arg4 *C.GCancellable            // out
	var _arg5 C.GAsyncReadyCallback      // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GInputStream)(unsafe.Pointer(source.Native()))
	_arg2 = C.GOutputStreamSpliceFlags(flags)
	_arg3 = C.int(ioPriority)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg6 = C.gpointer(box.Assign(callback))

	C.g_output_stream_splice_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s outputStream) SpliceFinishOutputStream(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_splice_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WriteOutputStream(buffer []byte, cancellable Cancellable) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_output_stream_write(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WriteAllOutputStream(buffer []byte, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_write_all(_arg0, unsafe.Pointer(_arg1), _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WriteAllAsyncOutputStream(buffer []byte, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg4 *C.GCancellable       // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = C.int(ioPriority)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg6 = C.gpointer(box.Assign(callback))

	C.g_output_stream_write_all_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s outputStream) WriteAllFinishOutputStream(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_write_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WriteAsyncOutputStream(buffer []byte, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.void
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg4 *C.GCancellable       // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(buffer))
	_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	_arg3 = C.int(ioPriority)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg6 = C.gpointer(box.Assign(callback))

	C.g_output_stream_write_async(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s outputStream) WriteBytesFinishOutputStream(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_write_bytes_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WriteFinishOutputStream(result AsyncResult) (int, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _cret C.gssize         // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_output_stream_write_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s outputStream) WritevOutputStream(vectors []OutputVector, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_writev(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevAllOutputStream(vectors []OutputVector, cancellable Cancellable) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.gsize         // in
	var _arg4 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_output_stream_writev_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevAllAsyncOutputStream(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg4 *C.GCancellable       // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg3 = C.int(ioPriority)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg6 = C.gpointer(box.Assign(callback))

	C.g_output_stream_writev_all_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s outputStream) WritevAllFinishOutputStream(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_writev_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}

func (s outputStream) WritevAsyncOutputStream(vectors []OutputVector, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GOutputVector
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg4 *C.GCancellable       // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg2 = C.gsize(len(vectors))
	_arg1 = (*C.GOutputVector)(unsafe.Pointer(&vectors[0]))
	_arg3 = C.int(ioPriority)
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg5 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg6 = C.gpointer(box.Assign(callback))

	C.g_output_stream_writev_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (s outputStream) WritevFinishOutputStream(result AsyncResult) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_output_stream_writev_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesWritten, _goerr
}
