// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_tls_client_connection_get_type()), F: marshalTLSClientConnection},
	})
}

// NewTLSClientConnection creates a new ClientConnection wrapping
// @base_io_stream (which must have pollable input and output streams) which is
// assumed to communicate with the server identified by @server_identity.
//
// See the documentation for Connection:base-io-stream for restrictions on when
// application code can run operations on the @base_io_stream after this
// function has returned.
func NewTLSClientConnection(baseIOStream IOStream, serverIdentity SocketConnectable) (tlsClientConnection TLSClientConnection, err error) {
	var arg1 *C.GIOStream
	var arg2 *C.GSocketConnectable
	var gError *C.GError

	arg1 = (*C.GIOStream)(baseIOStream.Native())
	arg2 = (*C.GSocketConnectable)(serverIdentity.Native())

	ret := C.g_tls_client_connection_new(arg1, arg2, &gError)

	var ret0 TLSClientConnection
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(TLSClientConnection)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// TLSClientConnectionOverrider contains methods that are overridable. This
// interface is a subset of the interface TLSClientConnection.
type TLSClientConnectionOverrider interface {
	// CopySessionState: possibly copies session state from one connection to
	// another, for use in TLS session resumption. This is not normally needed,
	// but may be used when the same session needs to be used between different
	// endpoints, as is required by some protocols, such as FTP over TLS.
	// @source should have already completed a handshake and, since TLS 1.3, it
	// should have been used to read data at least once. @conn should not have
	// completed a handshake.
	//
	// It is not possible to know whether a call to this function will actually
	// do anything. Because session resumption is normally used only for
	// performance benefit, the TLS backend might not implement this function.
	// Even if implemented, it may not actually succeed in allowing @conn to
	// resume @source's TLS session, because the server may not have sent a
	// session resumption token to @source, or it may refuse to accept the token
	// from @conn. There is no way to know whether a call to this function is
	// actually successful.
	//
	// Using this function is not required to benefit from session resumption.
	// If the TLS backend supports session resumption, the session will be
	// resumed automatically if it is possible to do so without weakening the
	// privacy guarantees normally provided by TLS, without need to call this
	// function. For example, with TLS 1.3, a session ticket will be
	// automatically copied from any ClientConnection that has previously
	// received session tickets from the server, provided a ticket is available
	// that has not previously been used for session resumption, since session
	// ticket reuse would be a privacy weakness. Using this function causes the
	// ticket to be copied without regard for privacy considerations.
	CopySessionState(source TLSClientConnection)
}

// TLSClientConnection is the client-side subclass of Connection, representing a
// client-side TLS connection.
type TLSClientConnection interface {
	TLSConnection
	TLSClientConnectionOverrider

	// AcceptedCAS gets the list of distinguished names of the Certificate
	// Authorities that the server will accept certificates from. This will be
	// set during the TLS handshake if the server requests a certificate.
	// Otherwise, it will be nil.
	//
	// Each item in the list is a Array which contains the complete subject DN
	// of the certificate authority.
	AcceptedCAS() *glib.List
	// ServerIdentity gets @conn's expected server identity
	ServerIdentity() SocketConnectable
	// UseSSL3: SSL 3.0 is no longer supported. See
	// g_tls_client_connection_set_use_ssl3() for details.
	UseSSL3() bool
	// ValidationFlags gets @conn's validation flags
	ValidationFlags() TLSCertificateFlags
	// SetServerIdentity sets @conn's expected server identity, which is used
	// both to tell servers on virtual hosts which certificate to present, and
	// also to let @conn know what name to look for in the certificate when
	// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(identity SocketConnectable)
	// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
	//
	// From GLib 2.42.1 through GLib 2.62, this function could be used to force
	// use of TLS 1.0, the lowest-supported TLS protocol version at the time. In
	// the past, this was needed to connect to broken TLS servers that exhibited
	// protocol version intolerance. Such servers are no longer common, and
	// using TLS 1.0 is no longer considered acceptable.
	//
	// Since GLib 2.64, this function does nothing.
	SetUseSSL3(useSSL3 bool)
	// SetValidationFlags sets @conn's validation flags, to override the default
	// set of checks performed when validating a server certificate. By default,
	// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	SetValidationFlags(flags TLSCertificateFlags)
}

// tlsClientConnection implements the TLSClientConnection interface.
type tlsClientConnection struct {
	TLSConnection
}

var _ TLSClientConnection = (*tlsClientConnection)(nil)

// WrapTLSClientConnection wraps a GObject to a type that implements interface
// TLSClientConnection. It is primarily used internally.
func WrapTLSClientConnection(obj *externglib.Object) TLSClientConnection {
	return TLSClientConnection{
		TLSConnection: WrapTLSConnection(obj),
	}
}

func marshalTLSClientConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTLSClientConnection(obj), nil
}

// CopySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed,
// but may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS.
// @source should have already completed a handshake and, since TLS 1.3, it
// should have been used to read data at least once. @conn should not have
// completed a handshake.
//
// It is not possible to know whether a call to this function will actually
// do anything. Because session resumption is normally used only for
// performance benefit, the TLS backend might not implement this function.
// Even if implemented, it may not actually succeed in allowing @conn to
// resume @source's TLS session, because the server may not have sent a
// session resumption token to @source, or it may refuse to accept the token
// from @conn. There is no way to know whether a call to this function is
// actually successful.
//
// Using this function is not required to benefit from session resumption.
// If the TLS backend supports session resumption, the session will be
// resumed automatically if it is possible to do so without weakening the
// privacy guarantees normally provided by TLS, without need to call this
// function. For example, with TLS 1.3, a session ticket will be
// automatically copied from any ClientConnection that has previously
// received session tickets from the server, provided a ticket is available
// that has not previously been used for session resumption, since session
// ticket reuse would be a privacy weakness. Using this function causes the
// ticket to be copied without regard for privacy considerations.
func (c tlsClientConnection) CopySessionState(source TLSClientConnection) {
	var arg0 *C.GTlsClientConnection
	var arg1 *C.GTlsClientConnection

	arg0 = (*C.GTlsClientConnection)(c.Native())
	arg1 = (*C.GTlsClientConnection)(source.Native())

	C.g_tls_client_connection_copy_session_state(arg0, arg1)
}

// AcceptedCAS gets the list of distinguished names of the Certificate
// Authorities that the server will accept certificates from. This will be
// set during the TLS handshake if the server requests a certificate.
// Otherwise, it will be nil.
//
// Each item in the list is a Array which contains the complete subject DN
// of the certificate authority.
func (c tlsClientConnection) AcceptedCAS() *glib.List {
	var arg0 *C.GTlsClientConnection

	arg0 = (*C.GTlsClientConnection)(c.Native())

	ret := C.g_tls_client_connection_get_accepted_cas(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ServerIdentity gets @conn's expected server identity
func (c tlsClientConnection) ServerIdentity() SocketConnectable {
	var arg0 *C.GTlsClientConnection

	arg0 = (*C.GTlsClientConnection)(c.Native())

	ret := C.g_tls_client_connection_get_server_identity(arg0)

	var ret0 SocketConnectable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(SocketConnectable)

	return ret0
}

// UseSSL3: SSL 3.0 is no longer supported. See
// g_tls_client_connection_set_use_ssl3() for details.
func (c tlsClientConnection) UseSSL3() bool {
	var arg0 *C.GTlsClientConnection

	arg0 = (*C.GTlsClientConnection)(c.Native())

	ret := C.g_tls_client_connection_get_use_ssl3(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ValidationFlags gets @conn's validation flags
func (c tlsClientConnection) ValidationFlags() TLSCertificateFlags {
	var arg0 *C.GTlsClientConnection

	arg0 = (*C.GTlsClientConnection)(c.Native())

	ret := C.g_tls_client_connection_get_validation_flags(arg0)

	var ret0 TLSCertificateFlags

	ret0 = TLSCertificateFlags(ret)

	return ret0
}

// SetServerIdentity sets @conn's expected server identity, which is used
// both to tell servers on virtual hosts which certificate to present, and
// also to let @conn know what name to look for in the certificate when
// performing G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
func (c tlsClientConnection) SetServerIdentity(identity SocketConnectable) {
	var arg0 *C.GTlsClientConnection
	var arg1 *C.GSocketConnectable

	arg0 = (*C.GTlsClientConnection)(c.Native())
	arg1 = (*C.GSocketConnectable)(identity.Native())

	C.g_tls_client_connection_set_server_identity(arg0, arg1)
}

// SetUseSSL3: since GLib 2.42.1, SSL 3.0 is no longer supported.
//
// From GLib 2.42.1 through GLib 2.62, this function could be used to force
// use of TLS 1.0, the lowest-supported TLS protocol version at the time. In
// the past, this was needed to connect to broken TLS servers that exhibited
// protocol version intolerance. Such servers are no longer common, and
// using TLS 1.0 is no longer considered acceptable.
//
// Since GLib 2.64, this function does nothing.
func (c tlsClientConnection) SetUseSSL3(useSSL3 bool) {
	var arg0 *C.GTlsClientConnection
	var arg1 C.gboolean

	arg0 = (*C.GTlsClientConnection)(c.Native())
	if useSSL3 {
		arg1 = C.TRUE
	}

	C.g_tls_client_connection_set_use_ssl3(arg0, arg1)
}

// SetValidationFlags sets @conn's validation flags, to override the default
// set of checks performed when validating a server certificate. By default,
// G_TLS_CERTIFICATE_VALIDATE_ALL is used.
func (c tlsClientConnection) SetValidationFlags(flags TLSCertificateFlags) {
	var arg0 *C.GTlsClientConnection
	var arg1 C.GTlsCertificateFlags

	arg0 = (*C.GTlsClientConnection)(c.Native())
	arg1 = (C.GTlsCertificateFlags)(flags)

	C.g_tls_client_connection_set_validation_flags(arg0, arg1)
}
