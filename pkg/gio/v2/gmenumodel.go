// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_menu_attribute_iter_get_type()), F: marshalMenuAttributeIter},
		{T: externglib.Type(C.g_menu_link_iter_get_type()), F: marshalMenuLinkIter},
		{T: externglib.Type(C.g_menu_model_get_type()), F: marshalMenuModel},
	})
}

type MenuAttributeIterPrivate struct {
	native C.GMenuAttributeIterPrivate
}

// WrapMenuAttributeIterPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuAttributeIterPrivate(ptr unsafe.Pointer) *MenuAttributeIterPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuAttributeIterPrivate)(ptr)
}

func marshalMenuAttributeIterPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuAttributeIterPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuAttributeIterPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuLinkIterPrivate struct {
	native C.GMenuLinkIterPrivate
}

// WrapMenuLinkIterPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuLinkIterPrivate(ptr unsafe.Pointer) *MenuLinkIterPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuLinkIterPrivate)(ptr)
}

func marshalMenuLinkIterPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuLinkIterPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuLinkIterPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

type MenuModelPrivate struct {
	native C.GMenuModelPrivate
}

// WrapMenuModelPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMenuModelPrivate(ptr unsafe.Pointer) *MenuModelPrivate {
	if ptr == nil {
		return nil
	}

	return (*MenuModelPrivate)(ptr)
}

func marshalMenuModelPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMenuModelPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *MenuModelPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter interface {
	gextras.Objector

	// Name gets the name of the attribute at the current iterator position, as
	// a string.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute. If
	// that fails, then false is returned and there are no other effects.
	//
	// If successful, @name and @value are set to the name and value of the
	// attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in @name remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	GetNext() (outName string, value *glib.Variant, ok bool)
	// Value gets the value of the attribute at the current iterator position.
	//
	// The iterator is not advanced.
	Value() *glib.Variant
	// Next attempts to advance the iterator to the next (possibly first)
	// attribute.
	//
	// true is returned on success, or false if there are no more attributes.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first attribute (and determine if the first attribute
	// exists at all).
	Next() bool
}

// menuAttributeIter implements the MenuAttributeIter interface.
type menuAttributeIter struct {
	gextras.Objector
}

var _ MenuAttributeIter = (*menuAttributeIter)(nil)

// WrapMenuAttributeIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuAttributeIter(obj *externglib.Object) MenuAttributeIter {
	return MenuAttributeIter{
		Objector: obj,
	}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuAttributeIter(obj), nil
}

// Name gets the name of the attribute at the current iterator position, as
// a string.
//
// The iterator is not advanced.
func (i menuAttributeIter) Name() string {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(i.Native())

	ret := C.g_menu_attribute_iter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetNext: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) attribute. If
// that fails, then false is returned and there are no other effects.
//
// If successful, @name and @value are set to the name and value of the
// attribute that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
// will return the same values again.
//
// The value returned in @name remains valid for as long as the iterator
// remains at the current position. The value returned in @value must be
// unreffed using g_variant_unref() when it is no longer in use.
func (i menuAttributeIter) GetNext() (outName string, value *glib.Variant, ok bool) {
	var arg0 *C.GMenuAttributeIter
	var arg1 **C.gchar    // out
	var arg2 **C.GVariant // out

	arg0 = (*C.GMenuAttributeIter)(i.Native())

	ret := C.g_menu_attribute_iter_get_next(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 **glib.Variant
	var ret2 bool

	ret0 = C.GoString(arg1)

	{
		ret1 = glib.WrapVariant(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret1, func(v **glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	ret2 = C.bool(ret) != 0

	return ret0, ret1, ret2
}

// Value gets the value of the attribute at the current iterator position.
//
// The iterator is not advanced.
func (i menuAttributeIter) Value() *glib.Variant {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(i.Native())

	ret := C.g_menu_attribute_iter_get_value(arg0)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Next attempts to advance the iterator to the next (possibly first)
// attribute.
//
// true is returned on success, or false if there are no more attributes.
//
// You must call this function when you first acquire the iterator to
// advance it to the first attribute (and determine if the first attribute
// exists at all).
func (i menuAttributeIter) Next() bool {
	var arg0 *C.GMenuAttributeIter

	arg0 = (*C.GMenuAttributeIter)(i.Native())

	ret := C.g_menu_attribute_iter_next(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter interface {
	gextras.Objector

	// Name gets the name of the link at the current iterator position.
	//
	// The iterator is not advanced.
	Name() string
	// GetNext: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link. If that
	// fails, then false is returned and there are no other effects.
	//
	// If successful, @out_link and @value are set to the name and Model of the
	// link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in @value must be
	// unreffed using g_object_unref() when it is no longer in use.
	GetNext() (outLink string, value MenuModel, ok bool)
	// Value gets the linked Model at the current iterator position.
	//
	// The iterator is not advanced.
	Value() MenuModel
	// Next attempts to advance the iterator to the next (possibly first) link.
	//
	// true is returned on success, or false if there are no more links.
	//
	// You must call this function when you first acquire the iterator to
	// advance it to the first link (and determine if the first link exists at
	// all).
	Next() bool
}

// menuLinkIter implements the MenuLinkIter interface.
type menuLinkIter struct {
	gextras.Objector
}

var _ MenuLinkIter = (*menuLinkIter)(nil)

// WrapMenuLinkIter wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuLinkIter(obj *externglib.Object) MenuLinkIter {
	return MenuLinkIter{
		Objector: obj,
	}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuLinkIter(obj), nil
}

// Name gets the name of the link at the current iterator position.
//
// The iterator is not advanced.
func (i menuLinkIter) Name() string {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(i.Native())

	ret := C.g_menu_link_iter_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetNext: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then false is returned and there are no other effects.
//
// If successful, @out_link and @value are set to the name and Model of the
// link that has just been advanced to. At this point,
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
// the same values again.
//
// The value returned in @out_link remains valid for as long as the iterator
// remains at the current position. The value returned in @value must be
// unreffed using g_object_unref() when it is no longer in use.
func (i menuLinkIter) GetNext() (outLink string, value MenuModel, ok bool) {
	var arg0 *C.GMenuLinkIter
	var arg1 **C.gchar      // out
	var arg2 **C.GMenuModel // out

	arg0 = (*C.GMenuLinkIter)(i.Native())

	ret := C.g_menu_link_iter_get_next(arg0, &arg1, &arg2)

	var ret0 string
	var ret1 MenuModel
	var ret2 bool

	ret0 = C.GoString(arg1)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg2.Native()))).(MenuModel)

	ret2 = C.bool(ret) != 0

	return ret0, ret1, ret2
}

// Value gets the linked Model at the current iterator position.
//
// The iterator is not advanced.
func (i menuLinkIter) Value() MenuModel {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(i.Native())

	ret := C.g_menu_link_iter_get_value(arg0)

	var ret0 MenuModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(MenuModel)

	return ret0
}

// Next attempts to advance the iterator to the next (possibly first) link.
//
// true is returned on success, or false if there are no more links.
//
// You must call this function when you first acquire the iterator to
// advance it to the first link (and determine if the first link exists at
// all).
func (i menuLinkIter) Next() bool {
	var arg0 *C.GMenuLinkIter

	arg0 = (*C.GMenuLinkIter)(i.Native())

	ret := C.g_menu_link_iter_next(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
//
// An example menu
//
// ! (menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items) - the View submenu (containing 3
// sections) - the first section of the View submenu (containing 2 items) - the
// second section of the View submenu (containing 1 item) - the final section of
// the View submenu (containing 1 item) - the Highlight Mode submenu (containing
// 2 sections) - the Sources section (containing 2 items) - the Markup section
// (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
//
// A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information: - an action with no parameter type and no state - an action with
// no parameter type and boolean state - an action with string parameter type
// and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel interface {
	gextras.Objector

	// ItemAttributeValue queries the item at position @item_index in @model for
	// the attribute specified by @attribute.
	//
	// If @expected_type is non-nil then it specifies the expected type of the
	// attribute. If it is nil then any type will be accepted.
	//
	// If the attribute exists and matches @expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// nil is returned.
	ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemLink queries the item at position @item_index in @model for the link
	// specified by @link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, nil is returned.
	ItemLink(itemIndex int, link string) MenuModel
	// NItems: query the number of items in @model.
	NItems() int
	// IsMutable queries if @model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	IsMutable() bool
	// ItemsChanged requests emission of the Model::items-changed signal on
	// @model.
	//
	// This function should never be called except by Model subclasses. Any
	// other calls to this function will very likely lead to a violation of the
	// interface of the model.
	//
	// The implementation should update its internal representation of the menu
	// before emitting the signal. The implementation should further expect to
	// receive queries about the new state of the menu (and particularly added
	// menu items) while signal handlers are running.
	//
	// The implementation must dispatch this call directly from a mainloop entry
	// and not in response to calls -- particularly those from the Model API.
	// Said another way: the menu must not change while user code is running
	// without returning to the mainloop.
	ItemsChanged(position int, removed int, added int)
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes(itemIndex int) MenuAttributeIter
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position @item_index in @model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks(itemIndex int) MenuLinkIter
}

// menuModel implements the MenuModel interface.
type menuModel struct {
	gextras.Objector
}

var _ MenuModel = (*menuModel)(nil)

// WrapMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuModel(obj *externglib.Object) MenuModel {
	return MenuModel{
		Objector: obj,
	}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuModel(obj), nil
}

// ItemAttributeValue queries the item at position @item_index in @model for
// the attribute specified by @attribute.
//
// If @expected_type is non-nil then it specifies the expected type of the
// attribute. If it is nil then any type will be accepted.
//
// If the attribute exists and matches @expected_type (or if the expected
// type is unspecified) then the value is returned.
//
// If the attribute does not exist, or does not match the expected type then
// nil is returned.
func (m menuModel) ItemAttributeValue(itemIndex int, attribute string, expectedType *glib.VariantType) *glib.Variant {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 *C.gchar
	var arg3 *C.GVariantType

	arg0 = (*C.GMenuModel)(m.Native())
	arg1 = C.gint(itemIndex)
	arg2 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GVariantType)(expectedType.Native())

	ret := C.g_menu_model_get_item_attribute_value(arg0, arg1, arg2, arg3)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// ItemLink queries the item at position @item_index in @model for the link
// specified by @link.
//
// If the link exists, the linked Model is returned. If the link does not
// exist, nil is returned.
func (m menuModel) ItemLink(itemIndex int, link string) MenuModel {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 *C.gchar

	arg0 = (*C.GMenuModel)(m.Native())
	arg1 = C.gint(itemIndex)
	arg2 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(arg2))

	ret := C.g_menu_model_get_item_link(arg0, arg1, arg2)

	var ret0 MenuModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(MenuModel)

	return ret0
}

// NItems: query the number of items in @model.
func (m menuModel) NItems() int {
	var arg0 *C.GMenuModel

	arg0 = (*C.GMenuModel)(m.Native())

	ret := C.g_menu_model_get_n_items(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// IsMutable queries if @model is mutable.
//
// An immutable Model will never emit the Model::items-changed signal.
// Consumers of the model may make optimisations accordingly.
func (m menuModel) IsMutable() bool {
	var arg0 *C.GMenuModel

	arg0 = (*C.GMenuModel)(m.Native())

	ret := C.g_menu_model_is_mutable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// ItemsChanged requests emission of the Model::items-changed signal on
// @model.
//
// This function should never be called except by Model subclasses. Any
// other calls to this function will very likely lead to a violation of the
// interface of the model.
//
// The implementation should update its internal representation of the menu
// before emitting the signal. The implementation should further expect to
// receive queries about the new state of the menu (and particularly added
// menu items) while signal handlers are running.
//
// The implementation must dispatch this call directly from a mainloop entry
// and not in response to calls -- particularly those from the Model API.
// Said another way: the menu must not change while user code is running
// without returning to the mainloop.
func (m menuModel) ItemsChanged(position int, removed int, added int) {
	var arg0 *C.GMenuModel
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GMenuModel)(m.Native())
	arg1 = C.gint(position)
	arg2 = C.gint(removed)
	arg3 = C.gint(added)

	C.g_menu_model_items_changed(arg0, arg1, arg2, arg3)
}

// IterateItemAttributes creates a AttributeIter to iterate over the
// attributes of the item at position @item_index in @model.
//
// You must free the iterator with g_object_unref() when you are done.
func (m menuModel) IterateItemAttributes(itemIndex int) MenuAttributeIter {
	var arg0 *C.GMenuModel
	var arg1 C.gint

	arg0 = (*C.GMenuModel)(m.Native())
	arg1 = C.gint(itemIndex)

	ret := C.g_menu_model_iterate_item_attributes(arg0, arg1)

	var ret0 MenuAttributeIter

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(MenuAttributeIter)

	return ret0
}

// IterateItemLinks creates a LinkIter to iterate over the links of the item
// at position @item_index in @model.
//
// You must free the iterator with g_object_unref() when you are done.
func (m menuModel) IterateItemLinks(itemIndex int) MenuLinkIter {
	var arg0 *C.GMenuModel
	var arg1 C.gint

	arg0 = (*C.GMenuModel)(m.Native())
	arg1 = C.gint(itemIndex)

	ret := C.g_menu_model_iterate_item_links(arg0, arg1)

	var ret0 MenuLinkIter

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(MenuLinkIter)

	return ret0
}
