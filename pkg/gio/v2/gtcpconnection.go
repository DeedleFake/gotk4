// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_tcp_connection_get_type()), F: marshalTcpConnection},
	})
}

// TcpConnection: this is the subclass of Connection that is created for TCP/IP
// sockets.
type TcpConnection interface {
	SocketConnection

	// GracefulDisconnect checks if graceful disconnects are used. See
	// g_tcp_connection_set_graceful_disconnect().
	GracefulDisconnect() bool
	// SetGracefulDisconnect: this enables graceful disconnects on close. A
	// graceful disconnect means that we signal the receiving end that the
	// connection is terminated and wait for it to close the connection before
	// closing the connection.
	//
	// A graceful disconnect means that we can be sure that we successfully sent
	// all the outstanding data to the other end, or get an error reported.
	// However, it also means we have to wait for all the data to reach the
	// other side and for it to acknowledge this by closing the socket, which
	// may take a while. For this reason it is disabled by default.
	SetGracefulDisconnect(gracefulDisconnect bool)
}

// tcpConnection implements the TcpConnection interface.
type tcpConnection struct {
	SocketConnection
}

var _ TcpConnection = (*tcpConnection)(nil)

// WrapTcpConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapTcpConnection(obj *externglib.Object) TcpConnection {
	return TcpConnection{
		SocketConnection: WrapSocketConnection(obj),
	}
}

func marshalTcpConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTcpConnection(obj), nil
}

// GracefulDisconnect checks if graceful disconnects are used. See
// g_tcp_connection_set_graceful_disconnect().
func (c tcpConnection) GracefulDisconnect() bool {
	var arg0 *C.GTcpConnection

	arg0 = (*C.GTcpConnection)(c.Native())

	ret := C.g_tcp_connection_get_graceful_disconnect(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetGracefulDisconnect: this enables graceful disconnects on close. A
// graceful disconnect means that we signal the receiving end that the
// connection is terminated and wait for it to close the connection before
// closing the connection.
//
// A graceful disconnect means that we can be sure that we successfully sent
// all the outstanding data to the other end, or get an error reported.
// However, it also means we have to wait for all the data to reach the
// other side and for it to acknowledge this by closing the socket, which
// may take a while. For this reason it is disabled by default.
func (c tcpConnection) SetGracefulDisconnect(gracefulDisconnect bool) {
	var arg0 *C.GTcpConnection
	var arg1 C.gboolean

	arg0 = (*C.GTcpConnection)(c.Native())
	if gracefulDisconnect {
		arg1 = C.TRUE
	}

	C.g_tcp_connection_set_graceful_disconnect(arg0, arg1)
}

type TcpConnectionPrivate struct {
	native C.GTcpConnectionPrivate
}

// WrapTcpConnectionPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTcpConnectionPrivate(ptr unsafe.Pointer) *TcpConnectionPrivate {
	if ptr == nil {
		return nil
	}

	return (*TcpConnectionPrivate)(ptr)
}

func marshalTcpConnectionPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTcpConnectionPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TcpConnectionPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}
