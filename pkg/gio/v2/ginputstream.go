// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/box"
	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
//
// void gotk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_input_stream_get_type()), F: marshalInputStream},
	})
}

// InputStream has functions to read from a stream (g_input_stream_read()), to
// close a stream (g_input_stream_close()) and to skip some content
// (g_input_stream_skip()).
//
// To copy the content of an input stream to an output stream without manually
// handling the reads and writes, use g_output_stream_splice().
//
// See the documentation for OStream for details of thread safety of streaming
// APIs.
//
// All of these functions have async variants too.
type InputStream interface {
	gextras.Objector

	ClearPendingInputStream()

	CloseInputStream(cancellable Cancellable) error

	CloseAsyncInputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	CloseFinishInputStream(result AsyncResult) error

	HasPendingInputStream() bool

	IsClosedInputStream() bool

	ReadAllFinishInputStream(result AsyncResult) (uint, error)

	ReadBytesAsyncInputStream(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	ReadFinishInputStream(result AsyncResult) (int, error)

	SetPendingInputStream() error

	SkipInputStream(count uint, cancellable Cancellable) (int, error)

	SkipAsyncInputStream(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback)

	SkipFinishInputStream(result AsyncResult) (int, error)
}

// inputStream implements the InputStream class.
type inputStream struct {
	gextras.Objector
}

// WrapInputStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapInputStream(obj *externglib.Object) InputStream {
	return inputStream{
		Objector: obj,
	}
}

func marshalInputStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapInputStream(obj), nil
}

func (s inputStream) ClearPendingInputStream() {
	var _arg0 *C.GInputStream // out

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	C.g_input_stream_clear_pending(_arg0)
}

func (s inputStream) CloseInputStream(cancellable Cancellable) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_input_stream_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) CloseAsyncInputStream(ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg1 C.int                 // out
	var _arg2 *C.GCancellable       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(ioPriority)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg4 = C.gpointer(box.Assign(callback))

	C.g_input_stream_close_async(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (s inputStream) CloseFinishInputStream(result AsyncResult) error {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_input_stream_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) HasPendingInputStream() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_input_stream_has_pending(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s inputStream) IsClosedInputStream() bool {
	var _arg0 *C.GInputStream // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	_cret = C.g_input_stream_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s inputStream) ReadAllFinishInputStream(result AsyncResult) (uint, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 C.gsize         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_input_stream_read_all_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _bytesRead uint // out
	var _goerr error    // out

	_bytesRead = uint(_arg2)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _bytesRead, _goerr
}

func (s inputStream) ReadBytesAsyncInputStream(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg1 C.gsize               // out
	var _arg2 C.int                 // out
	var _arg3 *C.GCancellable       // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.gsize(count)
	_arg2 = C.int(ioPriority)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg5 = C.gpointer(box.Assign(callback))

	C.g_input_stream_read_bytes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s inputStream) ReadFinishInputStream(result AsyncResult) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_input_stream_read_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s inputStream) SetPendingInputStream() error {
	var _arg0 *C.GInputStream // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))

	C.g_input_stream_set_pending(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (s inputStream) SkipInputStream(count uint, cancellable Cancellable) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 C.gsize         // out
	var _arg2 *C.GCancellable // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.gsize(count)
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	_cret = C.g_input_stream_skip(_arg0, _arg1, _arg2, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}

func (s inputStream) SkipAsyncInputStream(count uint, ioPriority int, cancellable Cancellable, callback AsyncReadyCallback) {
	var _arg0 *C.GInputStream       // out
	var _arg1 C.gsize               // out
	var _arg2 C.int                 // out
	var _arg3 *C.GCancellable       // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = C.gsize(count)
	_arg2 = C.int(ioPriority)
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	_arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	_arg5 = C.gpointer(box.Assign(callback))

	C.g_input_stream_skip_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (s inputStream) SkipFinishInputStream(result AsyncResult) (int, error) {
	var _arg0 *C.GInputStream // out
	var _arg1 *C.GAsyncResult // out
	var _cret C.gssize        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GInputStream)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_input_stream_skip_finish(_arg0, _arg1, &_cerr)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _gssize, _goerr
}
