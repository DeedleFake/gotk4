// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_unix_mount_monitor_get_type()), F: marshalUnixMountMonitor},
		{T: externglib.Type(C.g_unix_mount_entry_get_type()), F: marshalUnixMountEntry},
		{T: externglib.Type(C.g_unix_mount_point_get_type()), F: marshalUnixMountPoint},
	})
}

// UnixIsMountPathSystemInternal determines if @mount_path is considered an
// implementation of the OS. This is primarily used for hiding mountable and
// mounted volumes that only are used in the OS and has little to no relevance
// to the casual user.
func UnixIsMountPathSystemInternal(mountPath string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_mount_path_system_internal(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixIsSystemDevicePath determines if @device_path is considered a block
// device path which is only used in implementation of the OS. This is primarily
// used for hiding mounted volumes that are intended as APIs for programs to
// read, and system administrators at a shell; rather than something that
// should, for example, appear in a GUI. For example, the Linux `/proc`
// filesystem.
//
// The list of device paths considered ‘system’ ones may change over time.
func UnixIsSystemDevicePath(devicePath string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(devicePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_system_device_path(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixIsSystemFSType determines if @fs_type is considered a type of file system
// which is only used in implementation of the OS. This is primarily used for
// hiding mounted volumes that are intended as APIs for programs to read, and
// system administrators at a shell; rather than something that should, for
// example, appear in a GUI. For example, the Linux `/proc` filesystem.
//
// The list of file system types considered ‘system’ ones may change over time.
func UnixIsSystemFSType(fsType string) bool {
	var arg1 *C.char

	arg1 = (*C.gchar)(C.CString(fsType))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_is_system_fs_type(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountAt gets a MountEntry for a given mount path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountAt(mountPath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_at(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountEntry

	ret0 = uint64(arg2)

	{
		ret1 = WrapUnixMountEntry(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *UnixMountEntry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// UnixMountCompare compares two unix mounts.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int {
	var arg1 *C.GUnixMountEntry
	var arg2 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mount1.Native())
	arg2 = (*C.GUnixMountEntry)(mount2.Native())

	ret := C.g_unix_mount_compare(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// UnixMountCopy makes a copy of @mount_entry.
func UnixMountCopy(mountEntry *UnixMountEntry) *UnixMountEntry {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_copy(arg1)

	var ret0 *UnixMountEntry

	{
		ret0 = WrapUnixMountEntry(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *UnixMountEntry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// UnixMountFor gets a MountEntry for a given file path. If @time_read is set,
// it will be filled with a unix timestamp for checking if the mounts have
// changed since with g_unix_mounts_changed_since().
//
// If more mounts have the same mount path, the last matching mount is returned.
func UnixMountFor(filePath string) (timeRead uint64, unixMountEntry *UnixMountEntry) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(filePath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_for(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountEntry

	ret0 = uint64(arg2)

	{
		ret1 = WrapUnixMountEntry(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *UnixMountEntry) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// UnixMountFree frees a unix mount.
func UnixMountFree(mountEntry *UnixMountEntry) {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	C.g_unix_mount_free(arg1)
}

// UnixMountGetDevicePath gets the device path for a unix mount.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_device_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetFSType gets the filesystem type for the unix mount.
func UnixMountGetFSType(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_fs_type(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetMountPath gets the mount path for a unix mount.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_mount_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetOptions gets a comma-separated list of mount options for the unix
// mount. For example, `rw,relatime,seclabel,data=ordered`.
//
// This is similar to g_unix_mount_point_get_options(), but it takes a
// MountEntry as an argument.
func UnixMountGetOptions(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_options(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGetRootPath gets the root of the mount within the filesystem. This
// is useful e.g. for mounts created by bind operation, or btrfs subvolumes.
//
// For example, the root path is equal to "/" for mount created by "mount
// /dev/sda1 /mnt/foo" and "/bar" for "mount --bind /mnt/foo/bar /mnt/bar".
func UnixMountGetRootPath(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_get_root_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// UnixMountGuessCanEject guesses whether a Unix mount can be ejected.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_can_eject(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountGuessIcon guesses the icon of a Unix mount.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) Icon {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_icon(arg1)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// UnixMountGuessName guesses the name of a Unix mount. The result is a
// translated string.
func UnixMountGuessName(mountEntry *UnixMountEntry) string {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// UnixMountGuessShouldDisplay guesses whether a Unix mount should be displayed
// in the UI.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_should_display(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountGuessSymbolicIcon guesses the symbolic icon of a Unix mount.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) Icon {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_guess_symbolic_icon(arg1)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// UnixMountIsReadonly checks if a unix mount is mounted read only.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_is_readonly(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountIsSystemInternal checks if a Unix mount is a system mount. This is
// the Boolean OR of g_unix_is_system_fs_type(), g_unix_is_system_device_path()
// and g_unix_is_mount_path_system_internal() on @mount_entry’s properties.
//
// The definition of what a ‘system’ mount entry is may change over time as new
// file system types and device paths are ignored.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
	var arg1 *C.GUnixMountEntry

	arg1 = (*C.GUnixMountEntry)(mountEntry.Native())

	ret := C.g_unix_mount_is_system_internal(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountPointAt gets a MountPoint for a given mount path. If @time_read is
// set, it will be filled with a unix timestamp for checking if the mount points
// have changed since with g_unix_mount_points_changed_since().
//
// If more mount points have the same mount path, the last matching mount point
// is returned.
func UnixMountPointAt(mountPath string) (timeRead uint64, unixMountPoint *UnixMountPoint) {
	var arg1 *C.char
	var arg2 *C.guint64 // out

	arg1 = (*C.gchar)(C.CString(mountPath))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_unix_mount_point_at(arg1, &arg2)

	var ret0 uint64
	var ret1 *UnixMountPoint

	ret0 = uint64(arg2)

	{
		ret1 = WrapUnixMountPoint(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *UnixMountPoint) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// UnixMountPointsChangedSince checks if the unix mount points have changed
// since a given unix time.
func UnixMountPointsChangedSince(time uint64) bool {
	var arg1 C.guint64

	arg1 = C.guint64(time)

	ret := C.g_unix_mount_points_changed_since(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountPointsGet gets a #GList of MountPoint containing the unix mount
// points. If @time_read is set, it will be filled with the mount timestamp,
// allowing for checking if the mounts have changed with
// g_unix_mount_points_changed_since().
func UnixMountPointsGet() (timeRead uint64, list *glib.List) {
	var arg1 *C.guint64 // out

	ret := C.g_unix_mount_points_get(&arg1)

	var ret0 uint64
	var ret1 *glib.List

	ret0 = uint64(arg1)

	{
		ret1 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// UnixMountsChangedSince checks if the unix mounts have changed since a given
// unix time.
func UnixMountsChangedSince(time uint64) bool {
	var arg1 C.guint64

	arg1 = C.guint64(time)

	ret := C.g_unix_mounts_changed_since(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// UnixMountsGet gets a #GList of MountEntry containing the unix mounts. If
// @time_read is set, it will be filled with the mount timestamp, allowing for
// checking if the mounts have changed with g_unix_mounts_changed_since().
func UnixMountsGet() (timeRead uint64, list *glib.List) {
	var arg1 *C.guint64 // out

	ret := C.g_unix_mounts_get(&arg1)

	var ret0 uint64
	var ret1 *glib.List

	ret0 = uint64(arg1)

	{
		ret1 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret1, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0, ret1
}

// UnixMountMonitor watches Mounts for changes.
type UnixMountMonitor interface {
	gextras.Objector

	// SetRateLimit: this function does nothing.
	//
	// Before 2.44, this was a partially-effective way of controlling the rate
	// at which events would be reported under some uncommon circumstances.
	// Since @mount_monitor is a singleton, it also meant that calling this
	// function would have side effects for other users of the monitor.
	SetRateLimit(limitMsec int)
}

// unixMountMonitor implements the UnixMountMonitor interface.
type unixMountMonitor struct {
	gextras.Objector
}

var _ UnixMountMonitor = (*unixMountMonitor)(nil)

// WrapUnixMountMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapUnixMountMonitor(obj *externglib.Object) UnixMountMonitor {
	return UnixMountMonitor{
		Objector: obj,
	}
}

func marshalUnixMountMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapUnixMountMonitor(obj), nil
}

// NewUnixMountMonitor constructs a class UnixMountMonitor.
func NewUnixMountMonitor() UnixMountMonitor {
	ret := C.g_unix_mount_monitor_new()

	var ret0 UnixMountMonitor

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(UnixMountMonitor)

	return ret0
}

// SetRateLimit: this function does nothing.
//
// Before 2.44, this was a partially-effective way of controlling the rate
// at which events would be reported under some uncommon circumstances.
// Since @mount_monitor is a singleton, it also meant that calling this
// function would have side effects for other users of the monitor.
func (m unixMountMonitor) SetRateLimit(limitMsec int) {
	var arg0 *C.GUnixMountMonitor
	var arg1 C.int

	arg0 = (*C.GUnixMountMonitor)(m.Native())
	arg1 = C.int(limitMsec)

	C.g_unix_mount_monitor_set_rate_limit(arg0, arg1)
}

// UnixMountEntry defines a Unix mount entry (e.g.
// <filename>/media/cdrom</filename>). This corresponds roughly to a mtab entry.
type UnixMountEntry struct {
	native C.GUnixMountEntry
}

// WrapUnixMountEntry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountEntry(ptr unsafe.Pointer) *UnixMountEntry {
	if ptr == nil {
		return nil
	}

	return (*UnixMountEntry)(ptr)
}

func marshalUnixMountEntry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountEntry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *UnixMountEntry) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// UnixMountPoint defines a Unix mount point (e.g. <filename>/dev</filename>).
// This corresponds roughly to a fstab entry.
type UnixMountPoint struct {
	native C.GUnixMountPoint
}

// WrapUnixMountPoint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapUnixMountPoint(ptr unsafe.Pointer) *UnixMountPoint {
	if ptr == nil {
		return nil
	}

	return (*UnixMountPoint)(ptr)
}

func marshalUnixMountPoint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapUnixMountPoint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (u *UnixMountPoint) Native() unsafe.Pointer {
	return unsafe.Pointer(&u.native)
}

// Compare compares two unix mount points.
func (m *UnixMountPoint) Compare(mount2 *UnixMountPoint) int {
	var arg0 *C.GUnixMountPoint
	var arg1 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())
	arg1 = (*C.GUnixMountPoint)(mount2.Native())

	ret := C.g_unix_mount_point_compare(arg0, arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Copy makes a copy of @mount_point.
func (m *UnixMountPoint) Copy() *UnixMountPoint {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_copy(arg0)

	var ret0 *UnixMountPoint

	{
		ret0 = WrapUnixMountPoint(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *UnixMountPoint) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free frees a unix mount point.
func (m *UnixMountPoint) Free() {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	C.g_unix_mount_point_free(arg0)
}

// DevicePath gets the device path for a unix mount point.
func (m *UnixMountPoint) DevicePath() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_get_device_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// FSType gets the file system type for the mount point.
func (m *UnixMountPoint) FSType() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_get_fs_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// MountPath gets the mount path for a unix mount point.
func (m *UnixMountPoint) MountPath() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_get_mount_path(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Options gets the options for the mount point.
func (m *UnixMountPoint) Options() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_get_options(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GuessCanEject guesses whether a Unix mount point can be ejected.
func (m *UnixMountPoint) GuessCanEject() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_guess_can_eject(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// GuessIcon guesses the icon of a Unix mount point.
func (m *UnixMountPoint) GuessIcon() Icon {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_guess_icon(arg0)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// GuessName guesses the name of a Unix mount point. The result is a translated
// string.
func (m *UnixMountPoint) GuessName() string {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_guess_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// GuessSymbolicIcon guesses the symbolic icon of a Unix mount point.
func (m *UnixMountPoint) GuessSymbolicIcon() Icon {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_guess_symbolic_icon(arg0)

	var ret0 Icon

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Icon)

	return ret0
}

// IsLoopback checks if a unix mount point is a loopback device.
func (m *UnixMountPoint) IsLoopback() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_is_loopback(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsReadonly checks if a unix mount point is read only.
func (m *UnixMountPoint) IsReadonly() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_is_readonly(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsUserMountable checks if a unix mount point is mountable by the user.
func (m *UnixMountPoint) IsUserMountable() bool {
	var arg0 *C.GUnixMountPoint

	arg0 = (*C.GUnixMountPoint)(m.Native())

	ret := C.g_unix_mount_point_is_user_mountable(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}
