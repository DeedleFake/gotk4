// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname *string) {
	var _arg1 *C.char

	_arg1 = (*C.char)(C.CString(dirname))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_modules_scan_all_in_directory(_arg1)
}

// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname *string, scope *IOModuleScope) {
	var _arg1 *C.gchar
	var _arg2 *C.GIOModuleScope

	_arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GIOModuleScope)(unsafe.Pointer(scope.Native()))

	C.g_io_modules_scan_all_in_directory_with_scope(_arg1, _arg2)
}

// IOModuleScope represents a scope for loading IO modules. A scope can be used
// for blocking duplicate modules, or blocking a module you don't want to load.
//
// The scope can be used with g_io_modules_load_all_in_directory_with_scope() or
// g_io_modules_scan_all_in_directory_with_scope().
type IOModuleScope struct {
	native C.GIOModuleScope
}

// WrapIOModuleScope wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOModuleScope(ptr unsafe.Pointer) *IOModuleScope {
	if ptr == nil {
		return nil
	}

	return (*IOModuleScope)(ptr)
}

func marshalIOModuleScope(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIOModuleScope(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IOModuleScope) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Block: block modules with the given @basename from being loaded when this
// scope is used with g_io_modules_scan_all_in_directory_with_scope() or
// g_io_modules_load_all_in_directory_with_scope().
func (s *IOModuleScope) Block(basename string) {
	var _arg0 *C.GIOModuleScope
	var _arg1 *C.gchar

	_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(basename))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_io_module_scope_block(_arg0, _arg1)
}

// Free: free a module scope.
func (s *IOModuleScope) Free() {
	var _arg0 *C.GIOModuleScope

	_arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))

	C.g_io_module_scope_free(_arg0)
}
