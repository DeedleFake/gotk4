// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/gobject/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

// IOExtensionPointImplement registers @type as extension for the extension
// point with name @extension_point_name.
//
// If @type has already been registered as an extension for this extension
// point, the existing OExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, typ externglib.Type, extensionName string, priority int) *IOExtension {
	var arg1 *C.char
	var arg2 C.GType
	var arg3 *C.char
	var arg4 C.gint

	arg1 = (*C.char)(C.CString(extensionPointName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 := C.GType(typ)
	arg3 = (*C.char)(C.CString(extensionName))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint(priority)

	var cret *C.GIOExtension
	var ret1 *IOExtension

	cret = C.g_io_extension_point_implement(extensionPointName, typ, extensionName, priority)

	ret1 = WrapIOExtension(unsafe.Pointer(cret))

	return ret1
}

// IOExtensionPointLookup looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GIOExtensionPoint
	var ret1 *IOExtensionPoint

	cret = C.g_io_extension_point_lookup(name)

	ret1 = WrapIOExtensionPoint(unsafe.Pointer(cret))

	return ret1
}

// IOExtensionPointRegister registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GIOExtensionPoint
	var ret1 *IOExtensionPoint

	cret = C.g_io_extension_point_register(name)

	ret1 = WrapIOExtensionPoint(unsafe.Pointer(cret))

	return ret1
}

// IOModulesLoadAllInDirectory loads all the modules in the specified directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectory(dirname string) *glib.List {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GList
	var ret1 *glib.List

	cret = C.g_io_modules_load_all_in_directory(dirname)

	ret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// IOModulesLoadAllInDirectoryWithScope loads all the modules in the specified
// directory.
//
// If don't require all modules to be initialized (and thus registering all
// gtypes) then you can use g_io_modules_scan_all_in_directory() which allows
// delayed/lazy loading of modules.
func IOModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List {
	var arg1 *C.gchar
	var arg2 *C.GIOModuleScope

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GIOModuleScope)(unsafe.Pointer(scope.Native()))

	var cret *C.GList
	var ret1 *glib.List

	cret = C.g_io_modules_load_all_in_directory_with_scope(dirname, scope)

	ret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// IOModulesScanAllInDirectory scans all the modules in the specified directory,
// ensuring that any extension point implemented by a module is registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string) {
	var arg1 *C.char

	arg1 = (*C.char)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))

	C.g_io_modules_scan_all_in_directory(dirname)
}

// IOModulesScanAllInDirectoryWithScope scans all the modules in the specified
// directory, ensuring that any extension point implemented by a module is
// registered.
//
// This may not actually load and initialize all the types in each module, some
// modules may be lazily loaded and initialized when an extension point it
// implements is used with e.g. g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
//
// If you need to guarantee that all types are loaded in all the modules, use
// g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var arg1 *C.gchar
	var arg2 *C.GIOModuleScope

	arg1 = (*C.gchar)(C.CString(dirname))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GIOModuleScope)(unsafe.Pointer(scope.Native()))

	C.g_io_modules_scan_all_in_directory_with_scope(dirname, scope)
}

// IOModuleScope represents a scope for loading IO modules. A scope can be used
// for blocking duplicate modules, or blocking a module you don't want to load.
//
// The scope can be used with g_io_modules_load_all_in_directory_with_scope() or
// g_io_modules_scan_all_in_directory_with_scope().
type IOModuleScope struct {
	native C.GIOModuleScope
}

// WrapIOModuleScope wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapIOModuleScope(ptr unsafe.Pointer) *IOModuleScope {
	if ptr == nil {
		return nil
	}

	return (*IOModuleScope)(ptr)
}

func marshalIOModuleScope(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapIOModuleScope(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *IOModuleScope) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// Block: block modules with the given @basename from being loaded when this
// scope is used with g_io_modules_scan_all_in_directory_with_scope() or
// g_io_modules_load_all_in_directory_with_scope().
func (s *IOModuleScope) Block(basename string) {
	var arg0 *C.GIOModuleScope
	var arg1 *C.gchar

	arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(basename))
	defer C.free(unsafe.Pointer(arg1))

	C.g_io_module_scope_block(arg0, basename)
}

// Free: free a module scope.
func (s *IOModuleScope) Free() {
	var arg0 *C.GIOModuleScope

	arg0 = (*C.GIOModuleScope)(unsafe.Pointer(s.Native()))

	C.g_io_module_scope_free(arg0)
}
