// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
func DBusEscapeObjectPath(s string) string {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar

	_cret = C.g_dbus_escape_object_path(_arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusEscapeObjectPathBytestring escapes @bytes for use in a D-Bus object path
// component. @bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (`_`). For example: `foo.bar.baz` will become `foo_2ebar_2ebaz`.
//
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
func DBusEscapeObjectPathBytestring(bytes []byte) string {
	var _arg1 *C.guint8

	_arg1 = (*C.guint8)(C.malloc((len(bytes) + 1) * C.sizeof_guint8))
	defer C.free(unsafe.Pointer(_arg1))

	{
		var out []C.guint8
		ptr.SetSlice(unsafe.Pointer(&dst), unsafe.Pointer(_arg1), int(len(bytes)))

		for i := range bytes {
			_arg1 = C.guint8(bytes)
		}
	}

	var _cret *C.gchar

	_cret = C.g_dbus_escape_object_path_bytestring(_arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusGenerateGuid() string {
	var _cret *C.gchar

	_cret = C.g_dbus_generate_guid()

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGVariantToGValue converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DBusGVariantToGValue(value *glib.Variant) *externglib.Value {
	var _arg1 *C.GVariant

	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	var _arg2 C.GValue

	C.g_dbus_gvariant_to_gvalue(_arg1, &_arg2)

	var _outGvalue *externglib.Value

	_outGvalue = externglib.ValueFromNative(unsafe.Pointer(_arg2))

	return _outGvalue
}

// DBusIsGuid checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusIsGuid(string string) bool {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.g_dbus_is_guid(_arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DBusIsInterfaceName checks if @string is a valid D-Bus interface name.
func DBusIsInterfaceName(string string) bool {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.g_dbus_is_interface_name(_arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DBusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DBusIsMemberName(string string) bool {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.g_dbus_is_member_name(_arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DBusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DBusIsName(string string) bool {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.g_dbus_is_name(_arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DBusIsUniqueName checks if @string is a valid D-Bus unique bus name.
func DBusIsUniqueName(string string) bool {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.g_dbus_is_unique_name(_arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns nil.
//
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g `_63` is not valid, the string should contain `c` instead).
func DBusUnescapeObjectPath(s string) []byte {
	var _arg1 *C.gchar

	_arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.guint8

	_cret = C.g_dbus_unescape_object_path(_arg1)

	var _guint8s []byte

	{
		var length int
		for p := _cret; *p != 0; p = (*C.guint8)(ptr.Add(unsafe.Pointer(p), unsafe.Sizeof(int(0)))) {
			length++
			if length < 0 {
				panic(`length overflow`)
			}
		}

		var src []C.guint8
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(length))

		_guint8s = make([]byte, length)
		for i := range src {
			_guint8s = (byte)(_cret)
		}
	}

	return _guint8s
}
