// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
func DBusEscapeObjectPath(s string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_escape_object_path(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusEscapeObjectPathBytestring escapes @bytes for use in a D-Bus object path
// component. @bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (`_`). For example: `foo.bar.baz` will become `foo_2ebar_2ebaz`.
//
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
func DBusEscapeObjectPathBytestring(bytes []byte) string {
	var arg1 *C.guint8

	{
		var dst []C.guint8
		ptr := C.malloc(C.sizeof_guint8 * (len(bytes) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(bytes)
		sliceHeader.Cap = len(bytes)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(bytes); i++ {
			src := bytes[i]
			dst[i] = C.guint8(src)
		}

		arg1 = (*C.guint8)(unsafe.Pointer(ptr))
	}

	ret := C.g_dbus_escape_object_path_bytestring(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusGenerateGuid: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusGenerateGuid() string {
	ret := C.g_dbus_generate_guid()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// DBusGValueToGVariant converts a #GValue to a #GVariant of the type indicated
// by the @type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay' - TYPE_STRV: 'as', 'ao' or 'aay' -
// TYPE_BOOLEAN: 'b' - TYPE_UCHAR: 'y' - TYPE_INT: 'i', 'n' - TYPE_UINT: 'u',
// 'q' - TYPE_INT64 'x' - TYPE_UINT64: 't' - TYPE_DOUBLE: 'd' - TYPE_VARIANT:
// Any Type
//
// This can fail if e.g. @gvalue is of type TYPE_STRING and @type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if @gvalue is of type TYPE_VARIANT and its value is nil, the empty
// #GVariant instance (never nil) for @type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
func DBusGValueToGVariant(gvalue *externglib.Value, typ *glib.VariantType) *glib.Variant {
	var arg1 *C.GValue
	var arg2 *C.GVariantType

	arg1 = (*C.GValue)(gvalue.GValue)
	arg2 = (*C.GVariantType)(typ.Native())

	ret := C.g_dbus_gvalue_to_gvariant(arg1, arg2)

	var ret0 *glib.Variant

	{
		ret0 = glib.WrapVariant(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.Variant) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// DBusGVariantToGValue converts a #GVariant to a #GValue. If @value is
// floating, it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// @out_gvalue.
func DBusGVariantToGValue(value *glib.Variant) externglib.Value {
	var arg1 *C.GVariant
	var arg2 *C.GValue // out

	arg1 = (*C.GVariant)(value.Native())

	C.g_dbus_gvariant_to_gvalue(arg1, &arg2)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(arg2))

	return ret0
}

// DBusIsGuid checks if @string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
func DBusIsGuid(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_guid(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// DBusIsInterfaceName checks if @string is a valid D-Bus interface name.
func DBusIsInterfaceName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_interface_name(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// DBusIsMemberName checks if @string is a valid D-Bus member (e.g. signal or
// method) name.
func DBusIsMemberName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_member_name(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// DBusIsName checks if @string is a valid D-Bus bus name (either unique or
// well-known).
func DBusIsName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_name(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// DBusIsUniqueName checks if @string is a valid D-Bus unique bus name.
func DBusIsUniqueName(string string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(string))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_is_unique_name(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns nil.
//
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g `_63` is not valid, the string should contain `c` instead).
func DBusUnescapeObjectPath(s string) []byte {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(s))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_dbus_unescape_object_path(arg1)

	var ret0 []byte

	{
		var length uint
		for p := unsafe.Pointer(ret); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]byte, length)
		for i := 0; i < length; i++ {
			src := (C.guint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ret)) + i))
			ret0[i] = byte(src)
		}
	}

	return ret0
}
