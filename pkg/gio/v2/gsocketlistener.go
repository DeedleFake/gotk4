// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_socket_listener_get_type()), F: marshalSocketListener},
	})
}

// SocketListener: a Listener is an object that keeps track of a set of server
// sockets and helps you accept sockets from any of the socket, either sync or
// async.
//
// Add addresses and ports to listen on using g_socket_listener_add_address()
// and g_socket_listener_add_inet_port(). These will be listened on until
// g_socket_listener_close() is called. Dropping your final reference to the
// Listener will not cause g_socket_listener_close() to be called implicitly, as
// some references to the Listener may be held internally.
//
// If you want to implement a network server, also look at Service and
// SocketService which are subclasses of Listener that make this even easier.
type SocketListener interface {
	gextras.Objector

	// Accept blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a Connection for the socket that was accepted.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection, err error)
	// AcceptAsync: this is the asynchronous version of
	// g_socket_listener_accept().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket() to get the result of the
	// operation.
	AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptFinish finishes an async accept operation. See
	// g_socket_listener_accept_async()
	AcceptFinish(result AsyncResult) (sourceObject gextras.Objector, socketConnection SocketConnection, err error)
	// AcceptSocket blocks waiting for a client to connect to any of the sockets
	// added to the listener. Returns the #GSocket that was accepted.
	//
	// If you want to accept the high-level Connection, not a #GSocket, which is
	// often the case, then you should use g_socket_listener_accept() instead.
	//
	// If @source_object is not nil it will be filled out with the source object
	// specified when the corresponding socket or address was added to the
	// listener.
	//
	// If @cancellable is not nil, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
	AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket, err error)
	// AcceptSocketAsync: this is the asynchronous version of
	// g_socket_listener_accept_socket().
	//
	// When the operation is finished @callback will be called. You can then
	// call g_socket_listener_accept_socket_finish() to get the result of the
	// operation.
	AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback)
	// AcceptSocketFinish finishes an async accept operation. See
	// g_socket_listener_accept_socket_async()
	AcceptSocketFinish(result AsyncResult) (sourceObject gextras.Objector, socket Socket, err error)
	// AddAddress creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting sockets
	// from.
	//
	// Note that adding an IPv6 address, depending on the platform, may or may
	// not result in a listener that also accepts IPv4 connections. For more
	// deterministic behavior, see g_socket_listener_add_inet_port().
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// If successful and @effective_address is non-nil then it will be set to
	// the address that the binding actually occurred at. This is helpful for
	// determining the port number that was used for when requesting a binding
	// to port 0 (ie: "any port"). This address, if requested, belongs to the
	// caller and must be freed.
	//
	// Call g_socket_listener_close() to stop listening on @address; this will
	// not be done automatically when you drop your final reference to
	// @listener, as references may be held internally.
	AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, err error)
	// AddAnyInetPort listens for TCP connections on any available port number
	// for both IPv6 and IPv4 (if each is available).
	//
	// This is useful if you need to have a socket for incoming connections but
	// don't care about the specific port number.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	AddAnyInetPort(sourceObject gextras.Objector) (guint16 uint16, err error)
	// AddInetPort: helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
	// specified port on all interfaces.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddInetPort(port uint16, sourceObject gextras.Objector) error
	// AddSocket adds @socket to the set of sockets that we try to accept new
	// clients from. The socket must be bound to a local address and listened
	// to.
	//
	// @source_object will be passed out in the various calls to accept to
	// identify this particular source, which is useful if you're listening on
	// multiple addresses and do different things depending on what address is
	// connected to.
	//
	// The @socket will not be automatically closed when the @listener is
	// finalized unless the listener held the final reference to the socket.
	// Before GLib 2.42, the @socket was automatically closed on finalization of
	// the @listener, even if references to it were held elsewhere.
	AddSocket(socket Socket, sourceObject gextras.Objector) error
	// Close closes all the sockets in the listener.
	Close()
	// SetBacklog sets the listen backlog on the sockets in the listener. This
	// must be called before adding any sockets, addresses or ports to the
	// Listener (for example, by calling g_socket_listener_add_inet_port()) to
	// be effective.
	//
	// See g_socket_set_listen_backlog() for details
	SetBacklog(listenBacklog int)
}

// socketListener implements the SocketListener interface.
type socketListener struct {
	gextras.Objector
}

var _ SocketListener = (*socketListener)(nil)

// WrapSocketListener wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocketListener(obj *externglib.Object) SocketListener {
	return SocketListener{
		Objector: obj,
	}
}

func marshalSocketListener(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocketListener(obj), nil
}

// NewSocketListener constructs a class SocketListener.
func NewSocketListener() SocketListener {
	var cret C.GSocketListener
	var ret1 SocketListener

	cret = C.g_socket_listener_new()

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SocketListener)

	return ret1
}

// Accept blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns a Connection for the socket that was accepted.
//
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the
// listener.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (l socketListener) Accept(cancellable Cancellable) (sourceObject gextras.Objector, socketConnection SocketConnection, err error) {
	var arg0 *C.GSocketListener
	var arg2 *C.GCancellable
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg1 *C.GObject
	var ret1 gextras.Objector
	var cret *C.GSocketConnection
	var ret2 SocketConnection
	var goerr error

	cret = C.g_socket_listener_accept(arg0, &arg1, cancellable, &errout)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gextras.Objector)
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SocketConnection)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, ret2, goerr
}

// AcceptAsync: this is the asynchronous version of
// g_socket_listener_accept().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_listener_accept_socket() to get the result of the
// operation.
func (l socketListener) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketListener

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))

	C.g_socket_listener_accept_async(arg0, cancellable, callback, userData)
}

// AcceptFinish finishes an async accept operation. See
// g_socket_listener_accept_async()
func (l socketListener) AcceptFinish(result AsyncResult) (sourceObject gextras.Objector, socketConnection SocketConnection, err error) {
	var arg0 *C.GSocketListener
	var arg1 *C.GAsyncResult
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var arg2 *C.GObject
	var ret2 gextras.Objector
	var cret *C.GSocketConnection
	var ret2 SocketConnection
	var goerr error

	cret = C.g_socket_listener_accept_finish(arg0, result, &arg2, &errout)

	ret2 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(gextras.Objector)
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(SocketConnection)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret2, ret2, goerr
}

// AcceptSocket blocks waiting for a client to connect to any of the sockets
// added to the listener. Returns the #GSocket that was accepted.
//
// If you want to accept the high-level Connection, not a #GSocket, which is
// often the case, then you should use g_socket_listener_accept() instead.
//
// If @source_object is not nil it will be filled out with the source object
// specified when the corresponding socket or address was added to the
// listener.
//
// If @cancellable is not nil, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
func (l socketListener) AcceptSocket(cancellable Cancellable) (sourceObject gextras.Objector, socket Socket, err error) {
	var arg0 *C.GSocketListener
	var arg2 *C.GCancellable
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var arg1 *C.GObject
	var ret1 gextras.Objector
	var cret *C.GSocket
	var ret2 Socket
	var goerr error

	cret = C.g_socket_listener_accept_socket(arg0, &arg1, cancellable, &errout)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(gextras.Objector)
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Socket)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, ret2, goerr
}

// AcceptSocketAsync: this is the asynchronous version of
// g_socket_listener_accept_socket().
//
// When the operation is finished @callback will be called. You can then
// call g_socket_listener_accept_socket_finish() to get the result of the
// operation.
func (l socketListener) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var arg0 *C.GSocketListener

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))

	C.g_socket_listener_accept_socket_async(arg0, cancellable, callback, userData)
}

// AcceptSocketFinish finishes an async accept operation. See
// g_socket_listener_accept_socket_async()
func (l socketListener) AcceptSocketFinish(result AsyncResult) (sourceObject gextras.Objector, socket Socket, err error) {
	var arg0 *C.GSocketListener
	var arg1 *C.GAsyncResult
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var arg2 *C.GObject
	var ret2 gextras.Objector
	var cret *C.GSocket
	var ret2 Socket
	var goerr error

	cret = C.g_socket_listener_accept_socket_finish(arg0, result, &arg2, &errout)

	ret2 = gextras.CastObject(externglib.Take(unsafe.Pointer(arg2.Native()))).(gextras.Objector)
	ret2 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Socket)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret2, ret2, goerr
}

// AddAddress creates a socket of type @type and protocol @protocol, binds
// it to @address and adds it to the set of sockets we're accepting sockets
// from.
//
// Note that adding an IPv6 address, depending on the platform, may or may
// not result in a listener that also accepts IPv4 connections. For more
// deterministic behavior, see g_socket_listener_add_inet_port().
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// If successful and @effective_address is non-nil then it will be set to
// the address that the binding actually occurred at. This is helpful for
// determining the port number that was used for when requesting a binding
// to port 0 (ie: "any port"). This address, if requested, belongs to the
// caller and must be freed.
//
// Call g_socket_listener_close() to stop listening on @address; this will
// not be done automatically when you drop your final reference to
// @listener, as references may be held internally.
func (l socketListener) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gextras.Objector) (effectiveAddress SocketAddress, err error) {
	var arg0 *C.GSocketListener
	var arg1 *C.GSocketAddress
	var arg2 C.GSocketType
	var arg3 C.GSocketProtocol
	var arg4 *C.GObject
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GSocketAddress)(unsafe.Pointer(address.Native()))
	arg2 = (C.GSocketType)(typ)
	arg3 = (C.GSocketProtocol)(protocol)
	arg4 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	var arg5 *C.GSocketAddress
	var ret5 SocketAddress
	var goerr error

	C.g_socket_listener_add_address(arg0, address, typ, protocol, sourceObject, &arg5, &errout)

	ret5 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg5.Native()))).(SocketAddress)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret5, goerr
}

// AddAnyInetPort listens for TCP connections on any available port number
// for both IPv6 and IPv4 (if each is available).
//
// This is useful if you need to have a socket for incoming connections but
// don't care about the specific port number.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
func (l socketListener) AddAnyInetPort(sourceObject gextras.Objector) (guint16 uint16, err error) {
	var arg0 *C.GSocketListener
	var arg1 *C.GObject
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	var cret C.guint16
	var ret1 uint16
	var goerr error

	cret = C.g_socket_listener_add_any_inet_port(arg0, sourceObject, &errout)

	ret1 = C.guint16(cret)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// AddInetPort: helper function for g_socket_listener_add_address() that
// creates a TCP/IP socket listening on IPv4 and IPv6 (if supported) on the
// specified port on all interfaces.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// Call g_socket_listener_close() to stop listening on @port; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (l socketListener) AddInetPort(port uint16, sourceObject gextras.Objector) error {
	var arg0 *C.GSocketListener
	var arg1 C.guint16
	var arg2 *C.GObject
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = C.guint16(port)
	arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	var goerr error

	C.g_socket_listener_add_inet_port(arg0, port, sourceObject, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

}

// AddSocket adds @socket to the set of sockets that we try to accept new
// clients from. The socket must be bound to a local address and listened
// to.
//
// @source_object will be passed out in the various calls to accept to
// identify this particular source, which is useful if you're listening on
// multiple addresses and do different things depending on what address is
// connected to.
//
// The @socket will not be automatically closed when the @listener is
// finalized unless the listener held the final reference to the socket.
// Before GLib 2.42, the @socket was automatically closed on finalization of
// the @listener, even if references to it were held elsewhere.
func (l socketListener) AddSocket(socket Socket, sourceObject gextras.Objector) error {
	var arg0 *C.GSocketListener
	var arg1 *C.GSocket
	var arg2 *C.GObject
	var errout *C.GError

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GSocket)(unsafe.Pointer(socket.Native()))
	arg2 = (*C.GObject)(unsafe.Pointer(sourceObject.Native()))

	var goerr error

	C.g_socket_listener_add_socket(arg0, socket, sourceObject, &errout)

	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

}

// Close closes all the sockets in the listener.
func (l socketListener) Close() {
	var arg0 *C.GSocketListener

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))

	C.g_socket_listener_close(arg0)
}

// SetBacklog sets the listen backlog on the sockets in the listener. This
// must be called before adding any sockets, addresses or ports to the
// Listener (for example, by calling g_socket_listener_add_inet_port()) to
// be effective.
//
// See g_socket_set_listen_backlog() for details
func (l socketListener) SetBacklog(listenBacklog int) {
	var arg0 *C.GSocketListener
	var arg1 C.int

	arg0 = (*C.GSocketListener)(unsafe.Pointer(l.Native()))
	arg1 = C.int(listenBacklog)

	C.g_socket_listener_set_backlog(arg0, listenBacklog)
}

type SocketListenerPrivate struct {
	native C.GSocketListenerPrivate
}

// WrapSocketListenerPrivate wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSocketListenerPrivate(ptr unsafe.Pointer) *SocketListenerPrivate {
	if ptr == nil {
		return nil
	}

	return (*SocketListenerPrivate)(ptr)
}

func marshalSocketListenerPrivate(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSocketListenerPrivate(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SocketListenerPrivate) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}
