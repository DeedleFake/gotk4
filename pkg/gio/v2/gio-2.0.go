// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_app_info_monitor_get_type()), F: marshalAppInfoMonitor},
		{T: externglib.Type(C.g_dbus_action_group_get_type()), F: marshalDBusActionGroup},
		{T: externglib.Type(C.g_dbus_auth_observer_get_type()), F: marshalDBusAuthObserver},
		{T: externglib.Type(C.g_dbus_connection_get_type()), F: marshalDBusConnection},
		{T: externglib.Type(C.g_dbus_menu_model_get_type()), F: marshalDBusMenuModel},
		{T: externglib.Type(C.g_dbus_message_get_type()), F: marshalDBusMessage},
		{T: externglib.Type(C.g_dbus_method_invocation_get_type()), F: marshalDBusMethodInvocation},
		{T: externglib.Type(C.g_dbus_server_get_type()), F: marshalDBusServer},
		{T: externglib.Type(C.g_menu_get_type()), F: marshalMenu},
		{T: externglib.Type(C.g_menu_item_get_type()), F: marshalMenuItem},
		{T: externglib.Type(C.g_notification_get_type()), F: marshalNotification},
		{T: externglib.Type(C.g_property_action_get_type()), F: marshalPropertyAction},
		{T: externglib.Type(C.g_simple_action_get_type()), F: marshalSimpleAction},
		{T: externglib.Type(C.g_simple_io_stream_get_type()), F: marshalSimpleIOStream},
		{T: externglib.Type(C.g_simple_permission_get_type()), F: marshalSimplePermission},
		{T: externglib.Type(C.g_subprocess_get_type()), F: marshalSubprocess},
		{T: externglib.Type(C.g_subprocess_launcher_get_type()), F: marshalSubprocessLauncher},
		{T: externglib.Type(C.g_test_dbus_get_type()), F: marshalTestDBus},
	})
}

// AppInfoMonitor is a very simple object used for monitoring the app info
// database for changes (ie: newly installed or removed applications).
//
// Call g_app_info_monitor_get() to get a InfoMonitor and connect to the
// "changed" signal.
//
// In the usual case, applications should try to make note of the change (doing
// things like invalidating caches) but not act on it. In particular,
// applications should avoid making calls to Info APIs in response to the change
// signal, deferring these until the time that the data is actually required.
// The exception to this case is when application information is actually being
// displayed on the screen (eg: during a search or when the list of all
// applications is shown). The reason for this is that changes to the list of
// installed applications often come in groups (like during system updates) and
// rescanning the list on every change is pointless and expensive.
type AppInfoMonitor interface {
	gextras.Objector
}

// appInfoMonitor implements the AppInfoMonitor class.
type appInfoMonitor struct {
	gextras.Objector
}

var _ AppInfoMonitor = (*appInfoMonitor)(nil)

// WrapAppInfoMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppInfoMonitor(obj *externglib.Object) AppInfoMonitor {
	return appInfoMonitor{
		Objector: obj,
	}
}

func marshalAppInfoMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppInfoMonitor(obj), nil
}

// BytesIcon specifies an image held in memory in a common format (usually png)
// to be used as icon.
type BytesIcon interface {
	gextras.Objector
	Icon
	LoadableIcon
}

// bytesIcon implements the BytesIcon class.
type bytesIcon struct {
	gextras.Objector
	Icon
	LoadableIcon
}

var _ BytesIcon = (*bytesIcon)(nil)

// WrapBytesIcon wraps a GObject to the right type. It is
// primarily used internally.
func WrapBytesIcon(obj *externglib.Object) BytesIcon {
	return bytesIcon{
		Objector:     obj,
		Icon:         WrapIcon(obj),
		LoadableIcon: WrapLoadableIcon(obj),
	}
}

func marshalBytesIcon(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBytesIcon(obj), nil
}

// DBusActionGroup is an implementation of the Group interface that can be used
// as a proxy for an action group that is exported over D-Bus with
// g_dbus_connection_export_action_group().
type DBusActionGroup interface {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

// dBusActionGroup implements the DBusActionGroup class.
type dBusActionGroup struct {
	gextras.Objector
	ActionGroup
	RemoteActionGroup
}

var _ DBusActionGroup = (*dBusActionGroup)(nil)

// WrapDBusActionGroup wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusActionGroup(obj *externglib.Object) DBusActionGroup {
	return dBusActionGroup{
		Objector:          obj,
		ActionGroup:       WrapActionGroup(obj),
		RemoteActionGroup: WrapRemoteActionGroup(obj),
	}
}

func marshalDBusActionGroup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusActionGroup(obj), nil
}

// DBusAuthObserver: the BusAuthObserver type provides a mechanism for
// participating in how a BusServer (or a BusConnection) authenticates remote
// peers. Simply instantiate a BusAuthObserver and connect to the signals you
// are interested in. Note that new signals may be added in the future
//
//
// Controlling Authentication Mechanisms
//
// By default, a BusServer or server-side BusConnection will allow any
// authentication mechanism to be used. If you only want to allow D-Bus
// connections with the `EXTERNAL` mechanism, which makes use of credentials
// passing and is the recommended mechanism for modern Unix platforms such as
// Linux and the BSD family, you would use a signal handler like this:
//
//    static gboolean
//    on_authorize_authenticated_peer (GDBusAuthObserver *observer,
//                                     GIOStream         *stream,
//                                     GCredentials      *credentials,
//                                     gpointer           user_data)
//    {
//      gboolean authorized;
//
//      authorized = FALSE;
//      if (credentials != NULL)
//        {
//          GCredentials *own_credentials;
//          own_credentials = g_credentials_new ();
//          if (g_credentials_is_same_user (credentials, own_credentials, NULL))
//            authorized = TRUE;
//          g_object_unref (own_credentials);
//        }
//
//      return authorized;
//    }
type DBusAuthObserver interface {
	gextras.Objector

	// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
	// @observer.
	AllowMechanism(mechanism string) bool
	// AuthorizeAuthenticatedPeer emits the
	// BusAuthObserver::authorize-authenticated-peer signal on @observer.
	AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool
}

// dBusAuthObserver implements the DBusAuthObserver class.
type dBusAuthObserver struct {
	gextras.Objector
}

var _ DBusAuthObserver = (*dBusAuthObserver)(nil)

// WrapDBusAuthObserver wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusAuthObserver(obj *externglib.Object) DBusAuthObserver {
	return dBusAuthObserver{
		Objector: obj,
	}
}

func marshalDBusAuthObserver(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusAuthObserver(obj), nil
}

// NewDBusAuthObserver constructs a class DBusAuthObserver.
func NewDBusAuthObserver() DBusAuthObserver {
	var _cret C.GDBusAuthObserver // in

	_cret = C.g_dbus_auth_observer_new()

	var _dBusAuthObserver DBusAuthObserver // out

	_dBusAuthObserver = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusAuthObserver)

	return _dBusAuthObserver
}

// AllowMechanism emits the BusAuthObserver::allow-mechanism signal on
// @observer.
func (o dBusAuthObserver) AllowMechanism(mechanism string) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(mechanism))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.g_dbus_auth_observer_allow_mechanism(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AuthorizeAuthenticatedPeer emits the
// BusAuthObserver::authorize-authenticated-peer signal on @observer.
func (o dBusAuthObserver) AuthorizeAuthenticatedPeer(stream IOStream, credentials Credentials) bool {
	var _arg0 *C.GDBusAuthObserver // out
	var _arg1 *C.GIOStream         // out
	var _arg2 *C.GCredentials      // out

	_arg0 = (*C.GDBusAuthObserver)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.GCredentials)(unsafe.Pointer(credentials.Native()))

	var _cret C.gboolean // in

	_cret = C.g_dbus_auth_observer_authorize_authenticated_peer(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusConnection: the BusConnection type is used for D-Bus connections to
// remote peers such as a message buses. It is a low-level API that offers a lot
// of flexibility. For instance, it lets you establish a connection over any
// transport that can by represented as a OStream.
//
// This class is rarely used directly in D-Bus clients. If you are writing a
// D-Bus client, it is often easier to use the g_bus_own_name(),
// g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
//
// As an exception to the usual GLib rule that a particular object must not be
// used by two threads at the same time, BusConnection's methods may be called
// from any thread. This is so that g_bus_get() and g_bus_get_sync() can safely
// return the same BusConnection when called from any thread.
//
// Most of the ways to obtain a BusConnection automatically initialize it (i.e.
// connect to D-Bus): for instance, g_dbus_connection_new() and g_bus_get(), and
// the synchronous versions of those methods, give you an initialized
// connection. Language bindings for GIO should use g_initable_new() or
// g_async_initable_new_async(), which also initialize the connection.
//
// If you construct an uninitialized BusConnection, such as via g_object_new(),
// you must initialize it via g_initable_init() or g_async_initable_init_async()
// before using its methods or properties. Calling methods or accessing
// properties on a BusConnection that has not completed initialization
// successfully is considered to be invalid, and leads to undefined behaviour.
// In particular, if initialization fails with a #GError, the only valid thing
// you can do with that BusConnection is to free it with g_object_unref().
//
//
// An example D-Bus server
//
// Here is an example for a D-Bus server: gdbus-example-server.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-server.c)
//
//
// An example for exporting a subtree
//
// Here is an example for exporting a subtree: gdbus-example-subtree.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-subtree.c)
//
//
// An example for file descriptor passing
//
// Here is an example for passing UNIX file descriptors: gdbus-unix-fd-client.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-unix-fd-client.c)
//
//
// An example for exporting a GObject
//
// Here is an example for exporting a #GObject: gdbus-example-export.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-export.c)
type DBusConnection interface {
	gextras.Objector
	AsyncInitable
	Initable

	// CallFinish finishes an operation started with g_dbus_connection_call().
	CallFinish(res AsyncResult) (*glib.Variant, error)
	// CallSync: synchronously invokes the @method_name method on the
	// @interface_name D-Bus interface on the remote object at @object_path
	// owned by @bus_name.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
	// with the D-Bus protocol, the operation fails with
	// G_IO_ERROR_INVALID_ARGUMENT.
	//
	// If @reply_type is non-nil then the reply will be checked for having this
	// type and an error will be raised if it does not match. Said another way,
	// if you give a @reply_type then any non-nil return value will be of this
	// type.
	//
	// If the @parameters #GVariant is floating, it is consumed. This allows
	// convenient 'inline' use of g_variant_new(), e.g.:
	//
	//    g_dbus_connection_call_sync (connection,
	//                                 "org.freedesktop.StringThings",
	//                                 "/org/freedesktop/StringThings",
	//                                 "org.freedesktop.StringThings",
	//                                 "TwoStrings",
	//                                 g_variant_new ("(ss)",
	//                                                "Thing One",
	//                                                "Thing Two"),
	//                                 NULL,
	//                                 G_DBUS_CALL_FLAGS_NONE,
	//                                 -1,
	//                                 NULL,
	//                                 &error);
	//
	// The calling thread is blocked until a reply is received. See
	// g_dbus_connection_call() for the asynchronous version of this method.
	CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error)
	// CallWithUnixFdListFinish finishes an operation started with
	// g_dbus_connection_call_with_unix_fd_list().
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced in this way by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error)
	// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
	// and returns FDList objects. See
	// g_dbus_connection_call_with_unix_fd_list() and
	// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
	//
	// This method is only available on UNIX.
	CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error)
	// CloseFinish finishes an operation started with g_dbus_connection_close().
	CloseFinish(res AsyncResult) error
	// CloseSync: synchronously closes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_close() for the
	// asynchronous version of this method and more details about what it does.
	CloseSync(cancellable Cancellable) error
	// EmitSignal emits a signal.
	//
	// If the parameters GVariant is floating, it is consumed.
	//
	// This can only fail if @parameters is not compatible with the D-Bus
	// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
	// (G_IO_ERROR_CLOSED).
	EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error
	// ExportActionGroup exports @action_group on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// A given object path can only have one action group exported on it. If
	// this constraint is violated, the export will fail and 0 will be returned
	// (with @error set accordingly).
	//
	// You can unexport the action group using
	// g_dbus_connection_unexport_action_group() with the return value of this
	// function.
	//
	// The thread default main context is taken at the time of this call. All
	// incoming action activations and state change requests are reported from
	// this context. Any changes on the action group that cause it to emit
	// signals must also come from this same context. Since incoming action
	// activations and state change requests are rather likely to cause changes
	// on the action group, this effectively limits a given action group to
	// being exported from only one main context.
	ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error)
	// ExportMenuModel exports @menu on @connection at @object_path.
	//
	// The implemented D-Bus API should be considered private. It is subject to
	// change in the future.
	//
	// An object path can only have one menu model exported on it. If this
	// constraint is violated, the export will fail and 0 will be returned (with
	// @error set accordingly).
	//
	// You can unexport the menu model using
	// g_dbus_connection_unexport_menu_model() with the return value of this
	// function.
	ExportMenuModel(objectPath string, menu MenuModel) (uint, error)
	// FlushFinish finishes an operation started with g_dbus_connection_flush().
	FlushFinish(res AsyncResult) error
	// FlushSync: synchronously flushes @connection. The calling thread is
	// blocked until this is done. See g_dbus_connection_flush() for the
	// asynchronous version of this method and more details about what it does.
	FlushSync(cancellable Cancellable) error
	// Capabilities gets the capabilities negotiated with the remote peer
	Capabilities() DBusCapabilityFlags
	// ExitOnClose gets whether the process is terminated when @connection is
	// closed by the remote peer. See BusConnection:exit-on-close for more
	// details.
	ExitOnClose() bool
	// Flags gets the flags used to construct this connection
	Flags() DBusConnectionFlags
	// Guid: the GUID of the peer performing the role of server when
	// authenticating. See BusConnection:guid for more details.
	Guid() string
	// LastSerial retrieves the last serial number assigned to a BusMessage on
	// the current thread. This includes messages sent via both low-level API
	// such as g_dbus_connection_send_message() as well as high-level API such
	// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
	// g_dbus_proxy_call().
	LastSerial() uint32
	// PeerCredentials gets the credentials of the authenticated peer. This will
	// always return nil unless @connection acted as a server (e.g.
	// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
	// the client passed credentials as part of the authentication process.
	//
	// In a message bus setup, the message bus is always the server and each
	// application is a client. So this method will always return nil for
	// message bus clients.
	PeerCredentials() Credentials
	// Stream gets the underlying stream used for IO.
	//
	// While the BusConnection is active, it will interact with this stream from
	// a worker thread, so it is not safe to interact with the stream directly.
	Stream() IOStream
	// UniqueName gets the unique name of @connection as assigned by the message
	// bus. This can also be used to figure out if @connection is a message bus
	// connection.
	UniqueName() string
	// IsClosed gets whether @connection is closed.
	IsClosed() bool
	// RemoveFilter removes a filter.
	//
	// Note that since filters run in a different thread, there is a race
	// condition where it is possible that the filter will be running even after
	// calling g_dbus_connection_remove_filter(), so you cannot just free data
	// that the filter might be using. Instead, you should pass a Notify to
	// g_dbus_connection_add_filter(), which will be called when it is
	// guaranteed that the data is no longer needed.
	RemoveFilter(filterId uint)
	// SendMessage: asynchronously sends @message to the peer represented by
	// @connection.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
	// with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error)
	// SendMessageWithReplyFinish finishes an operation started with
	// g_dbus_connection_send_message_with_reply().
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error)
	// SendMessageWithReplySync: synchronously sends @message to the peer
	// represented by @connection and blocks the calling thread until a reply is
	// received or the timeout is reached. See
	// g_dbus_connection_send_message_with_reply() for the asynchronous version
	// of this method.
	//
	// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
	// the serial number will be assigned by @connection and set on @message via
	// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
	// number used will be written to this location prior to submitting the
	// message to the underlying transport. While it has a `volatile` qualifier,
	// this is a historical artifact and the argument passed to it should not be
	// `volatile`.
	//
	// If @connection is closed then the operation will fail with
	// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
	// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
	// fails with G_IO_ERROR_INVALID_ARGUMENT.
	//
	// Note that @error is only set if a local in-process error occurred. That
	// is to say that the returned BusMessage object may be of type
	// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
	// this to a #GError.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	//
	// Note that @message must be unlocked, unless @flags contain the
	// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
	SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error)
	// SetExitOnClose sets whether the process should be terminated when
	// @connection is closed by the remote peer. See BusConnection:exit-on-close
	// for more details.
	//
	// Note that this function should be used with care. Most modern UNIX
	// desktops tie the notion of a user session with the session bus, and
	// expect all of a user's applications to quit when their bus connection
	// goes away. If you are setting @exit_on_close to false for the shared
	// session bus connection, you should make sure that your application exits
	// when the user session ends.
	SetExitOnClose(exitOnClose bool)
	// SignalUnsubscribe unsubscribes from signals.
	//
	// Note that there may still be D-Bus traffic to process (relating to this
	// signal subscription) in the current thread-default Context after this
	// function has returned. You should continue to iterate the Context until
	// the Notify function passed to g_dbus_connection_signal_subscribe() is
	// called, in order to avoid memory leaks through callbacks queued on the
	// Context after it’s stopped being iterated.
	SignalUnsubscribe(subscriptionId uint)
	// StartMessageProcessing: if @connection was created with
	// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
	// processing messages. Does nothing on if @connection wasn't created with
	// this flag or if the method has already been called.
	StartMessageProcessing()
	// UnexportActionGroup reverses the effect of a previous call to
	// g_dbus_connection_export_action_group().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_action_group() or to call it with the same ID
	// more than once.
	UnexportActionGroup(exportId uint)
	// UnexportMenuModel reverses the effect of a previous call to
	// g_dbus_connection_export_menu_model().
	//
	// It is an error to call this function with an ID that wasn't returned from
	// g_dbus_connection_export_menu_model() or to call it with the same ID more
	// than once.
	UnexportMenuModel(exportId uint)
	// UnregisterObject unregisters an object.
	UnregisterObject(registrationId uint) bool
	// UnregisterSubtree unregisters a subtree.
	UnregisterSubtree(registrationId uint) bool
}

// dBusConnection implements the DBusConnection class.
type dBusConnection struct {
	gextras.Objector
	AsyncInitable
	Initable
}

var _ DBusConnection = (*dBusConnection)(nil)

// WrapDBusConnection wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusConnection(obj *externglib.Object) DBusConnection {
	return dBusConnection{
		Objector:      obj,
		AsyncInitable: WrapAsyncInitable(obj),
		Initable:      WrapInitable(obj),
	}
}

func marshalDBusConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusConnection(obj), nil
}

// NewDBusConnectionFinish constructs a class DBusConnection.
func NewDBusConnectionFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult // out

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cret C.GDBusConnection // in
	var _cerr *C.GError         // in

	_cret = C.g_dbus_connection_new_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressFinish constructs a class DBusConnection.
func NewDBusConnectionForAddressFinish(res AsyncResult) (DBusConnection, error) {
	var _arg1 *C.GAsyncResult // out

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cret C.GDBusConnection // in
	var _cerr *C.GError         // in

	_cret = C.g_dbus_connection_new_for_address_finish(_arg1, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionForAddressSync constructs a class DBusConnection.
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.gchar               // out
	var _arg2 C.GDBusConnectionFlags // out
	var _arg3 *C.GDBusAuthObserver   // out
	var _arg4 *C.GCancellable        // out

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GDBusConnectionFlags)(flags)
	_arg3 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GDBusConnection // in
	var _cerr *C.GError         // in

	_cret = C.g_dbus_connection_new_for_address_sync(_arg1, _arg2, _arg3, _arg4, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// NewDBusConnectionSync constructs a class DBusConnection.
func NewDBusConnectionSync(stream IOStream, guid string, flags DBusConnectionFlags, observer DBusAuthObserver, cancellable Cancellable) (DBusConnection, error) {
	var _arg1 *C.GIOStream           // out
	var _arg2 *C.gchar               // out
	var _arg3 C.GDBusConnectionFlags // out
	var _arg4 *C.GDBusAuthObserver   // out
	var _arg5 *C.GCancellable        // out

	_arg1 = (*C.GIOStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.GDBusConnectionFlags)(flags)
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GDBusConnection // in
	var _cerr *C.GError         // in

	_cret = C.g_dbus_connection_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusConnection DBusConnection // out
	var _goerr error                   // out

	_dBusConnection = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusConnection)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusConnection, _goerr
}

// CallFinish finishes an operation started with g_dbus_connection_call().
func (c dBusConnection) CallFinish(res AsyncResult) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cret *C.GVariant // in
	var _cerr *C.GError   // in

	_cret = C.g_dbus_connection_call_finish(_arg0, _arg1, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

// CallSync: synchronously invokes the @method_name method on the
// @interface_name D-Bus interface on the remote object at @object_path
// owned by @bus_name.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If @reply_type is non-nil then the reply will be checked for having this
// type and an error will be raised if it does not match. Said another way,
// if you give a @reply_type then any non-nil return value will be of this
// type.
//
// If the @parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_connection_call_sync (connection,
//                                 "org.freedesktop.StringThings",
//                                 "/org/freedesktop/StringThings",
//                                 "org.freedesktop.StringThings",
//                                 "TwoStrings",
//                                 g_variant_new ("(ss)",
//                                                "Thing One",
//                                                "Thing Two"),
//                                 NULL,
//                                 G_DBUS_CALL_FLAGS_NONE,
//                                 -1,
//                                 NULL,
//                                 &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_connection_call() for the asynchronous version of this method.
func (c dBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, cancellable Cancellable) (*glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GCancellable    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = (C.GDBusCallFlags)(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret *C.GVariant // in
	var _cerr *C.GError   // in

	_cret = C.g_dbus_connection_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _variant, _goerr
}

// CallWithUnixFdListFinish finishes an operation started with
// g_dbus_connection_call_with_unix_fd_list().
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
// in the body of the message. For example, if g_variant_get_handle()
// returns 5, that is intended to be a reference to the file descriptor that
// can be accessed by `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
//
// When designing D-Bus APIs that are intended to be interoperable, please
// note that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced in this way by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
func (c dBusConnection) CallWithUnixFdListFinish(res AsyncResult) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg2 *C.GAsyncResult    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _arg1 *C.GUnixFDList // in
	var _cret *C.GVariant    // in
	var _cerr *C.GError      // in

	_cret = C.g_dbus_connection_call_with_unix_fd_list_finish(_arg0, _arg2, &_arg1, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg1.Native()))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

// CallWithUnixFdListSync: like g_dbus_connection_call_sync() but also takes
// and returns FDList objects. See
// g_dbus_connection_call_with_unix_fd_list() and
// g_dbus_connection_call_with_unix_fd_list_finish() for more details.
//
// This method is only available on UNIX.
func (c dBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int, fdList UnixFDList, cancellable Cancellable) (UnixFDList, *glib.Variant, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out
	var _arg6 *C.GVariantType    // out
	var _arg7 C.GDBusCallFlags   // out
	var _arg8 C.gint             // out
	var _arg9 *C.GUnixFDList     // out
	var _arg11 *C.GCancellable   // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(busName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(methodName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg6 = (*C.GVariantType)(unsafe.Pointer(replyType.Native()))
	_arg7 = (C.GDBusCallFlags)(flags)
	_arg8 = C.gint(timeoutMsec)
	_arg9 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))
	_arg11 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _arg10 *C.GUnixFDList // in
	var _cret *C.GVariant     // in
	var _cerr *C.GError       // in

	_cret = C.g_dbus_connection_call_with_unix_fd_list_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg11, &_arg10, &_cerr)

	var _outFdList UnixFDList  // out
	var _variant *glib.Variant // out
	var _goerr error           // out

	_outFdList = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_arg10.Native()))).(UnixFDList)
	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outFdList, _variant, _goerr
}

// CloseFinish finishes an operation started with g_dbus_connection_close().
func (c dBusConnection) CloseFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cerr *C.GError // in

	C.g_dbus_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// CloseSync: synchronously closes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_close() for the
// asynchronous version of this method and more details about what it does.
func (c dBusConnection) CloseSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError // in

	C.g_dbus_connection_close_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// EmitSignal emits a signal.
//
// If the parameters GVariant is floating, it is consumed.
//
// This can only fail if @parameters is not compatible with the D-Bus
// protocol (G_IO_ERROR_INVALID_ARGUMENT), or if @connection has been closed
// (G_IO_ERROR_CLOSED).
func (c dBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out
	var _arg5 *C.GVariant        // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(destinationBusName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interfaceName))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(signalName))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	var _cerr *C.GError // in

	C.g_dbus_connection_emit_signal(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ExportActionGroup exports @action_group on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// A given object path can only have one action group exported on it. If
// this constraint is violated, the export will fail and 0 will be returned
// (with @error set accordingly).
//
// You can unexport the action group using
// g_dbus_connection_unexport_action_group() with the return value of this
// function.
//
// The thread default main context is taken at the time of this call. All
// incoming action activations and state change requests are reported from
// this context. Any changes on the action group that cause it to emit
// signals must also come from this same context. Since incoming action
// activations and state change requests are rather likely to cause changes
// on the action group, this effectively limits a given action group to
// being exported from only one main context.
func (c dBusConnection) ExportActionGroup(objectPath string, actionGroup ActionGroup) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GActionGroup    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GActionGroup)(unsafe.Pointer(actionGroup.Native()))

	var _cret C.guint   // in
	var _cerr *C.GError // in

	_cret = C.g_dbus_connection_export_action_group(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// ExportMenuModel exports @menu on @connection at @object_path.
//
// The implemented D-Bus API should be considered private. It is subject to
// change in the future.
//
// An object path can only have one menu model exported on it. If this
// constraint is violated, the export will fail and 0 will be returned (with
// @error set accordingly).
//
// You can unexport the menu model using
// g_dbus_connection_unexport_menu_model() with the return value of this
// function.
func (c dBusConnection) ExportMenuModel(objectPath string, menu MenuModel) (uint, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.GMenuModel      // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.gchar)(C.CString(objectPath))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

	var _cret C.guint   // in
	var _cerr *C.GError // in

	_cret = C.g_dbus_connection_export_menu_model(_arg0, _arg1, _arg2, &_cerr)

	var _guint uint  // out
	var _goerr error // out

	_guint = (uint)(_cret)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint, _goerr
}

// FlushFinish finishes an operation started with g_dbus_connection_flush().
func (c dBusConnection) FlushFinish(res AsyncResult) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cerr *C.GError // in

	C.g_dbus_connection_flush_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// FlushSync: synchronously flushes @connection. The calling thread is
// blocked until this is done. See g_dbus_connection_flush() for the
// asynchronous version of this method and more details about what it does.
func (c dBusConnection) FlushSync(cancellable Cancellable) error {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GCancellable    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError // in

	C.g_dbus_connection_flush_sync(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// Capabilities gets the capabilities negotiated with the remote peer
func (c dBusConnection) Capabilities() DBusCapabilityFlags {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret C.GDBusCapabilityFlags // in

	_cret = C.g_dbus_connection_get_capabilities(_arg0)

	var _dBusCapabilityFlags DBusCapabilityFlags // out

	_dBusCapabilityFlags = DBusCapabilityFlags(_cret)

	return _dBusCapabilityFlags
}

// ExitOnClose gets whether the process is terminated when @connection is
// closed by the remote peer. See BusConnection:exit-on-close for more
// details.
func (c dBusConnection) ExitOnClose() bool {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean // in

	_cret = C.g_dbus_connection_get_exit_on_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flags gets the flags used to construct this connection
func (c dBusConnection) Flags() DBusConnectionFlags {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret C.GDBusConnectionFlags // in

	_cret = C.g_dbus_connection_get_flags(_arg0)

	var _dBusConnectionFlags DBusConnectionFlags // out

	_dBusConnectionFlags = DBusConnectionFlags(_cret)

	return _dBusConnectionFlags
}

// Guid: the GUID of the peer performing the role of server when
// authenticating. See BusConnection:guid for more details.
func (c dBusConnection) Guid() string {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_connection_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LastSerial retrieves the last serial number assigned to a BusMessage on
// the current thread. This includes messages sent via both low-level API
// such as g_dbus_connection_send_message() as well as high-level API such
// as g_dbus_connection_emit_signal(), g_dbus_connection_call() or
// g_dbus_proxy_call().
func (c dBusConnection) LastSerial() uint32 {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret C.guint32 // in

	_cret = C.g_dbus_connection_get_last_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// PeerCredentials gets the credentials of the authenticated peer. This will
// always return nil unless @connection acted as a server (e.g.
// G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed) when set up and
// the client passed credentials as part of the authentication process.
//
// In a message bus setup, the message bus is always the server and each
// application is a client. So this method will always return nil for
// message bus clients.
func (c dBusConnection) PeerCredentials() Credentials {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret *C.GCredentials // in

	_cret = C.g_dbus_connection_get_peer_credentials(_arg0)

	var _credentials Credentials // out

	_credentials = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(Credentials)

	return _credentials
}

// Stream gets the underlying stream used for IO.
//
// While the BusConnection is active, it will interact with this stream from
// a worker thread, so it is not safe to interact with the stream directly.
func (c dBusConnection) Stream() IOStream {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret *C.GIOStream // in

	_cret = C.g_dbus_connection_get_stream(_arg0)

	var _ioStream IOStream // out

	_ioStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(IOStream)

	return _ioStream
}

// UniqueName gets the unique name of @connection as assigned by the message
// bus. This can also be used to figure out if @connection is a message bus
// connection.
func (c dBusConnection) UniqueName() string {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_connection_get_unique_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsClosed gets whether @connection is closed.
func (c dBusConnection) IsClosed() bool {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	var _cret C.gboolean // in

	_cret = C.g_dbus_connection_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFilter removes a filter.
//
// Note that since filters run in a different thread, there is a race
// condition where it is possible that the filter will be running even after
// calling g_dbus_connection_remove_filter(), so you cannot just free data
// that the filter might be using. Instead, you should pass a Notify to
// g_dbus_connection_add_filter(), which will be called when it is
// guaranteed that the data is no longer needed.
func (c dBusConnection) RemoveFilter(filterId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(filterId)

	C.g_dbus_connection_remove_filter(_arg0, _arg1)
}

// SendMessage: asynchronously sends @message to the peer represented by
// @connection.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport. While it has a `volatile` qualifier,
// this is a historical artifact and the argument passed to it should not be
// `volatile`.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @message is not well-formed, the operation fails
// with G_IO_ERROR_INVALID_ARGUMENT.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (c dBusConnection) SendMessage(message DBusMessage, flags DBusSendMessageFlags) (uint32, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = (C.GDBusSendMessageFlags)(flags)

	var _arg3 C.guint32 // in
	var _cerr *C.GError // in

	C.g_dbus_connection_send_message(_arg0, _arg1, _arg2, &_arg3, &_cerr)

	var _outSerial uint32 // out
	var _goerr error      // out

	_outSerial = (uint32)(_arg3)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _goerr
}

// SendMessageWithReplyFinish finishes an operation started with
// g_dbus_connection_send_message_with_reply().
//
// Note that @error is only set if a local in-process error occurred. That
// is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
// this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (c dBusConnection) SendMessageWithReplyFinish(res AsyncResult) (DBusMessage, error) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 *C.GAsyncResult    // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(res.Native()))

	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_cret = C.g_dbus_connection_send_message_with_reply_finish(_arg0, _arg1, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// SendMessageWithReplySync: synchronously sends @message to the peer
// represented by @connection and blocks the calling thread until a reply is
// received or the timeout is reached. See
// g_dbus_connection_send_message_with_reply() for the asynchronous version
// of this method.
//
// Unless @flags contain the G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag,
// the serial number will be assigned by @connection and set on @message via
// g_dbus_message_set_serial(). If @out_serial is not nil, then the serial
// number used will be written to this location prior to submitting the
// message to the underlying transport. While it has a `volatile` qualifier,
// this is a historical artifact and the argument passed to it should not be
// `volatile`.
//
// If @connection is closed then the operation will fail with
// G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will fail
// with G_IO_ERROR_CANCELLED. If @message is not well-formed, the operation
// fails with G_IO_ERROR_INVALID_ARGUMENT.
//
// Note that @error is only set if a local in-process error occurred. That
// is to say that the returned BusMessage object may be of type
// G_DBUS_MESSAGE_TYPE_ERROR. Use g_dbus_message_to_gerror() to transcode
// this to a #GError.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
//
// Note that @message must be unlocked, unless @flags contain the
// G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
func (c dBusConnection) SendMessageWithReplySync(message DBusMessage, flags DBusSendMessageFlags, timeoutMsec int, cancellable Cancellable) (uint32, DBusMessage, error) {
	var _arg0 *C.GDBusConnection      // out
	var _arg1 *C.GDBusMessage         // out
	var _arg2 C.GDBusSendMessageFlags // out
	var _arg3 C.gint                  // out
	var _arg5 *C.GCancellable         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GDBusMessage)(unsafe.Pointer(message.Native()))
	_arg2 = (C.GDBusSendMessageFlags)(flags)
	_arg3 = C.gint(timeoutMsec)
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _arg4 C.guint32       // in
	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_cret = C.g_dbus_connection_send_message_with_reply_sync(_arg0, _arg1, _arg2, _arg3, _arg5, &_arg4, &_cerr)

	var _outSerial uint32        // out
	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_outSerial = (uint32)(_arg4)
	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outSerial, _dBusMessage, _goerr
}

// SetExitOnClose sets whether the process should be terminated when
// @connection is closed by the remote peer. See BusConnection:exit-on-close
// for more details.
//
// Note that this function should be used with care. Most modern UNIX
// desktops tie the notion of a user session with the session bus, and
// expect all of a user's applications to quit when their bus connection
// goes away. If you are setting @exit_on_close to false for the shared
// session bus connection, you should make sure that your application exits
// when the user session ends.
func (c dBusConnection) SetExitOnClose(exitOnClose bool) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	if exitOnClose {
		_arg1 = C.TRUE
	}

	C.g_dbus_connection_set_exit_on_close(_arg0, _arg1)
}

// SignalUnsubscribe unsubscribes from signals.
//
// Note that there may still be D-Bus traffic to process (relating to this
// signal subscription) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until
// the Notify function passed to g_dbus_connection_signal_subscribe() is
// called, in order to avoid memory leaks through callbacks queued on the
// Context after it’s stopped being iterated.
func (c dBusConnection) SignalUnsubscribe(subscriptionId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe(_arg0, _arg1)
}

// StartMessageProcessing: if @connection was created with
// G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method starts
// processing messages. Does nothing on if @connection wasn't created with
// this flag or if the method has already been called.
func (c dBusConnection) StartMessageProcessing() {
	var _arg0 *C.GDBusConnection // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))

	C.g_dbus_connection_start_message_processing(_arg0)
}

// UnexportActionGroup reverses the effect of a previous call to
// g_dbus_connection_export_action_group().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_action_group() or to call it with the same ID
// more than once.
func (c dBusConnection) UnexportActionGroup(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_action_group(_arg0, _arg1)
}

// UnexportMenuModel reverses the effect of a previous call to
// g_dbus_connection_export_menu_model().
//
// It is an error to call this function with an ID that wasn't returned from
// g_dbus_connection_export_menu_model() or to call it with the same ID more
// than once.
func (c dBusConnection) UnexportMenuModel(exportId uint) {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(exportId)

	C.g_dbus_connection_unexport_menu_model(_arg0, _arg1)
}

// UnregisterObject unregisters an object.
func (c dBusConnection) UnregisterObject(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	var _cret C.gboolean // in

	_cret = C.g_dbus_connection_unregister_object(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnregisterSubtree unregisters a subtree.
func (c dBusConnection) UnregisterSubtree(registrationId uint) bool {
	var _arg0 *C.GDBusConnection // out
	var _arg1 C.guint            // out

	_arg0 = (*C.GDBusConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint(registrationId)

	var _cret C.gboolean // in

	_cret = C.g_dbus_connection_unregister_subtree(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DBusMenuModel is an implementation of Model that can be used as a proxy for a
// menu model that is exported over D-Bus with
// g_dbus_connection_export_menu_model().
type DBusMenuModel interface {
	MenuModel
}

// dBusMenuModel implements the DBusMenuModel class.
type dBusMenuModel struct {
	MenuModel
}

var _ DBusMenuModel = (*dBusMenuModel)(nil)

// WrapDBusMenuModel wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMenuModel(obj *externglib.Object) DBusMenuModel {
	return dBusMenuModel{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalDBusMenuModel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMenuModel(obj), nil
}

// DBusMessage: a type for representing D-Bus messages that can be sent or
// received on a BusConnection.
type DBusMessage interface {
	gextras.Objector

	// Copy copies @message. The copy is a deep copy and the returned BusMessage
	// is completely identical except that it is guaranteed to not be locked.
	//
	// This operation can fail if e.g. @message contains file descriptors and
	// the per-process or system-wide open files limit is reached.
	Copy() (DBusMessage, error)
	// Arg0: convenience to get the first item in the body of @message.
	Arg0() string
	// Body gets the body of a message.
	Body() *glib.Variant
	// ByteOrder gets the byte order of @message.
	ByteOrder() DBusMessageByteOrder
	// Destination: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	Destination() string
	// ErrorName: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	ErrorName() string
	// Flags gets the flags for @message.
	Flags() DBusMessageFlags
	// Header gets a header field on @message.
	//
	// The caller is responsible for checking the type of the returned #GVariant
	// matches what is expected.
	Header(headerField DBusMessageHeaderField) *glib.Variant
	// HeaderFields gets an array of all header fields on @message that are set.
	HeaderFields() []byte
	// Interface: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	Interface() string
	// Locked checks whether @message is locked. To monitor changes to this
	// value, conncet to the #GObject::notify signal to listen for changes on
	// the BusMessage:locked property.
	Locked() bool
	// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	Member() string
	// MessageType gets the type of @message.
	MessageType() DBusMessageType
	// NumUnixFds: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	NumUnixFds() uint32
	// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
	// field.
	Path() string
	// ReplySerial: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	ReplySerial() uint32
	// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	Sender() string
	// Serial gets the serial for @message.
	Serial() uint32
	// Signature: convenience getter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	Signature() string
	// UnixFdList gets the UNIX file descriptors associated with @message, if
	// any.
	//
	// This method is only available on UNIX.
	//
	// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
	// in the body of the message. For example, if g_variant_get_handle()
	// returns 5, that is intended to be a reference to the file descriptor that
	// can be accessed by `g_unix_fd_list_get (list, 5, ...)`.
	UnixFdList() UnixFDList
	// Lock: if @message is locked, does nothing. Otherwise locks the message.
	Lock()
	// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
	// @method_call_message.
	NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage
	// NewMethodReply creates a new BusMessage that is a reply to
	// @method_call_message.
	NewMethodReply() DBusMessage
	// Print produces a human-readable multi-line description of @message.
	//
	// The contents of the description has no ABI guarantees, the contents and
	// formatting is subject to change at any time. Typical output looks
	// something like this:
	//
	//    Flags:   none
	//    Version: 0
	//    Serial:  4
	//    Headers:
	//      path -> objectpath '/org/gtk/GDBus/TestObject'
	//      interface -> 'org.gtk.GDBus.TestInterface'
	//      member -> 'GimmeStdout'
	//      destination -> ':1.146'
	//    Body: ()
	//    UNIX File Descriptors:
	//      (none)
	//
	// or
	//
	//    Flags:   no-reply-expected
	//    Version: 0
	//    Serial:  477
	//    Headers:
	//      reply-serial -> uint32 4
	//      destination -> ':1.159'
	//      sender -> ':1.146'
	//      num-unix-fds -> uint32 1
	//    Body: ()
	//    UNIX File Descriptors:
	//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
	Print(indent uint) string
	// SetBody sets the body @message. As a side-effect the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
	// string of @body (or cleared if @body is nil).
	//
	// If @body is floating, @message assumes ownership of @body.
	SetBody(body *glib.Variant)
	// SetByteOrder sets the byte order of @message.
	SetByteOrder(byteOrder DBusMessageByteOrder)
	// SetDestination: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
	SetDestination(value string)
	// SetErrorName: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
	SetErrorName(value string)
	// SetFlags sets the flags to set on @message.
	SetFlags(flags DBusMessageFlags)
	// SetHeader sets a header field on @message.
	//
	// If @value is floating, @message assumes ownership of @value.
	SetHeader(headerField DBusMessageHeaderField, value *glib.Variant)
	// SetInterface: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
	SetInterface(value string)
	// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
	// header field.
	SetMember(value string)
	// SetMessageType sets @message to be of @type.
	SetMessageType(typ DBusMessageType)
	// SetNumUnixFds: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
	SetNumUnixFds(value uint32)
	// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
	// header field.
	SetPath(value string)
	// SetReplySerial: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
	SetReplySerial(value uint32)
	// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
	// header field.
	SetSender(value string)
	// SetSerial sets the serial for @message.
	SetSerial(serial uint32)
	// SetSignature: convenience setter for the
	// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
	SetSignature(value string)
	// SetUnixFdList sets the UNIX file descriptors associated with @message. As
	// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
	// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
	//
	// This method is only available on UNIX.
	//
	// When designing D-Bus APIs that are intended to be interoperable, please
	// note that non-GDBus implementations of D-Bus can usually only access file
	// descriptors if they are referenced by a value of type
	// G_VARIANT_TYPE_HANDLE in the body of the message.
	SetUnixFdList(fdList UnixFDList)
	// ToBlob serializes @message to a blob. The byte order returned by
	// g_dbus_message_get_byte_order() will be used.
	ToBlob(capabilities DBusCapabilityFlags) ([]byte, error)
	// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
	// nothing and returns false.
	//
	// Otherwise this method encodes the error in @message as a #GError using
	// g_dbus_error_set_dbus_error() using the information in the
	// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
	// as the first string item in @message's body.
	ToGerror() error
}

// dBusMessage implements the DBusMessage class.
type dBusMessage struct {
	gextras.Objector
}

var _ DBusMessage = (*dBusMessage)(nil)

// WrapDBusMessage wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMessage(obj *externglib.Object) DBusMessage {
	return dBusMessage{
		Objector: obj,
	}
}

func marshalDBusMessage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMessage(obj), nil
}

// NewDBusMessage constructs a class DBusMessage.
func NewDBusMessage() DBusMessage {
	var _cret C.GDBusMessage // in

	_cret = C.g_dbus_message_new()

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// NewDBusMessageFromBlob constructs a class DBusMessage.
func NewDBusMessageFromBlob(blob []byte, capabilities DBusCapabilityFlags) (DBusMessage, error) {
	var _arg1 *C.guchar
	var _arg2 C.gsize
	var _arg3 C.GDBusCapabilityFlags // out

	_arg2 = C.gsize(len(blob))
	_arg1 = (*C.guchar)(unsafe.Pointer(&blob[0]))
	_arg3 = (C.GDBusCapabilityFlags)(capabilities)

	var _cret C.GDBusMessage // in
	var _cerr *C.GError      // in

	_cret = C.g_dbus_message_new_from_blob(_arg1, _arg2, _arg3, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// NewDBusMessageMethodCall constructs a class DBusMessage.
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) DBusMessage {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out
	var _arg4 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(C.CString(method))
	defer C.free(unsafe.Pointer(_arg4))

	var _cret C.GDBusMessage // in

	_cret = C.g_dbus_message_new_method_call(_arg1, _arg2, _arg3, _arg4)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// NewDBusMessageSignal constructs a class DBusMessage.
func NewDBusMessageSignal(path string, interface_ string, signal string) DBusMessage {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(interface_))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(signal))
	defer C.free(unsafe.Pointer(_arg3))

	var _cret C.GDBusMessage // in

	_cret = C.g_dbus_message_new_signal(_arg1, _arg2, _arg3)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// Copy copies @message. The copy is a deep copy and the returned BusMessage
// is completely identical except that it is guaranteed to not be locked.
//
// This operation can fail if e.g. @message contains file descriptors and
// the per-process or system-wide open files limit is reached.
func (m dBusMessage) Copy() (DBusMessage, error) {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.GDBusMessage // in
	var _cerr *C.GError       // in

	_cret = C.g_dbus_message_copy(_arg0, &_cerr)

	var _dBusMessage DBusMessage // out
	var _goerr error             // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusMessage, _goerr
}

// Arg0: convenience to get the first item in the body of @message.
func (m dBusMessage) Arg0() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_arg0(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Body gets the body of a message.
func (m dBusMessage) Body() *glib.Variant {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.GVariant // in

	_cret = C.g_dbus_message_get_body(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// ByteOrder gets the byte order of @message.
func (m dBusMessage) ByteOrder() DBusMessageByteOrder {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.GDBusMessageByteOrder // in

	_cret = C.g_dbus_message_get_byte_order(_arg0)

	var _dBusMessageByteOrder DBusMessageByteOrder // out

	_dBusMessageByteOrder = DBusMessageByteOrder(_cret)

	return _dBusMessageByteOrder
}

// Destination: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (m dBusMessage) Destination() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_destination(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ErrorName: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (m dBusMessage) ErrorName() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_error_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags gets the flags for @message.
func (m dBusMessage) Flags() DBusMessageFlags {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.GDBusMessageFlags // in

	_cret = C.g_dbus_message_get_flags(_arg0)

	var _dBusMessageFlags DBusMessageFlags // out

	_dBusMessageFlags = DBusMessageFlags(_cret)

	return _dBusMessageFlags
}

// Header gets a header field on @message.
//
// The caller is responsible for checking the type of the returned #GVariant
// matches what is expected.
func (m dBusMessage) Header(headerField DBusMessageHeaderField) *glib.Variant {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageHeaderField)(headerField)

	var _cret *C.GVariant // in

	_cret = C.g_dbus_message_get_header(_arg0, _arg1)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// HeaderFields gets an array of all header fields on @message that are set.
func (m dBusMessage) HeaderFields() []byte {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.guchar

	_cret = C.g_dbus_message_get_header_fields(_arg0)

	var _guint8s []byte

	{
		var i int
		for p := _cret; *p != nil; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_guint8s = make([]byte, i)
		for i := range src {
			_guint8s[i] = (byte)(src[i])
		}
	}

	return _guint8s
}

// Interface: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (m dBusMessage) Interface() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_interface(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Locked checks whether @message is locked. To monitor changes to this
// value, conncet to the #GObject::notify signal to listen for changes on
// the BusMessage:locked property.
func (m dBusMessage) Locked() bool {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.gboolean // in

	_cret = C.g_dbus_message_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Member: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (m dBusMessage) Member() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_member(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// MessageType gets the type of @message.
func (m dBusMessage) MessageType() DBusMessageType {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.GDBusMessageType // in

	_cret = C.g_dbus_message_get_message_type(_arg0)

	var _dBusMessageType DBusMessageType // out

	_dBusMessageType = DBusMessageType(_cret)

	return _dBusMessageType
}

// NumUnixFds: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (m dBusMessage) NumUnixFds() uint32 {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.guint32 // in

	_cret = C.g_dbus_message_get_num_unix_fds(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Path: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header
// field.
func (m dBusMessage) Path() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ReplySerial: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (m dBusMessage) ReplySerial() uint32 {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.guint32 // in

	_cret = C.g_dbus_message_get_reply_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Sender: convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (m dBusMessage) Sender() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Serial gets the serial for @message.
func (m dBusMessage) Serial() uint32 {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret C.guint32 // in

	_cret = C.g_dbus_message_get_serial(_arg0)

	var _guint32 uint32 // out

	_guint32 = (uint32)(_cret)

	return _guint32
}

// Signature: convenience getter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (m dBusMessage) Signature() string {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_get_signature(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// UnixFdList gets the UNIX file descriptors associated with @message, if
// any.
//
// This method is only available on UNIX.
//
// The file descriptors normally correspond to G_VARIANT_TYPE_HANDLE values
// in the body of the message. For example, if g_variant_get_handle()
// returns 5, that is intended to be a reference to the file descriptor that
// can be accessed by `g_unix_fd_list_get (list, 5, ...)`.
func (m dBusMessage) UnixFdList() UnixFDList {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.GUnixFDList // in

	_cret = C.g_dbus_message_get_unix_fd_list(_arg0)

	var _unixFDList UnixFDList // out

	_unixFDList = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(UnixFDList)

	return _unixFDList
}

// Lock: if @message is locked, does nothing. Otherwise locks the message.
func (m dBusMessage) Lock() {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	C.g_dbus_message_lock(_arg0)
}

// NewMethodErrorLiteral creates a new BusMessage that is an error reply to
// @method_call_message.
func (m dBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) DBusMessage {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new_method_error_literal(_arg0, _arg1, _arg2)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// NewMethodReply creates a new BusMessage that is a reply to
// @method_call_message.
func (m dBusMessage) NewMethodReply() DBusMessage {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_message_new_method_reply(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// Print produces a human-readable multi-line description of @message.
//
// The contents of the description has no ABI guarantees, the contents and
// formatting is subject to change at any time. Typical output looks
// something like this:
//
//    Flags:   none
//    Version: 0
//    Serial:  4
//    Headers:
//      path -> objectpath '/org/gtk/GDBus/TestObject'
//      interface -> 'org.gtk.GDBus.TestInterface'
//      member -> 'GimmeStdout'
//      destination -> ':1.146'
//    Body: ()
//    UNIX File Descriptors:
//      (none)
//
// or
//
//    Flags:   no-reply-expected
//    Version: 0
//    Serial:  477
//    Headers:
//      reply-serial -> uint32 4
//      destination -> ':1.159'
//      sender -> ':1.146'
//      num-unix-fds -> uint32 1
//    Body: ()
//    UNIX File Descriptors:
//      fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
func (m dBusMessage) Print(indent uint) string {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint(indent)

	var _cret *C.gchar // in

	_cret = C.g_dbus_message_print(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetBody sets the body @message. As a side-effect the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the type
// string of @body (or cleared if @body is nil).
//
// If @body is floating, @message assumes ownership of @body.
func (m dBusMessage) SetBody(body *glib.Variant) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(body.Native()))

	C.g_dbus_message_set_body(_arg0, _arg1)
}

// SetByteOrder sets the byte order of @message.
func (m dBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	var _arg0 *C.GDBusMessage         // out
	var _arg1 C.GDBusMessageByteOrder // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageByteOrder)(byteOrder)

	C.g_dbus_message_set_byte_order(_arg0, _arg1)
}

// SetDestination: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
func (m dBusMessage) SetDestination(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_destination(_arg0, _arg1)
}

// SetErrorName: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
func (m dBusMessage) SetErrorName(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_error_name(_arg0, _arg1)
}

// SetFlags sets the flags to set on @message.
func (m dBusMessage) SetFlags(flags DBusMessageFlags) {
	var _arg0 *C.GDBusMessage     // out
	var _arg1 C.GDBusMessageFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageFlags)(flags)

	C.g_dbus_message_set_flags(_arg0, _arg1)
}

// SetHeader sets a header field on @message.
//
// If @value is floating, @message assumes ownership of @value.
func (m dBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	var _arg0 *C.GDBusMessage           // out
	var _arg1 C.GDBusMessageHeaderField // out
	var _arg2 *C.GVariant               // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageHeaderField)(headerField)
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_dbus_message_set_header(_arg0, _arg1, _arg2)
}

// SetInterface: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
func (m dBusMessage) SetInterface(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_interface(_arg0, _arg1)
}

// SetMember: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER
// header field.
func (m dBusMessage) SetMember(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_member(_arg0, _arg1)
}

// SetMessageType sets @message to be of @type.
func (m dBusMessage) SetMessageType(typ DBusMessageType) {
	var _arg0 *C.GDBusMessage    // out
	var _arg1 C.GDBusMessageType // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (C.GDBusMessageType)(typ)

	C.g_dbus_message_set_message_type(_arg0, _arg1)
}

// SetNumUnixFds: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
func (m dBusMessage) SetNumUnixFds(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_num_unix_fds(_arg0, _arg1)
}

// SetPath: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH
// header field.
func (m dBusMessage) SetPath(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_path(_arg0, _arg1)
}

// SetReplySerial: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
func (m dBusMessage) SetReplySerial(value uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(value)

	C.g_dbus_message_set_reply_serial(_arg0, _arg1)
}

// SetSender: convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER
// header field.
func (m dBusMessage) SetSender(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_sender(_arg0, _arg1)
}

// SetSerial sets the serial for @message.
func (m dBusMessage) SetSerial(serial uint32) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = C.guint32(serial)

	C.g_dbus_message_set_serial(_arg0, _arg1)
}

// SetSignature: convenience setter for the
// G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
func (m dBusMessage) SetSignature(value string) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_dbus_message_set_signature(_arg0, _arg1)
}

// SetUnixFdList sets the UNIX file descriptors associated with @message. As
// a side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field
// is set to the number of fds in @fd_list (or cleared if @fd_list is nil).
//
// This method is only available on UNIX.
//
// When designing D-Bus APIs that are intended to be interoperable, please
// note that non-GDBus implementations of D-Bus can usually only access file
// descriptors if they are referenced by a value of type
// G_VARIANT_TYPE_HANDLE in the body of the message.
func (m dBusMessage) SetUnixFdList(fdList UnixFDList) {
	var _arg0 *C.GDBusMessage // out
	var _arg1 *C.GUnixFDList  // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_message_set_unix_fd_list(_arg0, _arg1)
}

// ToBlob serializes @message to a blob. The byte order returned by
// g_dbus_message_get_byte_order() will be used.
func (m dBusMessage) ToBlob(capabilities DBusCapabilityFlags) ([]byte, error) {
	var _arg0 *C.GDBusMessage        // out
	var _arg2 C.GDBusCapabilityFlags // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))
	_arg2 = (C.GDBusCapabilityFlags)(capabilities)

	var _cret *C.guchar
	var _arg1 C.gsize   // in
	var _cerr *C.GError // in

	_cret = C.g_dbus_message_to_blob(_arg0, _arg2, &_arg1, &_cerr)

	var _guint8s []byte
	var _goerr error // out

	_guint8s = unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1)
	runtime.SetFinalizer(&_guint8s, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _guint8s, _goerr
}

// ToGerror: if @message is not of type G_DBUS_MESSAGE_TYPE_ERROR does
// nothing and returns false.
//
// Otherwise this method encodes the error in @message as a #GError using
// g_dbus_error_set_dbus_error() using the information in the
// G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as well
// as the first string item in @message's body.
func (m dBusMessage) ToGerror() error {
	var _arg0 *C.GDBusMessage // out

	_arg0 = (*C.GDBusMessage)(unsafe.Pointer(m.Native()))

	var _cerr *C.GError // in

	C.g_dbus_message_to_gerror(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// DBusMethodInvocation instances of the BusMethodInvocation class are used when
// handling D-Bus method calls. It provides a way to asynchronously return
// results and errors.
//
// The normal way to obtain a BusMethodInvocation object is to receive it as an
// argument to the handle_method_call() function in a BusInterfaceVTable that
// was passed to g_dbus_connection_register_object().
type DBusMethodInvocation interface {
	gextras.Objector

	// Connection gets the BusConnection the method was invoked on.
	Connection() DBusConnection
	// InterfaceName gets the name of the D-Bus interface the method was invoked
	// on.
	//
	// If this method call is a property Get, Set or GetAll call that has been
	// redirected to the method call handler then
	// "org.freedesktop.DBus.Properties" will be returned. See
	// BusInterfaceVTable for more information.
	InterfaceName() string
	// Message gets the BusMessage for the method invocation. This is useful if
	// you need to use low-level protocol features, such as UNIX file descriptor
	// passing, that cannot be properly expressed in the #GVariant API.
	//
	// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
	// example of how to use this low-level API to send and receive UNIX file
	// descriptors.
	Message() DBusMessage
	// MethodInfo gets information about the method call, if any.
	//
	// If this method invocation is a property Get, Set or GetAll call that has
	// been redirected to the method call handler then nil will be returned. See
	// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
	// more information.
	MethodInfo() *DBusMethodInfo
	// MethodName gets the name of the method that was invoked.
	MethodName() string
	// ObjectPath gets the object path the method was invoked on.
	ObjectPath() string
	// Parameters gets the parameters of the method invocation. If there are no
	// input parameters then this will return a GVariant with 0 children rather
	// than NULL.
	Parameters() *glib.Variant
	// PropertyInfo gets information about the property that this method call is
	// for, if any.
	//
	// This will only be set in the case of an invocation in response to a
	// property Get or Set call that has been directed to the method call
	// handler for an object on account of its property_get() or property_set()
	// vtable pointers being unset.
	//
	// See BusInterfaceVTable for more information.
	//
	// If the call was GetAll, nil will be returned.
	PropertyInfo() *DBusPropertyInfo
	// Sender gets the bus name that invoked the method.
	Sender() string
	// ReturnDBusError finishes handling a D-Bus method call by returning an
	// error.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnDBusError(errorName string, errorMessage string)
	// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
	// #GError instead of the error domain, error code and message.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnGerror(err error)
	// ReturnValue finishes handling a D-Bus method call by returning
	// @parameters. If the @parameters GVariant is floating, it is consumed.
	//
	// It is an error if @parameters is not of the right format: it must be a
	// tuple containing the out-parameters of the D-Bus method. Even if the
	// method has a single out-parameter, it must be contained in a tuple. If
	// the method has no out-parameters, @parameters may be nil or an empty
	// tuple.
	//
	//    GDBusMethodInvocation *invocation = some_invocation;
	//    g_autofree gchar *result_string = NULL;
	//    g_autoptr (GError) error = NULL;
	//
	//    result_string = calculate_result (&error);
	//
	//    if (error != NULL)
	//      g_dbus_method_invocation_return_gerror (invocation, error);
	//    else
	//      g_dbus_method_invocation_return_value (invocation,
	//                                             g_variant_new ("(s)", result_string));
	//
	//    // Do not free @invocation here; returning a value does that
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	//
	// Since 2.48, if the method call requested for a reply not to be sent then
	// this call will sink @parameters and free @invocation, but otherwise do
	// nothing (as per the recommendations of the D-Bus specification).
	ReturnValue(parameters *glib.Variant)
	// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
	// but also takes a FDList.
	//
	// This method is only available on UNIX.
	//
	// This method will take ownership of @invocation. See BusInterfaceVTable
	// for more information about the ownership of @invocation.
	ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList)
}

// dBusMethodInvocation implements the DBusMethodInvocation class.
type dBusMethodInvocation struct {
	gextras.Objector
}

var _ DBusMethodInvocation = (*dBusMethodInvocation)(nil)

// WrapDBusMethodInvocation wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusMethodInvocation(obj *externglib.Object) DBusMethodInvocation {
	return dBusMethodInvocation{
		Objector: obj,
	}
}

func marshalDBusMethodInvocation(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusMethodInvocation(obj), nil
}

// Connection gets the BusConnection the method was invoked on.
func (i dBusMethodInvocation) Connection() DBusConnection {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.GDBusConnection // in

	_cret = C.g_dbus_method_invocation_get_connection(_arg0)

	var _dBusConnection DBusConnection // out

	_dBusConnection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(DBusConnection)

	return _dBusConnection
}

// InterfaceName gets the name of the D-Bus interface the method was invoked
// on.
//
// If this method call is a property Get, Set or GetAll call that has been
// redirected to the method call handler then
// "org.freedesktop.DBus.Properties" will be returned. See
// BusInterfaceVTable for more information.
func (i dBusMethodInvocation) InterfaceName() string {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_method_invocation_get_interface_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Message gets the BusMessage for the method invocation. This is useful if
// you need to use low-level protocol features, such as UNIX file descriptor
// passing, that cannot be properly expressed in the #GVariant API.
//
// See this [server][gdbus-server] and [client][gdbus-unix-fd-client] for an
// example of how to use this low-level API to send and receive UNIX file
// descriptors.
func (i dBusMethodInvocation) Message() DBusMessage {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.GDBusMessage // in

	_cret = C.g_dbus_method_invocation_get_message(_arg0)

	var _dBusMessage DBusMessage // out

	_dBusMessage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(DBusMessage)

	return _dBusMessage
}

// MethodInfo gets information about the method call, if any.
//
// If this method invocation is a property Get, Set or GetAll call that has
// been redirected to the method call handler then nil will be returned. See
// g_dbus_method_invocation_get_property_info() and BusInterfaceVTable for
// more information.
func (i dBusMethodInvocation) MethodInfo() *DBusMethodInfo {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.GDBusMethodInfo // in

	_cret = C.g_dbus_method_invocation_get_method_info(_arg0)

	var _dBusMethodInfo *DBusMethodInfo // out

	_dBusMethodInfo = WrapDBusMethodInfo(unsafe.Pointer(_cret))

	return _dBusMethodInfo
}

// MethodName gets the name of the method that was invoked.
func (i dBusMethodInvocation) MethodName() string {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_method_invocation_get_method_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ObjectPath gets the object path the method was invoked on.
func (i dBusMethodInvocation) ObjectPath() string {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_method_invocation_get_object_path(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Parameters gets the parameters of the method invocation. If there are no
// input parameters then this will return a GVariant with 0 children rather
// than NULL.
func (i dBusMethodInvocation) Parameters() *glib.Variant {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.GVariant // in

	_cret = C.g_dbus_method_invocation_get_parameters(_arg0)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))

	return _variant
}

// PropertyInfo gets information about the property that this method call is
// for, if any.
//
// This will only be set in the case of an invocation in response to a
// property Get or Set call that has been directed to the method call
// handler for an object on account of its property_get() or property_set()
// vtable pointers being unset.
//
// See BusInterfaceVTable for more information.
//
// If the call was GetAll, nil will be returned.
func (i dBusMethodInvocation) PropertyInfo() *DBusPropertyInfo {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.GDBusPropertyInfo // in

	_cret = C.g_dbus_method_invocation_get_property_info(_arg0)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	_dBusPropertyInfo = WrapDBusPropertyInfo(unsafe.Pointer(_cret))

	return _dBusPropertyInfo
}

// Sender gets the bus name that invoked the method.
func (i dBusMethodInvocation) Sender() string {
	var _arg0 *C.GDBusMethodInvocation // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_method_invocation_get_sender(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// ReturnDBusError finishes handling a D-Bus method call by returning an
// error.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnDBusError(errorName string, errorMessage string) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.gchar                 // out
	var _arg2 *C.gchar                 // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.gchar)(C.CString(errorName))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(errorMessage))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_dbus_method_invocation_return_dbus_error(_arg0, _arg1, _arg2)
}

// ReturnGerror: like g_dbus_method_invocation_return_error() but takes a
// #GError instead of the error domain, error code and message.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnGerror(err error) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GError                // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
	defer C.g_error_free(_arg1)

	C.g_dbus_method_invocation_return_gerror(_arg0, _arg1)
}

// ReturnValue finishes handling a D-Bus method call by returning
// @parameters. If the @parameters GVariant is floating, it is consumed.
//
// It is an error if @parameters is not of the right format: it must be a
// tuple containing the out-parameters of the D-Bus method. Even if the
// method has a single out-parameter, it must be contained in a tuple. If
// the method has no out-parameters, @parameters may be nil or an empty
// tuple.
//
//    GDBusMethodInvocation *invocation = some_invocation;
//    g_autofree gchar *result_string = NULL;
//    g_autoptr (GError) error = NULL;
//
//    result_string = calculate_result (&error);
//
//    if (error != NULL)
//      g_dbus_method_invocation_return_gerror (invocation, error);
//    else
//      g_dbus_method_invocation_return_value (invocation,
//                                             g_variant_new ("(s)", result_string));
//
//    // Do not free @invocation here; returning a value does that
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
//
// Since 2.48, if the method call requested for a reply not to be sent then
// this call will sink @parameters and free @invocation, but otherwise do
// nothing (as per the recommendations of the D-Bus specification).
func (i dBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))

	C.g_dbus_method_invocation_return_value(_arg0, _arg1)
}

// ReturnValueWithUnixFdList: like g_dbus_method_invocation_return_value()
// but also takes a FDList.
//
// This method is only available on UNIX.
//
// This method will take ownership of @invocation. See BusInterfaceVTable
// for more information about the ownership of @invocation.
func (i dBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList UnixFDList) {
	var _arg0 *C.GDBusMethodInvocation // out
	var _arg1 *C.GVariant              // out
	var _arg2 *C.GUnixFDList           // out

	_arg0 = (*C.GDBusMethodInvocation)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(parameters.Native()))
	_arg2 = (*C.GUnixFDList)(unsafe.Pointer(fdList.Native()))

	C.g_dbus_method_invocation_return_value_with_unix_fd_list(_arg0, _arg1, _arg2)
}

// DBusServer is a helper for listening to and accepting D-Bus connections. This
// can be used to create a new D-Bus server, allowing two peers to use the D-Bus
// protocol for their own specialized communication. A server instance provided
// in this way will not perform message routing or implement the
// org.freedesktop.DBus interface.
//
// To just export an object on a well-known name on a message bus, such as the
// session or system bus, you should instead use g_bus_own_name().
//
// An example of peer-to-peer communication with GDBus can be found in
// gdbus-example-peer.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-peer.c).
//
// Note that a minimal BusServer will accept connections from any peer. In many
// use-cases it will be necessary to add a BusAuthObserver that only accepts
// connections that have successfully authenticated as the same user that is
// running the BusServer. Since GLib 2.68 this can be achieved more simply by
// passing the G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the
// server.
type DBusServer interface {
	gextras.Objector
	Initable

	// ClientAddress gets a D-Bus address
	// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
	// string that can be used by clients to connect to @server.
	ClientAddress() string
	// Flags gets the flags for @server.
	Flags() DBusServerFlags
	// Guid gets the GUID for @server.
	Guid() string
	// IsActive gets whether @server is active.
	IsActive() bool
	// Start starts @server.
	Start()
	// Stop stops @server.
	Stop()
}

// dBusServer implements the DBusServer class.
type dBusServer struct {
	gextras.Objector
	Initable
}

var _ DBusServer = (*dBusServer)(nil)

// WrapDBusServer wraps a GObject to the right type. It is
// primarily used internally.
func WrapDBusServer(obj *externglib.Object) DBusServer {
	return dBusServer{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalDBusServer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDBusServer(obj), nil
}

// NewDBusServerSync constructs a class DBusServer.
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer DBusAuthObserver, cancellable Cancellable) (DBusServer, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GDBusServerFlags   // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GDBusAuthObserver // out
	var _arg5 *C.GCancellable      // out

	_arg1 = (*C.gchar)(C.CString(address))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GDBusServerFlags)(flags)
	_arg3 = (*C.gchar)(C.CString(guid))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GDBusAuthObserver)(unsafe.Pointer(observer.Native()))
	_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cret C.GDBusServer // in
	var _cerr *C.GError     // in

	_cret = C.g_dbus_server_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)

	var _dBusServer DBusServer // out
	var _goerr error           // out

	_dBusServer = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(DBusServer)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _dBusServer, _goerr
}

// ClientAddress gets a D-Bus address
// (https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
// string that can be used by clients to connect to @server.
func (s dBusServer) ClientAddress() string {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_server_get_client_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags gets the flags for @server.
func (s dBusServer) Flags() DBusServerFlags {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var _cret C.GDBusServerFlags // in

	_cret = C.g_dbus_server_get_flags(_arg0)

	var _dBusServerFlags DBusServerFlags // out

	_dBusServerFlags = DBusServerFlags(_cret)

	return _dBusServerFlags
}

// Guid gets the GUID for @server.
func (s dBusServer) Guid() string {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar // in

	_cret = C.g_dbus_server_get_guid(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IsActive gets whether @server is active.
func (s dBusServer) IsActive() bool {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_dbus_server_is_active(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts @server.
func (s dBusServer) Start() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_start(_arg0)
}

// Stop stops @server.
func (s dBusServer) Stop() {
	var _arg0 *C.GDBusServer // out

	_arg0 = (*C.GDBusServer)(unsafe.Pointer(s.Native()))

	C.g_dbus_server_stop(_arg0)
}

// Menu is a simple implementation of Model. You populate a #GMenu by adding
// Item instances to it.
//
// There are some convenience functions to allow you to directly add items
// (avoiding Item) for the common cases. To add a regular item, use
// g_menu_insert(). To add a section, use g_menu_insert_section(). To add a
// submenu, use g_menu_insert_submenu().
type Menu interface {
	MenuModel

	// Append: convenience function for appending a normal menu item to the end
	// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(label string, detailedAction string)
	// AppendItem appends @item to the end of @menu.
	//
	// See g_menu_insert_item() for more information.
	AppendItem(item MenuItem)
	// AppendSection: convenience function for appending a section menu item to
	// the end of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSection(label string, section MenuModel)
	// AppendSubmenu: convenience function for appending a submenu menu item to
	// the end of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	AppendSubmenu(label string, submenu MenuModel)
	// Freeze marks @menu as frozen.
	//
	// After the menu is frozen, it is an error to attempt to make any changes
	// to it. In effect this means that the #GMenu API must no longer be used.
	//
	// This function causes g_menu_model_is_mutable() to begin returning false,
	// which has some positive performance implications.
	Freeze()
	// Insert: convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(position int, label string, detailedAction string)
	// InsertItem inserts @item into @menu.
	//
	// The "insertion" is actually done by copying all of the attribute and link
	// values of @item and using them to form a new item within @menu. As such,
	// @item itself is not really inserted, but rather, a menu item that is
	// exactly the same as the one presently described by @item.
	//
	// This means that @item is essentially useless after the insertion occurs.
	// Any changes you make to it are ignored unless it is inserted again (at
	// which point its updated values will be copied).
	//
	// You should probably just free @item once you're done.
	//
	// There are many convenience functions to take care of common cases. See
	// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
	// well as "prepend" and "append" variants of each of these functions.
	InsertItem(position int, item MenuItem)
	// InsertSection: convenience function for inserting a section menu item
	// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSection(position int, label string, section MenuModel)
	// InsertSubmenu: convenience function for inserting a submenu menu item
	// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
	// for a more flexible alternative.
	InsertSubmenu(position int, label string, submenu MenuModel)
	// Prepend: convenience function for prepending a normal menu item to the
	// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
	// more flexible alternative.
	Prepend(label string, detailedAction string)
	// PrependItem prepends @item to the start of @menu.
	//
	// See g_menu_insert_item() for more information.
	PrependItem(item MenuItem)
	// PrependSection: convenience function for prepending a section menu item
	// to the start of @menu. Combine g_menu_item_new_section() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSection(label string, section MenuModel)
	// PrependSubmenu: convenience function for prepending a submenu menu item
	// to the start of @menu. Combine g_menu_item_new_submenu() and
	// g_menu_insert_item() for a more flexible alternative.
	PrependSubmenu(label string, submenu MenuModel)
	// Remove removes an item from the menu.
	//
	// @position gives the index of the item to remove.
	//
	// It is an error if position is not in range the range from 0 to one less
	// than the number of items in the menu.
	//
	// It is not possible to remove items by identity since items are added to
	// the menu simply by copying their links and attributes (ie: identity of
	// the item itself is not preserved).
	Remove(position int)
	// RemoveAll removes all items in the menu.
	RemoveAll()
}

// menu implements the Menu class.
type menu struct {
	MenuModel
}

var _ Menu = (*menu)(nil)

// WrapMenu wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenu(obj *externglib.Object) Menu {
	return menu{
		MenuModel: WrapMenuModel(obj),
	}
}

func marshalMenu(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenu(obj), nil
}

// NewMenu constructs a class Menu.
func NewMenu() Menu {
	var _cret C.GMenu // in

	_cret = C.g_menu_new()

	var _menu Menu // out

	_menu = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Menu)

	return _menu
}

// Append: convenience function for appending a normal menu item to the end
// of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (m menu) Append(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_append(_arg0, _arg1, _arg2)
}

// AppendItem appends @item to the end of @menu.
//
// See g_menu_insert_item() for more information.
func (m menu) AppendItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_append_item(_arg0, _arg1)
}

// AppendSection: convenience function for appending a section menu item to
// the end of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) AppendSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_append_section(_arg0, _arg1, _arg2)
}

// AppendSubmenu: convenience function for appending a submenu menu item to
// the end of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) AppendSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_append_submenu(_arg0, _arg1, _arg2)
}

// Freeze marks @menu as frozen.
//
// After the menu is frozen, it is an error to attempt to make any changes
// to it. In effect this means that the #GMenu API must no longer be used.
//
// This function causes g_menu_model_is_mutable() to begin returning false,
// which has some positive performance implications.
func (m menu) Freeze() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_freeze(_arg0)
}

// Insert: convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (m menu) Insert(position int, label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out
	var _arg2 *C.gchar // out
	var _arg3 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_menu_insert(_arg0, _arg1, _arg2, _arg3)
}

// InsertItem inserts @item into @menu.
//
// The "insertion" is actually done by copying all of the attribute and link
// values of @item and using them to form a new item within @menu. As such,
// @item itself is not really inserted, but rather, a menu item that is
// exactly the same as the one presently described by @item.
//
// This means that @item is essentially useless after the insertion occurs.
// Any changes you make to it are ignored unless it is inserted again (at
// which point its updated values will be copied).
//
// You should probably just free @item once you're done.
//
// There are many convenience functions to take care of common cases. See
// g_menu_insert(), g_menu_insert_section() and g_menu_insert_submenu() as
// well as "prepend" and "append" variants of each of these functions.
func (m menu) InsertItem(position int, item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 C.gint       // out
	var _arg2 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_insert_item(_arg0, _arg1, _arg2)
}

// InsertSection: convenience function for inserting a section menu item
// into @menu. Combine g_menu_item_new_section() and g_menu_insert_item()
// for a more flexible alternative.
func (m menu) InsertSection(position int, label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_insert_section(_arg0, _arg1, _arg2, _arg3)
}

// InsertSubmenu: convenience function for inserting a submenu menu item
// into @menu. Combine g_menu_item_new_submenu() and g_menu_insert_item()
// for a more flexible alternative.
func (m menu) InsertSubmenu(position int, label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 C.gint        // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)
	_arg2 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_insert_submenu(_arg0, _arg1, _arg2, _arg3)
}

// Prepend: convenience function for prepending a normal menu item to the
// start of @menu. Combine g_menu_item_new() and g_menu_insert_item() for a
// more flexible alternative.
func (m menu) Prepend(label string, detailedAction string) {
	var _arg0 *C.GMenu // out
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_menu_prepend(_arg0, _arg1, _arg2)
}

// PrependItem prepends @item to the start of @menu.
//
// See g_menu_insert_item() for more information.
func (m menu) PrependItem(item MenuItem) {
	var _arg0 *C.GMenu     // out
	var _arg1 *C.GMenuItem // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuItem)(unsafe.Pointer(item.Native()))

	C.g_menu_prepend_item(_arg0, _arg1)
}

// PrependSection: convenience function for prepending a section menu item
// to the start of @menu. Combine g_menu_item_new_section() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) PrependSection(label string, section MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_prepend_section(_arg0, _arg1, _arg2)
}

// PrependSubmenu: convenience function for prepending a submenu menu item
// to the start of @menu. Combine g_menu_item_new_submenu() and
// g_menu_insert_item() for a more flexible alternative.
func (m menu) PrependSubmenu(label string, submenu MenuModel) {
	var _arg0 *C.GMenu      // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_prepend_submenu(_arg0, _arg1, _arg2)
}

// Remove removes an item from the menu.
//
// @position gives the index of the item to remove.
//
// It is an error if position is not in range the range from 0 to one less
// than the number of items in the menu.
//
// It is not possible to remove items by identity since items are added to
// the menu simply by copying their links and attributes (ie: identity of
// the item itself is not preserved).
func (m menu) Remove(position int) {
	var _arg0 *C.GMenu // out
	var _arg1 C.gint   // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))
	_arg1 = C.gint(position)

	C.g_menu_remove(_arg0, _arg1)
}

// RemoveAll removes all items in the menu.
func (m menu) RemoveAll() {
	var _arg0 *C.GMenu // out

	_arg0 = (*C.GMenu)(unsafe.Pointer(m.Native()))

	C.g_menu_remove_all(_arg0)
}

// MenuItem is an opaque structure type. You must access it using the functions
// below.
type MenuItem interface {
	gextras.Objector

	// AttributeValue queries the named @attribute on @menu_item.
	//
	// If @expected_type is specified and the attribute does not have this type,
	// nil is returned. nil is also returned if the attribute simply does not
	// exist.
	AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant
	// Link queries the named @link on @menu_item.
	Link(link string) MenuModel
	// SetActionAndTargetValue sets or unsets the "action" and "target"
	// attributes of @menu_item.
	//
	// If @action is nil then both the "action" and "target" attributes are
	// unset (and @target_value is ignored).
	//
	// If @action is non-nil then the "action" attribute is set. The "target"
	// attribute is then set to the value of @target_value if it is non-nil or
	// unset otherwise.
	//
	// Normal menu items (ie: not submenu, section or other custom item types)
	// are expected to have the "action" attribute set to identify the action
	// that they are associated with. The state type of the action help to
	// determine the disposition of the menu item. See #GAction and Group for an
	// overview of actions.
	//
	// In general, clicking on the menu item will result in activation of the
	// named action with the "target" attribute given as the parameter to the
	// action invocation. If the "target" attribute is not set then the action
	// is invoked with no parameter.
	//
	// If the action has no state then the menu item is usually drawn as a plain
	// menu item (ie: with no additional decoration).
	//
	// If the action has a boolean state then the menu item is usually drawn as
	// a toggle menu item (ie: with a checkmark or equivalent indication). The
	// item should be marked as 'toggled' or 'checked' when the boolean state is
	// true.
	//
	// If the action has a string state then the menu item is usually drawn as a
	// radio menu item (ie: with a radio bullet or equivalent indication). The
	// item should be marked as 'selected' when the string state is equal to the
	// value of the @target property.
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_detailed_action() for two equivalent calls that are
	// probably more convenient for most uses.
	SetActionAndTargetValue(action string, targetValue *glib.Variant)
	// SetAttributeValue sets or unsets an attribute on @menu_item.
	//
	// The attribute to set or unset is specified by @attribute. This can be one
	// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
	// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
	// name. Attribute names are restricted to lowercase characters, numbers and
	// '-'. Furthermore, the names must begin with a lowercase character, must
	// not end with a '-', and must not contain consecutive dashes.
	//
	// must consist only of lowercase ASCII characters, digits and '-'.
	//
	// If @value is non-nil then it is used as the new value for the attribute.
	// If @value is nil then the attribute is unset. If the @value #GVariant is
	// floating, it is consumed.
	//
	// See also g_menu_item_set_attribute() for a more convenient way to do the
	// same.
	SetAttributeValue(attribute string, value *glib.Variant)
	// SetDetailedAction sets the "action" and possibly the "target" attribute
	// of @menu_item.
	//
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	//
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but slightly
	// less convenient) alternatives.
	//
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(detailedAction string)
	// SetIcon sets (or unsets) the icon on @menu_item.
	//
	// This call is the same as calling g_icon_serialize() and using the result
	// as the value to g_menu_item_set_attribute_value() for
	// G_MENU_ATTRIBUTE_ICON.
	//
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu. Don't use it on menu
	// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
	//
	// If @icon is nil then the icon is unset.
	SetIcon(icon Icon)
	// SetLabel sets or unsets the "label" attribute of @menu_item.
	//
	// If @label is non-nil it is used as the label for the menu item. If it is
	// nil then the label attribute is unset.
	SetLabel(label string)
	// SetLink creates a link from @menu_item to @model if non-nil, or unsets
	// it.
	//
	// Links are used to establish a relationship between a particular menu item
	// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
	// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
	// create a section. Other types of link can be used, but there is no
	// guarantee that clients will be able to make sense of them. Link types are
	// restricted to lowercase characters, numbers and '-'. Furthermore, the
	// names must begin with a lowercase character, must not end with a '-', and
	// must not contain consecutive dashes.
	SetLink(link string, model MenuModel)
	// SetSection sets or unsets the "section" link of @menu_item to @section.
	//
	// The effect of having one menu appear as a section of another is exactly
	// as it sounds: the items from @section become a direct part of the menu
	// that @menu_item is added to. See g_menu_item_new_section() for more
	// information about what it means for a menu item to be a section.
	SetSection(section MenuModel)
	// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
	//
	// If @submenu is non-nil, it is linked to. If it is nil then the link is
	// unset.
	//
	// The effect of having one menu appear as a submenu of another is exactly
	// as it sounds.
	SetSubmenu(submenu MenuModel)
}

// menuItem implements the MenuItem class.
type menuItem struct {
	gextras.Objector
}

var _ MenuItem = (*menuItem)(nil)

// WrapMenuItem wraps a GObject to the right type. It is
// primarily used internally.
func WrapMenuItem(obj *externglib.Object) MenuItem {
	return menuItem{
		Objector: obj,
	}
}

func marshalMenuItem(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMenuItem(obj), nil
}

// NewMenuItem constructs a class MenuItem.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	var _cret C.GMenuItem // in

	_cret = C.g_menu_item_new(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(MenuItem)

	return _menuItem
}

// NewMenuItemFromModel constructs a class MenuItem.
func NewMenuItemFromModel(model MenuModel, itemIndex int) MenuItem {
	var _arg1 *C.GMenuModel // out
	var _arg2 C.gint        // out

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	_arg2 = C.gint(itemIndex)

	var _cret C.GMenuItem // in

	_cret = C.g_menu_item_new_from_model(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(MenuItem)

	return _menuItem
}

// NewMenuItemSection constructs a class MenuItem.
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	var _cret C.GMenuItem // in

	_cret = C.g_menu_item_new_section(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(MenuItem)

	return _menuItem
}

// NewMenuItemSubmenu constructs a class MenuItem.
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	var _cret C.GMenuItem // in

	_cret = C.g_menu_item_new_submenu(_arg1, _arg2)

	var _menuItem MenuItem // out

	_menuItem = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(MenuItem)

	return _menuItem
}

// AttributeValue queries the named @attribute on @menu_item.
//
// If @expected_type is specified and the attribute does not have this type,
// nil is returned. nil is also returned if the attribute simply does not
// exist.
func (m menuItem) AttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _arg0 *C.GMenuItem    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(expectedType.Native()))

	var _cret *C.GVariant // in

	_cret = C.g_menu_item_get_attribute_value(_arg0, _arg1, _arg2)

	var _variant *glib.Variant // out

	_variant = glib.WrapVariant(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_variant, func(v *glib.Variant) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _variant
}

// Link queries the named @link on @menu_item.
func (m menuItem) Link(link string) MenuModel {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.GMenuModel // in

	_cret = C.g_menu_item_get_link(_arg0, _arg1)

	var _menuModel MenuModel // out

	_menuModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(MenuModel)

	return _menuModel
}

// SetActionAndTargetValue sets or unsets the "action" and "target"
// attributes of @menu_item.
//
// If @action is nil then both the "action" and "target" attributes are
// unset (and @target_value is ignored).
//
// If @action is non-nil then the "action" attribute is set. The "target"
// attribute is then set to the value of @target_value if it is non-nil or
// unset otherwise.
//
// Normal menu items (ie: not submenu, section or other custom item types)
// are expected to have the "action" attribute set to identify the action
// that they are associated with. The state type of the action help to
// determine the disposition of the menu item. See #GAction and Group for an
// overview of actions.
//
// In general, clicking on the menu item will result in activation of the
// named action with the "target" attribute given as the parameter to the
// action invocation. If the "target" attribute is not set then the action
// is invoked with no parameter.
//
// If the action has no state then the menu item is usually drawn as a plain
// menu item (ie: with no additional decoration).
//
// If the action has a boolean state then the menu item is usually drawn as
// a toggle menu item (ie: with a checkmark or equivalent indication). The
// item should be marked as 'toggled' or 'checked' when the boolean state is
// true.
//
// If the action has a string state then the menu item is usually drawn as a
// radio menu item (ie: with a radio bullet or equivalent indication). The
// item should be marked as 'selected' when the string state is equal to the
// value of the @target property.
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_detailed_action() for two equivalent calls that are
// probably more convenient for most uses.
func (m menuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

	C.g_menu_item_set_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetAttributeValue sets or unsets an attribute on @menu_item.
//
// The attribute to set or unset is specified by @attribute. This can be one
// of the standard attribute names G_MENU_ATTRIBUTE_LABEL,
// G_MENU_ATTRIBUTE_ACTION, G_MENU_ATTRIBUTE_TARGET, or a custom attribute
// name. Attribute names are restricted to lowercase characters, numbers and
// '-'. Furthermore, the names must begin with a lowercase character, must
// not end with a '-', and must not contain consecutive dashes.
//
// must consist only of lowercase ASCII characters, digits and '-'.
//
// If @value is non-nil then it is used as the new value for the attribute.
// If @value is nil then the attribute is unset. If the @value #GVariant is
// floating, it is consumed.
//
// See also g_menu_item_set_attribute() for a more convenient way to do the
// same.
func (m menuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GVariant  // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(attribute))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_menu_item_set_attribute_value(_arg0, _arg1, _arg2)
}

// SetDetailedAction sets the "action" and possibly the "target" attribute
// of @menu_item.
//
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
//
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but slightly
// less convenient) alternatives.
//
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (m menuItem) SetDetailedAction(detailedAction string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_detailed_action(_arg0, _arg1)
}

// SetIcon sets (or unsets) the icon on @menu_item.
//
// This call is the same as calling g_icon_serialize() and using the result
// as the value to g_menu_item_set_attribute_value() for
// G_MENU_ATTRIBUTE_ICON.
//
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu. Don't use it on menu
// items corresponding to verbs (eg: stock icons for 'Save' or 'Quit').
//
// If @icon is nil then the icon is unset.
func (m menuItem) SetIcon(icon Icon) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.GIcon     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_menu_item_set_icon(_arg0, _arg1)
}

// SetLabel sets or unsets the "label" attribute of @menu_item.
//
// If @label is non-nil it is used as the label for the menu item. If it is
// nil then the label attribute is unset.
func (m menuItem) SetLabel(label string) {
	var _arg0 *C.GMenuItem // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_menu_item_set_label(_arg0, _arg1)
}

// SetLink creates a link from @menu_item to @model if non-nil, or unsets
// it.
//
// Links are used to establish a relationship between a particular menu item
// and another menu. For example, G_MENU_LINK_SUBMENU is used to associate a
// submenu with a particular menu item, and G_MENU_LINK_SECTION is used to
// create a section. Other types of link can be used, but there is no
// guarantee that clients will be able to make sense of them. Link types are
// restricted to lowercase characters, numbers and '-'. Furthermore, the
// names must begin with a lowercase character, must not end with a '-', and
// must not contain consecutive dashes.
func (m menuItem) SetLink(link string, model MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.gchar)(C.CString(link))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

	C.g_menu_item_set_link(_arg0, _arg1, _arg2)
}

// SetSection sets or unsets the "section" link of @menu_item to @section.
//
// The effect of having one menu appear as a section of another is exactly
// as it sounds: the items from @section become a direct part of the menu
// that @menu_item is added to. See g_menu_item_new_section() for more
// information about what it means for a menu item to be a section.
func (m menuItem) SetSection(section MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(section.Native()))

	C.g_menu_item_set_section(_arg0, _arg1)
}

// SetSubmenu sets or unsets the "submenu" link of @menu_item to @submenu.
//
// If @submenu is non-nil, it is linked to. If it is nil then the link is
// unset.
//
// The effect of having one menu appear as a submenu of another is exactly
// as it sounds.
func (m menuItem) SetSubmenu(submenu MenuModel) {
	var _arg0 *C.GMenuItem  // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GMenuItem)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer(submenu.Native()))

	C.g_menu_item_set_submenu(_arg0, _arg1)
}

// Notification is a mechanism for creating a notification to be shown to the
// user -- typically as a pop-up notification presented by the desktop
// environment shell.
//
// The key difference between #GNotification and other similar APIs is that, if
// supported by the desktop environment, notifications sent with #GNotification
// will persist after the application has exited, and even across system
// reboots.
//
// Since the user may click on a notification while the application is not
// running, applications using #GNotification should be able to be started as a
// D-Bus service, using #GApplication.
//
// User interaction with a notification (either the default action, or buttons)
// must be associated with actions on the application (ie: "app." actions). It
// is not possible to route user interaction through the notification itself,
// because the object will not exist if the application is autostarted as a
// result of a notification being clicked.
//
// A notification can be sent with g_application_send_notification().
type Notification interface {
	gextras.Objector

	// AddButton adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an application-wide
	// action (starting with "app."). If @detailed_action contains a target, the
	// action will be activated with that target as its parameter.
	//
	// See g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	AddButton(label string, detailedAction string)
	// AddButtonWithTargetValue adds a button to @notification that activates
	// @action when clicked. @action must be an application-wide action (it must
	// start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	AddButtonWithTargetValue(label string, action string, target *glib.Variant)
	// SetBody sets the body of @notification to @body.
	SetBody(body string)
	// SetDefaultAction sets the default action of @notification to
	// @detailed_action. This action is activated when the notification is
	// clicked on.
	//
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the given
	// action will be activated with that target as its parameter. See
	// g_action_parse_detailed_name() for a description of the format for
	// @detailed_action.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultAction(detailedAction string)
	// SetDefaultActionAndTargetValue sets the default action of @notification
	// to @action. This action is activated when the notification is clicked on.
	// It must be an application-wide action (start with "app.").
	//
	// If @target is non-nil, @action will be activated with @target as its
	// parameter.
	//
	// When no default action is set, the application that the notification was
	// sent on is activated.
	SetDefaultActionAndTargetValue(action string, target *glib.Variant)
	// SetIcon sets the icon of @notification to @icon.
	SetIcon(icon Icon)
	// SetPriority sets the priority of @notification to @priority. See Priority
	// for possible values.
	SetPriority(priority NotificationPriority)
	// SetTitle sets the title of @notification to @title.
	SetTitle(title string)
	// SetUrgent: deprecated in favor of g_notification_set_priority().
	SetUrgent(urgent bool)
}

// notification implements the Notification class.
type notification struct {
	gextras.Objector
}

var _ Notification = (*notification)(nil)

// WrapNotification wraps a GObject to the right type. It is
// primarily used internally.
func WrapNotification(obj *externglib.Object) Notification {
	return notification{
		Objector: obj,
	}
}

func marshalNotification(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapNotification(obj), nil
}

// NewNotification constructs a class Notification.
func NewNotification(title string) Notification {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.GNotification // in

	_cret = C.g_notification_new(_arg1)

	var _notification Notification // out

	_notification = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Notification)

	return _notification
}

// AddButton adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an application-wide
// action (starting with "app."). If @detailed_action contains a target, the
// action will be activated with that target as its parameter.
//
// See g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
func (n notification) AddButton(label string, detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_notification_add_button(_arg0, _arg1, _arg2)
}

// AddButtonWithTargetValue adds a button to @notification that activates
// @action when clicked. @action must be an application-wide action (it must
// start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
func (n notification) AddButtonWithTargetValue(label string, action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.gchar         // out
	var _arg3 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(label))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_add_button_with_target_value(_arg0, _arg1, _arg2, _arg3)
}

// SetBody sets the body of @notification to @body.
func (n notification) SetBody(body string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(body))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_body(_arg0, _arg1)
}

// SetDefaultAction sets the default action of @notification to
// @detailed_action. This action is activated when the notification is
// clicked on.
//
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the given
// action will be activated with that target as its parameter. See
// g_action_parse_detailed_name() for a description of the format for
// @detailed_action.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (n notification) SetDefaultAction(detailedAction string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(detailedAction))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_default_action(_arg0, _arg1)
}

// SetDefaultActionAndTargetValue sets the default action of @notification
// to @action. This action is activated when the notification is clicked on.
// It must be an application-wide action (start with "app.").
//
// If @target is non-nil, @action will be activated with @target as its
// parameter.
//
// When no default action is set, the application that the notification was
// sent on is activated.
func (n notification) SetDefaultActionAndTargetValue(action string, target *glib.Variant) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(action))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariant)(unsafe.Pointer(target.Native()))

	C.g_notification_set_default_action_and_target_value(_arg0, _arg1, _arg2)
}

// SetIcon sets the icon of @notification to @icon.
func (n notification) SetIcon(icon Icon) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.g_notification_set_icon(_arg0, _arg1)
}

// SetPriority sets the priority of @notification to @priority. See Priority
// for possible values.
func (n notification) SetPriority(priority NotificationPriority) {
	var _arg0 *C.GNotification        // out
	var _arg1 C.GNotificationPriority // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (C.GNotificationPriority)(priority)

	C.g_notification_set_priority(_arg0, _arg1)
}

// SetTitle sets the title of @notification to @title.
func (n notification) SetTitle(title string) {
	var _arg0 *C.GNotification // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	_arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_notification_set_title(_arg0, _arg1)
}

// SetUrgent: deprecated in favor of g_notification_set_priority().
func (n notification) SetUrgent(urgent bool) {
	var _arg0 *C.GNotification // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GNotification)(unsafe.Pointer(n.Native()))
	if urgent {
		_arg1 = C.TRUE
	}

	C.g_notification_set_urgent(_arg0, _arg1)
}

// PropertyAction: a Action is a way to get a #GAction with a state value
// reflecting and controlling the value of a #GObject property.
//
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value matches
// the requirements as specified in the Spec).
//
// Only the most common types are presently supported. Booleans are mapped to
// booleans, strings to strings, signed/unsigned integers to int32/uint32 and
// floats and doubles to doubles.
//
// If the property is an enum then the state will be string-typed and conversion
// will automatically be performed between the enum value and "nick" string as
// per the Value table.
//
// Flags types are not currently supported.
//
// Properties of object types, boxed types and pointer types are not supported
// and probably never will be.
//
// Properties of #GVariant types are not currently supported.
//
// If the property is boolean-valued then the action will have a NULL parameter
// type, and activating the action (with no parameter) will toggle the value of
// the property.
//
// In all other cases, the parameter type will correspond to the type of the
// property.
//
// The general idea here is to reduce the number of locations where a particular
// piece of state is kept (and therefore has to be synchronised between). Action
// does not have a separate state that is kept in sync with the property value
// -- its state is the property value.
//
// For example, it might be useful to create a #GAction corresponding to the
// "visible-child-name" property of a Stack so that the current page can be
// switched from a menu. The active radio indication in the menu is then
// directly determined from the active page of the Stack.
//
// An anti-example would be binding the "active-id" property on a ComboBox. This
// is because the state of the combobox itself is probably uninteresting and is
// actually being used to control something else.
//
// Another anti-example would be to bind to the "visible-child-name" property of
// a Stack if this value is actually stored in #GSettings. In that case, the
// real source of the value is #GSettings. If you want a #GAction to control a
// setting stored in #GSettings, see g_settings_create_action() instead, and
// possibly combine its use with g_settings_bind().
type PropertyAction interface {
	gextras.Objector
	Action
}

// propertyAction implements the PropertyAction class.
type propertyAction struct {
	gextras.Objector
	Action
}

var _ PropertyAction = (*propertyAction)(nil)

// WrapPropertyAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapPropertyAction(obj *externglib.Object) PropertyAction {
	return propertyAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalPropertyAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPropertyAction(obj), nil
}

// NewPropertyAction constructs a class PropertyAction.
func NewPropertyAction(name string, object gextras.Objector, propertyName string) PropertyAction {
	var _arg1 *C.gchar   // out
	var _arg2 C.gpointer // out
	var _arg3 *C.gchar   // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg3 = (*C.gchar)(C.CString(propertyName))
	defer C.free(unsafe.Pointer(_arg3))

	var _cret C.GPropertyAction // in

	_cret = C.g_property_action_new(_arg1, _arg2, _arg3)

	var _propertyAction PropertyAction // out

	_propertyAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(PropertyAction)

	return _propertyAction
}

// SimpleAction: a Action is the obvious simple implementation of the #GAction
// interface. This is the easiest way to create an action for purposes of adding
// it to a ActionGroup.
//
// See also Action.
type SimpleAction interface {
	gextras.Objector
	Action

	// SetEnabled sets the action as enabled or not.
	//
	// An action must be enabled in order to be activated or in order to have
	// its state changed from outside callers.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to modify its enabled flag.
	SetEnabled(enabled bool)
	// SetState sets the state of the action.
	//
	// This directly updates the 'state' property to the given value.
	//
	// This should only be called by the implementor of the action. Users of the
	// action should not attempt to directly modify the 'state' property.
	// Instead, they should call g_action_change_state() to request the change.
	//
	// If the @value GVariant is floating, it is consumed.
	SetState(value *glib.Variant)
	// SetStateHint sets the state hint for the action.
	//
	// See g_action_get_state_hint() for more information about action state
	// hints.
	SetStateHint(stateHint *glib.Variant)
}

// simpleAction implements the SimpleAction class.
type simpleAction struct {
	gextras.Objector
	Action
}

var _ SimpleAction = (*simpleAction)(nil)

// WrapSimpleAction wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleAction(obj *externglib.Object) SimpleAction {
	return simpleAction{
		Objector: obj,
		Action:   WrapAction(obj),
	}
}

func marshalSimpleAction(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleAction(obj), nil
}

// NewSimpleAction constructs a class SimpleAction.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))

	var _cret C.GSimpleAction // in

	_cret = C.g_simple_action_new(_arg1, _arg2)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(SimpleAction)

	return _simpleAction
}

// NewSimpleActionStateful constructs a class SimpleAction.
func NewSimpleActionStateful(name string, parameterType *glib.VariantType, state *glib.Variant) SimpleAction {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GVariantType // out
	var _arg3 *C.GVariant     // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GVariantType)(unsafe.Pointer(parameterType.Native()))
	_arg3 = (*C.GVariant)(unsafe.Pointer(state.Native()))

	var _cret C.GSimpleAction // in

	_cret = C.g_simple_action_new_stateful(_arg1, _arg2, _arg3)

	var _simpleAction SimpleAction // out

	_simpleAction = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(SimpleAction)

	return _simpleAction
}

// SetEnabled sets the action as enabled or not.
//
// An action must be enabled in order to be activated or in order to have
// its state changed from outside callers.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to modify its enabled flag.
func (s simpleAction) SetEnabled(enabled bool) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(_arg0, _arg1)
}

// SetState sets the state of the action.
//
// This directly updates the 'state' property to the given value.
//
// This should only be called by the implementor of the action. Users of the
// action should not attempt to directly modify the 'state' property.
// Instead, they should call g_action_change_state() to request the change.
//
// If the @value GVariant is floating, it is consumed.
func (s simpleAction) SetState(value *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(value.Native()))

	C.g_simple_action_set_state(_arg0, _arg1)
}

// SetStateHint sets the state hint for the action.
//
// See g_action_get_state_hint() for more information about action state
// hints.
func (s simpleAction) SetStateHint(stateHint *glib.Variant) {
	var _arg0 *C.GSimpleAction // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GSimpleAction)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GVariant)(unsafe.Pointer(stateHint.Native()))

	C.g_simple_action_set_state_hint(_arg0, _arg1)
}

// SimpleIOStream: GSimpleIOStream creates a OStream from an arbitrary Stream
// and Stream. This allows any pair of input and output streams to be used with
// OStream methods.
//
// This is useful when you obtained a Stream and a Stream by other means, for
// instance creating them with platform specific methods as
// g_unix_input_stream_new() or g_win32_input_stream_new(), and you want to take
// advantage of the methods provided by OStream.
type SimpleIOStream interface {
	IOStream
}

// simpleIOStream implements the SimpleIOStream class.
type simpleIOStream struct {
	IOStream
}

var _ SimpleIOStream = (*simpleIOStream)(nil)

// WrapSimpleIOStream wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimpleIOStream(obj *externglib.Object) SimpleIOStream {
	return simpleIOStream{
		IOStream: WrapIOStream(obj),
	}
}

func marshalSimpleIOStream(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimpleIOStream(obj), nil
}

// NewSimpleIOStream constructs a class SimpleIOStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) SimpleIOStream {
	var _arg1 *C.GInputStream  // out
	var _arg2 *C.GOutputStream // out

	_arg1 = (*C.GInputStream)(unsafe.Pointer(inputStream.Native()))
	_arg2 = (*C.GOutputStream)(unsafe.Pointer(outputStream.Native()))

	var _cret C.GSimpleIOStream // in

	_cret = C.g_simple_io_stream_new(_arg1, _arg2)

	var _simpleIOStream SimpleIOStream // out

	_simpleIOStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(SimpleIOStream)

	return _simpleIOStream
}

// SimplePermission is a trivial implementation of #GPermission that represents
// a permission that is either always or never allowed. The value is given at
// construction and doesn't change.
//
// Calling request or release will result in errors.
type SimplePermission interface {
	Permission
}

// simplePermission implements the SimplePermission class.
type simplePermission struct {
	Permission
}

var _ SimplePermission = (*simplePermission)(nil)

// WrapSimplePermission wraps a GObject to the right type. It is
// primarily used internally.
func WrapSimplePermission(obj *externglib.Object) SimplePermission {
	return simplePermission{
		Permission: WrapPermission(obj),
	}
}

func marshalSimplePermission(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSimplePermission(obj), nil
}

// NewSimplePermission constructs a class SimplePermission.
func NewSimplePermission(allowed bool) SimplePermission {
	var _arg1 C.gboolean // out

	if allowed {
		_arg1 = C.TRUE
	}

	var _cret C.GSimplePermission // in

	_cret = C.g_simple_permission_new(_arg1)

	var _simplePermission SimplePermission // out

	_simplePermission = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(SimplePermission)

	return _simplePermission
}

// Subprocess allows the creation of and interaction with child processes.
//
// Processes can be communicated with using standard GIO-style APIs (ie: Stream,
// Stream). There are GIO-style APIs to wait for process termination (ie:
// cancellable and with an asynchronous variant).
//
// There is an API to force a process to terminate, as well as a race-free API
// for sending UNIX signals to a subprocess.
//
// One major advantage that GIO brings over the core GLib library is
// comprehensive API for asynchronous I/O, such g_output_stream_splice_async().
// This makes GSubprocess significantly more powerful and flexible than
// equivalent APIs in some other languages such as the `subprocess.py` included
// with Python. For example, using #GSubprocess one could create two child
// processes, reading standard output from the first, processing it, and writing
// to the input stream of the second, all without blocking the main loop.
//
// A powerful g_subprocess_communicate() API is provided similar to the
// `communicate()` method of `subprocess.py`. This enables very easy interaction
// with a subprocess that has been opened with pipes.
//
// #GSubprocess defaults to tight control over the file descriptors open in the
// child process, avoiding dangling-fd issues that are caused by a simple
// fork()/exec(). The only open file descriptors in the spawned process are ones
// that were explicitly specified by the #GSubprocess API (unless
// G_SUBPROCESS_FLAGS_INHERIT_FDS was specified).
//
// #GSubprocess will quickly reap all child processes as they exit, avoiding
// "zombie processes" remaining around for long periods of time.
// g_subprocess_wait() can be used to wait for this to happen, but it will
// happen even without the call being explicitly made.
//
// As a matter of principle, #GSubprocess has no API that accepts shell-style
// space-separated strings. It will, however, match the typical shell behaviour
// of searching the PATH for executables that do not contain a directory
// separator in their name.
//
// #GSubprocess attempts to have a very simple API for most uses (ie: spawning a
// subprocess with arguments and support for most typical kinds of input and
// output redirection). See g_subprocess_new(). The Launcher API is provided for
// more complicated cases (advanced types of redirection, environment variable
// manipulation, change of working directory, child setup functions, etc).
//
// A typical use of #GSubprocess will involve calling g_subprocess_new(),
// followed by g_subprocess_wait_async() or g_subprocess_wait(). After the
// process exits, the status can be checked using functions such as
// g_subprocess_get_if_exited() (which are similar to the familiar
// WIFEXITED-style POSIX macros).
type Subprocess interface {
	gextras.Objector
	Initable

	// CommunicateUTF8: like g_subprocess_communicate(), but validates the
	// output of the process as UTF-8, and returns it as a regular NUL
	// terminated string.
	//
	// On error, @stdout_buf and @stderr_buf will be set to undefined values and
	// should not be used.
	CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error)
	// CommunicateUTF8Finish: complete an invocation of
	// g_subprocess_communicate_utf8_async().
	CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error)
	// ForceExit: use an operating-system specific method to attempt an
	// immediate, forceful termination of the process. There is no mechanism to
	// determine whether or not the request itself was successful; however, you
	// can use g_subprocess_wait() to monitor the status of the process after
	// calling this function.
	//
	// On Unix, this function sends SIGKILL.
	ForceExit()
	// ExitStatus: check the exit status of the subprocess, given that it exited
	// normally. This is the value passed to the exit() system call or the
	// return value from main.
	//
	// This is equivalent to the system WEXITSTATUS macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_exited() returned true.
	ExitStatus() int
	// Identifier: on UNIX, returns the process ID as a decimal string. On
	// Windows, returns the result of GetProcessId() also as a string. If the
	// subprocess has terminated, this will return nil.
	Identifier() string
	// IfExited: check if the given subprocess exited normally (ie: by way of
	// exit() or return from main()).
	//
	// This is equivalent to the system WIFEXITED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfExited() bool
	// IfSignaled: check if the given subprocess terminated in response to a
	// signal.
	//
	// This is equivalent to the system WIFSIGNALED macro.
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	IfSignaled() bool
	// Status gets the raw status code of the process, as from waitpid().
	//
	// This value has no particular meaning, but it can be used with the macros
	// defined by the system headers such as WIFEXITED. It can also be used with
	// g_spawn_check_exit_status().
	//
	// It is more likely that you want to use g_subprocess_get_if_exited()
	// followed by g_subprocess_get_exit_status().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Status() int
	// StderrPipe gets the Stream from which to read the stderr output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
	// otherwise nil will be returned.
	StderrPipe() InputStream
	// StdinPipe gets the Stream that you can write to in order to give data to
	// the stdin of @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and
	// not G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
	StdinPipe() OutputStream
	// StdoutPipe gets the Stream from which to read the stdout output of
	// @subprocess.
	//
	// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
	// otherwise nil will be returned.
	StdoutPipe() InputStream
	// Successful checks if the process was "successful". A process is
	// considered successful if it exited cleanly with an exit status of 0,
	// either by way of the exit() system call or return from main().
	//
	// It is an error to call this function before g_subprocess_wait() has
	// returned.
	Successful() bool
	// TermSig: get the signal number that caused the subprocess to terminate,
	// given that it terminated due to a signal.
	//
	// This is equivalent to the system WTERMSIG macro.
	//
	// It is an error to call this function before g_subprocess_wait() and
	// unless g_subprocess_get_if_signaled() returned true.
	TermSig() int
	// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
	// still running.
	//
	// This API is race-free. If the subprocess has terminated, it will not be
	// signalled.
	//
	// This API is not available on Windows.
	SendSignal(signalNum int)
	// Wait: synchronously wait for the subprocess to terminate.
	//
	// After the process terminates you can query its exit status with functions
	// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
	//
	// This function does not fail in the case of the subprocess having abnormal
	// termination. See g_subprocess_wait_check() for that.
	//
	// Cancelling @cancellable doesn't kill the subprocess. Call
	// g_subprocess_force_exit() if it is desirable.
	Wait(cancellable Cancellable) error
	// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
	WaitCheck(cancellable Cancellable) error
	// WaitCheckFinish collects the result of a previous call to
	// g_subprocess_wait_check_async().
	WaitCheckFinish(result AsyncResult) error
	// WaitFinish collects the result of a previous call to
	// g_subprocess_wait_async().
	WaitFinish(result AsyncResult) error
}

// subprocess implements the Subprocess class.
type subprocess struct {
	gextras.Objector
	Initable
}

var _ Subprocess = (*subprocess)(nil)

// WrapSubprocess wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocess(obj *externglib.Object) Subprocess {
	return subprocess{
		Objector: obj,
		Initable: WrapInitable(obj),
	}
}

func marshalSubprocess(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocess(obj), nil
}

// NewSubprocessV constructs a class Subprocess.
func NewSubprocessV(argv []string, flags SubprocessFlags) (Subprocess, error) {
	var _arg1 **C.gchar
	var _arg2 C.GSubprocessFlags // out

	_arg1 = (**C.gchar)(C.malloc(C.ulong((len(argv) + 1)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.GSubprocessFlags)(flags)

	var _cret C.GSubprocess // in
	var _cerr *C.GError     // in

	_cret = C.g_subprocess_newv(_arg1, _arg2, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

// CommunicateUTF8: like g_subprocess_communicate(), but validates the
// output of the process as UTF-8, and returns it as a regular NUL
// terminated string.
//
// On error, @stdout_buf and @stderr_buf will be set to undefined values and
// should not be used.
func (s subprocess) CommunicateUTF8(stdinBuf string, cancellable Cancellable) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.char         // out
	var _arg2 *C.GCancellable // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.char)(C.CString(stdinBuf))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _arg3 *C.char   // in
	var _arg4 *C.char   // in
	var _cerr *C.GError // in

	C.g_subprocess_communicate_utf8(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_stderrBuf = C.GoString(_arg4)
	defer C.free(unsafe.Pointer(_arg4))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

// CommunicateUTF8Finish: complete an invocation of
// g_subprocess_communicate_utf8_async().
func (s subprocess) CommunicateUTF8Finish(result AsyncResult) (stdoutBuf string, stderrBuf string, goerr error) {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var _arg2 *C.char   // in
	var _arg3 *C.char   // in
	var _cerr *C.GError // in

	C.g_subprocess_communicate_utf8_finish(_arg0, _arg1, &_arg2, &_arg3, &_cerr)

	var _stdoutBuf string // out
	var _stderrBuf string // out
	var _goerr error      // out

	_stdoutBuf = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_stderrBuf = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _stdoutBuf, _stderrBuf, _goerr
}

// ForceExit: use an operating-system specific method to attempt an
// immediate, forceful termination of the process. There is no mechanism to
// determine whether or not the request itself was successful; however, you
// can use g_subprocess_wait() to monitor the status of the process after
// calling this function.
//
// On Unix, this function sends SIGKILL.
func (s subprocess) ForceExit() {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	C.g_subprocess_force_exit(_arg0)
}

// ExitStatus: check the exit status of the subprocess, given that it exited
// normally. This is the value passed to the exit() system call or the
// return value from main.
//
// This is equivalent to the system WEXITSTATUS macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_exited() returned true.
func (s subprocess) ExitStatus() int {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gint // in

	_cret = C.g_subprocess_get_exit_status(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Identifier: on UNIX, returns the process ID as a decimal string. On
// Windows, returns the result of GetProcessId() also as a string. If the
// subprocess has terminated, this will return nil.
func (s subprocess) Identifier() string {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar // in

	_cret = C.g_subprocess_get_identifier(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IfExited: check if the given subprocess exited normally (ie: by way of
// exit() or return from main()).
//
// This is equivalent to the system WIFEXITED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) IfExited() bool {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_subprocess_get_if_exited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IfSignaled: check if the given subprocess terminated in response to a
// signal.
//
// This is equivalent to the system WIFSIGNALED macro.
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) IfSignaled() bool {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_subprocess_get_if_signaled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Status gets the raw status code of the process, as from waitpid().
//
// This value has no particular meaning, but it can be used with the macros
// defined by the system headers such as WIFEXITED. It can also be used with
// g_spawn_check_exit_status().
//
// It is more likely that you want to use g_subprocess_get_if_exited()
// followed by g_subprocess_get_exit_status().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) Status() int {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gint // in

	_cret = C.g_subprocess_get_status(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// StderrPipe gets the Stream from which to read the stderr output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDERR_PIPE,
// otherwise nil will be returned.
func (s subprocess) StderrPipe() InputStream {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret *C.GInputStream // in

	_cret = C.g_subprocess_get_stderr_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(InputStream)

	return _inputStream
}

// StdinPipe gets the Stream that you can write to in order to give data to
// the stdin of @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDIN_PIPE and
// not G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise nil will be returned.
func (s subprocess) StdinPipe() OutputStream {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret *C.GOutputStream // in

	_cret = C.g_subprocess_get_stdin_pipe(_arg0)

	var _outputStream OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(OutputStream)

	return _outputStream
}

// StdoutPipe gets the Stream from which to read the stdout output of
// @subprocess.
//
// The process must have been created with G_SUBPROCESS_FLAGS_STDOUT_PIPE,
// otherwise nil will be returned.
func (s subprocess) StdoutPipe() InputStream {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret *C.GInputStream // in

	_cret = C.g_subprocess_get_stdout_pipe(_arg0)

	var _inputStream InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret.Native()))).(InputStream)

	return _inputStream
}

// Successful checks if the process was "successful". A process is
// considered successful if it exited cleanly with an exit status of 0,
// either by way of the exit() system call or return from main().
//
// It is an error to call this function before g_subprocess_wait() has
// returned.
func (s subprocess) Successful() bool {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gboolean // in

	_cret = C.g_subprocess_get_successful(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TermSig: get the signal number that caused the subprocess to terminate,
// given that it terminated due to a signal.
//
// This is equivalent to the system WTERMSIG macro.
//
// It is an error to call this function before g_subprocess_wait() and
// unless g_subprocess_get_if_signaled() returned true.
func (s subprocess) TermSig() int {
	var _arg0 *C.GSubprocess // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))

	var _cret C.gint // in

	_cret = C.g_subprocess_get_term_sig(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SendSignal sends the UNIX signal @signal_num to the subprocess, if it is
// still running.
//
// This API is race-free. If the subprocess has terminated, it will not be
// signalled.
//
// This API is not available on Windows.
func (s subprocess) SendSignal(signalNum int) {
	var _arg0 *C.GSubprocess // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(signalNum)

	C.g_subprocess_send_signal(_arg0, _arg1)
}

// Wait: synchronously wait for the subprocess to terminate.
//
// After the process terminates you can query its exit status with functions
// such as g_subprocess_get_if_exited() and g_subprocess_get_exit_status().
//
// This function does not fail in the case of the subprocess having abnormal
// termination. See g_subprocess_wait_check() for that.
//
// Cancelling @cancellable doesn't kill the subprocess. Call
// g_subprocess_force_exit() if it is desirable.
func (s subprocess) Wait(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError // in

	C.g_subprocess_wait(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitCheck combines g_subprocess_wait() with g_spawn_check_exit_status().
func (s subprocess) WaitCheck(cancellable Cancellable) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GCancellable // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	var _cerr *C.GError // in

	C.g_subprocess_wait_check(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitCheckFinish collects the result of a previous call to
// g_subprocess_wait_check_async().
func (s subprocess) WaitCheckFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var _cerr *C.GError // in

	C.g_subprocess_wait_check_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// WaitFinish collects the result of a previous call to
// g_subprocess_wait_async().
func (s subprocess) WaitFinish(result AsyncResult) error {
	var _arg0 *C.GSubprocess  // out
	var _arg1 *C.GAsyncResult // out

	_arg0 = (*C.GSubprocess)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	var _cerr *C.GError // in

	C.g_subprocess_wait_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// SubprocessLauncher: this class contains a set of options for launching child
// processes, such as where its standard input and output will be directed, the
// argument list, the environment, and more.
//
// While the #GSubprocess class has high level functions covering popular cases,
// use of this class allows access to more advanced options. It can also be used
// to launch multiple subprocesses with a similar configuration.
type SubprocessLauncher interface {
	gextras.Objector

	// Close closes all the file descriptors previously passed to the object
	// with g_subprocess_launcher_take_fd(),
	// g_subprocess_launcher_take_stderr_fd(), etc.
	//
	// After calling this method, any subsequent calls to
	// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
	// return G_IO_ERROR_CLOSED. This method is idempotent if called more than
	// once.
	//
	// This function is called automatically when the Launcher is disposed, but
	// is provided separately so that garbage collected language bindings can
	// call it earlier to guarantee when FDs are closed.
	Close()
	// env returns the value of the environment variable @variable in the
	// environment of processes launched from this launcher.
	//
	// On UNIX, the returned string can be an arbitrary byte string. On Windows,
	// it will be UTF-8.
	env(variable string) string
	// SetCwd sets the current working directory that processes will be launched
	// with.
	//
	// By default processes are launched with the current working directory of
	// the launching process at the time of launch.
	SetCwd(cwd string)
	// SetEnviron: replace the entire environment of processes launched from
	// this launcher with the given 'environ' variable.
	//
	// Typically you will build this variable by using g_listenv() to copy the
	// process 'environ' and using the functions g_environ_setenv(),
	// g_environ_unsetenv(), etc.
	//
	// As an alternative, you can use g_subprocess_launcher_setenv(),
	// g_subprocess_launcher_unsetenv(), etc.
	//
	// Pass an empty array to set an empty environment. Pass nil to inherit the
	// parent process’ environment. As of GLib 2.54, the parent process’
	// environment will be copied when g_subprocess_launcher_set_environ() is
	// called. Previously, it was copied when the subprocess was executed. This
	// means the copied environment may now be modified (using
	// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
	//
	// On UNIX, all strings in this array can be arbitrary byte strings. On
	// Windows, they should be in UTF-8.
	SetEnviron(env []string)
	// SetFlags sets the flags on the launcher.
	//
	// The default flags are G_SUBPROCESS_FLAGS_NONE.
	//
	// You may not set flags that specify conflicting options for how to handle
	// a particular stdio stream (eg: specifying both
	// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
	//
	// You may also not set a flag that conflicts with a previous call to a
	// function like g_subprocess_launcher_set_stdin_file_path() or
	// g_subprocess_launcher_take_stdout_fd().
	SetFlags(flags SubprocessFlags)
	// SetStderrFilePath sets the file path to use as the stderr for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '2>' at the shell.
	//
	// If you want to send both stdout and stderr to the same file then use
	// G_SUBPROCESS_FLAGS_STDERR_MERGE.
	//
	// You may not set a stderr file path if a stderr fd is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	SetStderrFilePath(path string)
	// SetStdinFilePath sets the file path to use as the stdin for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file must exist or spawning the process will fail.
	//
	// You may not set a stdin file path if a stdin fd is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdinFilePath(path string)
	// SetStdoutFilePath sets the file path to use as the stdout for spawned
	// processes.
	//
	// If @path is nil then any previously given path is unset.
	//
	// The file will be created or truncated when the process is spawned, as
	// would be the case if using '>' at the shell.
	//
	// You may not set a stdout file path if a stdout fd is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	SetStdoutFilePath(path string)
	// Setenv sets the environment variable @variable in the environment of
	// processes launched from this launcher.
	//
	// On UNIX, both the variable's name and value can be arbitrary byte
	// strings, except that the variable's name cannot contain '='. On Windows,
	// they should be in UTF-8.
	Setenv(variable string, value string, overwrite bool)
	// Spawnv creates a #GSubprocess given a provided array of arguments.
	Spawnv(argv []string) (Subprocess, error)
	// TakeFd: transfer an arbitrary file descriptor from parent process to the
	// child. This function takes ownership of the @source_fd; it will be closed
	// in the parent when @self is freed.
	//
	// By default, all file descriptors from the parent will be closed. This
	// function allows you to create (for example) a custom `pipe()` or
	// `socketpair()` before launching the process, and choose the target
	// descriptor in the child.
	//
	// An example use case is GNUPG, which has a command line argument
	// `--passphrase-fd` providing a file descriptor number where it expects the
	// passphrase to be written.
	TakeFd(sourceFd int, targetFd int)
	// TakeStderrFd sets the file descriptor to use as the stderr for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stderr through to the stderr
	// of the parent process.
	//
	// The passed @fd belongs to the Launcher. It will be automatically closed
	// when the launcher is finalized. The file descriptor will also be closed
	// on the child side when executing the spawned process.
	//
	// You may not set a stderr fd if a stderr file path is already set or if
	// the launcher flags contain any flags directing stderr elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStderrFd(fd int)
	// TakeStdinFd sets the file descriptor to use as the stdin for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that if your intention is to have the stdin of the calling process
	// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
	// way to go about doing that.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdin fd if a stdin file path is already set or if the
	// launcher flags contain any flags directing stdin elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdinFd(fd int)
	// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
	// processes.
	//
	// If @fd is -1 then any previously given fd is unset.
	//
	// Note that the default behaviour is to pass stdout through to the stdout
	// of the parent process.
	//
	// The passed @fd is noted but will not be touched in the current process.
	// It is therefore necessary that it be kept open by the caller until the
	// subprocess is spawned. The file descriptor will also not be explicitly
	// closed on the child side, so it must be marked O_CLOEXEC if that's what
	// you want.
	//
	// You may not set a stdout fd if a stdout file path is already set or if
	// the launcher flags contain any flags directing stdout elsewhere.
	//
	// This feature is only available on UNIX.
	TakeStdoutFd(fd int)
	// Unsetenv removes the environment variable @variable from the environment
	// of processes launched from this launcher.
	//
	// On UNIX, the variable's name can be an arbitrary byte string not
	// containing '='. On Windows, it should be in UTF-8.
	Unsetenv(variable string)
}

// subprocessLauncher implements the SubprocessLauncher class.
type subprocessLauncher struct {
	gextras.Objector
}

var _ SubprocessLauncher = (*subprocessLauncher)(nil)

// WrapSubprocessLauncher wraps a GObject to the right type. It is
// primarily used internally.
func WrapSubprocessLauncher(obj *externglib.Object) SubprocessLauncher {
	return subprocessLauncher{
		Objector: obj,
	}
}

func marshalSubprocessLauncher(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSubprocessLauncher(obj), nil
}

// NewSubprocessLauncher constructs a class SubprocessLauncher.
func NewSubprocessLauncher(flags SubprocessFlags) SubprocessLauncher {
	var _arg1 C.GSubprocessFlags // out

	_arg1 = (C.GSubprocessFlags)(flags)

	var _cret C.GSubprocessLauncher // in

	_cret = C.g_subprocess_launcher_new(_arg1)

	var _subprocessLauncher SubprocessLauncher // out

	_subprocessLauncher = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(SubprocessLauncher)

	return _subprocessLauncher
}

// Close closes all the file descriptors previously passed to the object
// with g_subprocess_launcher_take_fd(),
// g_subprocess_launcher_take_stderr_fd(), etc.
//
// After calling this method, any subsequent calls to
// g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
// return G_IO_ERROR_CLOSED. This method is idempotent if called more than
// once.
//
// This function is called automatically when the Launcher is disposed, but
// is provided separately so that garbage collected language bindings can
// call it earlier to guarantee when FDs are closed.
func (s subprocessLauncher) Close() {
	var _arg0 *C.GSubprocessLauncher // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))

	C.g_subprocess_launcher_close(_arg0)
}

// env returns the value of the environment variable @variable in the
// environment of processes launched from this launcher.
//
// On UNIX, the returned string can be an arbitrary byte string. On Windows,
// it will be UTF-8.
func (s subprocessLauncher) env(variable string) string {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret *C.gchar // in

	_cret = C.g_subprocess_launcher_getenv(_arg0, _arg1)

	var _filename string // out

	_filename = C.GoString(_cret)

	return _filename
}

// SetCwd sets the current working directory that processes will be launched
// with.
//
// By default processes are launched with the current working directory of
// the launching process at the time of launch.
func (s subprocessLauncher) SetCwd(cwd string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(cwd))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_cwd(_arg0, _arg1)
}

// SetEnviron: replace the entire environment of processes launched from
// this launcher with the given 'environ' variable.
//
// Typically you will build this variable by using g_listenv() to copy the
// process 'environ' and using the functions g_environ_setenv(),
// g_environ_unsetenv(), etc.
//
// As an alternative, you can use g_subprocess_launcher_setenv(),
// g_subprocess_launcher_unsetenv(), etc.
//
// Pass an empty array to set an empty environment. Pass nil to inherit the
// parent process’ environment. As of GLib 2.54, the parent process’
// environment will be copied when g_subprocess_launcher_set_environ() is
// called. Previously, it was copied when the subprocess was executed. This
// means the copied environment may now be modified (using
// g_subprocess_launcher_setenv(), etc.) before launching the subprocess.
//
// On UNIX, all strings in this array can be arbitrary byte strings. On
// Windows, they should be in UTF-8.
func (s subprocessLauncher) SetEnviron(env []string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong((len(env) + 1)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		out := unsafe.Slice(_arg1, len(env))
		for i := range env {
			out[i] = (*C.gchar)(C.CString(env[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_subprocess_launcher_set_environ(_arg0, _arg1)
}

// SetFlags sets the flags on the launcher.
//
// The default flags are G_SUBPROCESS_FLAGS_NONE.
//
// You may not set flags that specify conflicting options for how to handle
// a particular stdio stream (eg: specifying both
// G_SUBPROCESS_FLAGS_STDIN_PIPE and G_SUBPROCESS_FLAGS_STDIN_INHERIT).
//
// You may also not set a flag that conflicts with a previous call to a
// function like g_subprocess_launcher_set_stdin_file_path() or
// g_subprocess_launcher_take_stdout_fd().
func (s subprocessLauncher) SetFlags(flags SubprocessFlags) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.GSubprocessFlags     // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (C.GSubprocessFlags)(flags)

	C.g_subprocess_launcher_set_flags(_arg0, _arg1)
}

// SetStderrFilePath sets the file path to use as the stderr for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '2>' at the shell.
//
// If you want to send both stdout and stderr to the same file then use
// G_SUBPROCESS_FLAGS_STDERR_MERGE.
//
// You may not set a stderr file path if a stderr fd is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStderrFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stderr_file_path(_arg0, _arg1)
}

// SetStdinFilePath sets the file path to use as the stdin for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file must exist or spawning the process will fail.
//
// You may not set a stdin file path if a stdin fd is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStdinFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdin_file_path(_arg0, _arg1)
}

// SetStdoutFilePath sets the file path to use as the stdout for spawned
// processes.
//
// If @path is nil then any previously given path is unset.
//
// The file will be created or truncated when the process is spawned, as
// would be the case if using '>' at the shell.
//
// You may not set a stdout file path if a stdout fd is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) SetStdoutFilePath(path string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_set_stdout_file_path(_arg0, _arg1)
}

// Setenv sets the environment variable @variable in the environment of
// processes launched from this launcher.
//
// On UNIX, both the variable's name and value can be arbitrary byte
// strings, except that the variable's name cannot contain '='. On Windows,
// they should be in UTF-8.
func (s subprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out
	var _arg2 *C.gchar               // out
	var _arg3 C.gboolean             // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(C.CString(value))
	defer C.free(unsafe.Pointer(_arg2))
	if overwrite {
		_arg3 = C.TRUE
	}

	C.g_subprocess_launcher_setenv(_arg0, _arg1, _arg2, _arg3)
}

// Spawnv creates a #GSubprocess given a provided array of arguments.
func (s subprocessLauncher) Spawnv(argv []string) (Subprocess, error) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 **C.gchar

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong((len(argv) + 1)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))

	{
		out := unsafe.Slice(_arg1, len(argv))
		for i := range argv {
			out[i] = (*C.gchar)(C.CString(argv[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	var _cret *C.GSubprocess // in
	var _cerr *C.GError      // in

	_cret = C.g_subprocess_launcher_spawnv(_arg0, _arg1, &_cerr)

	var _subprocess Subprocess // out
	var _goerr error           // out

	_subprocess = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(Subprocess)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _subprocess, _goerr
}

// TakeFd: transfer an arbitrary file descriptor from parent process to the
// child. This function takes ownership of the @source_fd; it will be closed
// in the parent when @self is freed.
//
// By default, all file descriptors from the parent will be closed. This
// function allows you to create (for example) a custom `pipe()` or
// `socketpair()` before launching the process, and choose the target
// descriptor in the child.
//
// An example use case is GNUPG, which has a command line argument
// `--passphrase-fd` providing a file descriptor number where it expects the
// passphrase to be written.
func (s subprocessLauncher) TakeFd(sourceFd int, targetFd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out
	var _arg2 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(sourceFd)
	_arg2 = C.gint(targetFd)

	C.g_subprocess_launcher_take_fd(_arg0, _arg1, _arg2)
}

// TakeStderrFd sets the file descriptor to use as the stderr for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stderr through to the stderr
// of the parent process.
//
// The passed @fd belongs to the Launcher. It will be automatically closed
// when the launcher is finalized. The file descriptor will also be closed
// on the child side when executing the spawned process.
//
// You may not set a stderr fd if a stderr file path is already set or if
// the launcher flags contain any flags directing stderr elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStderrFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stderr_fd(_arg0, _arg1)
}

// TakeStdinFd sets the file descriptor to use as the stdin for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that if your intention is to have the stdin of the calling process
// inherited by the child then G_SUBPROCESS_FLAGS_STDIN_INHERIT is a better
// way to go about doing that.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdin fd if a stdin file path is already set or if the
// launcher flags contain any flags directing stdin elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStdinFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdin_fd(_arg0, _arg1)
}

// TakeStdoutFd sets the file descriptor to use as the stdout for spawned
// processes.
//
// If @fd is -1 then any previously given fd is unset.
//
// Note that the default behaviour is to pass stdout through to the stdout
// of the parent process.
//
// The passed @fd is noted but will not be touched in the current process.
// It is therefore necessary that it be kept open by the caller until the
// subprocess is spawned. The file descriptor will also not be explicitly
// closed on the child side, so it must be marked O_CLOEXEC if that's what
// you want.
//
// You may not set a stdout fd if a stdout file path is already set or if
// the launcher flags contain any flags directing stdout elsewhere.
//
// This feature is only available on UNIX.
func (s subprocessLauncher) TakeStdoutFd(fd int) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 C.gint                 // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = C.gint(fd)

	C.g_subprocess_launcher_take_stdout_fd(_arg0, _arg1)
}

// Unsetenv removes the environment variable @variable from the environment
// of processes launched from this launcher.
//
// On UNIX, the variable's name can be an arbitrary byte string not
// containing '='. On Windows, it should be in UTF-8.
func (s subprocessLauncher) Unsetenv(variable string) {
	var _arg0 *C.GSubprocessLauncher // out
	var _arg1 *C.gchar               // out

	_arg0 = (*C.GSubprocessLauncher)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(variable))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_subprocess_launcher_unsetenv(_arg0, _arg1)
}

// TestDBus: a helper class for testing code which uses D-Bus without touching
// the user's session bus.
//
// Note that DBus modifies the user’s environment, calling setenv(). This is not
// thread-safe, so all DBus calls should be completed before threads are
// spawned, or should have appropriate locking to ensure no access conflicts to
// environment variables shared between DBus and other threads.
//
//
// Creating unit tests using GTestDBus
//
// Testing of D-Bus services can be tricky because normally we only ever run
// D-Bus services over an existing instance of the D-Bus daemon thus we usually
// don't activate D-Bus services that are not yet installed into the target
// system. The DBus object makes this easier for us by taking care of the lower
// level tasks such as running a private D-Bus daemon and looking up uninstalled
// services in customizable locations, typically in your source code tree.
//
// The first thing you will need is a separate service description file for the
// D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
// is a good place to put this file.
//
// The service file should list your service along with an absolute path to the
// uninstalled service executable in your source tree. Using autotools we would
// achieve this by adding a file such as `my-server.service.in` in the services
// directory and have it processed by configure.
//
//    [D-BUS Service]
//    Name=org.gtk.GDBus.Examples.ObjectManager
//    Exec=@abs_top_builddir@/gio/tests/gdbus-example-objectmanager-server
//
// You will also need to indicate this service directory in your test fixtures,
// so you will need to pass the path while compiling your test cases. Typically
// this is done with autotools with an added preprocessor flag specified to
// compile your tests such as:
//
//       -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
//
//    Once you have a service definition file which is local to your source tree,
//
// you can proceed to set up a GTest fixture using the DBus scaffolding.
//
// An example of a test fixture for D-Bus services can be found here:
// gdbus-test-fixture.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-test-fixture.c)
//
// Note that these examples only deal with isolating the D-Bus aspect of your
// service. To successfully run isolated unit tests on your service you may need
// some additional modifications to your test case fixture. For example; if your
// service uses GSettings and installs a schema then it is important that your
// test service not load the schema in the ordinary installed location (chances
// are that your service and schema files are not yet installed, or worse; there
// is an older version of the schema file sitting in the install location).
//
// Most of the time we can work around these obstacles using the environment.
// Since the environment is inherited by the D-Bus daemon created by DBus and
// then in turn inherited by any services the D-Bus daemon activates, using the
// setup routine for your fixture is a practical place to help sandbox your
// runtime environment. For the rather typical GSettings case we can work around
// this by setting `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your
// schemas in the above fixture_setup() routine.
//
// The GSettings schemas need to be locally pre-compiled for this to work. This
// can be achieved by compiling the schemas locally as a step before running
// test cases, an autotools setup might do the following in the directory
// holding schemas:
//
//        all-am:
//                $(GLIB_COMPILE_SCHEMAS) .
//
//        CLEANFILES += gschemas.compiled
type TestDBus interface {
	gextras.Objector

	// AddServiceDir: add a path where dbus-daemon will look up .service files.
	// This can't be called after g_test_dbus_up().
	AddServiceDir(path string)
	// Down: stop the session bus started by g_test_dbus_up().
	//
	// This will wait for the singleton returned by g_bus_get() or
	// g_bus_get_sync() to be destroyed. This is done to ensure that the next
	// unit test won't get a leaked singleton from this test.
	Down()
	// BusAddress: get the address on which dbus-daemon is running. If
	// g_test_dbus_up() has not been called yet, nil is returned. This can be
	// used with g_dbus_connection_new_for_address().
	BusAddress() string
	// Flags: get the flags of the DBus object.
	Flags() TestDBusFlags
	// Stop: stop the session bus started by g_test_dbus_up().
	//
	// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
	// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
	// wanting to verify behaviour after the session bus has been stopped can
	// use this function but should still call g_test_dbus_down() when done.
	Stop()
	// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
	// this call, it is safe for unit tests to start sending messages on the
	// session bus.
	//
	// If this function is called from setup callback of g_test_add(),
	// g_test_dbus_down() must be called in its teardown callback.
	//
	// If this function is called from unit test's main(), then
	// g_test_dbus_down() must be called after g_test_run().
	Up()
}

// testDBus implements the TestDBus class.
type testDBus struct {
	gextras.Objector
}

var _ TestDBus = (*testDBus)(nil)

// WrapTestDBus wraps a GObject to the right type. It is
// primarily used internally.
func WrapTestDBus(obj *externglib.Object) TestDBus {
	return testDBus{
		Objector: obj,
	}
}

func marshalTestDBus(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTestDBus(obj), nil
}

// NewTestDBus constructs a class TestDBus.
func NewTestDBus(flags TestDBusFlags) TestDBus {
	var _arg1 C.GTestDBusFlags // out

	_arg1 = (C.GTestDBusFlags)(flags)

	var _cret C.GTestDBus // in

	_cret = C.g_test_dbus_new(_arg1)

	var _testDBus TestDBus // out

	_testDBus = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret.Native()))).(TestDBus)

	return _testDBus
}

// AddServiceDir: add a path where dbus-daemon will look up .service files.
// This can't be called after g_test_dbus_up().
func (s testDBus) AddServiceDir(path string) {
	var _arg0 *C.GTestDBus // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.gchar)(C.CString(path))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_test_dbus_add_service_dir(_arg0, _arg1)
}

// Down: stop the session bus started by g_test_dbus_up().
//
// This will wait for the singleton returned by g_bus_get() or
// g_bus_get_sync() to be destroyed. This is done to ensure that the next
// unit test won't get a leaked singleton from this test.
func (s testDBus) Down() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_down(_arg0)
}

// BusAddress: get the address on which dbus-daemon is running. If
// g_test_dbus_up() has not been called yet, nil is returned. This can be
// used with g_dbus_connection_new_for_address().
func (s testDBus) BusAddress() string {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	var _cret *C.gchar // in

	_cret = C.g_test_dbus_get_bus_address(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Flags: get the flags of the DBus object.
func (s testDBus) Flags() TestDBusFlags {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	var _cret C.GTestDBusFlags // in

	_cret = C.g_test_dbus_get_flags(_arg0)

	var _testDBusFlags TestDBusFlags // out

	_testDBusFlags = TestDBusFlags(_cret)

	return _testDBusFlags
}

// Stop: stop the session bus started by g_test_dbus_up().
//
// Unlike g_test_dbus_down(), this won't verify the BusConnection singleton
// returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit tests
// wanting to verify behaviour after the session bus has been stopped can
// use this function but should still call g_test_dbus_down() when done.
func (s testDBus) Stop() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_stop(_arg0)
}

// Up: start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After
// this call, it is safe for unit tests to start sending messages on the
// session bus.
//
// If this function is called from setup callback of g_test_add(),
// g_test_dbus_down() must be called in its teardown callback.
//
// If this function is called from unit test's main(), then
// g_test_dbus_down() must be called after g_test_run().
func (s testDBus) Up() {
	var _arg0 *C.GTestDBus // out

	_arg0 = (*C.GTestDBus)(unsafe.Pointer(s.Native()))

	C.g_test_dbus_up(_arg0)
}
