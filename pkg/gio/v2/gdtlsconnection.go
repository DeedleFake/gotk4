// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_dtls_connection_get_type()), F: marshalDTLSConnection},
	})
}

// DTLSConnection is the base DTLS connection class type, which wraps a Based
// and provides DTLS encryption on top of it. Its subclasses, ClientConnection
// and ServerConnection, implement client-side and server-side DTLS,
// respectively.
//
// For TLS support, see Connection.
//
// As DTLS is datagram based, Connection implements Based, presenting a
// datagram-socket-like API for the encrypted connection. This operates over a
// base datagram connection, which is also a Based (Connection:base-socket).
//
// To close a DTLS connection, use g_dtls_connection_close().
//
// Neither ServerConnection or ClientConnection set the peer address on their
// base Based if it is a #GSocket â€” it is up to the caller to do that if they
// wish. If they do not, and g_socket_close() is called on the base socket, the
// Connection will not raise a G_IO_ERROR_NOT_CONNECTED error on further I/O.
type DTLSConnection interface {
	DatagramBased

	// Close: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Close(cancellable Cancellable) error
	// CloseFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	CloseFinish(result AsyncResult) error
	// EmitAcceptCertificate: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool
	// Certificate: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Certificate() TLSCertificate
	// ChannelBindingData: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	ChannelBindingData(typ TLSChannelBindingType) ([]byte, error)
	// Database: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Database() TLSDatabase
	// Interaction: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Interaction() TLSInteraction
	// NegotiatedProtocol: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	NegotiatedProtocol() string
	// PeerCertificate: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	PeerCertificate() TLSCertificate
	// PeerCertificateErrors: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	PeerCertificateErrors() TLSCertificateFlags
	// RehandshakeMode: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	RehandshakeMode() TLSRehandshakeMode
	// RequireCloseNotify: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	RequireCloseNotify() bool
	// Handshake: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Handshake(cancellable Cancellable) error
	// HandshakeFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	HandshakeFinish(result AsyncResult) error
	// SetAdvertisedProtocols: finish an asynchronous TLS shutdown operation.
	// See g_dtls_connection_shutdown() for more information.
	SetAdvertisedProtocols(protocols []string)
	// SetCertificate: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	SetCertificate(certificate TLSCertificate)
	// SetDatabase: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	SetDatabase(database TLSDatabase)
	// SetInteraction: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	SetInteraction(interaction TLSInteraction)
	// SetRehandshakeMode: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	SetRehandshakeMode(mode TLSRehandshakeMode)
	// SetRequireCloseNotify: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	SetRequireCloseNotify(requireCloseNotify bool)
	// Shutdown: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) error
	// ShutdownFinish: finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	ShutdownFinish(result AsyncResult) error
}

// dtlsConnection implements the DTLSConnection interface.
type dtlsConnection struct {
	DatagramBased
}

var _ DTLSConnection = (*dtlsConnection)(nil)

// WrapDTLSConnection wraps a GObject to a type that implements
// interface DTLSConnection. It is primarily used internally.
func WrapDTLSConnection(obj *externglib.Object) DTLSConnection {
	return dtlsConnection{
		DatagramBased: WrapDatagramBased(obj),
	}
}

func marshalDTLSConnection(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDTLSConnection(obj), nil
}

func (c dtlsConnection) Close(cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_close(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) CloseFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_close_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) EmitAcceptCertificate(peerCert TLSCertificate, errors TLSCertificateFlags) bool {
	var _arg0 *C.GDtlsConnection     // out
	var _arg1 *C.GTlsCertificate     // out
	var _arg2 C.GTlsCertificateFlags // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(peerCert.Native()))
	_arg2 = C.GTlsCertificateFlags(errors)

	_cret = C.g_dtls_connection_emit_accept_certificate(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dtlsConnection) Certificate() TLSCertificate {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c dtlsConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GDtlsConnection       // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray
	var _cerr *C.GError // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.GTlsChannelBindingType(typ)

	C.g_dtls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)

	var _data []byte
	var _goerr error // out

	_data = make([]byte, _arg2.len)
	copy(_data, unsafe.Slice((*byte)(_arg2.data), _arg2.len))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _data, _goerr
}

func (c dtlsConnection) Database() TLSDatabase {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsDatabase    // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_database(_arg0)

	var _tlsDatabase TLSDatabase // out

	_tlsDatabase = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSDatabase)

	return _tlsDatabase
}

func (c dtlsConnection) Interaction() TLSInteraction {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_interaction(_arg0)

	var _tlsInteraction TLSInteraction // out

	_tlsInteraction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSInteraction)

	return _tlsInteraction
}

func (c dtlsConnection) NegotiatedProtocol() string {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_negotiated_protocol(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c dtlsConnection) PeerCertificate() TLSCertificate {
	var _arg0 *C.GDtlsConnection // out
	var _cret *C.GTlsCertificate // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_peer_certificate(_arg0)

	var _tlsCertificate TLSCertificate // out

	_tlsCertificate = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TLSCertificate)

	return _tlsCertificate
}

func (c dtlsConnection) PeerCertificateErrors() TLSCertificateFlags {
	var _arg0 *C.GDtlsConnection     // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_peer_certificate_errors(_arg0)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

func (c dtlsConnection) RehandshakeMode() TLSRehandshakeMode {
	var _arg0 *C.GDtlsConnection    // out
	var _cret C.GTlsRehandshakeMode // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_rehandshake_mode(_arg0)

	var _tlsRehandshakeMode TLSRehandshakeMode // out

	_tlsRehandshakeMode = TLSRehandshakeMode(_cret)

	return _tlsRehandshakeMode
}

func (c dtlsConnection) RequireCloseNotify() bool {
	var _arg0 *C.GDtlsConnection // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))

	_cret = C.g_dtls_connection_get_require_close_notify(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c dtlsConnection) Handshake(cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_handshake(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) HandshakeFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_handshake_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) SetAdvertisedProtocols(protocols []string) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 **C.gchar

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (**C.gchar)(C.malloc(C.ulong(len(protocols)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(protocols))
		for i := range protocols {
			out[i] = (*C.gchar)(C.CString(protocols[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.g_dtls_connection_set_advertised_protocols(_arg0, _arg1)
}

func (c dtlsConnection) SetCertificate(certificate TLSCertificate) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsCertificate // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsCertificate)(unsafe.Pointer(certificate.Native()))

	C.g_dtls_connection_set_certificate(_arg0, _arg1)
}

func (c dtlsConnection) SetDatabase(database TLSDatabase) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsDatabase    // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(database.Native()))

	C.g_dtls_connection_set_database(_arg0, _arg1)
}

func (c dtlsConnection) SetInteraction(interaction TLSInteraction) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(interaction.Native()))

	C.g_dtls_connection_set_interaction(_arg0, _arg1)
}

func (c dtlsConnection) SetRehandshakeMode(mode TLSRehandshakeMode) {
	var _arg0 *C.GDtlsConnection    // out
	var _arg1 C.GTlsRehandshakeMode // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = C.GTlsRehandshakeMode(mode)

	C.g_dtls_connection_set_rehandshake_mode(_arg0, _arg1)
}

func (c dtlsConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	if requireCloseNotify {
		_arg1 = C.TRUE
	}

	C.g_dtls_connection_set_require_close_notify(_arg0, _arg1)
}

func (c dtlsConnection) Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 C.gboolean         // out
	var _arg2 C.gboolean         // out
	var _arg3 *C.GCancellable    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	if shutdownRead {
		_arg1 = C.TRUE
	}
	if shutdownWrite {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))

	C.g_dtls_connection_shutdown(_arg0, _arg1, _arg2, _arg3, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c dtlsConnection) ShutdownFinish(result AsyncResult) error {
	var _arg0 *C.GDtlsConnection // out
	var _arg1 *C.GAsyncResult    // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GDtlsConnection)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.g_dtls_connection_shutdown_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}
