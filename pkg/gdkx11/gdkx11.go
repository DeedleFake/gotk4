// Code generated by girgen. DO NOT EDIT.

package gdkx11

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gdk"
	"github.com/diamondburned/gotk4/pkg/xlib"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4-x11
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk/x11/gdkx.h>
//
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		// Skipped X11DeviceType.

		// Records
		// Skipped X11AppLaunchContextClass.
		// Skipped X11DeviceManagerXI2Class.
		// Skipped X11DeviceXI2Class.
		// Skipped X11DisplayClass.
		// Skipped X11DragClass.
		// Skipped X11GLContextClass.
		// Skipped X11MonitorClass.
		// Skipped X11ScreenClass.
		// Skipped X11SurfaceClass.

		// Classes
		{T: externglib.Type(C.gdk_x11_app_launch_context_get_type()), F: marshalX11AppLaunchContext},
		{T: externglib.Type(C.gdk_x11_device_manager_xi2_get_type()), F: marshalX11DeviceManagerXI2},
		{T: externglib.Type(C.gdk_x11_device_xi2_get_type()), F: marshalX11DeviceXI2},
		{T: externglib.Type(C.gdk_x11_display_get_type()), F: marshalX11Display},
		{T: externglib.Type(C.gdk_x11_drag_get_type()), F: marshalX11Drag},
		// Skipped X11GLContext.
		{T: externglib.Type(C.gdk_x11_monitor_get_type()), F: marshalX11Monitor},
		{T: externglib.Type(C.gdk_x11_screen_get_type()), F: marshalX11Screen},
		{T: externglib.Type(C.gdk_x11_surface_get_type()), F: marshalX11Surface},
	})
}

type X11DeviceType int

const (
	X11DeviceTypeLogical X11DeviceType = 0

	X11DeviceTypePhysical X11DeviceType = 1

	X11DeviceTypeFloating X11DeviceType = 2
)

// X11DeviceGetID returns the device ID as seen by XInput2.
func X11DeviceGetID(device X11DeviceXI2) int {
	var arg0 X11DeviceXI2
	arg0 = wrapX11DeviceXI2(externglib.Take(unsafe.Pointer(device)))

	ret := C.gdk_x11_device_get_id(arg0)

	var ret0 int
	ret0 = int(ret)

	return ret0
}

// X11DeviceManagerLookup returns the Device that wraps the given device ID.
func X11DeviceManagerLookup(deviceManager X11DeviceManagerXI2, deviceID int) X11DeviceXI2 {
	var arg0 X11DeviceManagerXI2
	arg0 = wrapX11DeviceManagerXI2(externglib.Take(unsafe.Pointer(deviceManager)))

	var arg1 int
	arg1 = int(deviceID)

	ret := C.gdk_x11_device_manager_lookup(arg0, arg1)

	var ret0 X11DeviceXI2
	ret0 = wrapX11DeviceXI2(externglib.Take(unsafe.Pointer(ret)))

	return ret0
}

// X11FreeCompoundText frees the data returned from
// gdk_x11_display_string_to_compound_text().
func X11FreeCompoundText(ctext uint8) {
	var arg0 uint8
	arg0 = uint8(ctext)

	C.gdk_x11_free_compound_text(arg0)
}

// X11FreeTextList frees the array of strings created by
// gdk_x11_display_text_property_to_text_list().
func X11FreeTextList(list string) {
	var arg0 string
	arg0 = C.GoString(list)
	defer C.free(unsafe.Pointer(list))

	C.gdk_x11_free_text_list(arg0)
}

// X11GetServerTime: routine to get the current X server time stamp.
func X11GetServerTime(surface X11Surface) uint32 {
	var arg0 X11Surface
	arg0 = wrapX11Surface(externglib.Take(unsafe.Pointer(surface)))

	ret := C.gdk_x11_get_server_time(arg0)

	var ret0 uint32
	ret0 = uint32(ret)

	return ret0
}

// X11GetXatomByNameForDisplay returns the X atom for a Display corresponding to
// @atom_name. This function caches the result, so if called repeatedly it is
// much faster than XInternAtom(), which is a round trip to the server each
// time.
func X11GetXatomByNameForDisplay(display X11Display, atomName string) xlib.Atom {
	var arg0 X11Display
	arg0 = wrapX11Display(externglib.Take(unsafe.Pointer(display)))

	var arg1 string
	arg1 = C.GoString(atomName)
	defer C.free(unsafe.Pointer(atomName))

	ret := C.gdk_x11_get_xatom_by_name_for_display(arg0, arg1)

	var ret0 xlib.Atom
	{
		tmp := uint32(ret)
		ret0 = Atom(tmp)
	}

	return ret0
}

// X11GetXatomNameForDisplay returns the name of an X atom for its display. This
// function is meant mainly for debugging, so for convenience, unlike
// XAtomName() and the result doesn’t need to be freed.
func X11GetXatomNameForDisplay(display X11Display, xatom xlib.Atom) string {
	var arg0 X11Display
	arg0 = wrapX11Display(externglib.Take(unsafe.Pointer(display)))

	var arg1 xlib.Atom
	{
		tmp := uint32(xatom)
		arg1 = Atom(tmp)
	}

	ret := C.gdk_x11_get_xatom_name_for_display(arg0, arg1)

	var ret0 string
	ret0 = C.GoString(ret)
	defer C.free(unsafe.Pointer(ret))

	return ret0
}

// X11LookupXdisplay: find the Display corresponding to @xdisplay, if any
// exists.
func X11LookupXdisplay(xdisplay *xlib.Display) X11Display {
	var arg0 *xlib.Display
	arg0 = wrapDisplay(xdisplay)

	ret := C.gdk_x11_lookup_xdisplay(arg0)

	var ret0 X11Display
	ret0 = wrapX11Display(externglib.Take(unsafe.Pointer(ret)))

	return ret0
}

// X11SetSmClientID sets the `SM_CLIENT_ID` property on the application’s leader
// window so that the window manager can save the application’s state using the
// X11R6 ICCCM session management protocol.
//
// See the X Session Management Library documentation for more information on
// session management and the Inter-Client Communication Conventions Manual
func X11SetSmClientID(smClientID string) {
	var arg0 string
	arg0 = C.GoString(smClientID)
	defer C.free(unsafe.Pointer(smClientID))

	C.gdk_x11_set_sm_client_id(arg0)
}

type X11AppLaunchContext interface {
	gdk.AppLaunchContext
}

type x11AppLaunchContext struct {
	gdk.appLaunchContext
}

func wrapX11AppLaunchContext(obj *externglib.Object) X11AppLaunchContext {
	return x11AppLaunchContext{gdk.appLaunchContext{gio.appLaunchContext{*externglib.Object{obj}}}}
}

func marshalX11AppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

type X11DeviceManagerXI2 interface {
	gextras.Objector
}

type x11DeviceManagerXI2 struct {
	*externglib.Object
}

func wrapX11DeviceManagerXI2(obj *externglib.Object) X11DeviceManagerXI2 {
	return x11DeviceManagerXI2{*externglib.Object{obj}}
}

func marshalX11DeviceManagerXI2(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

type X11DeviceXI2 interface {
	gdk.Device
}

type x11DeviceXI2 struct {
	gdk.device
}

func wrapX11DeviceXI2(obj *externglib.Object) X11DeviceXI2 {
	return x11DeviceXI2{gdk.device{*externglib.Object{obj}}}
}

func marshalX11DeviceXI2(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

type X11Display interface {
	gdk.Display

	// ErrorTrapPop pops the error trap pushed by
	// gdk_x11_display_error_trap_push(). Will XSync() if necessary and will
	// always block until the error is known to have occurred or not occurred,
	// so the error code can be returned.
	//
	// If you don’t need to use the return value,
	// gdk_x11_display_error_trap_pop_ignored() would be more efficient.
	ErrorTrapPop() int
	// ErrorTrapPopIgnored pops the error trap pushed by
	// gdk_x11_display_error_trap_push(). Does not block to see if an error
	// occurred; merely records the range of requests to ignore errors for, and
	// ignores those errors if they arrive asynchronously.
	ErrorTrapPopIgnored()
	// ErrorTrapPush begins a range of X requests on @display for which X error
	// events will be ignored. Unignored errors (when no trap is pushed) will
	// abort the application. Use gdk_x11_display_error_trap_pop() or
	// gdk_x11_display_error_trap_pop_ignored()to lift a trap pushed with this
	// function.
	ErrorTrapPush()
	// DefaultGroup returns the default group leader surface for all toplevel
	// surfaces on @display. This surface is implicitly created by GDK. See
	// gdk_x11_surface_set_group().
	DefaultGroup() gdk.Surface
	// GlxVersion retrieves the version of the GLX implementation.
	GlxVersion() (major int, minor int, ok bool)
	// PrimaryMonitor gets the primary monitor for the display.
	//
	// The primary monitor is considered the monitor where the “main desktop”
	// lives. While normal application surfaces typically allow the window
	// manager to place the surfaces, specialized desktop applications such as
	// panels should place themselves on the primary monitor.
	//
	// If no monitor is the designated primary monitor, any monitor (usually the
	// first) may be returned.
	PrimaryMonitor() gdk.Monitor
	// Screen retrieves the X11Screen of the @display.
	Screen() X11Screen
	// StartupNotificationID gets the startup notification ID for a display.
	StartupNotificationID() string
	// UserTime returns the timestamp of the last user interaction on @display.
	// The timestamp is taken from events caused by user interaction such as key
	// presses or pointer movements. See gdk_x11_surface_set_user_time().
	UserTime() uint32
	// Xcursor returns the X cursor belonging to a Cursor, potentially creating
	// the cursor.
	//
	// Be aware that the returned cursor may not be unique to @cursor. It may
	// for example be shared with its fallback cursor. On old X servers that
	// don't support the XCursor extension, all cursors may even fall back to a
	// few default cursors.
	Xcursor(cursor gdk.Cursor) xlib.Cursor
	// Xdisplay returns the X display of a Display.
	Xdisplay() *xlib.Display
	// Xrootwindow returns the root X window used by Display.
	Xrootwindow() xlib.Window
	// Xscreen returns the X Screen used by Display.
	Xscreen() *xlib.Screen
	// Grab: call XGrabServer() on @display. To ungrab the display again, use
	// gdk_x11_display_ungrab().
	//
	// gdk_x11_display_grab()/gdk_x11_display_ungrab() calls can be nested.
	Grab()
	// SetCursorTheme sets the cursor theme from which the images for cursor
	// should be taken.
	//
	// If the windowing system supports it, existing cursors created with
	// gdk_cursor_new_from_name() are updated to reflect the theme change.
	// Custom cursors constructed with gdk_cursor_new_from_texture() will have
	// to be handled by the application (GTK applications can learn about cursor
	// theme changes by listening for change notification for the corresponding
	// Setting).
	SetCursorTheme(theme string, size int)
	// SetStartupNotificationID sets the startup notification ID for a display.
	//
	// This is usually taken from the value of the DESKTOP_STARTUP_ID
	// environment variable, but in some cases (such as the application not
	// being launched using exec()) it can come from other sources.
	//
	// If the ID contains the string "_TIME" then the portion following that
	// string is taken to be the X11 timestamp of the event that triggered the
	// application to be launched and the GDK current event time is set
	// accordingly.
	//
	// The startup ID is also what is used to signal that the startup is
	// complete (for example, when opening a window or when calling
	// gdk_display_notify_startup_complete()).
	SetStartupNotificationID(startupID string)
	// SetSurfaceScale forces a specific window scale for all windows on this
	// display, instead of using the default or user configured scale. This is
	// can be used to disable scaling support by setting @scale to 1, or to
	// programmatically set the window scale.
	//
	// Once the scale is set by this call it will not change in response to
	// later user configuration changes.
	SetSurfaceScale(scale int)
	// StringToCompoundText: convert a string from the encoding of the current
	// locale into a form suitable for storing in a window property.
	StringToCompoundText(str string) (encoding string, format int, ctext []uint8, length int, gint int)
	// TextPropertyToTextList: convert a text string from the encoding as it is
	// stored in a property into an array of strings in the encoding of the
	// current locale. (The elements of the array represent the nul-separated
	// elements of the original text string.)
	TextPropertyToTextList(encoding string, format int, text uint8, length int, list string) int
	// Ungrab: ungrab @display after it has been grabbed with
	// gdk_x11_display_grab().
	Ungrab()
	// UTF8ToCompoundText converts from UTF-8 to compound text.
	UTF8ToCompoundText(str string) (encoding string, format int, ctext []uint8, length int, ok bool)
}

type x11Display struct {
	gdk.display
}

func wrapX11Display(obj *externglib.Object) X11Display {
	return x11Display{gdk.display{*externglib.Object{obj}}}
}

func marshalX11Display(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (x x11Display) ErrorTrapPop() int

func (x x11Display) ErrorTrapPopIgnored()

func (x x11Display) ErrorTrapPush()

func (x x11Display) DefaultGroup() gdk.Surface

func (x x11Display) GlxVersion() (major int, minor int, ok bool)

func (x x11Display) PrimaryMonitor() gdk.Monitor

func (x x11Display) Screen() X11Screen

func (x x11Display) StartupNotificationID() string

func (x x11Display) UserTime() uint32

func (x x11Display) Xcursor(cursor gdk.Cursor) xlib.Cursor

func (x x11Display) Xdisplay() *xlib.Display

func (x x11Display) Xrootwindow() xlib.Window

func (x x11Display) Xscreen() *xlib.Screen

func (x x11Display) Grab()

func (x x11Display) SetCursorTheme(theme string, size int)

func (x x11Display) SetStartupNotificationID(startupID string)

func (x x11Display) SetSurfaceScale(scale int)

func (x x11Display) StringToCompoundText(str string) (encoding string, format int, ctext []uint8, length int, gint int)

func (x x11Display) TextPropertyToTextList(encoding string, format int, text uint8, length int, list string) int

func (x x11Display) Ungrab()

func (x x11Display) UTF8ToCompoundText(str string) (encoding string, format int, ctext []uint8, length int, ok bool)

type X11Drag interface {
	gdk.Drag
}

type x11Drag struct {
	gdk.drag
}

func wrapX11Drag(obj *externglib.Object) X11Drag {
	return x11Drag{gdk.drag{*externglib.Object{obj}}}
}

func marshalX11Drag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

type X11Monitor interface {
	gdk.Monitor

	// Output returns the XID of the Output corresponding to @monitor.
	Output() xlib.XID
	// Workarea retrieves the size and position of the “work area” on a monitor
	// within the display coordinate space. The returned geometry is in
	// ”application pixels”, not in ”device pixels” (see
	// gdk_monitor_get_scale_factor()).
	Workarea() gdk.Rectangle
}

type x11Monitor struct {
	gdk.monitor
}

func wrapX11Monitor(obj *externglib.Object) X11Monitor {
	return x11Monitor{gdk.monitor{*externglib.Object{obj}}}
}

func marshalX11Monitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (x x11Monitor) Output() xlib.XID

func (x x11Monitor) Workarea() gdk.Rectangle

type X11Screen interface {
	gextras.Objector

	// CurrentDesktop returns the current workspace for @screen when running
	// under a window manager that supports multiple workspaces, as described in
	// the [Extended Window Manager
	// Hints](http://www.freedesktop.org/Standards/wm-spec) specification.
	CurrentDesktop() uint32
	// MonitorOutput gets the XID of the specified output/monitor. If the X
	// server does not support version 1.2 of the RANDR extension, 0 is
	// returned.
	MonitorOutput(monitorNum int) xlib.XID
	// NumberOfDesktops returns the number of workspaces for @screen when
	// running under a window manager that supports multiple workspaces, as
	// described in the [Extended Window Manager
	// Hints](http://www.freedesktop.org/Standards/wm-spec) specification.
	NumberOfDesktops() uint32
	// ScreenNumber returns the index of a X11Screen.
	ScreenNumber() int
	// WindowManagerName returns the name of the window manager for @screen.
	WindowManagerName() string
	// Xscreen returns the screen of a X11Screen.
	Xscreen() *xlib.Screen
	// SupportsNetWmHint: this function is specific to the X11 backend of GDK,
	// and indicates whether the window manager supports a certain hint from the
	// [Extended Window Manager
	// Hints](http://www.freedesktop.org/Standards/wm-spec) specification.
	//
	// When using this function, keep in mind that the window manager can change
	// over time; so you shouldn’t use this function in a way that impacts
	// persistent application state. A common bug is that your application can
	// start up before the window manager does when the user logs in, and before
	// the window manager starts gdk_x11_screen_supports_net_wm_hint() will
	// return false for every property. You can monitor the
	// window_manager_changed signal on X11Screen to detect a window manager
	// change.
	SupportsNetWmHint(propertyName string) bool
}

type x11Screen struct {
	*externglib.Object
}

func wrapX11Screen(obj *externglib.Object) X11Screen {
	return x11Screen{*externglib.Object{obj}}
}

func marshalX11Screen(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (x x11Screen) CurrentDesktop() uint32

func (x x11Screen) MonitorOutput(monitorNum int) xlib.XID

func (x x11Screen) NumberOfDesktops() uint32

func (x x11Screen) ScreenNumber() int

func (x x11Screen) WindowManagerName() string

func (x x11Screen) Xscreen() *xlib.Screen

func (x x11Screen) SupportsNetWmHint(propertyName string) bool

type X11Surface interface {
	gdk.Surface

	// Desktop gets the number of the workspace @surface is on.
	Desktop() uint32
	// Group returns the group this surface belongs to.
	Group() gdk.Surface
	// Xid returns the X resource (surface) belonging to a Surface.
	Xid() xlib.Window
	// MoveToCurrentDesktop moves the surface to the correct workspace when
	// running under a window manager that supports multiple workspaces, as
	// described in the [Extended Window Manager
	// Hints](http://www.freedesktop.org/Standards/wm-spec) specification. Will
	// not do anything if the surface is already on all workspaces.
	MoveToCurrentDesktop()
	// MoveToDesktop moves the surface to the given workspace when running unde
	// a window manager that supports multiple workspaces, as described in the
	// [Extended Window Manager
	// Hints](http://www.freedesktop.org/Standards/wm-spec) specification.
	MoveToDesktop(desktop uint32)
	// SetFrameSyncEnabled: this function can be used to disable frame
	// synchronization for a surface. Normally frame synchronziation will be
	// enabled or disabled based on whether the system has a compositor that
	// supports frame synchronization, but if the surface is not directly
	// managed by the window manager, then frame synchronziation may need to be
	// disabled. This is the case for a surface embedded via the XEMBED
	// protocol.
	SetFrameSyncEnabled(frameSyncEnabled bool)
	// SetGroup sets the group leader of @surface to be @leader. See the ICCCM
	// for details.
	SetGroup(leader gdk.Surface)
	// SetSkipPagerHint sets a hint on @surface that pagers should not display
	// it. See the EWMH for details.
	SetSkipPagerHint(skipsPager bool)
	// SetSkipTaskbarHint sets a hint on @surface that taskbars should not
	// display it. See the EWMH for details.
	SetSkipTaskbarHint(skipsTaskbar bool)
	// SetThemeVariant: GTK applications can request a dark theme variant. In
	// order to make other applications - namely window managers using GTK for
	// themeing - aware of this choice, GTK uses this function to export the
	// requested theme variant as _GTK_THEME_VARIANT property on toplevel
	// surfaces.
	//
	// Note that this property is automatically updated by GTK, so this function
	// should only be used by applications which do not use GTK to create
	// toplevel surfaces.
	SetThemeVariant(variant string)
	// SetUrgencyHint sets a hint on @surface that it needs user attention. See
	// the ICCCM for details.
	SetUrgencyHint(urgent bool)
	// SetUserTime: the application can use this call to update the
	// _NET_WM_USER_TIME property on a toplevel surface. This property stores an
	// Xserver time which represents the time of the last user input event
	// received for this surface. This property may be used by the window
	// manager to alter the focus, stacking, and/or placement behavior of
	// surfaces when they are mapped depending on whether the new surface was
	// created by a user action or is a "pop-up" surface activated by a timer or
	// some other event.
	//
	// Note that this property is automatically updated by GDK, so this function
	// should only be used by applications which handle input events bypassing
	// GDK.
	SetUserTime(timestamp uint32)
	// SetUTF8Property: this function modifies or removes an arbitrary X11
	// window property of type UTF8_STRING. If the given @surface is not a
	// toplevel surface, it is ignored.
	SetUTF8Property(name string, value string)
}

type x11Surface struct {
	gdk.surface
}

func wrapX11Surface(obj *externglib.Object) X11Surface {
	return x11Surface{gdk.surface{*externglib.Object{obj}}}
}

func marshalX11Surface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func (x x11Surface) Desktop() uint32

func (x x11Surface) Group() gdk.Surface

func (x x11Surface) Xid() xlib.Window

func (x x11Surface) MoveToCurrentDesktop()

func (x x11Surface) MoveToDesktop(desktop uint32)

func (x x11Surface) SetFrameSyncEnabled(frameSyncEnabled bool)

func (x x11Surface) SetGroup(leader gdk.Surface)

func (x x11Surface) SetSkipPagerHint(skipsPager bool)

func (x x11Surface) SetSkipTaskbarHint(skipsTaskbar bool)

func (x x11Surface) SetThemeVariant(variant string)

func (x x11Surface) SetUrgencyHint(urgent bool)

func (x x11Surface) SetUserTime(timestamp uint32)

func (x x11Surface) SetUTF8Property(name string, value string)
