// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_socket_get_type()), F: marshalSocket},
	})
}

// Socket: together with Plug, Socket provides the ability to embed accessibles
// from one process into another in a fashion that is transparent to assistive
// technologies. Socket works as the container of Plug, embedding it using the
// method atk_socket_embed(). Any accessible contained in the Plug will appear
// to the assistive technologies as being inside the application that created
// the Socket.
//
// The communication between a Socket and a Plug is done by the IPC layer of the
// accessibility framework, normally implemented by the D-Bus based
// implementation of AT-SPI (at-spi2). If that is the case, at-spi-atk2 is the
// responsible to implement the abstract methods atk_plug_get_id() and
// atk_socket_embed(), so an ATK implementor shouldn't reimplement them. The
// process that contains the Plug is responsible to send the ID returned by
// atk_plug_id() to the process that contains the Socket, so it could call the
// method atk_socket_embed() in order to embed it.
//
// For the same reasons, an implementor doesn't need to implement
// atk_object_get_n_accessible_children() and atk_object_ref_accessible_child().
// All the logic related to those functions will be implemented by the IPC
// layer.
type Socket interface {
	Object
	Component

	EmbedSocket(plugId string)

	IsOccupiedSocket() bool
}

// socket implements the Socket class.
type socket struct {
	Object
}

// WrapSocket wraps a GObject to the right type. It is
// primarily used internally.
func WrapSocket(obj *externglib.Object) Socket {
	return socket{
		Object: WrapObject(obj),
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSocket(obj), nil
}

func NewSocket() Socket {
	var _cret *C.AtkObject // in

	_cret = C.atk_socket_new()

	var _socket Socket // out

	_socket = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Socket)

	return _socket
}

func (o socket) EmbedSocket(plugId string) {
	var _arg0 *C.AtkSocket // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkSocket)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.gchar)(C.CString(plugId))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_socket_embed(_arg0, _arg1)
}

func (o socket) IsOccupiedSocket() bool {
	var _arg0 *C.AtkSocket // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AtkSocket)(unsafe.Pointer(o.Native()))

	_cret = C.atk_socket_is_occupied(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c socket) Contains(x int, y int, coordType CoordType) bool {
	return WrapComponent(gextras.InternObject(c)).Contains(x, y, coordType)
}

func (c socket) Alpha() float64 {
	return WrapComponent(gextras.InternObject(c)).Alpha()
}

func (c socket) Extents(coordType CoordType) (x int, y int, width int, height int) {
	return WrapComponent(gextras.InternObject(c)).Extents(coordType)
}

func (c socket) Layer() Layer {
	return WrapComponent(gextras.InternObject(c)).Layer()
}

func (c socket) MdiZorder() int {
	return WrapComponent(gextras.InternObject(c)).MdiZorder()
}

func (c socket) Position(coordType CoordType) (x int, y int) {
	return WrapComponent(gextras.InternObject(c)).Position(coordType)
}

func (c socket) Size() (width int, height int) {
	return WrapComponent(gextras.InternObject(c)).Size()
}

func (c socket) GrabFocus() bool {
	return WrapComponent(gextras.InternObject(c)).GrabFocus()
}

func (c socket) RefAccessibleAtPoint(x int, y int, coordType CoordType) Object {
	return WrapComponent(gextras.InternObject(c)).RefAccessibleAtPoint(x, y, coordType)
}

func (c socket) RemoveFocusHandler(handlerId uint) {
	WrapComponent(gextras.InternObject(c)).RemoveFocusHandler(handlerId)
}

func (c socket) ScrollTo(typ ScrollType) bool {
	return WrapComponent(gextras.InternObject(c)).ScrollTo(typ)
}

func (c socket) ScrollToPoint(coords CoordType, x int, y int) bool {
	return WrapComponent(gextras.InternObject(c)).ScrollToPoint(coords, x, y)
}

func (c socket) SetExtents(x int, y int, width int, height int, coordType CoordType) bool {
	return WrapComponent(gextras.InternObject(c)).SetExtents(x, y, width, height, coordType)
}

func (c socket) SetPosition(x int, y int, coordType CoordType) bool {
	return WrapComponent(gextras.InternObject(c)).SetPosition(x, y, coordType)
}

func (c socket) SetSize(width int, height int) bool {
	return WrapComponent(gextras.InternObject(c)).SetSize(width, height)
}
