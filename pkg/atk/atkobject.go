// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_layer_get_type()), F: marshalLayer},
		{T: externglib.Type(C.atk_role_get_type()), F: marshalRole},
		{T: externglib.Type(C.atk_implementor_get_type()), F: marshalImplementorIface},
		{T: externglib.Type(C.atk_object_get_type()), F: marshalObject},
	})
}

// AttributeSet: this is a singly-linked list (a List) of Attribute. It is used
// by atk_text_get_run_attributes(), atk_text_get_default_attributes(),
// atk_editable_text_set_run_attributes(), atk_document_get_attributes() and
// atk_object_get_attributes()
type AttributeSet = externglib.SList

// Layer describes the layer of a component
//
// These enumerated "layer values" are used when determining which UI rendering
// layer a component is drawn into, which can help in making determinations of
// when components occlude one another.
type Layer int

const (
	// invalid: the object does not have a layer
	LayerInvalid Layer = 0
	// background: this layer is reserved for the desktop background
	LayerBackground Layer = 1
	// canvas: this layer is used for Canvas components
	LayerCanvas Layer = 2
	// widget: this layer is normally used for components
	LayerWidget Layer = 3
	// mdi: this layer is used for layered components
	LayerMdi Layer = 4
	// popup: this layer is used for popup components, such as menus
	LayerPopup Layer = 5
	// overlay: this layer is reserved for future use.
	LayerOverlay Layer = 6
	// window: this layer is used for toplevel windows.
	LayerWindow Layer = 7
)

func marshalLayer(p uintptr) (interface{}, error) {
	return Layer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Role describes the role of an object
//
// These are the built-in enumerated roles that UI components can have in ATK.
// Other roles may be added at runtime, so an AtkRole >= ATK_ROLE_LAST_DEFINED
// is not necessarily an error.
type Role int

const (
	// invalid: invalid role
	RoleInvalid Role = 0
	// AcceleratorLabel: a label which represents an accelerator
	RoleAcceleratorLabel Role = 1
	// alert: an object which is an alert to the user. Assistive Technologies
	// typically respond to ATK_ROLE_ALERT by reading the entire onscreen
	// contents of containers advertising this role. Should be used for warning
	// dialogs, etc.
	RoleAlert Role = 2
	// animation: an object which is an animated image
	RoleAnimation Role = 3
	// arrow: an arrow in one of the four cardinal directions
	RoleArrow Role = 4
	// calendar: an object that displays a calendar and allows the user to
	// select a date
	RoleCalendar Role = 5
	// canvas: an object that can be drawn into and is used to trap events
	RoleCanvas Role = 6
	// CheckBox: a choice that can be checked or unchecked and provides a
	// separate indicator for the current state
	RoleCheckBox Role = 7
	// CheckMenuItem: a menu item with a check box
	RoleCheckMenuItem Role = 8
	// ColorChooser: a specialized dialog that lets the user choose a color
	RoleColorChooser Role = 9
	// ColumnHeader: the header for a column of data
	RoleColumnHeader Role = 10
	// ComboBox: a collapsible list of choices the user can select from
	RoleComboBox Role = 11
	// DateEditor: an object whose purpose is to allow a user to edit a date
	RoleDateEditor Role = 12
	// DesktopIcon: an inconifed internal frame within a DESKTOP_PANE
	RoleDesktopIcon Role = 13
	// DesktopFrame: a pane that supports internal frames and iconified versions
	// of those internal frames
	RoleDesktopFrame Role = 14
	// dial: an object whose purpose is to allow a user to set a value
	RoleDial Role = 15
	// dialog: a top level window with title bar and a border
	RoleDialog Role = 16
	// DirectoryPane: a pane that allows the user to navigate through and select
	// the contents of a directory
	RoleDirectoryPane Role = 17
	// DrawingArea: an object used for drawing custom user interface elements
	RoleDrawingArea Role = 18
	// FileChooser: a specialized dialog that lets the user choose a file
	RoleFileChooser Role = 19
	// filler: a object that fills up space in a user interface
	RoleFiller Role = 20
	// FontChooser: a specialized dialog that lets the user choose a font
	RoleFontChooser Role = 21
	// frame: a top level window with a title bar, border, menubar, etc.
	RoleFrame Role = 22
	// GlassPane: a pane that is guaranteed to be painted on top of all panes
	// beneath it
	RoleGlassPane Role = 23
	// HtmlContainer: a document container for HTML, whose children represent
	// the document content
	RoleHtmlContainer Role = 24
	// icon: a small fixed size picture, typically used to decorate components
	RoleIcon Role = 25
	// image: an object whose primary purpose is to display an image
	RoleImage Role = 26
	// InternalFrame: a frame-like object that is clipped by a desktop pane
	RoleInternalFrame Role = 27
	// label: an object used to present an icon or short string in an interface
	RoleLabel Role = 28
	// LayeredPane: a specialized pane that allows its children to be drawn in
	// layers, providing a form of stacking order
	RoleLayeredPane Role = 29
	// list: an object that presents a list of objects to the user and allows
	// the user to select one or more of them
	RoleList Role = 30
	// ListItem: an object that represents an element of a list
	RoleListItem Role = 31
	// menu: an object usually found inside a menu bar that contains a list of
	// actions the user can choose from
	RoleMenu Role = 32
	// MenuBar: an object usually drawn at the top of the primary dialog box of
	// an application that contains a list of menus the user can choose from
	RoleMenuBar Role = 33
	// MenuItem: an object usually contained in a menu that presents an action
	// the user can choose
	RoleMenuItem Role = 34
	// OptionPane: a specialized pane whose primary use is inside a DIALOG
	RoleOptionPane Role = 35
	// PageTab: an object that is a child of a page tab list
	RolePageTab Role = 36
	// PageTabList: an object that presents a series of panels (or page tabs),
	// one at a time, through some mechanism provided by the object
	RolePageTabList Role = 37
	// panel: a generic container that is often used to group objects
	RolePanel Role = 38
	// PasswordText: a text object uses for passwords, or other places where the
	// text content is not shown visibly to the user
	RolePasswordText Role = 39
	// PopupMenu: a temporary window that is usually used to offer the user a
	// list of choices, and then hides when the user selects one of those
	// choices
	RolePopupMenu Role = 40
	// ProgressBar: an object used to indicate how much of a task has been
	// completed
	RoleProgressBar Role = 41
	// PushButton: an object the user can manipulate to tell the application to
	// do something
	RolePushButton Role = 42
	// RadioButton: a specialized check box that will cause other radio buttons
	// in the same group to become unchecked when this one is checked
	RoleRadioButton Role = 43
	// RadioMenuItem: a check menu item which belongs to a group. At each
	// instant exactly one of the radio menu items from a group is selected
	RoleRadioMenuItem Role = 44
	// RootPane: a specialized pane that has a glass pane and a layered pane as
	// its children
	RoleRootPane Role = 45
	// RowHeader: the header for a row of data
	RoleRowHeader Role = 46
	// ScrollBar: an object usually used to allow a user to incrementally view a
	// large amount of data.
	RoleScrollBar Role = 47
	// ScrollPane: an object that allows a user to incrementally view a large
	// amount of information
	RoleScrollPane Role = 48
	// separator: an object usually contained in a menu to provide a visible and
	// logical separation of the contents in a menu
	RoleSeparator Role = 49
	// slider: an object that allows the user to select from a bounded range
	RoleSlider Role = 50
	// SplitPane: a specialized panel that presents two other panels at the same
	// time
	RoleSplitPane Role = 51
	// SpinButton: an object used to get an integer or floating point number
	// from the user
	RoleSpinButton Role = 52
	// statusbar: an object which reports messages of minor importance to the
	// user
	RoleStatusbar Role = 53
	// table: an object used to represent information in terms of rows and
	// columns
	RoleTable Role = 54
	// TableCell: a cell in a table
	RoleTableCell Role = 55
	// TableColumnHeader: the header for a column of a table
	RoleTableColumnHeader Role = 56
	// TableRowHeader: the header for a row of a table
	RoleTableRowHeader Role = 57
	// TearOffMenuItem: a menu item used to tear off and reattach its menu
	RoleTearOffMenuItem Role = 58
	// terminal: an object that represents an accessible terminal. (Since: 0.6)
	RoleTerminal Role = 59
	// text: an interactive widget that supports multiple lines of text and
	// optionally accepts user input, but whose purpose is not to solicit user
	// input. Thus ATK_ROLE_TEXT is appropriate for the text view in a plain
	// text editor but inappropriate for an input field in a dialog box or web
	// form. For widgets whose purpose is to solicit input from the user, see
	// ATK_ROLE_ENTRY and ATK_ROLE_PASSWORD_TEXT. For generic objects which
	// display a brief amount of textual information, see ATK_ROLE_STATIC.
	RoleText Role = 60
	// ToggleButton: a specialized push button that can be checked or unchecked,
	// but does not provide a separate indicator for the current state
	RoleToggleButton Role = 61
	// ToolBar: a bar or palette usually composed of push buttons or toggle
	// buttons
	RoleToolBar Role = 62
	// ToolTip: an object that provides information about another object
	RoleToolTip Role = 63
	// tree: an object used to represent hierarchical information to the user
	RoleTree Role = 64
	// TreeTable: an object capable of expanding and collapsing rows as well as
	// showing multiple columns of data. (Since: 0.7)
	RoleTreeTable Role = 65
	// unknown: the object contains some Accessible information, but its role is
	// not known
	RoleUnknown Role = 66
	// viewport: an object usually used in a scroll pane
	RoleViewport Role = 67
	// window: a top level window with no title or border.
	RoleWindow Role = 68
	// header: an object that serves as a document header. (Since: 1.1.1)
	RoleHeader Role = 69
	// footer: an object that serves as a document footer. (Since: 1.1.1)
	RoleFooter Role = 70
	// paragraph: an object which is contains a paragraph of text content.
	// (Since: 1.1.1)
	RoleParagraph Role = 71
	// ruler: an object which describes margins and tab stops, etc. for text
	// objects which it controls (should have CONTROLLER_FOR relation to such).
	// (Since: 1.1.1)
	RoleRuler Role = 72
	// application: the object is an application object, which may contain
	// @ATK_ROLE_FRAME objects or other types of accessibles. The root
	// accessible of any application's ATK hierarchy should have
	// ATK_ROLE_APPLICATION. (Since: 1.1.4)
	RoleApplication Role = 73
	// autocomplete: the object is a dialog or list containing items for
	// insertion into an entry widget, for instance a list of words for
	// completion of a text entry. (Since: 1.3)
	RoleAutocomplete Role = 74
	// EditBar: the object is an editable text object in a toolbar. (Since: 1.5)
	RoleEditBar Role = 75
	// embedded: the object is an embedded container within a document or panel.
	// This role is a grouping "hint" indicating that the contained objects
	// share a context. (Since: 1.7.2)
	RoleEmbedded Role = 76
	// entry: the object is a component whose textual content may be entered or
	// modified by the user, provided @ATK_STATE_EDITABLE is present. (Since:
	// 1.11)
	RoleEntry Role = 77
	// chart: the object is a graphical depiction of quantitative data. It may
	// contain multiple subelements whose attributes and/or description may be
	// queried to obtain both the quantitative data and information about how
	// the data is being presented. The LABELLED_BY relation is particularly
	// important in interpreting objects of this type, as is the
	// accessible-description property. (Since: 1.11)
	RoleChart Role = 78
	// caption: the object contains descriptive information, usually textual,
	// about another user interface element such as a table, chart, or image.
	// (Since: 1.11)
	RoleCaption Role = 79
	// DocumentFrame: the object is a visual frame or container which contains a
	// view of document content. Document frames may occur within another
	// Document instance, in which case the second document may be said to be
	// embedded in the containing instance. HTML frames are often
	// ROLE_DOCUMENT_FRAME. Either this object, or a singleton descendant,
	// should implement the Document interface. (Since: 1.11)
	RoleDocumentFrame Role = 80
	// heading: the object serves as a heading for content which follows it in a
	// document. The 'heading level' of the heading, if availabe, may be
	// obtained by querying the object's attributes.
	RoleHeading Role = 81
	// page: the object is a containing instance which encapsulates a page of
	// information. @ATK_ROLE_PAGE is used in documents and content which
	// support a paginated navigation model. (Since: 1.11)
	RolePage Role = 82
	// section: the object is a containing instance of document content which
	// constitutes a particular 'logical' section of the document. The type of
	// content within a section, and the nature of the section division itself,
	// may be obtained by querying the object's attributes. Sections may be
	// nested. (Since: 1.11)
	RoleSection Role = 83
	// RedundantObject: the object is redundant with another object in the
	// hierarchy, and is exposed for purely technical reasons. Objects of this
	// role should normally be ignored by clients. (Since: 1.11)
	RoleRedundantObject Role = 84
	// form: the object is a container for form controls, for instance as part
	// of a web form or user-input form within a document. This role is
	// primarily a tag/convenience for clients when navigating complex
	// documents, it is not expected that ordinary GUI containers will always
	// have ATK_ROLE_FORM. (Since: 1.12.0)
	RoleForm Role = 85
	// link: the object is a hypertext anchor, i.e. a "link" in a hypertext
	// document. Such objects are distinct from 'inline' content which may also
	// use the Hypertext/Hyperlink interfaces to indicate the range/location
	// within a text object where an inline or embedded object lies. (Since:
	// 1.12.1)
	RoleLink Role = 86
	// InputMethodWindow: the object is a window or similar viewport which is
	// used to allow composition or input of a 'complex character', in other
	// words it is an "input method window." (Since: 1.12.1)
	RoleInputMethodWindow Role = 87
	// TableRow: a row in a table. (Since: 2.1.0)
	RoleTableRow Role = 88
	// TreeItem: an object that represents an element of a tree. (Since: 2.1.0)
	RoleTreeItem Role = 89
	// DocumentSpreadsheet: a document frame which contains a spreadsheet.
	// (Since: 2.1.0)
	RoleDocumentSpreadsheet Role = 90
	// DocumentPresentation: a document frame which contains a presentation or
	// slide content. (Since: 2.1.0)
	RoleDocumentPresentation Role = 91
	// DocumentText: a document frame which contains textual content, such as
	// found in a word processing application. (Since: 2.1.0)
	RoleDocumentText Role = 92
	// DocumentWeb: a document frame which contains HTML or other markup
	// suitable for display in a web browser. (Since: 2.1.0)
	RoleDocumentWeb Role = 93
	// DocumentEmail: a document frame which contains email content to be
	// displayed or composed either in plain text or HTML. (Since: 2.1.0)
	RoleDocumentEmail Role = 94
	// comment: an object found within a document and designed to present a
	// comment, note, or other annotation. In some cases, this object might not
	// be visible until activated. (Since: 2.1.0)
	RoleComment Role = 95
	// ListBox: a non-collapsible list of choices the user can select from.
	// (Since: 2.1.0)
	RoleListBox Role = 96
	// grouping: a group of related widgets. This group typically has a label.
	// (Since: 2.1.0)
	RoleGrouping Role = 97
	// ImageMap: an image map object. Usually a graphic with multiple hotspots,
	// where each hotspot can be activated resulting in the loading of another
	// document or section of a document. (Since: 2.1.0)
	RoleImageMap Role = 98
	// notification: a transitory object designed to present a message to the
	// user, typically at the desktop level rather than inside a particular
	// application. (Since: 2.1.0)
	RoleNotification Role = 99
	// InfoBar: an object designed to present a message to the user within an
	// existing window. (Since: 2.1.0)
	RoleInfoBar Role = 100
	// LevelBar: a bar that serves as a level indicator to, for instance, show
	// the strength of a password or the state of a battery. (Since: 2.7.3)
	RoleLevelBar Role = 101
	// TitleBar: a bar that serves as the title of a window or a dialog. (Since:
	// 2.12)
	RoleTitleBar Role = 102
	// BlockQuote: an object which contains a text section that is quoted from
	// another source. (Since: 2.12)
	RoleBlockQuote Role = 103
	// audio: an object which represents an audio element. (Since: 2.12)
	RoleAudio Role = 104
	// video: an object which represents a video element. (Since: 2.12)
	RoleVideo Role = 105
	// definition: a definition of a term or concept. (Since: 2.12)
	RoleDefinition Role = 106
	// article: a section of a page that consists of a composition that forms an
	// independent part of a document, page, or site. Examples: A blog entry, a
	// news story, a forum post. (Since: 2.12)
	RoleArticle Role = 107
	// landmark: a region of a web page intended as a navigational landmark.
	// This is designed to allow Assistive Technologies to provide quick
	// navigation among key regions within a document. (Since: 2.12)
	RoleLandmark Role = 108
	// log: a text widget or container holding log content, such as chat history
	// and error logs. In this role there is a relationship between the arrival
	// of new items in the log and the reading order. The log contains a
	// meaningful sequence and new information is added only to the end of the
	// log, not at arbitrary points. (Since: 2.12)
	RoleLog Role = 109
	// marquee: a container where non-essential information changes frequently.
	// Common usages of marquee include stock tickers and ad banners. The
	// primary difference between a marquee and a log is that logs usually have
	// a meaningful order or sequence of important content changes. (Since:
	// 2.12)
	RoleMarquee Role = 110
	// math: a text widget or container that holds a mathematical expression.
	// (Since: 2.12)
	RoleMath Role = 111
	// rating: a widget whose purpose is to display a rating, such as the number
	// of stars associated with a song in a media player. Objects of this role
	// should also implement AtkValue. (Since: 2.12)
	RoleRating Role = 112
	// timer: an object containing a numerical counter which indicates an amount
	// of elapsed time from a start point, or the time remaining until an end
	// point. (Since: 2.12)
	RoleTimer Role = 113
	// DescriptionList: an object that represents a list of term-value groups. A
	// term-value group represents a individual description and consist of one
	// or more names (ATK_ROLE_DESCRIPTION_TERM) followed by one or more values
	// (ATK_ROLE_DESCRIPTION_VALUE). For each list, there should not be more
	// than one group with the same term name. (Since: 2.12)
	RoleDescriptionList Role = 114
	// DescriptionTerm: an object that represents a term or phrase with a
	// corresponding definition. (Since: 2.12)
	RoleDescriptionTerm Role = 115
	// DescriptionValue: an object that represents the description, definition
	// or value of a term. (Since: 2.12)
	RoleDescriptionValue Role = 116
	// static: a generic non-container object whose purpose is to display a
	// brief amount of information to the user and whose role is known by the
	// implementor but lacks semantic value for the user. Examples in which
	// ATK_ROLE_STATIC is appropriate include the message displayed in a message
	// box and an image used as an alternative means to display text.
	// ATK_ROLE_STATIC should not be applied to widgets which are traditionally
	// interactive, objects which display a significant amount of content, or
	// any object which has an accessible relation pointing to another object.
	// Implementors should expose the displayed information through the
	// accessible name of the object. If doing so seems inappropriate, it may
	// indicate that a different role should be used. For labels which describe
	// another widget, see ATK_ROLE_LABEL. For text views, see ATK_ROLE_TEXT.
	// For generic containers, see ATK_ROLE_PANEL. For objects whose role is not
	// known by the implementor, see ATK_ROLE_UNKNOWN. (Since: 2.16)
	RoleStatic Role = 117
	// MathFraction: an object that represents a mathematical fraction. (Since:
	// 2.16)
	RoleMathFraction Role = 118
	// MathRoot: an object that represents a mathematical expression displayed
	// with a radical. (Since: 2.16)
	RoleMathRoot Role = 119
	// subscript: an object that contains text that is displayed as a subscript.
	// (Since: 2.16)
	RoleSubscript Role = 120
	// superscript: an object that contains text that is displayed as a
	// superscript. (Since: 2.16)
	RoleSuperscript Role = 121
	// footnote: an object that contains the text of a footnote. (Since: 2.26)
	RoleFootnote Role = 122
	// ContentDeletion: content previously deleted or proposed to be deleted,
	// e.g. in revision history or a content view providing suggestions from
	// reviewers. (Since: 2.34)
	RoleContentDeletion Role = 123
	// ContentInsertion: content previously inserted or proposed to be inserted,
	// e.g. in revision history or a content view providing suggestions from
	// reviewers. (Since: 2.34)
	RoleContentInsertion Role = 124
	// mark: a run of content that is marked or highlighted, such as for
	// reference purposes, or to call it out as having a special purpose. If the
	// marked content has an associated section in the document elaborating on
	// the reason for the mark, then ATK_RELATION_DETAILS should be used on the
	// mark to point to that associated section. In addition, the reciprocal
	// relation ATK_RELATION_DETAILS_FOR should be used on the associated
	// content section to point back to the mark. (Since: 2.36)
	RoleMark Role = 125
	// suggestion: a container for content that is called out as a proposed
	// change from the current version of the document, such as by a reviewer of
	// the content. This role should include either ATK_ROLE_CONTENT_DELETION
	// and/or ATK_ROLE_CONTENT_INSERTION children, in any order, to indicate
	// what the actual change is. (Since: 2.36)
	RoleSuggestion Role = 126
	// LastDefined: not a valid role, used for finding end of the enumeration
	RoleLastDefined Role = 127
)

func marshalRole(p uintptr) (interface{}, error) {
	return Role(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Function: an AtkFunction is a function definition used for padding which has
// been added to class and interface structures to allow for expansion in the
// future.
type Function func(ok bool)

//export gotk4_Function
func gotk4_Function(arg0 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(Function)
	ok := fn()

	var cret C.gboolean // out

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ImplementorIface: the AtkImplementor interface is implemented by objects for
// which AtkObject peers may be obtained via calls to
// iface->(ref_accessible)(implementor);
type ImplementorIface interface {
	gextras.Objector
}

// implementorIface implements the ImplementorIface interface.
type implementorIface struct {
	gextras.Objector
}

var _ ImplementorIface = (*implementorIface)(nil)

// WrapImplementorIface wraps a GObject to a type that implements
// interface ImplementorIface. It is primarily used internally.
func WrapImplementorIface(obj *externglib.Object) ImplementorIface {
	return implementorIface{
		Objector: obj,
	}
}

func marshalImplementorIface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapImplementorIface(obj), nil
}

// Object: this class is the primary class for accessibility support via the
// Accessibility ToolKit (ATK). Objects which are instances of Object (or
// instances of AtkObject-derived types) are queried for properties which relate
// basic (and generic) properties of a UI component such as name and
// description. Instances of Object may also be queried as to whether they
// implement other ATK interfaces (e.g. Action, Component, etc.), as appropriate
// to the role which a given UI component plays in a user interface.
//
// All UI components in an application which provide useful information or
// services to the user must provide corresponding Object instances on request
// (in GTK+, for instance, usually on a call to #gtk_widget_get_accessible ()),
// either via ATK support built into the toolkit for the widget class or
// ancestor class, or in the case of custom widgets, if the inherited Object
// implementation is insufficient, via instances of a new Object subclass.
//
// See also: ObjectFactory, Registry. (GTK+ users see also Accessible).
type Object interface {
	gextras.Objector

	AddRelationshipObject(relationship RelationType, target Object) bool

	AccessibleID() string

	Description() string

	IndexInParent() int

	Layer() Layer

	MdiZorder() int

	NAccessibleChildren() int

	Name() string

	ObjectLocale() string

	Parent() Object

	Role() Role

	InitializeObject(data interface{})

	PeekParentObject() Object

	RefAccessibleChildObject(i int) Object

	RefRelationSetObject() RelationSet

	RefStateSetObject() StateSet

	RemovePropertyChangeHandlerObject(handlerId uint)

	RemoveRelationshipObject(relationship RelationType, target Object) bool

	SetAccessibleIDObject(name string)

	SetDescriptionObject(description string)

	SetNameObject(name string)

	SetParentObject(parent Object)

	SetRoleObject(role Role)
}

// object implements the Object class.
type object struct {
	gextras.Objector
}

// WrapObject wraps a GObject to the right type. It is
// primarily used internally.
func WrapObject(obj *externglib.Object) Object {
	return object{
		Objector: obj,
	}
}

func marshalObject(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapObject(obj), nil
}

func (o object) AddRelationshipObject(relationship RelationType, target Object) bool {
	var _arg0 *C.AtkObject      // out
	var _arg1 C.AtkRelationType // out
	var _arg2 *C.AtkObject      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(o.Native()))
	_arg1 = C.AtkRelationType(relationship)
	_arg2 = (*C.AtkObject)(unsafe.Pointer(target.Native()))

	_cret = C.atk_object_add_relationship(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a object) AccessibleID() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_accessible_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a object) Description() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_description(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a object) IndexInParent() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_index_in_parent(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (a object) Layer() Layer {
	var _arg0 *C.AtkObject // out
	var _cret C.AtkLayer   // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_layer(_arg0)

	var _layer Layer // out

	_layer = Layer(_cret)

	return _layer
}

func (a object) MdiZorder() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_mdi_zorder(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (a object) NAccessibleChildren() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_n_accessible_children(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (a object) Name() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a object) ObjectLocale() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_object_locale(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (a object) Parent() Object {
	var _arg0 *C.AtkObject // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_parent(_arg0)

	var _object Object // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Object)

	return _object
}

func (a object) Role() Role {
	var _arg0 *C.AtkObject // out
	var _cret C.AtkRole    // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_get_role(_arg0)

	var _role Role // out

	_role = Role(_cret)

	return _role
}

func (a object) InitializeObject(data interface{}) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.gpointer   // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = C.gpointer(box.Assign(unsafe.Pointer(data)))

	C.atk_object_initialize(_arg0, _arg1)
}

func (a object) PeekParentObject() Object {
	var _arg0 *C.AtkObject // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_peek_parent(_arg0)

	var _object Object // out

	_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Object)

	return _object
}

func (a object) RefAccessibleChildObject(i int) Object {
	var _arg0 *C.AtkObject // out
	var _arg1 C.gint       // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = C.gint(i)

	_cret = C.atk_object_ref_accessible_child(_arg0, _arg1)

	var _object Object // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Object)

	return _object
}

func (a object) RefRelationSetObject() RelationSet {
	var _arg0 *C.AtkObject      // out
	var _cret *C.AtkRelationSet // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_ref_relation_set(_arg0)

	var _relationSet RelationSet // out

	_relationSet = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(RelationSet)

	return _relationSet
}

func (a object) RefStateSetObject() StateSet {
	var _arg0 *C.AtkObject   // out
	var _cret *C.AtkStateSet // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))

	_cret = C.atk_object_ref_state_set(_arg0)

	var _stateSet StateSet // out

	_stateSet = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(StateSet)

	return _stateSet
}

func (a object) RemovePropertyChangeHandlerObject(handlerId uint) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.guint      // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = C.guint(handlerId)

	C.atk_object_remove_property_change_handler(_arg0, _arg1)
}

func (o object) RemoveRelationshipObject(relationship RelationType, target Object) bool {
	var _arg0 *C.AtkObject      // out
	var _arg1 C.AtkRelationType // out
	var _arg2 *C.AtkObject      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(o.Native()))
	_arg1 = C.AtkRelationType(relationship)
	_arg2 = (*C.AtkObject)(unsafe.Pointer(target.Native()))

	_cret = C.atk_object_remove_relationship(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (a object) SetAccessibleIDObject(name string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_accessible_id(_arg0, _arg1)
}

func (a object) SetDescriptionObject(description string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(description))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_description(_arg0, _arg1)
}

func (a object) SetNameObject(name string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_name(_arg0, _arg1)
}

func (a object) SetParentObject(parent Object) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.AtkObject // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.AtkObject)(unsafe.Pointer(parent.Native()))

	C.atk_object_set_parent(_arg0, _arg1)
}

func (a object) SetRoleObject(role Role) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.AtkRole    // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(a.Native()))
	_arg1 = C.AtkRole(role)

	C.atk_object_set_role(_arg0, _arg1)
}

// Attribute: atkAttribute is a string name/value pair representing a generic
// attribute. This can be used to expose additional information from an
// accessible object as a whole (see atk_object_get_attributes()) or an document
// (see atk_document_get_attributes()). In the case of text attributes (see
// atk_text_get_default_attributes()), TextAttribute enum defines all the
// possible text attribute names. You can use atk_text_attribute_get_name() to
// get the string name from the enum value. See also
// atk_text_attribute_for_name() and atk_text_attribute_get_value() for more
// information.
//
// A string name/value pair representing a generic attribute.
type Attribute C.AtkAttribute

// WrapAttribute wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttribute(ptr unsafe.Pointer) *Attribute {
	return (*Attribute)(ptr)
}

// Native returns the underlying C source pointer.
func (a *Attribute) Native() unsafe.Pointer {
	return unsafe.Pointer(a)
}

type Implementor C.AtkImplementor

// WrapImplementor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapImplementor(ptr unsafe.Pointer) *Implementor {
	return (*Implementor)(ptr)
}

// Native returns the underlying C source pointer.
func (i *Implementor) Native() unsafe.Pointer {
	return unsafe.Pointer(i)
}

// RefAccessible gets a reference to an object's Object implementation, if the
// object implements ObjectIface
func (i *Implementor) RefAccessible() Object {
	var _arg0 *C.AtkImplementor // out
	var _cret *C.AtkObject      // in

	_arg0 = (*C.AtkImplementor)(unsafe.Pointer(i.Native()))

	_cret = C.atk_implementor_ref_accessible(_arg0)

	var _object Object // out

	_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Object)

	return _object
}
