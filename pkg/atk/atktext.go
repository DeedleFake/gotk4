// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_text_attribute_get_type()), F: marshalTextAttribute},
		{T: externglib.Type(C.atk_text_boundary_get_type()), F: marshalTextBoundary},
		{T: externglib.Type(C.atk_text_clip_type_get_type()), F: marshalTextClipType},
		{T: externglib.Type(C.atk_text_granularity_get_type()), F: marshalTextGranularity},
		{T: externglib.Type(C.atk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.atk_text_range_get_type()), F: marshalTextRange},
	})
}

// TextAttribute describes the text attributes supported
type TextAttribute int

const (
	// invalid: invalid attribute, like bad spelling or grammar.
	TextAttributeInvalid TextAttribute = 0
	// LeftMargin: the pixel width of the left margin
	TextAttributeLeftMargin TextAttribute = 1
	// RightMargin: the pixel width of the right margin
	TextAttributeRightMargin TextAttribute = 2
	// indent: the number of pixels that the text is indented
	TextAttributeIndent TextAttribute = 3
	// invisible: either "true" or "false" indicating whether text is visible or
	// not
	TextAttributeInvisible TextAttribute = 4
	// editable: either "true" or "false" indicating whether text is editable or
	// not
	TextAttributeEditable TextAttribute = 5
	// PixelsAboveLines pixels of blank space to leave above each
	// newline-terminated line.
	TextAttributePixelsAboveLines TextAttribute = 6
	// PixelsBelowLines pixels of blank space to leave below each
	// newline-terminated line.
	TextAttributePixelsBelowLines TextAttribute = 7
	// PixelsInsideWrap pixels of blank space to leave between wrapped lines
	// inside the same newline-terminated line (paragraph).
	TextAttributePixelsInsideWrap TextAttribute = 8
	// BgFullHeight: "true" or "false" whether to make the background color for
	// each character the height of the highest font used on the current line,
	// or the height of the font used for the current character.
	TextAttributeBgFullHeight TextAttribute = 9
	// rise: number of pixels that the characters are risen above the baseline.
	// See also ATK_TEXT_ATTR_TEXT_POSITION.
	TextAttributeRise TextAttribute = 10
	// underline: "none", "single", "double", "low", or "error"
	TextAttributeUnderline TextAttribute = 11
	// strikethrough: "true" or "false" whether the text is strikethrough
	TextAttributeStrikethrough TextAttribute = 12
	// size: the size of the characters in points. eg: 10
	TextAttributeSize TextAttribute = 13
	// scale: the scale of the characters. The value is a string representation
	// of a double
	TextAttributeScale TextAttribute = 14
	// weight: the weight of the characters.
	TextAttributeWeight TextAttribute = 15
	// language: the language used
	TextAttributeLanguage TextAttribute = 16
	// FamilyName: the font family name
	TextAttributeFamilyName TextAttribute = 17
	// BgColor: the background color. The value is an RGB value of the format
	// "u,u,u"
	TextAttributeBgColor TextAttribute = 18
	// FgColor: the foreground color. The value is an RGB value of the format
	// "u,u,u"
	TextAttributeFgColor TextAttribute = 19
	// BgStipple: "true" if a Bitmap is set for stippling the background color.
	TextAttributeBgStipple TextAttribute = 20
	// FgStipple: "true" if a Bitmap is set for stippling the foreground color.
	TextAttributeFgStipple TextAttribute = 21
	// WrapMode: the wrap mode of the text, if any. Values are "none", "char",
	// "word", or "word_char".
	TextAttributeWrapMode TextAttribute = 22
	// direction: the direction of the text, if set. Values are "none", "ltr" or
	// "rtl"
	TextAttributeDirection TextAttribute = 23
	// justification: the justification of the text, if set. Values are "left",
	// "right", "center" or "fill"
	TextAttributeJustification TextAttribute = 24
	// stretch: the stretch of the text, if set. Values are "ultra_condensed",
	// "extra_condensed", "condensed", "semi_condensed", "normal",
	// "semi_expanded", "expanded", "extra_expanded" or "ultra_expanded"
	TextAttributeStretch TextAttribute = 25
	// variant: the capitalization variant of the text, if set. Values are
	// "normal" or "small_caps"
	TextAttributeVariant TextAttribute = 26
	// style: the slant style of the text, if set. Values are "normal",
	// "oblique" or "italic"
	TextAttributeStyle TextAttribute = 27
	// TextPosition: the vertical position with respect to the baseline. Values
	// are "baseline", "super", or "sub". Note that a super or sub text
	// attribute refers to position with respect to the baseline of the prior
	// character.
	TextAttributeTextPosition TextAttribute = 28
	// LastDefined: not a valid text attribute, used for finding end of
	// enumeration
	TextAttributeLastDefined TextAttribute = 29
)

func marshalTextAttribute(p uintptr) (interface{}, error) {
	return TextAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBoundary: text boundary types used for specifying boundaries for regions
// of text. This enumeration is deprecated since 2.9.4 and should not be used.
// Use AtkTextGranularity with #atk_text_get_string_at_offset instead.
type TextBoundary int

const (
	// char: boundary is the boundary between characters (including non-printing
	// characters)
	TextBoundaryChar TextBoundary = 0
	// WordStart: boundary is the start (i.e. first character) of a word.
	TextBoundaryWordStart TextBoundary = 1
	// WordEnd: boundary is the end (i.e. last character) of a word.
	TextBoundaryWordEnd TextBoundary = 2
	// SentenceStart: boundary is the first character in a sentence.
	TextBoundarySentenceStart TextBoundary = 3
	// SentenceEnd: boundary is the last (terminal) character in a sentence; in
	// languages which use "sentence stop" punctuation such as English, the
	// boundary is thus the '.', '?', or similar terminal punctuation character.
	TextBoundarySentenceEnd TextBoundary = 4
	// LineStart: boundary is the initial character of the content or a
	// character immediately following a newline, linefeed, or return character.
	TextBoundaryLineStart TextBoundary = 5
	// LineEnd: boundary is the linefeed, or return character.
	TextBoundaryLineEnd TextBoundary = 6
)

func marshalTextBoundary(p uintptr) (interface{}, error) {
	return TextBoundary(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextClipType describes the type of clipping required.
type TextClipType int

const (
	// none: no clipping to be done
	TextClipTypeNone TextClipType = 0
	// min: text clipped by min coordinate is omitted
	TextClipTypeMin TextClipType = 1
	// max: text clipped by max coordinate is omitted
	TextClipTypeMax TextClipType = 2
	// both: only text fully within mix/max bound is retained
	TextClipTypeBoth TextClipType = 3
)

func marshalTextClipType(p uintptr) (interface{}, error) {
	return TextClipType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextGranularity: text granularity types used for specifying the granularity
// of the region of text we are interested in.
type TextGranularity int

const (
	// char: granularity is defined by the boundaries between characters
	// (including non-printing characters)
	TextGranularityChar TextGranularity = 0
	// word: granularity is defined by the boundaries of a word, starting at the
	// beginning of the current word and finishing at the beginning of the
	// following one, if present.
	TextGranularityWord TextGranularity = 1
	// sentence: granularity is defined by the boundaries of a sentence,
	// starting at the beginning of the current sentence and finishing at the
	// beginning of the following one, if present.
	TextGranularitySentence TextGranularity = 2
	// line: granularity is defined by the boundaries of a line, starting at the
	// beginning of the current line and finishing at the beginning of the
	// following one, if present.
	TextGranularityLine TextGranularity = 3
	// paragraph: granularity is defined by the boundaries of a paragraph,
	// starting at the beginning of the current paragraph and finishing at the
	// beginning of the following one, if present.
	TextGranularityParagraph TextGranularity = 4
)

func marshalTextGranularity(p uintptr) (interface{}, error) {
	return TextGranularity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Text should be implemented by Objects on behalf of widgets that have text
// content which is either attributed or otherwise non-trivial. Objects whose
// text content is simple, unattributed, and very brief may expose that content
// via #atk_object_get_name instead; however if the text is editable,
// multi-line, typically longer than three or four words, attributed,
// selectable, or if the object already uses the 'name' ATK property for other
// information, the Text interface should be used to expose the text content. In
// the case of editable text content, EditableText (a subtype of the Text
// interface) should be implemented instead.
//
//    Text provides not only traversal facilities and change
//
// notification for text content, but also caret tracking and glyph bounding box
// calculations. Note that the text strings are exposed as UTF-8, and are
// therefore potentially multi-byte, and caret-to-byte offset mapping makes no
// assumptions about the character length; also bounding box glyph-to-offset
// mapping may be complex for languages which use ligatures.
type Text interface {
	gextras.Objector

	// AddSelection changes the start and end offset of the specified selection.
	AddSelection(startOffset int, endOffset int) bool
	// BoundedRanges changes the start and end offset of the specified
	// selection.
	BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange
	// CaretOffset changes the start and end offset of the specified selection.
	CaretOffset() int
	// CharacterAtOffset changes the start and end offset of the specified
	// selection.
	CharacterAtOffset(offset int) uint32
	// CharacterCount changes the start and end offset of the specified
	// selection.
	CharacterCount() int
	// CharacterExtents changes the start and end offset of the specified
	// selection.
	CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int)
	// NSelections changes the start and end offset of the specified selection.
	NSelections() int
	// OffsetAtPoint changes the start and end offset of the specified
	// selection.
	OffsetAtPoint(x int, y int, coords CoordType) int
	// RangeExtents changes the start and end offset of the specified selection.
	RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle
	// Selection changes the start and end offset of the specified selection.
	Selection(selectionNum int) (startOffset int, endOffset int, utf8 string)
	// StringAtOffset changes the start and end offset of the specified
	// selection.
	StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string)
	// Text changes the start and end offset of the specified selection.
	Text(startOffset int, endOffset int) string
	// TextAfterOffset changes the start and end offset of the specified
	// selection.
	TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextAtOffset changes the start and end offset of the specified selection.
	TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextBeforeOffset changes the start and end offset of the specified
	// selection.
	TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// RemoveSelection changes the start and end offset of the specified
	// selection.
	RemoveSelection(selectionNum int) bool
	// ScrollSubstringTo changes the start and end offset of the specified
	// selection.
	ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool
	// ScrollSubstringToPoint changes the start and end offset of the specified
	// selection.
	ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool
	// SetCaretOffset changes the start and end offset of the specified
	// selection.
	SetCaretOffset(offset int) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum int, startOffset int, endOffset int) bool
}

// text implements the Text interface.
type text struct {
	gextras.Objector
}

var _ Text = (*text)(nil)

// WrapText wraps a GObject to a type that implements
// interface Text. It is primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return text{
		Objector: obj,
	}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

func (t text) AddSelection(startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_add_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange {
	var _arg0 *C.AtkText          // out
	var _arg1 *C.AtkTextRectangle // out
	var _arg2 C.AtkCoordType      // out
	var _arg3 C.AtkTextClipType   // out
	var _arg4 C.AtkTextClipType   // out
	var _cret **C.AtkTextRange

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.AtkTextRectangle)(unsafe.Pointer(rect.Native()))
	_arg2 = C.AtkCoordType(coordType)
	_arg3 = C.AtkTextClipType(xClipType)
	_arg4 = C.AtkTextClipType(yClipType)

	_cret = C.atk_text_get_bounded_ranges(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _textRanges []*TextRange

	{
		var i int
		var z *C.AtkTextRange
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_textRanges = make([]*TextRange, i)
		for i := range src {
			_textRanges[i] = (*TextRange)(unsafe.Pointer(src[i]))
			runtime.SetFinalizer(&_textRanges[i], func(v **TextRange) {
				C.free(unsafe.Pointer(v))
			})
		}
	}

	return _textRanges
}

func (t text) CaretOffset() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_caret_offset(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) CharacterAtOffset(offset int) uint32 {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gunichar // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_get_character_at_offset(_arg0, _arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

func (t text) CharacterCount() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_character_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int) {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in
	var _arg5 C.gint         // in
	var _arg6 C.AtkCoordType // out

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg6 = C.AtkCoordType(coords)

	C.atk_text_get_character_extents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, _arg6)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg2)
	_y = int(_arg3)
	_width = int(_arg4)
	_height = int(_arg5)

	return _x, _y, _width, _height
}

func (t text) NSelections() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_n_selections(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) OffsetAtPoint(x int, y int, coords CoordType) int {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _cret C.gint         // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.AtkCoordType(coords)

	_cret = C.atk_text_get_offset_at_point(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle {
	var _arg0 *C.AtkText         // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out
	var _arg3 C.AtkCoordType     // out
	var _arg4 C.AtkTextRectangle // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coordType)

	C.atk_text_get_range_extents(_arg0, _arg1, _arg2, _arg3, &_arg4)

	var _rect TextRectangle // out

	{
		var refTmpIn *C.AtkTextRectangle
		var refTmpOut *TextRectangle

		in0 := &_arg4
		refTmpIn = in0

		refTmpOut = (*TextRectangle)(unsafe.Pointer(refTmpIn))

		_rect = *refTmpOut
	}

	return _rect
}

func (t text) Selection(selectionNum int) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // in
	var _arg3 C.gint     // in
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_get_selection(_arg0, _arg1, &_arg2, &_arg3)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg2)
	_endOffset = int(_arg3)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText           // out
	var _arg1 C.gint               // out
	var _arg2 C.AtkTextGranularity // out
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in
	var _cret *C.gchar             // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextGranularity(granularity)

	_cret = C.atk_text_get_string_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) Text(startOffset int, endOffset int) string {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_get_text(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (t text) TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_after_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_before_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) RemoveSelection(selectionNum int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_remove_selection(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool {
	var _arg0 *C.AtkText      // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _arg3 C.AtkScrollType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkScrollType(typ)

	_cret = C.atk_text_scroll_substring_to(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coords)
	_arg4 = C.gint(x)
	_arg5 = C.gint(y)

	_cret = C.atk_text_scroll_substring_to_point(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) SetCaretOffset(offset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_set_caret_offset(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) SetSelection(selectionNum int, startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)
	_arg2 = C.gint(startOffset)
	_arg3 = C.gint(endOffset)

	_cret = C.atk_text_set_selection(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextRange: a structure used to describe a text range.
type TextRange C.AtkTextRange

// WrapTextRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextRange(ptr unsafe.Pointer) *TextRange {
	return (*TextRange)(ptr)
}

func marshalTextRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TextRange)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextRange) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// TextRectangle: a structure used to store a rectangle used by AtkText.
type TextRectangle C.AtkTextRectangle

// WrapTextRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextRectangle(ptr unsafe.Pointer) *TextRectangle {
	return (*TextRectangle)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TextRectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}
