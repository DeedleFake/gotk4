// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_text_attribute_get_type()), F: marshalTextAttribute},
		{T: externglib.Type(C.atk_text_boundary_get_type()), F: marshalTextBoundary},
		{T: externglib.Type(C.atk_text_clip_type_get_type()), F: marshalTextClipType},
		{T: externglib.Type(C.atk_text_granularity_get_type()), F: marshalTextGranularity},
		{T: externglib.Type(C.atk_text_get_type()), F: marshalText},
		{T: externglib.Type(C.atk_text_range_get_type()), F: marshalTextRange},
	})
}

// TextAttribute describes the text attributes supported
type TextAttribute int

const (
	// Invalid: invalid attribute, like bad spelling or grammar.
	TextAttrInvalid TextAttribute = iota
	// LeftMargin: the pixel width of the left margin
	TextAttrLeftMargin
	// RightMargin: the pixel width of the right margin
	TextAttrRightMargin
	// Indent: the number of pixels that the text is indented
	TextAttrIndent
	// Invisible: either "true" or "false" indicating whether text is visible or
	// not
	TextAttrInvisible
	// Editable: either "true" or "false" indicating whether text is editable or
	// not
	TextAttrEditable
	// PixelsAboveLines pixels of blank space to leave above each
	// newline-terminated line.
	TextAttrPixelsAboveLines
	// PixelsBelowLines pixels of blank space to leave below each
	// newline-terminated line.
	TextAttrPixelsBelowLines
	// PixelsInsideWrap pixels of blank space to leave between wrapped lines
	// inside the same newline-terminated line (paragraph).
	TextAttrPixelsInsideWrap
	// BgFullHeight: "true" or "false" whether to make the background color for
	// each character the height of the highest font used on the current line,
	// or the height of the font used for the current character.
	TextAttrBgFullHeight
	// Rise: number of pixels that the characters are risen above the baseline.
	// See also ATK_TEXT_ATTR_TEXT_POSITION.
	TextAttrRise
	// Underline: "none", "single", "double", "low", or "error"
	TextAttrUnderline
	// Strikethrough: "true" or "false" whether the text is strikethrough
	TextAttrStrikethrough
	// Size: the size of the characters in points. eg: 10
	TextAttrSize
	// Scale: the scale of the characters. The value is a string representation
	// of a double
	TextAttrScale
	// Weight: the weight of the characters.
	TextAttrWeight
	// Language: the language used
	TextAttrLanguage
	// FamilyName: the font family name
	TextAttrFamilyName
	// BgColor: the background color. The value is an RGB value of the format
	// "u,u,u"
	TextAttrBgColor
	// FgColor: the foreground color. The value is an RGB value of the format
	// "u,u,u"
	TextAttrFgColor
	// BgStipple: "true" if a Bitmap is set for stippling the background color.
	TextAttrBgStipple
	// FgStipple: "true" if a Bitmap is set for stippling the foreground color.
	TextAttrFgStipple
	// WrapMode: the wrap mode of the text, if any. Values are "none", "char",
	// "word", or "word_char".
	TextAttrWrapMode
	// Direction: the direction of the text, if set. Values are "none", "ltr" or
	// "rtl"
	TextAttrDirection
	// Justification: the justification of the text, if set. Values are "left",
	// "right", "center" or "fill"
	TextAttrJustification
	// Stretch: the stretch of the text, if set. Values are "ultra_condensed",
	// "extra_condensed", "condensed", "semi_condensed", "normal",
	// "semi_expanded", "expanded", "extra_expanded" or "ultra_expanded"
	TextAttrStretch
	// Variant: the capitalization variant of the text, if set. Values are
	// "normal" or "small_caps"
	TextAttrVariant
	// Style: the slant style of the text, if set. Values are "normal",
	// "oblique" or "italic"
	TextAttrStyle
	// TextPosition: the vertical position with respect to the baseline. Values
	// are "baseline", "super", or "sub". Note that a super or sub text
	// attribute refers to position with respect to the baseline of the prior
	// character.
	TextAttrTextPosition
	// LastDefined: not a valid text attribute, used for finding end of
	// enumeration
	TextAttrLastDefined
)

func marshalTextAttribute(p uintptr) (interface{}, error) {
	return TextAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextBoundary: text boundary types used for specifying boundaries for regions
// of text. This enumeration is deprecated since 2.9.4 and should not be used.
// Use AtkTextGranularity with #atk_text_get_string_at_offset instead.
type TextBoundary int

const (
	// Char: boundary is the boundary between characters (including non-printing
	// characters)
	TextBoundaryChar TextBoundary = iota
	// WordStart: boundary is the start (i.e. first character) of a word.
	TextBoundaryWordStart
	// WordEnd: boundary is the end (i.e. last character) of a word.
	TextBoundaryWordEnd
	// SentenceStart: boundary is the first character in a sentence.
	TextBoundarySentenceStart
	// SentenceEnd: boundary is the last (terminal) character in a sentence; in
	// languages which use "sentence stop" punctuation such as English, the
	// boundary is thus the '.', '?', or similar terminal punctuation character.
	TextBoundarySentenceEnd
	// LineStart: boundary is the initial character of the content or a
	// character immediately following a newline, linefeed, or return character.
	TextBoundaryLineStart
	// LineEnd: boundary is the linefeed, or return character.
	TextBoundaryLineEnd
)

func marshalTextBoundary(p uintptr) (interface{}, error) {
	return TextBoundary(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextClipType describes the type of clipping required.
type TextClipType int

const (
	// None: no clipping to be done
	TextClipNone TextClipType = iota
	// Min: text clipped by min coordinate is omitted
	TextClipMin
	// Max: text clipped by max coordinate is omitted
	TextClipMax
	// Both: only text fully within mix/max bound is retained
	TextClipBoth
)

func marshalTextClipType(p uintptr) (interface{}, error) {
	return TextClipType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextGranularity: text granularity types used for specifying the granularity
// of the region of text we are interested in.
type TextGranularity int

const (
	// Char: granularity is defined by the boundaries between characters
	// (including non-printing characters)
	TextGranularityChar TextGranularity = iota
	// Word: granularity is defined by the boundaries of a word, starting at the
	// beginning of the current word and finishing at the beginning of the
	// following one, if present.
	TextGranularityWord
	// Sentence: granularity is defined by the boundaries of a sentence,
	// starting at the beginning of the current sentence and finishing at the
	// beginning of the following one, if present.
	TextGranularitySentence
	// Line: granularity is defined by the boundaries of a line, starting at the
	// beginning of the current line and finishing at the beginning of the
	// following one, if present.
	TextGranularityLine
	// Paragraph: granularity is defined by the boundaries of a paragraph,
	// starting at the beginning of the current paragraph and finishing at the
	// beginning of the following one, if present.
	TextGranularityParagraph
)

func marshalTextGranularity(p uintptr) (interface{}, error) {
	return TextGranularity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextOverrider contains methods that are overridable .
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextOverrider interface {
	// AddSelection adds a selection bounded by the specified offsets.
	AddSelection(startOffset int, endOffset int) bool
	// BoundedRanges: get the ranges of text in the specified bounding box.
	BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange
	// CaretOffset gets the offset of the position of the caret (cursor).
	CaretOffset() int
	// CharacterAtOffset gets the specified text.
	CharacterAtOffset(offset int) uint32
	// CharacterCount gets the character count.
	CharacterCount() int
	// CharacterExtents: if the extent can not be obtained (e.g. missing
	// support), all of x, y, width, height are set to -1.
	//
	// Get the bounding box containing the glyph representing the character at a
	// particular text offset.
	CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int)
	// NSelections gets the number of selected regions.
	NSelections() int
	// OffsetAtPoint gets the offset of the character located at coordinates @x
	// and @y. @x and @y are interpreted as being relative to the screen or this
	// widget's window depending on @coords.
	OffsetAtPoint(x int, y int, coords CoordType) int
	// RangeExtents: get the bounding box for text within the specified range.
	//
	// If the extents can not be obtained (e.g. or missing support), the
	// rectangle fields are set to -1.
	RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle
	// Selection gets the text from the specified selection.
	Selection(selectionNum int) (startOffset int, endOffset int, utf8 string)
	// StringAtOffset gets a portion of the text exposed through an Text
	// according to a given @offset and a specific @granularity, along with the
	// start and end offsets defining the boundaries of such a portion of text.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_CHAR the character at the offset
	// is returned.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_WORD the returned string is from
	// the word start at or before the offset to the word start after the
	// offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_SENTENCE the returned string is
	// from the sentence start at or before the offset to the sentence start
	// after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_LINE the returned string is from
	// the line start at or before the offset to the line start after the
	// offset.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_PARAGRAPH the returned string is
	// from the start of the paragraph at or before the offset to the start of
	// the following paragraph after the offset.
	StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string)
	// Text gets the specified text.
	Text(startOffset int, endOffset int) string
	// TextAfterOffset gets the specified text.
	//
	// Deprecated: since version 2.9.3.
	TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextAtOffset gets the specified text.
	//
	// If the boundary_type if ATK_TEXT_BOUNDARY_CHAR the character at the
	// offset is returned.
	//
	// If the boundary_type is ATK_TEXT_BOUNDARY_WORD_START the returned string
	// is from the word start at or before the offset to the word start after
	// the offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_SENTENCE_START the returned
	// string is from the sentence start at or before the offset to the sentence
	// start after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_LINE_START the returned string
	// is from the line start at or before the offset to the line start after
	// the offset.
	//
	// Deprecated.
	TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextBeforeOffset gets the specified text.
	//
	// Deprecated: since version 2.9.3.
	TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// RemoveSelection removes the specified selection.
	RemoveSelection(selectionNum int) bool
	// ScrollSubstringTo makes a substring of @text visible on the screen by
	// scrolling all necessary parents.
	ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool
	// ScrollSubstringToPoint: move the top-left of a substring of @text to a
	// given position of the screen by scrolling all necessary parents.
	ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool
	// SetCaretOffset sets the caret (cursor) position to the specified @offset.
	//
	// In the case of rich-text content, this method should either grab focus or
	// move the sequential focus navigation starting point (if the application
	// supports this concept) as if the user had clicked on the new caret
	// position. Typically, this means that the target of this operation is the
	// node containing the new caret position or one of its ancestors. In other
	// words, after this method is called, if the user advances focus, it should
	// move to the first focusable node following the new caret position.
	//
	// Calling this method should also scroll the application viewport in a way
	// that matches the behavior of the application's typical caret motion or
	// tab navigation as closely as possible. This also means that if the
	// application's caret motion or focus navigation does not trigger a scroll
	// operation, this method should not trigger one either. If the application
	// does not have a caret motion or focus navigation operation, this method
	// should try to scroll the new caret position into view while minimizing
	// unnecessary scroll motion.
	SetCaretOffset(offset int) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum int, startOffset int, endOffset int) bool
	TextAttributesChanged()
	TextCaretMoved(location int)
	TextChanged(position int, length int)
	TextSelectionChanged()
}

// Text should be implemented by Objects on behalf of widgets that have text
// content which is either attributed or otherwise non-trivial. Objects whose
// text content is simple, unattributed, and very brief may expose that content
// via #atk_object_get_name instead; however if the text is editable,
// multi-line, typically longer than three or four words, attributed,
// selectable, or if the object already uses the 'name' ATK property for other
// information, the Text interface should be used to expose the text content. In
// the case of editable text content, EditableText (a subtype of the Text
// interface) should be implemented instead.
//
//    Text provides not only traversal facilities and change
//
// notification for text content, but also caret tracking and glyph bounding box
// calculations. Note that the text strings are exposed as UTF-8, and are
// therefore potentially multi-byte, and caret-to-byte offset mapping makes no
// assumptions about the character length; also bounding box glyph-to-offset
// mapping may be complex for languages which use ligatures.
type Text interface {
	gextras.Objector

	// AddSelection adds a selection bounded by the specified offsets.
	AddSelection(startOffset int, endOffset int) bool
	// BoundedRanges: get the ranges of text in the specified bounding box.
	BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange
	// CaretOffset gets the offset of the position of the caret (cursor).
	CaretOffset() int
	// CharacterAtOffset gets the specified text.
	CharacterAtOffset(offset int) uint32
	// CharacterCount gets the character count.
	CharacterCount() int
	// CharacterExtents: if the extent can not be obtained (e.g. missing
	// support), all of x, y, width, height are set to -1.
	//
	// Get the bounding box containing the glyph representing the character at a
	// particular text offset.
	CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int)
	// NSelections gets the number of selected regions.
	NSelections() int
	// OffsetAtPoint gets the offset of the character located at coordinates @x
	// and @y. @x and @y are interpreted as being relative to the screen or this
	// widget's window depending on @coords.
	OffsetAtPoint(x int, y int, coords CoordType) int
	// RangeExtents: get the bounding box for text within the specified range.
	//
	// If the extents can not be obtained (e.g. or missing support), the
	// rectangle fields are set to -1.
	RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle
	// Selection gets the text from the specified selection.
	Selection(selectionNum int) (startOffset int, endOffset int, utf8 string)
	// StringAtOffset gets a portion of the text exposed through an Text
	// according to a given @offset and a specific @granularity, along with the
	// start and end offsets defining the boundaries of such a portion of text.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_CHAR the character at the offset
	// is returned.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_WORD the returned string is from
	// the word start at or before the offset to the word start after the
	// offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_SENTENCE the returned string is
	// from the sentence start at or before the offset to the sentence start
	// after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_LINE the returned string is from
	// the line start at or before the offset to the line start after the
	// offset.
	//
	// If @granularity is ATK_TEXT_GRANULARITY_PARAGRAPH the returned string is
	// from the start of the paragraph at or before the offset to the start of
	// the following paragraph after the offset.
	StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string)
	// Text gets the specified text.
	Text(startOffset int, endOffset int) string
	// TextAfterOffset gets the specified text.
	//
	// Deprecated: since version 2.9.3.
	TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextAtOffset gets the specified text.
	//
	// If the boundary_type if ATK_TEXT_BOUNDARY_CHAR the character at the
	// offset is returned.
	//
	// If the boundary_type is ATK_TEXT_BOUNDARY_WORD_START the returned string
	// is from the word start at or before the offset to the word start after
	// the offset.
	//
	// The returned string will contain the word at the offset if the offset is
	// inside a word and will contain the word before the offset if the offset
	// is not inside a word.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_SENTENCE_START the returned
	// string is from the sentence start at or before the offset to the sentence
	// start after the offset.
	//
	// The returned string will contain the sentence at the offset if the offset
	// is inside a sentence and will contain the sentence before the offset if
	// the offset is not inside a sentence.
	//
	// If the boundary type is ATK_TEXT_BOUNDARY_LINE_START the returned string
	// is from the line start at or before the offset to the line start after
	// the offset.
	//
	// Deprecated.
	TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// TextBeforeOffset gets the specified text.
	//
	// Deprecated: since version 2.9.3.
	TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string)
	// RemoveSelection removes the specified selection.
	RemoveSelection(selectionNum int) bool
	// ScrollSubstringTo makes a substring of @text visible on the screen by
	// scrolling all necessary parents.
	ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool
	// ScrollSubstringToPoint: move the top-left of a substring of @text to a
	// given position of the screen by scrolling all necessary parents.
	ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool
	// SetCaretOffset sets the caret (cursor) position to the specified @offset.
	//
	// In the case of rich-text content, this method should either grab focus or
	// move the sequential focus navigation starting point (if the application
	// supports this concept) as if the user had clicked on the new caret
	// position. Typically, this means that the target of this operation is the
	// node containing the new caret position or one of its ancestors. In other
	// words, after this method is called, if the user advances focus, it should
	// move to the first focusable node following the new caret position.
	//
	// Calling this method should also scroll the application viewport in a way
	// that matches the behavior of the application's typical caret motion or
	// tab navigation as closely as possible. This also means that if the
	// application's caret motion or focus navigation does not trigger a scroll
	// operation, this method should not trigger one either. If the application
	// does not have a caret motion or focus navigation operation, this method
	// should try to scroll the new caret position into view while minimizing
	// unnecessary scroll motion.
	SetCaretOffset(offset int) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum int, startOffset int, endOffset int) bool
}

// text implements the Text interface.
type text struct {
	*externglib.Object
}

var _ Text = (*text)(nil)

// WrapText wraps a GObject to a type that implements
// interface Text. It is primarily used internally.
func WrapText(obj *externglib.Object) Text {
	return text{obj}
}

func marshalText(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapText(obj), nil
}

func (t text) AddSelection(startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_add_selection(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) BoundedRanges(rect *TextRectangle, coordType CoordType, xClipType TextClipType, yClipType TextClipType) []*TextRange {
	var _arg0 *C.AtkText          // out
	var _arg1 *C.AtkTextRectangle // out
	var _arg2 C.AtkCoordType      // out
	var _arg3 C.AtkTextClipType   // out
	var _arg4 C.AtkTextClipType   // out
	var _cret **C.AtkTextRange

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.AtkTextRectangle)(unsafe.Pointer(rect))
	_arg2 = C.AtkCoordType(coordType)
	_arg3 = C.AtkTextClipType(xClipType)
	_arg4 = C.AtkTextClipType(yClipType)

	_cret = C.atk_text_get_bounded_ranges(_arg0, _arg1, _arg2, _arg3, _arg4)

	var _textRanges []*TextRange

	{
		var i int
		var z *C.AtkTextRange
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_textRanges = make([]*TextRange, i)
		for i := range src {
			_textRanges[i] = (*TextRange)(unsafe.Pointer(src[i]))
			runtime.SetFinalizer(_textRanges[i], func(v *TextRange) {
				C.free(unsafe.Pointer(v))
			})
		}
	}

	return _textRanges
}

func (t text) CaretOffset() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_caret_offset(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) CharacterAtOffset(offset int) uint32 {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gunichar // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_get_character_at_offset(_arg0, _arg1)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

func (t text) CharacterCount() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_character_count(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) CharacterExtents(offset int, coords CoordType) (x int, y int, width int, height int) {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in
	var _arg4 C.gint         // in
	var _arg5 C.gint         // in
	var _arg6 C.AtkCoordType // out

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg6 = C.AtkCoordType(coords)

	C.atk_text_get_character_extents(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, _arg6)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg2)
	_y = int(_arg3)
	_width = int(_arg4)
	_height = int(_arg5)

	return _x, _y, _width, _height
}

func (t text) NSelections() int {
	var _arg0 *C.AtkText // out
	var _cret C.gint     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))

	_cret = C.atk_text_get_n_selections(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) OffsetAtPoint(x int, y int, coords CoordType) int {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _cret C.gint         // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.AtkCoordType(coords)

	_cret = C.atk_text_get_offset_at_point(_arg0, _arg1, _arg2, _arg3)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t text) RangeExtents(startOffset int, endOffset int, coordType CoordType) TextRectangle {
	var _arg0 *C.AtkText         // out
	var _arg1 C.gint             // out
	var _arg2 C.gint             // out
	var _arg3 C.AtkCoordType     // out
	var _arg4 C.AtkTextRectangle // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coordType)

	C.atk_text_get_range_extents(_arg0, _arg1, _arg2, _arg3, &_arg4)

	var _rect TextRectangle // out

	{
		var refTmpIn *C.AtkTextRectangle
		var refTmpOut *TextRectangle

		in0 := &_arg4
		refTmpIn = in0

		refTmpOut = (*TextRectangle)(unsafe.Pointer(refTmpIn))

		_rect = *refTmpOut
	}

	return _rect
}

func (t text) Selection(selectionNum int) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // in
	var _arg3 C.gint     // in
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_get_selection(_arg0, _arg1, &_arg2, &_arg3)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg2)
	_endOffset = int(_arg3)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) StringAtOffset(offset int, granularity TextGranularity) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText           // out
	var _arg1 C.gint               // out
	var _arg2 C.AtkTextGranularity // out
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in
	var _cret *C.gchar             // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextGranularity(granularity)

	_cret = C.atk_text_get_string_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) Text(startOffset int, endOffset int) string {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _cret *C.gchar   // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)

	_cret = C.atk_text_get_text(_arg0, _arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (t text) TextAfterOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_after_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) TextAtOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_at_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) TextBeforeOffset(offset int, boundaryType TextBoundary) (startOffset int, endOffset int, utf8 string) {
	var _arg0 *C.AtkText        // out
	var _arg1 C.gint            // out
	var _arg2 C.AtkTextBoundary // out
	var _arg3 C.gint            // in
	var _arg4 C.gint            // in
	var _cret *C.gchar          // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)
	_arg2 = C.AtkTextBoundary(boundaryType)

	_cret = C.atk_text_get_text_before_offset(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _startOffset int // out
	var _endOffset int   // out
	var _utf8 string     // out

	_startOffset = int(_arg3)
	_endOffset = int(_arg4)
	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

func (t text) RemoveSelection(selectionNum int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)

	_cret = C.atk_text_remove_selection(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) ScrollSubstringTo(startOffset int, endOffset int, typ ScrollType) bool {
	var _arg0 *C.AtkText      // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _arg3 C.AtkScrollType // out
	var _cret C.gboolean      // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkScrollType(typ)

	_cret = C.atk_text_scroll_substring_to(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) ScrollSubstringToPoint(startOffset int, endOffset int, coords CoordType, x int, y int) bool {
	var _arg0 *C.AtkText     // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.AtkCoordType // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	_arg3 = C.AtkCoordType(coords)
	_arg4 = C.gint(x)
	_arg5 = C.gint(y)

	_cret = C.atk_text_scroll_substring_to_point(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) SetCaretOffset(offset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(offset)

	_cret = C.atk_text_set_caret_offset(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t text) SetSelection(selectionNum int, startOffset int, endOffset int) bool {
	var _arg0 *C.AtkText // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.AtkText)(unsafe.Pointer(t.Native()))
	_arg1 = C.gint(selectionNum)
	_arg2 = C.gint(startOffset)
	_arg3 = C.gint(endOffset)

	_cret = C.atk_text_set_selection(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextRange: structure used to describe a text range.
type TextRange struct {
	native C.AtkTextRange
}

// WrapTextRange wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextRange(ptr unsafe.Pointer) *TextRange {
	return (*TextRange)(ptr)
}

func marshalTextRange(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TextRange)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextRange) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Bounds: rectangle giving the bounds of the text range
func (t *TextRange) Bounds() TextRectangle {
	var v TextRectangle // out
	{
		var refTmpIn *C.AtkTextRectangle
		var refTmpOut *TextRectangle

		in0 := &t.native.bounds
		refTmpIn = in0

		refTmpOut = (*TextRectangle)(unsafe.Pointer(refTmpIn))

		v = *refTmpOut
	}
	return v
}

// StartOffset: the start offset of a AtkTextRange
func (t *TextRange) StartOffset() int {
	var v int // out
	v = int(t.native.start_offset)
	return v
}

// EndOffset: the end offset of a AtkTextRange
func (t *TextRange) EndOffset() int {
	var v int // out
	v = int(t.native.end_offset)
	return v
}

// Content: the text in the text range
func (t *TextRange) Content() string {
	var v string // out
	v = C.GoString(t.native.content)
	return v
}

// TextRectangle: structure used to store a rectangle used by AtkText.
type TextRectangle struct {
	native C.AtkTextRectangle
}

// WrapTextRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTextRectangle(ptr unsafe.Pointer) *TextRectangle {
	return (*TextRectangle)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TextRectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// X: the horizontal coordinate of a rectangle
func (t *TextRectangle) X() int {
	var v int // out
	v = int(t.native.x)
	return v
}

// Y: the vertical coordinate of a rectangle
func (t *TextRectangle) Y() int {
	var v int // out
	v = int(t.native.y)
	return v
}

// Width: the width of a rectangle
func (t *TextRectangle) Width() int {
	var v int // out
	v = int(t.native.width)
	return v
}

// Height: the height of a rectangle
func (t *TextRectangle) Height() int {
	var v int // out
	v = int(t.native.height)
	return v
}
