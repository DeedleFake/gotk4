// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_table_cell_get_type()), F: marshalTableCeller},
	})
}

// TableCellOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TableCellOverrider interface {
	// ColumnSpan returns the number of columns occupied by this cell
	// accessible.
	ColumnSpan() int32
	// Position retrieves the tabular position of this cell.
	Position() (row int32, column int32, ok bool)
	// RowColumnSpan gets the row and column indexes and span of this cell
	// accessible.
	//
	// Note: If the object does not implement this function, then, by default,
	// atk will implement this function by calling get_row_span and
	// get_column_span on the object.
	RowColumnSpan() (row int32, column int32, rowSpan int32, columnSpan int32, ok bool)
	// RowSpan returns the number of rows occupied by this cell accessible.
	RowSpan() int32
	// Table returns a reference to the accessible of the containing table.
	Table() *ObjectClass
}

// TableCell: being Table a component which present elements ordered via rows
// and columns, an TableCell is the interface which each of those elements, so
// "cells" should implement.
//
// See also Table.
type TableCell struct {
	ObjectClass
}

// TableCeller describes TableCell's abstract methods.
type TableCeller interface {
	externglib.Objector

	// ColumnSpan returns the number of columns occupied by this cell
	// accessible.
	ColumnSpan() int32
	// Position retrieves the tabular position of this cell.
	Position() (row int32, column int32, ok bool)
	// RowColumnSpan gets the row and column indexes and span of this cell
	// accessible.
	RowColumnSpan() (row int32, column int32, rowSpan int32, columnSpan int32, ok bool)
	// RowSpan returns the number of rows occupied by this cell accessible.
	RowSpan() int32
	// Table returns a reference to the accessible of the containing table.
	Table() *ObjectClass
}

var _ TableCeller = (*TableCell)(nil)

func wrapTableCell(obj *externglib.Object) *TableCell {
	return &TableCell{
		ObjectClass: ObjectClass{
			Object: obj,
		},
	}
}

func marshalTableCeller(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTableCell(obj), nil
}

// ColumnSpan returns the number of columns occupied by this cell accessible.
func (cell *TableCell) ColumnSpan() int32 {
	var _arg0 *C.AtkTableCell // out
	var _cret C.gint          // in

	_arg0 = (*C.AtkTableCell)(unsafe.Pointer(cell.Native()))

	_cret = C.atk_table_cell_get_column_span(_arg0)
	runtime.KeepAlive(cell)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Position retrieves the tabular position of this cell.
func (cell *TableCell) Position() (row int32, column int32, ok bool) {
	var _arg0 *C.AtkTableCell // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.AtkTableCell)(unsafe.Pointer(cell.Native()))

	_cret = C.atk_table_cell_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(cell)

	var _row int32    // out
	var _column int32 // out
	var _ok bool      // out

	_row = int32(_arg1)
	_column = int32(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _row, _column, _ok
}

// RowColumnSpan gets the row and column indexes and span of this cell
// accessible.
//
// Note: If the object does not implement this function, then, by default, atk
// will implement this function by calling get_row_span and get_column_span on
// the object.
func (cell *TableCell) RowColumnSpan() (row int32, column int32, rowSpan int32, columnSpan int32, ok bool) {
	var _arg0 *C.AtkTableCell // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in
	var _arg3 C.gint          // in
	var _arg4 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.AtkTableCell)(unsafe.Pointer(cell.Native()))

	_cret = C.atk_table_cell_get_row_column_span(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(cell)

	var _row int32        // out
	var _column int32     // out
	var _rowSpan int32    // out
	var _columnSpan int32 // out
	var _ok bool          // out

	_row = int32(_arg1)
	_column = int32(_arg2)
	_rowSpan = int32(_arg3)
	_columnSpan = int32(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _row, _column, _rowSpan, _columnSpan, _ok
}

// RowSpan returns the number of rows occupied by this cell accessible.
func (cell *TableCell) RowSpan() int32 {
	var _arg0 *C.AtkTableCell // out
	var _cret C.gint          // in

	_arg0 = (*C.AtkTableCell)(unsafe.Pointer(cell.Native()))

	_cret = C.atk_table_cell_get_row_span(_arg0)
	runtime.KeepAlive(cell)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Table returns a reference to the accessible of the containing table.
func (cell *TableCell) Table() *ObjectClass {
	var _arg0 *C.AtkTableCell // out
	var _cret *C.AtkObject    // in

	_arg0 = (*C.AtkTableCell)(unsafe.Pointer(cell.Native()))

	_cret = C.atk_table_cell_get_table(_arg0)
	runtime.KeepAlive(cell)

	var _object *ObjectClass // out

	_object = wrapObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _object
}
