// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_axis_use_get_type()), F: marshalAxisUse},
		{T: externglib.Type(C.gdk_crossing_mode_get_type()), F: marshalCrossingMode},
		{T: externglib.Type(C.gdk_device_pad_feature_get_type()), F: marshalDevicePadFeature},
		{T: externglib.Type(C.gdk_device_tool_type_get_type()), F: marshalDeviceToolType},
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_event_type_get_type()), F: marshalEventType},
		{T: externglib.Type(C.gdk_fullscreen_mode_get_type()), F: marshalFullscreenMode},
		{T: externglib.Type(C.gdk_gl_error_get_type()), F: marshalGLError},
		{T: externglib.Type(C.gdk_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.gdk_input_source_get_type()), F: marshalInputSource},
		{T: externglib.Type(C.gdk_key_match_get_type()), F: marshalKeyMatch},
		{T: externglib.Type(C.gdk_memory_format_get_type()), F: marshalMemoryFormat},
		{T: externglib.Type(C.gdk_notify_type_get_type()), F: marshalNotifyType},
		{T: externglib.Type(C.gdk_scroll_direction_get_type()), F: marshalScrollDirection},
		{T: externglib.Type(C.gdk_subpixel_layout_get_type()), F: marshalSubpixelLayout},
		{T: externglib.Type(C.gdk_surface_edge_get_type()), F: marshalSurfaceEdge},
		{T: externglib.Type(C.gdk_touchpad_gesture_phase_get_type()), F: marshalTouchpadGesturePhase},
		{T: externglib.Type(C.gdk_vulkan_error_get_type()), F: marshalVulkanError},
		{T: externglib.Type(C.gdk_anchor_hints_get_type()), F: marshalAnchorHints},
		{T: externglib.Type(C.gdk_axis_flags_get_type()), F: marshalAxisFlags},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
		{T: externglib.Type(C.gdk_frame_clock_phase_get_type()), F: marshalFrameClockPhase},
		{T: externglib.Type(C.gdk_modifier_type_get_type()), F: marshalModifierType},
		{T: externglib.Type(C.gdk_paintable_flags_get_type()), F: marshalPaintableFlags},
		{T: externglib.Type(C.gdk_seat_capabilities_get_type()), F: marshalSeatCapabilities},
		{T: externglib.Type(C.gdk_toplevel_state_get_type()), F: marshalToplevelState},
		{T: externglib.Type(C.gdk_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.gdk_cairo_context_get_type()), F: marshalCairoContext},
		{T: externglib.Type(C.gdk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gdk_content_deserializer_get_type()), F: marshalContentDeserializer},
		{T: externglib.Type(C.gdk_content_serializer_get_type()), F: marshalContentSerializer},
		{T: externglib.Type(C.gdk_cursor_get_type()), F: marshalCursor},
		{T: externglib.Type(C.gdk_device_get_type()), F: marshalDevice},
		{T: externglib.Type(C.gdk_device_tool_get_type()), F: marshalDeviceTool},
		{T: externglib.Type(C.gdk_display_get_type()), F: marshalDisplay},
		{T: externglib.Type(C.gdk_display_manager_get_type()), F: marshalDisplayManager},
		{T: externglib.Type(C.gdk_drag_get_type()), F: marshalDrag},
		{T: externglib.Type(C.gdk_draw_context_get_type()), F: marshalDrawContext},
		{T: externglib.Type(C.gdk_drop_get_type()), F: marshalDrop},
		{T: externglib.Type(C.gdk_gl_context_get_type()), F: marshalGLContext},
		{T: externglib.Type(C.gdk_seat_get_type()), F: marshalSeat},
		{T: externglib.Type(C.gdk_vulkan_context_get_type()), F: marshalVulkanContext},
	})
}

// AxisUse defines how device axes are interpreted by GTK.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse int

const (
	// AxisUseIgnore: the axis is ignored.
	AxisUseIgnore AxisUse = 0
	// AxisUseX: the axis is used as the x axis.
	AxisUseX AxisUse = 1
	// AxisUseY: the axis is used as the y axis.
	AxisUseY AxisUse = 2
	// AxisUseDeltaX: the axis is used as the scroll x delta
	AxisUseDeltaX AxisUse = 3
	// AxisUseDeltaY: the axis is used as the scroll y delta
	AxisUseDeltaY AxisUse = 4
	// AxisUsePressure: the axis is used for pressure information.
	AxisUsePressure AxisUse = 5
	// AxisUseXtilt: the axis is used for x tilt information.
	AxisUseXtilt AxisUse = 6
	// AxisUseYtilt: the axis is used for y tilt information.
	AxisUseYtilt AxisUse = 7
	// AxisUseWheel: the axis is used for wheel information.
	AxisUseWheel AxisUse = 8
	// AxisUseDistance: the axis is used for pen/tablet distance information
	AxisUseDistance AxisUse = 9
	// AxisUseRotation: the axis is used for pen rotation information
	AxisUseRotation AxisUse = 10
	// AxisUseSlider: the axis is used for pen slider information
	AxisUseSlider AxisUse = 11
	// AxisUseLast: a constant equal to the numerically highest axis value.
	AxisUseLast AxisUse = 12
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CrossingMode specifies the crossing mode for enter and leave events.
type CrossingMode int

const (
	// CrossingModeNormal: crossing because of pointer motion.
	CrossingModeNormal CrossingMode = 0
	// CrossingModeGrab: crossing because a grab is activated.
	CrossingModeGrab CrossingMode = 1
	// CrossingModeUngrab: crossing because a grab is deactivated.
	CrossingModeUngrab CrossingMode = 2
	// CrossingModeGTKGrab: crossing because a GTK grab is activated.
	CrossingModeGTKGrab CrossingMode = 3
	// CrossingModeGTKUngrab: crossing because a GTK grab is deactivated.
	CrossingModeGTKUngrab CrossingMode = 4
	// CrossingModeStateChanged: crossing because a GTK widget changed state
	// (e.g. sensitivity).
	CrossingModeStateChanged CrossingMode = 5
	// CrossingModeTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchBegin CrossingMode = 6
	// CrossingModeTouchEnd: crossing because a touch sequence has ended, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchEnd CrossingMode = 7
	// CrossingModeDeviceSwitch: crossing because of a device switch (i.e. a
	// mouse taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didnâ€™t leave the surface.
	CrossingModeDeviceSwitch CrossingMode = 8
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DevicePadFeature: a pad feature.
type DevicePadFeature int

const (
	// DevicePadFeatureButton: a button
	DevicePadFeatureButton DevicePadFeature = 0
	// DevicePadFeatureRing: a ring-shaped interactive area
	DevicePadFeatureRing DevicePadFeature = 1
	// DevicePadFeatureStrip: a straight interactive area
	DevicePadFeatureStrip DevicePadFeature = 2
)

func marshalDevicePadFeature(p uintptr) (interface{}, error) {
	return DevicePadFeature(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeviceToolType indicates the specific type of tool being used being a tablet.
// Such as an airbrush, pencil, etc.
type DeviceToolType int

const (
	// DeviceToolTypeUnknown: tool is of an unknown type.
	DeviceToolTypeUnknown DeviceToolType = 0
	// DeviceToolTypePen: tool is a standard tablet stylus.
	DeviceToolTypePen DeviceToolType = 1
	// DeviceToolTypeEraser: tool is standard tablet eraser.
	DeviceToolTypeEraser DeviceToolType = 2
	// DeviceToolTypeBrush: tool is a brush stylus.
	DeviceToolTypeBrush DeviceToolType = 3
	// DeviceToolTypePencil: tool is a pencil stylus.
	DeviceToolTypePencil DeviceToolType = 4
	// DeviceToolTypeAirbrush: tool is an airbrush stylus.
	DeviceToolTypeAirbrush DeviceToolType = 5
	// DeviceToolTypeMouse: tool is a mouse.
	DeviceToolTypeMouse DeviceToolType = 6
	// DeviceToolTypeLens: tool is a lens cursor.
	DeviceToolTypeLens DeviceToolType = 7
)

func marshalDeviceToolType(p uintptr) (interface{}, error) {
	return DeviceToolType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragCancelReason: used in `GdkDrag` to the reason of a cancelled DND
// operation.
type DragCancelReason int

const (
	// DragCancelReasonNoTarget: there is no suitable drop target.
	DragCancelReasonNoTarget DragCancelReason = 0
	// DragCancelReasonUserCancelled: drag cancelled by the user
	DragCancelReasonUserCancelled DragCancelReason = 1
	// DragCancelReasonError: unspecified error.
	DragCancelReasonError DragCancelReason = 2
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventType specifies the type of the event.
type EventType int

const (
	// EventTypeDelete: the window manager has requested that the toplevel
	// surface be hidden or destroyed, usually when the user clicks on a special
	// icon in the title bar.
	EventTypeDelete EventType = 0
	// EventTypeMotionNotify: the pointer (usually a mouse) has moved.
	EventTypeMotionNotify EventType = 1
	// EventTypeButtonPress: a mouse button has been pressed.
	EventTypeButtonPress EventType = 2
	// EventTypeButtonRelease: a mouse button has been released.
	EventTypeButtonRelease EventType = 3
	// EventTypeKeyPress: a key has been pressed.
	EventTypeKeyPress EventType = 4
	// EventTypeKeyRelease: a key has been released.
	EventTypeKeyRelease EventType = 5
	// EventTypeEnterNotify: the pointer has entered the surface.
	EventTypeEnterNotify EventType = 6
	// EventTypeLeaveNotify: the pointer has left the surface.
	EventTypeLeaveNotify EventType = 7
	// EventTypeFocusChange: the keyboard focus has entered or left the surface.
	EventTypeFocusChange EventType = 8
	// EventTypeProximityIn: an input device has moved into contact with a
	// sensing surface (e.g. a touchscreen or graphics tablet).
	EventTypeProximityIn EventType = 9
	// EventTypeProximityOut: an input device has moved out of contact with a
	// sensing surface.
	EventTypeProximityOut EventType = 10
	// EventTypeDragEnter: the mouse has entered the surface while a drag is in
	// progress.
	EventTypeDragEnter EventType = 11
	// EventTypeDragLeave: the mouse has left the surface while a drag is in
	// progress.
	EventTypeDragLeave EventType = 12
	// EventTypeDragMotion: the mouse has moved in the surface while a drag is
	// in progress.
	EventTypeDragMotion EventType = 13
	// EventTypeDropStart: a drop operation onto the surface has started.
	EventTypeDropStart EventType = 14
	// EventTypeScroll: the scroll wheel was turned
	EventTypeScroll EventType = 15
	// EventTypeGrabBroken: a pointer or keyboard grab was broken.
	EventTypeGrabBroken EventType = 16
	// EventTypeTouchBegin: a new touch event sequence has just started.
	EventTypeTouchBegin EventType = 17
	// EventTypeTouchUpdate: a touch event sequence has been updated.
	EventTypeTouchUpdate EventType = 18
	// EventTypeTouchEnd: a touch event sequence has finished.
	EventTypeTouchEnd EventType = 19
	// EventTypeTouchCancel: a touch event sequence has been canceled.
	EventTypeTouchCancel EventType = 20
	// EventTypeTouchpadSwipe: a touchpad swipe gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadSwipe EventType = 21
	// EventTypeTouchpadPinch: a touchpad pinch gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadPinch EventType = 22
	// EventTypePadButtonPress: a tablet pad button press event.
	EventTypePadButtonPress EventType = 23
	// EventTypePadButtonRelease: a tablet pad button release event.
	EventTypePadButtonRelease EventType = 24
	// EventTypePadRing: a tablet pad axis event from a "ring".
	EventTypePadRing EventType = 25
	// EventTypePadStrip: a tablet pad axis event from a "strip".
	EventTypePadStrip EventType = 26
	// EventTypePadGroupMode: a tablet pad group mode change.
	EventTypePadGroupMode EventType = 27
	// EventTypeEventLast marks the end of the GdkEventType enumeration.
	EventTypeEventLast EventType = 28
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FullscreenMode indicates which monitor a surface should span over when in
// fullscreen mode.
type FullscreenMode int

const (
	// FullscreenModeCurrentMonitor: fullscreen on current monitor only.
	FullscreenModeCurrentMonitor FullscreenMode = 0
	// FullscreenModeAllMonitors: span across all monitors when fullscreen.
	FullscreenModeAllMonitors FullscreenMode = 1
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLError: error enumeration for `GdkGLContext`.
type GLError int

const (
	// GLErrorNotAvailable: openGL support is not available
	GLErrorNotAvailable GLError = 0
	// GLErrorUnsupportedFormat: the requested visual format is not supported
	GLErrorUnsupportedFormat GLError = 1
	// GLErrorUnsupportedProfile: the requested profile is not supported
	GLErrorUnsupportedProfile GLError = 2
	// GLErrorCompilationFailed: the shader compilation failed
	GLErrorCompilationFailed GLError = 3
	// GLErrorLinkFailed: the shader linking failed
	GLErrorLinkFailed GLError = 4
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity defines the reference point of a surface and is used in PopupLayout.
type Gravity int

const (
	// GravityNorthWest: the reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: the reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: the reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: the reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: the reference point is at the center of the surface.
	GravityCenter Gravity = 5
	// GravityEast: the reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: the reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: the reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: the reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: the reference point is at the top left corner of the
	// surface itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputSource: an enumeration describing the type of an input device in general
// terms.
type InputSource int

const (
	// InputSourceMouse: the device is a mouse. (This will be reported for the
	// core pointer, even if it is something else, such as a trackball.)
	InputSourceMouse InputSource = 0
	// InputSourcePen: the device is a stylus of a graphics tablet or similar
	// device.
	InputSourcePen InputSource = 1
	// InputSourceKeyboard: the device is a keyboard.
	InputSourceKeyboard InputSource = 2
	// InputSourceTouchscreen: the device is a direct-input touch device, such
	// as a touchscreen or tablet
	InputSourceTouchscreen InputSource = 3
	// InputSourceTouchpad: the device is an indirect touch device, such as a
	// touchpad
	InputSourceTouchpad InputSource = 4
	// InputSourceTrackpoint: the device is a trackpoint
	InputSourceTrackpoint InputSource = 5
	// InputSourceTabletPad: the device is a "pad", a collection of buttons,
	// rings and strips found in drawing tablets
	InputSourceTabletPad InputSource = 6
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// KeyMatch describes how well an event matches a given keyval and modifiers.
//
// `GdkKeyMatch` values are returned by [method@Gdk.KeyEvent.matches].
type KeyMatch int

const (
	// KeyMatchNone: the key event does not match
	KeyMatchNone KeyMatch = 0
	// KeyMatchPartial: the key event matches if keyboard state (specifically,
	// the currently active group) is ignored
	KeyMatchPartial KeyMatch = 1
	// KeyMatchExact: the key event matches
	KeyMatchExact KeyMatch = 2
)

func marshalKeyMatch(p uintptr) (interface{}, error) {
	return KeyMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryFormat: `GdkMemoryFormat` describes a format that bytes can have in
// memory.
//
// It describes formats by listing the contents of the memory passed to it. So
// GDK_MEMORY_A8R8G8B8 will be 1 byte (8 bits) of alpha, followed by a byte each
// of red, green and blue. It is not endian-dependent, so CAIRO_FORMAT_ARGB32 is
// represented by different `GdkMemoryFormats` on architectures with different
// endiannesses.
//
// Its naming is modelled after VkFormat (see
// https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.htmlFormat for
// details).
type MemoryFormat int

const (
	// MemoryFormatB8G8R8A8Premultiplied: 4 bytes; for blue, green, red, alpha.
	// The color values are premultiplied with the alpha value.
	MemoryFormatB8G8R8A8Premultiplied MemoryFormat = 0
	// MemoryFormatA8R8G8B8Premultiplied: 4 bytes; for alpha, red, green, blue.
	// The color values are premultiplied with the alpha value.
	MemoryFormatA8R8G8B8Premultiplied MemoryFormat = 1
	// MemoryFormatR8G8B8A8Premultiplied: 4 bytes; for red, green, blue, alpha
	// The color values are premultiplied with the alpha value.
	MemoryFormatR8G8B8A8Premultiplied MemoryFormat = 2
	// MemoryFormatB8G8R8A8: 4 bytes; for blue, green, red, alpha.
	MemoryFormatB8G8R8A8 MemoryFormat = 3
	// MemoryFormatA8R8G8B8: 4 bytes; for alpha, red, green, blue.
	MemoryFormatA8R8G8B8 MemoryFormat = 4
	// MemoryFormatR8G8B8A8: 4 bytes; for red, green, blue, alpha.
	MemoryFormatR8G8B8A8 MemoryFormat = 5
	// MemoryFormatA8B8G8R8: 4 bytes; for alpha, blue, green, red.
	MemoryFormatA8B8G8R8 MemoryFormat = 6
	// MemoryFormatR8G8B8: 3 bytes; for red, green, blue. The data is opaque.
	MemoryFormatR8G8B8 MemoryFormat = 7
	// MemoryFormatB8G8R8: 3 bytes; for blue, green, red. The data is opaque.
	MemoryFormatB8G8R8 MemoryFormat = 8
	// MemoryFormatNFormats: the number of formats. This value will change as
	// more formats get added, so do not rely on its concrete integer.
	MemoryFormatNFormats MemoryFormat = 9
)

func marshalMemoryFormat(p uintptr) (interface{}, error) {
	return MemoryFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotifyType specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType int

const (
	// NotifyTypeAncestor: the surface is entered from an ancestor or left
	// towards an ancestor.
	NotifyTypeAncestor NotifyType = 0
	// NotifyTypeVirtual: the pointer moves between an ancestor and an inferior
	// of the surface.
	NotifyTypeVirtual NotifyType = 1
	// NotifyTypeInferior: the surface is entered from an inferior or left
	// towards an inferior.
	NotifyTypeInferior NotifyType = 2
	// NotifyTypeNonlinear: the surface is entered from or left towards a
	// surface which is neither an ancestor nor an inferior.
	NotifyTypeNonlinear NotifyType = 3
	// NotifyTypeNonlinearVirtual: the pointer moves between two surfaces which
	// are not ancestors of each other and the surface is part of the ancestor
	// chain between one of these surfaces and their least common ancestor.
	NotifyTypeNonlinearVirtual NotifyType = 4
	// NotifyTypeUnknown: an unknown type of enter/leave event occurred.
	NotifyTypeUnknown NotifyType = 5
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollDirection specifies the direction for scroll events.
type ScrollDirection int

const (
	// ScrollDirectionUp: the surface is scrolled up.
	ScrollDirectionUp ScrollDirection = 0
	// ScrollDirectionDown: the surface is scrolled down.
	ScrollDirectionDown ScrollDirection = 1
	// ScrollDirectionLeft: the surface is scrolled to the left.
	ScrollDirectionLeft ScrollDirection = 2
	// ScrollDirectionRight: the surface is scrolled to the right.
	ScrollDirectionRight ScrollDirection = 3
	// ScrollDirectionSmooth: the scrolling is determined by the delta values in
	// scroll events. See gdk_scroll_event_get_deltas()
	ScrollDirectionSmooth ScrollDirection = 4
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubpixelLayout: this enumeration describes how the red, green and blue
// components of physical pixels on an output device are laid out.
type SubpixelLayout int

const (
	// SubpixelLayoutUnknown: the layout is not known
	SubpixelLayoutUnknown SubpixelLayout = 0
	// SubpixelLayoutNone: not organized in this way
	SubpixelLayoutNone SubpixelLayout = 1
	// SubpixelLayoutHorizontalRGB: the layout is horizontal, the order is RGB
	SubpixelLayoutHorizontalRGB SubpixelLayout = 2
	// SubpixelLayoutHorizontalBgr: the layout is horizontal, the order is BGR
	SubpixelLayoutHorizontalBgr SubpixelLayout = 3
	// SubpixelLayoutVerticalRGB: the layout is vertical, the order is RGB
	SubpixelLayoutVerticalRGB SubpixelLayout = 4
	// SubpixelLayoutVerticalBgr: the layout is vertical, the order is BGR
	SubpixelLayoutVerticalBgr SubpixelLayout = 5
)

func marshalSubpixelLayout(p uintptr) (interface{}, error) {
	return SubpixelLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SurfaceEdge determines a surface edge or corner.
type SurfaceEdge int

const (
	// SurfaceEdgeNorthWest: the top left corner.
	SurfaceEdgeNorthWest SurfaceEdge = 0
	// SurfaceEdgeNorth: the top edge.
	SurfaceEdgeNorth SurfaceEdge = 1
	// SurfaceEdgeNorthEast: the top right corner.
	SurfaceEdgeNorthEast SurfaceEdge = 2
	// SurfaceEdgeWest: the left edge.
	SurfaceEdgeWest SurfaceEdge = 3
	// SurfaceEdgeEast: the right edge.
	SurfaceEdgeEast SurfaceEdge = 4
	// SurfaceEdgeSouthWest: the lower left corner.
	SurfaceEdgeSouthWest SurfaceEdge = 5
	// SurfaceEdgeSouth: the lower edge.
	SurfaceEdgeSouth SurfaceEdge = 6
	// SurfaceEdgeSouthEast: the lower right corner.
	SurfaceEdgeSouthEast SurfaceEdge = 7
)

func marshalSurfaceEdge(p uintptr) (interface{}, error) {
	return SurfaceEdge(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture.
//
// All gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
type TouchpadGesturePhase int

const (
	// TouchpadGesturePhaseBegin: the gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = 0
	// TouchpadGesturePhaseUpdate: the gesture has been updated.
	TouchpadGesturePhaseUpdate TouchpadGesturePhase = 1
	// TouchpadGesturePhaseEnd: the gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd TouchpadGesturePhase = 2
	// TouchpadGesturePhaseCancel: the gesture was cancelled, all changes should
	// be undone.
	TouchpadGesturePhaseCancel TouchpadGesturePhase = 3
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VulkanError: error enumeration for VulkanContext.
type VulkanError int

const (
	// VulkanErrorUnsupported: vulkan is not supported on this backend or has
	// not been compiled in.
	VulkanErrorUnsupported VulkanError = 0
	// VulkanErrorNotAvailable: vulkan support is not available on this Surface
	VulkanErrorNotAvailable VulkanError = 1
)

func marshalVulkanError(p uintptr) (interface{}, error) {
	return VulkanError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AnchorHints: positioning hints for aligning a surface relative to a
// rectangle.
//
// These hints determine how the surface should be positioned in the case that
// the surface would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the surface extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the surface can be shifted horizontally to fit
// on-screen. If GDK_ANCHOR_RESIZE_X is set, the surface can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints int

const (
	// AnchorHintsFlipX: allow flipping anchors horizontally
	AnchorHintsFlipX AnchorHints = 0b1
	// AnchorHintsFlipY: allow flipping anchors vertically
	AnchorHintsFlipY AnchorHints = 0b10
	// AnchorHintsSlideX: allow sliding surface horizontally
	AnchorHintsSlideX AnchorHints = 0b100
	// AnchorHintsSlideY: allow sliding surface vertically
	AnchorHintsSlideY AnchorHints = 0b1000
	// AnchorHintsResizeX: allow resizing surface horizontally
	AnchorHintsResizeX AnchorHints = 0b10000
	// AnchorHintsResizeY: allow resizing surface vertically
	AnchorHintsResizeY AnchorHints = 0b100000
	// AnchorHintsFlip: allow flipping anchors on both axes
	AnchorHintsFlip AnchorHints = 0b11
	// AnchorHintsSlide: allow sliding surface on both axes
	AnchorHintsSlide AnchorHints = 0b1100
	// AnchorHintsResize: allow resizing surface on both axes
	AnchorHintsResize AnchorHints = 0b110000
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AxisFlags flags describing the current capabilities of a device/tool.
type AxisFlags int

const (
	// AxisFlagsX: x axis is present
	AxisFlagsX AxisFlags = 0b10
	// AxisFlagsY: y axis is present
	AxisFlagsY AxisFlags = 0b100
	// AxisFlagsDeltaX: scroll X delta axis is present
	AxisFlagsDeltaX AxisFlags = 0b1000
	// AxisFlagsDeltaY: scroll Y delta axis is present
	AxisFlagsDeltaY AxisFlags = 0b10000
	// AxisFlagsPressure: pressure axis is present
	AxisFlagsPressure AxisFlags = 0b100000
	// AxisFlagsXtilt: x tilt axis is present
	AxisFlagsXtilt AxisFlags = 0b1000000
	// AxisFlagsYtilt: y tilt axis is present
	AxisFlagsYtilt AxisFlags = 0b10000000
	// AxisFlagsWheel: wheel axis is present
	AxisFlagsWheel AxisFlags = 0b100000000
	// AxisFlagsDistance: distance axis is present
	AxisFlagsDistance AxisFlags = 0b1000000000
	// AxisFlagsRotation z-axis rotation is present
	AxisFlagsRotation AxisFlags = 0b10000000000
	// AxisFlagsSlider: slider axis is present
	AxisFlagsSlider AxisFlags = 0b100000000000
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in `GdkDrop` and `GdkDrag` to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction int

const (
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 0b1
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 0b10
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means, and is not supported on
	// all platforms.
	DragActionLink DragAction = 0b100
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 0b1000
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FrameClockPhase: used to represent the different paint clock phases that can
// be requested.
//
// The elements of the enumeration correspond to the signals of `GdkFrameClock`.
type FrameClockPhase int

const (
	// FrameClockPhaseNone: no phase
	FrameClockPhaseNone FrameClockPhase = 0b0
	// FrameClockPhaseFlushEvents corresponds to GdkFrameClock::flush-events.
	// Should not be handled by applications.
	FrameClockPhaseFlushEvents FrameClockPhase = 0b1
	// FrameClockPhaseBeforePaint corresponds to GdkFrameClock::before-paint.
	// Should not be handled by applications.
	FrameClockPhaseBeforePaint FrameClockPhase = 0b10
	// FrameClockPhaseUpdate corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdate FrameClockPhase = 0b100
	// FrameClockPhaseLayout corresponds to GdkFrameClock::layout. Should not be
	// handled by applicatiosn.
	FrameClockPhaseLayout FrameClockPhase = 0b1000
	// FrameClockPhasePaint corresponds to GdkFrameClock::paint.
	FrameClockPhasePaint FrameClockPhase = 0b10000
	// FrameClockPhaseResumeEvents corresponds to GdkFrameClock::resume-events.
	// Should not be handled by applications.
	FrameClockPhaseResumeEvents FrameClockPhase = 0b100000
	// FrameClockPhaseAfterPaint corresponds to GdkFrameClock::after-paint.
	// Should not be handled by applications.
	FrameClockPhaseAfterPaint FrameClockPhase = 0b1000000
)

func marshalFrameClockPhase(p uintptr) (interface{}, error) {
	return FrameClockPhase(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierType flags to indicate the state of modifier keys and mouse buttons
// in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// GDK_MODIFIER_MASK to remove all private values.
type ModifierType int

const (
	// ModifierTypeShiftMask: the Shift key.
	ModifierTypeShiftMask ModifierType = 0b1
	// ModifierTypeLockMask: a Lock key (depending on the modifier mapping of
	// the X server this may either be CapsLock or ShiftLock).
	ModifierTypeLockMask ModifierType = 0b10
	// ModifierTypeControlMask: the Control key.
	ModifierTypeControlMask ModifierType = 0b100
	// ModifierTypeAltMask: the fourth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier, but
	// normally it is the Alt key).
	ModifierTypeAltMask ModifierType = 0b1000
	// ModifierTypeButton1Mask: the first mouse button.
	ModifierTypeButton1Mask ModifierType = 0b100000000
	// ModifierTypeButton2Mask: the second mouse button.
	ModifierTypeButton2Mask ModifierType = 0b1000000000
	// ModifierTypeButton3Mask: the third mouse button.
	ModifierTypeButton3Mask ModifierType = 0b10000000000
	// ModifierTypeButton4Mask: the fourth mouse button.
	ModifierTypeButton4Mask ModifierType = 0b100000000000
	// ModifierTypeButton5Mask: the fifth mouse button.
	ModifierTypeButton5Mask ModifierType = 0b1000000000000
	// ModifierTypeSuperMask: the Super modifier
	ModifierTypeSuperMask ModifierType = 0b100000000000000000000000000
	// ModifierTypeHyperMask: the Hyper modifier
	ModifierTypeHyperMask ModifierType = 0b1000000000000000000000000000
	// ModifierTypeMetaMask: the Meta modifier
	ModifierTypeMetaMask ModifierType = 0b10000000000000000000000000000
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PaintableFlags flags about a paintable object.
//
// Implementations use these for optimizations such as caching.
type PaintableFlags int

const (
	// PaintableFlagsSize: the size is immutable. The
	// [signal@GdkPaintable::invalidate-size] signal will never be emitted.
	PaintableFlagsSize PaintableFlags = 0b1
	// PaintableFlagsContents: the content is immutable. The
	// [signal@GdkPaintable::invalidate-contents] signal will never be emitted.
	PaintableFlagsContents PaintableFlags = 0b10
)

func marshalPaintableFlags(p uintptr) (interface{}, error) {
	return PaintableFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SeatCapabilities flags describing the seat capabilities.
type SeatCapabilities int

const (
	// SeatCapabilitiesNone: no input capabilities
	SeatCapabilitiesNone SeatCapabilities = 0b0
	// SeatCapabilitiesPointer: the seat has a pointer (e.g. mouse)
	SeatCapabilitiesPointer SeatCapabilities = 0b1
	// SeatCapabilitiesTouch: the seat has touchscreen(s) attached
	SeatCapabilitiesTouch SeatCapabilities = 0b10
	// SeatCapabilitiesTabletStylus: the seat has drawing tablet(s) attached
	SeatCapabilitiesTabletStylus SeatCapabilities = 0b100
	// SeatCapabilitiesKeyboard: the seat has keyboard(s) attached
	SeatCapabilitiesKeyboard SeatCapabilities = 0b1000
	// SeatCapabilitiesTabletPad: the seat has drawing tablet pad(s) attached
	SeatCapabilitiesTabletPad SeatCapabilities = 0b10000
	// SeatCapabilitiesAllPointing: the union of all pointing capabilities
	SeatCapabilitiesAllPointing SeatCapabilities = 0b111
	// SeatCapabilitiesAll: the union of all capabilities
	SeatCapabilitiesAll SeatCapabilities = 0b1111
)

func marshalSeatCapabilities(p uintptr) (interface{}, error) {
	return SeatCapabilities(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToplevelState specifies the state of a toplevel surface.
//
// On platforms that support information about individual edges, the
// GDK_TOPLEVEL_STATE_TILED state will be set whenever any of the individual
// tiled states is set. On platforms that lack that support, the tiled state
// will give an indication of tiledness without any of the per-edge states being
// set.
type ToplevelState int

const (
	// ToplevelStateMinimized: the surface is minimized
	ToplevelStateMinimized ToplevelState = 0b1
	// ToplevelStateMaximized: the surface is maximized
	ToplevelStateMaximized ToplevelState = 0b10
	// ToplevelStateSticky: the surface is sticky
	ToplevelStateSticky ToplevelState = 0b100
	// ToplevelStateFullscreen: the surface is maximized without decorations
	ToplevelStateFullscreen ToplevelState = 0b1000
	// ToplevelStateAbove: the surface is kept above other surfaces
	ToplevelStateAbove ToplevelState = 0b10000
	// ToplevelStateBelow: the surface is kept below other surfaces
	ToplevelStateBelow ToplevelState = 0b100000
	// ToplevelStateFocused: the surface is presented as focused (with active
	// decorations)
	ToplevelStateFocused ToplevelState = 0b1000000
	// ToplevelStateTiled: the surface is in a tiled state
	ToplevelStateTiled ToplevelState = 0b10000000
	// ToplevelStateTopTiled: whether the top edge is tiled
	ToplevelStateTopTiled ToplevelState = 0b100000000
	// ToplevelStateTopResizable: whether the top edge is resizable
	ToplevelStateTopResizable ToplevelState = 0b1000000000
	// ToplevelStateRightTiled: whether the right edge is tiled
	ToplevelStateRightTiled ToplevelState = 0b10000000000
	// ToplevelStateRightResizable: whether the right edge is resizable
	ToplevelStateRightResizable ToplevelState = 0b100000000000
	// ToplevelStateBottomTiled: whether the bottom edge is tiled
	ToplevelStateBottomTiled ToplevelState = 0b1000000000000
	// ToplevelStateBottomResizable: whether the bottom edge is resizable
	ToplevelStateBottomResizable ToplevelState = 0b10000000000000
	// ToplevelStateLeftTiled: whether the left edge is tiled
	ToplevelStateLeftTiled ToplevelState = 0b100000000000000
	// ToplevelStateLeftResizable: whether the left edge is resizable
	ToplevelStateLeftResizable ToplevelState = 0b1000000000000000
)

func marshalToplevelState(p uintptr) (interface{}, error) {
	return ToplevelState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

func GLErrorQuark() glib.Quark {
	ret := C.gdk_gl_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

func VulkanErrorQuark() glib.Quark {
	ret := C.gdk_vulkan_error_quark()

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// AppLaunchContext: `GdkAppLaunchContext` handles launching an application in a
// graphical context.
//
// It is an implementation of `GAppLaunchContext` that provides startup
// notification and allows to launch applications on a specific screen or
// workspace.
//
//
// Launching an application
//
// â€œ`c GdkAppLaunchContext *context;
//
// context = gdk_display_get_app_launch_context (display);
//
// gdk_app_launch_context_set_display (display);
// gdk_app_launch_context_set_timestamp (gdk_event_get_time (event));
//
// if (!g_app_info_launch_default_for_uri ("http://www.gtk.org", context,
// &error)) g_warning ("Launching failed: s\n", error->message);
//
// g_object_unref (context); â€œ`
type AppLaunchContext interface {
	gio.AppLaunchContext

	// Display gets the `GdkDisplay` that @context is for.
	Display() Display
	// SetDesktop sets the workspace on which applications will be launched.
	//
	// This only works when running under a window manager that supports
	// multiple workspaces, as described in the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec).
	//
	// When the workspace is not specified or @desktop is set to -1, it is up to
	// the window manager to pick one, typically it will be the current
	// workspace.
	SetDesktop(desktop int)
	// SetIcon sets the icon for applications that are launched with this
	// context.
	//
	// Window Managers can use this information when displaying startup
	// notification.
	//
	// See also [method@Gdk.AppLaunchContext.set_icon_name].
	SetIcon(icon gio.Icon)
	// SetIconName sets the icon for applications that are launched with this
	// context.
	//
	// The @icon_name will be interpreted in the same way as the Icon field in
	// desktop files. See also [method@Gdk.AppLaunchContext.set_icon()].
	//
	// If both @icon and @icon_name are set, the @icon_name takes priority. If
	// neither @icon or @icon_name is set, the icon is taken from either the
	// file that is passed to launched application or from the `GAppInfo` for
	// the launched application itself.
	SetIconName(iconName string)
	// SetTimestamp sets the timestamp of @context.
	//
	// The timestamp should ideally be taken from the event that triggered the
	// launch.
	//
	// Window managers can use this information to avoid moving the focus to the
	// newly launched application when the user is busy typing in another
	// window. This is also known as 'focus stealing prevention'.
	SetTimestamp(timestamp uint32)
}

// appLaunchContext implements the AppLaunchContext interface.
type appLaunchContext struct {
	gio.AppLaunchContext
}

var _ AppLaunchContext = (*appLaunchContext)(nil)

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return AppLaunchContext{
		gio.AppLaunchContext: gio.WrapAppLaunchContext(obj),
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

// Display gets the `GdkDisplay` that @context is for.
func (c appLaunchContext) Display() Display {
	var arg0 *C.GdkAppLaunchContext

	arg0 = (*C.GdkAppLaunchContext)(c.Native())

	ret := C.gdk_app_launch_context_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// SetDesktop sets the workspace on which applications will be launched.
//
// This only works when running under a window manager that supports
// multiple workspaces, as described in the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec).
//
// When the workspace is not specified or @desktop is set to -1, it is up to
// the window manager to pick one, typically it will be the current
// workspace.
func (c appLaunchContext) SetDesktop(desktop int) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 C.int

	arg0 = (*C.GdkAppLaunchContext)(c.Native())
	arg1 = C.int(desktop)

	C.gdk_app_launch_context_set_desktop(arg0, arg1)
}

// SetIcon sets the icon for applications that are launched with this
// context.
//
// Window Managers can use this information when displaying startup
// notification.
//
// See also [method@Gdk.AppLaunchContext.set_icon_name].
func (c appLaunchContext) SetIcon(icon gio.Icon) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.GIcon

	arg0 = (*C.GdkAppLaunchContext)(c.Native())
	arg1 = (*C.GIcon)(icon.Native())

	C.gdk_app_launch_context_set_icon(arg0, arg1)
}

// SetIconName sets the icon for applications that are launched with this
// context.
//
// The @icon_name will be interpreted in the same way as the Icon field in
// desktop files. See also [method@Gdk.AppLaunchContext.set_icon()].
//
// If both @icon and @icon_name are set, the @icon_name takes priority. If
// neither @icon or @icon_name is set, the icon is taken from either the
// file that is passed to launched application or from the `GAppInfo` for
// the launched application itself.
func (c appLaunchContext) SetIconName(iconName string) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.char

	arg0 = (*C.GdkAppLaunchContext)(c.Native())
	arg1 = (*C.gchar)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_app_launch_context_set_icon_name(arg0, arg1)
}

// SetTimestamp sets the timestamp of @context.
//
// The timestamp should ideally be taken from the event that triggered the
// launch.
//
// Window managers can use this information to avoid moving the focus to the
// newly launched application when the user is busy typing in another
// window. This is also known as 'focus stealing prevention'.
func (c appLaunchContext) SetTimestamp(timestamp uint32) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 C.guint32

	arg0 = (*C.GdkAppLaunchContext)(c.Native())
	arg1 = C.guint32(timestamp)

	C.gdk_app_launch_context_set_timestamp(arg0, arg1)
}

// CairoContext: `GdkCairoContext` is an object representing the
// platform-specific draw context.
//
// `GdkCairoContext`s are created for a surface using
// [method@Gdk.Surface.create_cairo_context], and the context can then be used
// to draw on that surface.
type CairoContext interface {
	DrawContext

	// CairoCreate retrieves a Cairo context to be used to draw on the
	// `GdkSurface` of @context.
	//
	// A call to [method@Gdk.DrawContext.begin_frame] with this @context must
	// have been done or this function will return nil.
	//
	// The returned context is guaranteed to be valid until
	// [method@Gdk.DrawContext.end_frame] is called.
	CairoCreate() *cairo.Context
}

// cairoContext implements the CairoContext interface.
type cairoContext struct {
	DrawContext
}

var _ CairoContext = (*cairoContext)(nil)

// WrapCairoContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoContext(obj *externglib.Object) CairoContext {
	return CairoContext{
		DrawContext: WrapDrawContext(obj),
	}
}

func marshalCairoContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoContext(obj), nil
}

// CairoCreate retrieves a Cairo context to be used to draw on the
// `GdkSurface` of @context.
//
// A call to [method@Gdk.DrawContext.begin_frame] with this @context must
// have been done or this function will return nil.
//
// The returned context is guaranteed to be valid until
// [method@Gdk.DrawContext.end_frame] is called.
func (s cairoContext) CairoCreate() *cairo.Context {
	var arg0 *C.GdkCairoContext

	arg0 = (*C.GdkCairoContext)(s.Native())

	ret := C.gdk_cairo_context_cairo_create(arg0)

	var ret0 *cairo.Context

	{
		ret0 = cairo.WrapContext(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *cairo.Context) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Clipboard: the `GdkClipboard` object represents data shared between
// applications or inside an application.
//
// To get a `GdkClipboard` object, use [method@Gdk.Display.get_clipboard] or
// [method@Gdk.Display.get_primary_clipboard]. You can find out about the data
// that is currently available in a clipboard using
// [method@Gdk.Clipboard.get_formats].
//
// To make text or image data available in a clipboard, use
// [method@Gdk.Clipboard.set_text] or [method@Gdk.Clipboard.set_texture]. For
// other data, you can use [method@Gdk.Clipboard.set_content], which takes a
// [class@Gdk.ContentProvider] object.
//
// To read textual or image data from a clipboard, use
// [method@Gdk.Clipboard.read_text_async] or
// [method@Gdk.Clipboard.read_texture_async]. For other data, use
// [method@Gdk.Clipboard.read_async], which provides a `GInputStream` object.
type Clipboard interface {
	gextras.Objector

	// Content returns the `GdkContentProvider` currently set on @clipboard.
	//
	// If the @clipboard is empty or its contents are not owned by the current
	// process, nil will be returned.
	Content() ContentProvider
	// Display gets the `GdkDisplay` that the clipboard was created for.
	Display() Display
	// Formats gets the formats that the clipboard can provide its current
	// contents in.
	Formats() *ContentFormats
	// IsLocal returns if the clipboard is local.
	//
	// A clipboard is considered local if it was last claimed by the running
	// application.
	//
	// Note that [method@Gdk.Clipboard.get_content] may return nil even on a
	// local clipboard. In this case the clipboard is empty.
	IsLocal() bool
	// ReadAsync: asynchronously requests an input stream to read the
	// @clipboard's contents from.
	//
	// When the operation is finished @callback will be called. You must then
	// call [method@Gdk.Clipboard.read_finish] to get the result of the
	// operation.
	//
	// The clipboard will choose the most suitable mime type from the given list
	// to fulfill the request, preferring the ones listed first.
	ReadAsync(mimeTypes string, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadFinish finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_async].
	ReadFinish(result gio.AsyncResult) (outMIMEType string, inputStream gio.InputStream, err error)
	// ReadTextAsync: asynchronously request the @clipboard contents converted
	// to a string.
	//
	// When the operation is finished @callback will be called. You must then
	// call [method@Gdk.Clipboard.read_text_finish] to get the result.
	//
	// This is a simple wrapper around [method@Gdk.Clipboard.read_value_async].
	// Use that function or [method@Gdk.Clipboard.read_async] directly if you
	// need more control over the operation.
	ReadTextAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadTextFinish finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_text_async].
	ReadTextFinish(result gio.AsyncResult) (utf8 string, err error)
	// ReadTextureAsync: asynchronously request the @clipboard contents
	// converted to a `GdkPixbuf`.
	//
	// When the operation is finished @callback will be called. You must then
	// call [method@Gdk.Clipboard.read_texture_finish] to get the result.
	//
	// This is a simple wrapper around [method@Gdk.Clipboard.read_value_async].
	// Use that function or [methos@Gdk.Clipboard.read_async] directly if you
	// need more control over the operation.
	ReadTextureAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadTextureFinish finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_texture_async].
	ReadTextureFinish(result gio.AsyncResult) (texture Texture, err error)
	// ReadValueAsync: asynchronously request the @clipboard contents converted
	// to the given @type.
	//
	// When the operation is finished @callback will be called. You must then
	// call [method@Gdk.Clipboard.read_value_finish] to get the resulting
	// `GValue`.
	//
	// For local clipboard contents that are available in the given `GType`, the
	// value will be copied directly. Otherwise, GDK will try to use
	// [func@content_deserialize_async] to convert the clipboard's data.
	ReadValueAsync(typ externglib.Type, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadValueFinish finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_value_async].
	ReadValueFinish(result gio.AsyncResult) (value *externglib.Value, err error)
	// SetContent sets a new content provider on @clipboard.
	//
	// The clipboard will claim the `GdkDisplay`'s resources and advertise these
	// new contents to other applications.
	//
	// In the rare case of a failure, this function will return false. The
	// clipboard will then continue reporting its old contents and ignore
	// @provider.
	//
	// If the contents are read by either an external application or the
	// @clipboard's read functions, @clipboard will select the best format to
	// transfer the contents and then request that format from @provider.
	SetContent(provider ContentProvider) bool
	// SetText puts the given @text into the clipboard.
	SetText(text string)
	// SetTexture puts the given @texture into the clipboard.
	SetTexture(texture Texture)
	// SetValue sets the @clipboard to contain the given @value.
	SetValue(value *externglib.Value)
	// StoreAsync: asynchronously instructs the @clipboard to store its contents
	// remotely.
	//
	// If the clipboard is not local, this function does nothing but report
	// success.
	//
	// The @callback must call [method@Gdk.Clipboard.store_finish].
	//
	// The purpose of this call is to preserve clipboard contents beyond the
	// lifetime of an application, so this function is typically called on exit.
	// Depending on the platform, the functionality may not be available unless
	// a "clipboard manager" is running.
	//
	// This function is called automatically when a [class@Gtk.Application] is
	// shut down, so you likely don't need to call it.
	StoreAsync(ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// StoreFinish finishes an asynchronous clipboard store.
	//
	// See [method@Gdk.Clipboard.store_async].
	StoreFinish(result gio.AsyncResult) error
}

// clipboard implements the Clipboard interface.
type clipboard struct {
	gextras.Objector
}

var _ Clipboard = (*clipboard)(nil)

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return Clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

// Content returns the `GdkContentProvider` currently set on @clipboard.
//
// If the @clipboard is empty or its contents are not owned by the current
// process, nil will be returned.
func (c clipboard) Content() ContentProvider {
	var arg0 *C.GdkClipboard

	arg0 = (*C.GdkClipboard)(c.Native())

	ret := C.gdk_clipboard_get_content(arg0)

	var ret0 ContentProvider

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(ContentProvider)

	return ret0
}

// Display gets the `GdkDisplay` that the clipboard was created for.
func (c clipboard) Display() Display {
	var arg0 *C.GdkClipboard

	arg0 = (*C.GdkClipboard)(c.Native())

	ret := C.gdk_clipboard_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// Formats gets the formats that the clipboard can provide its current
// contents in.
func (c clipboard) Formats() *ContentFormats {
	var arg0 *C.GdkClipboard

	arg0 = (*C.GdkClipboard)(c.Native())

	ret := C.gdk_clipboard_get_formats(arg0)

	var ret0 *ContentFormats

	{
		ret0 = WrapContentFormats(unsafe.Pointer(ret))
	}

	return ret0
}

// IsLocal returns if the clipboard is local.
//
// A clipboard is considered local if it was last claimed by the running
// application.
//
// Note that [method@Gdk.Clipboard.get_content] may return nil even on a
// local clipboard. In this case the clipboard is empty.
func (c clipboard) IsLocal() bool {
	var arg0 *C.GdkClipboard

	arg0 = (*C.GdkClipboard)(c.Native())

	ret := C.gdk_clipboard_is_local(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ReadAsync: asynchronously requests an input stream to read the
// @clipboard's contents from.
//
// When the operation is finished @callback will be called. You must then
// call [method@Gdk.Clipboard.read_finish] to get the result of the
// operation.
//
// The clipboard will choose the most suitable mime type from the given list
// to fulfill the request, preferring the ones listed first.
func (c clipboard) ReadAsync(mimeTypes string, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkClipboard
	var arg1 **C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.gchar)(C.CString(mimeTypes))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.gdk_clipboard_read_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ReadFinish finishes an asynchronous clipboard read.
//
// See [method@Gdk.Clipboard.read_async].
func (c clipboard) ReadFinish(result gio.AsyncResult) (outMIMEType string, inputStream gio.InputStream, err error) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GAsyncResult
	var arg2 **C.char // out
	var gError *C.GError

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_clipboard_read_finish(arg0, arg1, &arg2, &gError)

	var ret0 string
	var ret1 gio.InputStream
	var goError error

	ret0 = C.GoString(arg2)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.InputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// ReadTextAsync: asynchronously request the @clipboard contents converted
// to a string.
//
// When the operation is finished @callback will be called. You must then
// call [method@Gdk.Clipboard.read_text_finish] to get the result.
//
// This is a simple wrapper around [method@Gdk.Clipboard.read_value_async].
// Use that function or [method@Gdk.Clipboard.read_async] directly if you
// need more control over the operation.
func (c clipboard) ReadTextAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.gdk_clipboard_read_text_async(arg0, arg1, arg2, arg3)
}

// ReadTextFinish finishes an asynchronous clipboard read.
//
// See [method@Gdk.Clipboard.read_text_async].
func (c clipboard) ReadTextFinish(result gio.AsyncResult) (utf8 string, err error) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_clipboard_read_text_finish(arg0, arg1, &gError)

	var ret0 string
	var goError error

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReadTextureAsync: asynchronously request the @clipboard contents
// converted to a `GdkPixbuf`.
//
// When the operation is finished @callback will be called. You must then
// call [method@Gdk.Clipboard.read_texture_finish] to get the result.
//
// This is a simple wrapper around [method@Gdk.Clipboard.read_value_async].
// Use that function or [methos@Gdk.Clipboard.read_async] directly if you
// need more control over the operation.
func (c clipboard) ReadTextureAsync(cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GCancellable
	var arg2 C.GAsyncReadyCallback
	var arg3 C.gpointer

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GCancellable)(cancellable.Native())
	arg2 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg3 = C.gpointer(box.Assign(callback))

	C.gdk_clipboard_read_texture_async(arg0, arg1, arg2, arg3)
}

// ReadTextureFinish finishes an asynchronous clipboard read.
//
// See [method@Gdk.Clipboard.read_texture_async].
func (c clipboard) ReadTextureFinish(result gio.AsyncResult) (texture Texture, err error) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_clipboard_read_texture_finish(arg0, arg1, &gError)

	var ret0 Texture
	var goError error

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Texture)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// ReadValueAsync: asynchronously request the @clipboard contents converted
// to the given @type.
//
// When the operation is finished @callback will be called. You must then
// call [method@Gdk.Clipboard.read_value_finish] to get the resulting
// `GValue`.
//
// For local clipboard contents that are available in the given `GType`, the
// value will be copied directly. Otherwise, GDK will try to use
// [func@content_deserialize_async] to convert the clipboard's data.
func (c clipboard) ReadValueAsync(typ externglib.Type, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkClipboard
	var arg1 C.GType
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = C.GType(typ)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.gdk_clipboard_read_value_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ReadValueFinish finishes an asynchronous clipboard read.
//
// See [method@Gdk.Clipboard.read_value_async].
func (c clipboard) ReadValueFinish(result gio.AsyncResult) (value *externglib.Value, err error) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_clipboard_read_value_finish(arg0, arg1, &gError)

	var ret0 *externglib.Value
	var goError error

	ret0 = externglib.ValueFromNative(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// SetContent sets a new content provider on @clipboard.
//
// The clipboard will claim the `GdkDisplay`'s resources and advertise these
// new contents to other applications.
//
// In the rare case of a failure, this function will return false. The
// clipboard will then continue reporting its old contents and ignore
// @provider.
//
// If the contents are read by either an external application or the
// @clipboard's read functions, @clipboard will select the best format to
// transfer the contents and then request that format from @provider.
func (c clipboard) SetContent(provider ContentProvider) bool {
	var arg0 *C.GdkClipboard
	var arg1 *C.GdkContentProvider

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GdkContentProvider)(provider.Native())

	ret := C.gdk_clipboard_set_content(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SetText puts the given @text into the clipboard.
func (c clipboard) SetText(text string) {
	var arg0 *C.GdkClipboard
	var arg1 *C.char

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_clipboard_set_text(arg0, arg1)
}

// SetTexture puts the given @texture into the clipboard.
func (c clipboard) SetTexture(texture Texture) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GdkTexture

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GdkTexture)(texture.Native())

	C.gdk_clipboard_set_texture(arg0, arg1)
}

// SetValue sets the @clipboard to contain the given @value.
func (c clipboard) SetValue(value *externglib.Value) {
	var arg0 *C.GdkClipboard
	var arg1 *C.GValue

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GValue)(value.GValue)

	C.gdk_clipboard_set_value(arg0, arg1)
}

// StoreAsync: asynchronously instructs the @clipboard to store its contents
// remotely.
//
// If the clipboard is not local, this function does nothing but report
// success.
//
// The @callback must call [method@Gdk.Clipboard.store_finish].
//
// The purpose of this call is to preserve clipboard contents beyond the
// lifetime of an application, so this function is typically called on exit.
// Depending on the platform, the functionality may not be available unless
// a "clipboard manager" is running.
//
// This function is called automatically when a [class@Gtk.Application] is
// shut down, so you likely don't need to call it.
func (c clipboard) StoreAsync(ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkClipboard
	var arg1 C.int
	var arg2 *C.GCancellable
	var arg3 C.GAsyncReadyCallback
	var arg4 C.gpointer

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = C.int(ioPriority)
	arg2 = (*C.GCancellable)(cancellable.Native())
	arg3 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg4 = C.gpointer(box.Assign(callback))

	C.gdk_clipboard_store_async(arg0, arg1, arg2, arg3, arg4)
}

// StoreFinish finishes an asynchronous clipboard store.
//
// See [method@Gdk.Clipboard.store_async].
func (c clipboard) StoreFinish(result gio.AsyncResult) error {
	var arg0 *C.GdkClipboard
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GdkClipboard)(c.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_clipboard_store_finish(arg0, arg1, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// ContentDeserializer: a `GdkContentDeserializer` is used to deserialize
// content received via inter-application data transfers.
//
// The `GdkContentDeserializer` transforms serialized content that is identified
// by a mime type into an object identified by a GType.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own deserialization
// functions, use [func@content_register_deserializer].
//
// Also see [class@Gdk.ContentSerializer].
type ContentDeserializer interface {
	gextras.Objector
	gio.AsyncResult

	// Cancellable gets the cancellable for the current operation.
	//
	// This is the `GCancellable` that was passed to
	// [func@content_deserialize_async].
	Cancellable() gio.Cancellable
	// GType gets the GType to create an instance of.
	GType() externglib.Type
	// InputStream gets the input stream for the current operation.
	//
	// This is the stream that was passed to [func@content_deserialize_async].
	InputStream() gio.InputStream
	// MIMEType gets the mime type to deserialize from.
	MIMEType() string
	// Priority gets the I/O priority for the current operation.
	//
	// This is the priority that was passed to [funccontent_deserialize_async].
	Priority() int
	// TaskData gets the data that was associated with the current operation.
	//
	// See [method@Gdk.ContentDeserializer.set_task_data].
	TaskData() interface{}
	// UserData gets the user data that was passed when the deserializer was
	// registered.
	UserData() interface{}
	// Value gets the `GValue` to store the deserialized object in.
	Value() *externglib.Value
	// ReturnError: indicate that the deserialization has ended with an error.
	//
	// This function consumes @error.
	ReturnError(error *glib.Error)
	// ReturnSuccess: indicate that the deserialization has been successfully
	// completed.
	ReturnSuccess()
}

// contentDeserializer implements the ContentDeserializer interface.
type contentDeserializer struct {
	gextras.Objector
	gio.AsyncResult
}

var _ ContentDeserializer = (*contentDeserializer)(nil)

// WrapContentDeserializer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContentDeserializer(obj *externglib.Object) ContentDeserializer {
	return ContentDeserializer{
		Objector:        obj,
		gio.AsyncResult: gio.WrapAsyncResult(obj),
	}
}

func marshalContentDeserializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContentDeserializer(obj), nil
}

// Cancellable gets the cancellable for the current operation.
//
// This is the `GCancellable` that was passed to
// [func@content_deserialize_async].
func (d contentDeserializer) Cancellable() gio.Cancellable {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_cancellable(arg0)

	var ret0 gio.Cancellable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.Cancellable)

	return ret0
}

// GType gets the GType to create an instance of.
func (d contentDeserializer) GType() externglib.Type {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_gtype(arg0)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// InputStream gets the input stream for the current operation.
//
// This is the stream that was passed to [func@content_deserialize_async].
func (d contentDeserializer) InputStream() gio.InputStream {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_input_stream(arg0)

	var ret0 gio.InputStream

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.InputStream)

	return ret0
}

// MIMEType gets the mime type to deserialize from.
func (d contentDeserializer) MIMEType() string {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_mime_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Priority gets the I/O priority for the current operation.
//
// This is the priority that was passed to [funccontent_deserialize_async].
func (d contentDeserializer) Priority() int {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TaskData gets the data that was associated with the current operation.
//
// See [method@Gdk.ContentDeserializer.set_task_data].
func (d contentDeserializer) TaskData() interface{} {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_task_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// UserData gets the user data that was passed when the deserializer was
// registered.
func (d contentDeserializer) UserData() interface{} {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Value gets the `GValue` to store the deserialized object in.
func (d contentDeserializer) Value() *externglib.Value {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	ret := C.gdk_content_deserializer_get_value(arg0)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(ret))

	return ret0
}

// ReturnError: indicate that the deserialization has ended with an error.
//
// This function consumes @error.
func (d contentDeserializer) ReturnError(error *glib.Error) {
	var arg0 *C.GdkContentDeserializer
	var arg1 *C.GError

	arg0 = (*C.GdkContentDeserializer)(d.Native())
	arg1 = (*C.GError)(error.Native())

	C.gdk_content_deserializer_return_error(arg0, arg1)
}

// ReturnSuccess: indicate that the deserialization has been successfully
// completed.
func (d contentDeserializer) ReturnSuccess() {
	var arg0 *C.GdkContentDeserializer

	arg0 = (*C.GdkContentDeserializer)(d.Native())

	C.gdk_content_deserializer_return_success(arg0)
}

// ContentSerializer: a `GdkContentSerializer` is used to serialize content for
// inter-application data transfers.
//
// The `GdkContentSerializer` transforms an object that is identified by a GType
// into a serialized form (i.e. a byte stream) that is identified by a mime
// type.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own serialization
// functions, use [func@content_register_serializer].
//
// Also see [class@Gdk.ContentDeserializer].
type ContentSerializer interface {
	gextras.Objector
	gio.AsyncResult

	// Cancellable gets the cancellable for the current operation.
	//
	// This is the `GCancellable` that was passed to [content_serialize_async].
	Cancellable() gio.Cancellable
	// GType gets the `GType` to of the object to serialize.
	GType() externglib.Type
	// MIMEType gets the mime type to serialize to.
	MIMEType() string
	// OutputStream gets the output stream for the current operation.
	//
	// This is the stream that was passed to [func@content_serialize_async].
	OutputStream() gio.OutputStream
	// Priority gets the I/O priority for the current operation.
	//
	// This is the priority that was passed to [func@content_serialize_async].
	Priority() int
	// TaskData gets the data that was associated with the current operation.
	//
	// See [method@Gdk.ContentSerializer.set_task_data].
	TaskData() interface{}
	// UserData gets the user data that was passed when the serializer was
	// registered.
	UserData() interface{}
	// Value gets the `GValue` to read the object to serialize from.
	Value() *externglib.Value
	// ReturnError: indicate that the serialization has ended with an error.
	//
	// This function consumes @error.
	ReturnError(error *glib.Error)
	// ReturnSuccess: indicate that the serialization has been successfully
	// completed.
	ReturnSuccess()
}

// contentSerializer implements the ContentSerializer interface.
type contentSerializer struct {
	gextras.Objector
	gio.AsyncResult
}

var _ ContentSerializer = (*contentSerializer)(nil)

// WrapContentSerializer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContentSerializer(obj *externglib.Object) ContentSerializer {
	return ContentSerializer{
		Objector:        obj,
		gio.AsyncResult: gio.WrapAsyncResult(obj),
	}
}

func marshalContentSerializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContentSerializer(obj), nil
}

// Cancellable gets the cancellable for the current operation.
//
// This is the `GCancellable` that was passed to [content_serialize_async].
func (s contentSerializer) Cancellable() gio.Cancellable {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_cancellable(arg0)

	var ret0 gio.Cancellable

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.Cancellable)

	return ret0
}

// GType gets the `GType` to of the object to serialize.
func (s contentSerializer) GType() externglib.Type {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_gtype(arg0)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// MIMEType gets the mime type to serialize to.
func (s contentSerializer) MIMEType() string {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_mime_type(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// OutputStream gets the output stream for the current operation.
//
// This is the stream that was passed to [func@content_serialize_async].
func (s contentSerializer) OutputStream() gio.OutputStream {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_output_stream(arg0)

	var ret0 gio.OutputStream

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.OutputStream)

	return ret0
}

// Priority gets the I/O priority for the current operation.
//
// This is the priority that was passed to [func@content_serialize_async].
func (s contentSerializer) Priority() int {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_priority(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TaskData gets the data that was associated with the current operation.
//
// See [method@Gdk.ContentSerializer.set_task_data].
func (s contentSerializer) TaskData() interface{} {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_task_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// UserData gets the user data that was passed when the serializer was
// registered.
func (s contentSerializer) UserData() interface{} {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_user_data(arg0)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// Value gets the `GValue` to read the object to serialize from.
func (s contentSerializer) Value() *externglib.Value {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	ret := C.gdk_content_serializer_get_value(arg0)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(ret))

	return ret0
}

// ReturnError: indicate that the serialization has ended with an error.
//
// This function consumes @error.
func (s contentSerializer) ReturnError(error *glib.Error) {
	var arg0 *C.GdkContentSerializer
	var arg1 *C.GError

	arg0 = (*C.GdkContentSerializer)(s.Native())
	arg1 = (*C.GError)(error.Native())

	C.gdk_content_serializer_return_error(arg0, arg1)
}

// ReturnSuccess: indicate that the serialization has been successfully
// completed.
func (s contentSerializer) ReturnSuccess() {
	var arg0 *C.GdkContentSerializer

	arg0 = (*C.GdkContentSerializer)(s.Native())

	C.gdk_content_serializer_return_success(arg0)
}

// Cursor: `GdkCursor` is used to create and destroy cursors.
//
// Cursors are immutable objects, so once you created them, there is no way to
// modify them later. You should create a new cursor when you want to change
// something about it.
//
// Cursors by themselves are not very interesting: they must be bound to a
// window for users to see them. This is done with
// [method@Gdk.Surface.set_cursor] or [method@Gdk.Surface.set_device_cursor].
// Applications will typically use higher-level GTK functions such as
// [method@Gtk.Widget.set_cursor]` instead.
//
// Cursors are not bound to a given [class@Gdk.Display], so they can be shared.
// However, the appearance of cursors may vary when used on different platforms.
//
//
// Named and texture cursors
//
// There are multiple ways to create cursors. The platform's own cursors can be
// created with [ctor@Gdk.Cursor.new_from_name]. That function lists the
// commonly available names that are shared with the CSS specification. Other
// names may be available, depending on the platform in use. On some platforms,
// what images are used for named cursors may be influenced by the cursor theme.
//
// Another option to create a cursor is to use
// [ctor@Gdk.Cursor.new_from_texture] and provide an image to use for the
// cursor.
//
// To ease work with unsupported cursors, a fallback cursor can be provided. If
// a [class@Gdk.Surface] cannot use a cursor because of the reasons mentioned
// above, it will try the fallback cursor. Fallback cursors can themselves have
// fallback cursors again, so it is possible to provide a chain of progressively
// easier to support cursors. If none of the provided cursors can be supported,
// the default cursor will be the ultimate fallback.
type Cursor interface {
	gextras.Objector

	// Fallback returns the fallback for this @cursor.
	//
	// The fallback will be used if this cursor is not available on a given
	// `GdkDisplay`. For named cursors, this can happen when using nonstandard
	// names or when using an incomplete cursor theme. For textured cursors,
	// this can happen when the texture is too large or when the `GdkDisplay` it
	// is used on does not support textured cursors.
	Fallback() Cursor
	// HotspotX returns the horizontal offset of the hotspot.
	//
	// The hotspot indicates the pixel that will be directly above the cursor.
	//
	// Note that named cursors may have a nonzero hotspot, but this function
	// will only return the hotspot position for cursors created with
	// [ctor@Gdk.Cursor.new_from_texture].
	HotspotX() int
	// HotspotY returns the vertical offset of the hotspot.
	//
	// The hotspot indicates the pixel that will be directly above the cursor.
	//
	// Note that named cursors may have a nonzero hotspot, but this function
	// will only return the hotspot position for cursors created with
	// [ctor@Gdk.Cursor.new_from_texture].
	HotspotY() int
	// Name returns the name of the cursor.
	//
	// If the cursor is not a named cursor, nil will be returned.
	Name() string
	// Texture returns the texture for the cursor.
	//
	// If the cursor is a named cursor, nil will be returned.
	Texture() Texture
}

// cursor implements the Cursor interface.
type cursor struct {
	gextras.Objector
}

var _ Cursor = (*cursor)(nil)

// WrapCursor wraps a GObject to the right type. It is
// primarily used internally.
func WrapCursor(obj *externglib.Object) Cursor {
	return Cursor{
		Objector: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCursor(obj), nil
}

// NewCursorFromName constructs a class Cursor.
func NewCursorFromName(name string, fallback Cursor) Cursor {
	var arg1 *C.char
	var arg2 *C.GdkCursor

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GdkCursor)(fallback.Native())

	ret := C.gdk_cursor_new_from_name(arg1, arg2)

	var ret0 Cursor

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Cursor)

	return ret0
}

// NewCursorFromTexture constructs a class Cursor.
func NewCursorFromTexture(texture Texture, hotspotX int, hotspotY int, fallback Cursor) Cursor {
	var arg1 *C.GdkTexture
	var arg2 C.int
	var arg3 C.int
	var arg4 *C.GdkCursor

	arg1 = (*C.GdkTexture)(texture.Native())
	arg2 = C.int(hotspotX)
	arg3 = C.int(hotspotY)
	arg4 = (*C.GdkCursor)(fallback.Native())

	ret := C.gdk_cursor_new_from_texture(arg1, arg2, arg3, arg4)

	var ret0 Cursor

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(Cursor)

	return ret0
}

// Fallback returns the fallback for this @cursor.
//
// The fallback will be used if this cursor is not available on a given
// `GdkDisplay`. For named cursors, this can happen when using nonstandard
// names or when using an incomplete cursor theme. For textured cursors,
// this can happen when the texture is too large or when the `GdkDisplay` it
// is used on does not support textured cursors.
func (c cursor) Fallback() Cursor {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(c.Native())

	ret := C.gdk_cursor_get_fallback(arg0)

	var ret0 Cursor

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Cursor)

	return ret0
}

// HotspotX returns the horizontal offset of the hotspot.
//
// The hotspot indicates the pixel that will be directly above the cursor.
//
// Note that named cursors may have a nonzero hotspot, but this function
// will only return the hotspot position for cursors created with
// [ctor@Gdk.Cursor.new_from_texture].
func (c cursor) HotspotX() int {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(c.Native())

	ret := C.gdk_cursor_get_hotspot_x(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// HotspotY returns the vertical offset of the hotspot.
//
// The hotspot indicates the pixel that will be directly above the cursor.
//
// Note that named cursors may have a nonzero hotspot, but this function
// will only return the hotspot position for cursors created with
// [ctor@Gdk.Cursor.new_from_texture].
func (c cursor) HotspotY() int {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(c.Native())

	ret := C.gdk_cursor_get_hotspot_y(arg0)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// Name returns the name of the cursor.
//
// If the cursor is not a named cursor, nil will be returned.
func (c cursor) Name() string {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(c.Native())

	ret := C.gdk_cursor_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Texture returns the texture for the cursor.
//
// If the cursor is a named cursor, nil will be returned.
func (c cursor) Texture() Texture {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(c.Native())

	ret := C.gdk_cursor_get_texture(arg0)

	var ret0 Texture

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Texture)

	return ret0
}

// Device: the `GdkDevice` object represents an input device, such as a
// keyboard, a mouse, or a touchpad.
//
// See the [class@Gdk.Seat] documentation for more information about the various
// kinds of devices, and their relationships.
type Device interface {
	gextras.Objector

	// CapsLockState retrieves whether the Caps Lock modifier of the keyboard is
	// locked.
	//
	// This is only relevant for keyboard devices.
	CapsLockState() bool
	// DeviceTool retrieves the current tool for @device.
	DeviceTool() DeviceTool
	// Direction returns the direction of effective layout of the keyboard.
	//
	// This is only relevant for keyboard devices.
	//
	// The direction of a layout is the direction of the majority of its
	// symbols. See [func@Pango.unichar_direction].
	Direction() pango.Direction
	// Display returns the `GdkDisplay` to which @device pertains.
	Display() Display
	// HasCursor determines whether the pointer follows device motion.
	//
	// This is not meaningful for keyboard devices, which don't have a pointer.
	HasCursor() bool
	// ModifierState retrieves the current modifier state of the keyboard.
	//
	// This is only relevant for keyboard devices.
	ModifierState() ModifierType
	// Name: the name of the device, suitable for showing in a user interface.
	Name() string
	// NumLockState retrieves whether the Num Lock modifier of the keyboard is
	// locked.
	//
	// This is only relevant for keyboard devices.
	NumLockState() bool
	// NumTouches retrieves the number of touch points associated to @device.
	NumTouches() uint
	// ProductID returns the product ID of this device.
	//
	// This ID is retrieved from the device, and does not change. See
	// [method@Gdk.Device.get_vendor_id] for more information.
	ProductID() string
	// ScrollLockState retrieves whether the Scroll Lock modifier of the
	// keyboard is locked.
	//
	// This is only relevant for keyboard devices.
	ScrollLockState() bool
	// Seat returns the `GdkSeat` the device belongs to.
	Seat() Seat
	// Source determines the type of the device.
	Source() InputSource
	// SurfaceAtPosition obtains the surface underneath @device, returning the
	// location of the device in @win_x and @win_y
	//
	// Returns nil if the surface tree under @device is not known to GDK (for
	// example, belongs to another application).
	SurfaceAtPosition() (winX float64, winY float64, surface Surface)
	// Timestamp returns the timestamp of the last activity for this device.
	//
	// In practice, this means the timestamp of the last event that was received
	// from the OS for this device. (GTK may occasionally produce events for a
	// device that are not received from the OS, and will not update the
	// timestamp).
	Timestamp() uint32
	// VendorID returns the vendor ID of this device.
	//
	// This ID is retrieved from the device, and does not change.
	//
	// This function, together with [method@Gdk.Device.get_product_id], can be
	// used to eg. compose `GSettings` paths to store settings for this device.
	//
	// â€œ`c static GSettings * get_device_settings (GdkDevice *device) { const
	// char *vendor, *product; GSettings *settings; GdkDevice *device; char
	// *path;
	//
	//      vendor = gdk_device_get_vendor_id (device);
	//      product = gdk_device_get_product_id (device);
	//
	//      path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
	//      settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
	//      g_free (path);
	//
	//      return settings;
	//    }
	//
	// â€œ`
	VendorID() string
	// HasBidiLayouts determines if layouts for both right-to-left and
	// left-to-right languages are in use on the keyboard.
	//
	// This is only relevant for keyboard devices.
	HasBidiLayouts() bool
}

// device implements the Device interface.
type device struct {
	gextras.Objector
}

var _ Device = (*device)(nil)

// WrapDevice wraps a GObject to the right type. It is
// primarily used internally.
func WrapDevice(obj *externglib.Object) Device {
	return Device{
		Objector: obj,
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDevice(obj), nil
}

// CapsLockState retrieves whether the Caps Lock modifier of the keyboard is
// locked.
//
// This is only relevant for keyboard devices.
func (d device) CapsLockState() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_caps_lock_state(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// DeviceTool retrieves the current tool for @device.
func (d device) DeviceTool() DeviceTool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_device_tool(arg0)

	var ret0 DeviceTool

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(DeviceTool)

	return ret0
}

// Direction returns the direction of effective layout of the keyboard.
//
// This is only relevant for keyboard devices.
//
// The direction of a layout is the direction of the majority of its
// symbols. See [func@Pango.unichar_direction].
func (d device) Direction() pango.Direction {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_direction(arg0)

	var ret0 pango.Direction

	ret0 = pango.Direction(ret)

	return ret0
}

// Display returns the `GdkDisplay` to which @device pertains.
func (d device) Display() Display {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// HasCursor determines whether the pointer follows device motion.
//
// This is not meaningful for keyboard devices, which don't have a pointer.
func (d device) HasCursor() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_has_cursor(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ModifierState retrieves the current modifier state of the keyboard.
//
// This is only relevant for keyboard devices.
func (d device) ModifierState() ModifierType {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_modifier_state(arg0)

	var ret0 ModifierType

	ret0 = ModifierType(ret)

	return ret0
}

// Name: the name of the device, suitable for showing in a user interface.
func (d device) Name() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// NumLockState retrieves whether the Num Lock modifier of the keyboard is
// locked.
//
// This is only relevant for keyboard devices.
func (d device) NumLockState() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_num_lock_state(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// NumTouches retrieves the number of touch points associated to @device.
func (d device) NumTouches() uint {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_num_touches(arg0)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// ProductID returns the product ID of this device.
//
// This ID is retrieved from the device, and does not change. See
// [method@Gdk.Device.get_vendor_id] for more information.
func (d device) ProductID() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_product_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// ScrollLockState retrieves whether the Scroll Lock modifier of the
// keyboard is locked.
//
// This is only relevant for keyboard devices.
func (d device) ScrollLockState() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_scroll_lock_state(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Seat returns the `GdkSeat` the device belongs to.
func (d device) Seat() Seat {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_seat(arg0)

	var ret0 Seat

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Seat)

	return ret0
}

// Source determines the type of the device.
func (d device) Source() InputSource {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_source(arg0)

	var ret0 InputSource

	ret0 = InputSource(ret)

	return ret0
}

// SurfaceAtPosition obtains the surface underneath @device, returning the
// location of the device in @win_x and @win_y
//
// Returns nil if the surface tree under @device is not known to GDK (for
// example, belongs to another application).
func (d device) SurfaceAtPosition() (winX float64, winY float64, surface Surface) {
	var arg0 *C.GdkDevice
	var arg1 *C.double // out
	var arg2 *C.double // out

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_surface_at_position(arg0, &arg1, &arg2)

	var ret0 float64
	var ret1 float64
	var ret2 Surface

	ret0 = float64(arg1)

	ret1 = float64(arg2)

	ret2 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0, ret1, ret2
}

// Timestamp returns the timestamp of the last activity for this device.
//
// In practice, this means the timestamp of the last event that was received
// from the OS for this device. (GTK may occasionally produce events for a
// device that are not received from the OS, and will not update the
// timestamp).
func (d device) Timestamp() uint32 {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_timestamp(arg0)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// VendorID returns the vendor ID of this device.
//
// This ID is retrieved from the device, and does not change.
//
// This function, together with [method@Gdk.Device.get_product_id], can be
// used to eg. compose `GSettings` paths to store settings for this device.
//
// â€œ`c static GSettings * get_device_settings (GdkDevice *device) { const
// char *vendor, *product; GSettings *settings; GdkDevice *device; char
// *path;
//
//      vendor = gdk_device_get_vendor_id (device);
//      product = gdk_device_get_product_id (device);
//
//      path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
//      settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
//      g_free (path);
//
//      return settings;
//    }
//
// â€œ`
func (d device) VendorID() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_get_vendor_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// HasBidiLayouts determines if layouts for both right-to-left and
// left-to-right languages are in use on the keyboard.
//
// This is only relevant for keyboard devices.
func (d device) HasBidiLayouts() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(d.Native())

	ret := C.gdk_device_has_bidi_layouts(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// DeviceTool: a physical tool associated to a `GdkDevice`.
type DeviceTool interface {
	gextras.Objector

	// Axes gets the axes of the tool.
	Axes() AxisFlags
	// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
	//
	// When non-zero, the identificator is unique for the given tool model,
	// meaning that two identical tools will share the same @hardware_id, but
	// will have different serial numbers (see
	// [method@Gdk.DeviceTool.get_serial]).
	//
	// This is a more concrete (and device specific) method to identify a
	// `GdkDeviceTool` than [method@Gdk.DeviceTool.get_tool_type], as a tablet
	// may support multiple devices with the same `GdkDeviceToolType`, but
	// different hardware identificators.
	HardwareID() uint64
	// Serial gets the serial number of this tool.
	//
	// This value can be used to identify a physical tool (eg. a tablet pen)
	// across program executions.
	Serial() uint64
	// ToolType gets the `GdkDeviceToolType` of the tool.
	ToolType() DeviceToolType
}

// deviceTool implements the DeviceTool interface.
type deviceTool struct {
	gextras.Objector
}

var _ DeviceTool = (*deviceTool)(nil)

// WrapDeviceTool wraps a GObject to the right type. It is
// primarily used internally.
func WrapDeviceTool(obj *externglib.Object) DeviceTool {
	return DeviceTool{
		Objector: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDeviceTool(obj), nil
}

// Axes gets the axes of the tool.
func (t deviceTool) Axes() AxisFlags {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(t.Native())

	ret := C.gdk_device_tool_get_axes(arg0)

	var ret0 AxisFlags

	ret0 = AxisFlags(ret)

	return ret0
}

// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
//
// When non-zero, the identificator is unique for the given tool model,
// meaning that two identical tools will share the same @hardware_id, but
// will have different serial numbers (see
// [method@Gdk.DeviceTool.get_serial]).
//
// This is a more concrete (and device specific) method to identify a
// `GdkDeviceTool` than [method@Gdk.DeviceTool.get_tool_type], as a tablet
// may support multiple devices with the same `GdkDeviceToolType`, but
// different hardware identificators.
func (t deviceTool) HardwareID() uint64 {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(t.Native())

	ret := C.gdk_device_tool_get_hardware_id(arg0)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// Serial gets the serial number of this tool.
//
// This value can be used to identify a physical tool (eg. a tablet pen)
// across program executions.
func (t deviceTool) Serial() uint64 {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(t.Native())

	ret := C.gdk_device_tool_get_serial(arg0)

	var ret0 uint64

	ret0 = uint64(ret)

	return ret0
}

// ToolType gets the `GdkDeviceToolType` of the tool.
func (t deviceTool) ToolType() DeviceToolType {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(t.Native())

	ret := C.gdk_device_tool_get_tool_type(arg0)

	var ret0 DeviceToolType

	ret0 = DeviceToolType(ret)

	return ret0
}

// Display: `GdkDisplay` objects are the GDK representation of a workstation.
//
// Their purpose are two-fold:
//
// - To manage and provide information about input devices (pointers, keyboards,
// etc) - To manage and provide information about output devices (monitors,
// projectors, etc)
//
// Most of the input device handling has been factored out into separate
// [class@Gdk.Seat] objects. Every display has a one or more seats, which can be
// accessed with [method@Gdk.Display.get_default_seat] and
// [method@Gdk.Display.list_seats].
//
// Output devices are represented by [class@Gdk.Monitor] objects, which can be
// accessed with [method@Gdk.Display.get_monitor_at_surface] and similar APIs.
type Display interface {
	gextras.Objector

	// Beep emits a short beep on @display
	Beep()
	// Close closes the connection to the windowing system for the given
	// display.
	//
	// This cleans up associated resources.
	Close()
	// DeviceIsGrabbed returns true if there is an ongoing grab on @device for
	// @display.
	DeviceIsGrabbed(device Device) bool
	// Flush flushes any requests queued for the windowing system.
	//
	// This happens automatically when the main loop blocks waiting for new
	// events, but if your application is drawing without returning control to
	// the main loop, you may need to call this function explicitly. A common
	// case where this function needs to be called is when an application is
	// executing drawing commands from a thread other than the thread where the
	// main loop is running.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	Flush()
	// AppLaunchContext returns a `GdkAppLaunchContext` suitable for launching
	// applications on the given display.
	AppLaunchContext() AppLaunchContext
	// Clipboard gets the clipboard used for copy/paste operations.
	Clipboard() Clipboard
	// DefaultSeat returns the default `GdkSeat` for this display.
	//
	// Note that a display may not have a seat. In this case, this function will
	// return nil.
	DefaultSeat() Seat
	// MonitorAtSurface gets the monitor in which the largest area of @surface
	// resides.
	//
	// Returns a monitor close to @surface if it is outside of all monitors.
	MonitorAtSurface(surface Surface) Monitor
	// Monitors gets the list of monitors associated with this display.
	//
	// Subsequent calls to this function will always return the same list for
	// the same display.
	//
	// You can listen to the GListModel::items-changed signal on this list to
	// monitor changes to the monitor of this display.
	Monitors() gio.ListModel
	// Name gets the name of the display.
	Name() string
	// PrimaryClipboard gets the clipboard used for the primary selection.
	//
	// On backends where the primary clipboard is not supported natively, GDK
	// emulates this clipboard locally.
	PrimaryClipboard() Clipboard
	// Setting retrieves a desktop-wide setting such as double-click time for
	// the @display.
	Setting(name string, value *externglib.Value) bool
	// StartupNotificationID gets the startup notification ID for a Wayland
	// display, or nil if no ID has been defined.
	StartupNotificationID() string
	// IsClosed finds out if the display has been closed.
	IsClosed() bool
	// IsComposited returns whether surfaces can reasonably be expected to have
	// their alpha channel drawn correctly on the screen.
	//
	// Check [method@Gdk.Display.is_rgba] for whether the display supports an
	// alpha channel.
	//
	// On X11 this function returns whether a compositing manager is compositing
	// on @display.
	//
	// On modern displays, this value is always true.
	IsComposited() bool
	// IsRGBA returns whether surfaces on this @display are created with an
	// alpha channel.
	//
	// Even if a true is returned, it is possible that the surfaceâ€™s alpha
	// channel wonâ€™t be honored when displaying the surface on the screen: in
	// particular, for X an appropriate windowing manager and compositing
	// manager must be running to provide appropriate display. Use
	// [method@Gdk.Display.is_composited] to check if that is the case.
	//
	// On modern displays, this value is always true.
	IsRGBA() bool
	// ListSeats returns the list of seats known to @display.
	ListSeats() *glib.List
	// MapKeycode returns the keyvals bound to @keycode.
	//
	// The Nth `GdkKeymapKey` in @keys is bound to the Nth keyval in @keyvals.
	//
	// When a keycode is pressed by the user, the keyval from this list of
	// entries is selected by considering the effective keyboard group and
	// level.
	//
	// Free the returned arrays with g_free().
	MapKeycode(keycode uint) (keys []*KeymapKey, keyvals []uint, nEntries int, ok bool)
	// MapKeyval obtains a list of keycode/group/level combinations that will
	// generate @keyval.
	//
	// Groups and levels are two kinds of keyboard mode; in general, the level
	// determines whether the top or bottom symbol on a key is used, and the
	// group determines whether the left or right symbol is used.
	//
	// On US keyboards, the shift key changes the keyboard level, and there are
	// no groups. A group switch key might convert a keyboard between Hebrew to
	// English modes, for example.
	//
	// `GdkEventKey` contains a group field that indicates the active keyboard
	// group. The level is computed from the modifier mask.
	//
	// The returned array should be freed with g_free().
	MapKeyval(keyval uint) (keys []*KeymapKey, nKeys int, ok bool)
	// NotifyStartupComplete indicates to the GUI environment that the
	// application has finished loading, using a given identifier.
	//
	// GTK will call this function automatically for [class@Gtk.Window] with
	// custom startup-notification identifier unless
	// [method@Gtk.Window.set_auto_startup_notification] is called to disable
	// that feature.
	NotifyStartupComplete(startupID string)
	// PutEvent appends the given event onto the front of the event queue for
	// @display.
	//
	// This function is only useful in very special situations and should not be
	// used by applications.
	PutEvent(event Event)
	// SupportsInputShapes returns true if the display supports input shapes.
	//
	// This means that [method@Gdk.Surface.set_input_region] can be used to
	// modify the input shape of surfaces on @display.
	//
	// On modern displays, this value is always true.
	SupportsInputShapes() bool
	// Sync flushes any requests queued for the windowing system and waits until
	// all requests have been handled.
	//
	// This is often used for making sure that the display is synchronized with
	// the current state of the program. Calling [method@Gdk.Display.sync]
	// before [method@GdkX11.Display.error_trap_pop] makes sure that any errors
	// generated from earlier requests are handled before the error trap is
	// removed.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	Sync()
	// TranslateKey translates the contents of a `GdkEventKey` into a keyval,
	// effective group, and level.
	//
	// Modifiers that affected the translation and are thus unavailable for
	// application use are returned in @consumed_modifiers.
	//
	// The @effective_group is the group that was actually used for the
	// translation; some keys such as Enter are not affected by the active
	// keyboard group. The @level is derived from @state.
	//
	// @consumed_modifiers gives modifiers that should be masked out from @state
	// when comparing this key press to a keyboard shortcut. For instance, on a
	// US keyboard, the `plus` symbol is shifted, so when comparing a key press
	// to a `<Control>plus` accelerator `<Shift>` should be masked out.
	//
	// This function should rarely be needed, since `GdkEventKey` already
	// contains the translated keyval. It is exported for the benefit of
	// virtualized test environments.
	TranslateKey(keycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumed ModifierType, ok bool)
}

// display implements the Display interface.
type display struct {
	gextras.Objector
}

var _ Display = (*display)(nil)

// WrapDisplay wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplay(obj *externglib.Object) Display {
	return Display{
		Objector: obj,
	}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplay(obj), nil
}

// Beep emits a short beep on @display
func (d display) Beep() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	C.gdk_display_beep(arg0)
}

// Close closes the connection to the windowing system for the given
// display.
//
// This cleans up associated resources.
func (d display) Close() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	C.gdk_display_close(arg0)
}

// DeviceIsGrabbed returns true if there is an ongoing grab on @device for
// @display.
func (d display) DeviceIsGrabbed(device Device) bool {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = (*C.GdkDevice)(device.Native())

	ret := C.gdk_display_device_is_grabbed(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Flush flushes any requests queued for the windowing system.
//
// This happens automatically when the main loop blocks waiting for new
// events, but if your application is drawing without returning control to
// the main loop, you may need to call this function explicitly. A common
// case where this function needs to be called is when an application is
// executing drawing commands from a thread other than the thread where the
// main loop is running.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (d display) Flush() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	C.gdk_display_flush(arg0)
}

// AppLaunchContext returns a `GdkAppLaunchContext` suitable for launching
// applications on the given display.
func (d display) AppLaunchContext() AppLaunchContext {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_app_launch_context(arg0)

	var ret0 AppLaunchContext

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(AppLaunchContext)

	return ret0
}

// Clipboard gets the clipboard used for copy/paste operations.
func (d display) Clipboard() Clipboard {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_clipboard(arg0)

	var ret0 Clipboard

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Clipboard)

	return ret0
}

// DefaultSeat returns the default `GdkSeat` for this display.
//
// Note that a display may not have a seat. In this case, this function will
// return nil.
func (d display) DefaultSeat() Seat {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_default_seat(arg0)

	var ret0 Seat

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Seat)

	return ret0
}

// MonitorAtSurface gets the monitor in which the largest area of @surface
// resides.
//
// Returns a monitor close to @surface if it is outside of all monitors.
func (d display) MonitorAtSurface(surface Surface) Monitor {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkSurface

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = (*C.GdkSurface)(surface.Native())

	ret := C.gdk_display_get_monitor_at_surface(arg0, arg1)

	var ret0 Monitor

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Monitor)

	return ret0
}

// Monitors gets the list of monitors associated with this display.
//
// Subsequent calls to this function will always return the same list for
// the same display.
//
// You can listen to the GListModel::items-changed signal on this list to
// monitor changes to the monitor of this display.
func (s display) Monitors() gio.ListModel {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(s.Native())

	ret := C.gdk_display_get_monitors(arg0)

	var ret0 gio.ListModel

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gio.ListModel)

	return ret0
}

// Name gets the name of the display.
func (d display) Name() string {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_name(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// PrimaryClipboard gets the clipboard used for the primary selection.
//
// On backends where the primary clipboard is not supported natively, GDK
// emulates this clipboard locally.
func (d display) PrimaryClipboard() Clipboard {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_primary_clipboard(arg0)

	var ret0 Clipboard

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Clipboard)

	return ret0
}

// Setting retrieves a desktop-wide setting such as double-click time for
// the @display.
func (d display) Setting(name string, value *externglib.Value) bool {
	var arg0 *C.GdkDisplay
	var arg1 *C.char
	var arg2 *C.GValue

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GValue)(value.GValue)

	ret := C.gdk_display_get_setting(arg0, arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// StartupNotificationID gets the startup notification ID for a Wayland
// display, or nil if no ID has been defined.
func (d display) StartupNotificationID() string {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_get_startup_notification_id(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// IsClosed finds out if the display has been closed.
func (d display) IsClosed() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_is_closed(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsComposited returns whether surfaces can reasonably be expected to have
// their alpha channel drawn correctly on the screen.
//
// Check [method@Gdk.Display.is_rgba] for whether the display supports an
// alpha channel.
//
// On X11 this function returns whether a compositing manager is compositing
// on @display.
//
// On modern displays, this value is always true.
func (d display) IsComposited() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_is_composited(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// IsRGBA returns whether surfaces on this @display are created with an
// alpha channel.
//
// Even if a true is returned, it is possible that the surfaceâ€™s alpha
// channel wonâ€™t be honored when displaying the surface on the screen: in
// particular, for X an appropriate windowing manager and compositing
// manager must be running to provide appropriate display. Use
// [method@Gdk.Display.is_composited] to check if that is the case.
//
// On modern displays, this value is always true.
func (d display) IsRGBA() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_is_rgba(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// ListSeats returns the list of seats known to @display.
func (d display) ListSeats() *glib.List {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_list_seats(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// MapKeycode returns the keyvals bound to @keycode.
//
// The Nth `GdkKeymapKey` in @keys is bound to the Nth keyval in @keyvals.
//
// When a keycode is pressed by the user, the keyval from this list of
// entries is selected by considering the effective keyboard group and
// level.
//
// Free the returned arrays with g_free().
func (d display) MapKeycode(keycode uint) (keys []*KeymapKey, keyvals []uint, nEntries int, ok bool) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint
	var arg2 **C.GdkKeymapKey // out
	var arg3 **C.guint        // out
	var arg4 *C.int           // out

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = C.guint(keycode)

	ret := C.gdk_display_map_keycode(arg0, arg1, &arg2, &arg3, &arg4)

	var ret0 []*KeymapKey
	var ret1 []uint
	var ret2 int
	var ret3 bool

	{
		ret0 = make([]*KeymapKey, arg4)
		for i := 0; i < uintptr(arg4); i++ {
			src := (*C.GdkKeymapKey)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = WrapKeymapKey(unsafe.Pointer(src))
				runtime.SetFinalizer(ret0[i], func(v *KeymapKey) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg3))
		sliceHeader.Len = arg4
		sliceHeader.Cap = arg4
		runtime.SetFinalizer(&arg3, func() {
			C.free(unsafe.Pointer(arg3))
		})
		defer runtime.KeepAlive(arg3)
	}

	ret2 = int(arg4)

	ret3 = C.bool(ret) != C.false

	return ret0, ret1, ret2, ret3
}

// MapKeyval obtains a list of keycode/group/level combinations that will
// generate @keyval.
//
// Groups and levels are two kinds of keyboard mode; in general, the level
// determines whether the top or bottom symbol on a key is used, and the
// group determines whether the left or right symbol is used.
//
// On US keyboards, the shift key changes the keyboard level, and there are
// no groups. A group switch key might convert a keyboard between Hebrew to
// English modes, for example.
//
// `GdkEventKey` contains a group field that indicates the active keyboard
// group. The level is computed from the modifier mask.
//
// The returned array should be freed with g_free().
func (d display) MapKeyval(keyval uint) (keys []*KeymapKey, nKeys int, ok bool) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint
	var arg2 **C.GdkKeymapKey // out
	var arg3 *C.int           // out

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = C.guint(keyval)

	ret := C.gdk_display_map_keyval(arg0, arg1, &arg2, &arg3)

	var ret0 []*KeymapKey
	var ret1 int
	var ret2 bool

	{
		ret0 = make([]*KeymapKey, arg3)
		for i := 0; i < uintptr(arg3); i++ {
			src := (*C.GdkKeymapKey)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			{
				ret0[i] = WrapKeymapKey(unsafe.Pointer(src))
				runtime.SetFinalizer(ret0[i], func(v *KeymapKey) {
					C.free(unsafe.Pointer(v.Native()))
				})
			}
		}
	}

	ret1 = int(arg3)

	ret2 = C.bool(ret) != C.false

	return ret0, ret1, ret2
}

// NotifyStartupComplete indicates to the GUI environment that the
// application has finished loading, using a given identifier.
//
// GTK will call this function automatically for [class@Gtk.Window] with
// custom startup-notification identifier unless
// [method@Gtk.Window.set_auto_startup_notification] is called to disable
// that feature.
func (d display) NotifyStartupComplete(startupID string) {
	var arg0 *C.GdkDisplay
	var arg1 *C.char

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_display_notify_startup_complete(arg0, arg1)
}

// PutEvent appends the given event onto the front of the event queue for
// @display.
//
// This function is only useful in very special situations and should not be
// used by applications.
func (d display) PutEvent(event Event) {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkEvent

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = (*C.GdkEvent)(event.Native())

	C.gdk_display_put_event(arg0, arg1)
}

// SupportsInputShapes returns true if the display supports input shapes.
//
// This means that [method@Gdk.Surface.set_input_region] can be used to
// modify the input shape of surfaces on @display.
//
// On modern displays, this value is always true.
func (d display) SupportsInputShapes() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	ret := C.gdk_display_supports_input_shapes(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Sync flushes any requests queued for the windowing system and waits until
// all requests have been handled.
//
// This is often used for making sure that the display is synchronized with
// the current state of the program. Calling [method@Gdk.Display.sync]
// before [method@GdkX11.Display.error_trap_pop] makes sure that any errors
// generated from earlier requests are handled before the error trap is
// removed.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (d display) Sync() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(d.Native())

	C.gdk_display_sync(arg0)
}

// TranslateKey translates the contents of a `GdkEventKey` into a keyval,
// effective group, and level.
//
// Modifiers that affected the translation and are thus unavailable for
// application use are returned in @consumed_modifiers.
//
// The @effective_group is the group that was actually used for the
// translation; some keys such as Enter are not affected by the active
// keyboard group. The @level is derived from @state.
//
// @consumed_modifiers gives modifiers that should be masked out from @state
// when comparing this key press to a keyboard shortcut. For instance, on a
// US keyboard, the `plus` symbol is shifted, so when comparing a key press
// to a `<Control>plus` accelerator `<Shift>` should be masked out.
//
// This function should rarely be needed, since `GdkEventKey` already
// contains the translated keyval. It is exported for the benefit of
// virtualized test environments.
func (d display) TranslateKey(keycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumed ModifierType, ok bool) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint
	var arg2 C.GdkModifierType
	var arg3 C.int
	var arg4 *C.guint           // out
	var arg5 *C.int             // out
	var arg6 *C.int             // out
	var arg7 *C.GdkModifierType // out

	arg0 = (*C.GdkDisplay)(d.Native())
	arg1 = C.guint(keycode)
	arg2 = (C.GdkModifierType)(state)
	arg3 = C.int(group)

	ret := C.gdk_display_translate_key(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6, &arg7)

	var ret0 uint
	var ret1 int
	var ret2 int
	var ret3 *ModifierType
	var ret4 bool

	ret0 = uint(arg4)

	ret1 = int(arg5)

	ret2 = int(arg6)

	ret3 = (*ModifierType)(arg7)

	ret4 = C.bool(ret) != C.false

	return ret0, ret1, ret2, ret3, ret4
}

// DisplayManager: a singleton object that offers notification when displays
// appear or disappear.
//
// You can use [func@Gdk.DisplayManager.get] to obtain the `GdkDisplayManager`
// singleton, but that should be rarely necessary. Typically, initializing GTK
// opens a display that you can work with without ever accessing the
// `GdkDisplayManager`.
//
// The GDK library can be built with support for multiple backends. The
// `GdkDisplayManager` object determines which backend is used at runtime.
//
// In the rare case that you need to influence which of the backends is being
// used, you can use [func@Gdk.set_allowed_backends]. Note that you need to call
// this function before initializing GTK.
//
//
// Backend-specific code
//
// When writing backend-specific code that is supposed to work with multiple GDK
// backends, you have to consider both compile time and runtime. At compile
// time, use the K_WINDOWING_X11, K_WINDOWING_WIN32 macros, etc. to find out
// which backends are present in the GDK library you are building your
// application against. At runtime, use type-check macros like
// GDK_IS_X11_DISPLAY() to find out which backend is in use:
//
// â€œ`c #ifdef GDK_WINDOWING_X11 if (GDK_IS_X11_DISPLAY (display)) { // make
// X11-specific calls here } else #endif #ifdef GDK_WINDOWING_MACOS if
// (GDK_IS_MACOS_DISPLAY (display)) { // make Quartz-specific calls here } else
// #endif g_error ("Unsupported GDK backend"); â€œ`
type DisplayManager interface {
	gextras.Objector

	// DefaultDisplay gets the default `GdkDisplay`.
	DefaultDisplay() Display
	// ListDisplays: list all currently open displays.
	ListDisplays() *glib.SList
	// OpenDisplay opens a display.
	OpenDisplay(name string) Display
	// SetDefaultDisplay sets @display as the default display.
	SetDefaultDisplay(display Display)
}

// displayManager implements the DisplayManager interface.
type displayManager struct {
	gextras.Objector
}

var _ DisplayManager = (*displayManager)(nil)

// WrapDisplayManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplayManager(obj *externglib.Object) DisplayManager {
	return DisplayManager{
		Objector: obj,
	}
}

func marshalDisplayManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplayManager(obj), nil
}

// DefaultDisplay gets the default `GdkDisplay`.
func (m displayManager) DefaultDisplay() Display {
	var arg0 *C.GdkDisplayManager

	arg0 = (*C.GdkDisplayManager)(m.Native())

	ret := C.gdk_display_manager_get_default_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// ListDisplays: list all currently open displays.
func (m displayManager) ListDisplays() *glib.SList {
	var arg0 *C.GdkDisplayManager

	arg0 = (*C.GdkDisplayManager)(m.Native())

	ret := C.gdk_display_manager_list_displays(arg0)

	var ret0 *glib.SList

	{
		ret0 = glib.WrapSList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.SList) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// OpenDisplay opens a display.
func (m displayManager) OpenDisplay(name string) Display {
	var arg0 *C.GdkDisplayManager
	var arg1 *C.char

	arg0 = (*C.GdkDisplayManager)(m.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_display_manager_open_display(arg0, arg1)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// SetDefaultDisplay sets @display as the default display.
func (m displayManager) SetDefaultDisplay(display Display) {
	var arg0 *C.GdkDisplayManager
	var arg1 *C.GdkDisplay

	arg0 = (*C.GdkDisplayManager)(m.Native())
	arg1 = (*C.GdkDisplay)(display.Native())

	C.gdk_display_manager_set_default_display(arg0, arg1)
}

// Drag: the `GdkDrag` object represents the source of an ongoing DND operation.
//
// A `GdkDrag` is created when a drag is started, and stays alive for duration
// of the DND operation. After a drag has been started with
// [func@Gdk.Drag.begin], the caller gets informed about the status of the
// ongoing drag operation with signals on the `GdkDrag` object.
//
// GTK provides a higher level abstraction based on top of these functions, and
// so they are not normally needed in GTK applications. See the "Drag and Drop"
// section of the GTK documentation for more information.
type Drag interface {
	gextras.Objector

	// DropDone informs GDK that the drop ended.
	//
	// Passing false for @success may trigger a drag cancellation animation.
	//
	// This function is called by the drag source, and should be the last call
	// before dropping the reference to the @drag.
	//
	// The `GdkDrag` will only take the first [method@Gdk.Drag.drop_done] call
	// as effective, if this function is called multiple times, all subsequent
	// calls will be ignored.
	DropDone(success bool)
	// Actions determines the bitmask of possible actions proposed by the
	// source.
	Actions() DragAction
	// Content returns the `GdkContentProvider` associated to the `GdkDrag`
	// object.
	Content() ContentProvider
	// Device returns the `GdkDevice` associated to the `GdkDrag` object.
	Device() Device
	// Display gets the `GdkDisplay` that the drag object was created for.
	Display() Display
	// DragSurface returns the surface on which the drag icon should be rendered
	// during the drag operation.
	//
	// Note that the surface may not be available until the drag operation has
	// begun. GDK will move the surface in accordance with the ongoing drag
	// operation. The surface is owned by @drag and will be destroyed when the
	// drag operation is over.
	DragSurface() Surface
	// Formats retrieves the formats supported by this `GdkDrag` object.
	Formats() *ContentFormats
	// SelectedAction determines the action chosen by the drag destination.
	SelectedAction() DragAction
	// Surface returns the `GdkSurface` where the drag originates.
	Surface() Surface
	// SetHotspot sets the position of the drag surface that will be kept under
	// the cursor hotspot.
	//
	// Initially, the hotspot is at the top left corner of the drag surface.
	SetHotspot(hotX int, hotY int)
}

// drag implements the Drag interface.
type drag struct {
	gextras.Objector
}

var _ Drag = (*drag)(nil)

// WrapDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrag(obj *externglib.Object) Drag {
	return Drag{
		Objector: obj,
	}
}

func marshalDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrag(obj), nil
}

// DropDone informs GDK that the drop ended.
//
// Passing false for @success may trigger a drag cancellation animation.
//
// This function is called by the drag source, and should be the last call
// before dropping the reference to the @drag.
//
// The `GdkDrag` will only take the first [method@Gdk.Drag.drop_done] call
// as effective, if this function is called multiple times, all subsequent
// calls will be ignored.
func (d drag) DropDone(success bool) {
	var arg0 *C.GdkDrag
	var arg1 C.gboolean

	arg0 = (*C.GdkDrag)(d.Native())
	if success {
		arg1 = C.TRUE
	}

	C.gdk_drag_drop_done(arg0, arg1)
}

// Actions determines the bitmask of possible actions proposed by the
// source.
func (d drag) Actions() DragAction {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_actions(arg0)

	var ret0 DragAction

	ret0 = DragAction(ret)

	return ret0
}

// Content returns the `GdkContentProvider` associated to the `GdkDrag`
// object.
func (d drag) Content() ContentProvider {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_content(arg0)

	var ret0 ContentProvider

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(ContentProvider)

	return ret0
}

// Device returns the `GdkDevice` associated to the `GdkDrag` object.
func (d drag) Device() Device {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_device(arg0)

	var ret0 Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Device)

	return ret0
}

// Display gets the `GdkDisplay` that the drag object was created for.
func (d drag) Display() Display {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// DragSurface returns the surface on which the drag icon should be rendered
// during the drag operation.
//
// Note that the surface may not be available until the drag operation has
// begun. GDK will move the surface in accordance with the ongoing drag
// operation. The surface is owned by @drag and will be destroyed when the
// drag operation is over.
func (d drag) DragSurface() Surface {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_drag_surface(arg0)

	var ret0 Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0
}

// Formats retrieves the formats supported by this `GdkDrag` object.
func (d drag) Formats() *ContentFormats {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_formats(arg0)

	var ret0 *ContentFormats

	{
		ret0 = WrapContentFormats(unsafe.Pointer(ret))
	}

	return ret0
}

// SelectedAction determines the action chosen by the drag destination.
func (d drag) SelectedAction() DragAction {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_selected_action(arg0)

	var ret0 DragAction

	ret0 = DragAction(ret)

	return ret0
}

// Surface returns the `GdkSurface` where the drag originates.
func (d drag) Surface() Surface {
	var arg0 *C.GdkDrag

	arg0 = (*C.GdkDrag)(d.Native())

	ret := C.gdk_drag_get_surface(arg0)

	var ret0 Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0
}

// SetHotspot sets the position of the drag surface that will be kept under
// the cursor hotspot.
//
// Initially, the hotspot is at the top left corner of the drag surface.
func (d drag) SetHotspot(hotX int, hotY int) {
	var arg0 *C.GdkDrag
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkDrag)(d.Native())
	arg1 = C.int(hotX)
	arg2 = C.int(hotY)

	C.gdk_drag_set_hotspot(arg0, arg1, arg2)
}

// DrawContext: base class for objects implementing different rendering methods.
//
// `GdkDrawContext` is the base object used by contexts implementing different
// rendering methods, such as [class@Gdk.CairoContext] or [class@Gdk.GLContext].
// It provides shared functionality between those contexts.
//
// You will always interact with one of those subclasses.
//
// A `GdkDrawContext` is always associated with a single toplevel surface.
type DrawContext interface {
	gextras.Objector

	// BeginFrame indicates that you are beginning the process of redrawing
	// @region on the @context's surface.
	//
	// Calling this function begins a drawing operation using @context on the
	// surface that @context was created from. The actual requirements and
	// guarantees for the drawing operation vary for different implementations
	// of drawing, so a [class@Gdk.CairoContext] and a [class@Gdk.GLContext]
	// need to be treated differently.
	//
	// A call to this function is a requirement for drawing and must be followed
	// by a call to [method@Gdk.DrawContext.end_frame], which will complete the
	// drawing operation and ensure the contents become visible on screen.
	//
	// Note that the @region passed to this function is the minimum region that
	// needs to be drawn and depending on implementation, windowing system and
	// hardware in use, it might be necessary to draw a larger region. Drawing
	// implementation must use [method@Gdk.DrawContext.get_frame_region() to
	// query the region that must be drawn.
	//
	// When using GTK, the widget system automatically places calls to
	// gdk_draw_context_begin_frame() and gdk_draw_context_end_frame() via the
	// use of [class@Gsk.Renderer]s, so application code does not need to call
	// these functions explicitly.
	BeginFrame(region *cairo.Region)
	// EndFrame ends a drawing operation started with
	// gdk_draw_context_begin_frame().
	//
	// This makes the drawing available on screen. See
	// [method@Gdk.DrawContext.begin_frame] for more details about drawing.
	//
	// When using a [class@Gdk.GLContext], this function may call `glFlush()`
	// implicitly before returning; it is not recommended to call `glFlush()`
	// explicitly before calling this function.
	EndFrame()
	// Display retrieves the `GdkDisplay` the @context is created for
	Display() Display
	// FrameRegion retrieves the region that is currently being repainted.
	//
	// After a call to [method@Gdk.DrawContext.begin_frame] this function will
	// return a union of the region passed to that function and the area of the
	// surface that the @context determined needs to be repainted.
	//
	// If @context is not in between calls to
	// [method@Gdk.DrawContext.begin_frame] and
	// [method@Gdk.DrawContext.end_frame], nil will be returned.
	FrameRegion() *cairo.Region
	// Surface retrieves the surface that @context is bound to.
	Surface() Surface
	// IsInFrame returns true if @context is in the process of drawing to its
	// surface.
	//
	// This is the case between calls to [method@Gdk.DrawContext.begin_frame]
	// and [method@Gdk.DrawContext.end_frame]. In this situation, drawing
	// commands may be effecting the contents of the @context's surface.
	IsInFrame() bool
}

// drawContext implements the DrawContext interface.
type drawContext struct {
	gextras.Objector
}

var _ DrawContext = (*drawContext)(nil)

// WrapDrawContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrawContext(obj *externglib.Object) DrawContext {
	return DrawContext{
		Objector: obj,
	}
}

func marshalDrawContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrawContext(obj), nil
}

// BeginFrame indicates that you are beginning the process of redrawing
// @region on the @context's surface.
//
// Calling this function begins a drawing operation using @context on the
// surface that @context was created from. The actual requirements and
// guarantees for the drawing operation vary for different implementations
// of drawing, so a [class@Gdk.CairoContext] and a [class@Gdk.GLContext]
// need to be treated differently.
//
// A call to this function is a requirement for drawing and must be followed
// by a call to [method@Gdk.DrawContext.end_frame], which will complete the
// drawing operation and ensure the contents become visible on screen.
//
// Note that the @region passed to this function is the minimum region that
// needs to be drawn and depending on implementation, windowing system and
// hardware in use, it might be necessary to draw a larger region. Drawing
// implementation must use [method@Gdk.DrawContext.get_frame_region() to
// query the region that must be drawn.
//
// When using GTK, the widget system automatically places calls to
// gdk_draw_context_begin_frame() and gdk_draw_context_end_frame() via the
// use of [class@Gsk.Renderer]s, so application code does not need to call
// these functions explicitly.
func (c drawContext) BeginFrame(region *cairo.Region) {
	var arg0 *C.GdkDrawContext
	var arg1 *C.cairo_region_t

	arg0 = (*C.GdkDrawContext)(c.Native())
	arg1 = (*C.cairo_region_t)(region.Native())

	C.gdk_draw_context_begin_frame(arg0, arg1)
}

// EndFrame ends a drawing operation started with
// gdk_draw_context_begin_frame().
//
// This makes the drawing available on screen. See
// [method@Gdk.DrawContext.begin_frame] for more details about drawing.
//
// When using a [class@Gdk.GLContext], this function may call `glFlush()`
// implicitly before returning; it is not recommended to call `glFlush()`
// explicitly before calling this function.
func (c drawContext) EndFrame() {
	var arg0 *C.GdkDrawContext

	arg0 = (*C.GdkDrawContext)(c.Native())

	C.gdk_draw_context_end_frame(arg0)
}

// Display retrieves the `GdkDisplay` the @context is created for
func (c drawContext) Display() Display {
	var arg0 *C.GdkDrawContext

	arg0 = (*C.GdkDrawContext)(c.Native())

	ret := C.gdk_draw_context_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// FrameRegion retrieves the region that is currently being repainted.
//
// After a call to [method@Gdk.DrawContext.begin_frame] this function will
// return a union of the region passed to that function and the area of the
// surface that the @context determined needs to be repainted.
//
// If @context is not in between calls to
// [method@Gdk.DrawContext.begin_frame] and
// [method@Gdk.DrawContext.end_frame], nil will be returned.
func (c drawContext) FrameRegion() *cairo.Region {
	var arg0 *C.GdkDrawContext

	arg0 = (*C.GdkDrawContext)(c.Native())

	ret := C.gdk_draw_context_get_frame_region(arg0)

	var ret0 *cairo.Region

	{
		ret0 = cairo.WrapRegion(unsafe.Pointer(ret))
	}

	return ret0
}

// Surface retrieves the surface that @context is bound to.
func (c drawContext) Surface() Surface {
	var arg0 *C.GdkDrawContext

	arg0 = (*C.GdkDrawContext)(c.Native())

	ret := C.gdk_draw_context_get_surface(arg0)

	var ret0 Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0
}

// IsInFrame returns true if @context is in the process of drawing to its
// surface.
//
// This is the case between calls to [method@Gdk.DrawContext.begin_frame]
// and [method@Gdk.DrawContext.end_frame]. In this situation, drawing
// commands may be effecting the contents of the @context's surface.
func (c drawContext) IsInFrame() bool {
	var arg0 *C.GdkDrawContext

	arg0 = (*C.GdkDrawContext)(c.Native())

	ret := C.gdk_draw_context_is_in_frame(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Drop: the `GdkDrop` object represents the target of an ongoing DND operation.
//
// Possible drop sites get informed about the status of the ongoing drag
// operation with events of type GDK_DRAG_ENTER, GDK_DRAG_LEAVE, GDK_DRAG_MOTION
// and GDK_DROP_START. The `GdkDrop` object can be obtained from these
// [class@Gdk.Event] types using [method@Gdk.DNDEvent.get_drop].
//
// The actual data transfer is initiated from the target side via an async read,
// using one of the `GdkDrop` methods for this purpose:
// [method@Gdk.Drop.read_async] or [method@Gdk.Drop.read_value_async].
//
// GTK provides a higher level abstraction based on top of these functions, and
// so they are not normally needed in GTK applications. See the "Drag and Drop"
// section of the GTK documentation for more information.
type Drop interface {
	gextras.Objector

	// Finish ends the drag operation after a drop.
	//
	// The @action must be a single action selected from the actions available
	// via [method@Gdk.Drop.get_actions].
	Finish(action DragAction)
	// Actions returns the possible actions for this `GdkDrop`.
	//
	// If this value contains multiple actions - i.e.
	// [func@Gdk.DragAction.is_unique] returns false for the result -
	// [method@Gdk.Drop.finish] must choose the action to use when accepting the
	// drop. This will only happen if you passed GDK_ACTION_ASK as one of the
	// possible actions in [method@Gdk.Drop.status]. GDK_ACTION_ASK itself will
	// not be included in the actions returned by this function.
	//
	// This value may change over the lifetime of the [class@Gdk.Drop] both as a
	// response to source side actions as well as to calls to
	// [method@Gdk.Drop.status] or [method@Gdk.Drop.finish]. The source side
	// will not change this value anymore once a drop has started.
	Actions() DragAction
	// Device returns the `GdkDevice` performing the drop.
	Device() Device
	// Display gets the `GdkDisplay` that @self was created for.
	Display() Display
	// Drag: if this is an in-app drag-and-drop operation, returns the `GdkDrag`
	// that corresponds to this drop.
	//
	// If it is not, nil is returned.
	Drag() Drag
	// Formats returns the `GdkContentFormats` that the drop offers the data to
	// be read in.
	Formats() *ContentFormats
	// Surface returns the `GdkSurface` performing the drop.
	Surface() Surface
	// ReadAsync: asynchronously read the dropped data from a `GdkDrop` in a
	// format that complies with one of the mime types.
	ReadAsync(mimeTypes []string, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadFinish finishes an async drop read operation.
	//
	// Note that you must not use blocking read calls on the returned stream in
	// the GTK thread, since some platforms might require communication with GTK
	// to complete the data transfer. You can use async APIs such as
	// g_input_stream_read_bytes_async().
	//
	// See [method@Gdk.Drop.read_async].
	ReadFinish(result gio.AsyncResult) (outMIMEType string, inputStream gio.InputStream, err error)
	// ReadValueAsync: asynchronously request the drag operation's contents
	// converted to the given @type.
	//
	// When the operation is finished @callback will be called. You must then
	// call [method@Gdk.Drop.read_value_finish] to get the resulting `GValue`.
	//
	// For local drag'n'drop operations that are available in the given `GType`,
	// the value will be copied directly. Otherwise, GDK will try to use
	// [func@Gdk.content_deserialize_async] to convert the data.
	ReadValueAsync(typ externglib.Type, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback)
	// ReadValueFinish finishes an async drop read.
	//
	// See [method@Gdk.Drop.read_value_async].
	ReadValueFinish(result gio.AsyncResult) (value *externglib.Value, err error)
	// Status selects all actions that are potentially supported by the
	// destination.
	//
	// When calling this function, do not restrict the passed in actions to the
	// ones provided by [method@Gdk.Drop.get_actions]. Those actions may change
	// in the future, even depending on the actions you provide here.
	//
	// The @preferred action is a hint to the drag'n'drop mechanism about which
	// action to use when multiple actions are possible.
	//
	// This function should be called by drag destinations in response to
	// GDK_DRAG_ENTER or GDK_DRAG_MOTION events. If the destination does not yet
	// know the exact actions it supports, it should set any possible actions
	// first and then later call this function again.
	Status(actions DragAction, preferred DragAction)
}

// drop implements the Drop interface.
type drop struct {
	gextras.Objector
}

var _ Drop = (*drop)(nil)

// WrapDrop wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrop(obj *externglib.Object) Drop {
	return Drop{
		Objector: obj,
	}
}

func marshalDrop(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrop(obj), nil
}

// Finish ends the drag operation after a drop.
//
// The @action must be a single action selected from the actions available
// via [method@Gdk.Drop.get_actions].
func (s drop) Finish(action DragAction) {
	var arg0 *C.GdkDrop
	var arg1 C.GdkDragAction

	arg0 = (*C.GdkDrop)(s.Native())
	arg1 = (C.GdkDragAction)(action)

	C.gdk_drop_finish(arg0, arg1)
}

// Actions returns the possible actions for this `GdkDrop`.
//
// If this value contains multiple actions - i.e.
// [func@Gdk.DragAction.is_unique] returns false for the result -
// [method@Gdk.Drop.finish] must choose the action to use when accepting the
// drop. This will only happen if you passed GDK_ACTION_ASK as one of the
// possible actions in [method@Gdk.Drop.status]. GDK_ACTION_ASK itself will
// not be included in the actions returned by this function.
//
// This value may change over the lifetime of the [class@Gdk.Drop] both as a
// response to source side actions as well as to calls to
// [method@Gdk.Drop.status] or [method@Gdk.Drop.finish]. The source side
// will not change this value anymore once a drop has started.
func (s drop) Actions() DragAction {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_actions(arg0)

	var ret0 DragAction

	ret0 = DragAction(ret)

	return ret0
}

// Device returns the `GdkDevice` performing the drop.
func (s drop) Device() Device {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_device(arg0)

	var ret0 Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Device)

	return ret0
}

// Display gets the `GdkDisplay` that @self was created for.
func (s drop) Display() Display {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// Drag: if this is an in-app drag-and-drop operation, returns the `GdkDrag`
// that corresponds to this drop.
//
// If it is not, nil is returned.
func (s drop) Drag() Drag {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_drag(arg0)

	var ret0 Drag

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Drag)

	return ret0
}

// Formats returns the `GdkContentFormats` that the drop offers the data to
// be read in.
func (s drop) Formats() *ContentFormats {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_formats(arg0)

	var ret0 *ContentFormats

	{
		ret0 = WrapContentFormats(unsafe.Pointer(ret))
	}

	return ret0
}

// Surface returns the `GdkSurface` performing the drop.
func (s drop) Surface() Surface {
	var arg0 *C.GdkDrop

	arg0 = (*C.GdkDrop)(s.Native())

	ret := C.gdk_drop_get_surface(arg0)

	var ret0 Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0
}

// ReadAsync: asynchronously read the dropped data from a `GdkDrop` in a
// format that complies with one of the mime types.
func (s drop) ReadAsync(mimeTypes []string, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkDrop
	var arg1 **C.char
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GdkDrop)(s.Native())
	{
		var dst []*C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * (len(mimeTypes) + 1))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(mimeTypes)
		sliceHeader.Cap = len(mimeTypes)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(mimeTypes); i++ {
			src := mimeTypes[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.char)(unsafe.Pointer(ptr))
	}
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.gdk_drop_read_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ReadFinish finishes an async drop read operation.
//
// Note that you must not use blocking read calls on the returned stream in
// the GTK thread, since some platforms might require communication with GTK
// to complete the data transfer. You can use async APIs such as
// g_input_stream_read_bytes_async().
//
// See [method@Gdk.Drop.read_async].
func (s drop) ReadFinish(result gio.AsyncResult) (outMIMEType string, inputStream gio.InputStream, err error) {
	var arg0 *C.GdkDrop
	var arg1 *C.GAsyncResult
	var arg2 **C.char // out
	var gError *C.GError

	arg0 = (*C.GdkDrop)(s.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_drop_read_finish(arg0, arg1, &arg2, &gError)

	var ret0 string
	var ret1 gio.InputStream
	var goError error

	ret0 = C.GoString(arg2)
	C.free(unsafe.Pointer(arg2))

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.InputStream)

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, ret1, goError
}

// ReadValueAsync: asynchronously request the drag operation's contents
// converted to the given @type.
//
// When the operation is finished @callback will be called. You must then
// call [method@Gdk.Drop.read_value_finish] to get the resulting `GValue`.
//
// For local drag'n'drop operations that are available in the given `GType`,
// the value will be copied directly. Otherwise, GDK will try to use
// [func@Gdk.content_deserialize_async] to convert the data.
func (s drop) ReadValueAsync(typ externglib.Type, ioPriority int, cancellable gio.Cancellable, callback gio.AsyncReadyCallback) {
	var arg0 *C.GdkDrop
	var arg1 C.GType
	var arg2 C.int
	var arg3 *C.GCancellable
	var arg4 C.GAsyncReadyCallback
	var arg5 C.gpointer

	arg0 = (*C.GdkDrop)(s.Native())
	arg1 = C.GType(typ)
	arg2 = C.int(ioPriority)
	arg3 = (*C.GCancellable)(cancellable.Native())
	arg4 = (*[0]byte)(C.gotk4_AsyncReadyCallback)
	arg5 = C.gpointer(box.Assign(callback))

	C.gdk_drop_read_value_async(arg0, arg1, arg2, arg3, arg4, arg5)
}

// ReadValueFinish finishes an async drop read.
//
// See [method@Gdk.Drop.read_value_async].
func (s drop) ReadValueFinish(result gio.AsyncResult) (value *externglib.Value, err error) {
	var arg0 *C.GdkDrop
	var arg1 *C.GAsyncResult
	var gError *C.GError

	arg0 = (*C.GdkDrop)(s.Native())
	arg1 = (*C.GAsyncResult)(result.Native())

	ret := C.gdk_drop_read_value_finish(arg0, arg1, &gError)

	var ret0 *externglib.Value
	var goError error

	ret0 = externglib.ValueFromNative(unsafe.Pointer(ret))

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// Status selects all actions that are potentially supported by the
// destination.
//
// When calling this function, do not restrict the passed in actions to the
// ones provided by [method@Gdk.Drop.get_actions]. Those actions may change
// in the future, even depending on the actions you provide here.
//
// The @preferred action is a hint to the drag'n'drop mechanism about which
// action to use when multiple actions are possible.
//
// This function should be called by drag destinations in response to
// GDK_DRAG_ENTER or GDK_DRAG_MOTION events. If the destination does not yet
// know the exact actions it supports, it should set any possible actions
// first and then later call this function again.
func (s drop) Status(actions DragAction, preferred DragAction) {
	var arg0 *C.GdkDrop
	var arg1 C.GdkDragAction
	var arg2 C.GdkDragAction

	arg0 = (*C.GdkDrop)(s.Native())
	arg1 = (C.GdkDragAction)(actions)
	arg2 = (C.GdkDragAction)(preferred)

	C.gdk_drop_status(arg0, arg1, arg2)
}

// GLContext: `GdkGLContext` is an object representing a platform-specific
// OpenGL draw context.
//
// `GdkGLContext`s are created for a surface using
// [method@Gdk.Surface.create_gl_context], and the context will match the the
// characteristics of the surface.
//
// A `GdkGLContext` is not tied to any particular normal framebuffer. For
// instance, it cannot draw to the surface back buffer. The GDK repaint system
// is in full control of the painting to that. Instead, you can create render
// buffers or textures and use [func@cairo_draw_from_gl] in the draw function of
// your widget to draw them. Then GDK will handle the integration of your
// rendering with that of other widgets.
//
// Support for `GdkGLContext` is platform-specific and context creation can
// fail, returning nil context.
//
// A `GdkGLContext` has to be made "current" in order to start using it,
// otherwise any OpenGL call will be ignored.
//
//
// Creating a new OpenGL context
//
// In order to create a new `GdkGLContext` instance you need a `GdkSurface`,
// which you typically get during the realize call of a widget.
//
// A `GdkGLContext` is not realized until either
// [method@Gdk.GLContext.make_current] or [method@Gdk.GLContext.realize] is
// called. It is possible to specify details of the GL context like the OpenGL
// version to be used, or whether the GL context should have extra state
// validation enabled after calling [method@Gdk.Surface.create_gl_context] by
// calling [method@Gdk.GLContext.realize]. If the realization fails you have the
// option to change the settings of the `GdkGLContext` and try again.
//
//
// Using a GdkGLContext
//
// You will need to make the `GdkGLContext` the current context before issuing
// OpenGL calls; the system sends OpenGL commands to whichever context is
// current. It is possible to have multiple contexts, so you always need to
// ensure that the one which you want to draw with is the current one before
// issuing commands:
//
// â€œ`c gdk_gl_context_make_current (context); â€œ`
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which `GdkGLContext` is the current one by using
// [func@Gdk.GLContext.get_current]; you can also unset any `GdkGLContext` that
// is currently set by calling [func@Gdk.GLContext.clear_current].
type GLContext interface {
	DrawContext

	// DebugEnabled retrieves whether the context is doing extra validations and
	// runtime checking.
	//
	// See [method@Gdk.GLContext.set_debug_enabled].
	DebugEnabled() bool
	// Display retrieves the display the @context is created for
	Display() Display
	// ForwardCompatible retrieves whether the context is forward-compatible.
	//
	// See [method@Gdk.GLContext.set_forward_compatible].
	ForwardCompatible() bool
	// RequiredVersion retrieves required OpenGL version.
	//
	// See [method@Gdk.GLContext.set_required_version].
	RequiredVersion() (major int, minor int)
	// SharedContext retrieves the `GdkGLContext` that this @context share data
	// with.
	SharedContext() GLContext
	// Surface retrieves the surface used by the @context.
	Surface() Surface
	// UseES checks whether the @context is using an OpenGL or OpenGL ES
	// profile.
	UseES() bool
	// Version retrieves the OpenGL version of the @context.
	//
	// The @context must be realized prior to calling this function.
	Version() (major int, minor int)
	// IsLegacy: whether the `GdkGLContext` is in legacy mode or not.
	//
	// The `GdkGLContext` must be realized before calling this function.
	//
	// When realizing a GL context, GDK will try to use the OpenGL 3.2 core
	// profile; this profile removes all the OpenGL API that was deprecated
	// prior to the 3.2 version of the specification. If the realization is
	// successful, this function will return false.
	//
	// If the underlying OpenGL implementation does not support core profiles,
	// GDK will fall back to a pre-3.2 compatibility profile, and this function
	// will return true.
	//
	// You can use the value returned by this function to decide which kind of
	// OpenGL API to use, or whether to do extension discovery, or what kind of
	// shader programs to load.
	IsLegacy() bool
	// MakeCurrent makes the @context the current one.
	MakeCurrent()
	// Realize realizes the given `GdkGLContext`.
	//
	// It is safe to call this function on a realized `GdkGLContext`.
	Realize() error
	// SetDebugEnabled sets whether the `GdkGLContext` should perform extra
	// validations and runtime checking.
	//
	// This is useful during development, but has additional overhead.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetDebugEnabled(enabled bool)
	// SetForwardCompatible sets whether the `GdkGLContext` should be
	// forward-compatible.
	//
	// Forward-compatible contexts must not support OpenGL functionality that
	// has been marked as deprecated in the requested version; non-forward
	// compatible contexts, on the other hand, must support both deprecated and
	// non deprecated functionality.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetForwardCompatible(compatible bool)
	// SetRequiredVersion sets the major and minor version of OpenGL to request.
	//
	// Setting @major and @minor to zero will use the default values.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetRequiredVersion(major int, minor int)
	// SetUseES requests that GDK create an OpenGL ES context instead of an
	// OpenGL one.
	//
	// Not all platforms support OpenGL ES.
	//
	// The @context must not have been realized.
	//
	// By default, GDK will attempt to automatically detect whether the
	// underlying GL implementation is OpenGL or OpenGL ES once the @context is
	// realized.
	//
	// You should check the return value of [method@Gdk.GLContext.get_use_es]
	// after calling [method@Gdk.GLContext.realize] to decide whether to use the
	// OpenGL or OpenGL ES API, extensions, or shaders.
	SetUseES(useES int)
}

// glContext implements the GLContext interface.
type glContext struct {
	DrawContext
}

var _ GLContext = (*glContext)(nil)

// WrapGLContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLContext(obj *externglib.Object) GLContext {
	return GLContext{
		DrawContext: WrapDrawContext(obj),
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLContext(obj), nil
}

// DebugEnabled retrieves whether the context is doing extra validations and
// runtime checking.
//
// See [method@Gdk.GLContext.set_debug_enabled].
func (c glContext) DebugEnabled() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_debug_enabled(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Display retrieves the display the @context is created for
func (c glContext) Display() Display {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// ForwardCompatible retrieves whether the context is forward-compatible.
//
// See [method@Gdk.GLContext.set_forward_compatible].
func (c glContext) ForwardCompatible() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_forward_compatible(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// RequiredVersion retrieves required OpenGL version.
//
// See [method@Gdk.GLContext.set_required_version].
func (c glContext) RequiredVersion() (major int, minor int) {
	var arg0 *C.GdkGLContext
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GdkGLContext)(c.Native())

	C.gdk_gl_context_get_required_version(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// SharedContext retrieves the `GdkGLContext` that this @context share data
// with.
func (c glContext) SharedContext() GLContext {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_shared_context(arg0)

	var ret0 GLContext

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(GLContext)

	return ret0
}

// Surface retrieves the surface used by the @context.
func (c glContext) Surface() Surface {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_surface(arg0)

	var ret0 Surface

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Surface)

	return ret0
}

// UseES checks whether the @context is using an OpenGL or OpenGL ES
// profile.
func (c glContext) UseES() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_get_use_es(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Version retrieves the OpenGL version of the @context.
//
// The @context must be realized prior to calling this function.
func (c glContext) Version() (major int, minor int) {
	var arg0 *C.GdkGLContext
	var arg1 *C.int // out
	var arg2 *C.int // out

	arg0 = (*C.GdkGLContext)(c.Native())

	C.gdk_gl_context_get_version(arg0, &arg1, &arg2)

	var ret0 int
	var ret1 int

	ret0 = int(arg1)

	ret1 = int(arg2)

	return ret0, ret1
}

// IsLegacy: whether the `GdkGLContext` is in legacy mode or not.
//
// The `GdkGLContext` must be realized before calling this function.
//
// When realizing a GL context, GDK will try to use the OpenGL 3.2 core
// profile; this profile removes all the OpenGL API that was deprecated
// prior to the 3.2 version of the specification. If the realization is
// successful, this function will return false.
//
// If the underlying OpenGL implementation does not support core profiles,
// GDK will fall back to a pre-3.2 compatibility profile, and this function
// will return true.
//
// You can use the value returned by this function to decide which kind of
// OpenGL API to use, or whether to do extension discovery, or what kind of
// shader programs to load.
func (c glContext) IsLegacy() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_is_legacy(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// MakeCurrent makes the @context the current one.
func (c glContext) MakeCurrent() {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(c.Native())

	C.gdk_gl_context_make_current(arg0)
}

// Realize realizes the given `GdkGLContext`.
//
// It is safe to call this function on a realized `GdkGLContext`.
func (c glContext) Realize() error {
	var arg0 *C.GdkGLContext
	var gError *C.GError

	arg0 = (*C.GdkGLContext)(c.Native())

	ret := C.gdk_gl_context_realize(arg0, &gError)

	var goError error

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return goError
}

// SetDebugEnabled sets whether the `GdkGLContext` should perform extra
// validations and runtime checking.
//
// This is useful during development, but has additional overhead.
//
// The `GdkGLContext` must not be realized or made current prior to calling
// this function.
func (c glContext) SetDebugEnabled(enabled bool) {
	var arg0 *C.GdkGLContext
	var arg1 C.gboolean

	arg0 = (*C.GdkGLContext)(c.Native())
	if enabled {
		arg1 = C.TRUE
	}

	C.gdk_gl_context_set_debug_enabled(arg0, arg1)
}

// SetForwardCompatible sets whether the `GdkGLContext` should be
// forward-compatible.
//
// Forward-compatible contexts must not support OpenGL functionality that
// has been marked as deprecated in the requested version; non-forward
// compatible contexts, on the other hand, must support both deprecated and
// non deprecated functionality.
//
// The `GdkGLContext` must not be realized or made current prior to calling
// this function.
func (c glContext) SetForwardCompatible(compatible bool) {
	var arg0 *C.GdkGLContext
	var arg1 C.gboolean

	arg0 = (*C.GdkGLContext)(c.Native())
	if compatible {
		arg1 = C.TRUE
	}

	C.gdk_gl_context_set_forward_compatible(arg0, arg1)
}

// SetRequiredVersion sets the major and minor version of OpenGL to request.
//
// Setting @major and @minor to zero will use the default values.
//
// The `GdkGLContext` must not be realized or made current prior to calling
// this function.
func (c glContext) SetRequiredVersion(major int, minor int) {
	var arg0 *C.GdkGLContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkGLContext)(c.Native())
	arg1 = C.int(major)
	arg2 = C.int(minor)

	C.gdk_gl_context_set_required_version(arg0, arg1, arg2)
}

// SetUseES requests that GDK create an OpenGL ES context instead of an
// OpenGL one.
//
// Not all platforms support OpenGL ES.
//
// The @context must not have been realized.
//
// By default, GDK will attempt to automatically detect whether the
// underlying GL implementation is OpenGL or OpenGL ES once the @context is
// realized.
//
// You should check the return value of [method@Gdk.GLContext.get_use_es]
// after calling [method@Gdk.GLContext.realize] to decide whether to use the
// OpenGL or OpenGL ES API, extensions, or shaders.
func (c glContext) SetUseES(useES int) {
	var arg0 *C.GdkGLContext
	var arg1 C.int

	arg0 = (*C.GdkGLContext)(c.Native())
	arg1 = C.int(useES)

	C.gdk_gl_context_set_use_es(arg0, arg1)
}

// Seat: the `GdkSeat` object represents a collection of input devices that
// belong to a user.
type Seat interface {
	gextras.Objector

	// Capabilities returns the capabilities this `GdkSeat` currently has.
	Capabilities() SeatCapabilities
	// Devices returns the devices that match the given capabilities.
	Devices(capabilities SeatCapabilities) *glib.List
	// Display returns the `GdkDisplay` this seat belongs to.
	Display() Display
	// Keyboard returns the device that routes keyboard events.
	Keyboard() Device
	// Pointer returns the device that routes pointer events.
	Pointer() Device
	// Tools returns all `GdkDeviceTools` that are known to the application.
	Tools() *glib.List
}

// seat implements the Seat interface.
type seat struct {
	gextras.Objector
}

var _ Seat = (*seat)(nil)

// WrapSeat wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeat(obj *externglib.Object) Seat {
	return Seat{
		Objector: obj,
	}
}

func marshalSeat(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeat(obj), nil
}

// Capabilities returns the capabilities this `GdkSeat` currently has.
func (s seat) Capabilities() SeatCapabilities {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(s.Native())

	ret := C.gdk_seat_get_capabilities(arg0)

	var ret0 SeatCapabilities

	ret0 = SeatCapabilities(ret)

	return ret0
}

// Devices returns the devices that match the given capabilities.
func (s seat) Devices(capabilities SeatCapabilities) *glib.List {
	var arg0 *C.GdkSeat
	var arg1 C.GdkSeatCapabilities

	arg0 = (*C.GdkSeat)(s.Native())
	arg1 = (C.GdkSeatCapabilities)(capabilities)

	ret := C.gdk_seat_get_devices(arg0, arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Display returns the `GdkDisplay` this seat belongs to.
func (s seat) Display() Display {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(s.Native())

	ret := C.gdk_seat_get_display(arg0)

	var ret0 Display

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Display)

	return ret0
}

// Keyboard returns the device that routes keyboard events.
func (s seat) Keyboard() Device {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(s.Native())

	ret := C.gdk_seat_get_keyboard(arg0)

	var ret0 Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Device)

	return ret0
}

// Pointer returns the device that routes pointer events.
func (s seat) Pointer() Device {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(s.Native())

	ret := C.gdk_seat_get_pointer(arg0)

	var ret0 Device

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(Device)

	return ret0
}

// Tools returns all `GdkDeviceTools` that are known to the application.
func (s seat) Tools() *glib.List {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(s.Native())

	ret := C.gdk_seat_get_tools(arg0)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// VulkanContext: `GdkVulkanContext` is an object representing the
// platform-specific Vulkan draw context.
//
// `GdkVulkanContext`s are created for a surface using
// [method@Gdk.Surface.create_vulkan_context], and the context will match the
// the characteristics of the surface.
//
// Support for `GdkVulkanContext` is platform-specific and context creation can
// fail, returning nil context.
type VulkanContext interface {
	DrawContext
	gio.Initable
}

// vulkanContext implements the VulkanContext interface.
type vulkanContext struct {
	DrawContext
	gio.Initable
}

var _ VulkanContext = (*vulkanContext)(nil)

// WrapVulkanContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanContext(obj *externglib.Object) VulkanContext {
	return VulkanContext{
		DrawContext:  WrapDrawContext(obj),
		gio.Initable: gio.WrapInitable(obj),
	}
}

func marshalVulkanContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanContext(obj), nil
}
