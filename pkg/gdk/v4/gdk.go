// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_axis_use_get_type()), F: marshalAxisUse},
		{T: externglib.Type(C.gdk_crossing_mode_get_type()), F: marshalCrossingMode},
		{T: externglib.Type(C.gdk_device_pad_feature_get_type()), F: marshalDevicePadFeature},
		{T: externglib.Type(C.gdk_device_tool_type_get_type()), F: marshalDeviceToolType},
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_event_type_get_type()), F: marshalEventType},
		{T: externglib.Type(C.gdk_fullscreen_mode_get_type()), F: marshalFullscreenMode},
		{T: externglib.Type(C.gdk_gl_error_get_type()), F: marshalGLError},
		{T: externglib.Type(C.gdk_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.gdk_input_source_get_type()), F: marshalInputSource},
		{T: externglib.Type(C.gdk_key_match_get_type()), F: marshalKeyMatch},
		{T: externglib.Type(C.gdk_memory_format_get_type()), F: marshalMemoryFormat},
		{T: externglib.Type(C.gdk_notify_type_get_type()), F: marshalNotifyType},
		{T: externglib.Type(C.gdk_scroll_direction_get_type()), F: marshalScrollDirection},
		{T: externglib.Type(C.gdk_subpixel_layout_get_type()), F: marshalSubpixelLayout},
		{T: externglib.Type(C.gdk_surface_edge_get_type()), F: marshalSurfaceEdge},
		{T: externglib.Type(C.gdk_touchpad_gesture_phase_get_type()), F: marshalTouchpadGesturePhase},
		{T: externglib.Type(C.gdk_vulkan_error_get_type()), F: marshalVulkanError},
		{T: externglib.Type(C.gdk_anchor_hints_get_type()), F: marshalAnchorHints},
		{T: externglib.Type(C.gdk_axis_flags_get_type()), F: marshalAxisFlags},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
		{T: externglib.Type(C.gdk_frame_clock_phase_get_type()), F: marshalFrameClockPhase},
		{T: externglib.Type(C.gdk_modifier_type_get_type()), F: marshalModifierType},
		{T: externglib.Type(C.gdk_paintable_flags_get_type()), F: marshalPaintableFlags},
		{T: externglib.Type(C.gdk_seat_capabilities_get_type()), F: marshalSeatCapabilities},
		{T: externglib.Type(C.gdk_toplevel_state_get_type()), F: marshalToplevelState},
		{T: externglib.Type(C.gdk_device_pad_get_type()), F: marshalDevicePad},
		{T: externglib.Type(C.gdk_drag_surface_get_type()), F: marshalDragSurface},
		{T: externglib.Type(C.gdk_paintable_get_type()), F: marshalPaintable},
		{T: externglib.Type(C.gdk_popup_get_type()), F: marshalPopup},
		{T: externglib.Type(C.gdk_toplevel_get_type()), F: marshalToplevel},
		{T: externglib.Type(C.gdk_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.gdk_button_event_get_type()), F: marshalButtonEvent},
		{T: externglib.Type(C.gdk_cairo_context_get_type()), F: marshalCairoContext},
		{T: externglib.Type(C.gdk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gdk_content_deserializer_get_type()), F: marshalContentDeserializer},
		{T: externglib.Type(C.gdk_content_provider_get_type()), F: marshalContentProvider},
		{T: externglib.Type(C.gdk_content_serializer_get_type()), F: marshalContentSerializer},
		{T: externglib.Type(C.gdk_crossing_event_get_type()), F: marshalCrossingEvent},
		{T: externglib.Type(C.gdk_cursor_get_type()), F: marshalCursor},
		{T: externglib.Type(C.gdk_dnd_event_get_type()), F: marshalDNDEvent},
		{T: externglib.Type(C.gdk_delete_event_get_type()), F: marshalDeleteEvent},
		{T: externglib.Type(C.gdk_device_get_type()), F: marshalDevice},
		{T: externglib.Type(C.gdk_device_tool_get_type()), F: marshalDeviceTool},
		{T: externglib.Type(C.gdk_display_get_type()), F: marshalDisplay},
		{T: externglib.Type(C.gdk_display_manager_get_type()), F: marshalDisplayManager},
		{T: externglib.Type(C.gdk_drag_get_type()), F: marshalDrag},
		{T: externglib.Type(C.gdk_draw_context_get_type()), F: marshalDrawContext},
		{T: externglib.Type(C.gdk_drop_get_type()), F: marshalDrop},
		{T: externglib.Type(C.gdk_focus_event_get_type()), F: marshalFocusEvent},
		{T: externglib.Type(C.gdk_frame_clock_get_type()), F: marshalFrameClock},
		{T: externglib.Type(C.gdk_gl_context_get_type()), F: marshalGLContext},
		{T: externglib.Type(C.gdk_gl_texture_get_type()), F: marshalGLTexture},
		{T: externglib.Type(C.gdk_grab_broken_event_get_type()), F: marshalGrabBrokenEvent},
		{T: externglib.Type(C.gdk_key_event_get_type()), F: marshalKeyEvent},
		{T: externglib.Type(C.gdk_memory_texture_get_type()), F: marshalMemoryTexture},
		{T: externglib.Type(C.gdk_monitor_get_type()), F: marshalMonitor},
		{T: externglib.Type(C.gdk_motion_event_get_type()), F: marshalMotionEvent},
		{T: externglib.Type(C.gdk_pad_event_get_type()), F: marshalPadEvent},
		{T: externglib.Type(C.gdk_proximity_event_get_type()), F: marshalProximityEvent},
		{T: externglib.Type(C.gdk_scroll_event_get_type()), F: marshalScrollEvent},
		{T: externglib.Type(C.gdk_seat_get_type()), F: marshalSeat},
		{T: externglib.Type(C.gdk_snapshot_get_type()), F: marshalSnapshot},
		{T: externglib.Type(C.gdk_surface_get_type()), F: marshalSurface},
		{T: externglib.Type(C.gdk_texture_get_type()), F: marshalTexture},
		{T: externglib.Type(C.gdk_touch_event_get_type()), F: marshalTouchEvent},
		{T: externglib.Type(C.gdk_touchpad_event_get_type()), F: marshalTouchpadEvent},
		{T: externglib.Type(C.gdk_vulkan_context_get_type()), F: marshalVulkanContext},
		{T: externglib.Type(C.gdk_content_formats_get_type()), F: marshalContentFormats},
		{T: externglib.Type(C.gdk_content_formats_builder_get_type()), F: marshalContentFormatsBuilder},
		{T: externglib.Type(C.gdk_event_sequence_get_type()), F: marshalEventSequence},
		{T: externglib.Type(C.gdk_frame_timings_get_type()), F: marshalFrameTimings},
		{T: externglib.Type(C.gdk_popup_layout_get_type()), F: marshalPopupLayout},
		{T: externglib.Type(C.gdk_rgba_get_type()), F: marshalRGBA},
		{T: externglib.Type(C.gdk_rectangle_get_type()), F: marshalRectangle},
		{T: externglib.Type(C.gdk_toplevel_layout_get_type()), F: marshalToplevelLayout},
	})
}

// AxisUse defines how device axes are interpreted by GTK.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse int

const (
	// AxisUseIgnore: the axis is ignored.
	AxisUseIgnore AxisUse = 0
	// AxisUseX: the axis is used as the x axis.
	AxisUseX AxisUse = 1
	// AxisUseY: the axis is used as the y axis.
	AxisUseY AxisUse = 2
	// AxisUseDeltaX: the axis is used as the scroll x delta
	AxisUseDeltaX AxisUse = 3
	// AxisUseDeltaY: the axis is used as the scroll y delta
	AxisUseDeltaY AxisUse = 4
	// AxisUsePressure: the axis is used for pressure information.
	AxisUsePressure AxisUse = 5
	// AxisUseXtilt: the axis is used for x tilt information.
	AxisUseXtilt AxisUse = 6
	// AxisUseYtilt: the axis is used for y tilt information.
	AxisUseYtilt AxisUse = 7
	// AxisUseWheel: the axis is used for wheel information.
	AxisUseWheel AxisUse = 8
	// AxisUseDistance: the axis is used for pen/tablet distance information
	AxisUseDistance AxisUse = 9
	// AxisUseRotation: the axis is used for pen rotation information
	AxisUseRotation AxisUse = 10
	// AxisUseSlider: the axis is used for pen slider information
	AxisUseSlider AxisUse = 11
	// AxisUseLast: a constant equal to the numerically highest axis value.
	AxisUseLast AxisUse = 12
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CrossingMode specifies the crossing mode for enter and leave events.
type CrossingMode int

const (
	// CrossingModeNormal: crossing because of pointer motion.
	CrossingModeNormal CrossingMode = 0
	// CrossingModeGrab: crossing because a grab is activated.
	CrossingModeGrab CrossingMode = 1
	// CrossingModeUngrab: crossing because a grab is deactivated.
	CrossingModeUngrab CrossingMode = 2
	// CrossingModeGTKGrab: crossing because a GTK grab is activated.
	CrossingModeGTKGrab CrossingMode = 3
	// CrossingModeGTKUngrab: crossing because a GTK grab is deactivated.
	CrossingModeGTKUngrab CrossingMode = 4
	// CrossingModeStateChanged: crossing because a GTK widget changed state
	// (e.g. sensitivity).
	CrossingModeStateChanged CrossingMode = 5
	// CrossingModeTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchBegin CrossingMode = 6
	// CrossingModeTouchEnd: crossing because a touch sequence has ended, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchEnd CrossingMode = 7
	// CrossingModeDeviceSwitch: crossing because of a device switch (i.e. a
	// mouse taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didn’t leave the surface.
	CrossingModeDeviceSwitch CrossingMode = 8
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DevicePadFeature: a pad feature.
type DevicePadFeature int

const (
	// DevicePadFeatureButton: a button
	DevicePadFeatureButton DevicePadFeature = 0
	// DevicePadFeatureRing: a ring-shaped interactive area
	DevicePadFeatureRing DevicePadFeature = 1
	// DevicePadFeatureStrip: a straight interactive area
	DevicePadFeatureStrip DevicePadFeature = 2
)

func marshalDevicePadFeature(p uintptr) (interface{}, error) {
	return DevicePadFeature(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeviceToolType indicates the specific type of tool being used being a tablet.
// Such as an airbrush, pencil, etc.
type DeviceToolType int

const (
	// DeviceToolTypeUnknown: tool is of an unknown type.
	DeviceToolTypeUnknown DeviceToolType = 0
	// DeviceToolTypePen: tool is a standard tablet stylus.
	DeviceToolTypePen DeviceToolType = 1
	// DeviceToolTypeEraser: tool is standard tablet eraser.
	DeviceToolTypeEraser DeviceToolType = 2
	// DeviceToolTypeBrush: tool is a brush stylus.
	DeviceToolTypeBrush DeviceToolType = 3
	// DeviceToolTypePencil: tool is a pencil stylus.
	DeviceToolTypePencil DeviceToolType = 4
	// DeviceToolTypeAirbrush: tool is an airbrush stylus.
	DeviceToolTypeAirbrush DeviceToolType = 5
	// DeviceToolTypeMouse: tool is a mouse.
	DeviceToolTypeMouse DeviceToolType = 6
	// DeviceToolTypeLens: tool is a lens cursor.
	DeviceToolTypeLens DeviceToolType = 7
)

func marshalDeviceToolType(p uintptr) (interface{}, error) {
	return DeviceToolType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragCancelReason: used in `GdkDrag` to the reason of a cancelled DND
// operation.
type DragCancelReason int

const (
	// DragCancelReasonNoTarget: there is no suitable drop target.
	DragCancelReasonNoTarget DragCancelReason = 0
	// DragCancelReasonUserCancelled: drag cancelled by the user
	DragCancelReasonUserCancelled DragCancelReason = 1
	// DragCancelReasonError: unspecified error.
	DragCancelReasonError DragCancelReason = 2
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventType specifies the type of the event.
type EventType int

const (
	// EventTypeDelete: the window manager has requested that the toplevel
	// surface be hidden or destroyed, usually when the user clicks on a special
	// icon in the title bar.
	EventTypeDelete EventType = 0
	// EventTypeMotionNotify: the pointer (usually a mouse) has moved.
	EventTypeMotionNotify EventType = 1
	// EventTypeButtonPress: a mouse button has been pressed.
	EventTypeButtonPress EventType = 2
	// EventTypeButtonRelease: a mouse button has been released.
	EventTypeButtonRelease EventType = 3
	// EventTypeKeyPress: a key has been pressed.
	EventTypeKeyPress EventType = 4
	// EventTypeKeyRelease: a key has been released.
	EventTypeKeyRelease EventType = 5
	// EventTypeEnterNotify: the pointer has entered the surface.
	EventTypeEnterNotify EventType = 6
	// EventTypeLeaveNotify: the pointer has left the surface.
	EventTypeLeaveNotify EventType = 7
	// EventTypeFocusChange: the keyboard focus has entered or left the surface.
	EventTypeFocusChange EventType = 8
	// EventTypeProximityIn: an input device has moved into contact with a
	// sensing surface (e.g. a touchscreen or graphics tablet).
	EventTypeProximityIn EventType = 9
	// EventTypeProximityOut: an input device has moved out of contact with a
	// sensing surface.
	EventTypeProximityOut EventType = 10
	// EventTypeDragEnter: the mouse has entered the surface while a drag is in
	// progress.
	EventTypeDragEnter EventType = 11
	// EventTypeDragLeave: the mouse has left the surface while a drag is in
	// progress.
	EventTypeDragLeave EventType = 12
	// EventTypeDragMotion: the mouse has moved in the surface while a drag is
	// in progress.
	EventTypeDragMotion EventType = 13
	// EventTypeDropStart: a drop operation onto the surface has started.
	EventTypeDropStart EventType = 14
	// EventTypeScroll: the scroll wheel was turned
	EventTypeScroll EventType = 15
	// EventTypeGrabBroken: a pointer or keyboard grab was broken.
	EventTypeGrabBroken EventType = 16
	// EventTypeTouchBegin: a new touch event sequence has just started.
	EventTypeTouchBegin EventType = 17
	// EventTypeTouchUpdate: a touch event sequence has been updated.
	EventTypeTouchUpdate EventType = 18
	// EventTypeTouchEnd: a touch event sequence has finished.
	EventTypeTouchEnd EventType = 19
	// EventTypeTouchCancel: a touch event sequence has been canceled.
	EventTypeTouchCancel EventType = 20
	// EventTypeTouchpadSwipe: a touchpad swipe gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadSwipe EventType = 21
	// EventTypeTouchpadPinch: a touchpad pinch gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadPinch EventType = 22
	// EventTypePadButtonPress: a tablet pad button press event.
	EventTypePadButtonPress EventType = 23
	// EventTypePadButtonRelease: a tablet pad button release event.
	EventTypePadButtonRelease EventType = 24
	// EventTypePadRing: a tablet pad axis event from a "ring".
	EventTypePadRing EventType = 25
	// EventTypePadStrip: a tablet pad axis event from a "strip".
	EventTypePadStrip EventType = 26
	// EventTypePadGroupMode: a tablet pad group mode change.
	EventTypePadGroupMode EventType = 27
	// EventTypeEventLast marks the end of the GdkEventType enumeration.
	EventTypeEventLast EventType = 28
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FullscreenMode indicates which monitor a surface should span over when in
// fullscreen mode.
type FullscreenMode int

const (
	// FullscreenModeCurrentMonitor: fullscreen on current monitor only.
	FullscreenModeCurrentMonitor FullscreenMode = 0
	// FullscreenModeAllMonitors: span across all monitors when fullscreen.
	FullscreenModeAllMonitors FullscreenMode = 1
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLError: error enumeration for `GdkGLContext`.
type GLError int

const (
	// GLErrorNotAvailable: openGL support is not available
	GLErrorNotAvailable GLError = 0
	// GLErrorUnsupportedFormat: the requested visual format is not supported
	GLErrorUnsupportedFormat GLError = 1
	// GLErrorUnsupportedProfile: the requested profile is not supported
	GLErrorUnsupportedProfile GLError = 2
	// GLErrorCompilationFailed: the shader compilation failed
	GLErrorCompilationFailed GLError = 3
	// GLErrorLinkFailed: the shader linking failed
	GLErrorLinkFailed GLError = 4
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity defines the reference point of a surface and is used in PopupLayout.
type Gravity int

const (
	// GravityNorthWest: the reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: the reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: the reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: the reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: the reference point is at the center of the surface.
	GravityCenter Gravity = 5
	// GravityEast: the reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: the reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: the reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: the reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: the reference point is at the top left corner of the
	// surface itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputSource: an enumeration describing the type of an input device in general
// terms.
type InputSource int

const (
	// InputSourceMouse: the device is a mouse. (This will be reported for the
	// core pointer, even if it is something else, such as a trackball.)
	InputSourceMouse InputSource = 0
	// InputSourcePen: the device is a stylus of a graphics tablet or similar
	// device.
	InputSourcePen InputSource = 1
	// InputSourceKeyboard: the device is a keyboard.
	InputSourceKeyboard InputSource = 2
	// InputSourceTouchscreen: the device is a direct-input touch device, such
	// as a touchscreen or tablet
	InputSourceTouchscreen InputSource = 3
	// InputSourceTouchpad: the device is an indirect touch device, such as a
	// touchpad
	InputSourceTouchpad InputSource = 4
	// InputSourceTrackpoint: the device is a trackpoint
	InputSourceTrackpoint InputSource = 5
	// InputSourceTabletPad: the device is a "pad", a collection of buttons,
	// rings and strips found in drawing tablets
	InputSourceTabletPad InputSource = 6
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// KeyMatch describes how well an event matches a given keyval and modifiers.
//
// `GdkKeyMatch` values are returned by [method@Gdk.KeyEvent.matches].
type KeyMatch int

const (
	// KeyMatchNone: the key event does not match
	KeyMatchNone KeyMatch = 0
	// KeyMatchPartial: the key event matches if keyboard state (specifically,
	// the currently active group) is ignored
	KeyMatchPartial KeyMatch = 1
	// KeyMatchExact: the key event matches
	KeyMatchExact KeyMatch = 2
)

func marshalKeyMatch(p uintptr) (interface{}, error) {
	return KeyMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryFormat: `GdkMemoryFormat` describes a format that bytes can have in
// memory.
//
// It describes formats by listing the contents of the memory passed to it. So
// GDK_MEMORY_A8R8G8B8 will be 1 byte (8 bits) of alpha, followed by a byte each
// of red, green and blue. It is not endian-dependent, so CAIRO_FORMAT_ARGB32 is
// represented by different `GdkMemoryFormats` on architectures with different
// endiannesses.
//
// Its naming is modelled after VkFormat (see
// https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.htmlFormat for
// details).
type MemoryFormat int

const (
	// MemoryFormatB8G8R8A8Premultiplied: 4 bytes; for blue, green, red, alpha.
	// The color values are premultiplied with the alpha value.
	MemoryFormatB8G8R8A8Premultiplied MemoryFormat = 0
	// MemoryFormatA8R8G8B8Premultiplied: 4 bytes; for alpha, red, green, blue.
	// The color values are premultiplied with the alpha value.
	MemoryFormatA8R8G8B8Premultiplied MemoryFormat = 1
	// MemoryFormatR8G8B8A8Premultiplied: 4 bytes; for red, green, blue, alpha
	// The color values are premultiplied with the alpha value.
	MemoryFormatR8G8B8A8Premultiplied MemoryFormat = 2
	// MemoryFormatB8G8R8A8: 4 bytes; for blue, green, red, alpha.
	MemoryFormatB8G8R8A8 MemoryFormat = 3
	// MemoryFormatA8R8G8B8: 4 bytes; for alpha, red, green, blue.
	MemoryFormatA8R8G8B8 MemoryFormat = 4
	// MemoryFormatR8G8B8A8: 4 bytes; for red, green, blue, alpha.
	MemoryFormatR8G8B8A8 MemoryFormat = 5
	// MemoryFormatA8B8G8R8: 4 bytes; for alpha, blue, green, red.
	MemoryFormatA8B8G8R8 MemoryFormat = 6
	// MemoryFormatR8G8B8: 3 bytes; for red, green, blue. The data is opaque.
	MemoryFormatR8G8B8 MemoryFormat = 7
	// MemoryFormatB8G8R8: 3 bytes; for blue, green, red. The data is opaque.
	MemoryFormatB8G8R8 MemoryFormat = 8
	// MemoryFormatNFormats: the number of formats. This value will change as
	// more formats get added, so do not rely on its concrete integer.
	MemoryFormatNFormats MemoryFormat = 9
)

func marshalMemoryFormat(p uintptr) (interface{}, error) {
	return MemoryFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotifyType specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType int

const (
	// NotifyTypeAncestor: the surface is entered from an ancestor or left
	// towards an ancestor.
	NotifyTypeAncestor NotifyType = 0
	// NotifyTypeVirtual: the pointer moves between an ancestor and an inferior
	// of the surface.
	NotifyTypeVirtual NotifyType = 1
	// NotifyTypeInferior: the surface is entered from an inferior or left
	// towards an inferior.
	NotifyTypeInferior NotifyType = 2
	// NotifyTypeNonlinear: the surface is entered from or left towards a
	// surface which is neither an ancestor nor an inferior.
	NotifyTypeNonlinear NotifyType = 3
	// NotifyTypeNonlinearVirtual: the pointer moves between two surfaces which
	// are not ancestors of each other and the surface is part of the ancestor
	// chain between one of these surfaces and their least common ancestor.
	NotifyTypeNonlinearVirtual NotifyType = 4
	// NotifyTypeUnknown: an unknown type of enter/leave event occurred.
	NotifyTypeUnknown NotifyType = 5
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollDirection specifies the direction for scroll events.
type ScrollDirection int

const (
	// ScrollDirectionUp: the surface is scrolled up.
	ScrollDirectionUp ScrollDirection = 0
	// ScrollDirectionDown: the surface is scrolled down.
	ScrollDirectionDown ScrollDirection = 1
	// ScrollDirectionLeft: the surface is scrolled to the left.
	ScrollDirectionLeft ScrollDirection = 2
	// ScrollDirectionRight: the surface is scrolled to the right.
	ScrollDirectionRight ScrollDirection = 3
	// ScrollDirectionSmooth: the scrolling is determined by the delta values in
	// scroll events. See gdk_scroll_event_get_deltas()
	ScrollDirectionSmooth ScrollDirection = 4
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubpixelLayout: this enumeration describes how the red, green and blue
// components of physical pixels on an output device are laid out.
type SubpixelLayout int

const (
	// SubpixelLayoutUnknown: the layout is not known
	SubpixelLayoutUnknown SubpixelLayout = 0
	// SubpixelLayoutNone: not organized in this way
	SubpixelLayoutNone SubpixelLayout = 1
	// SubpixelLayoutHorizontalRGB: the layout is horizontal, the order is RGB
	SubpixelLayoutHorizontalRGB SubpixelLayout = 2
	// SubpixelLayoutHorizontalBGR: the layout is horizontal, the order is BGR
	SubpixelLayoutHorizontalBGR SubpixelLayout = 3
	// SubpixelLayoutVerticalRGB: the layout is vertical, the order is RGB
	SubpixelLayoutVerticalRGB SubpixelLayout = 4
	// SubpixelLayoutVerticalBGR: the layout is vertical, the order is BGR
	SubpixelLayoutVerticalBGR SubpixelLayout = 5
)

func marshalSubpixelLayout(p uintptr) (interface{}, error) {
	return SubpixelLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SurfaceEdge determines a surface edge or corner.
type SurfaceEdge int

const (
	// SurfaceEdgeNorthWest: the top left corner.
	SurfaceEdgeNorthWest SurfaceEdge = 0
	// SurfaceEdgeNorth: the top edge.
	SurfaceEdgeNorth SurfaceEdge = 1
	// SurfaceEdgeNorthEast: the top right corner.
	SurfaceEdgeNorthEast SurfaceEdge = 2
	// SurfaceEdgeWest: the left edge.
	SurfaceEdgeWest SurfaceEdge = 3
	// SurfaceEdgeEast: the right edge.
	SurfaceEdgeEast SurfaceEdge = 4
	// SurfaceEdgeSouthWest: the lower left corner.
	SurfaceEdgeSouthWest SurfaceEdge = 5
	// SurfaceEdgeSouth: the lower edge.
	SurfaceEdgeSouth SurfaceEdge = 6
	// SurfaceEdgeSouthEast: the lower right corner.
	SurfaceEdgeSouthEast SurfaceEdge = 7
)

func marshalSurfaceEdge(p uintptr) (interface{}, error) {
	return SurfaceEdge(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture.
//
// All gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
type TouchpadGesturePhase int

const (
	// TouchpadGesturePhaseBegin: the gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = 0
	// TouchpadGesturePhaseUpdate: the gesture has been updated.
	TouchpadGesturePhaseUpdate TouchpadGesturePhase = 1
	// TouchpadGesturePhaseEnd: the gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd TouchpadGesturePhase = 2
	// TouchpadGesturePhaseCancel: the gesture was cancelled, all changes should
	// be undone.
	TouchpadGesturePhaseCancel TouchpadGesturePhase = 3
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VulkanError: error enumeration for VulkanContext.
type VulkanError int

const (
	// VulkanErrorUnsupported: vulkan is not supported on this backend or has
	// not been compiled in.
	VulkanErrorUnsupported VulkanError = 0
	// VulkanErrorNotAvailable: vulkan support is not available on this Surface
	VulkanErrorNotAvailable VulkanError = 1
)

func marshalVulkanError(p uintptr) (interface{}, error) {
	return VulkanError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AnchorHints: positioning hints for aligning a surface relative to a
// rectangle.
//
// These hints determine how the surface should be positioned in the case that
// the surface would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the surface extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the surface can be shifted horizontally to fit
// on-screen. If GDK_ANCHOR_RESIZE_X is set, the surface can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints int

const (
	// AnchorHintsFlipX: allow flipping anchors horizontally
	AnchorHintsFlipX AnchorHints = 1
	// AnchorHintsFlipY: allow flipping anchors vertically
	AnchorHintsFlipY AnchorHints = 2
	// AnchorHintsSlideX: allow sliding surface horizontally
	AnchorHintsSlideX AnchorHints = 4
	// AnchorHintsSlideY: allow sliding surface vertically
	AnchorHintsSlideY AnchorHints = 8
	// AnchorHintsResizeX: allow resizing surface horizontally
	AnchorHintsResizeX AnchorHints = 16
	// AnchorHintsResizeY: allow resizing surface vertically
	AnchorHintsResizeY AnchorHints = 32
	// AnchorHintsFlip: allow flipping anchors on both axes
	AnchorHintsFlip AnchorHints = 3
	// AnchorHintsSlide: allow sliding surface on both axes
	AnchorHintsSlide AnchorHints = 12
	// AnchorHintsResize: allow resizing surface on both axes
	AnchorHintsResize AnchorHints = 48
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AxisFlags flags describing the current capabilities of a device/tool.
type AxisFlags int

const (
	// AxisFlagsX: x axis is present
	AxisFlagsX AxisFlags = 2
	// AxisFlagsY: y axis is present
	AxisFlagsY AxisFlags = 4
	// AxisFlagsDeltaX: scroll X delta axis is present
	AxisFlagsDeltaX AxisFlags = 8
	// AxisFlagsDeltaY: scroll Y delta axis is present
	AxisFlagsDeltaY AxisFlags = 16
	// AxisFlagsPressure: pressure axis is present
	AxisFlagsPressure AxisFlags = 32
	// AxisFlagsXtilt: x tilt axis is present
	AxisFlagsXtilt AxisFlags = 64
	// AxisFlagsYtilt: y tilt axis is present
	AxisFlagsYtilt AxisFlags = 128
	// AxisFlagsWheel: wheel axis is present
	AxisFlagsWheel AxisFlags = 256
	// AxisFlagsDistance: distance axis is present
	AxisFlagsDistance AxisFlags = 512
	// AxisFlagsRotation z-axis rotation is present
	AxisFlagsRotation AxisFlags = 1024
	// AxisFlagsSlider: slider axis is present
	AxisFlagsSlider AxisFlags = 2048
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in `GdkDrop` and `GdkDrag` to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction int

const (
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 1
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 2
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means, and is not supported on
	// all platforms.
	DragActionLink DragAction = 4
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 8
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FrameClockPhase: used to represent the different paint clock phases that can
// be requested.
//
// The elements of the enumeration correspond to the signals of `GdkFrameClock`.
type FrameClockPhase int

const (
	// FrameClockPhaseNone: no phase
	FrameClockPhaseNone FrameClockPhase = 0
	// FrameClockPhaseFlushEvents corresponds to GdkFrameClock::flush-events.
	// Should not be handled by applications.
	FrameClockPhaseFlushEvents FrameClockPhase = 1
	// FrameClockPhaseBeforePaint corresponds to GdkFrameClock::before-paint.
	// Should not be handled by applications.
	FrameClockPhaseBeforePaint FrameClockPhase = 2
	// FrameClockPhaseUpdate corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdate FrameClockPhase = 4
	// FrameClockPhaseLayout corresponds to GdkFrameClock::layout. Should not be
	// handled by applicatiosn.
	FrameClockPhaseLayout FrameClockPhase = 8
	// FrameClockPhasePaint corresponds to GdkFrameClock::paint.
	FrameClockPhasePaint FrameClockPhase = 16
	// FrameClockPhaseResumeEvents corresponds to GdkFrameClock::resume-events.
	// Should not be handled by applications.
	FrameClockPhaseResumeEvents FrameClockPhase = 32
	// FrameClockPhaseAfterPaint corresponds to GdkFrameClock::after-paint.
	// Should not be handled by applications.
	FrameClockPhaseAfterPaint FrameClockPhase = 64
)

func marshalFrameClockPhase(p uintptr) (interface{}, error) {
	return FrameClockPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierType flags to indicate the state of modifier keys and mouse buttons
// in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// GDK_MODIFIER_MASK to remove all private values.
type ModifierType int

const (
	// ModifierTypeShiftMask: the Shift key.
	ModifierTypeShiftMask ModifierType = 1
	// ModifierTypeLockMask: a Lock key (depending on the modifier mapping of
	// the X server this may either be CapsLock or ShiftLock).
	ModifierTypeLockMask ModifierType = 2
	// ModifierTypeControlMask: the Control key.
	ModifierTypeControlMask ModifierType = 4
	// ModifierTypeAltMask: the fourth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier, but
	// normally it is the Alt key).
	ModifierTypeAltMask ModifierType = 8
	// ModifierTypeButton1Mask: the first mouse button.
	ModifierTypeButton1Mask ModifierType = 256
	// ModifierTypeButton2Mask: the second mouse button.
	ModifierTypeButton2Mask ModifierType = 512
	// ModifierTypeButton3Mask: the third mouse button.
	ModifierTypeButton3Mask ModifierType = 1024
	// ModifierTypeButton4Mask: the fourth mouse button.
	ModifierTypeButton4Mask ModifierType = 2048
	// ModifierTypeButton5Mask: the fifth mouse button.
	ModifierTypeButton5Mask ModifierType = 4096
	// ModifierTypeSuperMask: the Super modifier
	ModifierTypeSuperMask ModifierType = 67108864
	// ModifierTypeHyperMask: the Hyper modifier
	ModifierTypeHyperMask ModifierType = 134217728
	// ModifierTypeMetaMask: the Meta modifier
	ModifierTypeMetaMask ModifierType = 268435456
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PaintableFlags flags about a paintable object.
//
// Implementations use these for optimizations such as caching.
type PaintableFlags int

const (
	// PaintableFlagsSize: the size is immutable. The
	// [signal@GdkPaintable::invalidate-size] signal will never be emitted.
	PaintableFlagsSize PaintableFlags = 1
	// PaintableFlagsContents: the content is immutable. The
	// [signal@GdkPaintable::invalidate-contents] signal will never be emitted.
	PaintableFlagsContents PaintableFlags = 2
)

func marshalPaintableFlags(p uintptr) (interface{}, error) {
	return PaintableFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SeatCapabilities flags describing the seat capabilities.
type SeatCapabilities int

const (
	// SeatCapabilitiesNone: no input capabilities
	SeatCapabilitiesNone SeatCapabilities = 0
	// SeatCapabilitiesPointer: the seat has a pointer (e.g. mouse)
	SeatCapabilitiesPointer SeatCapabilities = 1
	// SeatCapabilitiesTouch: the seat has touchscreen(s) attached
	SeatCapabilitiesTouch SeatCapabilities = 2
	// SeatCapabilitiesTabletStylus: the seat has drawing tablet(s) attached
	SeatCapabilitiesTabletStylus SeatCapabilities = 4
	// SeatCapabilitiesKeyboard: the seat has keyboard(s) attached
	SeatCapabilitiesKeyboard SeatCapabilities = 8
	// SeatCapabilitiesTabletPad: the seat has drawing tablet pad(s) attached
	SeatCapabilitiesTabletPad SeatCapabilities = 16
	// SeatCapabilitiesAllPointing: the union of all pointing capabilities
	SeatCapabilitiesAllPointing SeatCapabilities = 7
	// SeatCapabilitiesAll: the union of all capabilities
	SeatCapabilitiesAll SeatCapabilities = 15
)

func marshalSeatCapabilities(p uintptr) (interface{}, error) {
	return SeatCapabilities(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToplevelState specifies the state of a toplevel surface.
//
// On platforms that support information about individual edges, the
// GDK_TOPLEVEL_STATE_TILED state will be set whenever any of the individual
// tiled states is set. On platforms that lack that support, the tiled state
// will give an indication of tiledness without any of the per-edge states being
// set.
type ToplevelState int

const (
	// ToplevelStateMinimized: the surface is minimized
	ToplevelStateMinimized ToplevelState = 1
	// ToplevelStateMaximized: the surface is maximized
	ToplevelStateMaximized ToplevelState = 2
	// ToplevelStateSticky: the surface is sticky
	ToplevelStateSticky ToplevelState = 4
	// ToplevelStateFullscreen: the surface is maximized without decorations
	ToplevelStateFullscreen ToplevelState = 8
	// ToplevelStateAbove: the surface is kept above other surfaces
	ToplevelStateAbove ToplevelState = 16
	// ToplevelStateBelow: the surface is kept below other surfaces
	ToplevelStateBelow ToplevelState = 32
	// ToplevelStateFocused: the surface is presented as focused (with active
	// decorations)
	ToplevelStateFocused ToplevelState = 64
	// ToplevelStateTiled: the surface is in a tiled state
	ToplevelStateTiled ToplevelState = 128
	// ToplevelStateTopTiled: whether the top edge is tiled
	ToplevelStateTopTiled ToplevelState = 256
	// ToplevelStateTopResizable: whether the top edge is resizable
	ToplevelStateTopResizable ToplevelState = 512
	// ToplevelStateRightTiled: whether the right edge is tiled
	ToplevelStateRightTiled ToplevelState = 1024
	// ToplevelStateRightResizable: whether the right edge is resizable
	ToplevelStateRightResizable ToplevelState = 2048
	// ToplevelStateBottomTiled: whether the bottom edge is tiled
	ToplevelStateBottomTiled ToplevelState = 4096
	// ToplevelStateBottomResizable: whether the bottom edge is resizable
	ToplevelStateBottomResizable ToplevelState = 8192
	// ToplevelStateLeftTiled: whether the left edge is tiled
	ToplevelStateLeftTiled ToplevelState = 16384
	// ToplevelStateLeftResizable: whether the left edge is resizable
	ToplevelStateLeftResizable ToplevelState = 32768
)

func marshalToplevelState(p uintptr) (interface{}, error) {
	return ToplevelState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CairoDrawFromGL: the main way to draw GL content in GTK.
//
// It takes a render buffer ID (@source_type == RENDERBUFFER) or a texture id
// (@source_type == TEXTURE) and draws it onto @cr with an OVER operation,
// respecting the current clip. The top left corner of the rectangle specified
// by @x, @y, @width and @height will be drawn at the current (0,0) position of
// the `cairo_t`.
//
// This will work for *all* `cairo_t`, as long as @surface is realized, but the
// fallback implementation that reads back the pixels from the buffer may be
// used in the general case. In the case of direct drawing to a surface with no
// special effects applied to @cr it will however use a more efficient approach.
//
// For RENDERBUFFER the code will always fall back to software for buffers with
// alpha components, so make sure you use TEXTURE if using alpha.
//
// Calling this may change the current GL context.
func CairoDrawFromGL(cr *cairo.Context, surface Surface, source int, sourceType int, bufferScale int, x int, y int, width int, height int) {
	var _arg1 *C.cairo_t    // out
	var _arg2 *C.GdkSurface // out
	var _arg3 C.int         // out
	var _arg4 C.int         // out
	var _arg5 C.int         // out
	var _arg6 C.int         // out
	var _arg7 C.int         // out
	var _arg8 C.int         // out
	var _arg9 C.int         // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))
	_arg3 = C.int(source)
	_arg4 = C.int(sourceType)
	_arg5 = C.int(bufferScale)
	_arg6 = C.int(x)
	_arg7 = C.int(y)
	_arg8 = C.int(width)
	_arg9 = C.int(height)

	C.gdk_cairo_draw_from_gl(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
}

// CairoRectangle adds the given rectangle to the current path of @cr.
func CairoRectangle(cr *cairo.Context, rectangle *Rectangle) {
	var _arg1 *C.cairo_t      // out
	var _arg2 *C.GdkRectangle // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRectangle)(unsafe.Pointer(rectangle.Native()))

	C.gdk_cairo_rectangle(_arg1, _arg2)
}

// CairoRegion adds the given region to the current path of @cr.
func CairoRegion(cr *cairo.Context, region *cairo.Region) {
	var _arg1 *C.cairo_t        // out
	var _arg2 *C.cairo_region_t // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_cairo_region(_arg1, _arg2)
}

// CairoRegionCreateFromSurface creates region that covers the area where the
// given @surface is more than 50% opaque.
//
// This function takes into account device offsets that might be set with
// cairo_surface_set_device_offset().
func CairoRegionCreateFromSurface(surface *cairo.Surface) *cairo.Region {
	var _arg1 *C.cairo_surface_t // out
	var _cret *C.cairo_region_t  // in

	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	_cret = C.gdk_cairo_region_create_from_surface(_arg1)

	var _region *cairo.Region // out

	_region = (*cairo.Region)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_region, func(v **cairo.Region) {
		C.free(unsafe.Pointer(v))
	})

	return _region
}

// CairoSetSourcePixbuf sets the given pixbuf as the source pattern for @cr.
//
// The pattern has an extend mode of CAIRO_EXTEND_NONE and is aligned so that
// the origin of @pixbuf is @pixbuf_x, @pixbuf_y.
func CairoSetSourcePixbuf(cr *cairo.Context, pixbuf gdkpixbuf.Pixbuf, pixbufX float64, pixbufY float64) {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GdkPixbuf // out
	var _arg3 C.double     // out
	var _arg4 C.double     // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg3 = C.double(pixbufX)
	_arg4 = C.double(pixbufY)

	C.gdk_cairo_set_source_pixbuf(_arg1, _arg2, _arg3, _arg4)
}

// CairoSetSourceRGBA sets the specified RGBA as the source color of @cr.
func CairoSetSourceRGBA(cr *cairo.Context, rgba *RGBA) {
	var _arg1 *C.cairo_t // out
	var _arg2 *C.GdkRGBA // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	C.gdk_cairo_set_source_rgba(_arg1, _arg2)
}

// ContentDeserializeFinish finishes a content deserialization operation.
func ContentDeserializeFinish(result gio.AsyncResult, value externglib.Value) error {
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.GValue       // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gdk_content_deserialize_finish(_arg1, _arg2, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ContentSerializeFinish finishes a content serialization operation.
func ContentSerializeFinish(result gio.AsyncResult) error {
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.gdk_content_serialize_finish(_arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// EventsGetAngle returns the relative angle from @event1 to @event2.
//
// The relative angle is the angle between the X axis and the line through both
// events' positions. The rotation direction for positive angles is from the
// positive X axis towards the positive Y axis.
//
// This assumes that both events have X/Y information. If not, this function
// returns false.
func EventsGetAngle(event1 Event, event2 Event) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event1.Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(event2.Native()))

	_cret = C.gdk_events_get_angle(_arg1, _arg2, &_arg3)

	var _angle float64 // out
	var _ok bool       // out

	_angle = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _angle, _ok
}

// EventsGetCenter returns the point halfway between the events' positions.
//
// This assumes that both events have X/Y information. If not, this function
// returns false.
func EventsGetCenter(event1 Event, event2 Event) (x float64, y float64, ok bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _arg4 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event1.Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(event2.Native()))

	_cret = C.gdk_events_get_center(_arg1, _arg2, &_arg3, &_arg4)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg3)
	_y = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// EventsGetDistance returns the distance between the event locations.
//
// This assumes that both events have X/Y information. If not, this function
// returns false.
func EventsGetDistance(event1 Event, event2 Event) (float64, bool) {
	var _arg1 *C.GdkEvent // out
	var _arg2 *C.GdkEvent // out
	var _arg3 C.double    // in
	var _cret C.gboolean  // in

	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event1.Native()))
	_arg2 = (*C.GdkEvent)(unsafe.Pointer(event2.Native()))

	_cret = C.gdk_events_get_distance(_arg1, _arg2, &_arg3)

	var _distance float64 // out
	var _ok bool          // out

	_distance = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _distance, _ok
}

// InternMIMEType canonicalizes the given mime type and interns the result.
//
// If @string is not a valid mime type, nil is returned instead. See RFC 2048
// for the syntax if mime types.
func InternMIMEType(_string string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(C.CString(_string))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_intern_mime_type(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// KeyvalConvertCase obtains the upper- and lower-case versions of the keyval
// @symbol.
//
// Examples of keyvals are K_KEY_a, K_KEY_Enter, K_KEY_F1, etc.
func KeyvalConvertCase(symbol uint) (lower uint, upper uint) {
	var _arg1 C.guint // out
	var _arg2 C.guint // in
	var _arg3 C.guint // in

	_arg1 = C.guint(symbol)

	C.gdk_keyval_convert_case(_arg1, &_arg2, &_arg3)

	var _lower uint // out
	var _upper uint // out

	_lower = uint(_arg2)
	_upper = uint(_arg3)

	return _lower, _upper
}

// KeyvalFromName converts a key name to a key value.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalFromName(keyvalName string) uint {
	var _arg1 *C.char // out
	var _cret C.guint // in

	_arg1 = (*C.char)(C.CString(keyvalName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_keyval_from_name(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalIsLower returns true if the given key value is in lower case.
func KeyvalIsLower(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_lower(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalIsUpper returns true if the given key value is in upper case.
func KeyvalIsUpper(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_upper(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalName converts a key value into a symbolic name.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalName(keyval uint) string {
	var _arg1 C.guint // out
	var _cret *C.char // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// KeyvalToLower converts a key value to lower case, if applicable.
func KeyvalToLower(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_lower(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding Unicode
// character.
//
// Note that the conversion does not take the current locale into consideration,
// which might be expected for particular keyvals, such as GDK_KEY_KP_Decimal.
func KeyvalToUnicode(keyval uint) uint32 {
	var _arg1 C.guint   // out
	var _cret C.guint32 // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_unicode(_arg1)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// KeyvalToUpper converts a key value to upper case, if applicable.
func KeyvalToUpper(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_upper(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PixbufGetFromSurface transfers image data from a `cairo_surface_t` and
// converts it to a `GdkPixbuf`.
//
// This allows you to efficiently read individual pixels from cairo surfaces.
//
// This function will create an RGB pixbuf with 8 bits per channel. The pixbuf
// will contain an alpha channel if the @surface contains one.
func PixbufGetFromSurface(surface *cairo.Surface, srcX int, srcY int, width int, height int) gdkpixbuf.Pixbuf {
	var _arg1 *C.cairo_surface_t // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _arg4 C.int              // out
	var _arg5 C.int              // out
	var _cret *C.GdkPixbuf       // in

	_arg1 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))
	_arg2 = C.int(srcX)
	_arg3 = C.int(srcY)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	_cret = C.gdk_pixbuf_get_from_surface(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// PixbufGetFromTexture creates a new pixbuf from @texture.
//
// This should generally not be used in newly written code as later stages will
// almost certainly convert the pixbuf back into a texture to draw it on screen.
func PixbufGetFromTexture(texture Texture) gdkpixbuf.Pixbuf {
	var _arg1 *C.GdkTexture // out
	var _cret *C.GdkPixbuf  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))

	_cret = C.gdk_pixbuf_get_from_texture(_arg1)

	var _pixbuf gdkpixbuf.Pixbuf // out

	_pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdkpixbuf.Pixbuf)

	return _pixbuf
}

// SetAllowedBackends sets a list of backends that GDK should try to use.
//
// This can be useful if your application does not work with certain GDK
// backends.
//
// By default, GDK tries all included backends.
//
// For example:
//
// “`c gdk_set_allowed_backends ("wayland,macos,*"); “`
//
// instructs GDK to try the Wayland backend first, followed by the MacOs
// backend, and then all others.
//
// If the `GDK_BACKEND` environment variable is set, it determines what backends
// are tried in what order, while still respecting the set of allowed backends
// that are specified by this function.
//
// The possible backend names are:
//
//    - `broadway`
//    - `macos`
//    - `wayland`.
//    - `win32`
//    - `x11`
//
// You can also include a `*` in the list to try all remaining backends.
//
// This call must happen prior to functions that open a display, such as
// [func@Gdk.Display.open], `gtk_init()`, or `gtk_init_check()` in order to take
// effect.
func SetAllowedBackends(backends string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(C.CString(backends))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_set_allowed_backends(_arg1)
}

func ToplevelSizeGetType() externglib.Type {
	var _cret C.GType // in

	_cret = C.gdk_toplevel_size_get_type()

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// UnicodeToKeyval: convert from a Unicode character to a key symbol.
func UnicodeToKeyval(wc uint32) uint {
	var _arg1 C.guint32 // out
	var _cret C.guint   // in

	_arg1 = C.guint32(wc)

	_cret = C.gdk_unicode_to_keyval(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DevicePad: `GdkDevicePad` is an interface implemented by devices of type
// GDK_SOURCE_TABLET_PAD
//
// It allows querying the features provided by the pad device.
//
// Tablet pads may contain one or more groups, each containing a subset of the
// buttons/rings/strips available. [method@Gdk.DevicePad.get_n_groups] can be
// used to obtain the number of groups, [method@Gdk.DevicePad.get_n_features]
// and [method@Gdk.DevicePad.get_feature_group] can be combined to find out the
// number of buttons/rings/strips the device has, and how are they grouped.
//
// Each of those groups have different modes, which may be used to map each
// individual pad feature to multiple actions. Only one mode is effective
// (current) for each given group, different groups may have different current
// modes. The number of available modes in a group can be found out through
// [method@Gdk.DevicePad.get_group_n_modes], and the current mode for a given
// group will be notified through events of type K_PAD_GROUP_MODE.
type DevicePad interface {
	Device

	// FeatureGroup returns the group the given @feature and @idx belong to.
	//
	// f the feature or index do not exist in @pad, -1 is returned.
	FeatureGroup(feature DevicePadFeature, featureIdx int) int
	// GroupNModes returns the number of modes that @group may have.
	GroupNModes(groupIdx int) int
	// NFeatures returns the number of features a tablet pad has.
	NFeatures(feature DevicePadFeature) int
	// NGroups returns the number of groups this pad device has.
	//
	// Pads have at least one group. A pad group is a subcollection of
	// buttons/strip/rings that is affected collectively by a same current mode.
	NGroups() int
}

// devicePad implements the DevicePad interface.
type devicePad struct {
	Device
}

var _ DevicePad = (*devicePad)(nil)

// WrapDevicePad wraps a GObject to a type that implements
// interface DevicePad. It is primarily used internally.
func WrapDevicePad(obj *externglib.Object) DevicePad {
	return devicePad{
		Device: WrapDevice(obj),
	}
}

func marshalDevicePad(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDevicePad(obj), nil
}

func (p devicePad) FeatureGroup(feature DevicePadFeature, featureIdx int) int {
	var _arg0 *C.GdkDevicePad       // out
	var _arg1 C.GdkDevicePadFeature // out
	var _arg2 C.int                 // out
	var _cret C.int                 // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(p.Native()))
	_arg1 = C.GdkDevicePadFeature(feature)
	_arg2 = C.int(featureIdx)

	_cret = C.gdk_device_pad_get_feature_group(_arg0, _arg1, _arg2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p devicePad) GroupNModes(groupIdx int) int {
	var _arg0 *C.GdkDevicePad // out
	var _arg1 C.int           // out
	var _cret C.int           // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(p.Native()))
	_arg1 = C.int(groupIdx)

	_cret = C.gdk_device_pad_get_group_n_modes(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p devicePad) NFeatures(feature DevicePadFeature) int {
	var _arg0 *C.GdkDevicePad       // out
	var _arg1 C.GdkDevicePadFeature // out
	var _cret C.int                 // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(p.Native()))
	_arg1 = C.GdkDevicePadFeature(feature)

	_cret = C.gdk_device_pad_get_n_features(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p devicePad) NGroups() int {
	var _arg0 *C.GdkDevicePad // out
	var _cret C.int           // in

	_arg0 = (*C.GdkDevicePad)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_device_pad_get_n_groups(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DragSurface: a DragSurface is an interface for surfaces used during DND.
type DragSurface interface {
	Surface

	// Present: present @drag_surface.
	Present(width int, height int) bool
}

// dragSurface implements the DragSurface interface.
type dragSurface struct {
	Surface
}

var _ DragSurface = (*dragSurface)(nil)

// WrapDragSurface wraps a GObject to a type that implements
// interface DragSurface. It is primarily used internally.
func WrapDragSurface(obj *externglib.Object) DragSurface {
	return dragSurface{
		Surface: WrapSurface(obj),
	}
}

func marshalDragSurface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragSurface(obj), nil
}

func (d dragSurface) Present(width int, height int) bool {
	var _arg0 *C.GdkDragSurface // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDragSurface)(unsafe.Pointer(d.Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	_cret = C.gdk_drag_surface_present(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PaintableOverrider contains methods that are overridable. This
// interface is a subset of the interface Paintable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type PaintableOverrider interface {
	// CurrentImage gets an immutable paintable for the current contents
	// displayed by @paintable.
	//
	// This is useful when you want to retain the current state of an animation,
	// for example to take a screenshot of a running animation.
	//
	// If the @paintable is already immutable, it will return itself.
	CurrentImage() Paintable
	// Flags: get flags for the paintable.
	//
	// This is oftentimes useful for optimizations.
	//
	// See [flags@Gdk.PaintableFlags] for the flags and what they mean.
	Flags() PaintableFlags
	// IntrinsicAspectRatio gets the preferred aspect ratio the @paintable would
	// like to be displayed at.
	//
	// The aspect ratio is the width divided by the height, so a value of 0.5
	// means that the @paintable prefers to be displayed twice as high as it is
	// wide. Consumers of this interface can use this to preserve aspect ratio
	// when displaying the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// Usually when a @paintable returns nonzero values from
	// [method@Gdk.Paintable.get_intrinsic_width] and
	// [method@Gdk.Paintable.get_intrinsic_height] the aspect ratio should
	// conform to those values, though that is not required.
	//
	// If the @paintable does not have a preferred aspect ratio, it returns 0.
	// Negative values are never returned.
	IntrinsicAspectRatio() float64
	// IntrinsicHeight gets the preferred height the @paintable would like to be
	// displayed at.
	//
	// Consumers of this interface can use this to reserve enough space to draw
	// the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// If the @paintable does not have a preferred height, it returns 0.
	// Negative values are never returned.
	IntrinsicHeight() int
	// IntrinsicWidth gets the preferred width the @paintable would like to be
	// displayed at.
	//
	// Consumers of this interface can use this to reserve enough space to draw
	// the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// If the @paintable does not have a preferred width, it returns 0. Negative
	// values are never returned.
	IntrinsicWidth() int
	// Snapshot snapshots the given paintable with the given @width and @height.
	//
	// The paintable is drawn at the current (0,0) offset of the @snapshot. If
	// @width and @height are not larger than zero, this function will do
	// nothing.
	Snapshot(snapshot Snapshot, width float64, height float64)
}

// Paintable: `GdkPaintable` is a simple interface used by GTK to represent
// content that can be painted.
//
// The content of a `GdkPaintable` can be painted anywhere at any size without
// requiring any sort of layout. The interface is inspired by similar concepts
// elsewhere, such as ClutterContent
// (https://developer.gnome.org/clutter/stable/ClutterContent.html), HTML/CSS
// Paint Sources (https://www.w3.org/TR/css-images-4/#paint-source), or SVG
// Paint Servers (https://www.w3.org/TR/SVG2/pservers.html).
//
// A `GdkPaintable` can be snapshot at any time and size using
// [method@Gdk.Paintable.snapshot]. How the paintable interprets that size and
// if it scales or centers itself into the given rectangle is implementation
// defined, though if you are implementing a `GdkPaintable` and don't know what
// to do, it is suggested that you scale your paintable ignoring any potential
// aspect ratio.
//
// The contents that a `GdkPaintable` produces may depend on the
// [class@GdkSnapshot] passed to it. For example, paintables may decide to use
// more detailed images on higher resolution screens or when OpenGL is
// available. A `GdkPaintable` will however always produce the same output for
// the same snapshot.
//
// A `GdkPaintable` may change its contents, meaning that it will now produce a
// different output with the same snapshot. Once that happens, it will call
// [method@Gdk.Paintable.invalidate_contents] which will emit the
// [signal@GdkPaintable::invalidate-contents] signal. If a paintable is known to
// never change its contents, it will set the GDK_PAINTABLE_STATIC_CONTENTS
// flag. If a consumer cannot deal with changing contents, it may call
// [method@Gdk.Paintable.get_current_image] which will return a static paintable
// and use that.
//
// A paintable can report an intrinsic (or preferred) size or aspect ratio it
// wishes to be rendered at, though it doesn't have to. Consumers of the
// interface can use this information to layout thepaintable appropriately. Just
// like the contents, the size of a paintable can change. A paintable will
// indicate this by calling [method@Gdk.Paintable.invalidate_size] which will
// emit the [signal@GdkPaintable::invalidate-size] signal. And just like for
// contents, if a paintable is known to never change its size, it will set the
// GDK_PAINTABLE_STATIC_SIZE flag.
//
// Besides API for applications, there are some functions that are only useful
// for implementing subclasses and should not be used by applications:
// [method@Gdk.Paintable.invalidate_contents],
// [method@Gdk.Paintable.invalidate_size], [func@Gdk.Paintable.new_empty].
type Paintable interface {
	gextras.Objector

	// ComputeConcreteSize: compute a concrete size for the `GdkPaintable`.
	//
	// Applies the sizing algorithm outlined in the CSS Image spec
	// (https://drafts.csswg.org/css-images-3/#default-sizing) to the given
	// @paintable. See that link for more details.
	//
	// It is not necessary to call this function when both @specified_width and
	// @specified_height are known, but it is useful to call this function in
	// GtkWidget:measure implementations to compute the other dimension when
	// only one dimension is given.
	ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (concreteWidth float64, concreteHeight float64)
	// CurrentImage gets an immutable paintable for the current contents
	// displayed by @paintable.
	//
	// This is useful when you want to retain the current state of an animation,
	// for example to take a screenshot of a running animation.
	//
	// If the @paintable is already immutable, it will return itself.
	CurrentImage() Paintable
	// Flags: get flags for the paintable.
	//
	// This is oftentimes useful for optimizations.
	//
	// See [flags@Gdk.PaintableFlags] for the flags and what they mean.
	Flags() PaintableFlags
	// IntrinsicAspectRatio gets the preferred aspect ratio the @paintable would
	// like to be displayed at.
	//
	// The aspect ratio is the width divided by the height, so a value of 0.5
	// means that the @paintable prefers to be displayed twice as high as it is
	// wide. Consumers of this interface can use this to preserve aspect ratio
	// when displaying the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// Usually when a @paintable returns nonzero values from
	// [method@Gdk.Paintable.get_intrinsic_width] and
	// [method@Gdk.Paintable.get_intrinsic_height] the aspect ratio should
	// conform to those values, though that is not required.
	//
	// If the @paintable does not have a preferred aspect ratio, it returns 0.
	// Negative values are never returned.
	IntrinsicAspectRatio() float64
	// IntrinsicHeight gets the preferred height the @paintable would like to be
	// displayed at.
	//
	// Consumers of this interface can use this to reserve enough space to draw
	// the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// If the @paintable does not have a preferred height, it returns 0.
	// Negative values are never returned.
	IntrinsicHeight() int
	// IntrinsicWidth gets the preferred width the @paintable would like to be
	// displayed at.
	//
	// Consumers of this interface can use this to reserve enough space to draw
	// the paintable.
	//
	// This is a purely informational value and does not in any way limit the
	// values that may be passed to [method@Gdk.Paintable.snapshot].
	//
	// If the @paintable does not have a preferred width, it returns 0. Negative
	// values are never returned.
	IntrinsicWidth() int
	// InvalidateContents: called by implementations of `GdkPaintable` to
	// invalidate their contents.
	//
	// Unless the contents are invalidated, implementations must guarantee that
	// multiple calls of [method@Gdk.Paintable.snapshot] produce the same
	// output.
	//
	// This function will emit the [signal@Gdk.Paintable::invalidate-contents]
	// signal.
	//
	// If a @paintable reports the GDK_PAINTABLE_STATIC_CONTENTS flag, it must
	// not call this function.
	InvalidateContents()
	// InvalidateSize: called by implementations of `GdkPaintable` to invalidate
	// their size.
	//
	// As long as the size is not invalidated, @paintable must return the same
	// values for its intrinsic width, height and aspect ratio.
	//
	// This function will emit the [signal@Gdk.Paintable::invalidate-size]
	// signal.
	//
	// If a @paintable reports the GDK_PAINTABLE_STATIC_SIZE flag, it must not
	// call this function.
	InvalidateSize()
	// Snapshot snapshots the given paintable with the given @width and @height.
	//
	// The paintable is drawn at the current (0,0) offset of the @snapshot. If
	// @width and @height are not larger than zero, this function will do
	// nothing.
	Snapshot(snapshot Snapshot, width float64, height float64)
}

// paintable implements the Paintable interface.
type paintable struct {
	gextras.Objector
}

var _ Paintable = (*paintable)(nil)

// WrapPaintable wraps a GObject to a type that implements
// interface Paintable. It is primarily used internally.
func WrapPaintable(obj *externglib.Object) Paintable {
	return paintable{
		Objector: obj,
	}
}

func marshalPaintable(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPaintable(obj), nil
}

func (p paintable) ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (concreteWidth float64, concreteHeight float64) {
	var _arg0 *C.GdkPaintable // out
	var _arg1 C.double        // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _arg5 C.double        // in
	var _arg6 C.double        // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))
	_arg1 = C.double(specifiedWidth)
	_arg2 = C.double(specifiedHeight)
	_arg3 = C.double(defaultWidth)
	_arg4 = C.double(defaultHeight)

	C.gdk_paintable_compute_concrete_size(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

	var _concreteWidth float64  // out
	var _concreteHeight float64 // out

	_concreteWidth = float64(_arg5)
	_concreteHeight = float64(_arg6)

	return _concreteWidth, _concreteHeight
}

func (p paintable) CurrentImage() Paintable {
	var _arg0 *C.GdkPaintable // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_paintable_get_current_image(_arg0)

	var _ret Paintable // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Paintable)

	return _ret
}

func (p paintable) Flags() PaintableFlags {
	var _arg0 *C.GdkPaintable     // out
	var _cret C.GdkPaintableFlags // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_paintable_get_flags(_arg0)

	var _paintableFlags PaintableFlags // out

	_paintableFlags = PaintableFlags(_cret)

	return _paintableFlags
}

func (p paintable) IntrinsicAspectRatio() float64 {
	var _arg0 *C.GdkPaintable // out
	var _cret C.double        // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_paintable_get_intrinsic_aspect_ratio(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

func (p paintable) IntrinsicHeight() int {
	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_paintable_get_intrinsic_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p paintable) IntrinsicWidth() int {
	var _arg0 *C.GdkPaintable // out
	var _cret C.int           // in

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_paintable_get_intrinsic_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p paintable) InvalidateContents() {
	var _arg0 *C.GdkPaintable // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	C.gdk_paintable_invalidate_contents(_arg0)
}

func (p paintable) InvalidateSize() {
	var _arg0 *C.GdkPaintable // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))

	C.gdk_paintable_invalidate_size(_arg0)
}

func (p paintable) Snapshot(snapshot Snapshot, width float64, height float64) {
	var _arg0 *C.GdkPaintable // out
	var _arg1 *C.GdkSnapshot  // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out

	_arg0 = (*C.GdkPaintable)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GdkSnapshot)(unsafe.Pointer(snapshot.Native()))
	_arg2 = C.double(width)
	_arg3 = C.double(height)

	C.gdk_paintable_snapshot(_arg0, _arg1, _arg2, _arg3)
}

// Popup: a `GdkPopup` is a surface that is attached to another surface.
//
// The `GdkPopup` is positioned relative to its parent surface.
//
// `GdkPopup`s are typically used to implement menus and similar popups. They
// can be modal, which is indicated by the [property@GdkPopup:autohide]
// property.
type Popup interface {
	Surface

	// Autohide returns whether this popup is set to hide on outside clicks.
	Autohide() bool
	// Parent returns the parent surface of a popup.
	Parent() Surface
	// PositionX obtains the position of the popup relative to its parent.
	PositionX() int
	// PositionY obtains the position of the popup relative to its parent.
	PositionY() int
	// RectAnchor gets the current popup rectangle anchor.
	//
	// The value returned may change after calling [method@Gdk.Popup.present],
	// or after the [signal@Gdk.Surface::layout] signal is emitted.
	RectAnchor() Gravity
	// SurfaceAnchor gets the current popup surface anchor.
	//
	// The value returned may change after calling [method@Gdk.Popup.present],
	// or after the [signal@Gdk.Surface::layout] signal is emitted.
	SurfaceAnchor() Gravity
	// Present: present @popup after having processed the PopupLayout rules.
	//
	// If the popup was previously now showing, it will be showed, otherwise it
	// will change position according to @layout.
	//
	// After calling this function, the result should be handled in response to
	// the [signal@GdkSurface::layout] signal being emitted. The resulting popup
	// position can be queried using [method@Gdk.Popup.get_position_x],
	// [method@Gdk.Popup.get_position_y], and the resulting size will be sent as
	// parameters in the layout signal. Use [method@Gdk.Popup.get_rect_anchor]
	// and [method@Gdk.Popup.get_surface_anchor] to get the resulting anchors.
	//
	// Presenting may fail, for example if the @popup is set to autohide and is
	// immediately hidden upon being presented. If presenting failed, the
	// [signal@Gdk.Surface::layout] signal will not me emitted.
	Present(width int, height int, layout *PopupLayout) bool
}

// popup implements the Popup interface.
type popup struct {
	Surface
}

var _ Popup = (*popup)(nil)

// WrapPopup wraps a GObject to a type that implements
// interface Popup. It is primarily used internally.
func WrapPopup(obj *externglib.Object) Popup {
	return popup{
		Surface: WrapSurface(obj),
	}
}

func marshalPopup(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPopup(obj), nil
}

func (p popup) Autohide() bool {
	var _arg0 *C.GdkPopup // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_autohide(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p popup) Parent() Surface {
	var _arg0 *C.GdkPopup   // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_parent(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (p popup) PositionX() int {
	var _arg0 *C.GdkPopup // out
	var _cret C.int       // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_position_x(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p popup) PositionY() int {
	var _arg0 *C.GdkPopup // out
	var _cret C.int       // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_position_y(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (p popup) RectAnchor() Gravity {
	var _arg0 *C.GdkPopup  // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_rect_anchor(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

func (p popup) SurfaceAnchor() Gravity {
	var _arg0 *C.GdkPopup  // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_popup_get_surface_anchor(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

func (p popup) Present(width int, height int, layout *PopupLayout) bool {
	var _arg0 *C.GdkPopup       // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _arg3 *C.GdkPopupLayout // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkPopup)(unsafe.Pointer(p.Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = (*C.GdkPopupLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.gdk_popup_present(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Toplevel: a `GdkToplevel` is a freestanding toplevel surface.
//
// The `GdkToplevel` interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
type Toplevel interface {
	Surface

	// BeginMove begins an interactive move operation.
	//
	// You might use this function to implement draggable titlebars.
	BeginMove(device Device, button int, x float64, y float64, timestamp uint32)
	// BeginResize begins an interactive resize operation.
	//
	// You might use this function to implement a “window resize grip.”
	BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32)
	// Focus sets keyboard focus to @surface.
	//
	// In most cases, [method@Gtk.Window.present_with_time] should be used on a
	// [class@Gtk.Window], rather than calling this function.
	Focus(timestamp uint32)
	// State gets the bitwise or of the currently active surface state flags,
	// from the `GdkToplevelState` enumeration.
	State() ToplevelState
	// InhibitSystemShortcuts requests that the @toplevel inhibit the system
	// shortcuts.
	//
	// This is asking the desktop environment/windowing system to let all
	// keyboard events reach the surface, as long as it is focused, instead of
	// triggering system actions.
	//
	// If granted, the rerouting remains active until the default shortcuts
	// processing is restored with
	// [method@Gdk.Toplevel.restore_system_shortcuts], or the request is revoked
	// by the desktop environment, windowing system or the user.
	//
	// A typical use case for this API is remote desktop or virtual machine
	// viewers which need to inhibit the default system keyboard shortcuts so
	// that the remote session or virtual host gets those instead of the local
	// environment.
	//
	// The windowing system or desktop environment may ask the user to grant or
	// deny the request or even choose to ignore the request entirely.
	//
	// The caller can be notified whenever the request is granted or revoked by
	// listening to the [property@Gdk.Toplevel:shortcuts-inhibited] property.
	InhibitSystemShortcuts(event Event)
	// Lower asks to lower the @toplevel below other windows.
	//
	// The windowing system may choose to ignore the request.
	Lower() bool
	// Minimize asks to minimize the @toplevel.
	//
	// The windowing system may choose to ignore the request.
	Minimize() bool
	// Present: present @toplevel after having processed the `GdkToplevelLayout`
	// rules.
	//
	// If the toplevel was previously not showing, it will be showed, otherwise
	// it will change layout according to @layout.
	//
	// GDK may emit the [signal@Gdk.Toplevel::compute-size] signal to let the
	// user of this toplevel compute the preferred size of the toplevel surface.
	//
	// Presenting is asynchronous and the specified layout parameters are not
	// guaranteed to be respected.
	Present(layout *ToplevelLayout)
	// RestoreSystemShortcuts: restore default system keyboard shortcuts which
	// were previously inhibited.
	//
	// This undoes the effect of [method@Gdk.Toplevel.inhibit_system_shortcuts].
	RestoreSystemShortcuts()
	// SetDecorated sets the toplevel to be decorated.
	//
	// Setting @decorated to false hints the desktop environment that the
	// surface has its own, client-side decorations and does not need to have
	// window decorations added.
	SetDecorated(decorated bool)
	// SetDeletable sets the toplevel to be deletable.
	//
	// Setting @deletable to true hints the desktop environment that it should
	// offer the user a way to close the surface.
	SetDeletable(deletable bool)
	// SetModal sets the toplevel to be modal.
	//
	// The application can use this hint to tell the window manager that a
	// certain surface has modal behaviour. The window manager can use this
	// information to handle modal surfaces in a special way.
	//
	// You should only use this on surfaces for which you have previously called
	// [method@Gdk.Toplevel.set_transient_for].
	SetModal(modal bool)
	// SetStartupID sets the startup notification ID.
	//
	// When using GTK, typically you should use
	// [method@Gtk.Window.set_startup_id] instead of this low-level function.
	SetStartupID(startupId string)
	// SetTitle sets the title of a toplevel surface.
	//
	// The title maybe be displayed in the titlebar, in lists of windows, etc.
	SetTitle(title string)
	// SetTransientFor sets a transient-for parent.
	//
	// Indicates to the window manager that @surface is a transient dialog
	// associated with the application surface @parent. This allows the window
	// manager to do things like center @surface on @parent and keep @surface
	// above @parent.
	//
	// See [method@Gtk.Window.set_transient_for] if you’re using
	// [class@Gtk.Window] or [class@Gtk.Dialog].
	SetTransientFor(parent Surface)
	// ShowWindowMenu asks the windowing system to show the window menu.
	//
	// The window menu is the menu shown when right-clicking the titlebar on
	// traditional windows managed by the window manager. This is useful for
	// windows using client-side decorations, activating it with a right-click
	// on the window decorations.
	ShowWindowMenu(event Event) bool
	// SupportsEdgeConstraints returns whether the desktop environment supports
	// tiled window states.
	SupportsEdgeConstraints() bool
}

// toplevel implements the Toplevel interface.
type toplevel struct {
	Surface
}

var _ Toplevel = (*toplevel)(nil)

// WrapToplevel wraps a GObject to a type that implements
// interface Toplevel. It is primarily used internally.
func WrapToplevel(obj *externglib.Object) Toplevel {
	return toplevel{
		Surface: WrapSurface(obj),
	}
}

func marshalToplevel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToplevel(obj), nil
}

func (t toplevel) BeginMove(device Device, button int, x float64, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.int          // out
	var _arg3 C.double       // out
	var _arg4 C.double       // out
	var _arg5 C.guint32      // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg2 = C.int(button)
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.guint32(timestamp)

	C.gdk_toplevel_begin_move(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (t toplevel) BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel   // out
	var _arg1 C.GdkSurfaceEdge // out
	var _arg2 *C.GdkDevice     // out
	var _arg3 C.int            // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.guint32        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = C.GdkSurfaceEdge(edge)
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg3 = C.int(button)
	_arg4 = C.double(x)
	_arg5 = C.double(y)
	_arg6 = C.guint32(timestamp)

	C.gdk_toplevel_begin_resize(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

func (t toplevel) Focus(timestamp uint32) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.guint32      // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = C.guint32(timestamp)

	C.gdk_toplevel_focus(_arg0, _arg1)
}

func (t toplevel) State() ToplevelState {
	var _arg0 *C.GdkToplevel     // out
	var _cret C.GdkToplevelState // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_toplevel_get_state(_arg0)

	var _toplevelState ToplevelState // out

	_toplevelState = ToplevelState(_cret)

	return _toplevelState
}

func (t toplevel) InhibitSystemShortcuts(event Event) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkEvent    // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	C.gdk_toplevel_inhibit_system_shortcuts(_arg0, _arg1)
}

func (t toplevel) Lower() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_toplevel_lower(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t toplevel) Minimize() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_toplevel_minimize(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t toplevel) Present(layout *ToplevelLayout) {
	var _arg0 *C.GdkToplevel       // out
	var _arg1 *C.GdkToplevelLayout // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkToplevelLayout)(unsafe.Pointer(layout.Native()))

	C.gdk_toplevel_present(_arg0, _arg1)
}

func (t toplevel) RestoreSystemShortcuts() {
	var _arg0 *C.GdkToplevel // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	C.gdk_toplevel_restore_system_shortcuts(_arg0)
}

func (t toplevel) SetDecorated(decorated bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if decorated {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_decorated(_arg0, _arg1)
}

func (t toplevel) SetDeletable(deletable bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if deletable {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_deletable(_arg0, _arg1)
}

func (t toplevel) SetModal(modal bool) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_set_modal(_arg0, _arg1)
}

func (t toplevel) SetStartupID(startupId string) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_startup_id(_arg0, _arg1)
}

func (t toplevel) SetTitle(title string) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_title(_arg0, _arg1)
}

func (t toplevel) SetTransientFor(parent Surface) {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkSurface  // out

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(parent.Native()))

	C.gdk_toplevel_set_transient_for(_arg0, _arg1)
}

func (t toplevel) ShowWindowMenu(event Event) bool {
	var _arg0 *C.GdkToplevel // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	_cret = C.gdk_toplevel_show_window_menu(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (t toplevel) SupportsEdgeConstraints() bool {
	var _arg0 *C.GdkToplevel // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_toplevel_supports_edge_constraints(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppLaunchContext: `GdkAppLaunchContext` handles launching an application in a
// graphical context.
//
// It is an implementation of `GAppLaunchContext` that provides startup
// notification and allows to launch applications on a specific screen or
// workspace.
//
//
// Launching an application
//
// “`c GdkAppLaunchContext *context;
//
// context = gdk_display_get_app_launch_context (display);
//
// gdk_app_launch_context_set_display (display);
// gdk_app_launch_context_set_timestamp (gdk_event_get_time (event));
//
// if (!g_app_info_launch_default_for_uri ("http://www.gtk.org", context,
// &error)) g_warning ("Launching failed: s\n", error->message);
//
// g_object_unref (context); “`
type AppLaunchContext interface {
	gio.AppLaunchContext

	// Display gets the `GdkDisplay` that @context is for.
	Display() Display
	// SetDesktopAppLaunchContext sets the workspace on which applications will
	// be launched.
	//
	// This only works when running under a window manager that supports
	// multiple workspaces, as described in the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec).
	//
	// When the workspace is not specified or @desktop is set to -1, it is up to
	// the window manager to pick one, typically it will be the current
	// workspace.
	SetDesktopAppLaunchContext(desktop int)
	// SetIconAppLaunchContext sets the icon for applications that are launched
	// with this context.
	//
	// Window Managers can use this information when displaying startup
	// notification.
	//
	// See also [method@Gdk.AppLaunchContext.set_icon_name].
	SetIconAppLaunchContext(icon gio.Icon)
	// SetIconNameAppLaunchContext sets the icon for applications that are
	// launched with this context.
	//
	// The @icon_name will be interpreted in the same way as the Icon field in
	// desktop files. See also [method@Gdk.AppLaunchContext.set_icon()].
	//
	// If both @icon and @icon_name are set, the @icon_name takes priority. If
	// neither @icon or @icon_name is set, the icon is taken from either the
	// file that is passed to launched application or from the `GAppInfo` for
	// the launched application itself.
	SetIconNameAppLaunchContext(iconName string)
	// SetTimestampAppLaunchContext sets the timestamp of @context.
	//
	// The timestamp should ideally be taken from the event that triggered the
	// launch.
	//
	// Window managers can use this information to avoid moving the focus to the
	// newly launched application when the user is busy typing in another
	// window. This is also known as 'focus stealing prevention'.
	SetTimestampAppLaunchContext(timestamp uint32)
}

// appLaunchContext implements the AppLaunchContext class.
type appLaunchContext struct {
	gio.AppLaunchContext
}

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return appLaunchContext{
		AppLaunchContext: gio.WrapAppLaunchContext(obj),
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

func (c appLaunchContext) Display() Display {
	var _arg0 *C.GdkAppLaunchContext // out
	var _cret *C.GdkDisplay          // in

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_app_launch_context_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (c appLaunchContext) SetDesktopAppLaunchContext(desktop int) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(desktop)

	C.gdk_app_launch_context_set_desktop(_arg0, _arg1)
}

func (c appLaunchContext) SetIconAppLaunchContext(icon gio.Icon) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 *C.GIcon               // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gdk_app_launch_context_set_icon(_arg0, _arg1)
}

func (c appLaunchContext) SetIconNameAppLaunchContext(iconName string) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_app_launch_context_set_icon_name(_arg0, _arg1)
}

func (c appLaunchContext) SetTimestampAppLaunchContext(timestamp uint32) {
	var _arg0 *C.GdkAppLaunchContext // out
	var _arg1 C.guint32              // out

	_arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.guint32(timestamp)

	C.gdk_app_launch_context_set_timestamp(_arg0, _arg1)
}

// ButtonEvent: an event related to a button on a pointer device.
type ButtonEvent interface {
	Event

	// Button: extract the button number from a button event.
	Button() uint
}

// buttonEvent implements the ButtonEvent class.
type buttonEvent struct {
	Event
}

// WrapButtonEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapButtonEvent(obj *externglib.Object) ButtonEvent {
	return buttonEvent{
		Event: WrapEvent(obj),
	}
}

func marshalButtonEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapButtonEvent(obj), nil
}

func (e buttonEvent) Button() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_button_event_get_button(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CairoContext: `GdkCairoContext` is an object representing the
// platform-specific draw context.
//
// `GdkCairoContext`s are created for a surface using
// [method@Gdk.Surface.create_cairo_context], and the context can then be used
// to draw on that surface.
type CairoContext interface {
	DrawContext

	// CairoCreateCairoContext retrieves a Cairo context to be used to draw on
	// the `GdkSurface` of @context.
	//
	// A call to [method@Gdk.DrawContext.begin_frame] with this @context must
	// have been done or this function will return nil.
	//
	// The returned context is guaranteed to be valid until
	// [method@Gdk.DrawContext.end_frame] is called.
	CairoCreateCairoContext() *cairo.Context
}

// cairoContext implements the CairoContext class.
type cairoContext struct {
	DrawContext
}

// WrapCairoContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapCairoContext(obj *externglib.Object) CairoContext {
	return cairoContext{
		DrawContext: WrapDrawContext(obj),
	}
}

func marshalCairoContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCairoContext(obj), nil
}

func (s cairoContext) CairoCreateCairoContext() *cairo.Context {
	var _arg0 *C.GdkCairoContext // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GdkCairoContext)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_cairo_context_cairo_create(_arg0)

	var _context *cairo.Context // out

	_context = (*cairo.Context)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_context, func(v **cairo.Context) {
		C.free(unsafe.Pointer(v))
	})

	return _context
}

// Clipboard: the `GdkClipboard` object represents data shared between
// applications or inside an application.
//
// To get a `GdkClipboard` object, use [method@Gdk.Display.get_clipboard] or
// [method@Gdk.Display.get_primary_clipboard]. You can find out about the data
// that is currently available in a clipboard using
// [method@Gdk.Clipboard.get_formats].
//
// To make text or image data available in a clipboard, use
// [method@Gdk.Clipboard.set_text] or [method@Gdk.Clipboard.set_texture]. For
// other data, you can use [method@Gdk.Clipboard.set_content], which takes a
// [class@Gdk.ContentProvider] object.
//
// To read textual or image data from a clipboard, use
// [method@Gdk.Clipboard.read_text_async] or
// [method@Gdk.Clipboard.read_texture_async]. For other data, use
// [method@Gdk.Clipboard.read_async], which provides a `GInputStream` object.
type Clipboard interface {
	gextras.Objector

	// Content returns the `GdkContentProvider` currently set on @clipboard.
	//
	// If the @clipboard is empty or its contents are not owned by the current
	// process, nil will be returned.
	Content() ContentProvider
	// Display gets the `GdkDisplay` that the clipboard was created for.
	Display() Display
	// Formats gets the formats that the clipboard can provide its current
	// contents in.
	Formats() *ContentFormats
	// IsLocalClipboard returns if the clipboard is local.
	//
	// A clipboard is considered local if it was last claimed by the running
	// application.
	//
	// Note that [method@Gdk.Clipboard.get_content] may return nil even on a
	// local clipboard. In this case the clipboard is empty.
	IsLocalClipboard() bool
	// ReadFinishClipboard finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_async].
	ReadFinishClipboard(result gio.AsyncResult) (string, gio.InputStream, error)
	// ReadTextFinishClipboard finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_text_async].
	ReadTextFinishClipboard(result gio.AsyncResult) (string, error)
	// ReadTextureFinishClipboard finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_texture_async].
	ReadTextureFinishClipboard(result gio.AsyncResult) (Texture, error)
	// ReadValueFinishClipboard finishes an asynchronous clipboard read.
	//
	// See [method@Gdk.Clipboard.read_value_async].
	ReadValueFinishClipboard(result gio.AsyncResult) (externglib.Value, error)
	// SetContentClipboard sets a new content provider on @clipboard.
	//
	// The clipboard will claim the `GdkDisplay`'s resources and advertise these
	// new contents to other applications.
	//
	// In the rare case of a failure, this function will return false. The
	// clipboard will then continue reporting its old contents and ignore
	// @provider.
	//
	// If the contents are read by either an external application or the
	// @clipboard's read functions, @clipboard will select the best format to
	// transfer the contents and then request that format from @provider.
	SetContentClipboard(provider ContentProvider) bool
	// SetValueClipboard sets the @clipboard to contain the given @value.
	SetValueClipboard(value externglib.Value)
	// StoreFinishClipboard finishes an asynchronous clipboard store.
	//
	// See [method@Gdk.Clipboard.store_async].
	StoreFinishClipboard(result gio.AsyncResult) error
}

// clipboard implements the Clipboard class.
type clipboard struct {
	gextras.Objector
}

// WrapClipboard wraps a GObject to the right type. It is
// primarily used internally.
func WrapClipboard(obj *externglib.Object) Clipboard {
	return clipboard{
		Objector: obj,
	}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapClipboard(obj), nil
}

func (c clipboard) Content() ContentProvider {
	var _arg0 *C.GdkClipboard       // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_clipboard_get_content(_arg0)

	var _contentProvider ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ContentProvider)

	return _contentProvider
}

func (c clipboard) Display() Display {
	var _arg0 *C.GdkClipboard // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_clipboard_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (c clipboard) Formats() *ContentFormats {
	var _arg0 *C.GdkClipboard      // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_clipboard_get_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))

	return _contentFormats
}

func (c clipboard) IsLocalClipboard() bool {
	var _arg0 *C.GdkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_clipboard_is_local(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c clipboard) ReadFinishClipboard(result gio.AsyncResult) (string, gio.InputStream, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_clipboard_read_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _outMimeType string          // out
	var _inputStream gio.InputStream // out
	var _goerr error                 // out

	_outMimeType = C.GoString(_arg2)
	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outMimeType, _inputStream, _goerr
}

func (c clipboard) ReadTextFinishClipboard(result gio.AsyncResult) (string, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.char         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_clipboard_read_text_finish(_arg0, _arg1, &_cerr)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _utf8, _goerr
}

func (c clipboard) ReadTextureFinishClipboard(result gio.AsyncResult) (Texture, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkTexture   // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_clipboard_read_texture_finish(_arg0, _arg1, &_cerr)

	var _texture Texture // out
	var _goerr error     // out

	_texture = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Texture)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _texture, _goerr
}

func (c clipboard) ReadValueFinishClipboard(result gio.AsyncResult) (externglib.Value, error) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GValue       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_clipboard_read_value_finish(_arg0, _arg1, &_cerr)

	var _value externglib.Value // out
	var _goerr error            // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (c clipboard) SetContentClipboard(provider ContentProvider) bool {
	var _arg0 *C.GdkClipboard       // out
	var _arg1 *C.GdkContentProvider // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkContentProvider)(unsafe.Pointer(provider.Native()))

	_cret = C.gdk_clipboard_set_content(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c clipboard) SetValueClipboard(value externglib.Value) {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GValue       // out

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gdk_clipboard_set_value(_arg0, _arg1)
}

func (c clipboard) StoreFinishClipboard(result gio.AsyncResult) error {
	var _arg0 *C.GdkClipboard // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkClipboard)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.gdk_clipboard_store_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ContentDeserializer: a `GdkContentDeserializer` is used to deserialize
// content received via inter-application data transfers.
//
// The `GdkContentDeserializer` transforms serialized content that is identified
// by a mime type into an object identified by a GType.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own deserialization
// functions, use [func@content_register_deserializer].
//
// Also see [class@Gdk.ContentSerializer].
type ContentDeserializer interface {
	gio.AsyncResult

	// Cancellable gets the cancellable for the current operation.
	//
	// This is the `GCancellable` that was passed to
	// [func@content_deserialize_async].
	Cancellable() gio.Cancellable
	// GType gets the GType to create an instance of.
	GType() externglib.Type
	// InputStream gets the input stream for the current operation.
	//
	// This is the stream that was passed to [func@content_deserialize_async].
	InputStream() gio.InputStream
	// MIMEType gets the mime type to deserialize from.
	MIMEType() string
	// Priority gets the I/O priority for the current operation.
	//
	// This is the priority that was passed to [funccontent_deserialize_async].
	Priority() int
	// Value gets the `GValue` to store the deserialized object in.
	Value() externglib.Value
	// ReturnErrorContentDeserializer: indicate that the deserialization has
	// ended with an error.
	//
	// This function consumes @error.
	ReturnErrorContentDeserializer(err error)
	// ReturnSuccessContentDeserializer: indicate that the deserialization has
	// been successfully completed.
	ReturnSuccessContentDeserializer()
}

// contentDeserializer implements the ContentDeserializer class.
type contentDeserializer struct {
	gextras.Objector
}

// WrapContentDeserializer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContentDeserializer(obj *externglib.Object) ContentDeserializer {
	return contentDeserializer{
		Objector: obj,
	}
}

func marshalContentDeserializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContentDeserializer(obj), nil
}

func (d contentDeserializer) Cancellable() gio.Cancellable {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GCancellable           // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_cancellable(_arg0)

	var _cancellable gio.Cancellable // out

	_cancellable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Cancellable)

	return _cancellable
}

func (d contentDeserializer) GType() externglib.Type {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.GType                   // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_gtype(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (d contentDeserializer) InputStream() gio.InputStream {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GInputStream           // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_input_stream(_arg0)

	var _inputStream gio.InputStream // out

	_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.InputStream)

	return _inputStream
}

func (d contentDeserializer) MIMEType() string {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.char                   // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_mime_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d contentDeserializer) Priority() int {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret C.int                     // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_priority(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (d contentDeserializer) Value() externglib.Value {
	var _arg0 *C.GdkContentDeserializer // out
	var _cret *C.GValue                 // in

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_content_deserializer_get_value(_arg0)

	var _value externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

func (d contentDeserializer) ReturnErrorContentDeserializer(err error) {
	var _arg0 *C.GdkContentDeserializer // out
	var _arg1 *C.GError                 // out

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GError)(gerror.New(err))
	defer C.g_error_free(_arg1)

	C.gdk_content_deserializer_return_error(_arg0, _arg1)
}

func (d contentDeserializer) ReturnSuccessContentDeserializer() {
	var _arg0 *C.GdkContentDeserializer // out

	_arg0 = (*C.GdkContentDeserializer)(unsafe.Pointer(d.Native()))

	C.gdk_content_deserializer_return_success(_arg0)
}

// ContentProvider: a `GdkContentProvider` is used to provide content for the
// clipboard or for drag-and-drop operations in a number of formats.
//
// To create a `GdkContentProvider`, use
// [ctor@Gdk.ContentProvider.new_for_value] or
// [ctor@Gdk.ContentProvider.new_for_bytes].
//
// GDK knows how to handle common text and image formats out-of-the-box. See
// [class@Gdk.ContentSerializer] and [class@Gdk.ContentDeserializer] if you want
// to add support for application-specific data formats.
type ContentProvider interface {
	gextras.Objector

	// ContentChangedContentProvider emits the ::content-changed signal.
	ContentChangedContentProvider()
	// Value gets the contents of @provider stored in @value.
	//
	// The @value will have been initialized to the `GType` the value should be
	// provided in. This given `GType` does not need to be listed in the formats
	// returned by [method@Gdk.ContentProvider.ref_formats]. However, if the
	// given `GType` is not supported, this operation can fail and
	// IO_ERROR_NOT_SUPPORTED will be reported.
	Value(value externglib.Value) error
	// RefFormatsContentProvider gets the formats that the provider can provide
	// its current contents in.
	RefFormatsContentProvider() *ContentFormats
	// RefStorableFormatsContentProvider gets the formats that the provider
	// suggests other applications to store the data in.
	//
	// An example of such an application would be a clipboard manager.
	//
	// This can be assumed to be a subset of
	// [method@Gdk.ContentProvider.ref_formats].
	RefStorableFormatsContentProvider() *ContentFormats
	// WriteMIMETypeFinishContentProvider finishes an asynchronous write
	// operation.
	//
	// See [method@Gdk.ContentProvider.write_mime_type_async].
	WriteMIMETypeFinishContentProvider(result gio.AsyncResult) error
}

// contentProvider implements the ContentProvider class.
type contentProvider struct {
	gextras.Objector
}

// WrapContentProvider wraps a GObject to the right type. It is
// primarily used internally.
func WrapContentProvider(obj *externglib.Object) ContentProvider {
	return contentProvider{
		Objector: obj,
	}
}

func marshalContentProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContentProvider(obj), nil
}

// NewContentProviderForValue: create a content provider that provides the given
// @value.
func NewContentProviderForValue(value externglib.Value) ContentProvider {
	var _arg1 *C.GValue             // out
	var _cret *C.GdkContentProvider // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gdk_content_provider_new_for_value(_arg1)

	var _contentProvider ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ContentProvider)

	return _contentProvider
}

// NewContentProviderUnion creates a content provider that represents all the
// given @providers.
//
// Whenever data needs to be written, the union provider will try the given
// @providers in the given order and the first one supporting a format will be
// chosen to provide it.
//
// This allows an easy way to support providing data in different formats. For
// example, an image may be provided by its file and by the image contents with
// a call such as “`c gdk_content_provider_new_union ((GdkContentProvider *[2])
// { gdk_content_provider_new_typed (G_TYPE_FILE, file),
// gdk_content_provider_new_typed (G_TYPE_TEXTURE, texture) }, 2); “`
func NewContentProviderUnion(providers []ContentProvider) ContentProvider {
	var _arg1 **C.GdkContentProvider
	var _arg2 C.gsize
	var _cret *C.GdkContentProvider // in

	_arg2 = C.gsize(len(providers))
	_arg1 = (**C.GdkContentProvider)(C.malloc(C.ulong(len(providers)) * C.ulong(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice(_arg1, len(providers))
		for i := range providers {
			out[i] = (*C.GdkContentProvider)(unsafe.Pointer(providers[i].Native()))
		}
	}

	_cret = C.gdk_content_provider_new_union(_arg1, _arg2)

	var _contentProvider ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ContentProvider)

	return _contentProvider
}

func (p contentProvider) ContentChangedContentProvider() {
	var _arg0 *C.GdkContentProvider // out

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(p.Native()))

	C.gdk_content_provider_content_changed(_arg0)
}

func (p contentProvider) Value(value externglib.Value) error {
	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GValue             // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	C.gdk_content_provider_get_value(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (p contentProvider) RefFormatsContentProvider() *ContentFormats {
	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_content_provider_ref_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

func (p contentProvider) RefStorableFormatsContentProvider() *ContentFormats {
	var _arg0 *C.GdkContentProvider // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_content_provider_ref_storable_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

func (p contentProvider) WriteMIMETypeFinishContentProvider(result gio.AsyncResult) error {
	var _arg0 *C.GdkContentProvider // out
	var _arg1 *C.GAsyncResult       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.GdkContentProvider)(unsafe.Pointer(p.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	C.gdk_content_provider_write_mime_type_finish(_arg0, _arg1, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

// ContentSerializer: a `GdkContentSerializer` is used to serialize content for
// inter-application data transfers.
//
// The `GdkContentSerializer` transforms an object that is identified by a GType
// into a serialized form (i.e. a byte stream) that is identified by a mime
// type.
//
// GTK provides serializers and deserializers for common data types such as
// text, colors, images or file lists. To register your own serialization
// functions, use [func@content_register_serializer].
//
// Also see [class@Gdk.ContentDeserializer].
type ContentSerializer interface {
	gio.AsyncResult

	// Cancellable gets the cancellable for the current operation.
	//
	// This is the `GCancellable` that was passed to [content_serialize_async].
	Cancellable() gio.Cancellable
	// GType gets the `GType` to of the object to serialize.
	GType() externglib.Type
	// MIMEType gets the mime type to serialize to.
	MIMEType() string
	// OutputStream gets the output stream for the current operation.
	//
	// This is the stream that was passed to [func@content_serialize_async].
	OutputStream() gio.OutputStream
	// Priority gets the I/O priority for the current operation.
	//
	// This is the priority that was passed to [func@content_serialize_async].
	Priority() int
	// Value gets the `GValue` to read the object to serialize from.
	Value() externglib.Value
	// ReturnErrorContentSerializer: indicate that the serialization has ended
	// with an error.
	//
	// This function consumes @error.
	ReturnErrorContentSerializer(err error)
	// ReturnSuccessContentSerializer: indicate that the serialization has been
	// successfully completed.
	ReturnSuccessContentSerializer()
}

// contentSerializer implements the ContentSerializer class.
type contentSerializer struct {
	gextras.Objector
}

// WrapContentSerializer wraps a GObject to the right type. It is
// primarily used internally.
func WrapContentSerializer(obj *externglib.Object) ContentSerializer {
	return contentSerializer{
		Objector: obj,
	}
}

func marshalContentSerializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContentSerializer(obj), nil
}

func (s contentSerializer) Cancellable() gio.Cancellable {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GCancellable         // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_cancellable(_arg0)

	var _cancellable gio.Cancellable // out

	_cancellable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Cancellable)

	return _cancellable
}

func (s contentSerializer) GType() externglib.Type {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.GType                 // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_gtype(_arg0)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func (s contentSerializer) MIMEType() string {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.char                 // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_mime_type(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (s contentSerializer) OutputStream() gio.OutputStream {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GOutputStream        // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_output_stream(_arg0)

	var _outputStream gio.OutputStream // out

	_outputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.OutputStream)

	return _outputStream
}

func (s contentSerializer) Priority() int {
	var _arg0 *C.GdkContentSerializer // out
	var _cret C.int                   // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_priority(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s contentSerializer) Value() externglib.Value {
	var _arg0 *C.GdkContentSerializer // out
	var _cret *C.GValue               // in

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_content_serializer_get_value(_arg0)

	var _value externglib.Value // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

func (s contentSerializer) ReturnErrorContentSerializer(err error) {
	var _arg0 *C.GdkContentSerializer // out
	var _arg1 *C.GError               // out

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GError)(gerror.New(err))
	defer C.g_error_free(_arg1)

	C.gdk_content_serializer_return_error(_arg0, _arg1)
}

func (s contentSerializer) ReturnSuccessContentSerializer() {
	var _arg0 *C.GdkContentSerializer // out

	_arg0 = (*C.GdkContentSerializer)(unsafe.Pointer(s.Native()))

	C.gdk_content_serializer_return_success(_arg0)
}

// CrossingEvent: an event caused by a pointing device moving between surfaces.
type CrossingEvent interface {
	Event

	// Detail extracts the notify detail from a crossing event.
	Detail() NotifyType
	// Focus checks if the @event surface is the focus surface.
	Focus() bool
	// Mode extracts the crossing mode from a crossing event.
	Mode() CrossingMode
}

// crossingEvent implements the CrossingEvent class.
type crossingEvent struct {
	Event
}

// WrapCrossingEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapCrossingEvent(obj *externglib.Object) CrossingEvent {
	return crossingEvent{
		Event: WrapEvent(obj),
	}
}

func marshalCrossingEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCrossingEvent(obj), nil
}

func (e crossingEvent) Detail() NotifyType {
	var _arg0 *C.GdkEvent     // out
	var _cret C.GdkNotifyType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_crossing_event_get_detail(_arg0)

	var _notifyType NotifyType // out

	_notifyType = NotifyType(_cret)

	return _notifyType
}

func (e crossingEvent) Focus() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_crossing_event_get_focus(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e crossingEvent) Mode() CrossingMode {
	var _arg0 *C.GdkEvent       // out
	var _cret C.GdkCrossingMode // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_crossing_event_get_mode(_arg0)

	var _crossingMode CrossingMode // out

	_crossingMode = CrossingMode(_cret)

	return _crossingMode
}

// Cursor: `GdkCursor` is used to create and destroy cursors.
//
// Cursors are immutable objects, so once you created them, there is no way to
// modify them later. You should create a new cursor when you want to change
// something about it.
//
// Cursors by themselves are not very interesting: they must be bound to a
// window for users to see them. This is done with
// [method@Gdk.Surface.set_cursor] or [method@Gdk.Surface.set_device_cursor].
// Applications will typically use higher-level GTK functions such as
// [method@Gtk.Widget.set_cursor]` instead.
//
// Cursors are not bound to a given [class@Gdk.Display], so they can be shared.
// However, the appearance of cursors may vary when used on different platforms.
//
//
// Named and texture cursors
//
// There are multiple ways to create cursors. The platform's own cursors can be
// created with [ctor@Gdk.Cursor.new_from_name]. That function lists the
// commonly available names that are shared with the CSS specification. Other
// names may be available, depending on the platform in use. On some platforms,
// what images are used for named cursors may be influenced by the cursor theme.
//
// Another option to create a cursor is to use
// [ctor@Gdk.Cursor.new_from_texture] and provide an image to use for the
// cursor.
//
// To ease work with unsupported cursors, a fallback cursor can be provided. If
// a [class@Gdk.Surface] cannot use a cursor because of the reasons mentioned
// above, it will try the fallback cursor. Fallback cursors can themselves have
// fallback cursors again, so it is possible to provide a chain of progressively
// easier to support cursors. If none of the provided cursors can be supported,
// the default cursor will be the ultimate fallback.
type Cursor interface {
	gextras.Objector

	// Fallback returns the fallback for this @cursor.
	//
	// The fallback will be used if this cursor is not available on a given
	// `GdkDisplay`. For named cursors, this can happen when using nonstandard
	// names or when using an incomplete cursor theme. For textured cursors,
	// this can happen when the texture is too large or when the `GdkDisplay` it
	// is used on does not support textured cursors.
	Fallback() Cursor
	// HotspotX returns the horizontal offset of the hotspot.
	//
	// The hotspot indicates the pixel that will be directly above the cursor.
	//
	// Note that named cursors may have a nonzero hotspot, but this function
	// will only return the hotspot position for cursors created with
	// [ctor@Gdk.Cursor.new_from_texture].
	HotspotX() int
	// HotspotY returns the vertical offset of the hotspot.
	//
	// The hotspot indicates the pixel that will be directly above the cursor.
	//
	// Note that named cursors may have a nonzero hotspot, but this function
	// will only return the hotspot position for cursors created with
	// [ctor@Gdk.Cursor.new_from_texture].
	HotspotY() int
	// Name returns the name of the cursor.
	//
	// If the cursor is not a named cursor, nil will be returned.
	Name() string
	// Texture returns the texture for the cursor.
	//
	// If the cursor is a named cursor, nil will be returned.
	Texture() Texture
}

// cursor implements the Cursor class.
type cursor struct {
	gextras.Objector
}

// WrapCursor wraps a GObject to the right type. It is
// primarily used internally.
func WrapCursor(obj *externglib.Object) Cursor {
	return cursor{
		Objector: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCursor(obj), nil
}

// NewCursorFromName creates a new cursor by looking up @name in the current
// cursor theme.
//
// A recommended set of cursor names that will work across different platforms
// can be found in the CSS specification:
//
// | | | | | | --- | --- | ---- | --- | | "none" | ! (default_cursor.png)
// "default" | ! (help_cursor.png) "help" | ! (pointer_cursor.png) "pointer" | |
// ! (context_menu_cursor.png) "context-menu" | ! (progress_cursor.png)
// "progress" | ! (wait_cursor.png) "wait" | ! (cell_cursor.png) "cell" | | !
// (crosshair_cursor.png) "crosshair" | ! (text_cursor.png) "text" | !
// (vertical_text_cursor.png) "vertical-text" | ! (alias_cursor.png) "alias" | |
// ! (copy_cursor.png) "copy" | ! (no_drop_cursor.png) "no-drop" | !
// (move_cursor.png) "move" | ! (not_allowed_cursor.png) "not-allowed" | | !
// (grab_cursor.png) "grab" | ! (grabbing_cursor.png) "grabbing" | !
// (all_scroll_cursor.png) "all-scroll" | ! (col_resize_cursor.png) "col-resize"
// | | ! (row_resize_cursor.png) "row-resize" | ! (n_resize_cursor.png)
// "n-resize" | ! (e_resize_cursor.png) "e-resize" | ! (s_resize_cursor.png)
// "s-resize" | | ! (w_resize_cursor.png) "w-resize" | ! (ne_resize_cursor.png)
// "ne-resize" | ! (nw_resize_cursor.png) "nw-resize" | ! (sw_resize_cursor.png)
// "sw-resize" | | ! (se_resize_cursor.png) "se-resize" | !
// (ew_resize_cursor.png) "ew-resize" | ! (ns_resize_cursor.png) "ns-resize" | !
// (nesw_resize_cursor.png) "nesw-resize" | | ! (nwse_resize_cursor.png)
// "nwse-resize" | ! (zoom_in_cursor.png) "zoom-in" | ! (zoom_out_cursor.png)
// "zoom-out" | |
func NewCursorFromName(name string, fallback Cursor) Cursor {
	var _arg1 *C.char      // out
	var _arg2 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GdkCursor)(unsafe.Pointer(fallback.Native()))

	_cret = C.gdk_cursor_new_from_name(_arg1, _arg2)

	var _cursor Cursor // out

	_cursor = WrapCursor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cursor
}

// NewCursorFromTexture creates a new cursor from a `GdkTexture`.
func NewCursorFromTexture(texture Texture, hotspotX int, hotspotY int, fallback Cursor) Cursor {
	var _arg1 *C.GdkTexture // out
	var _arg2 C.int         // out
	var _arg3 C.int         // out
	var _arg4 *C.GdkCursor  // out
	var _cret *C.GdkCursor  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = C.int(hotspotX)
	_arg3 = C.int(hotspotY)
	_arg4 = (*C.GdkCursor)(unsafe.Pointer(fallback.Native()))

	_cret = C.gdk_cursor_new_from_texture(_arg1, _arg2, _arg3, _arg4)

	var _cursor Cursor // out

	_cursor = WrapCursor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cursor
}

func (c cursor) Fallback() Cursor {
	var _arg0 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_fallback(_arg0)

	var _ret Cursor // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cursor)

	return _ret
}

func (c cursor) HotspotX() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_hotspot_x(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (c cursor) HotspotY() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_hotspot_y(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (c cursor) Name() string {
	var _arg0 *C.GdkCursor // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c cursor) Texture() Texture {
	var _arg0 *C.GdkCursor  // out
	var _cret *C.GdkTexture // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_texture(_arg0)

	var _texture Texture // out

	_texture = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Texture)

	return _texture
}

// DNDEvent: an event related to drag and drop operations.
type DNDEvent interface {
	Event

	// Drop gets the `GdkDrop` object from a DND event.
	Drop() Drop
}

// dndEvent implements the DNDEvent class.
type dndEvent struct {
	Event
}

// WrapDNDEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapDNDEvent(obj *externglib.Object) DNDEvent {
	return dndEvent{
		Event: WrapEvent(obj),
	}
}

func marshalDNDEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDNDEvent(obj), nil
}

func (e dndEvent) Drop() Drop {
	var _arg0 *C.GdkEvent // out
	var _cret *C.GdkDrop  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_dnd_event_get_drop(_arg0)

	var _drop Drop // out

	_drop = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Drop)

	return _drop
}

// DeleteEvent: an event related to closing a top-level surface.
type DeleteEvent interface {
	Event
}

// deleteEvent implements the DeleteEvent class.
type deleteEvent struct {
	Event
}

// WrapDeleteEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapDeleteEvent(obj *externglib.Object) DeleteEvent {
	return deleteEvent{
		Event: WrapEvent(obj),
	}
}

func marshalDeleteEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDeleteEvent(obj), nil
}

// Device: the `GdkDevice` object represents an input device, such as a
// keyboard, a mouse, or a touchpad.
//
// See the [class@Gdk.Seat] documentation for more information about the various
// kinds of devices, and their relationships.
type Device interface {
	gextras.Objector

	// CapsLockState retrieves whether the Caps Lock modifier of the keyboard is
	// locked.
	//
	// This is only relevant for keyboard devices.
	CapsLockState() bool
	// DeviceTool retrieves the current tool for @device.
	DeviceTool() DeviceTool
	// Direction returns the direction of effective layout of the keyboard.
	//
	// This is only relevant for keyboard devices.
	//
	// The direction of a layout is the direction of the majority of its
	// symbols. See [func@Pango.unichar_direction].
	Direction() pango.Direction
	// Display returns the `GdkDisplay` to which @device pertains.
	Display() Display
	// HasCursor determines whether the pointer follows device motion.
	//
	// This is not meaningful for keyboard devices, which don't have a pointer.
	HasCursor() bool
	// ModifierState retrieves the current modifier state of the keyboard.
	//
	// This is only relevant for keyboard devices.
	ModifierState() ModifierType
	// Name: the name of the device, suitable for showing in a user interface.
	Name() string
	// NumLockState retrieves whether the Num Lock modifier of the keyboard is
	// locked.
	//
	// This is only relevant for keyboard devices.
	NumLockState() bool
	// NumTouches retrieves the number of touch points associated to @device.
	NumTouches() uint
	// ProductID returns the product ID of this device.
	//
	// This ID is retrieved from the device, and does not change. See
	// [method@Gdk.Device.get_vendor_id] for more information.
	ProductID() string
	// ScrollLockState retrieves whether the Scroll Lock modifier of the
	// keyboard is locked.
	//
	// This is only relevant for keyboard devices.
	ScrollLockState() bool
	// Seat returns the `GdkSeat` the device belongs to.
	Seat() Seat
	// Source determines the type of the device.
	Source() InputSource
	// SurfaceAtPosition obtains the surface underneath @device, returning the
	// location of the device in @win_x and @win_y
	//
	// Returns nil if the surface tree under @device is not known to GDK (for
	// example, belongs to another application).
	SurfaceAtPosition() (winX float64, winY float64, surface Surface)
	// Timestamp returns the timestamp of the last activity for this device.
	//
	// In practice, this means the timestamp of the last event that was received
	// from the OS for this device. (GTK may occasionally produce events for a
	// device that are not received from the OS, and will not update the
	// timestamp).
	Timestamp() uint32
	// VendorID returns the vendor ID of this device.
	//
	// This ID is retrieved from the device, and does not change.
	//
	// This function, together with [method@Gdk.Device.get_product_id], can be
	// used to eg. compose `GSettings` paths to store settings for this device.
	//
	// “`c static GSettings * get_device_settings (GdkDevice *device) { const
	// char *vendor, *product; GSettings *settings; GdkDevice *device; char
	// *path;
	//
	//      vendor = gdk_device_get_vendor_id (device);
	//      product = gdk_device_get_product_id (device);
	//
	//      path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
	//      settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
	//      g_free (path);
	//
	//      return settings;
	//    }
	//
	// “`
	VendorID() string
	// HasBidiLayoutsDevice determines if layouts for both right-to-left and
	// left-to-right languages are in use on the keyboard.
	//
	// This is only relevant for keyboard devices.
	HasBidiLayoutsDevice() bool
}

// device implements the Device class.
type device struct {
	gextras.Objector
}

// WrapDevice wraps a GObject to the right type. It is
// primarily used internally.
func WrapDevice(obj *externglib.Object) Device {
	return device{
		Objector: obj,
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDevice(obj), nil
}

func (d device) CapsLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_caps_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d device) DeviceTool() DeviceTool {
	var _arg0 *C.GdkDevice     // out
	var _cret *C.GdkDeviceTool // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_device_tool(_arg0)

	var _deviceTool DeviceTool // out

	_deviceTool = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(DeviceTool)

	return _deviceTool
}

func (d device) Direction() pango.Direction {
	var _arg0 *C.GdkDevice     // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_direction(_arg0)

	var _direction pango.Direction // out

	_direction = pango.Direction(_cret)

	return _direction
}

func (d device) Display() Display {
	var _arg0 *C.GdkDevice  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (d device) HasCursor() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_has_cursor(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d device) ModifierState() ModifierType {
	var _arg0 *C.GdkDevice      // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_modifier_state(_arg0)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

func (d device) Name() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d device) NumLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_num_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d device) NumTouches() uint {
	var _arg0 *C.GdkDevice // out
	var _cret C.guint      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_num_touches(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (d device) ProductID() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_product_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d device) ScrollLockState() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_scroll_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d device) Seat() Seat {
	var _arg0 *C.GdkDevice // out
	var _cret *C.GdkSeat   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_seat(_arg0)

	var _seat Seat // out

	_seat = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Seat)

	return _seat
}

func (d device) Source() InputSource {
	var _arg0 *C.GdkDevice     // out
	var _cret C.GdkInputSource // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_source(_arg0)

	var _inputSource InputSource // out

	_inputSource = InputSource(_cret)

	return _inputSource
}

func (d device) SurfaceAtPosition() (winX float64, winY float64, surface Surface) {
	var _arg0 *C.GdkDevice  // out
	var _arg1 C.double      // in
	var _arg2 C.double      // in
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_surface_at_position(_arg0, &_arg1, &_arg2)

	var _winX float64    // out
	var _winY float64    // out
	var _surface Surface // out

	_winX = float64(_arg1)
	_winY = float64(_arg2)
	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _winX, _winY, _surface
}

func (d device) Timestamp() uint32 {
	var _arg0 *C.GdkDevice // out
	var _cret C.guint32    // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_timestamp(_arg0)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

func (d device) VendorID() string {
	var _arg0 *C.GdkDevice // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_get_vendor_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d device) HasBidiLayoutsDevice() bool {
	var _arg0 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_device_has_bidi_layouts(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceTool: a physical tool associated to a `GdkDevice`.
type DeviceTool interface {
	gextras.Objector

	// Axes gets the axes of the tool.
	Axes() AxisFlags
	// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
	//
	// When non-zero, the identificator is unique for the given tool model,
	// meaning that two identical tools will share the same @hardware_id, but
	// will have different serial numbers (see
	// [method@Gdk.DeviceTool.get_serial]).
	//
	// This is a more concrete (and device specific) method to identify a
	// `GdkDeviceTool` than [method@Gdk.DeviceTool.get_tool_type], as a tablet
	// may support multiple devices with the same `GdkDeviceToolType`, but
	// different hardware identificators.
	HardwareID() uint64
	// Serial gets the serial number of this tool.
	//
	// This value can be used to identify a physical tool (eg. a tablet pen)
	// across program executions.
	Serial() uint64
	// ToolType gets the `GdkDeviceToolType` of the tool.
	ToolType() DeviceToolType
}

// deviceTool implements the DeviceTool class.
type deviceTool struct {
	gextras.Objector
}

// WrapDeviceTool wraps a GObject to the right type. It is
// primarily used internally.
func WrapDeviceTool(obj *externglib.Object) DeviceTool {
	return deviceTool{
		Objector: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDeviceTool(obj), nil
}

func (t deviceTool) Axes() AxisFlags {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.GdkAxisFlags   // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_axes(_arg0)

	var _axisFlags AxisFlags // out

	_axisFlags = AxisFlags(_cret)

	return _axisFlags
}

func (t deviceTool) HardwareID() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_hardware_id(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

func (t deviceTool) Serial() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_serial(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

func (t deviceTool) ToolType() DeviceToolType {
	var _arg0 *C.GdkDeviceTool    // out
	var _cret C.GdkDeviceToolType // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_tool_type(_arg0)

	var _deviceToolType DeviceToolType // out

	_deviceToolType = DeviceToolType(_cret)

	return _deviceToolType
}

// Display: `GdkDisplay` objects are the GDK representation of a workstation.
//
// Their purpose are two-fold:
//
// - To manage and provide information about input devices (pointers, keyboards,
// etc) - To manage and provide information about output devices (monitors,
// projectors, etc)
//
// Most of the input device handling has been factored out into separate
// [class@Gdk.Seat] objects. Every display has a one or more seats, which can be
// accessed with [method@Gdk.Display.get_default_seat] and
// [method@Gdk.Display.list_seats].
//
// Output devices are represented by [class@Gdk.Monitor] objects, which can be
// accessed with [method@Gdk.Display.get_monitor_at_surface] and similar APIs.
type Display interface {
	gextras.Objector

	// BeepDisplay emits a short beep on @display
	BeepDisplay()
	// CloseDisplay closes the connection to the windowing system for the given
	// display.
	//
	// This cleans up associated resources.
	CloseDisplay()
	// DeviceIsGrabbedDisplay returns true if there is an ongoing grab on
	// @device for @display.
	DeviceIsGrabbedDisplay(device Device) bool
	// FlushDisplay flushes any requests queued for the windowing system.
	//
	// This happens automatically when the main loop blocks waiting for new
	// events, but if your application is drawing without returning control to
	// the main loop, you may need to call this function explicitly. A common
	// case where this function needs to be called is when an application is
	// executing drawing commands from a thread other than the thread where the
	// main loop is running.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	FlushDisplay()
	// AppLaunchContext returns a `GdkAppLaunchContext` suitable for launching
	// applications on the given display.
	AppLaunchContext() AppLaunchContext
	// Clipboard gets the clipboard used for copy/paste operations.
	Clipboard() Clipboard
	// DefaultSeat returns the default `GdkSeat` for this display.
	//
	// Note that a display may not have a seat. In this case, this function will
	// return nil.
	DefaultSeat() Seat
	// MonitorAtSurface gets the monitor in which the largest area of @surface
	// resides.
	//
	// Returns a monitor close to @surface if it is outside of all monitors.
	MonitorAtSurface(surface Surface) Monitor
	// Monitors gets the list of monitors associated with this display.
	//
	// Subsequent calls to this function will always return the same list for
	// the same display.
	//
	// You can listen to the GListModel::items-changed signal on this list to
	// monitor changes to the monitor of this display.
	Monitors() gio.ListModel
	// Name gets the name of the display.
	Name() string
	// PrimaryClipboard gets the clipboard used for the primary selection.
	//
	// On backends where the primary clipboard is not supported natively, GDK
	// emulates this clipboard locally.
	PrimaryClipboard() Clipboard
	// Setting retrieves a desktop-wide setting such as double-click time for
	// the @display.
	Setting(name string, value externglib.Value) bool
	// StartupNotificationID gets the startup notification ID for a Wayland
	// display, or nil if no ID has been defined.
	StartupNotificationID() string
	// IsClosedDisplay finds out if the display has been closed.
	IsClosedDisplay() bool
	// IsCompositedDisplay returns whether surfaces can reasonably be expected
	// to have their alpha channel drawn correctly on the screen.
	//
	// Check [method@Gdk.Display.is_rgba] for whether the display supports an
	// alpha channel.
	//
	// On X11 this function returns whether a compositing manager is compositing
	// on @display.
	//
	// On modern displays, this value is always true.
	IsCompositedDisplay() bool
	// IsRGBADisplay returns whether surfaces on this @display are created with
	// an alpha channel.
	//
	// Even if a true is returned, it is possible that the surface’s alpha
	// channel won’t be honored when displaying the surface on the screen: in
	// particular, for X an appropriate windowing manager and compositing
	// manager must be running to provide appropriate display. Use
	// [method@Gdk.Display.is_composited] to check if that is the case.
	//
	// On modern displays, this value is always true.
	IsRGBADisplay() bool
	// MapKeycodeDisplay returns the keyvals bound to @keycode.
	//
	// The Nth `GdkKeymapKey` in @keys is bound to the Nth keyval in @keyvals.
	//
	// When a keycode is pressed by the user, the keyval from this list of
	// entries is selected by considering the effective keyboard group and
	// level.
	//
	// Free the returned arrays with g_free().
	MapKeycodeDisplay(keycode uint) ([]KeymapKey, []uint, bool)
	// MapKeyvalDisplay obtains a list of keycode/group/level combinations that
	// will generate @keyval.
	//
	// Groups and levels are two kinds of keyboard mode; in general, the level
	// determines whether the top or bottom symbol on a key is used, and the
	// group determines whether the left or right symbol is used.
	//
	// On US keyboards, the shift key changes the keyboard level, and there are
	// no groups. A group switch key might convert a keyboard between Hebrew to
	// English modes, for example.
	//
	// `GdkEventKey` contains a group field that indicates the active keyboard
	// group. The level is computed from the modifier mask.
	//
	// The returned array should be freed with g_free().
	MapKeyvalDisplay(keyval uint) ([]KeymapKey, bool)
	// NotifyStartupCompleteDisplay indicates to the GUI environment that the
	// application has finished loading, using a given identifier.
	//
	// GTK will call this function automatically for [class@Gtk.Window] with
	// custom startup-notification identifier unless
	// [method@Gtk.Window.set_auto_startup_notification] is called to disable
	// that feature.
	NotifyStartupCompleteDisplay(startupId string)
	// PutEventDisplay appends the given event onto the front of the event queue
	// for @display.
	//
	// This function is only useful in very special situations and should not be
	// used by applications.
	PutEventDisplay(event Event)
	// SupportsInputShapesDisplay returns true if the display supports input
	// shapes.
	//
	// This means that [method@Gdk.Surface.set_input_region] can be used to
	// modify the input shape of surfaces on @display.
	//
	// On modern displays, this value is always true.
	SupportsInputShapesDisplay() bool
	// SyncDisplay flushes any requests queued for the windowing system and
	// waits until all requests have been handled.
	//
	// This is often used for making sure that the display is synchronized with
	// the current state of the program. Calling [method@Gdk.Display.sync]
	// before [method@GdkX11.Display.error_trap_pop] makes sure that any errors
	// generated from earlier requests are handled before the error trap is
	// removed.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	SyncDisplay()
	// TranslateKeyDisplay translates the contents of a `GdkEventKey` into a
	// keyval, effective group, and level.
	//
	// Modifiers that affected the translation and are thus unavailable for
	// application use are returned in @consumed_modifiers.
	//
	// The @effective_group is the group that was actually used for the
	// translation; some keys such as Enter are not affected by the active
	// keyboard group. The @level is derived from @state.
	//
	// @consumed_modifiers gives modifiers that should be masked out from @state
	// when comparing this key press to a keyboard shortcut. For instance, on a
	// US keyboard, the `plus` symbol is shifted, so when comparing a key press
	// to a `<Control>plus` accelerator `<Shift>` should be masked out.
	//
	// This function should rarely be needed, since `GdkEventKey` already
	// contains the translated keyval. It is exported for the benefit of
	// virtualized test environments.
	TranslateKeyDisplay(keycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumed ModifierType, ok bool)
}

// display implements the Display class.
type display struct {
	gextras.Objector
}

// WrapDisplay wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplay(obj *externglib.Object) Display {
	return display{
		Objector: obj,
	}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplay(obj), nil
}

func (d display) BeepDisplay() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_beep(_arg0)
}

func (d display) CloseDisplay() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_close(_arg0)
}

func (d display) DeviceIsGrabbedDisplay(device Device) bool {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkDevice  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gdk_display_device_is_grabbed(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) FlushDisplay() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_flush(_arg0)
}

func (d display) AppLaunchContext() AppLaunchContext {
	var _arg0 *C.GdkDisplay          // out
	var _cret *C.GdkAppLaunchContext // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_app_launch_context(_arg0)

	var _appLaunchContext AppLaunchContext // out

	_appLaunchContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(AppLaunchContext)

	return _appLaunchContext
}

func (d display) Clipboard() Clipboard {
	var _arg0 *C.GdkDisplay   // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_clipboard(_arg0)

	var _clipboard Clipboard // out

	_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Clipboard)

	return _clipboard
}

func (d display) DefaultSeat() Seat {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkSeat    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_default_seat(_arg0)

	var _seat Seat // out

	_seat = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Seat)

	return _seat
}

func (d display) MonitorAtSurface(surface Surface) Monitor {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkSurface // out
	var _cret *C.GdkMonitor // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

	_cret = C.gdk_display_get_monitor_at_surface(_arg0, _arg1)

	var _monitor Monitor // out

	_monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Monitor)

	return _monitor
}

func (s display) Monitors() gio.ListModel {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_display_get_monitors(_arg0)

	var _listModel gio.ListModel // out

	_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

	return _listModel
}

func (d display) Name() string {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d display) PrimaryClipboard() Clipboard {
	var _arg0 *C.GdkDisplay   // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_primary_clipboard(_arg0)

	var _clipboard Clipboard // out

	_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Clipboard)

	return _clipboard
}

func (d display) Setting(name string, value externglib.Value) bool {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.char       // out
	var _arg2 *C.GValue     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.gdk_display_get_setting(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) StartupNotificationID() string {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_get_startup_notification_id(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (d display) IsClosedDisplay() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_is_closed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) IsCompositedDisplay() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_is_composited(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) IsRGBADisplay() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_is_rgba(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) MapKeycodeDisplay(keycode uint) ([]KeymapKey, []uint, bool) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint       // out
	var _arg2 *C.GdkKeymapKey
	var _arg4 C.int // in
	var _arg3 *C.guint
	var _arg4 C.int      // in
	var _cret C.gboolean // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = C.guint(keycode)

	_cret = C.gdk_display_map_keycode(_arg0, _arg1, &_arg2, &_arg3, &_arg4)

	var _keys []KeymapKey
	var _keyvals []uint
	var _ok bool // out

	_keys = unsafe.Slice((*KeymapKey)(unsafe.Pointer(_arg2)), _arg4)
	runtime.SetFinalizer(&_keys, func(v *[]KeymapKey) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_keyvals = unsafe.Slice((*uint)(unsafe.Pointer(_arg3)), _arg4)
	runtime.SetFinalizer(&_keyvals, func(v *[]uint) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _keys, _keyvals, _ok
}

func (d display) MapKeyvalDisplay(keyval uint) ([]KeymapKey, bool) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint       // out
	var _arg2 *C.GdkKeymapKey
	var _arg3 C.int      // in
	var _cret C.gboolean // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = C.guint(keyval)

	_cret = C.gdk_display_map_keyval(_arg0, _arg1, &_arg2, &_arg3)

	var _keys []KeymapKey
	var _ok bool // out

	_keys = unsafe.Slice((*KeymapKey)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_keys, func(v *[]KeymapKey) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _keys, _ok
}

func (d display) NotifyStartupCompleteDisplay(startupId string) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_display_notify_startup_complete(_arg0, _arg1)
}

func (d display) PutEventDisplay(event Event) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkEvent   // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	C.gdk_display_put_event(_arg0, _arg1)
}

func (d display) SupportsInputShapesDisplay() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_display_supports_input_shapes(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (d display) SyncDisplay() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_sync(_arg0)
}

func (d display) TranslateKeyDisplay(keycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumed ModifierType, ok bool) {
	var _arg0 *C.GdkDisplay     // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _arg3 C.int             // out
	var _arg4 C.guint           // in
	var _arg5 C.int             // in
	var _arg6 C.int             // in
	var _arg7 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	_arg1 = C.guint(keycode)
	_arg2 = C.GdkModifierType(state)
	_arg3 = C.int(group)

	_cret = C.gdk_display_translate_key(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)

	var _keyval uint           // out
	var _effectiveGroup int    // out
	var _level int             // out
	var _consumed ModifierType // out
	var _ok bool               // out

	_keyval = uint(_arg4)
	_effectiveGroup = int(_arg5)
	_level = int(_arg6)
	_consumed = ModifierType(_arg7)
	if _cret != 0 {
		_ok = true
	}

	return _keyval, _effectiveGroup, _level, _consumed, _ok
}

// DisplayManager: a singleton object that offers notification when displays
// appear or disappear.
//
// You can use [func@Gdk.DisplayManager.get] to obtain the `GdkDisplayManager`
// singleton, but that should be rarely necessary. Typically, initializing GTK
// opens a display that you can work with without ever accessing the
// `GdkDisplayManager`.
//
// The GDK library can be built with support for multiple backends. The
// `GdkDisplayManager` object determines which backend is used at runtime.
//
// In the rare case that you need to influence which of the backends is being
// used, you can use [func@Gdk.set_allowed_backends]. Note that you need to call
// this function before initializing GTK.
//
//
// Backend-specific code
//
// When writing backend-specific code that is supposed to work with multiple GDK
// backends, you have to consider both compile time and runtime. At compile
// time, use the K_WINDOWING_X11, K_WINDOWING_WIN32 macros, etc. to find out
// which backends are present in the GDK library you are building your
// application against. At runtime, use type-check macros like
// GDK_IS_X11_DISPLAY() to find out which backend is in use:
//
// “`c #ifdef GDK_WINDOWING_X11 if (GDK_IS_X11_DISPLAY (display)) { // make
// X11-specific calls here } else #endif #ifdef GDK_WINDOWING_MACOS if
// (GDK_IS_MACOS_DISPLAY (display)) { // make Quartz-specific calls here } else
// #endif g_error ("Unsupported GDK backend"); “`
type DisplayManager interface {
	gextras.Objector

	// DefaultDisplay gets the default `GdkDisplay`.
	DefaultDisplay() Display
	// OpenDisplayDisplayManager opens a display.
	OpenDisplayDisplayManager(name string) Display
	// SetDefaultDisplayDisplayManager sets @display as the default display.
	SetDefaultDisplayDisplayManager(display Display)
}

// displayManager implements the DisplayManager class.
type displayManager struct {
	gextras.Objector
}

// WrapDisplayManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplayManager(obj *externglib.Object) DisplayManager {
	return displayManager{
		Objector: obj,
	}
}

func marshalDisplayManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplayManager(obj), nil
}

func (m displayManager) DefaultDisplay() Display {
	var _arg0 *C.GdkDisplayManager // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_display_manager_get_default_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (m displayManager) OpenDisplayDisplayManager(name string) Display {
	var _arg0 *C.GdkDisplayManager // out
	var _arg1 *C.char              // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_display_manager_open_display(_arg0, _arg1)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (m displayManager) SetDefaultDisplayDisplayManager(display Display) {
	var _arg0 *C.GdkDisplayManager // out
	var _arg1 *C.GdkDisplay        // out

	_arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gdk_display_manager_set_default_display(_arg0, _arg1)
}

// Drag: the `GdkDrag` object represents the source of an ongoing DND operation.
//
// A `GdkDrag` is created when a drag is started, and stays alive for duration
// of the DND operation. After a drag has been started with
// [func@Gdk.Drag.begin], the caller gets informed about the status of the
// ongoing drag operation with signals on the `GdkDrag` object.
//
// GTK provides a higher level abstraction based on top of these functions, and
// so they are not normally needed in GTK applications. See the "Drag and Drop"
// section of the GTK documentation for more information.
type Drag interface {
	gextras.Objector

	// DropDoneDrag informs GDK that the drop ended.
	//
	// Passing false for @success may trigger a drag cancellation animation.
	//
	// This function is called by the drag source, and should be the last call
	// before dropping the reference to the @drag.
	//
	// The `GdkDrag` will only take the first [method@Gdk.Drag.drop_done] call
	// as effective, if this function is called multiple times, all subsequent
	// calls will be ignored.
	DropDoneDrag(success bool)
	// Actions determines the bitmask of possible actions proposed by the
	// source.
	Actions() DragAction
	// Content returns the `GdkContentProvider` associated to the `GdkDrag`
	// object.
	Content() ContentProvider
	// Device returns the `GdkDevice` associated to the `GdkDrag` object.
	Device() Device
	// Display gets the `GdkDisplay` that the drag object was created for.
	Display() Display
	// DragSurface returns the surface on which the drag icon should be rendered
	// during the drag operation.
	//
	// Note that the surface may not be available until the drag operation has
	// begun. GDK will move the surface in accordance with the ongoing drag
	// operation. The surface is owned by @drag and will be destroyed when the
	// drag operation is over.
	DragSurface() Surface
	// Formats retrieves the formats supported by this `GdkDrag` object.
	Formats() *ContentFormats
	// SelectedAction determines the action chosen by the drag destination.
	SelectedAction() DragAction
	// Surface returns the `GdkSurface` where the drag originates.
	Surface() Surface
	// SetHotspotDrag sets the position of the drag surface that will be kept
	// under the cursor hotspot.
	//
	// Initially, the hotspot is at the top left corner of the drag surface.
	SetHotspotDrag(hotX int, hotY int)
}

// drag implements the Drag class.
type drag struct {
	gextras.Objector
}

// WrapDrag wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrag(obj *externglib.Object) Drag {
	return drag{
		Objector: obj,
	}
}

func marshalDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrag(obj), nil
}

func (d drag) DropDoneDrag(success bool) {
	var _arg0 *C.GdkDrag // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))
	if success {
		_arg1 = C.TRUE
	}

	C.gdk_drag_drop_done(_arg0, _arg1)
}

func (d drag) Actions() DragAction {
	var _arg0 *C.GdkDrag      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_actions(_arg0)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

func (d drag) Content() ContentProvider {
	var _arg0 *C.GdkDrag            // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_content(_arg0)

	var _contentProvider ContentProvider // out

	_contentProvider = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ContentProvider)

	return _contentProvider
}

func (d drag) Device() Device {
	var _arg0 *C.GdkDrag   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_device(_arg0)

	var _device Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Device)

	return _device
}

func (d drag) Display() Display {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (d drag) DragSurface() Surface {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_drag_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (d drag) Formats() *ContentFormats {
	var _arg0 *C.GdkDrag           // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))

	return _contentFormats
}

func (d drag) SelectedAction() DragAction {
	var _arg0 *C.GdkDrag      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_selected_action(_arg0)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

func (d drag) Surface() Surface {
	var _arg0 *C.GdkDrag    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))

	_cret = C.gdk_drag_get_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (d drag) SetHotspotDrag(hotX int, hotY int) {
	var _arg0 *C.GdkDrag // out
	var _arg1 C.int      // out
	var _arg2 C.int      // out

	_arg0 = (*C.GdkDrag)(unsafe.Pointer(d.Native()))
	_arg1 = C.int(hotX)
	_arg2 = C.int(hotY)

	C.gdk_drag_set_hotspot(_arg0, _arg1, _arg2)
}

// DrawContext: base class for objects implementing different rendering methods.
//
// `GdkDrawContext` is the base object used by contexts implementing different
// rendering methods, such as [class@Gdk.CairoContext] or [class@Gdk.GLContext].
// It provides shared functionality between those contexts.
//
// You will always interact with one of those subclasses.
//
// A `GdkDrawContext` is always associated with a single toplevel surface.
type DrawContext interface {
	gextras.Objector

	// BeginFrameDrawContext indicates that you are beginning the process of
	// redrawing @region on the @context's surface.
	//
	// Calling this function begins a drawing operation using @context on the
	// surface that @context was created from. The actual requirements and
	// guarantees for the drawing operation vary for different implementations
	// of drawing, so a [class@Gdk.CairoContext] and a [class@Gdk.GLContext]
	// need to be treated differently.
	//
	// A call to this function is a requirement for drawing and must be followed
	// by a call to [method@Gdk.DrawContext.end_frame], which will complete the
	// drawing operation and ensure the contents become visible on screen.
	//
	// Note that the @region passed to this function is the minimum region that
	// needs to be drawn and depending on implementation, windowing system and
	// hardware in use, it might be necessary to draw a larger region. Drawing
	// implementation must use [method@Gdk.DrawContext.get_frame_region() to
	// query the region that must be drawn.
	//
	// When using GTK, the widget system automatically places calls to
	// gdk_draw_context_begin_frame() and gdk_draw_context_end_frame() via the
	// use of [class@Gsk.Renderer]s, so application code does not need to call
	// these functions explicitly.
	BeginFrameDrawContext(region *cairo.Region)
	// EndFrameDrawContext ends a drawing operation started with
	// gdk_draw_context_begin_frame().
	//
	// This makes the drawing available on screen. See
	// [method@Gdk.DrawContext.begin_frame] for more details about drawing.
	//
	// When using a [class@Gdk.GLContext], this function may call `glFlush()`
	// implicitly before returning; it is not recommended to call `glFlush()`
	// explicitly before calling this function.
	EndFrameDrawContext()
	// Display retrieves the `GdkDisplay` the @context is created for
	Display() Display
	// FrameRegion retrieves the region that is currently being repainted.
	//
	// After a call to [method@Gdk.DrawContext.begin_frame] this function will
	// return a union of the region passed to that function and the area of the
	// surface that the @context determined needs to be repainted.
	//
	// If @context is not in between calls to
	// [method@Gdk.DrawContext.begin_frame] and
	// [method@Gdk.DrawContext.end_frame], nil will be returned.
	FrameRegion() *cairo.Region
	// Surface retrieves the surface that @context is bound to.
	Surface() Surface
	// IsInFrameDrawContext returns true if @context is in the process of
	// drawing to its surface.
	//
	// This is the case between calls to [method@Gdk.DrawContext.begin_frame]
	// and [method@Gdk.DrawContext.end_frame]. In this situation, drawing
	// commands may be effecting the contents of the @context's surface.
	IsInFrameDrawContext() bool
}

// drawContext implements the DrawContext class.
type drawContext struct {
	gextras.Objector
}

// WrapDrawContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrawContext(obj *externglib.Object) DrawContext {
	return drawContext{
		Objector: obj,
	}
}

func marshalDrawContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrawContext(obj), nil
}

func (c drawContext) BeginFrameDrawContext(region *cairo.Region) {
	var _arg0 *C.GdkDrawContext // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_draw_context_begin_frame(_arg0, _arg1)
}

func (c drawContext) EndFrameDrawContext() {
	var _arg0 *C.GdkDrawContext // out

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))

	C.gdk_draw_context_end_frame(_arg0)
}

func (c drawContext) Display() Display {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.GdkDisplay     // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_draw_context_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (c drawContext) FrameRegion() *cairo.Region {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.cairo_region_t // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_draw_context_get_frame_region(_arg0)

	var _region *cairo.Region // out

	_region = (*cairo.Region)(unsafe.Pointer(_cret))

	return _region
}

func (c drawContext) Surface() Surface {
	var _arg0 *C.GdkDrawContext // out
	var _cret *C.GdkSurface     // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_draw_context_get_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (c drawContext) IsInFrameDrawContext() bool {
	var _arg0 *C.GdkDrawContext // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDrawContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_draw_context_is_in_frame(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Drop: the `GdkDrop` object represents the target of an ongoing DND operation.
//
// Possible drop sites get informed about the status of the ongoing drag
// operation with events of type GDK_DRAG_ENTER, GDK_DRAG_LEAVE, GDK_DRAG_MOTION
// and GDK_DROP_START. The `GdkDrop` object can be obtained from these
// [class@Gdk.Event] types using [method@Gdk.DNDEvent.get_drop].
//
// The actual data transfer is initiated from the target side via an async read,
// using one of the `GdkDrop` methods for this purpose:
// [method@Gdk.Drop.read_async] or [method@Gdk.Drop.read_value_async].
//
// GTK provides a higher level abstraction based on top of these functions, and
// so they are not normally needed in GTK applications. See the "Drag and Drop"
// section of the GTK documentation for more information.
type Drop interface {
	gextras.Objector

	// FinishDrop ends the drag operation after a drop.
	//
	// The @action must be a single action selected from the actions available
	// via [method@Gdk.Drop.get_actions].
	FinishDrop(action DragAction)
	// Actions returns the possible actions for this `GdkDrop`.
	//
	// If this value contains multiple actions - i.e.
	// [func@Gdk.DragAction.is_unique] returns false for the result -
	// [method@Gdk.Drop.finish] must choose the action to use when accepting the
	// drop. This will only happen if you passed GDK_ACTION_ASK as one of the
	// possible actions in [method@Gdk.Drop.status]. GDK_ACTION_ASK itself will
	// not be included in the actions returned by this function.
	//
	// This value may change over the lifetime of the [class@Gdk.Drop] both as a
	// response to source side actions as well as to calls to
	// [method@Gdk.Drop.status] or [method@Gdk.Drop.finish]. The source side
	// will not change this value anymore once a drop has started.
	Actions() DragAction
	// Device returns the `GdkDevice` performing the drop.
	Device() Device
	// Display gets the `GdkDisplay` that @self was created for.
	Display() Display
	// Drag: if this is an in-app drag-and-drop operation, returns the `GdkDrag`
	// that corresponds to this drop.
	//
	// If it is not, nil is returned.
	Drag() Drag
	// Formats returns the `GdkContentFormats` that the drop offers the data to
	// be read in.
	Formats() *ContentFormats
	// Surface returns the `GdkSurface` performing the drop.
	Surface() Surface
	// ReadFinishDrop finishes an async drop read operation.
	//
	// Note that you must not use blocking read calls on the returned stream in
	// the GTK thread, since some platforms might require communication with GTK
	// to complete the data transfer. You can use async APIs such as
	// g_input_stream_read_bytes_async().
	//
	// See [method@Gdk.Drop.read_async].
	ReadFinishDrop(result gio.AsyncResult) (string, gio.InputStream, error)
	// ReadValueFinishDrop finishes an async drop read.
	//
	// See [method@Gdk.Drop.read_value_async].
	ReadValueFinishDrop(result gio.AsyncResult) (externglib.Value, error)
	// StatusDrop selects all actions that are potentially supported by the
	// destination.
	//
	// When calling this function, do not restrict the passed in actions to the
	// ones provided by [method@Gdk.Drop.get_actions]. Those actions may change
	// in the future, even depending on the actions you provide here.
	//
	// The @preferred action is a hint to the drag'n'drop mechanism about which
	// action to use when multiple actions are possible.
	//
	// This function should be called by drag destinations in response to
	// GDK_DRAG_ENTER or GDK_DRAG_MOTION events. If the destination does not yet
	// know the exact actions it supports, it should set any possible actions
	// first and then later call this function again.
	StatusDrop(actions DragAction, preferred DragAction)
}

// drop implements the Drop class.
type drop struct {
	gextras.Objector
}

// WrapDrop wraps a GObject to the right type. It is
// primarily used internally.
func WrapDrop(obj *externglib.Object) Drop {
	return drop{
		Objector: obj,
	}
}

func marshalDrop(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDrop(obj), nil
}

func (s drop) FinishDrop(action DragAction) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 C.GdkDragAction // out

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))
	_arg1 = C.GdkDragAction(action)

	C.gdk_drop_finish(_arg0, _arg1)
}

func (s drop) Actions() DragAction {
	var _arg0 *C.GdkDrop      // out
	var _cret C.GdkDragAction // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_actions(_arg0)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

func (s drop) Device() Device {
	var _arg0 *C.GdkDrop   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_device(_arg0)

	var _device Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Device)

	return _device
}

func (s drop) Display() Display {
	var _arg0 *C.GdkDrop    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (s drop) Drag() Drag {
	var _arg0 *C.GdkDrop // out
	var _cret *C.GdkDrag // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_drag(_arg0)

	var _drag Drag // out

	_drag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Drag)

	return _drag
}

func (s drop) Formats() *ContentFormats {
	var _arg0 *C.GdkDrop           // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))

	return _contentFormats
}

func (s drop) Surface() Surface {
	var _arg0 *C.GdkDrop    // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_drop_get_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (s drop) ReadFinishDrop(result gio.AsyncResult) (string, gio.InputStream, error) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.char         // in
	var _cret *C.GInputStream // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_drop_read_finish(_arg0, _arg1, &_arg2, &_cerr)

	var _outMimeType string          // out
	var _inputStream gio.InputStream // out
	var _goerr error                 // out

	_outMimeType = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_inputStream = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.InputStream)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _outMimeType, _inputStream, _goerr
}

func (s drop) ReadValueFinishDrop(result gio.AsyncResult) (externglib.Value, error) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GValue       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.gdk_drop_read_value_finish(_arg0, _arg1, &_cerr)

	var _value externglib.Value // out
	var _goerr error            // out

	_value = externglib.ValueFromNative(unsafe.Pointer(_cret))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _value, _goerr
}

func (s drop) StatusDrop(actions DragAction, preferred DragAction) {
	var _arg0 *C.GdkDrop      // out
	var _arg1 C.GdkDragAction // out
	var _arg2 C.GdkDragAction // out

	_arg0 = (*C.GdkDrop)(unsafe.Pointer(s.Native()))
	_arg1 = C.GdkDragAction(actions)
	_arg2 = C.GdkDragAction(preferred)

	C.gdk_drop_status(_arg0, _arg1, _arg2)
}

// FocusEvent: an event related to a keyboard focus change.
type FocusEvent interface {
	Event

	// In extracts whether this event is about focus entering or leaving the
	// surface.
	In() bool
}

// focusEvent implements the FocusEvent class.
type focusEvent struct {
	Event
}

// WrapFocusEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapFocusEvent(obj *externglib.Object) FocusEvent {
	return focusEvent{
		Event: WrapEvent(obj),
	}
}

func marshalFocusEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFocusEvent(obj), nil
}

func (e focusEvent) In() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_focus_event_get_in(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameClock: a `GdkFrameClock` tells the application when to update and
// repaint a surface.
//
// This may be synced to the vertical refresh rate of the monitor, for example.
// Even when the frame clock uses a simple timer rather than a hardware-based
// vertical sync, the frame clock helps because it ensures everything paints at
// the same time (reducing the total number of frames).
//
// The frame clock can also automatically stop painting when it knows the frames
// will not be visible, or scale back animation framerates.
//
// `GdkFrameClock` is designed to be compatible with an OpenGL-based
// implementation or with mozRequestAnimationFrame in Firefox, for example.
//
// A frame clock is idle until someone requests a frame with
// [method@Gdk.FrameClock.request_phase]. At some later point that makes sense
// for the synchronization being implemented, the clock will process a frame and
// emit signals for each phase that has been requested. (See the signals of the
// `GdkFrameClock` class for documentation of the phases.
// GDK_FRAME_CLOCK_PHASE_UPDATE and the [signal@GdkFrameClock::update] signal
// are most interesting for application writers, and are used to update the
// animations, using the frame time given by
// [metohd@Gdk.FrameClock.get_frame_time].
//
// The frame time is reported in microseconds and generally in the same
// timescale as g_get_monotonic_time(), however, it is not the same as
// g_get_monotonic_time(). The frame time does not advance during the time a
// frame is being painted, and outside of a frame, an attempt is made so that
// all calls to [method@Gdk.FrameClock.get_frame_time] that are called at a
// “similar” time get the same value. This means that if different animations
// are timed by looking at the difference in time between an initial value from
// [method@Gdk.FrameClock.get_frame_time] and the value inside the
// [signal@GdkFrameClock::update] signal of the clock, they will stay exactly
// synchronized.
type FrameClock interface {
	gextras.Objector

	// BeginUpdatingFrameClock starts updates for an animation.
	//
	// Until a matching call to [method@Gdk.FrameClock.end_updating] is made,
	// the frame clock will continually request a new frame with the
	// GDK_FRAME_CLOCK_PHASE_UPDATE phase. This function may be called multiple
	// times and frames will be requested until gdk_frame_clock_end_updating()
	// is called the same number of times.
	BeginUpdatingFrameClock()
	// EndUpdatingFrameClock stops updates for an animation.
	//
	// See the documentation for [method@Gdk.FrameClock.begin_updating].
	EndUpdatingFrameClock()
	// CurrentTimings gets the frame timings for the current frame.
	CurrentTimings() *FrameTimings
	// Fps calculates the current frames-per-second, based on the frame timings
	// of @frame_clock.
	Fps() float64
	// FrameCounter: `GdkFrameClock` maintains a 64-bit counter that increments
	// for each frame drawn.
	FrameCounter() int64
	// FrameTime gets the time that should currently be used for animations.
	//
	// Inside the processing of a frame, it’s the time used to compute the
	// animation position of everything in a frame. Outside of a frame, it's the
	// time of the conceptual “previous frame,” which may be either the actual
	// previous frame time, or if that’s too old, an updated time.
	FrameTime() int64
	// HistoryStart returns the frame counter for the oldest frame available in
	// history.
	//
	// `GdkFrameClock` internally keeps a history of `GdkFrameTimings` objects
	// for recent frames that can be retrieved with
	// [method@Gdk.FrameClock.get_timings]. The set of stored frames is the set
	// from the counter values given by
	// [method@Gdk.FrameClock.get_history_start] and
	// [method@Gdk.FrameClock.get_frame_counter], inclusive.
	HistoryStart() int64
	// RefreshInfo predicts a presentation time, based on history.
	//
	// Using the frame history stored in the frame clock, finds the last known
	// presentation time and refresh interval, and assuming that presentation
	// times are separated by the refresh interval, predicts a presentation time
	// that is a multiple of the refresh interval after the last presentation
	// time, and later than @base_time.
	RefreshInfo(baseTime int64) (refreshIntervalReturn int64, presentationTimeReturn int64)
	// Timings retrieves a `GdkFrameTimings` object holding timing information
	// for the current frame or a recent frame.
	//
	// The `GdkFrameTimings` object may not yet be complete: see
	// [method@Gdk.FrameTimings.get_complete].
	Timings(frameCounter int64) *FrameTimings
	// RequestPhaseFrameClock asks the frame clock to run a particular phase.
	//
	// The signal corresponding the requested phase will be emitted the next
	// time the frame clock processes. Multiple calls to
	// gdk_frame_clock_request_phase() will be combined together and only one
	// frame processed. If you are displaying animated content and want to
	// continually request the GDK_FRAME_CLOCK_PHASE_UPDATE phase for a period
	// of time, you should use [method@Gdk.FrameClock.begin_updating] instead,
	// since this allows GTK to adjust system parameters to get maximally smooth
	// animations.
	RequestPhaseFrameClock(phase FrameClockPhase)
}

// frameClock implements the FrameClock class.
type frameClock struct {
	gextras.Objector
}

// WrapFrameClock wraps a GObject to the right type. It is
// primarily used internally.
func WrapFrameClock(obj *externglib.Object) FrameClock {
	return frameClock{
		Objector: obj,
	}
}

func marshalFrameClock(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFrameClock(obj), nil
}

func (f frameClock) BeginUpdatingFrameClock() {
	var _arg0 *C.GdkFrameClock // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	C.gdk_frame_clock_begin_updating(_arg0)
}

func (f frameClock) EndUpdatingFrameClock() {
	var _arg0 *C.GdkFrameClock // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	C.gdk_frame_clock_end_updating(_arg0)
}

func (f frameClock) CurrentTimings() *FrameTimings {
	var _arg0 *C.GdkFrameClock   // out
	var _cret *C.GdkFrameTimings // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_frame_clock_get_current_timings(_arg0)

	var _frameTimings *FrameTimings // out

	_frameTimings = (*FrameTimings)(unsafe.Pointer(_cret))

	return _frameTimings
}

func (f frameClock) Fps() float64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.double         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_frame_clock_get_fps(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

func (f frameClock) FrameCounter() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_frame_clock_get_frame_counter(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

func (f frameClock) FrameTime() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_frame_clock_get_frame_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

func (f frameClock) HistoryStart() int64 {
	var _arg0 *C.GdkFrameClock // out
	var _cret C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_frame_clock_get_history_start(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

func (f frameClock) RefreshInfo(baseTime int64) (refreshIntervalReturn int64, presentationTimeReturn int64) {
	var _arg0 *C.GdkFrameClock // out
	var _arg1 C.gint64         // out
	var _arg2 C.gint64         // in
	var _arg3 C.gint64         // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))
	_arg1 = C.gint64(baseTime)

	C.gdk_frame_clock_get_refresh_info(_arg0, _arg1, &_arg2, &_arg3)

	var _refreshIntervalReturn int64  // out
	var _presentationTimeReturn int64 // out

	_refreshIntervalReturn = int64(_arg2)
	_presentationTimeReturn = int64(_arg3)

	return _refreshIntervalReturn, _presentationTimeReturn
}

func (f frameClock) Timings(frameCounter int64) *FrameTimings {
	var _arg0 *C.GdkFrameClock   // out
	var _arg1 C.gint64           // out
	var _cret *C.GdkFrameTimings // in

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))
	_arg1 = C.gint64(frameCounter)

	_cret = C.gdk_frame_clock_get_timings(_arg0, _arg1)

	var _frameTimings *FrameTimings // out

	_frameTimings = (*FrameTimings)(unsafe.Pointer(_cret))

	return _frameTimings
}

func (f frameClock) RequestPhaseFrameClock(phase FrameClockPhase) {
	var _arg0 *C.GdkFrameClock     // out
	var _arg1 C.GdkFrameClockPhase // out

	_arg0 = (*C.GdkFrameClock)(unsafe.Pointer(f.Native()))
	_arg1 = C.GdkFrameClockPhase(phase)

	C.gdk_frame_clock_request_phase(_arg0, _arg1)
}

// GLContext: `GdkGLContext` is an object representing a platform-specific
// OpenGL draw context.
//
// `GdkGLContext`s are created for a surface using
// [method@Gdk.Surface.create_gl_context], and the context will match the the
// characteristics of the surface.
//
// A `GdkGLContext` is not tied to any particular normal framebuffer. For
// instance, it cannot draw to the surface back buffer. The GDK repaint system
// is in full control of the painting to that. Instead, you can create render
// buffers or textures and use [func@cairo_draw_from_gl] in the draw function of
// your widget to draw them. Then GDK will handle the integration of your
// rendering with that of other widgets.
//
// Support for `GdkGLContext` is platform-specific and context creation can
// fail, returning nil context.
//
// A `GdkGLContext` has to be made "current" in order to start using it,
// otherwise any OpenGL call will be ignored.
//
//
// Creating a new OpenGL context
//
// In order to create a new `GdkGLContext` instance you need a `GdkSurface`,
// which you typically get during the realize call of a widget.
//
// A `GdkGLContext` is not realized until either
// [method@Gdk.GLContext.make_current] or [method@Gdk.GLContext.realize] is
// called. It is possible to specify details of the GL context like the OpenGL
// version to be used, or whether the GL context should have extra state
// validation enabled after calling [method@Gdk.Surface.create_gl_context] by
// calling [method@Gdk.GLContext.realize]. If the realization fails you have the
// option to change the settings of the `GdkGLContext` and try again.
//
//
// Using a GdkGLContext
//
// You will need to make the `GdkGLContext` the current context before issuing
// OpenGL calls; the system sends OpenGL commands to whichever context is
// current. It is possible to have multiple contexts, so you always need to
// ensure that the one which you want to draw with is the current one before
// issuing commands:
//
// “`c gdk_gl_context_make_current (context); “`
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which `GdkGLContext` is the current one by using
// [func@Gdk.GLContext.get_current]; you can also unset any `GdkGLContext` that
// is currently set by calling [func@Gdk.GLContext.clear_current].
type GLContext interface {
	DrawContext

	// DebugEnabled retrieves whether the context is doing extra validations and
	// runtime checking.
	//
	// See [method@Gdk.GLContext.set_debug_enabled].
	DebugEnabled() bool
	// Display retrieves the display the @context is created for
	Display() Display
	// ForwardCompatible retrieves whether the context is forward-compatible.
	//
	// See [method@Gdk.GLContext.set_forward_compatible].
	ForwardCompatible() bool
	// RequiredVersion retrieves required OpenGL version.
	//
	// See [method@Gdk.GLContext.set_required_version].
	RequiredVersion() (major int, minor int)
	// SharedContext retrieves the `GdkGLContext` that this @context share data
	// with.
	SharedContext() GLContext
	// Surface retrieves the surface used by the @context.
	Surface() Surface
	// UseES checks whether the @context is using an OpenGL or OpenGL ES
	// profile.
	UseES() bool
	// Version retrieves the OpenGL version of the @context.
	//
	// The @context must be realized prior to calling this function.
	Version() (major int, minor int)
	// IsLegacyGLContext: whether the `GdkGLContext` is in legacy mode or not.
	//
	// The `GdkGLContext` must be realized before calling this function.
	//
	// When realizing a GL context, GDK will try to use the OpenGL 3.2 core
	// profile; this profile removes all the OpenGL API that was deprecated
	// prior to the 3.2 version of the specification. If the realization is
	// successful, this function will return false.
	//
	// If the underlying OpenGL implementation does not support core profiles,
	// GDK will fall back to a pre-3.2 compatibility profile, and this function
	// will return true.
	//
	// You can use the value returned by this function to decide which kind of
	// OpenGL API to use, or whether to do extension discovery, or what kind of
	// shader programs to load.
	IsLegacyGLContext() bool
	// MakeCurrentGLContext makes the @context the current one.
	MakeCurrentGLContext()
	// RealizeGLContext realizes the given `GdkGLContext`.
	//
	// It is safe to call this function on a realized `GdkGLContext`.
	RealizeGLContext() error
	// SetDebugEnabledGLContext sets whether the `GdkGLContext` should perform
	// extra validations and runtime checking.
	//
	// This is useful during development, but has additional overhead.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetDebugEnabledGLContext(enabled bool)
	// SetForwardCompatibleGLContext sets whether the `GdkGLContext` should be
	// forward-compatible.
	//
	// Forward-compatible contexts must not support OpenGL functionality that
	// has been marked as deprecated in the requested version; non-forward
	// compatible contexts, on the other hand, must support both deprecated and
	// non deprecated functionality.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetForwardCompatibleGLContext(compatible bool)
	// SetRequiredVersionGLContext sets the major and minor version of OpenGL to
	// request.
	//
	// Setting @major and @minor to zero will use the default values.
	//
	// The `GdkGLContext` must not be realized or made current prior to calling
	// this function.
	SetRequiredVersionGLContext(major int, minor int)
	// SetUseESGLContext requests that GDK create an OpenGL ES context instead
	// of an OpenGL one.
	//
	// Not all platforms support OpenGL ES.
	//
	// The @context must not have been realized.
	//
	// By default, GDK will attempt to automatically detect whether the
	// underlying GL implementation is OpenGL or OpenGL ES once the @context is
	// realized.
	//
	// You should check the return value of [method@Gdk.GLContext.get_use_es]
	// after calling [method@Gdk.GLContext.realize] to decide whether to use the
	// OpenGL or OpenGL ES API, extensions, or shaders.
	SetUseESGLContext(useEs int)
}

// glContext implements the GLContext class.
type glContext struct {
	DrawContext
}

// WrapGLContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLContext(obj *externglib.Object) GLContext {
	return glContext{
		DrawContext: WrapDrawContext(obj),
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLContext(obj), nil
}

func (c glContext) DebugEnabled() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_debug_enabled(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c glContext) Display() Display {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (c glContext) ForwardCompatible() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_forward_compatible(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c glContext) RequiredVersion() (major int, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // in
	var _arg2 C.int           // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	C.gdk_gl_context_get_required_version(_arg0, &_arg1, &_arg2)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

func (c glContext) SharedContext() GLContext {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkGLContext // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_shared_context(_arg0)

	var _glContext GLContext // out

	_glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(GLContext)

	return _glContext
}

func (c glContext) Surface() Surface {
	var _arg0 *C.GdkGLContext // out
	var _cret *C.GdkSurface   // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (c glContext) UseES() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_get_use_es(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c glContext) Version() (major int, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // in
	var _arg2 C.int           // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	C.gdk_gl_context_get_version(_arg0, &_arg1, &_arg2)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

func (c glContext) IsLegacyGLContext() bool {
	var _arg0 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_gl_context_is_legacy(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c glContext) MakeCurrentGLContext() {
	var _arg0 *C.GdkGLContext // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	C.gdk_gl_context_make_current(_arg0)
}

func (c glContext) RealizeGLContext() error {
	var _arg0 *C.GdkGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	C.gdk_gl_context_realize(_arg0, &_cerr)

	var _goerr error // out

	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _goerr
}

func (c glContext) SetDebugEnabledGLContext(enabled bool) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gdk_gl_context_set_debug_enabled(_arg0, _arg1)
}

func (c glContext) SetForwardCompatibleGLContext(compatible bool) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	if compatible {
		_arg1 = C.TRUE
	}

	C.gdk_gl_context_set_forward_compatible(_arg0, _arg1)
}

func (c glContext) SetRequiredVersionGLContext(major int, minor int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(major)
	_arg2 = C.int(minor)

	C.gdk_gl_context_set_required_version(_arg0, _arg1, _arg2)
}

func (c glContext) SetUseESGLContext(useEs int) {
	var _arg0 *C.GdkGLContext // out
	var _arg1 C.int           // out

	_arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.int(useEs)

	C.gdk_gl_context_set_use_es(_arg0, _arg1)
}

// GLTexture: a GdkTexture representing a GL texture object.
type GLTexture interface {
	Texture

	// ReleaseGLTexture releases the GL resources held by a `GdkGLTexture`.
	//
	// The texture contents are still available via the
	// [method@Gdk.Texture.download] function, after this function has been
	// called.
	ReleaseGLTexture()
}

// glTexture implements the GLTexture class.
type glTexture struct {
	Texture
}

// WrapGLTexture wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLTexture(obj *externglib.Object) GLTexture {
	return glTexture{
		Texture: WrapTexture(obj),
	}
}

func marshalGLTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLTexture(obj), nil
}

func (s glTexture) ReleaseGLTexture() {
	var _arg0 *C.GdkGLTexture // out

	_arg0 = (*C.GdkGLTexture)(unsafe.Pointer(s.Native()))

	C.gdk_gl_texture_release(_arg0)
}

func (p glTexture) ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (concreteWidth float64, concreteHeight float64) {
	return WrapPaintable(gextras.InternObject(p)).ComputeConcreteSize(specifiedWidth, specifiedHeight, defaultWidth, defaultHeight)
}

func (p glTexture) CurrentImage() Paintable {
	return WrapPaintable(gextras.InternObject(p)).CurrentImage()
}

func (p glTexture) Flags() PaintableFlags {
	return WrapPaintable(gextras.InternObject(p)).Flags()
}

func (p glTexture) IntrinsicAspectRatio() float64 {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicAspectRatio()
}

func (p glTexture) IntrinsicHeight() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicHeight()
}

func (p glTexture) IntrinsicWidth() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicWidth()
}

func (p glTexture) InvalidateContents() {
	WrapPaintable(gextras.InternObject(p)).InvalidateContents()
}

func (p glTexture) InvalidateSize() {
	WrapPaintable(gextras.InternObject(p)).InvalidateSize()
}

func (p glTexture) Snapshot(snapshot Snapshot, width float64, height float64) {
	WrapPaintable(gextras.InternObject(p)).Snapshot(snapshot, width, height)
}

// GrabBrokenEvent: an event related to a broken windowing system grab.
type GrabBrokenEvent interface {
	Event

	// GrabSurface extracts the grab surface from a grab broken event.
	GrabSurface() Surface
	// Implicit checks whether the grab broken event is for an implicit grab.
	Implicit() bool
}

// grabBrokenEvent implements the GrabBrokenEvent class.
type grabBrokenEvent struct {
	Event
}

// WrapGrabBrokenEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapGrabBrokenEvent(obj *externglib.Object) GrabBrokenEvent {
	return grabBrokenEvent{
		Event: WrapEvent(obj),
	}
}

func marshalGrabBrokenEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGrabBrokenEvent(obj), nil
}

func (e grabBrokenEvent) GrabSurface() Surface {
	var _arg0 *C.GdkEvent   // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_grab_broken_event_get_grab_surface(_arg0)

	var _surface Surface // out

	_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Surface)

	return _surface
}

func (e grabBrokenEvent) Implicit() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_grab_broken_event_get_implicit(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyEvent: an event related to a key-based device.
type KeyEvent interface {
	Event

	// ConsumedModifiers extracts the consumed modifiers from a key event.
	ConsumedModifiers() ModifierType
	// Keycode extracts the keycode from a key event.
	Keycode() uint
	// Keyval extracts the keyval from a key event.
	Keyval() uint
	// Layout extracts the layout from a key event.
	Layout() uint
	// Level extracts the shift level from a key event.
	Level() uint
	// Match gets a keyval and modifier combination that will match the event.
	//
	// See [method@Gdk.KeyEvent.matches].
	Match() (uint, ModifierType, bool)
	// IsModifierKeyEvent extracts whether the key event is for a modifier key.
	IsModifierKeyEvent() bool
	// MatchesKeyEvent matches a key event against a keyval and modifiers.
	//
	// This is typically used to trigger keyboard shortcuts such as Ctrl-C.
	//
	// Partial matches are possible where the combination matches if the
	// currently active group is ignored.
	//
	// Note that we ignore Caps Lock for matching.
	MatchesKeyEvent(keyval uint, modifiers ModifierType) KeyMatch
}

// keyEvent implements the KeyEvent class.
type keyEvent struct {
	Event
}

// WrapKeyEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapKeyEvent(obj *externglib.Object) KeyEvent {
	return keyEvent{
		Event: WrapEvent(obj),
	}
}

func marshalKeyEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapKeyEvent(obj), nil
}

func (e keyEvent) ConsumedModifiers() ModifierType {
	var _arg0 *C.GdkEvent       // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_consumed_modifiers(_arg0)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

func (e keyEvent) Keycode() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_keycode(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e keyEvent) Keyval() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_keyval(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e keyEvent) Layout() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_layout(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e keyEvent) Level() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_level(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e keyEvent) Match() (uint, ModifierType, bool) {
	var _arg0 *C.GdkEvent       // out
	var _arg1 C.guint           // in
	var _arg2 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_get_match(_arg0, &_arg1, &_arg2)

	var _keyval uint            // out
	var _modifiers ModifierType // out
	var _ok bool                // out

	_keyval = uint(_arg1)
	_modifiers = ModifierType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _keyval, _modifiers, _ok
}

func (e keyEvent) IsModifierKeyEvent() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_key_event_is_modifier(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (e keyEvent) MatchesKeyEvent(keyval uint, modifiers ModifierType) KeyMatch {
	var _arg0 *C.GdkEvent       // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.GdkKeyMatch     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifiers)

	_cret = C.gdk_key_event_matches(_arg0, _arg1, _arg2)

	var _keyMatch KeyMatch // out

	_keyMatch = KeyMatch(_cret)

	return _keyMatch
}

// MemoryTexture: a `GdkTexture` representing image data in memory.
type MemoryTexture interface {
	Texture
}

// memoryTexture implements the MemoryTexture class.
type memoryTexture struct {
	Texture
}

// WrapMemoryTexture wraps a GObject to the right type. It is
// primarily used internally.
func WrapMemoryTexture(obj *externglib.Object) MemoryTexture {
	return memoryTexture{
		Texture: WrapTexture(obj),
	}
}

func marshalMemoryTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMemoryTexture(obj), nil
}

func (p memoryTexture) ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (concreteWidth float64, concreteHeight float64) {
	return WrapPaintable(gextras.InternObject(p)).ComputeConcreteSize(specifiedWidth, specifiedHeight, defaultWidth, defaultHeight)
}

func (p memoryTexture) CurrentImage() Paintable {
	return WrapPaintable(gextras.InternObject(p)).CurrentImage()
}

func (p memoryTexture) Flags() PaintableFlags {
	return WrapPaintable(gextras.InternObject(p)).Flags()
}

func (p memoryTexture) IntrinsicAspectRatio() float64 {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicAspectRatio()
}

func (p memoryTexture) IntrinsicHeight() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicHeight()
}

func (p memoryTexture) IntrinsicWidth() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicWidth()
}

func (p memoryTexture) InvalidateContents() {
	WrapPaintable(gextras.InternObject(p)).InvalidateContents()
}

func (p memoryTexture) InvalidateSize() {
	WrapPaintable(gextras.InternObject(p)).InvalidateSize()
}

func (p memoryTexture) Snapshot(snapshot Snapshot, width float64, height float64) {
	WrapPaintable(gextras.InternObject(p)).Snapshot(snapshot, width, height)
}

// Monitor: `GdkMonitor` objects represent the individual outputs that are
// associated with a `GdkDisplay`.
//
// `GdkDisplay` keeps a `GListModel` to enumerate and monitor monitors with
// [method@Gdk.Display.get_monitors]. You can use
// [method@Gdk.Display.get_monitor_at_surface] to find a particular monitor.
type Monitor interface {
	gextras.Objector

	// Connector gets the name of the monitor's connector, if available.
	Connector() string
	// Display gets the display that this monitor belongs to.
	Display() Display
	// Geometry retrieves the size and position of the monitor within the
	// display coordinate space.
	//
	// The returned geometry is in ”application pixels”, not in ”device pixels”
	// (see [method@Gdk.Monitor.get_scale_factor]).
	Geometry() Rectangle
	// HeightMm gets the height in millimeters of the monitor.
	HeightMm() int
	// Manufacturer gets the name or PNP ID of the monitor's manufacturer.
	//
	// Note that this value might also vary depending on actual display backend.
	//
	// The PNP ID registry is located at https://uefi.org/pnp_id_list
	// (https://uefi.org/pnp_id_list).
	Manufacturer() string
	// Model gets the string identifying the monitor model, if available.
	Model() string
	// RefreshRate gets the refresh rate of the monitor, if available.
	//
	// The value is in milli-Hertz, so a refresh rate of 60Hz is returned as
	// 60000.
	RefreshRate() int
	// ScaleFactor gets the internal scale factor that maps from monitor
	// coordinates to device pixels.
	//
	// On traditional systems this is 1, but on very high density outputs it can
	// be a higher value (often 2).
	//
	// This can be used if you want to create pixel based data for a particular
	// monitor, but most of the time you’re drawing to a surface where it is
	// better to use [method@Gdk.Surface.get_scale_factor] instead.
	ScaleFactor() int
	// SubpixelLayout gets information about the layout of red, green and blue
	// primaries for pixels.
	SubpixelLayout() SubpixelLayout
	// WidthMm gets the width in millimeters of the monitor.
	WidthMm() int
	// IsValidMonitor returns true if the @monitor object corresponds to a
	// physical monitor.
	//
	// The @monitor becomes invalid when the physical monitor is unplugged or
	// removed.
	IsValidMonitor() bool
}

// monitor implements the Monitor class.
type monitor struct {
	gextras.Objector
}

// WrapMonitor wraps a GObject to the right type. It is
// primarily used internally.
func WrapMonitor(obj *externglib.Object) Monitor {
	return monitor{
		Objector: obj,
	}
}

func marshalMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMonitor(obj), nil
}

func (m monitor) Connector() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_connector(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m monitor) Display() Display {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (m monitor) Geometry() Rectangle {
	var _arg0 *C.GdkMonitor  // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	C.gdk_monitor_get_geometry(_arg0, &_arg1)

	var _geometry Rectangle // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *Rectangle

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_geometry = *refTmpOut
	}

	return _geometry
}

func (m monitor) HeightMm() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_height_mm(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (m monitor) Manufacturer() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_manufacturer(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m monitor) Model() string {
	var _arg0 *C.GdkMonitor // out
	var _cret *C.char       // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_model(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (m monitor) RefreshRate() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_refresh_rate(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (m monitor) ScaleFactor() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_scale_factor(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (m monitor) SubpixelLayout() SubpixelLayout {
	var _arg0 *C.GdkMonitor       // out
	var _cret C.GdkSubpixelLayout // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_subpixel_layout(_arg0)

	var _subpixelLayout SubpixelLayout // out

	_subpixelLayout = SubpixelLayout(_cret)

	return _subpixelLayout
}

func (m monitor) WidthMm() int {
	var _arg0 *C.GdkMonitor // out
	var _cret C.int         // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_get_width_mm(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (m monitor) IsValidMonitor() bool {
	var _arg0 *C.GdkMonitor // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkMonitor)(unsafe.Pointer(m.Native()))

	_cret = C.gdk_monitor_is_valid(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MotionEvent: an event related to a pointer or touch device motion.
type MotionEvent interface {
	Event
}

// motionEvent implements the MotionEvent class.
type motionEvent struct {
	Event
}

// WrapMotionEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapMotionEvent(obj *externglib.Object) MotionEvent {
	return motionEvent{
		Event: WrapEvent(obj),
	}
}

func marshalMotionEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapMotionEvent(obj), nil
}

// PadEvent: an event related to a pad-based device.
type PadEvent interface {
	Event

	// AxisValue extracts the information from a pad strip or ring event.
	AxisValue() (uint, float64)
	// Button extracts information about the pressed button from a pad event.
	Button() uint
	// GroupMode extracts group and mode information from a pad event.
	GroupMode() (group uint, mode uint)
}

// padEvent implements the PadEvent class.
type padEvent struct {
	Event
}

// WrapPadEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapPadEvent(obj *externglib.Object) PadEvent {
	return padEvent{
		Event: WrapEvent(obj),
	}
}

func marshalPadEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapPadEvent(obj), nil
}

func (e padEvent) AxisValue() (uint, float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.guint     // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	C.gdk_pad_event_get_axis_value(_arg0, &_arg1, &_arg2)

	var _index uint    // out
	var _value float64 // out

	_index = uint(_arg1)
	_value = float64(_arg2)

	return _index, _value
}

func (e padEvent) Button() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_pad_event_get_button(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e padEvent) GroupMode() (group uint, mode uint) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.guint     // in
	var _arg2 C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	C.gdk_pad_event_get_group_mode(_arg0, &_arg1, &_arg2)

	var _group uint // out
	var _mode uint  // out

	_group = uint(_arg1)
	_mode = uint(_arg2)

	return _group, _mode
}

// ProximityEvent: an event related to the proximity of a tool to a device.
type ProximityEvent interface {
	Event
}

// proximityEvent implements the ProximityEvent class.
type proximityEvent struct {
	Event
}

// WrapProximityEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapProximityEvent(obj *externglib.Object) ProximityEvent {
	return proximityEvent{
		Event: WrapEvent(obj),
	}
}

func marshalProximityEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapProximityEvent(obj), nil
}

// ScrollEvent: an event related to a scrolling motion.
type ScrollEvent interface {
	Event

	// Deltas extracts the scroll deltas of a scroll event.
	//
	// The deltas will be zero unless the scroll direction is GDK_SCROLL_SMOOTH.
	Deltas() (deltaX float64, deltaY float64)
	// Direction extracts the direction of a scroll event.
	Direction() ScrollDirection
	// IsStopScrollEvent: check whether a scroll event is a stop scroll event.
	//
	// Scroll sequences with smooth scroll information may provide a stop scroll
	// event once the interaction with the device finishes, e.g. by lifting a
	// finger. This stop scroll event is the signal that a widget may trigger
	// kinetic scrolling based on the current velocity.
	//
	// Stop scroll events always have a delta of 0/0.
	IsStopScrollEvent() bool
}

// scrollEvent implements the ScrollEvent class.
type scrollEvent struct {
	Event
}

// WrapScrollEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapScrollEvent(obj *externglib.Object) ScrollEvent {
	return scrollEvent{
		Event: WrapEvent(obj),
	}
}

func marshalScrollEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScrollEvent(obj), nil
}

func (e scrollEvent) Deltas() (deltaX float64, deltaY float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.double    // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	C.gdk_scroll_event_get_deltas(_arg0, &_arg1, &_arg2)

	var _deltaX float64 // out
	var _deltaY float64 // out

	_deltaX = float64(_arg1)
	_deltaY = float64(_arg2)

	return _deltaX, _deltaY
}

func (e scrollEvent) Direction() ScrollDirection {
	var _arg0 *C.GdkEvent          // out
	var _cret C.GdkScrollDirection // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_scroll_event_get_direction(_arg0)

	var _scrollDirection ScrollDirection // out

	_scrollDirection = ScrollDirection(_cret)

	return _scrollDirection
}

func (e scrollEvent) IsStopScrollEvent() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_scroll_event_is_stop(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Seat: the `GdkSeat` object represents a collection of input devices that
// belong to a user.
type Seat interface {
	gextras.Objector

	// Capabilities returns the capabilities this `GdkSeat` currently has.
	Capabilities() SeatCapabilities
	// Display returns the `GdkDisplay` this seat belongs to.
	Display() Display
	// Keyboard returns the device that routes keyboard events.
	Keyboard() Device
	// Pointer returns the device that routes pointer events.
	Pointer() Device
}

// seat implements the Seat class.
type seat struct {
	gextras.Objector
}

// WrapSeat wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeat(obj *externglib.Object) Seat {
	return seat{
		Objector: obj,
	}
}

func marshalSeat(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeat(obj), nil
}

func (s seat) Capabilities() SeatCapabilities {
	var _arg0 *C.GdkSeat            // out
	var _cret C.GdkSeatCapabilities // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_seat_get_capabilities(_arg0)

	var _seatCapabilities SeatCapabilities // out

	_seatCapabilities = SeatCapabilities(_cret)

	return _seatCapabilities
}

func (s seat) Display() Display {
	var _arg0 *C.GdkSeat    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_seat_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (s seat) Keyboard() Device {
	var _arg0 *C.GdkSeat   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_seat_get_keyboard(_arg0)

	var _device Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Device)

	return _device
}

func (s seat) Pointer() Device {
	var _arg0 *C.GdkSeat   // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_seat_get_pointer(_arg0)

	var _device Device // out

	_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Device)

	return _device
}

// Snapshot: base type for snapshot operations.
//
// The subclass of `GdkSnapshot` used by GTK is [class@Gtk.Snapshot].
type Snapshot interface {
	gextras.Objector
}

// snapshot implements the Snapshot class.
type snapshot struct {
	gextras.Objector
}

// WrapSnapshot wraps a GObject to the right type. It is
// primarily used internally.
func WrapSnapshot(obj *externglib.Object) Snapshot {
	return snapshot{
		Objector: obj,
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSnapshot(obj), nil
}

// Surface: a `GdkSurface` is a rectangular region on the screen.
//
// It’s a low-level object, used to implement high-level objects such as
// [class@Gtk.Window] or [class@Gtk.Dialog] in GTK.
//
// The surfaces you see in practice are either [class@Gdk.Toplevel] or
// [class@Gdk.Popup], and those interfaces provide much of the required API to
// interact with these surfaces. Other, more specialized surface types exist,
// but you will rarely interact with them directly.
type Surface interface {
	gextras.Objector

	// BeepSurface emits a short beep associated to @surface.
	//
	// If the display of @surface does not support per-surface beeps, emits a
	// short beep on the display just as [method@Gdk.Display.beep].
	BeepSurface()
	// CreateCairoContextSurface creates a new `GdkCairoContext` for rendering
	// on @surface.
	CreateCairoContextSurface() CairoContext
	// CreateGLContextSurface creates a new `GdkGLContext` for the `GdkSurface`.
	//
	// The context is disconnected from any particular surface or surface. If
	// the creation of the `GdkGLContext` failed, @error will be set. Before
	// using the returned `GdkGLContext`, you will need to call
	// [method@Gdk.GLContext.make_current] or [method@Gdk.GLContext.realize].
	CreateGLContextSurface() (GLContext, error)
	// CreateSimilarSurfaceSurface: create a new Cairo surface that is as
	// compatible as possible with the given @surface.
	//
	// For example the new surface will have the same fallback resolution and
	// font options as @surface. Generally, the new surface will also use the
	// same backend as @surface, unless that is not possible for some reason.
	// The type of the returned surface may be examined with
	// cairo_surface_get_type().
	//
	// Initially the surface contents are all 0 (transparent if contents have
	// transparency, black otherwise.)
	//
	// This function always returns a valid pointer, but it will return a
	// pointer to a “nil” surface if @other is already in an error state or any
	// other error occurs.
	CreateSimilarSurfaceSurface(content cairo.Content, width int, height int) *cairo.Surface
	// CreateVulkanContextSurface creates a new `GdkVulkanContext` for rendering
	// on @surface.
	//
	// If the creation of the `GdkVulkanContext` failed, @error will be set.
	CreateVulkanContextSurface() (VulkanContext, error)
	// DestroySurface destroys the window system resources associated with
	// @surface and decrements @surface's reference count.
	//
	// The window system resources for all children of @surface are also
	// destroyed, but the children’s reference counts are not decremented.
	//
	// Note that a surface will not be destroyed automatically when its
	// reference count reaches zero. You must call this function yourself before
	// that happens.
	DestroySurface()
	// Cursor retrieves a `GdkCursor` pointer for the cursor currently set on
	// the `GdkSurface`.
	//
	// If the return value is nil then there is no custom cursor set on the
	// surface, and it is using the cursor for its parent surface.
	Cursor() Cursor
	// DeviceCursor retrieves a `GdkCursor` pointer for the @device currently
	// set on the specified `GdkSurface`.
	//
	// If the return value is nil then there is no custom cursor set on the
	// specified surface, and it is using the cursor for its parent surface.
	DeviceCursor(device Device) Cursor
	// DevicePosition obtains the current device position and modifier state.
	//
	// The position is given in coordinates relative to the upper left corner of
	// @surface.
	DevicePosition(device Device) (x float64, y float64, mask ModifierType, ok bool)
	// Display gets the `GdkDisplay` associated with a `GdkSurface`.
	Display() Display
	// FrameClock gets the frame clock for the surface.
	//
	// The frame clock for a surface never changes unless the surface is
	// reparented to a new toplevel surface.
	FrameClock() FrameClock
	// Height returns the height of the given @surface.
	//
	// Surface size is reported in ”application pixels”, not ”device pixels”
	// (see [method@Gdk.Surface.get_scale_factor]).
	Height() int
	// Mapped checks whether the surface has been mapped.
	//
	// A surface is mapped with [method@Gdk.Toplevel.present] or
	// [method@Gdk.Popup.present].
	Mapped() bool
	// ScaleFactor returns the internal scale factor that maps from surface
	// coordinates to the actual device pixels.
	//
	// On traditional systems this is 1, but on very high density outputs this
	// can be a higher value (often 2). A higher value means that drawing is
	// automatically scaled up to a higher resolution, so any code doing drawing
	// will automatically look nicer. However, if you are supplying pixel-based
	// data the scale value can be used to determine whether to use a pixel
	// resource with higher resolution data.
	//
	// The scale of a surface may change during runtime.
	ScaleFactor() int
	// Width returns the width of the given @surface.
	//
	// Surface size is reported in ”application pixels”, not ”device pixels”
	// (see [method@Gdk.Surface.get_scale_factor]).
	Width() int
	// HideSurface: hide the surface.
	//
	// For toplevel surfaces, withdraws them, so they will no longer be known to
	// the window manager; for all surfaces, unmaps them, so they won’t be
	// displayed. Normally done automatically as part of
	// [method@Gtk.Widget.hide].
	HideSurface()
	// IsDestroyedSurface: check to see if a surface is destroyed.
	IsDestroyedSurface() bool
	// QueueRenderSurface forces a [signal@Gdk.Surface::render] signal emission
	// for @surface to be scheduled.
	//
	// This function is useful for implementations that track invalid regions on
	// their own.
	QueueRenderSurface()
	// RequestLayoutSurface: request a layout phase from the surface's frame
	// clock.
	//
	// See [method@Gdk.FrameClock.request_phase].
	RequestLayoutSurface()
	// SetCursorSurface sets the default mouse pointer for a `GdkSurface`.
	//
	// Passing nil for the @cursor argument means that @surface will use the
	// cursor of its parent surface. Most surfaces should use this default. Note
	// that @cursor must be for the same display as @surface.
	//
	// Use [ctor@Gdk.Cursor.new_from_name] or [ctor@Gdk.Cursor.new_from_texture]
	// to create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
	SetCursorSurface(cursor Cursor)
	// SetDeviceCursorSurface sets a specific `GdkCursor` for a given device
	// when it gets inside @surface.
	//
	// Passing nil for the @cursor argument means that @surface will use the
	// cursor of its parent surface. Most surfaces should use this default.
	//
	// Use [ctor@Gdk.Cursor.new_from_name] or [ctor@Gdk.Cursor.new_from_texture]
	// to create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
	SetDeviceCursorSurface(device Device, cursor Cursor)
	// SetInputRegionSurface: apply the region to the surface for the purpose of
	// event handling.
	//
	// Mouse events which happen while the pointer position corresponds to an
	// unset bit in the mask will be passed on the surface below @surface.
	//
	// An input region is typically used with RGBA surfaces. The alpha channel
	// of the surface defines which pixels are invisible and allows for nicely
	// antialiased borders, and the input region controls where the surface is
	// “clickable”.
	//
	// Use [method@Gdk.Display.supports_input_shapes] to find out if a
	// particular backend supports input regions.
	SetInputRegionSurface(region *cairo.Region)
	// SetOpaqueRegionSurface marks a region of the `GdkSurface` as opaque.
	//
	// For optimisation purposes, compositing window managers may like to not
	// draw obscured regions of surfaces, or turn off blending during for these
	// regions. With RGB windows with no transparency, this is just the shape of
	// the window, but with ARGB32 windows, the compositor does not know what
	// regions of the window are transparent or not.
	//
	// This function only works for toplevel surfaces.
	//
	// GTK will update this property automatically if the @surface background is
	// opaque, as we know where the opaque regions are. If your surface
	// background is not opaque, please update this property in your
	// WidgetClass.css_changed() handler.
	SetOpaqueRegionSurface(region *cairo.Region)
}

// surface implements the Surface class.
type surface struct {
	gextras.Objector
}

// WrapSurface wraps a GObject to the right type. It is
// primarily used internally.
func WrapSurface(obj *externglib.Object) Surface {
	return surface{
		Objector: obj,
	}
}

func marshalSurface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSurface(obj), nil
}

// NewSurfacePopup: create a new popup surface.
//
// The surface will be attached to @parent and can be positioned relative to it
// using [method@Gdk.Popup.present].
func NewSurfacePopup(parent Surface, autohide bool) Surface {
	var _arg1 *C.GdkSurface // out
	var _arg2 C.gboolean    // out
	var _cret *C.GdkSurface // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(parent.Native()))
	if autohide {
		_arg2 = C.TRUE
	}

	_cret = C.gdk_surface_new_popup(_arg1, _arg2)

	var _surface Surface // out

	_surface = WrapSurface(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _surface
}

// NewSurfaceToplevel creates a new toplevel surface.
func NewSurfaceToplevel(display Display) Surface {
	var _arg1 *C.GdkDisplay // out
	var _cret *C.GdkSurface // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	_cret = C.gdk_surface_new_toplevel(_arg1)

	var _surface Surface // out

	_surface = WrapSurface(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _surface
}

func (s surface) BeepSurface() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	C.gdk_surface_beep(_arg0)
}

func (s surface) CreateCairoContextSurface() CairoContext {
	var _arg0 *C.GdkSurface      // out
	var _cret *C.GdkCairoContext // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_create_cairo_context(_arg0)

	var _cairoContext CairoContext // out

	_cairoContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CairoContext)

	return _cairoContext
}

func (s surface) CreateGLContextSurface() (GLContext, error) {
	var _arg0 *C.GdkSurface   // out
	var _cret *C.GdkGLContext // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_create_gl_context(_arg0, &_cerr)

	var _glContext GLContext // out
	var _goerr error         // out

	_glContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(GLContext)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _glContext, _goerr
}

func (s surface) CreateSimilarSurfaceSurface(content cairo.Content, width int, height int) *cairo.Surface {
	var _arg0 *C.GdkSurface      // out
	var _arg1 C.cairo_content_t  // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = C.cairo_content_t(content)
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	_cret = C.gdk_surface_create_similar_surface(_arg0, _arg1, _arg2, _arg3)

	var _ret *cairo.Surface // out

	_ret = (*cairo.Surface)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_ret, func(v **cairo.Surface) {
		C.free(unsafe.Pointer(v))
	})

	return _ret
}

func (s surface) CreateVulkanContextSurface() (VulkanContext, error) {
	var _arg0 *C.GdkSurface       // out
	var _cret *C.GdkVulkanContext // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_create_vulkan_context(_arg0, &_cerr)

	var _vulkanContext VulkanContext // out
	var _goerr error                 // out

	_vulkanContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(VulkanContext)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _vulkanContext, _goerr
}

func (s surface) DestroySurface() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	C.gdk_surface_destroy(_arg0)
}

func (s surface) Cursor() Cursor {
	var _arg0 *C.GdkSurface // out
	var _cret *C.GdkCursor  // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_cursor(_arg0)

	var _cursor Cursor // out

	_cursor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cursor)

	return _cursor
}

func (s surface) DeviceCursor(device Device) Cursor {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkDevice  // out
	var _cret *C.GdkCursor  // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gdk_surface_get_device_cursor(_arg0, _arg1)

	var _cursor Cursor // out

	_cursor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cursor)

	return _cursor
}

func (s surface) DevicePosition(device Device) (x float64, y float64, mask ModifierType, ok bool) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.GdkDevice      // out
	var _arg2 C.double          // in
	var _arg3 C.double          // in
	var _arg4 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	_cret = C.gdk_surface_get_device_position(_arg0, _arg1, &_arg2, &_arg3, &_arg4)

	var _x float64         // out
	var _y float64         // out
	var _mask ModifierType // out
	var _ok bool           // out

	_x = float64(_arg2)
	_y = float64(_arg3)
	_mask = ModifierType(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _mask, _ok
}

func (s surface) Display() Display {
	var _arg0 *C.GdkSurface // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_display(_arg0)

	var _display Display // out

	_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Display)

	return _display
}

func (s surface) FrameClock() FrameClock {
	var _arg0 *C.GdkSurface    // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_frame_clock(_arg0)

	var _frameClock FrameClock // out

	_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FrameClock)

	return _frameClock
}

func (s surface) Height() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s surface) Mapped() bool {
	var _arg0 *C.GdkSurface // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_mapped(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s surface) ScaleFactor() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_scale_factor(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s surface) Width() int {
	var _arg0 *C.GdkSurface // out
	var _cret C.int         // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_get_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (s surface) HideSurface() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	C.gdk_surface_hide(_arg0)
}

func (s surface) IsDestroyedSurface() bool {
	var _arg0 *C.GdkSurface // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	_cret = C.gdk_surface_is_destroyed(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (s surface) QueueRenderSurface() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	C.gdk_surface_queue_render(_arg0)
}

func (s surface) RequestLayoutSurface() {
	var _arg0 *C.GdkSurface // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))

	C.gdk_surface_request_layout(_arg0)
}

func (s surface) SetCursorSurface(cursor Cursor) {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkCursor  // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gdk_surface_set_cursor(_arg0, _arg1)
}

func (s surface) SetDeviceCursorSurface(device Device, cursor Cursor) {
	var _arg0 *C.GdkSurface // out
	var _arg1 *C.GdkDevice  // out
	var _arg2 *C.GdkCursor  // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg2 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gdk_surface_set_device_cursor(_arg0, _arg1, _arg2)
}

func (s surface) SetInputRegionSurface(region *cairo.Region) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_surface_set_input_region(_arg0, _arg1)
}

func (s surface) SetOpaqueRegionSurface(region *cairo.Region) {
	var _arg0 *C.GdkSurface     // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GdkSurface)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_surface_set_opaque_region(_arg0, _arg1)
}

// Texture: `GdkTexture` is the basic element used to refer to pixel data.
//
// It is primarily meant for pixel data that will not change over multiple
// frames, and will be used for a long time.
//
// There are various ways to create `GdkTexture` objects from a `GdkPixbuf`, or
// a Cairo surface, or other pixel data.
//
// The ownership of the pixel data is transferred to the `GdkTexture` instance;
// you can only make a copy of it, via [method@Gdk.Texture.download].
//
// `GdkTexture` is an immutable object: That means you cannot change anything
// about it other than increasing the reference count via g_object_ref().
type Texture interface {
	Paintable

	// Height returns the height of the @texture, in pixels.
	Height() int
	// Width returns the width of @texture, in pixels.
	Width() int
	// SaveToPngTexture: store the given @texture to the @filename as a PNG
	// file.
	//
	// This is a utility function intended for debugging and testing. If you
	// want more control over formats, proper error handling or want to store to
	// a `GFile` or other location, you might want to look into using the
	// gdk-pixbuf library.
	SaveToPngTexture(filename string) bool
}

// texture implements the Texture class.
type texture struct {
	gextras.Objector
}

// WrapTexture wraps a GObject to the right type. It is
// primarily used internally.
func WrapTexture(obj *externglib.Object) Texture {
	return texture{
		Objector: obj,
	}
}

func marshalTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTexture(obj), nil
}

// NewTextureForPixbuf creates a new texture object representing the
// `GdkPixbuf`.
func NewTextureForPixbuf(pixbuf gdkpixbuf.Pixbuf) Texture {
	var _arg1 *C.GdkPixbuf  // out
	var _cret *C.GdkTexture // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_texture_new_for_pixbuf(_arg1)

	var _texture Texture // out

	_texture = WrapTexture(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _texture
}

// NewTextureFromFile creates a new texture by loading an image from a file.
//
// The file format is detected automatically. The supported formats are PNG and
// JPEG, though more formats might be available.
//
// If nil is returned, then @error will be set.
func NewTextureFromFile(file gio.File) (Texture, error) {
	var _arg1 *C.GFile      // out
	var _cret *C.GdkTexture // in
	var _cerr *C.GError     // in

	_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

	_cret = C.gdk_texture_new_from_file(_arg1, &_cerr)

	var _texture Texture // out
	var _goerr error     // out

	_texture = WrapTexture(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _texture, _goerr
}

// NewTextureFromResource creates a new texture by loading an image from a
// resource.
//
// The file format is detected automatically. The supported formats are PNG and
// JPEG, though more formats might be available.
//
// It is a fatal error if @resource_path does not specify a valid image resource
// and the program will abort if that happens. If you are unsure about the
// validity of a resource, use [ctor@Gdk.Texture.new_from_file] to load it.
func NewTextureFromResource(resourcePath string) Texture {
	var _arg1 *C.char       // out
	var _cret *C.GdkTexture // in

	_arg1 = (*C.char)(C.CString(resourcePath))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_new_from_resource(_arg1)

	var _texture Texture // out

	_texture = WrapTexture(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _texture
}

func (t texture) Height() int {
	var _arg0 *C.GdkTexture // out
	var _cret C.int         // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_texture_get_height(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t texture) Width() int {
	var _arg0 *C.GdkTexture // out
	var _cret C.int         // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_texture_get_width(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (t texture) SaveToPngTexture(filename string) bool {
	var _arg0 *C.GdkTexture // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkTexture)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(filename))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_texture_save_to_png(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (p texture) ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (concreteWidth float64, concreteHeight float64) {
	return WrapPaintable(gextras.InternObject(p)).ComputeConcreteSize(specifiedWidth, specifiedHeight, defaultWidth, defaultHeight)
}

func (p texture) CurrentImage() Paintable {
	return WrapPaintable(gextras.InternObject(p)).CurrentImage()
}

func (p texture) Flags() PaintableFlags {
	return WrapPaintable(gextras.InternObject(p)).Flags()
}

func (p texture) IntrinsicAspectRatio() float64 {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicAspectRatio()
}

func (p texture) IntrinsicHeight() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicHeight()
}

func (p texture) IntrinsicWidth() int {
	return WrapPaintable(gextras.InternObject(p)).IntrinsicWidth()
}

func (p texture) InvalidateContents() {
	WrapPaintable(gextras.InternObject(p)).InvalidateContents()
}

func (p texture) InvalidateSize() {
	WrapPaintable(gextras.InternObject(p)).InvalidateSize()
}

func (p texture) Snapshot(snapshot Snapshot, width float64, height float64) {
	WrapPaintable(gextras.InternObject(p)).Snapshot(snapshot, width, height)
}

// TouchEvent: an event related to a touch-based device.
type TouchEvent interface {
	Event

	// EmulatingPointer extracts whether a touch event is emulating a pointer
	// event.
	EmulatingPointer() bool
}

// touchEvent implements the TouchEvent class.
type touchEvent struct {
	Event
}

// WrapTouchEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapTouchEvent(obj *externglib.Object) TouchEvent {
	return touchEvent{
		Event: WrapEvent(obj),
	}
}

func marshalTouchEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTouchEvent(obj), nil
}

func (e touchEvent) EmulatingPointer() bool {
	var _arg0 *C.GdkEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_touch_event_get_emulating_pointer(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TouchpadEvent: an event related to a gesture on a touchpad device.
//
// Unlike touchscreens, where the windowing system sends basic sequences of
// begin, update, end events, and leaves gesture recognition to the clients,
// touchpad gestures are typically processed by the system, resulting in these
// events.
type TouchpadEvent interface {
	Event

	// Deltas extracts delta information from a touchpad event.
	Deltas() (dx float64, dy float64)
	// GesturePhase extracts the touchpad gesture phase from a touchpad event.
	GesturePhase() TouchpadGesturePhase
	// NFingers extracts the number of fingers from a touchpad event.
	NFingers() uint
	// PinchAngleDelta extracts the angle delta from a touchpad pinch event.
	PinchAngleDelta() float64
	// PinchScale extracts the scale from a touchpad pinch event.
	PinchScale() float64
}

// touchpadEvent implements the TouchpadEvent class.
type touchpadEvent struct {
	Event
}

// WrapTouchpadEvent wraps a GObject to the right type. It is
// primarily used internally.
func WrapTouchpadEvent(obj *externglib.Object) TouchpadEvent {
	return touchpadEvent{
		Event: WrapEvent(obj),
	}
}

func marshalTouchpadEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTouchpadEvent(obj), nil
}

func (e touchpadEvent) Deltas() (dx float64, dy float64) {
	var _arg0 *C.GdkEvent // out
	var _arg1 C.double    // in
	var _arg2 C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	C.gdk_touchpad_event_get_deltas(_arg0, &_arg1, &_arg2)

	var _dx float64 // out
	var _dy float64 // out

	_dx = float64(_arg1)
	_dy = float64(_arg2)

	return _dx, _dy
}

func (e touchpadEvent) GesturePhase() TouchpadGesturePhase {
	var _arg0 *C.GdkEvent               // out
	var _cret C.GdkTouchpadGesturePhase // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_touchpad_event_get_gesture_phase(_arg0)

	var _touchpadGesturePhase TouchpadGesturePhase // out

	_touchpadGesturePhase = TouchpadGesturePhase(_cret)

	return _touchpadGesturePhase
}

func (e touchpadEvent) NFingers() uint {
	var _arg0 *C.GdkEvent // out
	var _cret C.guint     // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_touchpad_event_get_n_fingers(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (e touchpadEvent) PinchAngleDelta() float64 {
	var _arg0 *C.GdkEvent // out
	var _cret C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_touchpad_event_get_pinch_angle_delta(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

func (e touchpadEvent) PinchScale() float64 {
	var _arg0 *C.GdkEvent // out
	var _cret C.double    // in

	_arg0 = (*C.GdkEvent)(unsafe.Pointer(e.Native()))

	_cret = C.gdk_touchpad_event_get_pinch_scale(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// VulkanContext: `GdkVulkanContext` is an object representing the
// platform-specific Vulkan draw context.
//
// `GdkVulkanContext`s are created for a surface using
// [method@Gdk.Surface.create_vulkan_context], and the context will match the
// the characteristics of the surface.
//
// Support for `GdkVulkanContext` is platform-specific and context creation can
// fail, returning nil context.
type VulkanContext interface {
	DrawContext
	gio.Initable
}

// vulkanContext implements the VulkanContext class.
type vulkanContext struct {
	DrawContext
}

// WrapVulkanContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapVulkanContext(obj *externglib.Object) VulkanContext {
	return vulkanContext{
		DrawContext: WrapDrawContext(obj),
	}
}

func marshalVulkanContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVulkanContext(obj), nil
}

// ContentFormats: the `GdkContentFormats` structure is used to advertise and
// negotiate the format of content.
//
// You will encounter `GdkContentFormats` when interacting with objects
// controlling operations that pass data between different widgets, window or
// application, like [class@Gdk.Drag], [class@Gdk.Drop], [class@Gdk.Clipboard]
// or [class@Gdk.ContentProvider].
//
// GDK supports content in 2 forms: `GType` and mime type. Using `GTypes` is
// meant only for in-process content transfers. Mime types are meant to be used
// for data passing both in-process and out-of-process. The details of how data
// is passed is described in the documentation of the actual implementations. To
// transform between the two forms, [class@Gdk.ContentSerializer] and
// [class@Gdk.ContentDeserializer] are used.
//
// A `GdkContentFormats` describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. `GTypes` are more
// important than mime types. Order between different `GTypes` or mime types is
// the order they were added in, most important first. Functions that care about
// order, such as [method@Gdk.ContentFormats.union], will describe in their
// documentation how they interpret that order, though in general the order of
// the first argument is considered the primary order of the result, followed by
// the order of further arguments.
//
// For debugging purposes, the function [method@Gdk.ContentFormats.to_string]
// exists. It will print a comma-separated list of formats from most important
// to least important.
//
// `GdkContentFormats` is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new `GdkContentFormats` have to be created.
// The [struct@Gdk.ContentFormatsBuilder]` structure is meant to help in this
// endeavor.
type ContentFormats C.GdkContentFormats

// WrapContentFormats wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContentFormats(ptr unsafe.Pointer) *ContentFormats {
	return (*ContentFormats)(ptr)
}

func marshalContentFormats(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*ContentFormats)(unsafe.Pointer(b)), nil
}

// NewContentFormats constructs a struct ContentFormats.
func NewContentFormats(mimeTypes []string) *ContentFormats {
	var _arg1 **C.char
	var _arg2 C.guint
	var _cret *C.GdkContentFormats // in

	_arg2 = C.guint(len(mimeTypes))
	_arg1 = (**C.char)(C.malloc(C.ulong(len(mimeTypes)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice(_arg1, len(mimeTypes))
		for i := range mimeTypes {
			out[i] = (*C.char)(C.CString(mimeTypes[i]))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gdk_content_formats_new(_arg1, _arg2)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// NewContentFormatsForGType constructs a struct ContentFormats.
func NewContentFormatsForGType(typ externglib.Type) *ContentFormats {
	var _arg1 C.GType              // out
	var _cret *C.GdkContentFormats // in

	_arg1 = (C.GType)(typ)

	_cret = C.gdk_content_formats_new_for_gtype(_arg1)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// Native returns the underlying C source pointer.
func (c *ContentFormats) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// ContainGType checks if a given `GType` is part of the given @formats.
func (f *ContentFormats) ContainGType(typ externglib.Type) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 C.GType              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (C.GType)(typ)

	_cret = C.gdk_content_formats_contain_gtype(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainMIMEType checks if a given mime type is part of the given @formats.
func (f *ContentFormats) ContainMIMEType(mimeType string) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_content_formats_contain_mime_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Match checks if @first and @second have any matching formats.
func (f *ContentFormats) Match(second *ContentFormats) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	_cret = C.gdk_content_formats_match(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchGType finds the first `GType` from @first that is also contained in
// @second.
//
// If no matching `GType` is found, G_TYPE_INVALID is returned.
func (f *ContentFormats) MatchGType(second *ContentFormats) externglib.Type {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret C.GType              // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	_cret = C.gdk_content_formats_match_gtype(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// MatchMIMEType finds the first mime type from @first that is also contained in
// @second.
//
// If no matching mime type is found, nil is returned.
func (f *ContentFormats) MatchMIMEType(second *ContentFormats) string {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret *C.char              // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	_cret = C.gdk_content_formats_match_mime_type(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Ref increases the reference count of a `GdkContentFormats` by one.
func (f *ContentFormats) Ref() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_ref(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// String prints the given @formats into a human-readable string.
//
// This is a small wrapper around [method@Gdk.ContentFormats.print] to help when
// debugging.
func (f *ContentFormats) String() string {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.char              // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Union: append all missing types from @second to @first, in the order they had
// in @second.
func (f *ContentFormats) Union(second *ContentFormats) *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	_cret = C.gdk_content_formats_union(_arg0, _arg1)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// UnionDeserializeGTypes: add GTypes for mime types in @formats for which
// deserializers are registered.
func (f *ContentFormats) UnionDeserializeGTypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_union_deserialize_gtypes(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// UnionDeserializeMIMETypes: add mime types for GTypes in @formats for which
// deserializers are registered.
func (f *ContentFormats) UnionDeserializeMIMETypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_union_deserialize_mime_types(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// UnionSerializeGTypes: add GTypes for the mime types in @formats for which
// serializers are registered.
func (f *ContentFormats) UnionSerializeGTypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_union_serialize_gtypes(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// UnionSerializeMIMETypes: add mime types for GTypes in @formats for which
// serializers are registered.
func (f *ContentFormats) UnionSerializeMIMETypes() *ContentFormats {
	var _arg0 *C.GdkContentFormats // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	_cret = C.gdk_content_formats_union_serialize_mime_types(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// Unref decreases the reference count of a `GdkContentFormats` by one.
//
// If the resulting reference count is zero, frees the formats.
func (f *ContentFormats) Unref() {
	var _arg0 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	C.gdk_content_formats_unref(_arg0)
}

// ContentFormatsBuilder: a `GdkContentFormatsBuilder` is an auxiliary struct
// used to create new `GdkContentFormats`, and should not be kept around.
type ContentFormatsBuilder C.GdkContentFormatsBuilder

// WrapContentFormatsBuilder wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContentFormatsBuilder(ptr unsafe.Pointer) *ContentFormatsBuilder {
	return (*ContentFormatsBuilder)(ptr)
}

func marshalContentFormatsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*ContentFormatsBuilder)(unsafe.Pointer(b)), nil
}

// NewContentFormatsBuilder constructs a struct ContentFormatsBuilder.
func NewContentFormatsBuilder() *ContentFormatsBuilder {
	var _cret *C.GdkContentFormatsBuilder // in

	_cret = C.gdk_content_formats_builder_new()

	var _contentFormatsBuilder *ContentFormatsBuilder // out

	_contentFormatsBuilder = (*ContentFormatsBuilder)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormatsBuilder, func(v **ContentFormatsBuilder) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormatsBuilder
}

// Native returns the underlying C source pointer.
func (c *ContentFormatsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// AddFormats appends all formats from @formats to @builder, skipping those that
// already exist.
func (b *ContentFormatsBuilder) AddFormats(formats *ContentFormats) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 *C.GdkContentFormats        // out

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))

	C.gdk_content_formats_builder_add_formats(_arg0, _arg1)
}

// AddGType appends @type to @builder if it has not already been added.
func (b *ContentFormatsBuilder) AddGType(typ externglib.Type) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 C.GType                     // out

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (C.GType)(typ)

	C.gdk_content_formats_builder_add_gtype(_arg0, _arg1)
}

// AddMIMEType appends @mime_type to @builder if it has not already been added.
func (b *ContentFormatsBuilder) AddMIMEType(mimeType string) {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _arg1 *C.char                     // out

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_content_formats_builder_add_mime_type(_arg0, _arg1)
}

// Ref acquires a reference on the given @builder.
//
// This function is intended primarily for bindings. `GdkContentFormatsBuilder`
// objects should not be kept around.
func (b *ContentFormatsBuilder) Ref() *ContentFormatsBuilder {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _cret *C.GdkContentFormatsBuilder // in

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gdk_content_formats_builder_ref(_arg0)

	var _contentFormatsBuilder *ContentFormatsBuilder // out

	_contentFormatsBuilder = (*ContentFormatsBuilder)(unsafe.Pointer(_cret))

	return _contentFormatsBuilder
}

// ToFormats creates a new `GdkContentFormats` from the given @builder.
//
// The given `GdkContentFormatsBuilder` is reset once this function returns; you
// cannot call this function multiple times on the same @builder instance.
//
// This function is intended primarily for bindings. C code should use
// [method@Gdk.ContentFormatsBuilder.free_to_formats].
func (b *ContentFormatsBuilder) ToFormats() *ContentFormats {
	var _arg0 *C.GdkContentFormatsBuilder // out
	var _cret *C.GdkContentFormats        // in

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))

	_cret = C.gdk_content_formats_builder_to_formats(_arg0)

	var _contentFormats *ContentFormats // out

	_contentFormats = (*ContentFormats)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_contentFormats, func(v **ContentFormats) {
		C.free(unsafe.Pointer(v))
	})

	return _contentFormats
}

// Unref releases a reference on the given @builder.
func (b *ContentFormatsBuilder) Unref() {
	var _arg0 *C.GdkContentFormatsBuilder // out

	_arg0 = (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b.Native()))

	C.gdk_content_formats_builder_unref(_arg0)
}

// EventSequence: `GdkEventSequence` is an opaque type representing a sequence
// of related touch events.
type EventSequence C.GdkEventSequence

// WrapEventSequence wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEventSequence(ptr unsafe.Pointer) *EventSequence {
	return (*EventSequence)(ptr)
}

func marshalEventSequence(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*EventSequence)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EventSequence) Native() unsafe.Pointer {
	return unsafe.Pointer(e)
}

// FrameTimings: a `GdkFrameTimings` object holds timing information for a
// single frame of the application’s displays.
//
// To retrieve `GdkFrameTimings` objects, use
// [method@Gdk.FrameClock.get_timings] or
// [method@Gdk.FrameClock.get_current_timings]. The information in
// `GdkFrameTimings` is useful for precise synchronization of video with the
// event or audio streams, and for measuring quality metrics for the
// application’s display, such as latency and jitter.
type FrameTimings C.GdkFrameTimings

// WrapFrameTimings wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFrameTimings(ptr unsafe.Pointer) *FrameTimings {
	return (*FrameTimings)(ptr)
}

func marshalFrameTimings(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*FrameTimings)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FrameTimings) Native() unsafe.Pointer {
	return unsafe.Pointer(f)
}

// Complete returns whether @timings are complete.
//
// The timing information in a `GdkFrameTimings` is filled in incrementally as
// the frame as drawn and passed off to the window system for processing and
// display to the user. The accessor functions for `GdkFrameTimings` can return
// 0 to indicate an unavailable value for two reasons: either because the
// information is not yet available, or because it isn't available at all.
//
// Once this function returns true for a frame, you can be certain that no
// further values will become available and be stored in the `GdkFrameTimings`.
func (t *FrameTimings) Complete() bool {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_complete(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameCounter gets the frame counter value of the `GdkFrameClock` when this
// frame was drawn.
func (t *FrameTimings) FrameCounter() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_frame_counter(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// FrameTime returns the frame time for the frame.
//
// This is the time value that is typically used to time animations for the
// frame. See [method@Gdk.FrameClock.get_frame_time].
func (t *FrameTimings) FrameTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_frame_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PredictedPresentationTime gets the predicted time at which this frame will be
// displayed.
//
// Although no predicted time may be available, if one is available, it will be
// available while the frame is being generated, in contrast to
// [method@Gdk.FrameTimings.get_presentation_time], which is only available
// after the frame has been presented.
//
// In general, if you are simply animating, you should use
// [method@Gdk.FrameClock.get_frame_time] rather than this function, but this
// function is useful for applications that want exact control over latency. For
// example, a movie player may want this information for Audio/Video
// synchronization.
func (t *FrameTimings) PredictedPresentationTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_predicted_presentation_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PresentationTime reurns the presentation time.
//
// This is the time at which the frame became visible to the user.
func (t *FrameTimings) PresentationTime() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_presentation_time(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// RefreshInterval gets the natural interval between presentation times for the
// display that this frame was displayed on.
//
// Frame presentation usually happens during the “vertical blanking interval”.
func (t *FrameTimings) RefreshInterval() int64 {
	var _arg0 *C.GdkFrameTimings // out
	var _cret C.gint64           // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_get_refresh_interval(_arg0)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Ref increases the reference count of @timings.
func (t *FrameTimings) Ref() *FrameTimings {
	var _arg0 *C.GdkFrameTimings // out
	var _cret *C.GdkFrameTimings // in

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_frame_timings_ref(_arg0)

	var _frameTimings *FrameTimings // out

	_frameTimings = (*FrameTimings)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_frameTimings, func(v **FrameTimings) {
		C.free(unsafe.Pointer(v))
	})

	return _frameTimings
}

// Unref decreases the reference count of @timings.
//
// If @timings is no longer referenced, it will be freed.
func (t *FrameTimings) Unref() {
	var _arg0 *C.GdkFrameTimings // out

	_arg0 = (*C.GdkFrameTimings)(unsafe.Pointer(t.Native()))

	C.gdk_frame_timings_unref(_arg0)
}

// KeymapKey: a `GdkKeymapKey` is a hardware key that can be mapped to a keyval.
type KeymapKey C.GdkKeymapKey

// WrapKeymapKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeymapKey(ptr unsafe.Pointer) *KeymapKey {
	return (*KeymapKey)(ptr)
}

// Native returns the underlying C source pointer.
func (k *KeymapKey) Native() unsafe.Pointer {
	return unsafe.Pointer(k)
}

// PopupLayout: the `GdkPopupLayout` struct contains information that is
// necessary position a [interface@Gdk.Popup] relative to its parent.
//
// The positioning requires a negotiation with the windowing system, since it
// depends on external constraints, such as the position of the parent surface,
// and the screen dimensions.
//
// The basic ingredients are a rectangle on the parent surface, and the anchor
// on both that rectangle and the popup. The anchors specify a side or corner to
// place next to each other.
//
// !Popup anchors (popup-anchors.png)
//
// For cases where placing the anchors next to each other would make the popup
// extend offscreen, the layout includes some hints for how to resolve this
// problem. The hints may suggest to flip the anchor position to the other side,
// or to 'slide' the popup along a side, or to resize it.
//
// !Flipping popups (popup-flip.png)
//
// !Sliding popups (popup-slide.png)
//
// These hints may be combined.
//
// Ultimatively, it is up to the windowing system to determine the position and
// size of the popup. You can learn about the result by calling
// [method@Gdk.Popup.get_position_x], [method@Gdk.Popup.get_position_y],
// [method@Gdk.Popup.get_rect_anchor] and [method@Gdk.Popup.get_surface_anchor]
// after the popup has been presented. This can be used to adjust the rendering.
// For example, [class@Gtk.Popover] changes its arrow position accordingly. But
// you have to be careful avoid changing the size of the popover, or it has to
// be presented again.
type PopupLayout C.GdkPopupLayout

// WrapPopupLayout wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPopupLayout(ptr unsafe.Pointer) *PopupLayout {
	return (*PopupLayout)(ptr)
}

func marshalPopupLayout(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*PopupLayout)(unsafe.Pointer(b)), nil
}

// NewPopupLayout constructs a struct PopupLayout.
func NewPopupLayout(anchorRect *Rectangle, rectAnchor Gravity, surfaceAnchor Gravity) *PopupLayout {
	var _arg1 *C.GdkRectangle   // out
	var _arg2 C.GdkGravity      // out
	var _arg3 C.GdkGravity      // out
	var _cret *C.GdkPopupLayout // in

	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(anchorRect.Native()))
	_arg2 = C.GdkGravity(rectAnchor)
	_arg3 = C.GdkGravity(surfaceAnchor)

	_cret = C.gdk_popup_layout_new(_arg1, _arg2, _arg3)

	var _popupLayout *PopupLayout // out

	_popupLayout = (*PopupLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_popupLayout, func(v **PopupLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _popupLayout
}

// Native returns the underlying C source pointer.
func (p *PopupLayout) Native() unsafe.Pointer {
	return unsafe.Pointer(p)
}

// Copy makes a copy of @layout.
func (l *PopupLayout) Copy() *PopupLayout {
	var _arg0 *C.GdkPopupLayout // out
	var _cret *C.GdkPopupLayout // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_copy(_arg0)

	var _popupLayout *PopupLayout // out

	_popupLayout = (*PopupLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_popupLayout, func(v **PopupLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _popupLayout
}

// Equal: check whether @layout and @other has identical layout properties.
func (l *PopupLayout) Equal(other *PopupLayout) bool {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 *C.GdkPopupLayout // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GdkPopupLayout)(unsafe.Pointer(other.Native()))

	_cret = C.gdk_popup_layout_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AnchorHints: get the `GdkAnchorHints`.
func (l *PopupLayout) AnchorHints() AnchorHints {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkAnchorHints  // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_get_anchor_hints(_arg0)

	var _anchorHints AnchorHints // out

	_anchorHints = AnchorHints(_cret)

	return _anchorHints
}

// AnchorRect: get the anchor rectangle.
func (l *PopupLayout) AnchorRect() *Rectangle {
	var _arg0 *C.GdkPopupLayout // out
	var _cret *C.GdkRectangle   // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_get_anchor_rect(_arg0)

	var _rectangle *Rectangle // out

	_rectangle = (*Rectangle)(unsafe.Pointer(_cret))

	return _rectangle
}

// Offset retrieves the offset for the anchor rectangle.
func (l *PopupLayout) Offset() (dx int, dy int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // in
	var _arg2 C.int             // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	C.gdk_popup_layout_get_offset(_arg0, &_arg1, &_arg2)

	var _dx int // out
	var _dy int // out

	_dx = int(_arg1)
	_dy = int(_arg2)

	return _dx, _dy
}

// RectAnchor returns the anchor position on the anchor rectangle.
func (l *PopupLayout) RectAnchor() Gravity {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkGravity      // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_get_rect_anchor(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// ShadowWidth obtains the shadow widths of this layout.
func (l *PopupLayout) ShadowWidth() (left int, right int, top int, bottom int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // in
	var _arg2 C.int             // in
	var _arg3 C.int             // in
	var _arg4 C.int             // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	C.gdk_popup_layout_get_shadow_width(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

	var _left int   // out
	var _right int  // out
	var _top int    // out
	var _bottom int // out

	_left = int(_arg1)
	_right = int(_arg2)
	_top = int(_arg3)
	_bottom = int(_arg4)

	return _left, _right, _top, _bottom
}

// SurfaceAnchor returns the anchor position on the popup surface.
func (l *PopupLayout) SurfaceAnchor() Gravity {
	var _arg0 *C.GdkPopupLayout // out
	var _cret C.GdkGravity      // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_get_surface_anchor(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// Ref increases the reference count of @value.
func (l *PopupLayout) Ref() *PopupLayout {
	var _arg0 *C.GdkPopupLayout // out
	var _cret *C.GdkPopupLayout // in

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_popup_layout_ref(_arg0)

	var _popupLayout *PopupLayout // out

	_popupLayout = (*PopupLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_popupLayout, func(v **PopupLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _popupLayout
}

// SetAnchorHints: set new anchor hints.
//
// The set @anchor_hints determines how @surface will be moved if the anchor
// points cause it to move off-screen. For example, GDK_ANCHOR_FLIP_X will
// replace GDK_GRAVITY_NORTH_WEST with GDK_GRAVITY_NORTH_EAST and vice versa if
// @surface extends beyond the left or right edges of the monitor.
func (l *PopupLayout) SetAnchorHints(anchorHints AnchorHints) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkAnchorHints  // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = C.GdkAnchorHints(anchorHints)

	C.gdk_popup_layout_set_anchor_hints(_arg0, _arg1)
}

// SetAnchorRect: set the anchor rectangle.
func (l *PopupLayout) SetAnchorRect(anchorRect *Rectangle) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 *C.GdkRectangle   // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(anchorRect.Native()))

	C.gdk_popup_layout_set_anchor_rect(_arg0, _arg1)
}

// SetOffset: offset the position of the anchor rectangle with the given delta.
func (l *PopupLayout) SetOffset(dx int, dy int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = C.int(dx)
	_arg2 = C.int(dy)

	C.gdk_popup_layout_set_offset(_arg0, _arg1, _arg2)
}

// SetRectAnchor: set the anchor on the anchor rectangle.
func (l *PopupLayout) SetRectAnchor(anchor Gravity) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkGravity      // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = C.GdkGravity(anchor)

	C.gdk_popup_layout_set_rect_anchor(_arg0, _arg1)
}

// SetShadowWidth sets the shadow width of the popup.
//
// The shadow width corresponds to the part of the computed surface size that
// would consist of the shadow margin surrounding the window, would there be
// any.
func (l *PopupLayout) SetShadowWidth(left int, right int, top int, bottom int) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = C.int(left)
	_arg2 = C.int(right)
	_arg3 = C.int(top)
	_arg4 = C.int(bottom)

	C.gdk_popup_layout_set_shadow_width(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSurfaceAnchor: set the anchor on the popup surface.
func (l *PopupLayout) SetSurfaceAnchor(anchor Gravity) {
	var _arg0 *C.GdkPopupLayout // out
	var _arg1 C.GdkGravity      // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))
	_arg1 = C.GdkGravity(anchor)

	C.gdk_popup_layout_set_surface_anchor(_arg0, _arg1)
}

// Unref decreases the reference count of @value.
func (l *PopupLayout) Unref() {
	var _arg0 *C.GdkPopupLayout // out

	_arg0 = (*C.GdkPopupLayout)(unsafe.Pointer(l.Native()))

	C.gdk_popup_layout_unref(_arg0)
}

// RGBA: a `GdkRGBA` is used to represent a color, in a way that is compatible
// with cairo’s notion of color.
//
// `GdkRGBA` is a convenient way to pass colors around. It’s based on cairo’s
// way to deal with colors and mirrors its behavior. All values are in the range
// from 0.0 to 1.0 inclusive. So the color (0.0, 0.0, 0.0, 0.0) represents
// transparent black and (1.0, 1.0, 1.0, 1.0) is opaque white. Other values will
// be clamped to this range when drawing.
type RGBA C.GdkRGBA

// WrapRGBA wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRGBA(ptr unsafe.Pointer) *RGBA {
	return (*RGBA)(ptr)
}

func marshalRGBA(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*RGBA)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *RGBA) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// Copy makes a copy of a `GdkRGBA`.
//
// The result must be freed through [method@Gdk.RGBA.free].
func (r *RGBA) Copy() *RGBA {
	var _arg0 *C.GdkRGBA // out
	var _cret *C.GdkRGBA // in

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))

	_cret = C.gdk_rgba_copy(_arg0)

	var _rgbA *RGBA // out

	_rgbA = (*RGBA)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_rgbA, func(v **RGBA) {
		C.free(unsafe.Pointer(v))
	})

	return _rgbA
}

// Equal compares two `GdkRGBA` colors.
func (p *RGBA) Equal(p2 RGBA) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(p.Native()))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(p2.Native()))

	_cret = C.gdk_rgba_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free frees a `GdkRGBA`.
func (r *RGBA) Free() {
	var _arg0 *C.GdkRGBA // out

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))

	C.gdk_rgba_free(_arg0)
}

// Hash: a hash function suitable for using for a hash table that stores
// `GdkRGBA`s.
func (p *RGBA) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = (C.gconstpointer)(unsafe.Pointer(p.Native()))

	_cret = C.gdk_rgba_hash(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsClear checks if an @rgba value is transparent.
//
// That is, drawing with the value would not produce any change.
func (r *RGBA) IsClear() bool {
	var _arg0 *C.GdkRGBA // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))

	_cret = C.gdk_rgba_is_clear(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsOpaque checks if an @rgba value is opaque.
//
// That is, drawing with the value will not retain any results from previous
// contents.
func (r *RGBA) IsOpaque() bool {
	var _arg0 *C.GdkRGBA // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))

	_cret = C.gdk_rgba_is_opaque(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parse parses a textual representation of a color.
//
// The string can be either one of:
//
// - A standard name (Taken from the X11 rgb.txt file). - A hexadecimal value in
// the form “\#rgb”, “\#rrggbb”, “\#rrrgggbbb” or ”\#rrrrggggbbbb” - A
// hexadecimal value in the form “\#rgba”, “\#rrggbbaa”, or ”\#rrrrggggbbbbaaaa”
// - A RGB color in the form “rgb(r,g,b)” (In this case the color will have full
// opacity) - A RGBA color in the form “rgba(r,g,b,a)”
//
// Where “r”, “g”, “b” and “a” are respectively the red, green, blue and alpha
// color values. In the last two cases, “r”, “g”, and “b” are either integers in
// the range 0 to 255 or percentage values in the range 0% to 100%, and a is a
// floating point value in the range 0 to 1.
func (r *RGBA) Parse(spec string) bool {
	var _arg0 *C.GdkRGBA // out
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.char)(C.CString(spec))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_rgba_parse(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String returns a textual specification of @rgba in the form `rgb(r,g,b)` or
// `rgba(r,g,b,a)`, where “r”, “g”, “b” and “a” represent the red, green, blue
// and alpha values respectively. “r”, “g”, and “b” are represented as integers
// in the range 0 to 255, and “a” is represented as a floating point value in
// the range 0 to 1.
//
// These string forms are string forms that are supported by the CSS3 colors
// module, and can be parsed by [method@Gdk.RGBA.parse].
//
// Note that this string representation may lose some precision, since “r”, “g”
// and “b” are represented as 8-bit integers. If this is a concern, you should
// use a different representation.
func (r *RGBA) String() string {
	var _arg0 *C.GdkRGBA // out
	var _cret *C.char    // in

	_arg0 = (*C.GdkRGBA)(unsafe.Pointer(r.Native()))

	_cret = C.gdk_rgba_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Rectangle: a `GdkRectangle` data type for representing rectangles.
//
// `GdkRectangle` is identical to `cairo_rectangle_t`. Together with Cairo’s
// `cairo_region_t` data type, these are the central types for representing sets
// of pixels.
//
// The intersection of two rectangles can be computed with
// [method@Gdk.Rectangle.intersect]; to find the union of two rectangles use
// [method@Gdk.Rectangle.union].
//
// The `cairo_region_t` type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and volumes
// in 2D and 3D.
type Rectangle C.GdkRectangle

// WrapRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRectangle(ptr unsafe.Pointer) *Rectangle {
	return (*Rectangle)(ptr)
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Rectangle)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(r)
}

// ContainsPoint returns UE if @rect contains the point described by @x and @y.
func (r *Rectangle) ContainsPoint(x int, y int) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gdk_rectangle_contains_point(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal checks if the two given rectangles are equal.
func (r *Rectangle) Equal(rect2 *Rectangle) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect2.Native()))

	_cret = C.gdk_rectangle_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Intersect calculates the intersection of two rectangles.
//
// It is allowed for @dest to be the same as either @src1 or @src2. If the
// rectangles do not intersect, @dest’s width and height is set to 0 and its x
// and y values are undefined. If you are only interested in whether the
// rectangles intersect, but not in the intersecting area itself, pass nil for
// @dest.
func (s *Rectangle) Intersect(src2 *Rectangle) (Rectangle, bool) {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	_cret = C.gdk_rectangle_intersect(_arg0, _arg1, &_arg2)

	var _dest Rectangle // out
	var _ok bool        // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *Rectangle

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_dest = *refTmpOut
	}
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// Union calculates the union of two rectangles.
//
// The union of rectangles @src1 and @src2 is the smallest rectangle which
// includes both @src1 and @src2 within it. It is allowed for @dest to be the
// same as either @src1 or @src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with zero
// width or height).
func (s *Rectangle) Union(src2 *Rectangle) Rectangle {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	C.gdk_rectangle_union(_arg0, _arg1, &_arg2)

	var _dest Rectangle // out

	{
		var refTmpIn *C.GdkRectangle
		var refTmpOut *Rectangle

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*Rectangle)(unsafe.Pointer(refTmpIn))

		_dest = *refTmpOut
	}

	return _dest
}

// TimeCoord: a TimeCoord stores a single event in a motion history.
type TimeCoord C.GdkTimeCoord

// WrapTimeCoord wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTimeCoord(ptr unsafe.Pointer) *TimeCoord {
	return (*TimeCoord)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TimeCoord) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// ToplevelLayout: the `GdkToplevelLayout` struct contains information that is
// necessary to present a sovereign window on screen.
//
// The `GdkToplevelLayout` struct is necessary for using
// [method@Gdk.Toplevel.present].
//
// Toplevel surfaces are sovereign windows that can be presented to the user in
// various states (maximized, on all workspaces, etc).
type ToplevelLayout C.GdkToplevelLayout

// WrapToplevelLayout wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToplevelLayout(ptr unsafe.Pointer) *ToplevelLayout {
	return (*ToplevelLayout)(ptr)
}

func marshalToplevelLayout(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*ToplevelLayout)(unsafe.Pointer(b)), nil
}

// NewToplevelLayout constructs a struct ToplevelLayout.
func NewToplevelLayout() *ToplevelLayout {
	var _cret *C.GdkToplevelLayout // in

	_cret = C.gdk_toplevel_layout_new()

	var _toplevelLayout *ToplevelLayout // out

	_toplevelLayout = (*ToplevelLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_toplevelLayout, func(v **ToplevelLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _toplevelLayout
}

// Native returns the underlying C source pointer.
func (t *ToplevelLayout) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Copy: create a new ToplevelLayout and copy the contents of @layout into it.
func (l *ToplevelLayout) Copy() *ToplevelLayout {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret *C.GdkToplevelLayout // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_copy(_arg0)

	var _toplevelLayout *ToplevelLayout // out

	_toplevelLayout = (*ToplevelLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_toplevelLayout, func(v **ToplevelLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _toplevelLayout
}

// Equal: check whether @layout and @other has identical layout properties.
func (l *ToplevelLayout) Equal(other *ToplevelLayout) bool {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 *C.GdkToplevelLayout // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.GdkToplevelLayout)(unsafe.Pointer(other.Native()))

	_cret = C.gdk_toplevel_layout_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fullscreen: if the layout specifies whether to the toplevel should go
// fullscreen, the value pointed to by @fullscreen is set to true if it should
// go fullscreen, or false, if it should go unfullscreen.
func (l *ToplevelLayout) Fullscreen() (fullscreen bool, ok bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_get_fullscreen(_arg0, &_arg1)

	var _fullscreen bool // out
	var _ok bool         // out

	if _arg1 != 0 {
		_fullscreen = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _fullscreen, _ok
}

// FullscreenMonitor returns the monitor that the layout is fullscreening the
// surface on.
func (l *ToplevelLayout) FullscreenMonitor() Monitor {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret *C.GdkMonitor        // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_get_fullscreen_monitor(_arg0)

	var _monitor Monitor // out

	_monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Monitor)

	return _monitor
}

// Maximized: if the layout specifies whether to the toplevel should go
// maximized, the value pointed to by @maximized is set to true if it should go
// fullscreen, or false, if it should go unmaximized.
func (l *ToplevelLayout) Maximized() (maximized bool, ok bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_get_maximized(_arg0, &_arg1)

	var _maximized bool // out
	var _ok bool        // out

	if _arg1 != 0 {
		_maximized = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _maximized, _ok
}

// Resizable returns whether the layout should allow the user to resize the
// surface.
func (l *ToplevelLayout) Resizable() bool {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_get_resizable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ref increases the reference count of @layout.
func (l *ToplevelLayout) Ref() *ToplevelLayout {
	var _arg0 *C.GdkToplevelLayout // out
	var _cret *C.GdkToplevelLayout // in

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	_cret = C.gdk_toplevel_layout_ref(_arg0)

	var _toplevelLayout *ToplevelLayout // out

	_toplevelLayout = (*ToplevelLayout)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_toplevelLayout, func(v **ToplevelLayout) {
		C.free(unsafe.Pointer(v))
	})

	return _toplevelLayout
}

// SetFullscreen sets whether the layout should cause the surface to be
// fullscreen when presented.
func (l *ToplevelLayout) SetFullscreen(fullscreen bool, monitor Monitor) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out
	var _arg2 *C.GdkMonitor        // out

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if fullscreen {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

	C.gdk_toplevel_layout_set_fullscreen(_arg0, _arg1, _arg2)
}

// SetMaximized sets whether the layout should cause the surface to be maximized
// when presented.
func (l *ToplevelLayout) SetMaximized(maximized bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if maximized {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_layout_set_maximized(_arg0, _arg1)
}

// SetResizable sets whether the layout should allow the user to resize the
// surface after it has been presented.
func (l *ToplevelLayout) SetResizable(resizable bool) {
	var _arg0 *C.GdkToplevelLayout // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gdk_toplevel_layout_set_resizable(_arg0, _arg1)
}

// Unref decreases the reference count of @layout.
func (l *ToplevelLayout) Unref() {
	var _arg0 *C.GdkToplevelLayout // out

	_arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	C.gdk_toplevel_layout_unref(_arg0)
}

// ToplevelSize: the `GdkToplevelSize` struct contains information that is
// useful to compute the size of a toplevel.
type ToplevelSize C.GdkToplevelSize

// WrapToplevelSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToplevelSize(ptr unsafe.Pointer) *ToplevelSize {
	return (*ToplevelSize)(ptr)
}

// Native returns the underlying C source pointer.
func (t *ToplevelSize) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// Bounds retrieves the bounds the toplevel is placed within.
//
// The bounds represent the largest size a toplevel may have while still being
// able to fit within some type of boundary. Depending on the backend, this may
// be equivalent to the dimensions of the work area or the monitor on which the
// window is being presented on, or something else that limits the way a
// toplevel can be presented.
func (s *ToplevelSize) Bounds() (boundsWidth int, boundsHeight int) {
	var _arg0 *C.GdkToplevelSize // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.GdkToplevelSize)(unsafe.Pointer(s.Native()))

	C.gdk_toplevel_size_get_bounds(_arg0, &_arg1, &_arg2)

	var _boundsWidth int  // out
	var _boundsHeight int // out

	_boundsWidth = int(_arg1)
	_boundsHeight = int(_arg2)

	return _boundsWidth, _boundsHeight
}

// SetMinSize sets the minimum size of the toplevel.
//
// The minimum size corresponds to the limitations the toplevel can be shrunk
// to, without resulting in incorrect painting. A user of a `GdkToplevel` should
// calculate these given both the existing size, and the bounds retrieved from
// the `GdkToplevelSize` object.
//
// The minimum size should be within the bounds (see
// [method@Gdk.ToplevelSize.get_bounds]).
func (s *ToplevelSize) SetMinSize(minWidth int, minHeight int) {
	var _arg0 *C.GdkToplevelSize // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GdkToplevelSize)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(minWidth)
	_arg2 = C.int(minHeight)

	C.gdk_toplevel_size_set_min_size(_arg0, _arg1, _arg2)
}

// SetShadowWidth sets the shadows size of the toplevel.
//
// The shadow width corresponds to the part of the computed surface size that
// would consist of the shadow margin surrounding the window, would there be
// any.
func (s *ToplevelSize) SetShadowWidth(left int, right int, top int, bottom int) {
	var _arg0 *C.GdkToplevelSize // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _arg4 C.int              // out

	_arg0 = (*C.GdkToplevelSize)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(left)
	_arg2 = C.int(right)
	_arg3 = C.int(top)
	_arg4 = C.int(bottom)

	C.gdk_toplevel_size_set_shadow_width(_arg0, _arg1, _arg2, _arg3, _arg4)
}

// SetSize sets the size the toplevel prefers to be resized to.
//
// The size should be within the bounds (see
// [method@Gdk.ToplevelSize.get_bounds]). The set size should be considered as a
// hint, and should not be assumed to be respected by the windowing system, or
// backend.
func (s *ToplevelSize) SetSize(width int, height int) {
	var _arg0 *C.GdkToplevelSize // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GdkToplevelSize)(unsafe.Pointer(s.Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gdk_toplevel_size_set_size(_arg0, _arg1, _arg2)
}
