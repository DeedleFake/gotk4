// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_content_formats_get_type()), F: marshalContentFormats},
		{T: externglib.Type(C.gdk_rectangle_get_type()), F: marshalRectangle},
	})
}

// ContentFormats: the `GdkContentFormats` structure is used to advertise and
// negotiate the format of content.
//
// You will encounter `GdkContentFormats` when interacting with objects
// controlling operations that pass data between different widgets, window or
// application, like [class@Gdk.Drag], [class@Gdk.Drop], [class@Gdk.Clipboard]
// or [class@Gdk.ContentProvider].
//
// GDK supports content in 2 forms: `GType` and mime type. Using `GTypes` is
// meant only for in-process content transfers. Mime types are meant to be used
// for data passing both in-process and out-of-process. The details of how data
// is passed is described in the documentation of the actual implementations. To
// transform between the two forms, [class@Gdk.ContentSerializer] and
// [class@Gdk.ContentDeserializer] are used.
//
// A `GdkContentFormats` describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. `GTypes` are more
// important than mime types. Order between different `GTypes` or mime types is
// the order they were added in, most important first. Functions that care about
// order, such as [method@Gdk.ContentFormats.union], will describe in their
// documentation how they interpret that order, though in general the order of
// the first argument is considered the primary order of the result, followed by
// the order of further arguments.
//
// For debugging purposes, the function [method@Gdk.ContentFormats.to_string]
// exists. It will print a comma-separated list of formats from most important
// to least important.
//
// `GdkContentFormats` is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new `GdkContentFormats` have to be created.
// The [struct@Gdk.ContentFormatsBuilder]` structure is meant to help in this
// endeavor.
type ContentFormats struct {
	native C.GdkContentFormats
}

// WrapContentFormats wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContentFormats(ptr unsafe.Pointer) *ContentFormats {
	if ptr == nil {
		return nil
	}

	return (*ContentFormats)(ptr)
}

func marshalContentFormats(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapContentFormats(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ContentFormats) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// ContainGType checks if a given `GType` is part of the given @formats.
func (f *ContentFormats) ContainGType(typ externglib.Type) bool {
	var _arg0 *C.GdkContentFormats
	var _arg1 C.GType

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = C.GType(typ)

	var _cret C.gboolean

	_cret = C.gdk_content_formats_contain_gtype(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// ContainMIMEType checks if a given mime type is part of the given @formats.
func (f *ContentFormats) ContainMIMEType(mimeType string) bool {
	var _arg0 *C.GdkContentFormats
	var _arg1 *C.char

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean

	_cret = C.gdk_content_formats_contain_mime_type(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// GTypes gets the `GTypes` included in @formats.
//
// Note that @formats may not contain any #GTypes, in particular when they are
// empty. In that case nil will be returned.
func (f *ContentFormats) GTypes() []externglib.Type {
	var _arg0 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret *C.GType
	var _arg1 *C.gsize

	_cret = C.gdk_content_formats_get_gtypes(_arg0, &_arg1)

	var _gTypes []externglib.Type

	{
		var src []C.GType
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_gTypes = make([]externglib.Type, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_gTypes = externglib.Type(_cret)
		}
	}

	return _gTypes
}

// MIMETypes gets the mime types included in @formats.
//
// Note that @formats may not contain any mime types, in particular when they
// are empty. In that case nil will be returned.
func (f *ContentFormats) MIMETypes() []string {
	var _arg0 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret **C.char
	var _arg1 *C.gsize

	_cret = C.gdk_content_formats_get_mime_types(_arg0, &_arg1)

	var _utf8s []string

	{
		var src []*C.gchar
		ptr.SetSlice(unsafe.Pointer(&src), unsafe.Pointer(_cret), int(_arg1))

		_utf8s = make([]string, _arg1)
		for i := 0; i < uintptr(_arg1); i++ {
			_utf8s = C.GoString(_cret)
		}
	}

	return _utf8s
}

// Match checks if @first and @second have any matching formats.
func (f *ContentFormats) Match(second *ContentFormats) bool {
	var _arg0 *C.GdkContentFormats
	var _arg1 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret C.gboolean

	_cret = C.gdk_content_formats_match(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// MatchGType finds the first `GType` from @first that is also contained in
// @second.
//
// If no matching `GType` is found, G_TYPE_INVALID is returned.
func (f *ContentFormats) MatchGType(second *ContentFormats) externglib.Type {
	var _arg0 *C.GdkContentFormats
	var _arg1 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret C.GType

	_cret = C.gdk_content_formats_match_gtype(_arg0, _arg1)

	var _gType externglib.Type

	_gType = externglib.Type(_cret)

	return _gType
}

// MatchMIMEType finds the first mime type from @first that is also contained in
// @second.
//
// If no matching mime type is found, nil is returned.
func (f *ContentFormats) MatchMIMEType(second *ContentFormats) string {
	var _arg0 *C.GdkContentFormats
	var _arg1 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret *C.char

	_cret = C.gdk_content_formats_match_mime_type(_arg0, _arg1)

	var _utf8 string

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Print prints the given @formats into a string for human consumption.
//
// This is meant for debugging and logging.
//
// The form of the representation may change at any time and is not guaranteed
// to stay identical.
func (f *ContentFormats) Print(string *glib.String) {
	var _arg0 *C.GdkContentFormats
	var _arg1 *C.GString

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GString)(unsafe.Pointer(string.Native()))

	C.gdk_content_formats_print(_arg0, _arg1)
}

// String prints the given @formats into a human-readable string.
//
// This is a small wrapper around [method@Gdk.ContentFormats.print] to help when
// debugging.
func (f *ContentFormats) String() string {
	var _arg0 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret *C.char

	_cret = C.gdk_content_formats_to_string(_arg0)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decreases the reference count of a `GdkContentFormats` by one.
//
// If the resulting reference count is zero, frees the formats.
func (f *ContentFormats) Unref() {
	var _arg0 *C.GdkContentFormats

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	C.gdk_content_formats_unref(_arg0)
}

// KeymapKey: a `GdkKeymapKey` is a hardware key that can be mapped to a keyval.
type KeymapKey struct {
	native C.GdkKeymapKey
}

// WrapKeymapKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeymapKey(ptr unsafe.Pointer) *KeymapKey {
	if ptr == nil {
		return nil
	}

	return (*KeymapKey)(ptr)
}

func marshalKeymapKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapKeymapKey(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (k *KeymapKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&k.native)
}

// Keycode gets the field inside the struct.
func (k *KeymapKey) Keycode() uint {
	var v uint
	v = (uint)(k.native.keycode)
	return v
}

// Group gets the field inside the struct.
func (k *KeymapKey) Group() int {
	var v int
	v = (int)(k.native.group)
	return v
}

// Level gets the field inside the struct.
func (k *KeymapKey) Level() int {
	var v int
	v = (int)(k.native.level)
	return v
}

// Rectangle: a `GdkRectangle` data type for representing rectangles.
//
// `GdkRectangle` is identical to `cairo_rectangle_t`. Together with Cairoâ€™s
// `cairo_region_t` data type, these are the central types for representing sets
// of pixels.
//
// The intersection of two rectangles can be computed with
// [method@Gdk.Rectangle.intersect]; to find the union of two rectangles use
// [method@Gdk.Rectangle.union].
//
// The `cairo_region_t` type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and volumes
// in 2D and 3D.
type Rectangle struct {
	native C.GdkRectangle
}

// WrapRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRectangle(ptr unsafe.Pointer) *Rectangle {
	if ptr == nil {
		return nil
	}

	return (*Rectangle)(ptr)
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRectangle(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// X gets the field inside the struct.
func (r *Rectangle) X() int {
	var v int
	v = (int)(r.native.x)
	return v
}

// Y gets the field inside the struct.
func (r *Rectangle) Y() int {
	var v int
	v = (int)(r.native.y)
	return v
}

// Width gets the field inside the struct.
func (r *Rectangle) Width() int {
	var v int
	v = (int)(r.native.width)
	return v
}

// Height gets the field inside the struct.
func (r *Rectangle) Height() int {
	var v int
	v = (int)(r.native.height)
	return v
}

// ContainsPoint returns UE if @rect contains the point described by @x and @y.
func (r *Rectangle) ContainsPoint(x int, y int) bool {
	var _arg0 *C.GdkRectangle
	var _arg1 C.int
	var _arg2 C.int

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	var _cret C.gboolean

	_cret = C.gdk_rectangle_contains_point(_arg0, _arg1, _arg2)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Equal checks if the two given rectangles are equal.
func (r *Rectangle) Equal(rect2 *Rectangle) bool {
	var _arg0 *C.GdkRectangle
	var _arg1 *C.GdkRectangle

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect2.Native()))

	var _cret C.gboolean

	_cret = C.gdk_rectangle_equal(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Intersect calculates the intersection of two rectangles.
//
// It is allowed for @dest to be the same as either @src1 or @src2. If the
// rectangles do not intersect, @destâ€™s width and height is set to 0 and its x
// and y values are undefined. If you are only interested in whether the
// rectangles intersect, but not in the intersecting area itself, pass nil for
// @dest.
func (s *Rectangle) Intersect(src2 *Rectangle) (Rectangle, bool) {
	var _arg0 *C.GdkRectangle
	var _arg1 *C.GdkRectangle

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	var _dest Rectangle
	var _cret C.gboolean

	_cret = C.gdk_rectangle_intersect(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_dest)))

	var _ok bool

	if _cret {
		_ok = true
	}

	return _dest, _ok
}

// Union calculates the union of two rectangles.
//
// The union of rectangles @src1 and @src2 is the smallest rectangle which
// includes both @src1 and @src2 within it. It is allowed for @dest to be the
// same as either @src1 or @src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with zero
// width or height).
func (s *Rectangle) Union(src2 *Rectangle) Rectangle {
	var _arg0 *C.GdkRectangle
	var _arg1 *C.GdkRectangle

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	var _dest Rectangle

	C.gdk_rectangle_union(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_dest)))

	return _dest
}
