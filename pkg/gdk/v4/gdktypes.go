// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: glib-2.0 gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_axis_use_get_type()), F: marshalAxisUse},
		{T: externglib.Type(C.gdk_gl_error_get_type()), F: marshalGLError},
		{T: externglib.Type(C.gdk_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.gdk_vulkan_error_get_type()), F: marshalVulkanError},
		{T: externglib.Type(C.gdk_axis_flags_get_type()), F: marshalAxisFlags},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
		{T: externglib.Type(C.gdk_modifier_type_get_type()), F: marshalModifierType},
		{T: externglib.Type(C.gdk_content_formats_get_type()), F: marshalContentFormats},
		{T: externglib.Type(C.gdk_rectangle_get_type()), F: marshalRectangle},
	})
}

// AxisUse defines how device axes are interpreted by GTK.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse int

const (
	// AxisUseIgnore: the axis is ignored.
	AxisUseIgnore AxisUse = 0
	// AxisUseX: the axis is used as the x axis.
	AxisUseX AxisUse = 1
	// AxisUseY: the axis is used as the y axis.
	AxisUseY AxisUse = 2
	// AxisUseDeltaX: the axis is used as the scroll x delta
	AxisUseDeltaX AxisUse = 3
	// AxisUseDeltaY: the axis is used as the scroll y delta
	AxisUseDeltaY AxisUse = 4
	// AxisUsePressure: the axis is used for pressure information.
	AxisUsePressure AxisUse = 5
	// AxisUseXtilt: the axis is used for x tilt information.
	AxisUseXtilt AxisUse = 6
	// AxisUseYtilt: the axis is used for y tilt information.
	AxisUseYtilt AxisUse = 7
	// AxisUseWheel: the axis is used for wheel information.
	AxisUseWheel AxisUse = 8
	// AxisUseDistance: the axis is used for pen/tablet distance information
	AxisUseDistance AxisUse = 9
	// AxisUseRotation: the axis is used for pen rotation information
	AxisUseRotation AxisUse = 10
	// AxisUseSlider: the axis is used for pen slider information
	AxisUseSlider AxisUse = 11
	// AxisUseLast: a constant equal to the numerically highest axis value.
	AxisUseLast AxisUse = 12
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLError: error enumeration for `GdkGLContext`.
type GLError int

const (
	// GLErrorNotAvailable: openGL support is not available
	GLErrorNotAvailable GLError = 0
	// GLErrorUnsupportedFormat: the requested visual format is not supported
	GLErrorUnsupportedFormat GLError = 1
	// GLErrorUnsupportedProfile: the requested profile is not supported
	GLErrorUnsupportedProfile GLError = 2
	// GLErrorCompilationFailed: the shader compilation failed
	GLErrorCompilationFailed GLError = 3
	// GLErrorLinkFailed: the shader linking failed
	GLErrorLinkFailed GLError = 4
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity defines the reference point of a surface and is used in PopupLayout.
type Gravity int

const (
	// GravityNorthWest: the reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: the reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: the reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: the reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: the reference point is at the center of the surface.
	GravityCenter Gravity = 5
	// GravityEast: the reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: the reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: the reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: the reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: the reference point is at the top left corner of the
	// surface itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VulkanError: error enumeration for VulkanContext.
type VulkanError int

const (
	// VulkanErrorUnsupported: vulkan is not supported on this backend or has
	// not been compiled in.
	VulkanErrorUnsupported VulkanError = 0
	// VulkanErrorNotAvailable: vulkan support is not available on this Surface
	VulkanErrorNotAvailable VulkanError = 1
)

func marshalVulkanError(p uintptr) (interface{}, error) {
	return VulkanError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AxisFlags flags describing the current capabilities of a device/tool.
type AxisFlags int

const (
	// AxisFlagsX: x axis is present
	AxisFlagsX AxisFlags = 2
	// AxisFlagsY: y axis is present
	AxisFlagsY AxisFlags = 4
	// AxisFlagsDeltaX: scroll X delta axis is present
	AxisFlagsDeltaX AxisFlags = 8
	// AxisFlagsDeltaY: scroll Y delta axis is present
	AxisFlagsDeltaY AxisFlags = 16
	// AxisFlagsPressure: pressure axis is present
	AxisFlagsPressure AxisFlags = 32
	// AxisFlagsXtilt: x tilt axis is present
	AxisFlagsXtilt AxisFlags = 64
	// AxisFlagsYtilt: y tilt axis is present
	AxisFlagsYtilt AxisFlags = 128
	// AxisFlagsWheel: wheel axis is present
	AxisFlagsWheel AxisFlags = 256
	// AxisFlagsDistance: distance axis is present
	AxisFlagsDistance AxisFlags = 512
	// AxisFlagsRotation z-axis rotation is present
	AxisFlagsRotation AxisFlags = 1024
	// AxisFlagsSlider: slider axis is present
	AxisFlagsSlider AxisFlags = 2048
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in `GdkDrop` and `GdkDrag` to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction int

const (
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 1
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 2
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means, and is not supported on
	// all platforms.
	DragActionLink DragAction = 4
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 8
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierType flags to indicate the state of modifier keys and mouse buttons
// in events.
//
// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
// Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// GDK_MODIFIER_MASK to remove all private values.
type ModifierType int

const (
	// ModifierTypeShiftMask: the Shift key.
	ModifierTypeShiftMask ModifierType = 1
	// ModifierTypeLockMask: a Lock key (depending on the modifier mapping of
	// the X server this may either be CapsLock or ShiftLock).
	ModifierTypeLockMask ModifierType = 2
	// ModifierTypeControlMask: the Control key.
	ModifierTypeControlMask ModifierType = 4
	// ModifierTypeAltMask: the fourth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier, but
	// normally it is the Alt key).
	ModifierTypeAltMask ModifierType = 8
	// ModifierTypeButton1Mask: the first mouse button.
	ModifierTypeButton1Mask ModifierType = 256
	// ModifierTypeButton2Mask: the second mouse button.
	ModifierTypeButton2Mask ModifierType = 512
	// ModifierTypeButton3Mask: the third mouse button.
	ModifierTypeButton3Mask ModifierType = 1024
	// ModifierTypeButton4Mask: the fourth mouse button.
	ModifierTypeButton4Mask ModifierType = 2048
	// ModifierTypeButton5Mask: the fifth mouse button.
	ModifierTypeButton5Mask ModifierType = 4096
	// ModifierTypeSuperMask: the Super modifier
	ModifierTypeSuperMask ModifierType = 67108864
	// ModifierTypeHyperMask: the Hyper modifier
	ModifierTypeHyperMask ModifierType = 134217728
	// ModifierTypeMetaMask: the Meta modifier
	ModifierTypeMetaMask ModifierType = 268435456
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ContentFormats: the `GdkContentFormats` structure is used to advertise and
// negotiate the format of content.
//
// You will encounter `GdkContentFormats` when interacting with objects
// controlling operations that pass data between different widgets, window or
// application, like [class@Gdk.Drag], [class@Gdk.Drop], [class@Gdk.Clipboard]
// or [class@Gdk.ContentProvider].
//
// GDK supports content in 2 forms: `GType` and mime type. Using `GTypes` is
// meant only for in-process content transfers. Mime types are meant to be used
// for data passing both in-process and out-of-process. The details of how data
// is passed is described in the documentation of the actual implementations. To
// transform between the two forms, [class@Gdk.ContentSerializer] and
// [class@Gdk.ContentDeserializer] are used.
//
// A `GdkContentFormats` describes a set of possible formats content can be
// exchanged in. It is assumed that this set is ordered. `GTypes` are more
// important than mime types. Order between different `GTypes` or mime types is
// the order they were added in, most important first. Functions that care about
// order, such as [method@Gdk.ContentFormats.union], will describe in their
// documentation how they interpret that order, though in general the order of
// the first argument is considered the primary order of the result, followed by
// the order of further arguments.
//
// For debugging purposes, the function [method@Gdk.ContentFormats.to_string]
// exists. It will print a comma-separated list of formats from most important
// to least important.
//
// `GdkContentFormats` is an immutable struct. After creation, you cannot change
// the types it represents. Instead, new `GdkContentFormats` have to be created.
// The [struct@Gdk.ContentFormatsBuilder]` structure is meant to help in this
// endeavor.
type ContentFormats struct {
	native C.GdkContentFormats
}

// WrapContentFormats wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapContentFormats(ptr unsafe.Pointer) *ContentFormats {
	if ptr == nil {
		return nil
	}

	return (*ContentFormats)(ptr)
}

func marshalContentFormats(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapContentFormats(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ContentFormats) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// ContainGType checks if a given `GType` is part of the given @formats.
func (f *ContentFormats) ContainGType(typ externglib.Type) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 C.GType              // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = C.GType(typ)

	var _cret C.gboolean // in

	_cret = C.gdk_content_formats_contain_gtype(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainMIMEType checks if a given mime type is part of the given @formats.
func (f *ContentFormats) ContainMIMEType(mimeType string) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(mimeType))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.gdk_content_formats_contain_mime_type(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GTypes gets the `GTypes` included in @formats.
//
// Note that @formats may not contain any #GTypes, in particular when they are
// empty. In that case nil will be returned.
func (f *ContentFormats) GTypes() []externglib.Type {
	var _arg0 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret *C.GType
	var _arg1 C.gsize // in

	_cret = C.gdk_content_formats_get_gtypes(_arg0, &_arg1)

	var _gTypes []externglib.Type

	{
		src := unsafe.Slice(_cret, _arg1)
		_gTypes = make([]externglib.Type, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_gTypes[i] = externglib.Type(src[i])
		}
	}

	return _gTypes
}

// MIMETypes gets the mime types included in @formats.
//
// Note that @formats may not contain any mime types, in particular when they
// are empty. In that case nil will be returned.
func (f *ContentFormats) MIMETypes() []string {
	var _arg0 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret **C.char
	var _arg1 C.gsize // in

	_cret = C.gdk_content_formats_get_mime_types(_arg0, &_arg1)

	var _utf8s []string

	{
		src := unsafe.Slice(_cret, _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString(src[i])
		}
	}

	return _utf8s
}

// Match checks if @first and @second have any matching formats.
func (f *ContentFormats) Match(second *ContentFormats) bool {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_content_formats_match(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchGType finds the first `GType` from @first that is also contained in
// @second.
//
// If no matching `GType` is found, G_TYPE_INVALID is returned.
func (f *ContentFormats) MatchGType(second *ContentFormats) externglib.Type {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret C.GType // in

	_cret = C.gdk_content_formats_match_gtype(_arg0, _arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// MatchMIMEType finds the first mime type from @first that is also contained in
// @second.
//
// If no matching mime type is found, nil is returned.
func (f *ContentFormats) MatchMIMEType(second *ContentFormats) string {
	var _arg0 *C.GdkContentFormats // out
	var _arg1 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(second.Native()))

	var _cret *C.char // in

	_cret = C.gdk_content_formats_match_mime_type(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// String prints the given @formats into a human-readable string.
//
// This is a small wrapper around [method@Gdk.ContentFormats.print] to help when
// debugging.
func (f *ContentFormats) String() string {
	var _arg0 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	var _cret *C.char // in

	_cret = C.gdk_content_formats_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Unref decreases the reference count of a `GdkContentFormats` by one.
//
// If the resulting reference count is zero, frees the formats.
func (f *ContentFormats) Unref() {
	var _arg0 *C.GdkContentFormats // out

	_arg0 = (*C.GdkContentFormats)(unsafe.Pointer(f.Native()))

	C.gdk_content_formats_unref(_arg0)
}

// KeymapKey: a `GdkKeymapKey` is a hardware key that can be mapped to a keyval.
type KeymapKey struct {
	native C.GdkKeymapKey
}

// WrapKeymapKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeymapKey(ptr unsafe.Pointer) *KeymapKey {
	if ptr == nil {
		return nil
	}

	return (*KeymapKey)(ptr)
}

// Native returns the underlying C source pointer.
func (k *KeymapKey) Native() unsafe.Pointer {
	return unsafe.Pointer(&k.native)
}

// Keycode gets the field inside the struct.
func (k *KeymapKey) Keycode() uint {
	var v uint // out
	v = (uint)(k.native.keycode)
	return v
}

// Group gets the field inside the struct.
func (k *KeymapKey) Group() int {
	var v int // out
	v = (int)(k.native.group)
	return v
}

// Level gets the field inside the struct.
func (k *KeymapKey) Level() int {
	var v int // out
	v = (int)(k.native.level)
	return v
}

// Rectangle: a `GdkRectangle` data type for representing rectangles.
//
// `GdkRectangle` is identical to `cairo_rectangle_t`. Together with Cairo’s
// `cairo_region_t` data type, these are the central types for representing sets
// of pixels.
//
// The intersection of two rectangles can be computed with
// [method@Gdk.Rectangle.intersect]; to find the union of two rectangles use
// [method@Gdk.Rectangle.union].
//
// The `cairo_region_t` type provided by Cairo is usually used for managing
// non-rectangular clipping of graphical operations.
//
// The Graphene library has a number of other data types for regions and volumes
// in 2D and 3D.
type Rectangle struct {
	native C.GdkRectangle
}

// WrapRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRectangle(ptr unsafe.Pointer) *Rectangle {
	if ptr == nil {
		return nil
	}

	return (*Rectangle)(ptr)
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapRectangle(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// X gets the field inside the struct.
func (r *Rectangle) X() int {
	var v int // out
	v = (int)(r.native.x)
	return v
}

// Y gets the field inside the struct.
func (r *Rectangle) Y() int {
	var v int // out
	v = (int)(r.native.y)
	return v
}

// Width gets the field inside the struct.
func (r *Rectangle) Width() int {
	var v int // out
	v = (int)(r.native.width)
	return v
}

// Height gets the field inside the struct.
func (r *Rectangle) Height() int {
	var v int // out
	v = (int)(r.native.height)
	return v
}

// ContainsPoint returns UE if @rect contains the point described by @x and @y.
func (r *Rectangle) ContainsPoint(x int, y int) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	var _cret C.gboolean // in

	_cret = C.gdk_rectangle_contains_point(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal checks if the two given rectangles are equal.
func (r *Rectangle) Equal(rect2 *Rectangle) bool {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect2.Native()))

	var _cret C.gboolean // in

	_cret = C.gdk_rectangle_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Intersect calculates the intersection of two rectangles.
//
// It is allowed for @dest to be the same as either @src1 or @src2. If the
// rectangles do not intersect, @dest’s width and height is set to 0 and its x
// and y values are undefined. If you are only interested in whether the
// rectangles intersect, but not in the intersecting area itself, pass nil for
// @dest.
func (s *Rectangle) Intersect(src2 *Rectangle) (Rectangle, bool) {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	var _dest Rectangle
	var _cret C.gboolean // in

	_cret = C.gdk_rectangle_intersect(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_dest)))

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// Union calculates the union of two rectangles.
//
// The union of rectangles @src1 and @src2 is the smallest rectangle which
// includes both @src1 and @src2 within it. It is allowed for @dest to be the
// same as either @src1 or @src2.
//
// Note that this function does not ignore 'empty' rectangles (ie. with zero
// width or height).
func (s *Rectangle) Union(src2 *Rectangle) Rectangle {
	var _arg0 *C.GdkRectangle // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GdkRectangle)(unsafe.Pointer(s.Native()))
	_arg1 = (*C.GdkRectangle)(unsafe.Pointer(src2.Native()))

	var _dest Rectangle

	C.gdk_rectangle_union(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_dest)))

	return _dest
}
