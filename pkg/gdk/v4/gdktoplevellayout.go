// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_toplevel_layout_get_type()), F: marshalToplevelLayout},
	})
}

// ToplevelLayout: toplevel surfaces are sovereign windows that can be presented
// to the user in various states (maximized, on all workspaces, etc).
//
// The GdkToplevelLayout struct contains information that is necessary to do so,
// and is passed to gdk_toplevel_present().
type ToplevelLayout struct {
	native C.GdkToplevelLayout
}

// WrapToplevelLayout wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapToplevelLayout(ptr unsafe.Pointer) *ToplevelLayout {
	if ptr == nil {
		return nil
	}

	return (*ToplevelLayout)(ptr)
}

func marshalToplevelLayout(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapToplevelLayout(unsafe.Pointer(b)), nil
}

// NewToplevelLayout constructs a struct ToplevelLayout.
func NewToplevelLayout() *ToplevelLayout {
	var cret *C.GdkToplevelLayout
	var ret1 *ToplevelLayout

	cret = C.gdk_toplevel_layout_new()

	ret1 = WrapToplevelLayout(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *ToplevelLayout) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Native returns the underlying C source pointer.
func (t *ToplevelLayout) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy: create a new ToplevelLayout and copy the contents of @layout into it.
func (l *ToplevelLayout) Copy() *ToplevelLayout {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var cret *C.GdkToplevelLayout
	var ret1 *ToplevelLayout

	cret = C.gdk_toplevel_layout_copy(arg0)

	ret1 = WrapToplevelLayout(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *ToplevelLayout) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Equal: check whether @layout and @other has identical layout properties.
func (l *ToplevelLayout) Equal(other *ToplevelLayout) bool {
	var arg0 *C.GdkToplevelLayout
	var arg1 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	arg1 = (*C.GdkToplevelLayout)(unsafe.Pointer(other.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_toplevel_layout_equal(arg0, other)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Fullscreen: if the layout specifies whether to the toplevel should go
// fullscreen, the value pointed to by @fullscreen is set to true if it should
// go fullscreen, or false, if it should go unfullscreen.
func (l *ToplevelLayout) Fullscreen() (fullscreen bool, ok bool) {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var arg1 C.gboolean
	var ret1 bool
	var cret C.gboolean
	var ret2 bool

	cret = C.gdk_toplevel_layout_get_fullscreen(arg0, &arg1)

	*ret1 = C.bool(arg1) != C.false
	ret2 = C.bool(cret) != C.false

	return ret1, ret2
}

// FullscreenMonitor returns the monitor that the layout is fullscreening the
// surface on.
func (l *ToplevelLayout) FullscreenMonitor() Monitor {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var cret *C.GdkMonitor
	var ret1 Monitor

	cret = C.gdk_toplevel_layout_get_fullscreen_monitor(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Monitor)

	return ret1
}

// Maximized: if the layout specifies whether to the toplevel should go
// maximized, the value pointed to by @maximized is set to true if it should go
// fullscreen, or false, if it should go unmaximized.
func (l *ToplevelLayout) Maximized() (maximized bool, ok bool) {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var arg1 C.gboolean
	var ret1 bool
	var cret C.gboolean
	var ret2 bool

	cret = C.gdk_toplevel_layout_get_maximized(arg0, &arg1)

	*ret1 = C.bool(arg1) != C.false
	ret2 = C.bool(cret) != C.false

	return ret1, ret2
}

// Resizable returns whether the layout should allow the user to resize the
// surface.
func (l *ToplevelLayout) Resizable() bool {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_toplevel_layout_get_resizable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Ref increases the reference count of @layout.
func (l *ToplevelLayout) Ref() *ToplevelLayout {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	var cret *C.GdkToplevelLayout
	var ret1 *ToplevelLayout

	cret = C.gdk_toplevel_layout_ref(arg0)

	ret1 = WrapToplevelLayout(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *ToplevelLayout) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// SetFullscreen sets whether the layout should cause the surface to be
// fullscreen when presented.
func (l *ToplevelLayout) SetFullscreen(fullscreen bool, monitor Monitor) {
	var arg0 *C.GdkToplevelLayout
	var arg1 C.gboolean
	var arg2 *C.GdkMonitor

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if fullscreen {
		arg1 = C.gboolean(1)
	}
	arg2 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

	C.gdk_toplevel_layout_set_fullscreen(arg0, fullscreen, monitor)
}

// SetMaximized sets whether the layout should cause the surface to be maximized
// when presented.
func (l *ToplevelLayout) SetMaximized(maximized bool) {
	var arg0 *C.GdkToplevelLayout
	var arg1 C.gboolean

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if maximized {
		arg1 = C.gboolean(1)
	}

	C.gdk_toplevel_layout_set_maximized(arg0, maximized)
}

// SetResizable sets whether the layout should allow the user to resize the
// surface after it has been presented.
func (l *ToplevelLayout) SetResizable(resizable bool) {
	var arg0 *C.GdkToplevelLayout
	var arg1 C.gboolean

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))
	if resizable {
		arg1 = C.gboolean(1)
	}

	C.gdk_toplevel_layout_set_resizable(arg0, resizable)
}

// Unref decreases the reference count of @layout.
func (l *ToplevelLayout) Unref() {
	var arg0 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevelLayout)(unsafe.Pointer(l.Native()))

	C.gdk_toplevel_layout_unref(arg0)
}
