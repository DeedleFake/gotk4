// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_cursor_get_type()), F: marshalCursor},
	})
}

// Cursor: `GdkCursor` is used to create and destroy cursors.
//
// Cursors are immutable objects, so once you created them, there is no way to
// modify them later. You should create a new cursor when you want to change
// something about it.
//
// Cursors by themselves are not very interesting: they must be bound to a
// window for users to see them. This is done with
// [method@Gdk.Surface.set_cursor] or [method@Gdk.Surface.set_device_cursor].
// Applications will typically use higher-level GTK functions such as
// [method@Gtk.Widget.set_cursor]` instead.
//
// Cursors are not bound to a given [class@Gdk.Display], so they can be shared.
// However, the appearance of cursors may vary when used on different platforms.
//
//
// Named and texture cursors
//
// There are multiple ways to create cursors. The platform's own cursors can be
// created with [ctor@Gdk.Cursor.new_from_name]. That function lists the
// commonly available names that are shared with the CSS specification. Other
// names may be available, depending on the platform in use. On some platforms,
// what images are used for named cursors may be influenced by the cursor theme.
//
// Another option to create a cursor is to use
// [ctor@Gdk.Cursor.new_from_texture] and provide an image to use for the
// cursor.
//
// To ease work with unsupported cursors, a fallback cursor can be provided. If
// a [class@Gdk.Surface] cannot use a cursor because of the reasons mentioned
// above, it will try the fallback cursor. Fallback cursors can themselves have
// fallback cursors again, so it is possible to provide a chain of progressively
// easier to support cursors. If none of the provided cursors can be supported,
// the default cursor will be the ultimate fallback.
type Cursor interface {
	gextras.Objector

	// Fallback:
	Fallback() Cursor
	// HotspotX:
	HotspotX() int
	// HotspotY:
	HotspotY() int
	// Name:
	Name() string
	// Texture:
	Texture() Texture
}

// cursor implements the Cursor class.
type cursor struct {
	gextras.Objector
}

// WrapCursor wraps a GObject to the right type. It is
// primarily used internally.
func WrapCursor(obj *externglib.Object) Cursor {
	return cursor{
		Objector: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCursor(obj), nil
}

// NewCursorFromName:
func NewCursorFromName(name string, fallback Cursor) Cursor {
	var _arg1 *C.char      // out
	var _arg2 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GdkCursor)(unsafe.Pointer(fallback.Native()))

	_cret = C.gdk_cursor_new_from_name(_arg1, _arg2)

	var _cursor Cursor // out

	_cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Cursor)

	return _cursor
}

// NewCursorFromTexture:
func NewCursorFromTexture(texture Texture, hotspotX int, hotspotY int, fallback Cursor) Cursor {
	var _arg1 *C.GdkTexture // out
	var _arg2 C.int         // out
	var _arg3 C.int         // out
	var _arg4 *C.GdkCursor  // out
	var _cret *C.GdkCursor  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = C.int(hotspotX)
	_arg3 = C.int(hotspotY)
	_arg4 = (*C.GdkCursor)(unsafe.Pointer(fallback.Native()))

	_cret = C.gdk_cursor_new_from_texture(_arg1, _arg2, _arg3, _arg4)

	var _cursor Cursor // out

	_cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Cursor)

	return _cursor
}

func (c cursor) Fallback() Cursor {
	var _arg0 *C.GdkCursor // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_fallback(_arg0)

	var _ret Cursor // out

	_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Cursor)

	return _ret
}

func (c cursor) HotspotX() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_hotspot_x(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (c cursor) HotspotY() int {
	var _arg0 *C.GdkCursor // out
	var _cret C.int        // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_hotspot_y(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (c cursor) Name() string {
	var _arg0 *C.GdkCursor // out
	var _cret *C.char      // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (c cursor) Texture() Texture {
	var _arg0 *C.GdkCursor  // out
	var _cret *C.GdkTexture // in

	_arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_cursor_get_texture(_arg0)

	var _texture Texture // out

	_texture = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Texture)

	return _texture
}
