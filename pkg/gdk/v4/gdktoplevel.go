// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_toplevel_get_type()), F: marshalToplevel},
	})
}

// Toplevel: a Toplevel is a freestanding toplevel surface.
//
// The Toplevel interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
type Toplevel interface {
	Surface

	// BeginMove begins an interactive move operation (for a toplevel surface).
	// You might use this function to implement draggable titlebars.
	BeginMove(device Device, button int, x float64, y float64, timestamp uint32)
	// BeginResize begins an interactive resize operation (for a toplevel
	// surface). You might use this function to implement a “window resize
	// grip.”
	BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32)
	// Focus sets keyboard focus to @surface.
	//
	// In most cases, gtk_window_present_with_time() should be used on a Window,
	// rather than calling this function.
	Focus(timestamp uint32)
	// State gets the bitwise OR of the currently active surface state flags,
	// from the ToplevelState enumeration.
	State() ToplevelState
	// InhibitSystemShortcuts requests that the @toplevel inhibit the system
	// shortcuts, asking the desktop environment/windowing system to let all
	// keyboard events reach the surface, as long as it is focused, instead of
	// triggering system actions.
	//
	// If granted, the rerouting remains active until the default shortcuts
	// processing is restored with gdk_toplevel_restore_system_shortcuts(), or
	// the request is revoked by the desktop environment, windowing system or
	// the user.
	//
	// A typical use case for this API is remote desktop or virtual machine
	// viewers which need to inhibit the default system keyboard shortcuts so
	// that the remote session or virtual host gets those instead of the local
	// environment.
	//
	// The windowing system or desktop environment may ask the user to grant or
	// deny the request or even choose to ignore the request entirely.
	//
	// The caller can be notified whenever the request is granted or revoked by
	// listening to the GdkToplevel::shortcuts-inhibited property.
	InhibitSystemShortcuts(event Event)
	// Lower asks to lower the @toplevel below other windows.
	//
	// The windowing system may choose to ignore the request.
	Lower() bool
	// Minimize asks to minimize the @toplevel.
	//
	// The windowing system may choose to ignore the request.
	Minimize() bool
	// Present: present @toplevel after having processed the ToplevelLayout
	// rules. If the toplevel was previously not showing, it will be showed,
	// otherwise it will change layout according to @layout.
	//
	// GDK may emit the 'compute-size' signal to let the user of this toplevel
	// compute the preferred size of the toplevel surface. See
	// Toplevel::compute-size for details.
	//
	// Presenting is asynchronous and the specified layout parameters are not
	// guaranteed to be respected.
	Present(layout *ToplevelLayout)
	// RestoreSystemShortcuts: restore default system keyboard shortcuts which
	// were previously requested to be inhibited by
	// gdk_toplevel_inhibit_system_shortcuts().
	RestoreSystemShortcuts()
	// SetDecorated: setting @decorated to false hints the desktop environment
	// that the surface has its own, client-side decorations and does not need
	// to have window decorations added.
	SetDecorated(decorated bool)
	// SetDeletable: setting @deletable to true hints the desktop environment
	// that it should offer the user a way to close the surface.
	SetDeletable(deletable bool)
	// SetIconList sets a list of icons for the surface.
	//
	// One of these will be used to represent the surface in iconic form. The
	// icon may be shown in window lists or task bars. Which icon size is shown
	// depends on the window manager. The window manager can scale the icon but
	// setting several size icons can give better image quality.
	//
	// Note that some platforms don't support surface icons.
	SetIconList(surfaces *glib.List)
	// SetModal: the application can use this hint to tell the window manager
	// that a certain surface has modal behaviour. The window manager can use
	// this information to handle modal surfaces in a special way.
	//
	// You should only use this on surfaces for which you have previously called
	// gdk_toplevel_set_transient_for().
	SetModal(modal bool)
	// SetStartupID: when using GTK, typically you should use
	// gtk_window_set_startup_id() instead of this low-level function.
	SetStartupID(startupId string)
	// SetTitle sets the title of a toplevel surface, to be displayed in the
	// titlebar, in lists of windows, etc.
	SetTitle(title string)
	// SetTransientFor indicates to the window manager that @surface is a
	// transient dialog associated with the application surface @parent. This
	// allows the window manager to do things like center @surface on @parent
	// and keep @surface above @parent.
	//
	// See gtk_window_set_transient_for() if you’re using Window or Dialog.
	SetTransientFor(parent Surface)
	// ShowWindowMenu asks the windowing system to show the window menu.
	//
	// The window menu is the menu shown when right-clicking the titlebar on
	// traditional windows managed by the window manager. This is useful for
	// windows using client-side decorations, activating it with a right-click
	// on the window decorations.
	ShowWindowMenu(event Event) bool
	// SupportsEdgeConstraints returns whether the desktop environment supports
	// tiled window states.
	SupportsEdgeConstraints() bool
}

// toplevel implements the Toplevel interface.
type toplevel struct {
	Surface
}

var _ Toplevel = (*toplevel)(nil)

// WrapToplevel wraps a GObject to a type that implements interface
// Toplevel. It is primarily used internally.
func WrapToplevel(obj *externglib.Object) Toplevel {
	return Toplevel{
		Surface: WrapSurface(obj),
	}
}

func marshalToplevel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToplevel(obj), nil
}

// BeginMove begins an interactive move operation (for a toplevel surface).
// You might use this function to implement draggable titlebars.
func (t toplevel) BeginMove(device Device, button int, x float64, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GdkDevice
	var _arg2 C.int
	var _arg3 C.double
	var _arg4 C.double
	var _arg5 C.guint32

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg2 = C.int(button)
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.guint32(timestamp)

	C.gdk_toplevel_begin_move(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

// BeginResize begins an interactive resize operation (for a toplevel
// surface). You might use this function to implement a “window resize
// grip.”
func (t toplevel) BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32) {
	var _arg0 *C.GdkToplevel
	var _arg1 C.GdkSurfaceEdge
	var _arg2 *C.GdkDevice
	var _arg3 C.int
	var _arg4 C.double
	var _arg5 C.double
	var _arg6 C.guint32

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (C.GdkSurfaceEdge)(edge)
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	_arg3 = C.int(button)
	_arg4 = C.double(x)
	_arg5 = C.double(y)
	_arg6 = C.guint32(timestamp)

	C.gdk_toplevel_begin_resize(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// Focus sets keyboard focus to @surface.
//
// In most cases, gtk_window_present_with_time() should be used on a Window,
// rather than calling this function.
func (t toplevel) Focus(timestamp uint32) {
	var _arg0 *C.GdkToplevel
	var _arg1 C.guint32

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = C.guint32(timestamp)

	C.gdk_toplevel_focus(_arg0, _arg1)
}

// State gets the bitwise OR of the currently active surface state flags,
// from the ToplevelState enumeration.
func (t toplevel) State() ToplevelState {
	var _arg0 *C.GdkToplevel

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	var _cret C.GdkToplevelState

	cret = C.gdk_toplevel_get_state(_arg0)

	var _toplevelState ToplevelState

	_toplevelState = ToplevelState(_cret)

	return _toplevelState
}

// InhibitSystemShortcuts requests that the @toplevel inhibit the system
// shortcuts, asking the desktop environment/windowing system to let all
// keyboard events reach the surface, as long as it is focused, instead of
// triggering system actions.
//
// If granted, the rerouting remains active until the default shortcuts
// processing is restored with gdk_toplevel_restore_system_shortcuts(), or
// the request is revoked by the desktop environment, windowing system or
// the user.
//
// A typical use case for this API is remote desktop or virtual machine
// viewers which need to inhibit the default system keyboard shortcuts so
// that the remote session or virtual host gets those instead of the local
// environment.
//
// The windowing system or desktop environment may ask the user to grant or
// deny the request or even choose to ignore the request entirely.
//
// The caller can be notified whenever the request is granted or revoked by
// listening to the GdkToplevel::shortcuts-inhibited property.
func (t toplevel) InhibitSystemShortcuts(event Event) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GdkEvent

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	C.gdk_toplevel_inhibit_system_shortcuts(_arg0, _arg1)
}

// Lower asks to lower the @toplevel below other windows.
//
// The windowing system may choose to ignore the request.
func (t toplevel) Lower() bool {
	var _arg0 *C.GdkToplevel

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	cret = C.gdk_toplevel_lower(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Minimize asks to minimize the @toplevel.
//
// The windowing system may choose to ignore the request.
func (t toplevel) Minimize() bool {
	var _arg0 *C.GdkToplevel

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	cret = C.gdk_toplevel_minimize(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// Present: present @toplevel after having processed the ToplevelLayout
// rules. If the toplevel was previously not showing, it will be showed,
// otherwise it will change layout according to @layout.
//
// GDK may emit the 'compute-size' signal to let the user of this toplevel
// compute the preferred size of the toplevel surface. See
// Toplevel::compute-size for details.
//
// Presenting is asynchronous and the specified layout parameters are not
// guaranteed to be respected.
func (t toplevel) Present(layout *ToplevelLayout) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GdkToplevelLayout

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkToplevelLayout)(unsafe.Pointer(layout.Native()))

	C.gdk_toplevel_present(_arg0, _arg1)
}

// RestoreSystemShortcuts: restore default system keyboard shortcuts which
// were previously requested to be inhibited by
// gdk_toplevel_inhibit_system_shortcuts().
func (t toplevel) RestoreSystemShortcuts() {
	var _arg0 *C.GdkToplevel

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	C.gdk_toplevel_restore_system_shortcuts(_arg0)
}

// SetDecorated: setting @decorated to false hints the desktop environment
// that the surface has its own, client-side decorations and does not need
// to have window decorations added.
func (t toplevel) SetDecorated(decorated bool) {
	var _arg0 *C.GdkToplevel
	var _arg1 C.gboolean

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if decorated {
		_arg1 = C.gboolean(1)
	}

	C.gdk_toplevel_set_decorated(_arg0, _arg1)
}

// SetDeletable: setting @deletable to true hints the desktop environment
// that it should offer the user a way to close the surface.
func (t toplevel) SetDeletable(deletable bool) {
	var _arg0 *C.GdkToplevel
	var _arg1 C.gboolean

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if deletable {
		_arg1 = C.gboolean(1)
	}

	C.gdk_toplevel_set_deletable(_arg0, _arg1)
}

// SetIconList sets a list of icons for the surface.
//
// One of these will be used to represent the surface in iconic form. The
// icon may be shown in window lists or task bars. Which icon size is shown
// depends on the window manager. The window manager can scale the icon but
// setting several size icons can give better image quality.
//
// Note that some platforms don't support surface icons.
func (t toplevel) SetIconList(surfaces *glib.List) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GList

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GList)(unsafe.Pointer(surfaces.Native()))

	C.gdk_toplevel_set_icon_list(_arg0, _arg1)
}

// SetModal: the application can use this hint to tell the window manager
// that a certain surface has modal behaviour. The window manager can use
// this information to handle modal surfaces in a special way.
//
// You should only use this on surfaces for which you have previously called
// gdk_toplevel_set_transient_for().
func (t toplevel) SetModal(modal bool) {
	var _arg0 *C.GdkToplevel
	var _arg1 C.gboolean

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	if modal {
		_arg1 = C.gboolean(1)
	}

	C.gdk_toplevel_set_modal(_arg0, _arg1)
}

// SetStartupID: when using GTK, typically you should use
// gtk_window_set_startup_id() instead of this low-level function.
func (t toplevel) SetStartupID(startupId string) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.char

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(startupId))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_startup_id(_arg0, _arg1)
}

// SetTitle sets the title of a toplevel surface, to be displayed in the
// titlebar, in lists of windows, etc.
func (t toplevel) SetTitle(title string) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.char

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.char)(C.CString(title))
	defer C.free(unsafe.Pointer(_arg1))

	C.gdk_toplevel_set_title(_arg0, _arg1)
}

// SetTransientFor indicates to the window manager that @surface is a
// transient dialog associated with the application surface @parent. This
// allows the window manager to do things like center @surface on @parent
// and keep @surface above @parent.
//
// See gtk_window_set_transient_for() if you’re using Window or Dialog.
func (t toplevel) SetTransientFor(parent Surface) {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GdkSurface

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(parent.Native()))

	C.gdk_toplevel_set_transient_for(_arg0, _arg1)
}

// ShowWindowMenu asks the windowing system to show the window menu.
//
// The window menu is the menu shown when right-clicking the titlebar on
// traditional windows managed by the window manager. This is useful for
// windows using client-side decorations, activating it with a right-click
// on the window decorations.
func (t toplevel) ShowWindowMenu(event Event) bool {
	var _arg0 *C.GdkToplevel
	var _arg1 *C.GdkEvent

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	var _cret C.gboolean

	cret = C.gdk_toplevel_show_window_menu(_arg0, _arg1)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}

// SupportsEdgeConstraints returns whether the desktop environment supports
// tiled window states.
func (t toplevel) SupportsEdgeConstraints() bool {
	var _arg0 *C.GdkToplevel

	_arg0 = (*C.GdkToplevel)(unsafe.Pointer(t.Native()))

	var _cret C.gboolean

	cret = C.gdk_toplevel_supports_edge_constraints(_arg0)

	var _ok bool

	if _cret {
		_ok = true
	}

	return _ok
}
