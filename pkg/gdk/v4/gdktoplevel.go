// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_toplevel_get_type()), F: marshalToplevel},
	})
}

// Toplevel: a `GdkToplevel` is a freestanding toplevel surface.
//
// The `GdkToplevel` interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
type Toplevel interface {
	Surface

	// BeginMove begins an interactive move operation.
	//
	// You might use this function to implement draggable titlebars.
	BeginMove(device Device, button int, x float64, y float64, timestamp uint32)
	// BeginResize begins an interactive resize operation.
	//
	// You might use this function to implement a “window resize grip.”
	BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32)
	// Focus sets keyboard focus to @surface.
	//
	// In most cases, [method@Gtk.Window.present_with_time] should be used on a
	// [class@Gtk.Window], rather than calling this function.
	Focus(timestamp uint32)
	// State gets the bitwise or of the currently active surface state flags,
	// from the `GdkToplevelState` enumeration.
	State() ToplevelState
	// InhibitSystemShortcuts requests that the @toplevel inhibit the system
	// shortcuts.
	//
	// This is asking the desktop environment/windowing system to let all
	// keyboard events reach the surface, as long as it is focused, instead of
	// triggering system actions.
	//
	// If granted, the rerouting remains active until the default shortcuts
	// processing is restored with
	// [method@Gdk.Toplevel.restore_system_shortcuts], or the request is revoked
	// by the desktop environment, windowing system or the user.
	//
	// A typical use case for this API is remote desktop or virtual machine
	// viewers which need to inhibit the default system keyboard shortcuts so
	// that the remote session or virtual host gets those instead of the local
	// environment.
	//
	// The windowing system or desktop environment may ask the user to grant or
	// deny the request or even choose to ignore the request entirely.
	//
	// The caller can be notified whenever the request is granted or revoked by
	// listening to the [property@Gdk.Toplevel:shortcuts-inhibited] property.
	InhibitSystemShortcuts(event Event)
	// Lower asks to lower the @toplevel below other windows.
	//
	// The windowing system may choose to ignore the request.
	Lower() bool
	// Minimize asks to minimize the @toplevel.
	//
	// The windowing system may choose to ignore the request.
	Minimize() bool
	// Present: present @toplevel after having processed the `GdkToplevelLayout`
	// rules.
	//
	// If the toplevel was previously not showing, it will be showed, otherwise
	// it will change layout according to @layout.
	//
	// GDK may emit the [signal@Gdk.Toplevel::compute-size] signal to let the
	// user of this toplevel compute the preferred size of the toplevel surface.
	//
	// Presenting is asynchronous and the specified layout parameters are not
	// guaranteed to be respected.
	Present(layout *ToplevelLayout)
	// RestoreSystemShortcuts: restore default system keyboard shortcuts which
	// were previously inhibited.
	//
	// This undoes the effect of [method@Gdk.Toplevel.inhibit_system_shortcuts].
	RestoreSystemShortcuts()
	// SetDecorated sets the toplevel to be decorated.
	//
	// Setting @decorated to false hints the desktop environment that the
	// surface has its own, client-side decorations and does not need to have
	// window decorations added.
	SetDecorated(decorated bool)
	// SetDeletable sets the toplevel to be deletable.
	//
	// Setting @deletable to true hints the desktop environment that it should
	// offer the user a way to close the surface.
	SetDeletable(deletable bool)
	// SetIconList sets a list of icons for the surface.
	//
	// One of these will be used to represent the surface in iconic form. The
	// icon may be shown in window lists or task bars. Which icon size is shown
	// depends on the window manager. The window manager can scale the icon but
	// setting several size icons can give better image quality.
	//
	// Note that some platforms don't support surface icons.
	SetIconList(surfaces *glib.List)
	// SetModal sets the toplevel to be modal.
	//
	// The application can use this hint to tell the window manager that a
	// certain surface has modal behaviour. The window manager can use this
	// information to handle modal surfaces in a special way.
	//
	// You should only use this on surfaces for which you have previously called
	// [method@Gdk.Toplevel.set_transient_for].
	SetModal(modal bool)
	// SetStartupID sets the startup notification ID.
	//
	// When using GTK, typically you should use
	// [method@Gtk.Window.set_startup_id] instead of this low-level function.
	SetStartupID(startupID string)
	// SetTitle sets the title of a toplevel surface.
	//
	// The title maybe be displayed in the titlebar, in lists of windows, etc.
	SetTitle(title string)
	// SetTransientFor sets a transient-for parent.
	//
	// Indicates to the window manager that @surface is a transient dialog
	// associated with the application surface @parent. This allows the window
	// manager to do things like center @surface on @parent and keep @surface
	// above @parent.
	//
	// See [method@Gtk.Window.set_transient_for] if you’re using
	// [class@Gtk.Window] or [class@Gtk.Dialog].
	SetTransientFor(parent Surface)
	// ShowWindowMenu asks the windowing system to show the window menu.
	//
	// The window menu is the menu shown when right-clicking the titlebar on
	// traditional windows managed by the window manager. This is useful for
	// windows using client-side decorations, activating it with a right-click
	// on the window decorations.
	ShowWindowMenu(event Event) bool
	// SupportsEdgeConstraints returns whether the desktop environment supports
	// tiled window states.
	SupportsEdgeConstraints() bool
}

// toplevel implements the Toplevel interface.
type toplevel struct {
	Surface
}

var _ Toplevel = (*toplevel)(nil)

// WrapToplevel wraps a GObject to a type that implements interface
// Toplevel. It is primarily used internally.
func WrapToplevel(obj *externglib.Object) Toplevel {
	return Toplevel{
		Surface: WrapSurface(obj),
	}
}

func marshalToplevel(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapToplevel(obj), nil
}

// BeginMove begins an interactive move operation.
//
// You might use this function to implement draggable titlebars.
func (t toplevel) BeginMove(device Device, button int, x float64, y float64, timestamp uint32) {
	var arg0 *C.GdkToplevel
	var arg1 *C.GdkDevice
	var arg2 C.int
	var arg3 C.double
	var arg4 C.double
	var arg5 C.guint32

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GdkDevice)(device.Native())
	arg2 = C.int(button)
	arg3 = C.double(x)
	arg4 = C.double(y)
	arg5 = C.guint32(timestamp)

	C.gdk_toplevel_begin_move(arg0, arg1, arg2, arg3, arg4, arg5)
}

// BeginResize begins an interactive resize operation.
//
// You might use this function to implement a “window resize grip.”
func (t toplevel) BeginResize(edge SurfaceEdge, device Device, button int, x float64, y float64, timestamp uint32) {
	var arg0 *C.GdkToplevel
	var arg1 C.GdkSurfaceEdge
	var arg2 *C.GdkDevice
	var arg3 C.int
	var arg4 C.double
	var arg5 C.double
	var arg6 C.guint32

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (C.GdkSurfaceEdge)(edge)
	arg2 = (*C.GdkDevice)(device.Native())
	arg3 = C.int(button)
	arg4 = C.double(x)
	arg5 = C.double(y)
	arg6 = C.guint32(timestamp)

	C.gdk_toplevel_begin_resize(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
}

// Focus sets keyboard focus to @surface.
//
// In most cases, [method@Gtk.Window.present_with_time] should be used on a
// [class@Gtk.Window], rather than calling this function.
func (t toplevel) Focus(timestamp uint32) {
	var arg0 *C.GdkToplevel
	var arg1 C.guint32

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = C.guint32(timestamp)

	C.gdk_toplevel_focus(arg0, arg1)
}

// State gets the bitwise or of the currently active surface state flags,
// from the `GdkToplevelState` enumeration.
func (t toplevel) State() ToplevelState {
	var arg0 *C.GdkToplevel

	arg0 = (*C.GdkToplevel)(t.Native())

	ret := C.gdk_toplevel_get_state(arg0)

	var ret0 ToplevelState

	ret0 = ToplevelState(ret)

	return ret0
}

// InhibitSystemShortcuts requests that the @toplevel inhibit the system
// shortcuts.
//
// This is asking the desktop environment/windowing system to let all
// keyboard events reach the surface, as long as it is focused, instead of
// triggering system actions.
//
// If granted, the rerouting remains active until the default shortcuts
// processing is restored with
// [method@Gdk.Toplevel.restore_system_shortcuts], or the request is revoked
// by the desktop environment, windowing system or the user.
//
// A typical use case for this API is remote desktop or virtual machine
// viewers which need to inhibit the default system keyboard shortcuts so
// that the remote session or virtual host gets those instead of the local
// environment.
//
// The windowing system or desktop environment may ask the user to grant or
// deny the request or even choose to ignore the request entirely.
//
// The caller can be notified whenever the request is granted or revoked by
// listening to the [property@Gdk.Toplevel:shortcuts-inhibited] property.
func (t toplevel) InhibitSystemShortcuts(event Event) {
	var arg0 *C.GdkToplevel
	var arg1 *C.GdkEvent

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GdkEvent)(event.Native())

	C.gdk_toplevel_inhibit_system_shortcuts(arg0, arg1)
}

// Lower asks to lower the @toplevel below other windows.
//
// The windowing system may choose to ignore the request.
func (t toplevel) Lower() bool {
	var arg0 *C.GdkToplevel

	arg0 = (*C.GdkToplevel)(t.Native())

	ret := C.gdk_toplevel_lower(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Minimize asks to minimize the @toplevel.
//
// The windowing system may choose to ignore the request.
func (t toplevel) Minimize() bool {
	var arg0 *C.GdkToplevel

	arg0 = (*C.GdkToplevel)(t.Native())

	ret := C.gdk_toplevel_minimize(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// Present: present @toplevel after having processed the `GdkToplevelLayout`
// rules.
//
// If the toplevel was previously not showing, it will be showed, otherwise
// it will change layout according to @layout.
//
// GDK may emit the [signal@Gdk.Toplevel::compute-size] signal to let the
// user of this toplevel compute the preferred size of the toplevel surface.
//
// Presenting is asynchronous and the specified layout parameters are not
// guaranteed to be respected.
func (t toplevel) Present(layout *ToplevelLayout) {
	var arg0 *C.GdkToplevel
	var arg1 *C.GdkToplevelLayout

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GdkToplevelLayout)(layout.Native())

	C.gdk_toplevel_present(arg0, arg1)
}

// RestoreSystemShortcuts: restore default system keyboard shortcuts which
// were previously inhibited.
//
// This undoes the effect of [method@Gdk.Toplevel.inhibit_system_shortcuts].
func (t toplevel) RestoreSystemShortcuts() {
	var arg0 *C.GdkToplevel

	arg0 = (*C.GdkToplevel)(t.Native())

	C.gdk_toplevel_restore_system_shortcuts(arg0)
}

// SetDecorated sets the toplevel to be decorated.
//
// Setting @decorated to false hints the desktop environment that the
// surface has its own, client-side decorations and does not need to have
// window decorations added.
func (t toplevel) SetDecorated(decorated bool) {
	var arg0 *C.GdkToplevel
	var arg1 C.gboolean

	arg0 = (*C.GdkToplevel)(t.Native())
	if decorated {
		arg1 = C.TRUE
	}

	C.gdk_toplevel_set_decorated(arg0, arg1)
}

// SetDeletable sets the toplevel to be deletable.
//
// Setting @deletable to true hints the desktop environment that it should
// offer the user a way to close the surface.
func (t toplevel) SetDeletable(deletable bool) {
	var arg0 *C.GdkToplevel
	var arg1 C.gboolean

	arg0 = (*C.GdkToplevel)(t.Native())
	if deletable {
		arg1 = C.TRUE
	}

	C.gdk_toplevel_set_deletable(arg0, arg1)
}

// SetIconList sets a list of icons for the surface.
//
// One of these will be used to represent the surface in iconic form. The
// icon may be shown in window lists or task bars. Which icon size is shown
// depends on the window manager. The window manager can scale the icon but
// setting several size icons can give better image quality.
//
// Note that some platforms don't support surface icons.
func (t toplevel) SetIconList(surfaces *glib.List) {
	var arg0 *C.GdkToplevel
	var arg1 *C.GList

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GList)(surfaces.Native())

	C.gdk_toplevel_set_icon_list(arg0, arg1)
}

// SetModal sets the toplevel to be modal.
//
// The application can use this hint to tell the window manager that a
// certain surface has modal behaviour. The window manager can use this
// information to handle modal surfaces in a special way.
//
// You should only use this on surfaces for which you have previously called
// [method@Gdk.Toplevel.set_transient_for].
func (t toplevel) SetModal(modal bool) {
	var arg0 *C.GdkToplevel
	var arg1 C.gboolean

	arg0 = (*C.GdkToplevel)(t.Native())
	if modal {
		arg1 = C.TRUE
	}

	C.gdk_toplevel_set_modal(arg0, arg1)
}

// SetStartupID sets the startup notification ID.
//
// When using GTK, typically you should use
// [method@Gtk.Window.set_startup_id] instead of this low-level function.
func (t toplevel) SetStartupID(startupID string) {
	var arg0 *C.GdkToplevel
	var arg1 *C.char

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_toplevel_set_startup_id(arg0, arg1)
}

// SetTitle sets the title of a toplevel surface.
//
// The title maybe be displayed in the titlebar, in lists of windows, etc.
func (t toplevel) SetTitle(title string) {
	var arg0 *C.GdkToplevel
	var arg1 *C.char

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_toplevel_set_title(arg0, arg1)
}

// SetTransientFor sets a transient-for parent.
//
// Indicates to the window manager that @surface is a transient dialog
// associated with the application surface @parent. This allows the window
// manager to do things like center @surface on @parent and keep @surface
// above @parent.
//
// See [method@Gtk.Window.set_transient_for] if you’re using
// [class@Gtk.Window] or [class@Gtk.Dialog].
func (t toplevel) SetTransientFor(parent Surface) {
	var arg0 *C.GdkToplevel
	var arg1 *C.GdkSurface

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GdkSurface)(parent.Native())

	C.gdk_toplevel_set_transient_for(arg0, arg1)
}

// ShowWindowMenu asks the windowing system to show the window menu.
//
// The window menu is the menu shown when right-clicking the titlebar on
// traditional windows managed by the window manager. This is useful for
// windows using client-side decorations, activating it with a right-click
// on the window decorations.
func (t toplevel) ShowWindowMenu(event Event) bool {
	var arg0 *C.GdkToplevel
	var arg1 *C.GdkEvent

	arg0 = (*C.GdkToplevel)(t.Native())
	arg1 = (*C.GdkEvent)(event.Native())

	ret := C.gdk_toplevel_show_window_menu(arg0, arg1)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}

// SupportsEdgeConstraints returns whether the desktop environment supports
// tiled window states.
func (t toplevel) SupportsEdgeConstraints() bool {
	var arg0 *C.GdkToplevel

	arg0 = (*C.GdkToplevel)(t.Native())

	ret := C.gdk_toplevel_supports_edge_constraints(arg0)

	var ret0 bool

	ret0 = C.bool(ret) != C.false

	return ret0
}
