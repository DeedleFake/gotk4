// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf"
	"github.com/diamondburned/gotk4/pkg/gdkx11"
	"github.com/diamondburned/gotk4/pkg/gio"
	"github.com/diamondburned/gotk4/pkg/glib"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		// Enums
		{T: externglib.Type(C.gdk_axis_use_get_type()), F: marshalAxisUse},
		{T: externglib.Type(C.gdk_crossing_mode_get_type()), F: marshalCrossingMode},
		{T: externglib.Type(C.gdk_device_pad_feature_get_type()), F: marshalDevicePadFeature},
		{T: externglib.Type(C.gdk_device_tool_type_get_type()), F: marshalDeviceToolType},
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_event_type_get_type()), F: marshalEventType},
		{T: externglib.Type(C.gdk_fullscreen_mode_get_type()), F: marshalFullscreenMode},
		{T: externglib.Type(C.gdk_gl_error_get_type()), F: marshalGLError},
		{T: externglib.Type(C.gdk_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.gdk_input_source_get_type()), F: marshalInputSource},
		{T: externglib.Type(C.gdk_key_match_get_type()), F: marshalKeyMatch},
		{T: externglib.Type(C.gdk_memory_format_get_type()), F: marshalMemoryFormat},
		{T: externglib.Type(C.gdk_notify_type_get_type()), F: marshalNotifyType},
		{T: externglib.Type(C.gdk_scroll_direction_get_type()), F: marshalScrollDirection},
		{T: externglib.Type(C.gdk_subpixel_layout_get_type()), F: marshalSubpixelLayout},
		{T: externglib.Type(C.gdk_surface_edge_get_type()), F: marshalSurfaceEdge},
		{T: externglib.Type(C.gdk_touchpad_gesture_phase_get_type()), F: marshalTouchpadGesturePhase},
		{T: externglib.Type(C.gdk_vulkan_error_get_type()), F: marshalVulkanError},

		// Records
		{T: externglib.Type(C.gdk_content_formats_get_type()), F: marshalContentFormats},
		{T: externglib.Type(C.gdk_content_formats_builder_get_type()), F: marshalContentFormatsBuilder},
		// Skipped ContentProviderClass.
		// Skipped DevicePadInterface.
		// Skipped DragSurfaceInterface.
		// Skipped DrawingContext.
		{T: externglib.Type(C.gdk_event_sequence_get_type()), F: marshalEventSequence},
		// Skipped FrameClockClass.
		// Skipped FrameClockPrivate.
		{T: externglib.Type(C.gdk_frame_timings_get_type()), F: marshalFrameTimings},
		// Skipped GLTextureClass.
		// Skipped KeymapKey.
		// Skipped MemoryTextureClass.
		// Skipped MonitorClass.
		// Skipped PaintableInterface.
		// Skipped PopupInterface.
		{T: externglib.Type(C.gdk_popup_layout_get_type()), F: marshalPopupLayout},
		{T: externglib.Type(C.gdk_rgba_get_type()), F: marshalRGBA},
		{T: externglib.Type(C.gdk_rectangle_get_type()), F: marshalRectangle},
		// Skipped SnapshotClass.
		// Skipped SurfaceClass.
		// Skipped TextureClass.
		// Skipped TimeCoord.
		// Skipped ToplevelInterface.
		{T: externglib.Type(C.gdk_toplevel_layout_get_type()), F: marshalToplevelLayout},
		// Skipped ToplevelSize.

		// Classes
		{T: externglib.Type(C.gdk_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.gdk_button_event_get_type()), F: marshalButtonEvent},
		{T: externglib.Type(C.gdk_cairo_context_get_type()), F: marshalCairoContext},
		{T: externglib.Type(C.gdk_clipboard_get_type()), F: marshalClipboard},
		{T: externglib.Type(C.gdk_content_deserializer_get_type()), F: marshalContentDeserializer},
		{T: externglib.Type(C.gdk_content_provider_get_type()), F: marshalContentProvider},
		{T: externglib.Type(C.gdk_content_serializer_get_type()), F: marshalContentSerializer},
		{T: externglib.Type(C.gdk_crossing_event_get_type()), F: marshalCrossingEvent},
		{T: externglib.Type(C.gdk_cursor_get_type()), F: marshalCursor},
		{T: externglib.Type(C.gdk_dnd_event_get_type()), F: marshalDNDEvent},
		{T: externglib.Type(C.gdk_delete_event_get_type()), F: marshalDeleteEvent},
		{T: externglib.Type(C.gdk_device_get_type()), F: marshalDevice},
		{T: externglib.Type(C.gdk_device_tool_get_type()), F: marshalDeviceTool},
		{T: externglib.Type(C.gdk_display_get_type()), F: marshalDisplay},
		{T: externglib.Type(C.gdk_display_manager_get_type()), F: marshalDisplayManager},
		{T: externglib.Type(C.gdk_drag_get_type()), F: marshalDrag},
		{T: externglib.Type(C.gdk_draw_context_get_type()), F: marshalDrawContext},
		{T: externglib.Type(C.gdk_drop_get_type()), F: marshalDrop},
		// Skipped Event.
		{T: externglib.Type(C.gdk_focus_event_get_type()), F: marshalFocusEvent},
		{T: externglib.Type(C.gdk_frame_clock_get_type()), F: marshalFrameClock},
		{T: externglib.Type(C.gdk_gl_context_get_type()), F: marshalGLContext},
		{T: externglib.Type(C.gdk_gl_texture_get_type()), F: marshalGLTexture},
		{T: externglib.Type(C.gdk_grab_broken_event_get_type()), F: marshalGrabBrokenEvent},
		{T: externglib.Type(C.gdk_key_event_get_type()), F: marshalKeyEvent},
		{T: externglib.Type(C.gdk_memory_texture_get_type()), F: marshalMemoryTexture},
		{T: externglib.Type(C.gdk_monitor_get_type()), F: marshalMonitor},
		{T: externglib.Type(C.gdk_motion_event_get_type()), F: marshalMotionEvent},
		{T: externglib.Type(C.gdk_pad_event_get_type()), F: marshalPadEvent},
		{T: externglib.Type(C.gdk_proximity_event_get_type()), F: marshalProximityEvent},
		{T: externglib.Type(C.gdk_scroll_event_get_type()), F: marshalScrollEvent},
		{T: externglib.Type(C.gdk_seat_get_type()), F: marshalSeat},
		{T: externglib.Type(C.gdk_snapshot_get_type()), F: marshalSnapshot},
		{T: externglib.Type(C.gdk_surface_get_type()), F: marshalSurface},
		{T: externglib.Type(C.gdk_texture_get_type()), F: marshalTexture},
		{T: externglib.Type(C.gdk_touch_event_get_type()), F: marshalTouchEvent},
		{T: externglib.Type(C.gdk_touchpad_event_get_type()), F: marshalTouchpadEvent},
		{T: externglib.Type(C.gdk_vulkan_context_get_type()), F: marshalVulkanContext},
	})
}

// AxisUse: an enumeration describing the way in which a device axis (valuator)
// maps onto the predefined valuator types that GTK understands.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse int

const (
	// AxisUseIgnore: the axis is ignored.
	AxisUseIgnore AxisUse = 0
	// AxisUseX: the axis is used as the x axis.
	AxisUseX AxisUse = 1
	// AxisUseY: the axis is used as the y axis.
	AxisUseY AxisUse = 2
	// AxisUseDeltaX: the axis is used as the scroll x delta
	AxisUseDeltaX AxisUse = 3
	// AxisUseDeltaY: the axis is used as the scroll y delta
	AxisUseDeltaY AxisUse = 4
	// AxisUsePressure: the axis is used for pressure information.
	AxisUsePressure AxisUse = 5
	// AxisUseXtilt: the axis is used for x tilt information.
	AxisUseXtilt AxisUse = 6
	// AxisUseYtilt: the axis is used for y tilt information.
	AxisUseYtilt AxisUse = 7
	// AxisUseWheel: the axis is used for wheel information.
	AxisUseWheel AxisUse = 8
	// AxisUseDistance: the axis is used for pen/tablet distance information
	AxisUseDistance AxisUse = 9
	// AxisUseRotation: the axis is used for pen rotation information
	AxisUseRotation AxisUse = 10
	// AxisUseSlider: the axis is used for pen slider information
	AxisUseSlider AxisUse = 11
	// AxisUseLast: a constant equal to the numerically highest axis value.
	AxisUseLast AxisUse = 12
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CrossingMode: specifies the crossing mode for enter and leave events.
type CrossingMode int

const (
	// CrossingModeNormal: crossing because of pointer motion.
	CrossingModeNormal CrossingMode = 0
	// CrossingModeGrab: crossing because a grab is activated.
	CrossingModeGrab CrossingMode = 1
	// CrossingModeUngrab: crossing because a grab is deactivated.
	CrossingModeUngrab CrossingMode = 2
	// CrossingModeGTKGrab: crossing because a GTK grab is activated.
	CrossingModeGTKGrab CrossingMode = 3
	// CrossingModeGTKUngrab: crossing because a GTK grab is deactivated.
	CrossingModeGTKUngrab CrossingMode = 4
	// CrossingModeStateChanged: crossing because a GTK widget changed state
	// (e.g. sensitivity).
	CrossingModeStateChanged CrossingMode = 5
	// CrossingModeTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchBegin CrossingMode = 6
	// CrossingModeTouchEnd: crossing because a touch sequence has ended, this
	// event is synthetic as the pointer might have not left the surface.
	CrossingModeTouchEnd CrossingMode = 7
	// CrossingModeDeviceSwitch: crossing because of a device switch (i.e. a
	// mouse taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didn’t leave the surface.
	CrossingModeDeviceSwitch CrossingMode = 8
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DevicePadFeature: a pad feature.
type DevicePadFeature int

const (
	// DevicePadFeatureButton: a button
	DevicePadFeatureButton DevicePadFeature = 0
	// DevicePadFeatureRing: a ring-shaped interactive area
	DevicePadFeatureRing DevicePadFeature = 1
	// DevicePadFeatureStrip: a straight interactive area
	DevicePadFeatureStrip DevicePadFeature = 2
)

func marshalDevicePadFeature(p uintptr) (interface{}, error) {
	return DevicePadFeature(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeviceToolType: indicates the specific type of tool being used being a
// tablet. Such as an airbrush, pencil, etc.
type DeviceToolType int

const (
	// DeviceToolTypeUnknown: tool is of an unknown type.
	DeviceToolTypeUnknown DeviceToolType = 0
	// DeviceToolTypePen: tool is a standard tablet stylus.
	DeviceToolTypePen DeviceToolType = 1
	// DeviceToolTypeEraser: tool is standard tablet eraser.
	DeviceToolTypeEraser DeviceToolType = 2
	// DeviceToolTypeBrush: tool is a brush stylus.
	DeviceToolTypeBrush DeviceToolType = 3
	// DeviceToolTypePencil: tool is a pencil stylus.
	DeviceToolTypePencil DeviceToolType = 4
	// DeviceToolTypeAirbrush: tool is an airbrush stylus.
	DeviceToolTypeAirbrush DeviceToolType = 5
	// DeviceToolTypeMouse: tool is a mouse.
	DeviceToolTypeMouse DeviceToolType = 6
	// DeviceToolTypeLens: tool is a lens cursor.
	DeviceToolTypeLens DeviceToolType = 7
)

func marshalDeviceToolType(p uintptr) (interface{}, error) {
	return DeviceToolType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragCancelReason: used in Drag to the reason of a cancelled DND operation.
type DragCancelReason int

const (
	// DragCancelReasonNoTarget: there is no suitable drop target.
	DragCancelReasonNoTarget DragCancelReason = 0
	// DragCancelReasonUserCancelled: drag cancelled by the user
	DragCancelReasonUserCancelled DragCancelReason = 1
	// DragCancelReasonError: unspecified error.
	DragCancelReasonError DragCancelReason = 2
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventType: specifies the type of the event.
type EventType int

const (
	// EventTypeDelete: the window manager has requested that the toplevel
	// surface be hidden or destroyed, usually when the user clicks on a special
	// icon in the title bar.
	EventTypeDelete EventType = 0
	// EventTypeMotionNotify: the pointer (usually a mouse) has moved.
	EventTypeMotionNotify EventType = 1
	// EventTypeButtonPress: a mouse button has been pressed.
	EventTypeButtonPress EventType = 2
	// EventTypeButtonRelease: a mouse button has been released.
	EventTypeButtonRelease EventType = 3
	// EventTypeKeyPress: a key has been pressed.
	EventTypeKeyPress EventType = 4
	// EventTypeKeyRelease: a key has been released.
	EventTypeKeyRelease EventType = 5
	// EventTypeEnterNotify: the pointer has entered the surface.
	EventTypeEnterNotify EventType = 6
	// EventTypeLeaveNotify: the pointer has left the surface.
	EventTypeLeaveNotify EventType = 7
	// EventTypeFocusChange: the keyboard focus has entered or left the surface.
	EventTypeFocusChange EventType = 8
	// EventTypeProximityIn: an input device has moved into contact with a
	// sensing surface (e.g. a touchscreen or graphics tablet).
	EventTypeProximityIn EventType = 9
	// EventTypeProximityOut: an input device has moved out of contact with a
	// sensing surface.
	EventTypeProximityOut EventType = 10
	// EventTypeDragEnter: the mouse has entered the surface while a drag is in
	// progress.
	EventTypeDragEnter EventType = 11
	// EventTypeDragLeave: the mouse has left the surface while a drag is in
	// progress.
	EventTypeDragLeave EventType = 12
	// EventTypeDragMotion: the mouse has moved in the surface while a drag is
	// in progress.
	EventTypeDragMotion EventType = 13
	// EventTypeDropStart: a drop operation onto the surface has started.
	EventTypeDropStart EventType = 14
	// EventTypeScroll: the scroll wheel was turned
	EventTypeScroll EventType = 15
	// EventTypeGrabBroken: a pointer or keyboard grab was broken.
	EventTypeGrabBroken EventType = 16
	// EventTypeTouchBegin: a new touch event sequence has just started.
	EventTypeTouchBegin EventType = 17
	// EventTypeTouchUpdate: a touch event sequence has been updated.
	EventTypeTouchUpdate EventType = 18
	// EventTypeTouchEnd: a touch event sequence has finished.
	EventTypeTouchEnd EventType = 19
	// EventTypeTouchCancel: a touch event sequence has been canceled.
	EventTypeTouchCancel EventType = 20
	// EventTypeTouchpadSwipe: a touchpad swipe gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadSwipe EventType = 21
	// EventTypeTouchpadPinch: a touchpad pinch gesture event, the current state
	// is determined by its phase field.
	EventTypeTouchpadPinch EventType = 22
	// EventTypePadButtonPress: a tablet pad button press event.
	EventTypePadButtonPress EventType = 23
	// EventTypePadButtonRelease: a tablet pad button release event.
	EventTypePadButtonRelease EventType = 24
	// EventTypePadRing: a tablet pad axis event from a "ring".
	EventTypePadRing EventType = 25
	// EventTypePadStrip: a tablet pad axis event from a "strip".
	EventTypePadStrip EventType = 26
	// EventTypePadGroupMode: a tablet pad group mode change.
	EventTypePadGroupMode EventType = 27
	// EventTypeEventLast: marks the end of the GdkEventType enumeration.
	EventTypeEventLast EventType = 28
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FullscreenMode: indicates which monitor (in a multi-head setup) a surface
// should span over when in fullscreen mode.
type FullscreenMode int

const (
	// FullscreenModeCurrentMonitor: fullscreen on current monitor only.
	FullscreenModeCurrentMonitor FullscreenMode = 0
	// FullscreenModeAllMonitors: span across all monitors when fullscreen.
	FullscreenModeAllMonitors FullscreenMode = 1
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLError: error enumeration for GLContext.
type GLError int

const (
	// GLErrorNotAvailable: openGL support is not available
	GLErrorNotAvailable GLError = 0
	// GLErrorUnsupportedFormat: the requested visual format is not supported
	GLErrorUnsupportedFormat GLError = 1
	// GLErrorUnsupportedProfile: the requested profile is not supported
	GLErrorUnsupportedProfile GLError = 2
	// GLErrorCompilationFailed: the shader compilation failed
	GLErrorCompilationFailed GLError = 3
	// GLErrorLinkFailed: the shader linking failed
	GLErrorLinkFailed GLError = 4
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity: defines the reference point of a surface and is used in PopupLayout.
type Gravity int

const (
	// GravityNorthWest: the reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: the reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: the reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: the reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: the reference point is at the center of the surface.
	GravityCenter Gravity = 5
	// GravityEast: the reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: the reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: the reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: the reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: the reference point is at the top left corner of the
	// surface itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputSource: an enumeration describing the type of an input device in general
// terms.
type InputSource int

const (
	// InputSourceMouse: the device is a mouse. (This will be reported for the
	// core pointer, even if it is something else, such as a trackball.)
	InputSourceMouse InputSource = 0
	// InputSourcePen: the device is a stylus of a graphics tablet or similar
	// device.
	InputSourcePen InputSource = 1
	// InputSourceKeyboard: the device is a keyboard.
	InputSourceKeyboard InputSource = 2
	// InputSourceTouchscreen: the device is a direct-input touch device, such
	// as a touchscreen or tablet
	InputSourceTouchscreen InputSource = 3
	// InputSourceTouchpad: the device is an indirect touch device, such as a
	// touchpad
	InputSourceTouchpad InputSource = 4
	// InputSourceTrackpoint: the device is a trackpoint
	InputSourceTrackpoint InputSource = 5
	// InputSourceTabletPad: the device is a "pad", a collection of buttons,
	// rings and strips found in drawing tablets
	InputSourceTabletPad InputSource = 6
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// KeyMatch: the possible return values from gdk_key_event_matches() describe
// how well an event matches a given keyval and modifiers.
type KeyMatch int

const (
	// KeyMatchNone: the key event does not match
	KeyMatchNone KeyMatch = 0
	// KeyMatchPartial: the key event matches if keyboard state (specifically,
	// the currently active group) is ignored
	KeyMatchPartial KeyMatch = 1
	// KeyMatchExact: the key event matches
	KeyMatchExact KeyMatch = 2
)

func marshalKeyMatch(p uintptr) (interface{}, error) {
	return KeyMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// MemoryFormat: memoryFormat describes a format that bytes can have in memory.
//
// It describes formats by listing the contents of the memory passed to it. So
// GDK_MEMORY_A8R8G8B8 will be 1 byte (8 bits) of alpha, followed by a byte each
// of red, green and blue. It is not endian-dependent, so CAIRO_FORMAT_ARGB32 is
// represented by different MemoryFormats on architectures with different
// endiannesses.
//
// Its naming is modelled after VkFormat (see
// https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.htmlFormat for
// details).
type MemoryFormat int

const (
	// MemoryFormatB8G8R8A8Premultiplied: 4 bytes; for blue, green, red, alpha.
	// The color values are premultiplied with the alpha value.
	MemoryFormatB8G8R8A8Premultiplied MemoryFormat = 0
	// MemoryFormatA8R8G8B8Premultiplied: 4 bytes; for alpha, red, green, blue.
	// The color values are premultiplied with the alpha value.
	MemoryFormatA8R8G8B8Premultiplied MemoryFormat = 1
	// MemoryFormatR8G8B8A8Premultiplied: 4 bytes; for red, green, blue, alpha
	// The color values are premultiplied with the alpha value.
	MemoryFormatR8G8B8A8Premultiplied MemoryFormat = 2
	// MemoryFormatB8G8R8A8: 4 bytes; for blue, green, red, alpha.
	MemoryFormatB8G8R8A8 MemoryFormat = 3
	// MemoryFormatA8R8G8B8: 4 bytes; for alpha, red, green, blue.
	MemoryFormatA8R8G8B8 MemoryFormat = 4
	// MemoryFormatR8G8B8A8: 4 bytes; for red, green, blue, alpha.
	MemoryFormatR8G8B8A8 MemoryFormat = 5
	// MemoryFormatA8B8G8R8: 4 bytes; for alpha, blue, green, red.
	MemoryFormatA8B8G8R8 MemoryFormat = 6
	// MemoryFormatR8G8B8: 3 bytes; for red, green, blue. The data is opaque.
	MemoryFormatR8G8B8 MemoryFormat = 7
	// MemoryFormatB8G8R8: 3 bytes; for blue, green, red. The data is opaque.
	MemoryFormatB8G8R8 MemoryFormat = 8
	// MemoryFormatNFormats: the number of formats. This value will change as
	// more formats get added, so do not rely on its concrete integer.
	MemoryFormatNFormats MemoryFormat = 9
)

func marshalMemoryFormat(p uintptr) (interface{}, error) {
	return MemoryFormat(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotifyType: specifies the kind of crossing for enter and leave events.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType int

const (
	// NotifyTypeAncestor: the surface is entered from an ancestor or left
	// towards an ancestor.
	NotifyTypeAncestor NotifyType = 0
	// NotifyTypeVirtual: the pointer moves between an ancestor and an inferior
	// of the surface.
	NotifyTypeVirtual NotifyType = 1
	// NotifyTypeInferior: the surface is entered from an inferior or left
	// towards an inferior.
	NotifyTypeInferior NotifyType = 2
	// NotifyTypeNonlinear: the surface is entered from or left towards a
	// surface which is neither an ancestor nor an inferior.
	NotifyTypeNonlinear NotifyType = 3
	// NotifyTypeNonlinearVirtual: the pointer moves between two surfaces which
	// are not ancestors of each other and the surface is part of the ancestor
	// chain between one of these surfaces and their least common ancestor.
	NotifyTypeNonlinearVirtual NotifyType = 4
	// NotifyTypeUnknown: an unknown type of enter/leave event occurred.
	NotifyTypeUnknown NotifyType = 5
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollDirection: specifies the direction for scroll events.
type ScrollDirection int

const (
	// ScrollDirectionUp: the surface is scrolled up.
	ScrollDirectionUp ScrollDirection = 0
	// ScrollDirectionDown: the surface is scrolled down.
	ScrollDirectionDown ScrollDirection = 1
	// ScrollDirectionLeft: the surface is scrolled to the left.
	ScrollDirectionLeft ScrollDirection = 2
	// ScrollDirectionRight: the surface is scrolled to the right.
	ScrollDirectionRight ScrollDirection = 3
	// ScrollDirectionSmooth: the scrolling is determined by the delta values in
	// scroll events. See gdk_scroll_event_get_deltas()
	ScrollDirectionSmooth ScrollDirection = 4
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubpixelLayout: this enumeration describes how the red, green and blue
// components of physical pixels on an output device are laid out.
type SubpixelLayout int

const (
	// SubpixelLayoutUnknown: the layout is not known
	SubpixelLayoutUnknown SubpixelLayout = 0
	// SubpixelLayoutNone: not organized in this way
	SubpixelLayoutNone SubpixelLayout = 1
	// SubpixelLayoutHorizontalRgb: the layout is horizontal, the order is RGB
	SubpixelLayoutHorizontalRgb SubpixelLayout = 2
	// SubpixelLayoutHorizontalBgr: the layout is horizontal, the order is BGR
	SubpixelLayoutHorizontalBgr SubpixelLayout = 3
	// SubpixelLayoutVerticalRgb: the layout is vertical, the order is RGB
	SubpixelLayoutVerticalRgb SubpixelLayout = 4
	// SubpixelLayoutVerticalBgr: the layout is vertical, the order is BGR
	SubpixelLayoutVerticalBgr SubpixelLayout = 5
)

func marshalSubpixelLayout(p uintptr) (interface{}, error) {
	return SubpixelLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SurfaceEdge: determines a surface edge or corner.
type SurfaceEdge int

const (
	// SurfaceEdgeNorthWest: the top left corner.
	SurfaceEdgeNorthWest SurfaceEdge = 0
	// SurfaceEdgeNorth: the top edge.
	SurfaceEdgeNorth SurfaceEdge = 1
	// SurfaceEdgeNorthEast: the top right corner.
	SurfaceEdgeNorthEast SurfaceEdge = 2
	// SurfaceEdgeWest: the left edge.
	SurfaceEdgeWest SurfaceEdge = 3
	// SurfaceEdgeEast: the right edge.
	SurfaceEdgeEast SurfaceEdge = 4
	// SurfaceEdgeSouthWest: the lower left corner.
	SurfaceEdgeSouthWest SurfaceEdge = 5
	// SurfaceEdgeSouth: the lower edge.
	SurfaceEdgeSouth SurfaceEdge = 6
	// SurfaceEdgeSouthEast: the lower right corner.
	SurfaceEdgeSouthEast SurfaceEdge = 7
)

func marshalSurfaceEdge(p uintptr) (interface{}, error) {
	return SurfaceEdge(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TouchpadGesturePhase: specifies the current state of a touchpad gesture. All
// gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
type TouchpadGesturePhase int

const (
	// TouchpadGesturePhaseBegin: the gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = 0
	// TouchpadGesturePhaseUpdate: the gesture has been updated.
	TouchpadGesturePhaseUpdate TouchpadGesturePhase = 1
	// TouchpadGesturePhaseEnd: the gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd TouchpadGesturePhase = 2
	// TouchpadGesturePhaseCancel: the gesture was cancelled, all changes should
	// be undone.
	TouchpadGesturePhaseCancel TouchpadGesturePhase = 3
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VulkanError: error enumeration for VulkanContext.
type VulkanError int

const (
	// VulkanErrorUnsupported: vulkan is not supported on this backend or has
	// not been compiled in.
	VulkanErrorUnsupported VulkanError = 0
	// VulkanErrorNotAvailable: vulkan support is not available on this Surface
	VulkanErrorNotAvailable VulkanError = 1
)

func marshalVulkanError(p uintptr) (interface{}, error) {
	return VulkanError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AnchorHints: positioning hints for aligning a surface relative to a
// rectangle.
//
// These hints determine how the surface should be positioned in the case that
// the surface would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the surface extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the surface can be shifted horizontally to fit
// on-screen. If GDK_ANCHOR_RESIZE_X is set, the surface can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints int

const (
	// AnchorHintsFlipX: allow flipping anchors horizontally
	AnchorHintsFlipX AnchorHints = 0b1
	// AnchorHintsFlipY: allow flipping anchors vertically
	AnchorHintsFlipY AnchorHints = 0b10
	// AnchorHintsSlideX: allow sliding surface horizontally
	AnchorHintsSlideX AnchorHints = 0b100
	// AnchorHintsSlideY: allow sliding surface vertically
	AnchorHintsSlideY AnchorHints = 0b1000
	// AnchorHintsResizeX: allow resizing surface horizontally
	AnchorHintsResizeX AnchorHints = 0b10000
	// AnchorHintsResizeY: allow resizing surface vertically
	AnchorHintsResizeY AnchorHints = 0b100000
	// AnchorHintsFlip: allow flipping anchors on both axes
	AnchorHintsFlip AnchorHints = 0b11
	// AnchorHintsSlide: allow sliding surface on both axes
	AnchorHintsSlide AnchorHints = 0b1100
	// AnchorHintsResize: allow resizing surface on both axes
	AnchorHintsResize AnchorHints = 0b110000
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AxisFlags: flags describing the current capabilities of a device/tool.
type AxisFlags int

const (
	// AxisFlagsX: x axis is present
	AxisFlagsX AxisFlags = 0b10
	// AxisFlagsY: y axis is present
	AxisFlagsY AxisFlags = 0b100
	// AxisFlagsDeltaX: scroll X delta axis is present
	AxisFlagsDeltaX AxisFlags = 0b1000
	// AxisFlagsDeltaY: scroll Y delta axis is present
	AxisFlagsDeltaY AxisFlags = 0b10000
	// AxisFlagsPressure: pressure axis is present
	AxisFlagsPressure AxisFlags = 0b100000
	// AxisFlagsXtilt: x tilt axis is present
	AxisFlagsXtilt AxisFlags = 0b1000000
	// AxisFlagsYtilt: y tilt axis is present
	AxisFlagsYtilt AxisFlags = 0b10000000
	// AxisFlagsWheel: wheel axis is present
	AxisFlagsWheel AxisFlags = 0b100000000
	// AxisFlagsDistance: distance axis is present
	AxisFlagsDistance AxisFlags = 0b1000000000
	// AxisFlagsRotation: z-axis rotation is present
	AxisFlagsRotation AxisFlags = 0b10000000000
	// AxisFlagsSlider: slider axis is present
	AxisFlagsSlider AxisFlags = 0b100000000000
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in Drop and Drag to indicate the actions that the
// destination can and should do with the dropped data.
type DragAction int

const (
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 0b1
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 0b10
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means, and is not supported on
	// all platforms.
	DragActionLink DragAction = 0b100
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 0b1000
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FrameClockPhase is used to represent the different paint clock phases that
// can be requested. The elements of the enumeration correspond to the signals
// of FrameClock.
type FrameClockPhase int

const (
	// FrameClockPhaseNone: no phase
	FrameClockPhaseNone FrameClockPhase = 0b0
	// FrameClockPhaseFlushEvents: corresponds to GdkFrameClock::flush-events.
	// Should not be handled by applications.
	FrameClockPhaseFlushEvents FrameClockPhase = 0b1
	// FrameClockPhaseBeforePaint: corresponds to GdkFrameClock::before-paint.
	// Should not be handled by applications.
	FrameClockPhaseBeforePaint FrameClockPhase = 0b10
	// FrameClockPhaseUpdate: corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdate FrameClockPhase = 0b100
	// FrameClockPhaseLayout: corresponds to GdkFrameClock::layout. Should not
	// be handled by applicatiosn.
	FrameClockPhaseLayout FrameClockPhase = 0b1000
	// FrameClockPhasePaint: corresponds to GdkFrameClock::paint.
	FrameClockPhasePaint FrameClockPhase = 0b10000
	// FrameClockPhaseResumeEvents: corresponds to GdkFrameClock::resume-events.
	// Should not be handled by applications.
	FrameClockPhaseResumeEvents FrameClockPhase = 0b100000
	// FrameClockPhaseAfterPaint: corresponds to GdkFrameClock::after-paint.
	// Should not be handled by applications.
	FrameClockPhaseAfterPaint FrameClockPhase = 0b1000000
)

func marshalFrameClockPhase(p uintptr) (interface{}, error) {
	return FrameClockPhase(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierType: a set of bit-flags to indicate the state of modifier keys and
// mouse buttons in various event types. Typical modifier keys are Shift,
// Control, Meta, Super, Hyper, Alt, Compose, Apple, CapsLock or ShiftLock.
//
// Note that GDK may add internal values to events which include values outside
// of this enumeration. Your code should preserve and ignore them. You can use
// GDK_MODIFIER_MASK to remove all private values.
type ModifierType int

const (
	// ModifierTypeShiftMask: the Shift key.
	ModifierTypeShiftMask ModifierType = 0b1
	// ModifierTypeLockMask: a Lock key (depending on the modifier mapping of
	// the X server this may either be CapsLock or ShiftLock).
	ModifierTypeLockMask ModifierType = 0b10
	// ModifierTypeControlMask: the Control key.
	ModifierTypeControlMask ModifierType = 0b100
	// ModifierTypeAltMask: the fourth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier, but
	// normally it is the Alt key).
	ModifierTypeAltMask ModifierType = 0b1000
	// ModifierTypeButton1Mask: the first mouse button.
	ModifierTypeButton1Mask ModifierType = 0b100000000
	// ModifierTypeButton2Mask: the second mouse button.
	ModifierTypeButton2Mask ModifierType = 0b1000000000
	// ModifierTypeButton3Mask: the third mouse button.
	ModifierTypeButton3Mask ModifierType = 0b10000000000
	// ModifierTypeButton4Mask: the fourth mouse button.
	ModifierTypeButton4Mask ModifierType = 0b100000000000
	// ModifierTypeButton5Mask: the fifth mouse button.
	ModifierTypeButton5Mask ModifierType = 0b1000000000000
	// ModifierTypeSuperMask: the Super modifier
	ModifierTypeSuperMask ModifierType = 0b100000000000000000000000000
	// ModifierTypeHyperMask: the Hyper modifier
	ModifierTypeHyperMask ModifierType = 0b1000000000000000000000000000
	// ModifierTypeMetaMask: the Meta modifier
	ModifierTypeMetaMask ModifierType = 0b10000000000000000000000000000
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PaintableFlags: flags about this object. Implementations use these for
// optimizations such as caching.
type PaintableFlags int

const (
	// PaintableFlagsSize: the size is immutable. The Paintable::invalidate-size
	// signal will never be emitted.
	PaintableFlagsSize PaintableFlags = 0b1
	// PaintableFlagsContents: the content is immutable. The
	// Paintable::invalidate-contents signal will never be emitted.
	PaintableFlagsContents PaintableFlags = 0b10
)

func marshalPaintableFlags(p uintptr) (interface{}, error) {
	return PaintableFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SeatCapabilities: flags describing the seat capabilities.
type SeatCapabilities int

const (
	// SeatCapabilitiesNone: no input capabilities
	SeatCapabilitiesNone SeatCapabilities = 0b0
	// SeatCapabilitiesPointer: the seat has a pointer (e.g. mouse)
	SeatCapabilitiesPointer SeatCapabilities = 0b1
	// SeatCapabilitiesTouch: the seat has touchscreen(s) attached
	SeatCapabilitiesTouch SeatCapabilities = 0b10
	// SeatCapabilitiesTabletStylus: the seat has drawing tablet(s) attached
	SeatCapabilitiesTabletStylus SeatCapabilities = 0b100
	// SeatCapabilitiesKeyboard: the seat has keyboard(s) attached
	SeatCapabilitiesKeyboard SeatCapabilities = 0b1000
	// SeatCapabilitiesTabletPad: the seat has drawing tablet pad(s) attached
	SeatCapabilitiesTabletPad SeatCapabilities = 0b10000
	// SeatCapabilitiesAllPointing: the union of all pointing capabilities
	SeatCapabilitiesAllPointing SeatCapabilities = 0b111
	// SeatCapabilitiesAll: the union of all capabilities
	SeatCapabilitiesAll SeatCapabilities = 0b1111
)

func marshalSeatCapabilities(p uintptr) (interface{}, error) {
	return SeatCapabilities(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ToplevelState: specifies the state of a toplevel surface.
//
// On platforms that support information about individual edges, the
// GDK_TOPLEVEL_STATE_TILED state will be set whenever any of the individual
// tiled states is set. On platforms that lack that support, the tiled state
// will give an indication of tiledness without any of the per-edge states being
// set.
type ToplevelState int

const (
	// ToplevelStateMinimized: the surface is minimized
	ToplevelStateMinimized ToplevelState = 0b1
	// ToplevelStateMaximized: the surface is maximized
	ToplevelStateMaximized ToplevelState = 0b10
	// ToplevelStateSticky: the surface is sticky
	ToplevelStateSticky ToplevelState = 0b100
	// ToplevelStateFullscreen: the surface is maximized without decorations
	ToplevelStateFullscreen ToplevelState = 0b1000
	// ToplevelStateAbove: the surface is kept above other surfaces
	ToplevelStateAbove ToplevelState = 0b10000
	// ToplevelStateBelow: the surface is kept below other surfaces
	ToplevelStateBelow ToplevelState = 0b100000
	// ToplevelStateFocused: the surface is presented as focused (with active
	// decorations)
	ToplevelStateFocused ToplevelState = 0b1000000
	// ToplevelStateTiled: the surface is in a tiled state
	ToplevelStateTiled ToplevelState = 0b10000000
	// ToplevelStateTopTiled: whether the top edge is tiled
	ToplevelStateTopTiled ToplevelState = 0b100000000
	// ToplevelStateTopResizable: whether the top edge is resizable
	ToplevelStateTopResizable ToplevelState = 0b1000000000
	// ToplevelStateRightTiled: whether the right edge is tiled
	ToplevelStateRightTiled ToplevelState = 0b10000000000
	// ToplevelStateRightResizable: whether the right edge is resizable
	ToplevelStateRightResizable ToplevelState = 0b100000000000
	// ToplevelStateBottomTiled: whether the bottom edge is tiled
	ToplevelStateBottomTiled ToplevelState = 0b1000000000000
	// ToplevelStateBottomResizable: whether the bottom edge is resizable
	ToplevelStateBottomResizable ToplevelState = 0b10000000000000
	// ToplevelStateLeftTiled: whether the left edge is tiled
	ToplevelStateLeftTiled ToplevelState = 0b100000000000000
	// ToplevelStateLeftResizable: whether the left edge is resizable
	ToplevelStateLeftResizable ToplevelState = 0b1000000000000000
)

func marshalToplevelState(p uintptr) (interface{}, error) {
	return ToplevelState(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CairoDrawFromGl: this is the main way to draw GL content in GTK. It takes a
// render buffer ID (@source_type == RENDERBUFFER) or a texture id (@source_type
// == TEXTURE) and draws it onto @cr with an OVER operation, respecting the
// current clip. The top left corner of the rectangle specified by @x, @y,
// @width and @height will be drawn at the current (0,0) position of the
// cairo_t.
//
// This will work for *all* cairo_t, as long as @surface is realized, but the
// fallback implementation that reads back the pixels from the buffer may be
// used in the general case. In the case of direct drawing to a surface with no
// special effects applied to @cr it will however use a more efficient approach.
//
// For RENDERBUFFER the code will always fall back to software for buffers with
// alpha components, so make sure you use TEXTURE if using alpha.
//
// Calling this may change the current GL context.
func CairoDrawFromGl(cr *cairo.Context, surface *gdkx11.X11Surface, source int, sourceType int, bufferScale int, x int, y int, width int, height int)

// CairoRectangle: adds the given rectangle to the current path of @cr.
func CairoRectangle(cr *cairo.Context, rectangle *Rectangle)

// CairoRegion: adds the given region to the current path of @cr.
func CairoRegion(cr *cairo.Context, region *cairo.Region)

// CairoRegionCreateFromSurface: creates region that describes covers the area
// where the given @surface is more than 50% opaque.
//
// This function takes into account device offsets that might be set with
// cairo_surface_set_device_offset().
func CairoRegionCreateFromSurface(surface *cairo.Surface) *cairo.Region

// CairoSetSourcePixbuf: sets the given pixbuf as the source pattern for @cr.
//
// The pattern has an extend mode of CAIRO_EXTEND_NONE and is aligned so that
// the origin of @pixbuf is @pixbuf_x, @pixbuf_y.
func CairoSetSourcePixbuf(cr *cairo.Context, pixbuf *gdkpixbuf.Pixbuf, pixbufX float64, pixbufY float64)

// CairoSetSourceRgba: sets the specified RGBA as the source color of @cr.
func CairoSetSourceRgba(cr *cairo.Context, rgba *RGBA)

// ContentDeserializeAsync: read content from the given input stream and
// deserialize it, asynchronously. When the operation is finished, @callback
// will be called. You can then call gdk_content_deserialize_finish() to get the
// result of the operation.
func ContentDeserializeAsync(stream *gio.InputStream, mimeType string, _type externglib.Type, ioPriority int, cancellable *gio.Cancellable, callback gio.AsyncReadyCallback, userData unsafe.Pointer)

// ContentDeserializeFinish: finishes a content deserialization operation.
func ContentDeserializeFinish(result gio.AsyncResult, value *externglib.Value) bool

// ContentRegisterDeserializer: registers a function to create objects of a
// given @type from a serialized representation with the given mime type.
func ContentRegisterDeserializer(mimeType string, _type externglib.Type, deserialize ContentDeserializeFunc, data unsafe.Pointer, notify unsafe.Pointer)

// ContentRegisterSerializer: registers a function to convert objects of the
// given @type to a serialized representation with the given mime type.
func ContentRegisterSerializer(_type externglib.Type, mimeType string, serialize ContentSerializeFunc, data unsafe.Pointer, notify unsafe.Pointer)

// ContentSerializeAsync: serialize content and write it to the given output
// stream, asynchronously. When the operation is finished, @callback will be
// called. You can then call gdk_content_serialize_finish() to get the result of
// the operation.
func ContentSerializeAsync(stream *gio.OutputStream, mimeType string, value *externglib.Value, ioPriority int, cancellable *gio.Cancellable, callback gio.AsyncReadyCallback, userData unsafe.Pointer)

// ContentSerializeFinish: finishes a content serialization operation.
func ContentSerializeFinish(result gio.AsyncResult) bool

// DragActionIsUnique: checks if @action represents a single action or if it
// includes multiple flags that can be selected from.
//
// When @action is 0 - ie no action was given, true is returned.
func DragActionIsUnique(action DragAction) bool

// EventsGetAngle: if both events contain X/Y information, this function will
// return true and return in @angle the relative angle from @event1 to @event2.
// The rotation direction for positive angles is from the positive X axis
// towards the positive Y axis.
func EventsGetAngle(event1 *Event, event2 *Event) (float64, bool)

// EventsGetCenter: if both events contain X/Y information, the center of both
// coordinates will be returned in @x and @y.
func EventsGetCenter(event1 *Event, event2 *Event) (float64, float64, bool)

// EventsGetDistance: if both events have X/Y information, the distance between
// both coordinates (as in a straight line going from @event1 to @event2) will
// be returned.
func EventsGetDistance(event1 *Event, event2 *Event) (float64, bool)

func GlErrorQuark() glib.Quark

// InternMimeType: canonicalizes the given mime type and interns the result.
//
// If @string is not a valid mime type, nil is returned instead. See RFC 2048
// for the syntax if mime types.
func InternMimeType(string string) string

// KeyvalConvertCase: obtains the upper- and lower-case versions of the keyval
// @symbol. Examples of keyvals are K_KEY_a, K_KEY_Enter, K_KEY_F1, etc.
func KeyvalConvertCase(symbol uint) (uint, uint)

// KeyvalFromName: converts a key name to a key value.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalFromName(keyvalName string) uint

// KeyvalIsLower: returns true if the given key value is in lower case.
func KeyvalIsLower(keyval uint) bool

// KeyvalIsUpper: returns true if the given key value is in upper case.
func KeyvalIsUpper(keyval uint) bool

// KeyvalName: converts a key value into a symbolic name.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalName(keyval uint) string

// KeyvalToLower: converts a key value to lower case, if applicable.
func KeyvalToLower(keyval uint) uint

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding ISO10646
// (Unicode) character.
//
// Note that the conversion does not take the current locale into consideration,
// which might be expected for particular keyvals, such as GDK_KEY_KP_Decimal.
func KeyvalToUnicode(keyval uint) uint32

// KeyvalToUpper: converts a key value to upper case, if applicable.
func KeyvalToUpper(keyval uint) uint

// PaintableNewEmpty: returns a paintable that has the given intrinsic size and
// draws nothing. This is often useful for implementing the
// PaintableInterface.get_current_image() virtual function when the paintable is
// in an incomplete state (like a MediaStream before receiving the first frame).
func PaintableNewEmpty(intrinsicWidth int, intrinsicHeight int) Paintable

// PangoLayoutGetClipRegion: obtains a clip region which contains the areas
// where the given ranges of text would be drawn. @x_origin and @y_origin are
// the top left point to center the layout. @index_ranges should contain ranges
// of bytes in the layout’s text.
//
// Note that the regions returned correspond to logical extents of the text
// ranges, not ink extents. So the drawn layout may in fact touch areas out of
// the clip region. The clip region is mainly useful for highlightling parts of
// text, such as when text is selected.
func PangoLayoutGetClipRegion(layout *pango.Layout, xOrigin int, yOrigin int, indexRanges int, nRanges int) *cairo.Region

// PangoLayoutLineGetClipRegion: obtains a clip region which contains the areas
// where the given ranges of text would be drawn. @x_origin and @y_origin are
// the top left position of the layout. @index_ranges should contain ranges of
// bytes in the layout’s text. The clip region will include space to the left or
// right of the line (to the layout bounding box) if you have indexes above or
// below the indexes contained inside the line. This is to draw the selection
// all the way to the side of the layout. However, the clip region is in line
// coordinates, not layout coordinates.
//
// Note that the regions returned correspond to logical extents of the text
// ranges, not ink extents. So the drawn line may in fact touch areas out of the
// clip region. The clip region is mainly useful for highlightling parts of
// text, such as when text is selected.
func PangoLayoutLineGetClipRegion(line *pango.LayoutLine, xOrigin int, yOrigin int, indexRanges []int, nRanges int) *cairo.Region

// PixbufGetFromSurface: transfers image data from a #cairo_surface_t and
// converts it to an RGB(A) representation inside a Pixbuf. This allows you to
// efficiently read individual pixels from cairo surfaces.
//
// This function will create an RGB pixbuf with 8 bits per channel. The pixbuf
// will contain an alpha channel if the @surface contains one.
func PixbufGetFromSurface(surface *cairo.Surface, srcX int, srcY int, width int, height int) *gdkpixbuf.Pixbuf

// PixbufGetFromTexture: creates a new pixbuf from @texture. This should
// generally not be used in newly written code as later stages will almost
// certainly convert the pixbuf back into a texture to draw it on screen.
func PixbufGetFromTexture(texture *Texture) *gdkpixbuf.Pixbuf

// SetAllowedBackends: sets a list of backends that GDK should try to use.
//
// This can be useful if your application does not work with certain GDK
// backends.
//
// By default, GDK tries all included backends.
//
// For example, |[<!-- language="C" --> gdk_set_allowed_backends
// ("wayland,quartz,*"); ]| instructs GDK to try the Wayland backend first,
// followed by the Quartz backend, and then all others.
//
// If the `GDK_BACKEND` environment variable is set, it determines what backends
// are tried in what order, while still respecting the set of allowed backends
// that are specified by this function.
//
// The possible backend names are x11, win32, quartz, broadway, wayland. You can
// also include a * in the list to try all remaining backends.
//
// This call must happen prior to gdk_display_open(), gtk_init(), or
// gtk_init_check() in order to take effect.
func SetAllowedBackends(backends string)

func ToplevelSizeGetType() externglib.Type

// UnicodeToKeyval: convert from a ISO10646 character to a key symbol.
func UnicodeToKeyval(wc uint32) uint

func VulkanErrorQuark() glib.Quark

// DevicePad is an interface implemented by devices of type
// GDK_SOURCE_TABLET_PAD, it allows querying the features provided by the pad
// device.
//
// Tablet pads may contain one or more groups, each containing a subset of the
// buttons/rings/strips available. gdk_device_pad_get_n_groups() can be used to
// obtain the number of groups, gdk_device_pad_get_n_features() and
// gdk_device_pad_get_feature_group() can be combined to find out the number of
// buttons/rings/strips the device has, and how are they grouped.
//
// Each of those groups have different modes, which may be used to map each
// individual pad feature to multiple actions. Only one mode is effective
// (current) for each given group, different groups may have different current
// modes. The number of available modes in a group can be found out through
// gdk_device_pad_get_group_n_modes(), and the current mode for a given group
// will be notified through events of type K_PAD_GROUP_MODE.
type DevicePad interface {
	GetFeatureGroup(feature DevicePadFeature, featureIdx int) int
	GetGroupNModes(groupIdx int) int
	GetNFeatures(feature DevicePadFeature) int
	GetNGroups() int
}

// DragSurface: a DragSurface is an interface implemented by Surfaces used
// during a DND operation.
type DragSurface interface {
	Present(width int, height int) bool
}

// Paintable is a simple interface used by GDK and GTK to represent objects that
// can be painted anywhere at any size without requiring any sort of layout. The
// interface is inspired by similar concepts elsewhere, such as
// [ClutterContent](https://developer.gnome.org/clutter/stable/ClutterContent.html),
// [HTML/CSS Paint Sources](https://www.w3.org/TR/css-images-4/#paint-source),
// or [SVG Paint Servers](https://www.w3.org/TR/SVG2/pservers.html).
//
// A Paintable can be snapshot at any time and size using
// gdk_paintable_snapshot(). How the paintable interprets that size and if it
// scales or centers itself into the given rectangle is implementation defined,
// though if you are implementing a Paintable and don't know what to do, it is
// suggested that you scale your paintable ignoring any potential aspect ratio.
//
// The contents that a Paintable produces may depend on the Snapshot passed to
// it. For example, paintables may decide to use more detailed images on higher
// resolution screens or when OpenGL is available. A Paintable will however
// always produce the same output for the same snapshot.
//
// A Paintable may change its contents, meaning that it will now produce a
// different output with the same snapshot. Once that happens, it will call
// gdk_paintable_invalidate_contents() which will emit the
// Paintable::invalidate-contents signal. If a paintable is known to never
// change its contents, it will set the GDK_PAINTABLE_STATIC_CONTENTS flag. If a
// consumer cannot deal with changing contents, it may call
// gdk_paintable_get_current_image() which will return a static paintable and
// use that.
//
// A paintable can report an intrinsic (or preferred) size or aspect ratio it
// wishes to be rendered at, though it doesn't have to. Consumers of the
// interface can use this information to layout thepaintable appropriately. Just
// like the contents, the size of a paintable can change. A paintable will
// indicate this by calling gdk_paintable_invalidate_size() which will emit the
// Paintable::invalidate-size signal. And just like for contents, if a paintable
// is known to never change its size, it will set the GDK_PAINTABLE_STATIC_SIZE
// flag.
//
// Besides API for applications, there are some functions that are only useful
// for implementing subclasses and should not be used by applications:
// gdk_paintable_invalidate_contents(), gdk_paintable_invalidate_size(),
// gdk_paintable_new_empty().
type Paintable interface {
	ComputeConcreteSize(specifiedWidth float64, specifiedHeight float64, defaultWidth float64, defaultHeight float64) (float64, float64)
	GetCurrentImage() Paintable
	GetFlags() PaintableFlags
	GetIntrinsicAspectRatio() float64
	GetIntrinsicHeight() int
	GetIntrinsicWidth() int
	InvalidateContents()
	InvalidateSize()
	Snapshot(snapshot *Snapshot, width float64, height float64)
}

// Popup: a Popup is a surface that is attached to another surface, called its
// Popup:parent, and is positioned relative to it.
//
// Popups are typically used to implement menus and similar popups. They can be
// modal, which is indicated by the Popup:autohide property.
type Popup interface {
	GetAutohide() bool
	GetParent() *gdkx11.X11Surface
	GetPositionX() int
	GetPositionY() int
	GetRectAnchor() Gravity
	GetSurfaceAnchor() Gravity
	Present(width int, height int, layout *PopupLayout) bool
}

// Toplevel: a Toplevel is a freestanding toplevel surface.
//
// The Toplevel interface provides useful APIs for interacting with the
// windowing system, such as controlling maximization and size of the surface,
// setting icons and transient parents for dialogs.
type Toplevel interface {
	BeginMove(device *gdkx11.X11DeviceXI2, button int, x float64, y float64, timestamp uint32)
	BeginResize(edge SurfaceEdge, device *gdkx11.X11DeviceXI2, button int, x float64, y float64, timestamp uint32)
	Focus(timestamp uint32)
	GetState() ToplevelState
	InhibitSystemShortcuts(event *Event)
	Lower() bool
	Minimize() bool
	Present(layout *ToplevelLayout)
	RestoreSystemShortcuts()
	SetDecorated(decorated bool)
	SetDeletable(deletable bool)
	SetIconList(surfaces *glib.List)
	SetModal(modal bool)
	SetStartupID(startupID string)
	SetTitle(title string)
	SetTransientFor(parent *gdkx11.X11Surface)
	ShowWindowMenu(event *Event) bool
	SupportsEdgeConstraints() bool
}

// ContentFormats: this section describes the ContentFormats structure that is
// used to advertise and negotiate the format of content passed between
// different widgets, windows or applications using for example the clipboard or
// drag'n'drop.
//
// GDK supports content in 2 forms: #GType and mime type. Using #GTypes is meant
// only for in-process content transfers. Mime types are meant to be used for
// data passing both in-process and out-of-process. The details of how data is
// passed is described in the documentation of the actual implementations.
//
// A ContentFormats describes a set of possible formats content can be exchanged
// in. It is assumed that this set is ordered. #GTypes are more important than
// mime types. Order between different #GTypes or mime types is the order they
// were added in, most important first. Functions that care about order, such as
// gdk_content_formats_union() will describe in their documentation how they
// interpret that order, though in general the order of the first argument is
// considered the primary order of the result, followed by the order of further
// arguments.
//
// For debugging purposes, the function gdk_content_formats_to_string() exists.
// It will print a comma-seperated formats of formats from most important to
// least important.
//
// ContentFormats is an immutable struct. After creation, you cannot change the
// types it represents. Instead, new ContentFormats have to be created. The
// ContentFormatsBuilder structure is meant to help in this endeavor.
type ContentFormats struct {
	native *C.GdkContentFormats
}

func wrapContentFormats(p *C.GdkContentFormats) *ContentFormats {
	v := ContentFormats{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*ContentFormats).free)

	return &v
}

func marshalContentFormats(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkContentFormats)(unsafe.Pointer(b))

	return wrapContentFormats(c)
}

func (c *ContentFormats) free() {}

// Native returns the pointer to *C.GdkContentFormats. The caller is expected to
// cast.
func (c *ContentFormats) Native() unsafe.Pointer {
	return unsafe.Pointer(c.native)
}

func NewContentFormats(mimeTypes []string, nMimeTypes uint) *ContentFormats

func NewContentFormats(_type externglib.Type) *ContentFormats

// ContentFormatsBuilder: a ContentFormatsBuilder struct is an opaque struct. It
// is meant to not be kept around and only be used to create new ContentFormats
// objects.
type ContentFormatsBuilder struct {
	native *C.GdkContentFormatsBuilder
}

func wrapContentFormatsBuilder(p *C.GdkContentFormatsBuilder) *ContentFormatsBuilder {
	v := ContentFormatsBuilder{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*ContentFormatsBuilder).free)

	return &v
}

func marshalContentFormatsBuilder(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkContentFormatsBuilder)(unsafe.Pointer(b))

	return wrapContentFormatsBuilder(c)
}

func (c *ContentFormatsBuilder) free() {}

// Native returns the pointer to *C.GdkContentFormatsBuilder. The caller is expected to
// cast.
func (c *ContentFormatsBuilder) Native() unsafe.Pointer {
	return unsafe.Pointer(c.native)
}

func NewContentFormatsBuilder() *ContentFormatsBuilder

// EventSequence: gdkEventSequence is an opaque type representing a sequence of
// related touch events.
type EventSequence struct {
	native *C.GdkEventSequence
}

func wrapEventSequence(p *C.GdkEventSequence) *EventSequence {
	v := EventSequence{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*EventSequence).free)

	return &v
}

func marshalEventSequence(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkEventSequence)(unsafe.Pointer(b))

	return wrapEventSequence(c)
}

func (e *EventSequence) free() {}

// Native returns the pointer to *C.GdkEventSequence. The caller is expected to
// cast.
func (e *EventSequence) Native() unsafe.Pointer {
	return unsafe.Pointer(e.native)
}

// FrameTimings: a FrameTimings object holds timing information for a single
// frame of the application’s displays. To retrieve FrameTimings objects, use
// gdk_frame_clock_get_timings() or gdk_frame_clock_get_current_timings(). The
// information in FrameTimings is useful for precise synchronization of video
// with the event or audio streams, and for measuring quality metrics for the
// application’s display, such as latency and jitter.
type FrameTimings struct {
	native *C.GdkFrameTimings
}

func wrapFrameTimings(p *C.GdkFrameTimings) *FrameTimings {
	v := FrameTimings{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*FrameTimings).free)

	return &v
}

func marshalFrameTimings(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkFrameTimings)(unsafe.Pointer(b))

	return wrapFrameTimings(c)
}

func (f *FrameTimings) free() {}

// Native returns the pointer to *C.GdkFrameTimings. The caller is expected to
// cast.
func (f *FrameTimings) Native() unsafe.Pointer {
	return unsafe.Pointer(f.native)
}

// KeymapKey: a KeymapKey is a hardware key that can be mapped to a keyval.
type KeymapKey struct {
	// Keycode: the hardware keycode. This is an identifying number for a
	// physical key.
	Keycode uint
	// Group: indicates movement in a horizontal direction. Usually groups are
	// used for two different languages. In group 0, a key might have two
	// English characters, and in group 1 it might have two Hebrew characters.
	// The Hebrew characters will be printed on the key next to the English
	// characters.
	Group int
	// Level: indicates which symbol on the key will be used, in a vertical
	// direction. So on a standard US keyboard, the key with the number “1” on
	// it also has the exclamation point ("!") character on it. The level
	// indicates whether to use the “1” or the “!” symbol. The letter keys are
	// considered to have a lowercase letter at level 0, and an uppercase letter
	// at level 1, though only the uppercase letter is printed.
	Level int

	native *C.GdkKeymapKey
}

func wrapKeymapKey(p *C.GdkKeymapKey) *KeymapKey {
	var v KeymapKey

	v.Keycode = uint(p.keycode)
	v.Group = int(p.group)
	v.Level = int(p.level)

	return &v
}

func marshalKeymapKey(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkKeymapKey)(unsafe.Pointer(b))

	return wrapKeymapKey(c)
}

// Native returns the pointer to *C.GdkKeymapKey. The caller is expected to
// cast.
func (k *KeymapKey) Native() unsafe.Pointer {
	return unsafe.Pointer(k.native)
}

// PopupLayout: popups are positioned relative to their parent surface. The
// GdkPopupLayout struct contains information that is necessary to do so.
//
// The positioning requires a negotiation with the windowing system, since it
// depends on external constraints, such as the position of the parent surface,
// and the screen dimensions.
//
// The basic ingredients are a rectangle on the parent surface, and the anchor
// on both that rectangle and the popup. The anchors specify a side or corner to
// place next to each other.
//
// ![Popup anchors](popup-anchors.png)
//
// For cases where placing the anchors next to each other would make the popup
// extend offscreen, the layout includes some hints for how to resolve this
// problem. The hints may suggest to flip the anchor position to the other side,
// or to 'slide' the popup along a side, or to resize it.
//
// ![Flipping popups](popup-flip.png)
//
// ![Sliding popups](popup-slide.png)
//
// These hints may be combined.
//
// Ultimatively, it is up to the windowing system to determine the position and
// size of the popup. You can learn about the result by calling
// gdk_popup_get_position_x(), gdk_popup_get_position_y(),
// gdk_popup_get_rect_anchor() and gdk_popup_get_surface_anchor() after the
// popup has been presented. This can be used to adjust the rendering. For
// example, GtkPopover changes its arrow position accordingly. But you have to
// be careful avoid changing the size of the popover, or it has to be presented
// again.
type PopupLayout struct {
	native *C.GdkPopupLayout
}

func wrapPopupLayout(p *C.GdkPopupLayout) *PopupLayout {
	v := PopupLayout{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*PopupLayout).free)

	return &v
}

func marshalPopupLayout(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkPopupLayout)(unsafe.Pointer(b))

	return wrapPopupLayout(c)
}

func (p *PopupLayout) free() {}

// Native returns the pointer to *C.GdkPopupLayout. The caller is expected to
// cast.
func (p *PopupLayout) Native() unsafe.Pointer {
	return unsafe.Pointer(p.native)
}

func NewPopupLayout(anchorRect *Rectangle, rectAnchor Gravity, surfaceAnchor Gravity) *PopupLayout

// RGBA: a RGBA is used to represent a (possibly translucent) color, in a way
// that is compatible with cairo’s notion of color.
type RGBA struct {
	// Red: the intensity of the red channel from 0.0 to 1.0 inclusive
	Red float32
	// Green: the intensity of the green channel from 0.0 to 1.0 inclusive
	Green float32
	// Blue: the intensity of the blue channel from 0.0 to 1.0 inclusive
	Blue float32
	// Alpha: the opacity of the color from 0.0 for completely translucent to
	// 1.0 for opaque
	Alpha float32

	native *C.GdkRGBA
}

func wrapRGBA(p *C.GdkRGBA) *RGBA {
	var v RGBA

	v.Red = float32(p.red)
	v.Green = float32(p.green)
	v.Blue = float32(p.blue)
	v.Alpha = float32(p.alpha)

	return &v
}

func marshalRGBA(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkRGBA)(unsafe.Pointer(b))

	return wrapRGBA(c)
}

// Native returns the pointer to *C.GdkRGBA. The caller is expected to
// cast.
func (r *RGBA) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// Rectangle: defines the position and size of a rectangle. It is identical to
// #cairo_rectangle_int_t.
type Rectangle struct {
	// X: the x coordinate of the top left corner
	X int
	// Y: the y coordinate of the top left corner
	Y int
	// Width: the width of the rectangle
	Width int
	// Height: the height of the rectangle
	Height int

	native *C.GdkRectangle
}

func wrapRectangle(p *C.GdkRectangle) *Rectangle {
	var v Rectangle

	v.X = int(p.x)
	v.Y = int(p.y)
	v.Width = int(p.width)
	v.Height = int(p.height)

	return &v
}

func marshalRectangle(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkRectangle)(unsafe.Pointer(b))

	return wrapRectangle(c)
}

// Native returns the pointer to *C.GdkRectangle. The caller is expected to
// cast.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(r.native)
}

// TimeCoord: a TimeCoord stores a single event in a motion history.
type TimeCoord struct {
	// Time: the timestamp for this event.
	Time uint32
	// Flags: flags indicating what axes are present
	Flags AxisFlags
	// Axes: axis values
	Axes [12]float64

	native *C.GdkTimeCoord
}

func wrapTimeCoord(p *C.GdkTimeCoord) *TimeCoord {
	var v TimeCoord

	v.Time = uint32(p.time)
	v.Flags = AxisFlags(p.flags)

	return &v
}

func marshalTimeCoord(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkTimeCoord)(unsafe.Pointer(b))

	return wrapTimeCoord(c)
}

// Native returns the pointer to *C.GdkTimeCoord. The caller is expected to
// cast.
func (t *TimeCoord) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

// ToplevelLayout: toplevel surfaces are sovereign windows that can be presented
// to the user in various states (maximized, on all workspaces, etc).
//
// The GdkToplevelLayout struct contains information that is necessary to do so,
// and is passed to gdk_toplevel_present().
type ToplevelLayout struct {
	native *C.GdkToplevelLayout
}

func wrapToplevelLayout(p *C.GdkToplevelLayout) *ToplevelLayout {
	v := ToplevelLayout{native: p}

	runtime.SetFinalizer(v, nil)
	runtime.SetFinalizer(v, (*ToplevelLayout).free)

	return &v
}

func marshalToplevelLayout(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	c := (*C.GdkToplevelLayout)(unsafe.Pointer(b))

	return wrapToplevelLayout(c)
}

func (t *ToplevelLayout) free() {}

// Native returns the pointer to *C.GdkToplevelLayout. The caller is expected to
// cast.
func (t *ToplevelLayout) Native() unsafe.Pointer {
	return unsafe.Pointer(t.native)
}

func NewToplevelLayout() *ToplevelLayout

// AppLaunchContext: gdkAppLaunchContext is an implementation of LaunchContext
// that handles launching an application in a graphical context. It provides
// startup notification and allows to launch applications on a specific screen
// or workspace.
//
// Launching an application
//
//    GdkAppLaunchContext *context;
//
//    context = gdk_display_get_app_launch_context (display);
//
//    gdk_app_launch_context_set_display (display);
//    gdk_app_launch_context_set_timestamp (gdk_event_get_time (event));
//
//    if (!g_app_info_launch_default_for_uri ("http://www.gtk.org", context, &error))
//      g_warning ("Launching failed: s\n", error->message);
//
//    g_object_unref (context);
//
type AppLaunchContext struct {
	gio.AppLaunchContext
}

func wrapAppLaunchContext(obj *externglib.Object) *AppLaunchContext {
	return &AppLaunchContext{AppLaunchContext{*externglib.Object{obj}}}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ButtonEvent: an event related to a button on a pointer device/
type ButtonEvent struct {
	Event
}

func wrapButtonEvent(obj *externglib.Object) *ButtonEvent {
	return &ButtonEvent{Event{obj}}
}

func marshalButtonEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// CairoContext is an object representing the platform-specific draw context.
//
// CairoContexts are created for a Display using
// gdk_surface_create_cairo_context(), and the context can then be used to draw
// on that Surface.
type CairoContext struct {
	DrawContext
}

func wrapCairoContext(obj *externglib.Object) *CairoContext {
	return &CairoContext{DrawContext{*externglib.Object{obj}}}
}

func marshalCairoContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Clipboard: the Clipboard object represents a clipboard of data shared between
// different applications or between different parts of the same application.
//
// To get a GdkClipboard object, use gdk_display_get_clipboard() or
// gdk_display_get_primary_clipboard(). You can find out about the data that is
// currently available in a clipboard using gdk_clipboard_get_formats().
//
// To make text or image data available in a clipboard, use
// gdk_clipboard_set_text() or gdk_clipboard_set_texture(). For other data, you
// can use gdk_clipboard_set_content(), which takes a ContentProvider object.
//
// To read textual or image data from a clipboard, use
// gdk_clipboard_read_text_async() or gdk_clipboard_read_texture_async(). For
// other data, use gdk_clipboard_read_async(), which provides a Stream object.
type Clipboard struct {
	*externglib.Object
}

func wrapClipboard(obj *externglib.Object) *Clipboard {
	return &Clipboard{*externglib.Object{obj}}
}

func marshalClipboard(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ContentDeserializer: a GdkContentDeserializer is used to deserialize content
// received via inter-application data transfers.
type ContentDeserializer struct {
	*externglib.Object
}

func wrapContentDeserializer(obj *externglib.Object) *ContentDeserializer {
	return &ContentDeserializer{*externglib.Object{obj}}
}

func marshalContentDeserializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ContentProvider: a GdkContentProvider is used to provide content for the
// clipboard in a number of formats.
//
// To create a GdkContentProvider, use gdk_content_provider_new_for_value() or
// gdk_content_provider_new_for_bytes().
//
// GDK knows how to handle common text and image formats out-of-the-box. See
// ContentSerializer and ContentDeserializer if you want to add support for
// application-specific data formats.
type ContentProvider struct {
	*externglib.Object
}

func wrapContentProvider(obj *externglib.Object) *ContentProvider {
	return &ContentProvider{*externglib.Object{obj}}
}

func marshalContentProvider(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewContentProvider(mimeType string, bytes *glib.Bytes) *ContentProvider

func NewContentProvider(value *externglib.Value) *ContentProvider

func NewContentProvider(providers []*ContentProvider, nProviders uint) *ContentProvider

// ContentSerializer: a GdkContentSerializer is used to serialize content for
// inter-application data transfers.
type ContentSerializer struct {
	*externglib.Object
}

func wrapContentSerializer(obj *externglib.Object) *ContentSerializer {
	return &ContentSerializer{*externglib.Object{obj}}
}

func marshalContentSerializer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// CrossingEvent: an event caused by a pointing device moving between surfaces.
type CrossingEvent struct {
	Event
}

func wrapCrossingEvent(obj *externglib.Object) *CrossingEvent {
	return &CrossingEvent{Event{obj}}
}

func marshalCrossingEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Cursor: a Cursor represents a cursor. Its contents are private.
//
// Cursors are immutable objects, so they can not change after they have been
// constructed.
type Cursor struct {
	*externglib.Object
}

func wrapCursor(obj *externglib.Object) *Cursor {
	return &Cursor{*externglib.Object{obj}}
}

func marshalCursor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewCursor(name string, fallback *Cursor) *Cursor

func NewCursor(texture *Texture, hotspotX int, hotspotY int, fallback *Cursor) *Cursor

// DNDEvent: an event related to drag and drop operations.
type DNDEvent struct {
	Event
}

func wrapDNDEvent(obj *externglib.Object) *DNDEvent {
	return &DNDEvent{Event{obj}}
}

func marshalDNDEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DeleteEvent: an event related to closing a top-level surface.
type DeleteEvent struct {
	Event
}

func wrapDeleteEvent(obj *externglib.Object) *DeleteEvent {
	return &DeleteEvent{Event{obj}}
}

func marshalDeleteEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Device: the Device object represents a single input device, such as a
// keyboard, a mouse, a touchpad, etc.
//
// See the Seat documentation for more information about the various kinds of
// devices, and their relationships.
type Device struct {
	*externglib.Object
}

func wrapDevice(obj *externglib.Object) *Device {
	return &Device{*externglib.Object{obj}}
}

func marshalDevice(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DeviceTool: a physical tool associated to a Device.
type DeviceTool struct {
	*externglib.Object
}

func wrapDeviceTool(obj *externglib.Object) *DeviceTool {
	return &DeviceTool{*externglib.Object{obj}}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Display: gdkDisplay objects are the GDK representation of a workstation.
//
// Their purpose are two-fold: - To manage and provide information about input
// devices (pointers, keyboards, etc) - To manage and provide information about
// output devices (monitors, projectors, etc)
//
// Most of the input device handling has been factored out into separate Seat
// objects. Every display has a one or more seats, which can be accessed with
// gdk_display_get_default_seat() and gdk_display_list_seats().
//
// Output devices are represented by Monitor objects, which can be accessed with
// gdk_display_get_monitor_at_surface() and similar APIs.
type Display struct {
	*externglib.Object
}

func wrapDisplay(obj *externglib.Object) *Display {
	return &Display{*externglib.Object{obj}}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DisplayManager: the purpose of the DisplayManager singleton object is to
// offer notification when displays appear or disappear or the default display
// changes.
//
// You can use gdk_display_manager_get() to obtain the DisplayManager singleton,
// but that should be rarely necessary. Typically, initializing GTK opens a
// display that you can work with without ever accessing the DisplayManager.
//
// The GDK library can be built with support for multiple backends. The
// DisplayManager object determines which backend is used at runtime.
//
// When writing backend-specific code that is supposed to work with multiple GDK
// backends, you have to consider both compile time and runtime. At compile
// time, use the K_WINDOWING_X11, K_WINDOWING_WIN32 macros, etc. to find out
// which backends are present in the GDK library you are building your
// application against. At runtime, use type-check macros like
// GDK_IS_X11_DISPLAY() to find out which backend is in use:
//
// Backend-specific code {#backend-specific}
//
//    #ifdef GDK_WINDOWING_X11
//      if (GDK_IS_X11_DISPLAY (display))
//        {
//          // make X11-specific calls here
//        }
//      else
//    #endif
//    #ifdef GDK_WINDOWING_MACOS
//      if (GDK_IS_MACOS_DISPLAY (display))
//        {
//          // make Quartz-specific calls here
//        }
//      else
//    #endif
//      g_error ("Unsupported GDK backend");
type DisplayManager struct {
	*externglib.Object
}

func wrapDisplayManager(obj *externglib.Object) *DisplayManager {
	return &DisplayManager{*externglib.Object{obj}}
}

func marshalDisplayManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Drag: the GdkDrag struct contains only private fields and should not be
// accessed directly.
type Drag struct {
	*externglib.Object
}

func wrapDrag(obj *externglib.Object) *Drag {
	return &Drag{*externglib.Object{obj}}
}

func marshalDrag(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// DrawContext is the base object used by contexts implementing different
// rendering methods, such as GLContext or VulkanContext. It provides shared
// functionality between those contexts.
//
// You will always interact with one of those subclasses.
//
// A GdkDrawContext is always associated with a single toplevel surface.
type DrawContext struct {
	*externglib.Object
}

func wrapDrawContext(obj *externglib.Object) *DrawContext {
	return &DrawContext{*externglib.Object{obj}}
}

func marshalDrawContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Drop: the GdkDrop struct contains only private fields and should not be
// accessed directly.
type Drop struct {
	*externglib.Object
}

func wrapDrop(obj *externglib.Object) *Drop {
	return &Drop{*externglib.Object{obj}}
}

func marshalDrop(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FocusEvent: an event related to a focus change.
type FocusEvent struct {
	Event
}

func wrapFocusEvent(obj *externglib.Object) *FocusEvent {
	return &FocusEvent{Event{obj}}
}

func marshalFocusEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// FrameClock: a FrameClock tells the application when to update and repaint a
// surface. This may be synced to the vertical refresh rate of the monitor, for
// example. Even when the frame clock uses a simple timer rather than a
// hardware-based vertical sync, the frame clock helps because it ensures
// everything paints at the same time (reducing the total number of frames). The
// frame clock can also automatically stop painting when it knows the frames
// will not be visible, or scale back animation framerates.
//
// FrameClock is designed to be compatible with an OpenGL-based implementation
// or with mozRequestAnimationFrame in Firefox, for example.
//
// A frame clock is idle until someone requests a frame with
// gdk_frame_clock_request_phase(). At some later point that makes sense for the
// synchronization being implemented, the clock will process a frame and emit
// signals for each phase that has been requested. (See the signals of the
// FrameClock class for documentation of the phases.
// GDK_FRAME_CLOCK_PHASE_UPDATE and the FrameClock::update signal are most
// interesting for application writers, and are used to update the animations,
// using the frame time given by gdk_frame_clock_get_frame_time().
//
// The frame time is reported in microseconds and generally in the same
// timescale as g_get_monotonic_time(), however, it is not the same as
// g_get_monotonic_time(). The frame time does not advance during the time a
// frame is being painted, and outside of a frame, an attempt is made so that
// all calls to gdk_frame_clock_get_frame_time() that are called at a “similar”
// time get the same value. This means that if different animations are timed by
// looking at the difference in time between an initial value from
// gdk_frame_clock_get_frame_time() and the value inside the FrameClock::update
// signal of the clock, they will stay exactly synchronized.
type FrameClock struct {
	*externglib.Object
}

func wrapFrameClock(obj *externglib.Object) *FrameClock {
	return &FrameClock{*externglib.Object{obj}}
}

func marshalFrameClock(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// GLContext is an object representing the platform-specific OpenGL draw
// context.
//
// GLContexts are created for a Surface using gdk_surface_create_gl_context(),
// and the context will match the the characteristics of the surface.
//
// A GLContext is not tied to any particular normal framebuffer. For instance,
// it cannot draw to the Surface back buffer. The GDK repaint system is in full
// control of the painting to that. Instead, you can create render buffers or
// textures and use gdk_cairo_draw_from_gl() in the draw function of your widget
// to draw them. Then GDK will handle the integration of your rendering with
// that of other widgets.
//
// Support for GLContext is platform-specific, context creation can fail,
// returning nil context.
//
// A GLContext has to be made "current" in order to start using it, otherwise
// any OpenGL call will be ignored.
//
// Creating a new OpenGL context ##
//
// In order to create a new GLContext instance you need a Surface, which you
// typically get during the realize call of a widget.
//
// A GLContext is not realized until either gdk_gl_context_make_current(), or
// until it is realized using gdk_gl_context_realize(). It is possible to
// specify details of the GL context like the OpenGL version to be used, or
// whether the GL context should have extra state validation enabled after
// calling gdk_surface_create_gl_context() by calling gdk_gl_context_realize().
// If the realization fails you have the option to change the settings of the
// GLContext and try again.
//
// Using a GdkGLContext ##
//
// You will need to make the GLContext the current context before issuing OpenGL
// calls; the system sends OpenGL commands to whichever context is current. It
// is possible to have multiple contexts, so you always need to ensure that the
// one which you want to draw with is the current one before issuing commands:
//
//    gdk_gl_context_make_current (context);
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which GLContext is the current one by using
// gdk_gl_context_get_current(); you can also unset any GLContext that is
// currently set by calling gdk_gl_context_clear_current().
type GLContext struct {
	DrawContext
}

func wrapGLContext(obj *externglib.Object) *GLContext {
	return &GLContext{DrawContext{*externglib.Object{obj}}}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// GLTexture: a Texture representing a GL texture object.
type GLTexture struct {
	Texture
}

func wrapGLTexture(obj *externglib.Object) *GLTexture {
	return &GLTexture{Texture{*externglib.Object{obj}}}
}

func marshalGLTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewGLTexture(context *GLContext, id uint, width int, height int, destroy unsafe.Pointer, data unsafe.Pointer) *GLTexture

// GrabBrokenEvent: an event related to a broken windowing system grab.
type GrabBrokenEvent struct {
	Event
}

func wrapGrabBrokenEvent(obj *externglib.Object) *GrabBrokenEvent {
	return &GrabBrokenEvent{Event{obj}}
}

func marshalGrabBrokenEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// KeyEvent: an event related to a key-based device.
type KeyEvent struct {
	Event
}

func wrapKeyEvent(obj *externglib.Object) *KeyEvent {
	return &KeyEvent{Event{obj}}
}

func marshalKeyEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MemoryTexture: a Texture representing image data in memory.
type MemoryTexture struct {
	Texture
}

func wrapMemoryTexture(obj *externglib.Object) *MemoryTexture {
	return &MemoryTexture{Texture{*externglib.Object{obj}}}
}

func marshalMemoryTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewMemoryTexture(width int, height int, format MemoryFormat, bytes *glib.Bytes, stride uint) *MemoryTexture

// Monitor: gdkMonitor objects represent the individual outputs that are
// associated with a Display. GdkDisplay keeps a Model to enumerate and monitor
// monitors with gdk_display_get_monitors(). You can use
// gdk_display_get_monitor_at_surface() to find a particular monitor.
type Monitor struct {
	*externglib.Object
}

func wrapMonitor(obj *externglib.Object) *Monitor {
	return &Monitor{*externglib.Object{obj}}
}

func marshalMonitor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// MotionEvent: an event related to a pointer or touch device motion.
type MotionEvent struct {
	Event
}

func wrapMotionEvent(obj *externglib.Object) *MotionEvent {
	return &MotionEvent{Event{obj}}
}

func marshalMotionEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// PadEvent: an event related to a pad-based device.
type PadEvent struct {
	Event
}

func wrapPadEvent(obj *externglib.Object) *PadEvent {
	return &PadEvent{Event{obj}}
}

func marshalPadEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ProximityEvent: an event related to the proximity of a tool to a device.
type ProximityEvent struct {
	Event
}

func wrapProximityEvent(obj *externglib.Object) *ProximityEvent {
	return &ProximityEvent{Event{obj}}
}

func marshalProximityEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// ScrollEvent: an event related to a scrolling motion.
type ScrollEvent struct {
	Event
}

func wrapScrollEvent(obj *externglib.Object) *ScrollEvent {
	return &ScrollEvent{Event{obj}}
}

func marshalScrollEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Seat: the Seat object represents a collection of input devices that belong to
// a user.
type Seat struct {
	*externglib.Object
}

func wrapSeat(obj *externglib.Object) *Seat {
	return &Seat{*externglib.Object{obj}}
}

func marshalSeat(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Snapshot: base type for snapshot operations.
type Snapshot struct {
	*externglib.Object
}

func wrapSnapshot(obj *externglib.Object) *Snapshot {
	return &Snapshot{*externglib.Object{obj}}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// Surface: a Surface is a (usually) rectangular region on the screen. It’s a
// low-level object, used to implement high-level objects such as Window or
// Dialog in GTK.
//
// The surfaces you see in practice are either Toplevel or Popup, and those
// interfaces provide much of the required API to interact with these surfaces.
// Other, more specialized surface types exist, but you will rarely interact
// with them directly.
type Surface struct {
	*externglib.Object
}

func wrapSurface(obj *externglib.Object) *Surface {
	return &Surface{*externglib.Object{obj}}
}

func marshalSurface(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewSurface(parent *gdkx11.X11Surface, autohide bool) *Surface

func NewSurface(display *gdkx11.X11Display) *Surface

// Texture: the `GdkTexture` structure contains only private data.
type Texture struct {
	*externglib.Object
}

func wrapTexture(obj *externglib.Object) *Texture {
	return &Texture{*externglib.Object{obj}}
}

func marshalTexture(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

func NewTexture(pixbuf *gdkpixbuf.Pixbuf) *Texture

func NewTexture(file gio.File) *Texture

func NewTexture(resourcePath string) *Texture

// TouchEvent: an event related to a touch-based device.
type TouchEvent struct {
	Event
}

func wrapTouchEvent(obj *externglib.Object) *TouchEvent {
	return &TouchEvent{Event{obj}}
}

func marshalTouchEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// TouchpadEvent: an event related to a touchpad device.
type TouchpadEvent struct {
	Event
}

func wrapTouchpadEvent(obj *externglib.Object) *TouchpadEvent {
	return &TouchpadEvent{Event{obj}}
}

func marshalTouchpadEvent(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}

// VulkanContext is an object representing the platform-specific Vulkan draw
// context.
//
// VulkanContexts are created for a Surface using
// gdk_surface_create_vulkan_context(), and the context will match the the
// characteristics of the surface.
//
// Support for VulkanContext is platform-specific, context creation can fail,
// returning nil context.
type VulkanContext struct {
	DrawContext
}

func wrapVulkanContext(obj *externglib.Object) *VulkanContext {
	return &VulkanContext{DrawContext{*externglib.Object{obj}}}
}

func marshalVulkanContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapWidget(obj), nil
}
