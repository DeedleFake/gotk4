// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_window_get_type()), F: marshalWindow},
	})
}

// WindowChildFunc: a function of this type is passed to
// gdk_window_invalidate_maybe_recurse(). It gets called for each child of the
// window to determine whether to recursively invalidate it or now.
type WindowChildFunc func(window Window) bool

//export gotk4_WindowChildFunc
func gotk4_WindowChildFunc(arg0 *C.GdkWindow, arg1 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(WindowChildFunc)
	ret := fn(window, userData)

	if ret {
		cret = C.gboolean(1)
	}

	return cret
}

// GetDefaultRootWindow obtains the root window (parent all other windows are
// inside) for the default display and screen.
func GetDefaultRootWindow() Window {
	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_get_default_root_window()

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// OffscreenWindowGetEmbedder gets the window that @window is embedded in.
func OffscreenWindowGetEmbedder(window Window) Window {
	var arg1 *C.GdkWindow

	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_offscreen_window_get_embedder(window)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// OffscreenWindowGetSurface gets the offscreen surface that an offscreen window
// renders into. If you need to keep this around over window resizes, you need
// to add a reference to it.
func OffscreenWindowGetSurface(window Window) *cairo.Surface {
	var arg1 *C.GdkWindow

	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret *C.cairo_surface_t
	var ret1 *cairo.Surface

	cret = C.gdk_offscreen_window_get_surface(window)

	ret1 = cairo.WrapSurface(unsafe.Pointer(cret))

	return ret1
}

// OffscreenWindowSetEmbedder sets @window to be embedded in @embedder.
//
// To fully embed an offscreen window, in addition to calling this function, it
// is also necessary to handle the Window::pick-embedded-child signal on the
// @embedder and the Window::to-embedder and Window::from-embedder signals on
// @window.
func OffscreenWindowSetEmbedder(window Window, embedder Window) {
	var arg1 *C.GdkWindow
	var arg2 *C.GdkWindow

	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	arg2 = (*C.GdkWindow)(unsafe.Pointer(embedder.Native()))

	C.gdk_offscreen_window_set_embedder(window, embedder)
}

type Window interface {
	gextras.Objector

	// AddFilter adds an event filter to @window, allowing you to intercept
	// events before they reach GDK. This is a low-level operation and makes it
	// easy to break GDK and/or GTK+, so you have to know what you're doing.
	// Pass nil for @window to get all events for all windows, instead of events
	// for a specific window.
	//
	// If you are interested in X GenericEvents, bear in mind that
	// XGetEventData() has been already called on the event, and
	// XFreeEventData() must not be called within @function.
	AddFilter(function FilterFunc)
	// Beep emits a short beep associated to @window in the appropriate display,
	// if supported. Otherwise, emits a short beep on the display just as
	// gdk_display_beep().
	Beep()
	// BeginDrawFrame indicates that you are beginning the process of redrawing
	// @region on @window, and provides you with a DrawingContext.
	//
	// If @window is a top level Window, backed by a native window
	// implementation, a backing store (offscreen buffer) large enough to
	// contain @region will be created. The backing store will be initialized
	// with the background color or background surface for @window. Then, all
	// drawing operations performed on @window will be diverted to the backing
	// store. When you call gdk_window_end_frame(), the contents of the backing
	// store will be copied to @window, making it visible on screen. Only the
	// part of @window contained in @region will be modified; that is, drawing
	// operations are clipped to @region.
	//
	// The net result of all this is to remove flicker, because the user sees
	// the finished product appear all at once when you call
	// gdk_window_end_draw_frame(). If you draw to @window directly without
	// calling gdk_window_begin_draw_frame(), the user may see flicker as
	// individual drawing operations are performed in sequence.
	//
	// When using GTK+, the widget system automatically places calls to
	// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() around
	// emissions of the `GtkWidget::draw` signal. That is, if you’re drawing the
	// contents of the widget yourself, you can assume that the widget has a
	// cleared background, is already set as the clip region, and already has a
	// backing store. Therefore in most cases, application code in GTK does not
	// need to call gdk_window_begin_draw_frame() explicitly.
	BeginDrawFrame(region *cairo.Region) DrawingContext
	// BeginMoveDrag begins a window move operation (for a toplevel window).
	//
	// This function assumes that the drag is controlled by the client pointer
	// device, use gdk_window_begin_move_drag_for_device() to begin a drag with
	// a different device.
	BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32)
	// BeginMoveDragForDevice begins a window move operation (for a toplevel
	// window). You might use this function to implement a “window move grip,”
	// for example. The function works best with window managers that support
	// the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec) but has a fallback
	// implementation for other window managers.
	BeginMoveDragForDevice(device Device, button int, rootX int, rootY int, timestamp uint32)
	// BeginPaintRect: a convenience wrapper around
	// gdk_window_begin_paint_region() which creates a rectangular region for
	// you. See gdk_window_begin_paint_region() for details.
	BeginPaintRect(rectangle *Rectangle)
	// BeginPaintRegion indicates that you are beginning the process of
	// redrawing @region. A backing store (offscreen buffer) large enough to
	// contain @region will be created. The backing store will be initialized
	// with the background color or background surface for @window. Then, all
	// drawing operations performed on @window will be diverted to the backing
	// store. When you call gdk_window_end_paint(), the backing store will be
	// copied to @window, making it visible onscreen. Only the part of @window
	// contained in @region will be modified; that is, drawing operations are
	// clipped to @region.
	//
	// The net result of all this is to remove flicker, because the user sees
	// the finished product appear all at once when you call
	// gdk_window_end_paint(). If you draw to @window directly without calling
	// gdk_window_begin_paint_region(), the user may see flicker as individual
	// drawing operations are performed in sequence. The clipping and
	// background-initializing features of gdk_window_begin_paint_region() are
	// conveniences for the programmer, so you can avoid doing that work
	// yourself.
	//
	// When using GTK+, the widget system automatically places calls to
	// gdk_window_begin_paint_region() and gdk_window_end_paint() around
	// emissions of the expose_event signal. That is, if you’re writing an
	// expose event handler, you can assume that the exposed area in EventExpose
	// has already been cleared to the window background, is already set as the
	// clip region, and already has a backing store. Therefore in most cases,
	// application code need not call gdk_window_begin_paint_region(). (You can
	// disable the automatic calls around expose events on a widget-by-widget
	// basis by calling gtk_widget_set_double_buffered().)
	//
	// If you call this function multiple times before calling the matching
	// gdk_window_end_paint(), the backing stores are pushed onto a stack.
	// gdk_window_end_paint() copies the topmost backing store onscreen,
	// subtracts the topmost region from all other regions in the stack, and
	// pops the stack. All drawing operations affect only the topmost backing
	// store in the stack. One matching call to gdk_window_end_paint() is
	// required for each call to gdk_window_begin_paint_region().
	BeginPaintRegion(region *cairo.Region)
	// BeginResizeDrag begins a window resize operation (for a toplevel window).
	//
	// This function assumes that the drag is controlled by the client pointer
	// device, use gdk_window_begin_resize_drag_for_device() to begin a drag
	// with a different device.
	BeginResizeDrag(edge WindowEdge, button int, rootX int, rootY int, timestamp uint32)
	// BeginResizeDragForDevice begins a window resize operation (for a toplevel
	// window). You might use this function to implement a “window resize grip,”
	// for example; in fact Statusbar uses it. The function works best with
	// window managers that support the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec) but has a fallback
	// implementation for other window managers.
	BeginResizeDragForDevice(edge WindowEdge, device Device, button int, rootX int, rootY int, timestamp uint32)
	// ConfigureFinished does nothing, present only for compatiblity.
	ConfigureFinished()
	// CoordsFromParent transforms window coordinates from a parent window to a
	// child window, where the parent window is the normal parent as returned by
	// gdk_window_get_parent() for normal windows, and the window's embedder as
	// returned by gdk_offscreen_window_get_embedder() for offscreen windows.
	//
	// For normal windows, calling this function is equivalent to subtracting
	// the return values of gdk_window_get_position() from the parent
	// coordinates. For offscreen windows however (which can be arbitrarily
	// transformed), this function calls the GdkWindow::from-embedder: signal to
	// translate the coordinates.
	//
	// You should always use this function when writing generic code that walks
	// down a window hierarchy.
	//
	// See also: gdk_window_coords_to_parent()
	CoordsFromParent(parentX float64, parentY float64) (x float64, y float64)
	// CoordsToParent transforms window coordinates from a child window to its
	// parent window, where the parent window is the normal parent as returned
	// by gdk_window_get_parent() for normal windows, and the window's embedder
	// as returned by gdk_offscreen_window_get_embedder() for offscreen windows.
	//
	// For normal windows, calling this function is equivalent to adding the
	// return values of gdk_window_get_position() to the child coordinates. For
	// offscreen windows however (which can be arbitrarily transformed), this
	// function calls the GdkWindow::to-embedder: signal to translate the
	// coordinates.
	//
	// You should always use this function when writing generic code that walks
	// up a window hierarchy.
	//
	// See also: gdk_window_coords_from_parent()
	CoordsToParent(x float64, y float64) (parentX float64, parentY float64)
	// CreateGLContext creates a new GLContext matching the framebuffer format
	// to the visual of the Window. The context is disconnected from any
	// particular window or surface.
	//
	// If the creation of the GLContext failed, @error will be set.
	//
	// Before using the returned GLContext, you will need to call
	// gdk_gl_context_make_current() or gdk_gl_context_realize().
	CreateGLContext() (glContext GLContext, err error)
	// CreateSimilarImageSurface: create a new image surface that is efficient
	// to draw on the given @window.
	//
	// Initially the surface contents are all 0 (transparent if contents have
	// transparency, black otherwise.)
	//
	// The @width and @height of the new surface are not affected by the scaling
	// factor of the @window, or by the @scale argument; they are the size of
	// the surface in device pixels. If you wish to create an image surface
	// capable of holding the contents of @window you can use:
	//
	//      int scale = gdk_window_get_scale_factor (window);
	//      int width = gdk_window_get_width (window) * scale;
	//      int height = gdk_window_get_height (window) * scale;
	//
	//      // format is set elsewhere
	//      cairo_surface_t *surface =
	//        gdk_window_create_similar_image_surface (window,
	//                                                 format,
	//                                                 width, height,
	//                                                 scale);
	//
	// Note that unlike cairo_surface_create_similar_image(), the new surface's
	// device scale is set to @scale, or to the scale factor of @window if
	// @scale is 0.
	CreateSimilarImageSurface(format cairo.Format, width int, height int, scale int) *cairo.Surface
	// CreateSimilarSurface: create a new surface that is as compatible as
	// possible with the given @window. For example the new surface will have
	// the same fallback resolution and font options as @window. Generally, the
	// new surface will also use the same backend as @window, unless that is not
	// possible for some reason. The type of the returned surface may be
	// examined with cairo_surface_get_type().
	//
	// Initially the surface contents are all 0 (transparent if contents have
	// transparency, black otherwise.)
	CreateSimilarSurface(content cairo.Content, width int, height int) *cairo.Surface
	// Deiconify: attempt to deiconify (unminimize) @window. On X11 the window
	// manager may choose to ignore the request to deiconify. When using GTK+,
	// use gtk_window_deiconify() instead of the Window variant. Or better yet,
	// you probably want to use gtk_window_present_with_time(), which raises the
	// window, focuses it, unminimizes it, and puts it on the current desktop.
	Deiconify()
	// Destroy destroys the window system resources associated with @window and
	// decrements @window's reference count. The window system resources for all
	// children of @window are also destroyed, but the children’s reference
	// counts are not decremented.
	//
	// Note that a window will not be destroyed automatically when its reference
	// count reaches zero. You must call this function yourself before that
	// happens.
	Destroy()

	DestroyNotify()
	// EnableSynchronizedConfigure does nothing, present only for compatiblity.
	EnableSynchronizedConfigure()
	// EndDrawFrame indicates that the drawing of the contents of @window
	// started with gdk_window_begin_frame() has been completed.
	//
	// This function will take care of destroying the DrawingContext.
	//
	// It is an error to call this function without a matching
	// gdk_window_begin_frame() first.
	EndDrawFrame(context DrawingContext)
	// EndPaint indicates that the backing store created by the most recent call
	// to gdk_window_begin_paint_region() should be copied onscreen and deleted,
	// leaving the next-most-recent backing store or no backing store at all as
	// the active paint region. See gdk_window_begin_paint_region() for full
	// details.
	//
	// It is an error to call this function without a matching
	// gdk_window_begin_paint_region() first.
	EndPaint()
	// EnsureNative tries to ensure that there is a window-system native window
	// for this GdkWindow. This may fail in some situations, returning false.
	//
	// Offscreen window and children of them can never have native windows.
	//
	// Some backends may not support native child windows.
	EnsureNative() bool
	// Flush: this function does nothing.
	Flush()
	// Focus sets keyboard focus to @window. In most cases,
	// gtk_window_present_with_time() should be used on a Window, rather than
	// calling this function.
	Focus(timestamp uint32)
	// FreezeToplevelUpdatesLibgtkOnly: temporarily freezes a window and all its
	// descendants such that it won't receive expose events. The window will
	// begin receiving expose events again when
	// gdk_window_thaw_toplevel_updates_libgtk_only() is called. If
	// gdk_window_freeze_toplevel_updates_libgtk_only() has been called more
	// than once, gdk_window_thaw_toplevel_updates_libgtk_only() must be called
	// an equal number of times to begin processing exposes.
	//
	// This function is not part of the GDK public API and is only for use by
	// GTK+.
	FreezeToplevelUpdatesLibgtkOnly()
	// FreezeUpdates: temporarily freezes a window such that it won’t receive
	// expose events. The window will begin receiving expose events again when
	// gdk_window_thaw_updates() is called. If gdk_window_freeze_updates() has
	// been called more than once, gdk_window_thaw_updates() must be called an
	// equal number of times to begin processing exposes.
	FreezeUpdates()
	// Fullscreen moves the window into fullscreen mode. This means the window
	// covers the entire screen and is above any panels or task bars.
	//
	// If the window was already fullscreen, then this function does nothing.
	//
	// On X11, asks the window manager to put @window in a fullscreen state, if
	// the window manager supports this operation. Not all window managers
	// support this, and some deliberately ignore it or don’t have a concept of
	// “fullscreen”; so you can’t rely on the fullscreenification actually
	// happening. But it will happen with most standard window managers, and GDK
	// makes a best effort to get it to happen.
	Fullscreen()
	// FullscreenOnMonitor moves the window into fullscreen mode on the given
	// monitor. This means the window covers the entire screen and is above any
	// panels or task bars.
	//
	// If the window was already fullscreen, then this function does nothing.
	FullscreenOnMonitor(monitor int)
	// GeometryChanged: this function informs GDK that the geometry of an
	// embedded offscreen window has changed. This is necessary for GDK to keep
	// track of which offscreen window the pointer is in.
	GeometryChanged()
	// AcceptFocus determines whether or not the desktop environment shuld be
	// hinted that the window does not want to receive input focus.
	AcceptFocus() bool
	// BackgroundPattern gets the pattern used to clear the background on
	// @window.
	BackgroundPattern() *cairo.Pattern
	// Children gets the list of children of @window known to GDK. This function
	// only returns children created via GDK, so for example it’s useless when
	// used with the root window; it only returns windows an application created
	// itself.
	//
	// The returned list must be freed, but the elements in the list need not
	// be.
	Children() *glib.List
	// ChildrenWithUserData gets the list of children of @window known to GDK
	// with a particular @user_data set on it.
	//
	// The returned list must be freed, but the elements in the list need not
	// be.
	//
	// The list is returned in (relative) stacking order, i.e. the lowest window
	// is first.
	ChildrenWithUserData(userData interface{}) *glib.List
	// ClipRegion computes the region of a window that potentially can be
	// written to by drawing primitives. This region may not take into account
	// other factors such as if the window is obscured by other windows, but no
	// area outside of this region will be affected by drawing primitives.
	ClipRegion() *cairo.Region
	// Composited determines whether @window is composited.
	//
	// See gdk_window_set_composited().
	Composited() bool
	// Cursor retrieves a Cursor pointer for the cursor currently set on the
	// specified Window, or nil. If the return value is nil then there is no
	// custom cursor set on the specified window, and it is using the cursor for
	// its parent window.
	Cursor() Cursor
	// Decorations returns the decorations set on the GdkWindow with
	// gdk_window_set_decorations().
	Decorations() (decorations WMDecoration, ok bool)
	// DeviceCursor retrieves a Cursor pointer for the @device currently set on
	// the specified Window, or nil. If the return value is nil then there is no
	// custom cursor set on the specified window, and it is using the cursor for
	// its parent window.
	DeviceCursor(device Device) Cursor
	// DeviceEvents returns the event mask for @window corresponding to an
	// specific device.
	DeviceEvents(device Device) EventMask
	// DevicePosition obtains the current device position and modifier state.
	// The position is given in coordinates relative to the upper left corner of
	// @window.
	//
	// Use gdk_window_get_device_position_double() if you need subpixel
	// precision.
	DevicePosition(device Device) (x int, y int, mask ModifierType, window Window)
	// DevicePositionDouble obtains the current device position in doubles and
	// modifier state. The position is given in coordinates relative to the
	// upper left corner of @window.
	DevicePositionDouble(device Device) (x float64, y float64, mask ModifierType, window Window)
	// Display gets the Display associated with a Window.
	Display() Display
	// DragProtocol finds out the DND protocol supported by a window.
	DragProtocol() (target Window, dragProtocol DragProtocol)
	// EffectiveParent obtains the parent of @window, as known to GDK. Works
	// like gdk_window_get_parent() for normal windows, but returns the window’s
	// embedder for offscreen windows.
	//
	// See also: gdk_offscreen_window_get_embedder()
	EffectiveParent() Window
	// EffectiveToplevel gets the toplevel window that’s an ancestor of @window.
	//
	// Works like gdk_window_get_toplevel(), but treats an offscreen window's
	// embedder as its parent, using gdk_window_get_effective_parent().
	//
	// See also: gdk_offscreen_window_get_embedder()
	EffectiveToplevel() Window
	// EventCompression: get the current event compression setting for this
	// window.
	EventCompression() bool
	// Events gets the event mask for @window for all master input devices. See
	// gdk_window_set_events().
	Events() EventMask
	// FocusOnMap determines whether or not the desktop environment should be
	// hinted that the window does not want to receive input focus when it is
	// mapped.
	FocusOnMap() bool
	// FrameClock gets the frame clock for the window. The frame clock for a
	// window never changes unless the window is reparented to a new toplevel
	// window.
	FrameClock() FrameClock
	// FrameExtents obtains the bounding box of the window, including window
	// manager titlebar/borders if any. The frame position is given in root
	// window coordinates. To get the position of the window itself (rather than
	// the frame) in root window coordinates, use gdk_window_get_origin().
	FrameExtents() Rectangle
	// FullscreenMode obtains the FullscreenMode of the @window.
	FullscreenMode() FullscreenMode
	// Geometry: any of the return location arguments to this function may be
	// nil, if you aren’t interested in getting the value of that field.
	//
	// The X and Y coordinates returned are relative to the parent window of
	// @window, which for toplevels usually means relative to the window
	// decorations (titlebar, etc.) rather than relative to the root window
	// (screen-size background window).
	//
	// On the X11 platform, the geometry is obtained from the X server, so
	// reflects the latest position of @window; this may be out-of-sync with the
	// position of @window delivered in the most-recently-processed
	// EventConfigure. gdk_window_get_position() in contrast gets the position
	// from the most recent configure event.
	//
	// Note: If @window is not a toplevel, it is much better to call
	// gdk_window_get_position(), gdk_window_get_width() and
	// gdk_window_get_height() instead, because it avoids the roundtrip to the X
	// server and because these functions support the full 32-bit coordinate
	// space, whereas gdk_window_get_geometry() is restricted to the 16-bit
	// coordinates of X11.
	Geometry() (x int, y int, width int, height int)
	// Group returns the group leader window for @window. See
	// gdk_window_set_group().
	Group() Window
	// Height returns the height of the given @window.
	//
	// On the X11 platform the returned size is the size reported in the
	// most-recently-processed configure event, rather than the current size on
	// the X server.
	Height() int
	// ModalHint determines whether or not the window manager is hinted that
	// @window has modal behaviour.
	ModalHint() bool
	// Origin obtains the position of a window in root window coordinates.
	// (Compare with gdk_window_get_position() and gdk_window_get_geometry()
	// which return the position of a window relative to its parent window.)
	Origin() (x int, y int, gint int)
	// Parent obtains the parent of @window, as known to GDK. Does not query the
	// X server; thus this returns the parent as passed to gdk_window_new(), not
	// the actual parent. This should never matter unless you’re using Xlib
	// calls mixed with GDK calls on the X11 platform. It may also matter for
	// toplevel windows, because the window manager may choose to reparent them.
	//
	// Note that you should use gdk_window_get_effective_parent() when writing
	// generic code that walks up a window hierarchy, because
	// gdk_window_get_parent() will most likely not do what you expect if there
	// are offscreen windows in the hierarchy.
	Parent() Window
	// PassThrough returns whether input to the window is passed through to the
	// window below.
	//
	// See gdk_window_set_pass_through() for details
	PassThrough() bool
	// Pointer obtains the current pointer position and modifier state. The
	// position is given in coordinates relative to the upper left corner of
	// @window.
	Pointer() (x int, y int, mask ModifierType, window Window)
	// Position obtains the position of the window as reported in the
	// most-recently-processed EventConfigure. Contrast with
	// gdk_window_get_geometry() which queries the X server for the current
	// window position, regardless of which events have been received or
	// processed.
	//
	// The position coordinates are relative to the window’s parent window.
	Position() (x int, y int)
	// RootCoords obtains the position of a window position in root window
	// coordinates. This is similar to gdk_window_get_origin() but allows you to
	// pass in any position in the window, not just the origin.
	RootCoords(x int, y int) (rootX int, rootY int)
	// RootOrigin obtains the top-left corner of the window manager frame in
	// root window coordinates.
	RootOrigin() (x int, y int)
	// ScaleFactor returns the internal scale factor that maps from window
	// coordiantes to the actual device pixels. On traditional systems this is
	// 1, but on very high density outputs this can be a higher value (often 2).
	//
	// A higher value means that drawing is automatically scaled up to a higher
	// resolution, so any code doing drawing will automatically look nicer.
	// However, if you are supplying pixel-based data the scale value can be
	// used to determine whether to use a pixel resource with higher resolution
	// data.
	//
	// The scale of a window may change during runtime, if this happens a
	// configure event will be sent to the toplevel window.
	ScaleFactor() int
	// Screen gets the Screen associated with a Window.
	Screen() Screen
	// SourceEvents returns the event mask for @window corresponding to the
	// device class specified by @source.
	SourceEvents(source InputSource) EventMask
	// State gets the bitwise OR of the currently active window state flags,
	// from the WindowState enumeration.
	State() WindowState
	// SupportMultidevice returns true if the window is aware of the existence
	// of multiple devices.
	SupportMultidevice() bool
	// Toplevel gets the toplevel window that’s an ancestor of @window.
	//
	// Any window type but GDK_WINDOW_CHILD is considered a toplevel window, as
	// is a GDK_WINDOW_CHILD window that has a root window as parent.
	//
	// Note that you should use gdk_window_get_effective_toplevel() when you
	// want to get to a window’s toplevel as seen on screen, because
	// gdk_window_get_toplevel() will most likely not do what you expect if
	// there are offscreen windows in the hierarchy.
	Toplevel() Window
	// TypeHint: this function returns the type hint set for a window.
	TypeHint() WindowTypeHint
	// UpdateArea transfers ownership of the update area from @window to the
	// caller of the function. That is, after calling this function, @window
	// will no longer have an invalid/dirty region; the update area is removed
	// from @window and handed to you. If a window has no update area,
	// gdk_window_get_update_area() returns nil. You are responsible for calling
	// cairo_region_destroy() on the returned region if it’s non-nil.
	UpdateArea() *cairo.Region
	// UserData retrieves the user data for @window, which is normally the
	// widget that @window belongs to. See gdk_window_set_user_data().
	UserData() interface{}
	// VisibleRegion computes the region of the @window that is potentially
	// visible. This does not necessarily take into account if the window is
	// obscured by other windows, but no area outside of this region is visible.
	VisibleRegion() *cairo.Region
	// Visual gets the Visual describing the pixel format of @window.
	Visual() Visual
	// Width returns the width of the given @window.
	//
	// On the X11 platform the returned size is the size reported in the
	// most-recently-processed configure event, rather than the current size on
	// the X server.
	Width() int
	// WindowType gets the type of the window. See WindowType.
	WindowType() WindowType
	// HasNative checks whether the window has a native window or not. Note that
	// you can use gdk_window_ensure_native() if a native window is needed.
	HasNative() bool
	// Hide: for toplevel windows, withdraws them, so they will no longer be
	// known to the window manager; for all windows, unmaps them, so they won’t
	// be displayed. Normally done automatically as part of gtk_widget_hide().
	Hide()
	// Iconify asks to iconify (minimize) @window. The window manager may choose
	// to ignore the request, but normally will honor it. Using
	// gtk_window_iconify() is preferred, if you have a Window widget.
	//
	// This function only makes sense when @window is a toplevel window.
	Iconify()
	// InputShapeCombineRegion: like gdk_window_shape_combine_region(), but the
	// shape applies only to event handling. Mouse events which happen while the
	// pointer position corresponds to an unset bit in the mask will be passed
	// on the window below @window.
	//
	// An input shape is typically used with RGBA windows. The alpha channel of
	// the window defines which pixels are invisible and allows for nicely
	// antialiased borders, and the input shape controls where the window is
	// “clickable”.
	//
	// On the X11 platform, this requires version 1.1 of the shape extension.
	//
	// On the Win32 platform, this functionality is not present and the function
	// does nothing.
	InputShapeCombineRegion(shapeRegion *cairo.Region, offsetX int, offsetY int)
	// InvalidateMaybeRecurse adds @region to the update area for @window. The
	// update area is the region that needs to be redrawn, or “dirty region.”
	// The call gdk_window_process_updates() sends one or more expose events to
	// the window, which together cover the entire update area. An application
	// would normally redraw the contents of @window in response to those expose
	// events.
	//
	// GDK will call gdk_window_process_all_updates() on your behalf whenever
	// your program returns to the main loop and becomes idle, so normally
	// there’s no need to do that manually, you just need to invalidate regions
	// that you know should be redrawn.
	//
	// The @child_func parameter controls whether the region of each child
	// window that intersects @region will also be invalidated. Only children
	// for which @child_func returns UE will have the area invalidated.
	InvalidateMaybeRecurse(region *cairo.Region, childFunc WindowChildFunc)
	// InvalidateRect: a convenience wrapper around
	// gdk_window_invalidate_region() which invalidates a rectangular region.
	// See gdk_window_invalidate_region() for details.
	InvalidateRect(rect *Rectangle, invalidateChildren bool)
	// InvalidateRegion adds @region to the update area for @window. The update
	// area is the region that needs to be redrawn, or “dirty region.” The call
	// gdk_window_process_updates() sends one or more expose events to the
	// window, which together cover the entire update area. An application would
	// normally redraw the contents of @window in response to those expose
	// events.
	//
	// GDK will call gdk_window_process_all_updates() on your behalf whenever
	// your program returns to the main loop and becomes idle, so normally
	// there’s no need to do that manually, you just need to invalidate regions
	// that you know should be redrawn.
	//
	// The @invalidate_children parameter controls whether the region of each
	// child window that intersects @region will also be invalidated. If false,
	// then the update area for child windows will remain unaffected. See
	// gdk_window_invalidate_maybe_recurse if you need fine grained control over
	// which children are invalidated.
	InvalidateRegion(region *cairo.Region, invalidateChildren bool)
	// IsDestroyed: check to see if a window is destroyed..
	IsDestroyed() bool
	// IsInputOnly determines whether or not the window is an input only window.
	IsInputOnly() bool
	// IsShaped determines whether or not the window is shaped.
	IsShaped() bool
	// IsViewable: check if the window and all ancestors of the window are
	// mapped. (This is not necessarily "viewable" in the X sense, since we only
	// check as far as we have GDK window parents, not to the root window.)
	IsViewable() bool
	// IsVisible checks whether the window has been mapped (with
	// gdk_window_show() or gdk_window_show_unraised()).
	IsVisible() bool
	// Lower lowers @window to the bottom of the Z-order (stacking order), so
	// that other windows with the same parent window appear above @window. This
	// is true whether or not the other windows are visible.
	//
	// If @window is a toplevel, the window manager may choose to deny the
	// request to move the window in the Z-order, gdk_window_lower() only
	// requests the restack, does not guarantee it.
	//
	// Note that gdk_window_show() raises the window again, so don’t call this
	// function before gdk_window_show(). (Try gdk_window_show_unraised().)
	Lower()
	// MarkPaintFromClip: if you call this during a paint (e.g. between
	// gdk_window_begin_paint_region() and gdk_window_end_paint() then GDK will
	// mark the current clip region of the window as being drawn. This is
	// required when mixing GL rendering via gdk_cairo_draw_from_gl() and cairo
	// rendering, as otherwise GDK has no way of knowing when something paints
	// over the GL-drawn regions.
	//
	// This is typically called automatically by GTK+ and you don't need to care
	// about this.
	MarkPaintFromClip(cr *cairo.Context)
	// Maximize maximizes the window. If the window was already maximized, then
	// this function does nothing.
	//
	// On X11, asks the window manager to maximize @window, if the window
	// manager supports this operation. Not all window managers support this,
	// and some deliberately ignore it or don’t have a concept of “maximized”;
	// so you can’t rely on the maximization actually happening. But it will
	// happen with most standard window managers, and GDK makes a best effort to
	// get it to happen.
	//
	// On Windows, reliably maximizes the window.
	Maximize()
	// MergeChildInputShapes merges the input shape masks for any child windows
	// into the input shape mask for @window. i.e. the union of all input masks
	// for @window and its children will become the new input mask for @window.
	// See gdk_window_input_shape_combine_region().
	//
	// This function is distinct from gdk_window_set_child_input_shapes()
	// because it includes @window’s input shape mask in the set of shapes to be
	// merged.
	MergeChildInputShapes()
	// MergeChildShapes merges the shape masks for any child windows into the
	// shape mask for @window. i.e. the union of all masks for @window and its
	// children will become the new mask for @window. See
	// gdk_window_shape_combine_region().
	//
	// This function is distinct from gdk_window_set_child_shapes() because it
	// includes @window’s shape mask in the set of shapes to be merged.
	MergeChildShapes()
	// Move repositions a window relative to its parent window. For toplevel
	// windows, window managers may ignore or modify the move; you should
	// probably use gtk_window_move() on a Window widget anyway, instead of
	// using GDK functions. For child windows, the move will reliably succeed.
	//
	// If you’re also planning to resize the window, use
	// gdk_window_move_resize() to both move and resize simultaneously, for a
	// nicer visual effect.
	Move(x int, y int)
	// MoveRegion: move the part of @window indicated by @region by @dy pixels
	// in the Y direction and @dx pixels in the X direction. The portions of
	// @region that not covered by the new position of @region are invalidated.
	//
	// Child windows are not moved.
	MoveRegion(region *cairo.Region, dx int, dy int)
	// MoveResize: equivalent to calling gdk_window_move() and
	// gdk_window_resize(), except that both operations are performed at once,
	// avoiding strange visual effects. (i.e. the user may be able to see the
	// window first move, then resize, if you don’t use
	// gdk_window_move_resize().)
	MoveResize(x int, y int, width int, height int)
	// MoveToRect moves @window to @rect, aligning their anchor points.
	//
	// @rect is relative to the top-left corner of the window that @window is
	// transient for. @rect_anchor and @window_anchor determine anchor points on
	// @rect and @window to pin together. @rect's anchor point can optionally be
	// offset by @rect_anchor_dx and @rect_anchor_dy, which is equivalent to
	// offsetting the position of @window.
	//
	// @anchor_hints determines how @window will be moved if the anchor points
	// cause it to move off-screen. For example, GDK_ANCHOR_FLIP_X will replace
	// GDK_GRAVITY_NORTH_WEST with GDK_GRAVITY_NORTH_EAST and vice versa if
	// @window extends beyond the left or right edges of the monitor.
	//
	// Connect to the Window::moved-to-rect signal to find out how it was
	// actually positioned.
	MoveToRect(rect *Rectangle, rectAnchor Gravity, windowAnchor Gravity, anchorHints AnchorHints, rectAnchorDx int, rectAnchorDy int)
	// PeekChildren: like gdk_window_get_children(), but does not copy the list
	// of children, so the list does not need to be freed.
	PeekChildren() *glib.List
	// ProcessUpdates sends one or more expose events to @window. The areas in
	// each expose event will cover the entire update area for the window (see
	// gdk_window_invalidate_region() for details). Normally GDK calls
	// gdk_window_process_all_updates() on your behalf, so there’s no need to
	// call this function unless you want to force expose events to be delivered
	// immediately and synchronously (vs. the usual case, where GDK delivers
	// them in an idle handler). Occasionally this is useful to produce nicer
	// scrolling behavior, for example.
	ProcessUpdates(updateChildren bool)
	// Raise raises @window to the top of the Z-order (stacking order), so that
	// other windows with the same parent window appear below @window. This is
	// true whether or not the windows are visible.
	//
	// If @window is a toplevel, the window manager may choose to deny the
	// request to move the window in the Z-order, gdk_window_raise() only
	// requests the restack, does not guarantee it.
	Raise()
	// RegisterDnd registers a window as a potential drop destination.
	RegisterDnd()
	// RemoveFilter: remove a filter previously added with
	// gdk_window_add_filter().
	RemoveFilter(function FilterFunc)
	// Reparent reparents @window into the given @new_parent. The window being
	// reparented will be unmapped as a side effect.
	Reparent(newParent Window, x int, y int)
	// Resize resizes @window; for toplevel windows, asks the window manager to
	// resize the window. The window manager may not allow the resize. When
	// using GTK+, use gtk_window_resize() instead of this low-level GDK
	// function.
	//
	// Windows may not be resized below 1x1.
	//
	// If you’re also planning to move the window, use gdk_window_move_resize()
	// to both move and resize simultaneously, for a nicer visual effect.
	Resize(width int, height int)
	// Restack changes the position of @window in the Z-order (stacking order),
	// so that it is above @sibling (if @above is true) or below @sibling (if
	// @above is false).
	//
	// If @sibling is nil, then this either raises (if @above is true) or lowers
	// the window.
	//
	// If @window is a toplevel, the window manager may choose to deny the
	// request to move the window in the Z-order, gdk_window_restack() only
	// requests the restack, does not guarantee it.
	Restack(sibling Window, above bool)
	// Scroll: scroll the contents of @window, both pixels and children, by the
	// given amount. @window itself does not move. Portions of the window that
	// the scroll operation brings in from offscreen areas are invalidated. The
	// invalidated region may be bigger than what would strictly be necessary.
	//
	// For X11, a minimum area will be invalidated if the window has no
	// subwindows, or if the edges of the window’s parent do not extend beyond
	// the edges of the window. In other cases, a multi-step process is used to
	// scroll the window which may produce temporary visual artifacts and
	// unnecessary invalidations.
	Scroll(dx int, dy int)
	// SetAcceptFocus: setting @accept_focus to false hints the desktop
	// environment that the window doesn’t want to receive input focus.
	//
	// On X, it is the responsibility of the window manager to interpret this
	// hint. ICCCM-compliant window manager usually respect it.
	SetAcceptFocus(acceptFocus bool)
	// SetBackground sets the background color of @window.
	//
	// However, when using GTK+, influence the background of a widget using a
	// style class or CSS — if you’re an application — or with
	// gtk_style_context_set_background() — if you're implementing a custom
	// widget.
	SetBackground(color *Color)
	// SetBackgroundPattern sets the background of @window.
	//
	// A background of nil means that the window won't have any background. On
	// the X11 backend it's also possible to inherit the background from the
	// parent window using gdk_x11_get_parent_relative_pattern().
	//
	// The windowing system will normally fill a window with its background when
	// the window is obscured then exposed.
	SetBackgroundPattern(pattern *cairo.Pattern)
	// SetBackgroundRGBA sets the background color of @window.
	//
	// See also gdk_window_set_background_pattern().
	SetBackgroundRGBA(rgba *RGBA)
	// SetChildInputShapes sets the input shape mask of @window to the union of
	// input shape masks for all children of @window, ignoring the input shape
	// mask of @window itself. Contrast with
	// gdk_window_merge_child_input_shapes() which includes the input shape mask
	// of @window in the masks to be merged.
	SetChildInputShapes()
	// SetChildShapes sets the shape mask of @window to the union of shape masks
	// for all children of @window, ignoring the shape mask of @window itself.
	// Contrast with gdk_window_merge_child_shapes() which includes the shape
	// mask of @window in the masks to be merged.
	SetChildShapes()
	// SetComposited sets a Window as composited, or unsets it. Composited
	// windows do not automatically have their contents drawn to the screen.
	// Drawing is redirected to an offscreen buffer and an expose event is
	// emitted on the parent of the composited window. It is the responsibility
	// of the parent’s expose handler to manually merge the off-screen content
	// onto the screen in whatever way it sees fit.
	//
	// It only makes sense for child windows to be composited; see
	// gdk_window_set_opacity() if you need translucent toplevel windows.
	//
	// An additional effect of this call is that the area of this window is no
	// longer clipped from regions marked for invalidation on its parent. Draws
	// done on the parent window are also no longer clipped by the child.
	//
	// This call is only supported on some systems (currently, only X11 with new
	// enough Xcomposite and Xdamage extensions). You must call
	// gdk_display_supports_composite() to check if setting a window as
	// composited is supported before attempting to do so.
	SetComposited(composited bool)
	// SetCursor sets the default mouse pointer for a Window.
	//
	// Note that @cursor must be for the same display as @window.
	//
	// Use gdk_cursor_new_for_display() or gdk_cursor_new_from_pixbuf() to
	// create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
	// Passing nil for the @cursor argument to gdk_window_set_cursor() means
	// that @window will use the cursor of its parent window. Most windows
	// should use this default.
	SetCursor(cursor Cursor)
	// SetDecorations: “Decorations” are the features the window manager adds to
	// a toplevel Window. This function sets the traditional Motif window
	// manager hints that tell the window manager which decorations you would
	// like your window to have. Usually you should use
	// gtk_window_set_decorated() on a Window instead of using the GDK function
	// directly.
	//
	// The @decorations argument is the logical OR of the fields in the
	// WMDecoration enumeration. If K_DECOR_ALL is included in the mask, the
	// other bits indicate which decorations should be turned off. If
	// K_DECOR_ALL is not included, then the other bits indicate which
	// decorations should be turned on.
	//
	// Most window managers honor a decorations hint of 0 to disable all
	// decorations, but very few honor all possible combinations of bits.
	SetDecorations(decorations WMDecoration)
	// SetDeviceCursor sets a specific Cursor for a given device when it gets
	// inside @window. Use gdk_cursor_new_for_display() or
	// gdk_cursor_new_from_pixbuf() to create the cursor. To make the cursor
	// invisible, use GDK_BLANK_CURSOR. Passing nil for the @cursor argument to
	// gdk_window_set_cursor() means that @window will use the cursor of its
	// parent window. Most windows should use this default.
	SetDeviceCursor(device Device, cursor Cursor)
	// SetDeviceEvents sets the event mask for a given device (Normally a
	// floating device, not attached to any visible pointer) to @window. For
	// example, an event mask including K_BUTTON_PRESS_MASK means the window
	// should report button press events. The event mask is the bitwise OR of
	// values from the EventMask enumeration.
	//
	// See the [input handling overview][event-masks] for details.
	SetDeviceEvents(device Device, eventMask EventMask)
	// SetEventCompression determines whether or not extra unprocessed motion
	// events in the event queue can be discarded. If true only the most recent
	// event will be delivered.
	//
	// Some types of applications, e.g. paint programs, need to see all motion
	// events and will benefit from turning off event compression.
	//
	// By default, event compression is enabled.
	SetEventCompression(eventCompression bool)
	// SetEvents: the event mask for a window determines which events will be
	// reported for that window from all master input devices. For example, an
	// event mask including K_BUTTON_PRESS_MASK means the window should report
	// button press events. The event mask is the bitwise OR of values from the
	// EventMask enumeration.
	//
	// See the [input handling overview][event-masks] for details.
	SetEvents(eventMask EventMask)
	// SetFocusOnMap: setting @focus_on_map to false hints the desktop
	// environment that the window doesn’t want to receive input focus when it
	// is mapped. focus_on_map should be turned off for windows that aren’t
	// triggered interactively (such as popups from network activity).
	//
	// On X, it is the responsibility of the window manager to interpret this
	// hint. Window managers following the freedesktop.org window manager
	// extension specification should respect it.
	SetFocusOnMap(focusOnMap bool)
	// SetFullscreenMode specifies whether the @window should span over all
	// monitors (in a multi-head setup) or only the current monitor when in
	// fullscreen mode.
	//
	// The @mode argument is from the FullscreenMode enumeration. If
	// K_FULLSCREEN_ON_ALL_MONITORS is specified, the fullscreen @window will
	// span over all monitors from the Screen.
	//
	// On X11, searches through the list of monitors from the Screen the ones
	// which delimit the 4 edges of the entire Screen and will ask the window
	// manager to span the @window over these monitors.
	//
	// If the XINERAMA extension is not available or not usable, this function
	// has no effect.
	//
	// Not all window managers support this, so you can’t rely on the fullscreen
	// window to span over the multiple monitors when
	// K_FULLSCREEN_ON_ALL_MONITORS is specified.
	SetFullscreenMode(mode FullscreenMode)
	// SetFunctions sets hints about the window management functions to make
	// available via buttons on the window frame.
	//
	// On the X backend, this function sets the traditional Motif window manager
	// hint for this purpose. However, few window managers do anything reliable
	// or interesting with this hint. Many ignore it entirely.
	//
	// The @functions argument is the logical OR of values from the WMFunction
	// enumeration. If the bitmask includes K_FUNC_ALL, then the other bits
	// indicate which functions to disable; if it doesn’t include K_FUNC_ALL, it
	// indicates which functions to enable.
	SetFunctions(functions WMFunction)
	// SetGeometryHints sets the geometry hints for @window. Hints flagged in
	// @geom_mask are set, hints not flagged in @geom_mask are unset. To unset
	// all hints, use a @geom_mask of 0 and a @geometry of nil.
	//
	// This function provides hints to the windowing system about acceptable
	// sizes for a toplevel window. The purpose of this is to constrain user
	// resizing, but the windowing system will typically (but is not required
	// to) also constrain the current size of the window to the provided values
	// and constrain programatic resizing via gdk_window_resize() or
	// gdk_window_move_resize().
	//
	// Note that on X11, this effect has no effect on windows of type
	// GDK_WINDOW_TEMP or windows where override redirect has been turned on via
	// gdk_window_set_override_redirect() since these windows are not resizable
	// by the user.
	//
	// Since you can’t count on the windowing system doing the constraints for
	// programmatic resizes, you should generally call
	// gdk_window_constrain_size() yourself to determine appropriate sizes.
	SetGeometryHints(geometry *Geometry, geomMask WindowHints)
	// SetGroup sets the group leader window for @window. By default, GDK sets
	// the group leader for all toplevel windows to a global window implicitly
	// created by GDK. With this function you can override this default.
	//
	// The group leader window allows the window manager to distinguish all
	// windows that belong to a single application. It may for example allow
	// users to minimize/unminimize all windows belonging to an application at
	// once. You should only set a non-default group window if your application
	// pretends to be multiple applications.
	SetGroup(leader Window)
	// SetIconList sets a list of icons for the window. One of these will be
	// used to represent the window when it has been iconified. The icon is
	// usually shown in an icon box or some sort of task bar. Which icon size is
	// shown depends on the window manager. The window manager can scale the
	// icon but setting several size icons can give better image quality since
	// the window manager may only need to scale the icon by a small amount or
	// not at all.
	//
	// Note that some platforms don't support window icons.
	SetIconList(pixbufs *glib.List)
	// SetIconName windows may have a name used while minimized, distinct from
	// the name they display in their titlebar. Most of the time this is a bad
	// idea from a user interface standpoint. But you can set such a name with
	// this function, if you like.
	//
	// After calling this with a non-nil @name, calls to gdk_window_set_title()
	// will not update the icon title.
	//
	// Using nil for @name unsets the icon title; further calls to
	// gdk_window_set_title() will again update the icon title as well.
	//
	// Note that some platforms don't support window icons.
	SetIconName(name string)
	// SetKeepAbove: set if @window must be kept above other windows. If the
	// window was already above, then this function does nothing.
	//
	// On X11, asks the window manager to keep @window above, if the window
	// manager supports this operation. Not all window managers support this,
	// and some deliberately ignore it or don’t have a concept of “keep above”;
	// so you can’t rely on the window being kept above. But it will happen with
	// most standard window managers, and GDK makes a best effort to get it to
	// happen.
	SetKeepAbove(setting bool)
	// SetKeepBelow: set if @window must be kept below other windows. If the
	// window was already below, then this function does nothing.
	//
	// On X11, asks the window manager to keep @window below, if the window
	// manager supports this operation. Not all window managers support this,
	// and some deliberately ignore it or don’t have a concept of “keep below”;
	// so you can’t rely on the window being kept below. But it will happen with
	// most standard window managers, and GDK makes a best effort to get it to
	// happen.
	SetKeepBelow(setting bool)
	// SetModalHint: the application can use this hint to tell the window
	// manager that a certain window has modal behaviour. The window manager can
	// use this information to handle modal windows in a special way.
	//
	// You should only use this on windows for which you have previously called
	// gdk_window_set_transient_for()
	SetModalHint(modal bool)
	// SetOpacity: set @window to render as partially transparent, with opacity
	// 0 being fully transparent and 1 fully opaque. (Values of the opacity
	// parameter are clamped to the [0,1] range.)
	//
	// For toplevel windows this depends on support from the windowing system
	// that may not always be there. For instance, On X11, this works only on X
	// screens with a compositing manager running. On Wayland, there is no
	// per-window opacity value that the compositor would apply. Instead, use
	// `gdk_window_set_opaque_region (window, NULL)` to tell the compositor that
	// the entire window is (potentially) non-opaque, and draw your content with
	// alpha, or use gtk_widget_set_opacity() to set an overall opacity for your
	// widgets.
	//
	// For child windows this function only works for non-native windows.
	//
	// For setting up per-pixel alpha topelevels, see
	// gdk_screen_get_rgba_visual(), and for non-toplevels, see
	// gdk_window_set_composited().
	//
	// Support for non-toplevel windows was added in 3.8.
	SetOpacity(opacity float64)
	// SetOpaqueRegion: for optimisation purposes, compositing window managers
	// may like to not draw obscured regions of windows, or turn off blending
	// during for these regions. With RGB windows with no transparency, this is
	// just the shape of the window, but with ARGB32 windows, the compositor
	// does not know what regions of the window are transparent or not.
	//
	// This function only works for toplevel windows.
	//
	// GTK+ will update this property automatically if the @window background is
	// opaque, as we know where the opaque regions are. If your window
	// background is not opaque, please update this property in your
	// Widget::style-updated handler.
	SetOpaqueRegion(region *cairo.Region)
	// SetOverrideRedirect: an override redirect window is not under the control
	// of the window manager. This means it won’t have a titlebar, won’t be
	// minimizable, etc. - it will be entirely under the control of the
	// application. The window manager can’t see the override redirect window at
	// all.
	//
	// Override redirect should only be used for short-lived temporary windows,
	// such as popup menus. Menu uses an override redirect window in its
	// implementation, for example.
	SetOverrideRedirect(overrideRedirect bool)
	// SetPassThrough sets whether input to the window is passed through to the
	// window below.
	//
	// The default value of this is false, which means that pointer events that
	// happen inside the window are send first to the window, but if the event
	// is not selected by the event mask then the event is sent to the parent
	// window, and so on up the hierarchy.
	//
	// If @pass_through is true then such pointer events happen as if the window
	// wasn't there at all, and thus will be sent first to any windows below
	// @window. This is useful if the window is used in a transparent fashion.
	// In the terminology of the web this would be called "pointer-events:
	// none".
	//
	// Note that a window with @pass_through true can still have a subwindow
	// without pass through, so you can get events on a subset of a window. And
	// in that cases you would get the in-between related events such as the
	// pointer enter/leave events on its way to the destination window.
	SetPassThrough(passThrough bool)
	// SetRole: when using GTK+, typically you should use gtk_window_set_role()
	// instead of this low-level function.
	//
	// The window manager and session manager use a window’s role to distinguish
	// it from other kinds of window in the same application. When an
	// application is restarted after being saved in a previous session, all
	// windows with the same title and role are treated as interchangeable. So
	// if you have two windows with the same title that should be distinguished
	// for session management purposes, you should set the role on those
	// windows. It doesn’t matter what string you use for the role, as long as
	// you have a different role for each non-interchangeable kind of window.
	SetRole(role string)
	// SetShadowWidth: newer GTK+ windows using client-side decorations use
	// extra geometry around their frames for effects like shadows and invisible
	// borders. Window managers that want to maximize windows or snap to edges
	// need to know where the extents of the actual frame lie, so that users
	// don’t feel like windows are snapping against random invisible edges.
	//
	// Note that this property is automatically updated by GTK+, so this
	// function should only be used by applications which do not use GTK+ to
	// create toplevel windows.
	SetShadowWidth(left int, right int, top int, bottom int)
	// SetSkipPagerHint toggles whether a window should appear in a pager
	// (workspace switcher, or other desktop utility program that displays a
	// small thumbnail representation of the windows on the desktop). If a
	// window’s semantic type as specified with gdk_window_set_type_hint()
	// already fully describes the window, this function should not be called in
	// addition, instead you should allow the window to be treated according to
	// standard policy for its semantic type.
	SetSkipPagerHint(skipsPager bool)
	// SetSkipTaskbarHint toggles whether a window should appear in a task list
	// or window list. If a window’s semantic type as specified with
	// gdk_window_set_type_hint() already fully describes the window, this
	// function should not be called in addition, instead you should allow the
	// window to be treated according to standard policy for its semantic type.
	SetSkipTaskbarHint(skipsTaskbar bool)
	// SetSourceEvents sets the event mask for any floating device (i.e. not
	// attached to any visible pointer) that has the source defined as @source.
	// This event mask will be applied both to currently existing, newly added
	// devices after this call, and devices being attached/detached.
	SetSourceEvents(source InputSource, eventMask EventMask)
	// SetStartupID: when using GTK+, typically you should use
	// gtk_window_set_startup_id() instead of this low-level function.
	SetStartupID(startupID string)
	// SetStaticGravities: used to set the bit gravity of the given window to
	// static, and flag it so all children get static subwindow gravity. This is
	// used if you are implementing scary features that involve deep knowledge
	// of the windowing system. Don’t worry about it.
	SetStaticGravities(useStatic bool) bool
	// SetSupportMultidevice: this function will enable multidevice features in
	// @window.
	//
	// Multidevice aware windows will need to handle properly multiple, per
	// device enter/leave events, device grabs and grab ownerships.
	SetSupportMultidevice(supportMultidevice bool)
	// SetTitle sets the title of a toplevel window, to be displayed in the
	// titlebar. If you haven’t explicitly set the icon name for the window
	// (using gdk_window_set_icon_name()), the icon name will be set to @title
	// as well. @title must be in UTF-8 encoding (as with all user-readable
	// strings in GDK/GTK+). @title may not be nil.
	SetTitle(title string)
	// SetTransientFor indicates to the window manager that @window is a
	// transient dialog associated with the application window @parent. This
	// allows the window manager to do things like center @window on @parent and
	// keep @window above @parent.
	//
	// See gtk_window_set_transient_for() if you’re using Window or Dialog.
	SetTransientFor(parent Window)
	// SetTypeHint: the application can use this call to provide a hint to the
	// window manager about the functionality of a window. The window manager
	// can use this information when determining the decoration and behaviour of
	// the window.
	//
	// The hint must be set before the window is mapped.
	SetTypeHint(hint WindowTypeHint)
	// SetUrgencyHint toggles whether a window needs the user's urgent
	// attention.
	SetUrgencyHint(urgent bool)
	// SetUserData: for most purposes this function is deprecated in favor of
	// g_object_set_data(). However, for historical reasons GTK+ stores the
	// Widget that owns a Window as user data on the Window. So, custom widget
	// implementations should use this function for that. If GTK+ receives an
	// event for a Window, and the user data for the window is non-nil, GTK+
	// will assume the user data is a Widget, and forward the event to that
	// widget.
	SetUserData(userData gextras.Objector)
	// ShapeCombineRegion makes pixels in @window outside @shape_region be
	// transparent, so that the window may be nonrectangular.
	//
	// If @shape_region is nil, the shape will be unset, so the whole window
	// will be opaque again. @offset_x and @offset_y are ignored if
	// @shape_region is nil.
	//
	// On the X11 platform, this uses an X server extension which is widely
	// available on most common platforms, but not available on very old X
	// servers, and occasionally the implementation will be buggy. On servers
	// without the shape extension, this function will do nothing.
	//
	// This function works on both toplevel and child windows.
	ShapeCombineRegion(shapeRegion *cairo.Region, offsetX int, offsetY int)
	// Show: like gdk_window_show_unraised(), but also raises the window to the
	// top of the window stack (moves the window to the front of the Z-order).
	//
	// This function maps a window so it’s visible onscreen. Its opposite is
	// gdk_window_hide().
	//
	// When implementing a Widget, you should call this function on the widget's
	// Window as part of the “map” method.
	Show()
	// ShowUnraised shows a Window onscreen, but does not modify its stacking
	// order. In contrast, gdk_window_show() will raise the window to the top of
	// the window stack.
	//
	// On the X11 platform, in Xlib terms, this function calls XMapWindow() (it
	// also updates some internal GDK state, which means that you can’t really
	// use XMapWindow() directly on a GDK window).
	ShowUnraised()
	// Stick: “Pins” a window such that it’s on all workspaces and does not
	// scroll with viewports, for window managers that have scrollable
	// viewports. (When using Window, gtk_window_stick() may be more useful.)
	//
	// On the X11 platform, this function depends on window manager support, so
	// may have no effect with many window managers. However, GDK will do the
	// best it can to convince the window manager to stick the window. For
	// window managers that don’t support this operation, there’s nothing you
	// can do to force it to happen.
	Stick()
	// ThawToplevelUpdatesLibgtkOnly thaws a window frozen with
	// gdk_window_freeze_toplevel_updates_libgtk_only().
	//
	// This function is not part of the GDK public API and is only for use by
	// GTK+.
	ThawToplevelUpdatesLibgtkOnly()
	// ThawUpdates thaws a window frozen with gdk_window_freeze_updates().
	ThawUpdates()
	// Unfullscreen moves the window out of fullscreen mode. If the window was
	// not fullscreen, does nothing.
	//
	// On X11, asks the window manager to move @window out of the fullscreen
	// state, if the window manager supports this operation. Not all window
	// managers support this, and some deliberately ignore it or don’t have a
	// concept of “fullscreen”; so you can’t rely on the unfullscreenification
	// actually happening. But it will happen with most standard window
	// managers, and GDK makes a best effort to get it to happen.
	Unfullscreen()
	// Unmaximize unmaximizes the window. If the window wasn’t maximized, then
	// this function does nothing.
	//
	// On X11, asks the window manager to unmaximize @window, if the window
	// manager supports this operation. Not all window managers support this,
	// and some deliberately ignore it or don’t have a concept of “maximized”;
	// so you can’t rely on the unmaximization actually happening. But it will
	// happen with most standard window managers, and GDK makes a best effort to
	// get it to happen.
	//
	// On Windows, reliably unmaximizes the window.
	Unmaximize()
	// Unstick: reverse operation for gdk_window_stick(); see
	// gdk_window_stick(), and gtk_window_unstick().
	Unstick()
	// Withdraw withdraws a window (unmaps it and asks the window manager to
	// forget about it). This function is not really useful as gdk_window_hide()
	// automatically withdraws toplevel windows before hiding them.
	Withdraw()
}

// window implements the Window interface.
type window struct {
	gextras.Objector
}

var _ Window = (*window)(nil)

// WrapWindow wraps a GObject to the right type. It is
// primarily used internally.
func WrapWindow(obj *externglib.Object) Window {
	return Window{
		Objector: obj,
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapWindow(obj), nil
}

// NewWindow constructs a class Window.
func NewWindow(parent Window, attributes *WindowAttr, attributesMask WindowAttributesType) Window {
	var arg1 *C.GdkWindow
	var arg2 *C.GdkWindowAttr
	var arg3 C.gint

	arg1 = (*C.GdkWindow)(unsafe.Pointer(parent.Native()))
	arg2 = (*C.GdkWindowAttr)(unsafe.Pointer(attributes.Native()))
	arg3 = (C.gint)(attributesMask)

	var cret C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_new(parent, attributes, attributesMask)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// AddFilter adds an event filter to @window, allowing you to intercept
// events before they reach GDK. This is a low-level operation and makes it
// easy to break GDK and/or GTK+, so you have to know what you're doing.
// Pass nil for @window to get all events for all windows, instead of events
// for a specific window.
//
// If you are interested in X GenericEvents, bear in mind that
// XGetEventData() has been already called on the event, and
// XFreeEventData() must not be called within @function.
func (w window) AddFilter(function FilterFunc) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_add_filter(arg0, function, data)
}

// Beep emits a short beep associated to @window in the appropriate display,
// if supported. Otherwise, emits a short beep on the display just as
// gdk_display_beep().
func (w window) Beep() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_beep(arg0)
}

// BeginDrawFrame indicates that you are beginning the process of redrawing
// @region on @window, and provides you with a DrawingContext.
//
// If @window is a top level Window, backed by a native window
// implementation, a backing store (offscreen buffer) large enough to
// contain @region will be created. The backing store will be initialized
// with the background color or background surface for @window. Then, all
// drawing operations performed on @window will be diverted to the backing
// store. When you call gdk_window_end_frame(), the contents of the backing
// store will be copied to @window, making it visible on screen. Only the
// part of @window contained in @region will be modified; that is, drawing
// operations are clipped to @region.
//
// The net result of all this is to remove flicker, because the user sees
// the finished product appear all at once when you call
// gdk_window_end_draw_frame(). If you draw to @window directly without
// calling gdk_window_begin_draw_frame(), the user may see flicker as
// individual drawing operations are performed in sequence.
//
// When using GTK+, the widget system automatically places calls to
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() around
// emissions of the `GtkWidget::draw` signal. That is, if you’re drawing the
// contents of the widget yourself, you can assume that the widget has a
// cleared background, is already set as the clip region, and already has a
// backing store. Therefore in most cases, application code in GTK does not
// need to call gdk_window_begin_draw_frame() explicitly.
func (w window) BeginDrawFrame(region *cairo.Region) DrawingContext {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	var cret *C.GdkDrawingContext
	var ret1 DrawingContext

	cret = C.gdk_window_begin_draw_frame(arg0, region)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(DrawingContext)

	return ret1
}

// BeginMoveDrag begins a window move operation (for a toplevel window).
//
// This function assumes that the drag is controlled by the client pointer
// device, use gdk_window_begin_move_drag_for_device() to begin a drag with
// a different device.
func (w window) BeginMoveDrag(button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.guint32

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(button)
	arg2 = C.gint(rootX)
	arg3 = C.gint(rootY)
	arg4 = C.guint32(timestamp)

	C.gdk_window_begin_move_drag(arg0, button, rootX, rootY, timestamp)
}

// BeginMoveDragForDevice begins a window move operation (for a toplevel
// window). You might use this function to implement a “window move grip,”
// for example. The function works best with window managers that support
// the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) but has a fallback
// implementation for other window managers.
func (w window) BeginMoveDragForDevice(device Device, button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.guint32

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg2 = C.gint(button)
	arg3 = C.gint(rootX)
	arg4 = C.gint(rootY)
	arg5 = C.guint32(timestamp)

	C.gdk_window_begin_move_drag_for_device(arg0, device, button, rootX, rootY, timestamp)
}

// BeginPaintRect: a convenience wrapper around
// gdk_window_begin_paint_region() which creates a rectangular region for
// you. See gdk_window_begin_paint_region() for details.
func (w window) BeginPaintRect(rectangle *Rectangle) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkRectangle

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(rectangle.Native()))

	C.gdk_window_begin_paint_rect(arg0, rectangle)
}

// BeginPaintRegion indicates that you are beginning the process of
// redrawing @region. A backing store (offscreen buffer) large enough to
// contain @region will be created. The backing store will be initialized
// with the background color or background surface for @window. Then, all
// drawing operations performed on @window will be diverted to the backing
// store. When you call gdk_window_end_paint(), the backing store will be
// copied to @window, making it visible onscreen. Only the part of @window
// contained in @region will be modified; that is, drawing operations are
// clipped to @region.
//
// The net result of all this is to remove flicker, because the user sees
// the finished product appear all at once when you call
// gdk_window_end_paint(). If you draw to @window directly without calling
// gdk_window_begin_paint_region(), the user may see flicker as individual
// drawing operations are performed in sequence. The clipping and
// background-initializing features of gdk_window_begin_paint_region() are
// conveniences for the programmer, so you can avoid doing that work
// yourself.
//
// When using GTK+, the widget system automatically places calls to
// gdk_window_begin_paint_region() and gdk_window_end_paint() around
// emissions of the expose_event signal. That is, if you’re writing an
// expose event handler, you can assume that the exposed area in EventExpose
// has already been cleared to the window background, is already set as the
// clip region, and already has a backing store. Therefore in most cases,
// application code need not call gdk_window_begin_paint_region(). (You can
// disable the automatic calls around expose events on a widget-by-widget
// basis by calling gtk_widget_set_double_buffered().)
//
// If you call this function multiple times before calling the matching
// gdk_window_end_paint(), the backing stores are pushed onto a stack.
// gdk_window_end_paint() copies the topmost backing store onscreen,
// subtracts the topmost region from all other regions in the stack, and
// pops the stack. All drawing operations affect only the topmost backing
// store in the stack. One matching call to gdk_window_end_paint() is
// required for each call to gdk_window_begin_paint_region().
func (w window) BeginPaintRegion(region *cairo.Region) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_window_begin_paint_region(arg0, region)
}

// BeginResizeDrag begins a window resize operation (for a toplevel window).
//
// This function assumes that the drag is controlled by the client pointer
// device, use gdk_window_begin_resize_drag_for_device() to begin a drag
// with a different device.
func (w window) BeginResizeDrag(edge WindowEdge, button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkWindowEdge
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.guint32

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWindowEdge)(edge)
	arg2 = C.gint(button)
	arg3 = C.gint(rootX)
	arg4 = C.gint(rootY)
	arg5 = C.guint32(timestamp)

	C.gdk_window_begin_resize_drag(arg0, edge, button, rootX, rootY, timestamp)
}

// BeginResizeDragForDevice begins a window resize operation (for a toplevel
// window). You might use this function to implement a “window resize grip,”
// for example; in fact Statusbar uses it. The function works best with
// window managers that support the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) but has a fallback
// implementation for other window managers.
func (w window) BeginResizeDragForDevice(edge WindowEdge, device Device, button int, rootX int, rootY int, timestamp uint32) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkWindowEdge
	var arg2 *C.GdkDevice
	var arg3 C.gint
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.guint32

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWindowEdge)(edge)
	arg2 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg3 = C.gint(button)
	arg4 = C.gint(rootX)
	arg5 = C.gint(rootY)
	arg6 = C.guint32(timestamp)

	C.gdk_window_begin_resize_drag_for_device(arg0, edge, device, button, rootX, rootY, timestamp)
}

// ConfigureFinished does nothing, present only for compatiblity.
func (w window) ConfigureFinished() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_configure_finished(arg0)
}

// CoordsFromParent transforms window coordinates from a parent window to a
// child window, where the parent window is the normal parent as returned by
// gdk_window_get_parent() for normal windows, and the window's embedder as
// returned by gdk_offscreen_window_get_embedder() for offscreen windows.
//
// For normal windows, calling this function is equivalent to subtracting
// the return values of gdk_window_get_position() from the parent
// coordinates. For offscreen windows however (which can be arbitrarily
// transformed), this function calls the GdkWindow::from-embedder: signal to
// translate the coordinates.
//
// You should always use this function when writing generic code that walks
// down a window hierarchy.
//
// See also: gdk_window_coords_to_parent()
func (w window) CoordsFromParent(parentX float64, parentY float64) (x float64, y float64) {
	var arg0 *C.GdkWindow
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gdouble(parentX)
	arg2 = C.gdouble(parentY)

	var arg3 C.gdouble
	var ret3 float64
	var arg4 C.gdouble
	var ret4 float64

	C.gdk_window_coords_from_parent(arg0, parentX, parentY, &arg3, &arg4)

	ret3 = C.gdouble(arg3)
	ret4 = C.gdouble(arg4)

	return ret3, ret4
}

// CoordsToParent transforms window coordinates from a child window to its
// parent window, where the parent window is the normal parent as returned
// by gdk_window_get_parent() for normal windows, and the window's embedder
// as returned by gdk_offscreen_window_get_embedder() for offscreen windows.
//
// For normal windows, calling this function is equivalent to adding the
// return values of gdk_window_get_position() to the child coordinates. For
// offscreen windows however (which can be arbitrarily transformed), this
// function calls the GdkWindow::to-embedder: signal to translate the
// coordinates.
//
// You should always use this function when writing generic code that walks
// up a window hierarchy.
//
// See also: gdk_window_coords_from_parent()
func (w window) CoordsToParent(x float64, y float64) (parentX float64, parentY float64) {
	var arg0 *C.GdkWindow
	var arg1 C.gdouble
	var arg2 C.gdouble

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gdouble(x)
	arg2 = C.gdouble(y)

	var arg3 C.gdouble
	var ret3 float64
	var arg4 C.gdouble
	var ret4 float64

	C.gdk_window_coords_to_parent(arg0, x, y, &arg3, &arg4)

	ret3 = C.gdouble(arg3)
	ret4 = C.gdouble(arg4)

	return ret3, ret4
}

// CreateGLContext creates a new GLContext matching the framebuffer format
// to the visual of the Window. The context is disconnected from any
// particular window or surface.
//
// If the creation of the GLContext failed, @error will be set.
//
// Before using the returned GLContext, you will need to call
// gdk_gl_context_make_current() or gdk_gl_context_realize().
func (w window) CreateGLContext() (glContext GLContext, err error) {
	var arg0 *C.GdkWindow
	var errout *C.GError

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkGLContext
	var ret1 GLContext
	var goerr error

	cret = C.gdk_window_create_gl_context(arg0, &errout)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(GLContext)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// CreateSimilarImageSurface: create a new image surface that is efficient
// to draw on the given @window.
//
// Initially the surface contents are all 0 (transparent if contents have
// transparency, black otherwise.)
//
// The @width and @height of the new surface are not affected by the scaling
// factor of the @window, or by the @scale argument; they are the size of
// the surface in device pixels. If you wish to create an image surface
// capable of holding the contents of @window you can use:
//
//      int scale = gdk_window_get_scale_factor (window);
//      int width = gdk_window_get_width (window) * scale;
//      int height = gdk_window_get_height (window) * scale;
//
//      // format is set elsewhere
//      cairo_surface_t *surface =
//        gdk_window_create_similar_image_surface (window,
//                                                 format,
//                                                 width, height,
//                                                 scale);
//
// Note that unlike cairo_surface_create_similar_image(), the new surface's
// device scale is set to @scale, or to the scale factor of @window if
// @scale is 0.
func (w window) CreateSimilarImageSurface(format cairo.Format, width int, height int, scale int) *cairo.Surface {
	var arg0 *C.GdkWindow
	var arg1 C.cairo_format_t
	var arg2 C.int
	var arg3 C.int
	var arg4 C.int

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.cairo_format_t)(format)
	arg2 = C.int(width)
	arg3 = C.int(height)
	arg4 = C.int(scale)

	var cret *C.cairo_surface_t
	var ret1 *cairo.Surface

	cret = C.gdk_window_create_similar_image_surface(arg0, format, width, height, scale)

	ret1 = cairo.WrapSurface(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// CreateSimilarSurface: create a new surface that is as compatible as
// possible with the given @window. For example the new surface will have
// the same fallback resolution and font options as @window. Generally, the
// new surface will also use the same backend as @window, unless that is not
// possible for some reason. The type of the returned surface may be
// examined with cairo_surface_get_type().
//
// Initially the surface contents are all 0 (transparent if contents have
// transparency, black otherwise.)
func (w window) CreateSimilarSurface(content cairo.Content, width int, height int) *cairo.Surface {
	var arg0 *C.GdkWindow
	var arg1 C.cairo_content_t
	var arg2 C.int
	var arg3 C.int

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.cairo_content_t)(content)
	arg2 = C.int(width)
	arg3 = C.int(height)

	var cret *C.cairo_surface_t
	var ret1 *cairo.Surface

	cret = C.gdk_window_create_similar_surface(arg0, content, width, height)

	ret1 = cairo.WrapSurface(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Deiconify: attempt to deiconify (unminimize) @window. On X11 the window
// manager may choose to ignore the request to deiconify. When using GTK+,
// use gtk_window_deiconify() instead of the Window variant. Or better yet,
// you probably want to use gtk_window_present_with_time(), which raises the
// window, focuses it, unminimizes it, and puts it on the current desktop.
func (w window) Deiconify() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_deiconify(arg0)
}

// Destroy destroys the window system resources associated with @window and
// decrements @window's reference count. The window system resources for all
// children of @window are also destroyed, but the children’s reference
// counts are not decremented.
//
// Note that a window will not be destroyed automatically when its reference
// count reaches zero. You must call this function yourself before that
// happens.
func (w window) Destroy() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_destroy(arg0)
}

func (w window) DestroyNotify() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_destroy_notify(arg0)
}

// EnableSynchronizedConfigure does nothing, present only for compatiblity.
func (w window) EnableSynchronizedConfigure() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_enable_synchronized_configure(arg0)
}

// EndDrawFrame indicates that the drawing of the contents of @window
// started with gdk_window_begin_frame() has been completed.
//
// This function will take care of destroying the DrawingContext.
//
// It is an error to call this function without a matching
// gdk_window_begin_frame() first.
func (w window) EndDrawFrame(context DrawingContext) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDrawingContext

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDrawingContext)(unsafe.Pointer(context.Native()))

	C.gdk_window_end_draw_frame(arg0, context)
}

// EndPaint indicates that the backing store created by the most recent call
// to gdk_window_begin_paint_region() should be copied onscreen and deleted,
// leaving the next-most-recent backing store or no backing store at all as
// the active paint region. See gdk_window_begin_paint_region() for full
// details.
//
// It is an error to call this function without a matching
// gdk_window_begin_paint_region() first.
func (w window) EndPaint() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_end_paint(arg0)
}

// EnsureNative tries to ensure that there is a window-system native window
// for this GdkWindow. This may fail in some situations, returning false.
//
// Offscreen window and children of them can never have native windows.
//
// Some backends may not support native child windows.
func (w window) EnsureNative() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_ensure_native(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Flush: this function does nothing.
func (w window) Flush() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_flush(arg0)
}

// Focus sets keyboard focus to @window. In most cases,
// gtk_window_present_with_time() should be used on a Window, rather than
// calling this function.
func (w window) Focus(timestamp uint32) {
	var arg0 *C.GdkWindow
	var arg1 C.guint32

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.guint32(timestamp)

	C.gdk_window_focus(arg0, timestamp)
}

// FreezeToplevelUpdatesLibgtkOnly: temporarily freezes a window and all its
// descendants such that it won't receive expose events. The window will
// begin receiving expose events again when
// gdk_window_thaw_toplevel_updates_libgtk_only() is called. If
// gdk_window_freeze_toplevel_updates_libgtk_only() has been called more
// than once, gdk_window_thaw_toplevel_updates_libgtk_only() must be called
// an equal number of times to begin processing exposes.
//
// This function is not part of the GDK public API and is only for use by
// GTK+.
func (w window) FreezeToplevelUpdatesLibgtkOnly() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_freeze_toplevel_updates_libgtk_only(arg0)
}

// FreezeUpdates: temporarily freezes a window such that it won’t receive
// expose events. The window will begin receiving expose events again when
// gdk_window_thaw_updates() is called. If gdk_window_freeze_updates() has
// been called more than once, gdk_window_thaw_updates() must be called an
// equal number of times to begin processing exposes.
func (w window) FreezeUpdates() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_freeze_updates(arg0)
}

// Fullscreen moves the window into fullscreen mode. This means the window
// covers the entire screen and is above any panels or task bars.
//
// If the window was already fullscreen, then this function does nothing.
//
// On X11, asks the window manager to put @window in a fullscreen state, if
// the window manager supports this operation. Not all window managers
// support this, and some deliberately ignore it or don’t have a concept of
// “fullscreen”; so you can’t rely on the fullscreenification actually
// happening. But it will happen with most standard window managers, and GDK
// makes a best effort to get it to happen.
func (w window) Fullscreen() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_fullscreen(arg0)
}

// FullscreenOnMonitor moves the window into fullscreen mode on the given
// monitor. This means the window covers the entire screen and is above any
// panels or task bars.
//
// If the window was already fullscreen, then this function does nothing.
func (w window) FullscreenOnMonitor(monitor int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(monitor)

	C.gdk_window_fullscreen_on_monitor(arg0, monitor)
}

// GeometryChanged: this function informs GDK that the geometry of an
// embedded offscreen window has changed. This is necessary for GDK to keep
// track of which offscreen window the pointer is in.
func (w window) GeometryChanged() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_geometry_changed(arg0)
}

// AcceptFocus determines whether or not the desktop environment shuld be
// hinted that the window does not want to receive input focus.
func (w window) AcceptFocus() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_accept_focus(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// BackgroundPattern gets the pattern used to clear the background on
// @window.
func (w window) BackgroundPattern() *cairo.Pattern {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.cairo_pattern_t
	var ret1 *cairo.Pattern

	cret = C.gdk_window_get_background_pattern(arg0)

	ret1 = cairo.WrapPattern(unsafe.Pointer(cret))

	return ret1
}

// Children gets the list of children of @window known to GDK. This function
// only returns children created via GDK, so for example it’s useless when
// used with the root window; it only returns windows an application created
// itself.
//
// The returned list must be freed, but the elements in the list need not
// be.
func (w window) Children() *glib.List {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GList
	var ret1 *glib.List

	cret = C.gdk_window_get_children(arg0)

	ret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// ChildrenWithUserData gets the list of children of @window known to GDK
// with a particular @user_data set on it.
//
// The returned list must be freed, but the elements in the list need not
// be.
//
// The list is returned in (relative) stacking order, i.e. the lowest window
// is first.
func (w window) ChildrenWithUserData(userData interface{}) *glib.List {
	var arg0 *C.GdkWindow
	var arg1 C.gpointer

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gpointer(userData)

	var cret *C.GList
	var ret1 *glib.List

	cret = C.gdk_window_get_children_with_user_data(arg0, userData)

	ret1 = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// ClipRegion computes the region of a window that potentially can be
// written to by drawing primitives. This region may not take into account
// other factors such as if the window is obscured by other windows, but no
// area outside of this region will be affected by drawing primitives.
func (w window) ClipRegion() *cairo.Region {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.cairo_region_t
	var ret1 *cairo.Region

	cret = C.gdk_window_get_clip_region(arg0)

	ret1 = cairo.WrapRegion(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *cairo.Region) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Composited determines whether @window is composited.
//
// See gdk_window_set_composited().
func (w window) Composited() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_composited(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Cursor retrieves a Cursor pointer for the cursor currently set on the
// specified Window, or nil. If the return value is nil then there is no
// custom cursor set on the specified window, and it is using the cursor for
// its parent window.
func (w window) Cursor() Cursor {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkCursor
	var ret1 Cursor

	cret = C.gdk_window_get_cursor(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Cursor)

	return ret1
}

// Decorations returns the decorations set on the GdkWindow with
// gdk_window_set_decorations().
func (w window) Decorations() (decorations WMDecoration, ok bool) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.GdkWMDecoration
	var ret1 *WMDecoration
	var cret C.gboolean
	var ret2 bool

	cret = C.gdk_window_get_decorations(arg0, &arg1)

	ret1 = *WMDecoration(arg1)
	ret2 = C.bool(cret) != C.false

	return ret1, ret2
}

// DeviceCursor retrieves a Cursor pointer for the @device currently set on
// the specified Window, or nil. If the return value is nil then there is no
// custom cursor set on the specified window, and it is using the cursor for
// its parent window.
func (w window) DeviceCursor(device Device) Cursor {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret *C.GdkCursor
	var ret1 Cursor

	cret = C.gdk_window_get_device_cursor(arg0, device)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Cursor)

	return ret1
}

// DeviceEvents returns the event mask for @window corresponding to an
// specific device.
func (w window) DeviceEvents(device Device) EventMask {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret C.GdkEventMask
	var ret1 EventMask

	cret = C.gdk_window_get_device_events(arg0, device)

	ret1 = EventMask(cret)

	return ret1
}

// DevicePosition obtains the current device position and modifier state.
// The position is given in coordinates relative to the upper left corner of
// @window.
//
// Use gdk_window_get_device_position_double() if you need subpixel
// precision.
func (w window) DevicePosition(device Device) (x int, y int, mask ModifierType, window Window) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var arg2 C.gint
	var ret2 int
	var arg3 C.gint
	var ret3 int
	var arg4 C.GdkModifierType
	var ret4 *ModifierType
	var cret *C.GdkWindow
	var ret4 Window

	cret = C.gdk_window_get_device_position(arg0, device, &arg2, &arg3, &arg4)

	ret2 = C.gint(arg2)
	ret3 = C.gint(arg3)
	ret4 = *ModifierType(arg4)
	ret4 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret2, ret3, ret4, ret4
}

// DevicePositionDouble obtains the current device position in doubles and
// modifier state. The position is given in coordinates relative to the
// upper left corner of @window.
func (w window) DevicePositionDouble(device Device) (x float64, y float64, mask ModifierType, window Window) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var arg2 C.gdouble
	var ret2 float64
	var arg3 C.gdouble
	var ret3 float64
	var arg4 C.GdkModifierType
	var ret4 *ModifierType
	var cret *C.GdkWindow
	var ret4 Window

	cret = C.gdk_window_get_device_position_double(arg0, device, &arg2, &arg3, &arg4)

	ret2 = C.gdouble(arg2)
	ret3 = C.gdouble(arg3)
	ret4 = *ModifierType(arg4)
	ret4 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret2, ret3, ret4, ret4
}

// Display gets the Display associated with a Window.
func (w window) Display() Display {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkDisplay
	var ret1 Display

	cret = C.gdk_window_get_display(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return ret1
}

// DragProtocol finds out the DND protocol supported by a window.
func (w window) DragProtocol() (target Window, dragProtocol DragProtocol) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 *C.GdkWindow
	var ret1 Window
	var cret C.GdkDragProtocol
	var ret2 DragProtocol

	cret = C.gdk_window_get_drag_protocol(arg0, &arg1)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(arg1.Native()))).(Window)
	ret2 = DragProtocol(cret)

	return ret1, ret2
}

// EffectiveParent obtains the parent of @window, as known to GDK. Works
// like gdk_window_get_parent() for normal windows, but returns the window’s
// embedder for offscreen windows.
//
// See also: gdk_offscreen_window_get_embedder()
func (w window) EffectiveParent() Window {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_get_effective_parent(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// EffectiveToplevel gets the toplevel window that’s an ancestor of @window.
//
// Works like gdk_window_get_toplevel(), but treats an offscreen window's
// embedder as its parent, using gdk_window_get_effective_parent().
//
// See also: gdk_offscreen_window_get_embedder()
func (w window) EffectiveToplevel() Window {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_get_effective_toplevel(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// EventCompression: get the current event compression setting for this
// window.
func (w window) EventCompression() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_event_compression(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Events gets the event mask for @window for all master input devices. See
// gdk_window_set_events().
func (w window) Events() EventMask {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkEventMask
	var ret1 EventMask

	cret = C.gdk_window_get_events(arg0)

	ret1 = EventMask(cret)

	return ret1
}

// FocusOnMap determines whether or not the desktop environment should be
// hinted that the window does not want to receive input focus when it is
// mapped.
func (w window) FocusOnMap() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_focus_on_map(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// FrameClock gets the frame clock for the window. The frame clock for a
// window never changes unless the window is reparented to a new toplevel
// window.
func (w window) FrameClock() FrameClock {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkFrameClock
	var ret1 FrameClock

	cret = C.gdk_window_get_frame_clock(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(FrameClock)

	return ret1
}

// FrameExtents obtains the bounding box of the window, including window
// manager titlebar/borders if any. The frame position is given in root
// window coordinates. To get the position of the window itself (rather than
// the frame) in root window coordinates, use gdk_window_get_origin().
func (w window) FrameExtents() Rectangle {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.GdkRectangle
	var ret1 *Rectangle

	C.gdk_window_get_frame_extents(arg0, &arg1)

	ret1 = WrapRectangle(unsafe.Pointer(arg1))

	return ret1
}

// FullscreenMode obtains the FullscreenMode of the @window.
func (w window) FullscreenMode() FullscreenMode {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkFullscreenMode
	var ret1 FullscreenMode

	cret = C.gdk_window_get_fullscreen_mode(arg0)

	ret1 = FullscreenMode(cret)

	return ret1
}

// Geometry: any of the return location arguments to this function may be
// nil, if you aren’t interested in getting the value of that field.
//
// The X and Y coordinates returned are relative to the parent window of
// @window, which for toplevels usually means relative to the window
// decorations (titlebar, etc.) rather than relative to the root window
// (screen-size background window).
//
// On the X11 platform, the geometry is obtained from the X server, so
// reflects the latest position of @window; this may be out-of-sync with the
// position of @window delivered in the most-recently-processed
// EventConfigure. gdk_window_get_position() in contrast gets the position
// from the most recent configure event.
//
// Note: If @window is not a toplevel, it is much better to call
// gdk_window_get_position(), gdk_window_get_width() and
// gdk_window_get_height() instead, because it avoids the roundtrip to the X
// server and because these functions support the full 32-bit coordinate
// space, whereas gdk_window_get_geometry() is restricted to the 16-bit
// coordinates of X11.
func (w window) Geometry() (x int, y int, width int, height int) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int
	var arg3 C.gint
	var ret3 int
	var arg4 C.gint
	var ret4 int

	C.gdk_window_get_geometry(arg0, &arg1, &arg2, &arg3, &arg4)

	ret1 = C.gint(arg1)
	ret2 = C.gint(arg2)
	ret3 = C.gint(arg3)
	ret4 = C.gint(arg4)

	return ret1, ret2, ret3, ret4
}

// Group returns the group leader window for @window. See
// gdk_window_set_group().
func (w window) Group() Window {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_get_group(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// Height returns the height of the given @window.
//
// On the X11 platform the returned size is the size reported in the
// most-recently-processed configure event, rather than the current size on
// the X server.
func (w window) Height() int {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.int
	var ret1 int

	cret = C.gdk_window_get_height(arg0)

	ret1 = C.int(cret)

	return ret1
}

// ModalHint determines whether or not the window manager is hinted that
// @window has modal behaviour.
func (w window) ModalHint() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_modal_hint(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Origin obtains the position of a window in root window coordinates.
// (Compare with gdk_window_get_position() and gdk_window_get_geometry()
// which return the position of a window relative to its parent window.)
func (w window) Origin() (x int, y int, gint int) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int
	var cret C.gint
	var ret3 int

	cret = C.gdk_window_get_origin(arg0, &arg1, &arg2)

	ret1 = C.gint(arg1)
	ret2 = C.gint(arg2)
	ret3 = C.gint(cret)

	return ret1, ret2, ret3
}

// Parent obtains the parent of @window, as known to GDK. Does not query the
// X server; thus this returns the parent as passed to gdk_window_new(), not
// the actual parent. This should never matter unless you’re using Xlib
// calls mixed with GDK calls on the X11 platform. It may also matter for
// toplevel windows, because the window manager may choose to reparent them.
//
// Note that you should use gdk_window_get_effective_parent() when writing
// generic code that walks up a window hierarchy, because
// gdk_window_get_parent() will most likely not do what you expect if there
// are offscreen windows in the hierarchy.
func (w window) Parent() Window {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_get_parent(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// PassThrough returns whether input to the window is passed through to the
// window below.
//
// See gdk_window_set_pass_through() for details
func (w window) PassThrough() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_pass_through(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Pointer obtains the current pointer position and modifier state. The
// position is given in coordinates relative to the upper left corner of
// @window.
func (w window) Pointer() (x int, y int, mask ModifierType, window Window) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int
	var arg3 C.GdkModifierType
	var ret3 *ModifierType
	var cret *C.GdkWindow
	var ret4 Window

	cret = C.gdk_window_get_pointer(arg0, &arg1, &arg2, &arg3)

	ret1 = C.gint(arg1)
	ret2 = C.gint(arg2)
	ret3 = *ModifierType(arg3)
	ret4 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1, ret2, ret3, ret4
}

// Position obtains the position of the window as reported in the
// most-recently-processed EventConfigure. Contrast with
// gdk_window_get_geometry() which queries the X server for the current
// window position, regardless of which events have been received or
// processed.
//
// The position coordinates are relative to the window’s parent window.
func (w window) Position() (x int, y int) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int

	C.gdk_window_get_position(arg0, &arg1, &arg2)

	ret1 = C.gint(arg1)
	ret2 = C.gint(arg2)

	return ret1, ret2
}

// RootCoords obtains the position of a window position in root window
// coordinates. This is similar to gdk_window_get_origin() but allows you to
// pass in any position in the window, not just the origin.
func (w window) RootCoords(x int, y int) (rootX int, rootY int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	var arg3 C.gint
	var ret3 int
	var arg4 C.gint
	var ret4 int

	C.gdk_window_get_root_coords(arg0, x, y, &arg3, &arg4)

	ret3 = C.gint(arg3)
	ret4 = C.gint(arg4)

	return ret3, ret4
}

// RootOrigin obtains the top-left corner of the window manager frame in
// root window coordinates.
func (w window) RootOrigin() (x int, y int) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gint
	var ret1 int
	var arg2 C.gint
	var ret2 int

	C.gdk_window_get_root_origin(arg0, &arg1, &arg2)

	ret1 = C.gint(arg1)
	ret2 = C.gint(arg2)

	return ret1, ret2
}

// ScaleFactor returns the internal scale factor that maps from window
// coordiantes to the actual device pixels. On traditional systems this is
// 1, but on very high density outputs this can be a higher value (often 2).
//
// A higher value means that drawing is automatically scaled up to a higher
// resolution, so any code doing drawing will automatically look nicer.
// However, if you are supplying pixel-based data the scale value can be
// used to determine whether to use a pixel resource with higher resolution
// data.
//
// The scale of a window may change during runtime, if this happens a
// configure event will be sent to the toplevel window.
func (w window) ScaleFactor() int {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gint
	var ret1 int

	cret = C.gdk_window_get_scale_factor(arg0)

	ret1 = C.gint(cret)

	return ret1
}

// Screen gets the Screen associated with a Window.
func (w window) Screen() Screen {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkScreen
	var ret1 Screen

	cret = C.gdk_window_get_screen(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Screen)

	return ret1
}

// SourceEvents returns the event mask for @window corresponding to the
// device class specified by @source.
func (w window) SourceEvents(source InputSource) EventMask {
	var arg0 *C.GdkWindow
	var arg1 C.GdkInputSource

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkInputSource)(source)

	var cret C.GdkEventMask
	var ret1 EventMask

	cret = C.gdk_window_get_source_events(arg0, source)

	ret1 = EventMask(cret)

	return ret1
}

// State gets the bitwise OR of the currently active window state flags,
// from the WindowState enumeration.
func (w window) State() WindowState {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkWindowState
	var ret1 WindowState

	cret = C.gdk_window_get_state(arg0)

	ret1 = WindowState(cret)

	return ret1
}

// SupportMultidevice returns true if the window is aware of the existence
// of multiple devices.
func (w window) SupportMultidevice() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_get_support_multidevice(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Toplevel gets the toplevel window that’s an ancestor of @window.
//
// Any window type but GDK_WINDOW_CHILD is considered a toplevel window, as
// is a GDK_WINDOW_CHILD window that has a root window as parent.
//
// Note that you should use gdk_window_get_effective_toplevel() when you
// want to get to a window’s toplevel as seen on screen, because
// gdk_window_get_toplevel() will most likely not do what you expect if
// there are offscreen windows in the hierarchy.
func (w window) Toplevel() Window {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkWindow
	var ret1 Window

	cret = C.gdk_window_get_toplevel(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return ret1
}

// TypeHint: this function returns the type hint set for a window.
func (w window) TypeHint() WindowTypeHint {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkWindowTypeHint
	var ret1 WindowTypeHint

	cret = C.gdk_window_get_type_hint(arg0)

	ret1 = WindowTypeHint(cret)

	return ret1
}

// UpdateArea transfers ownership of the update area from @window to the
// caller of the function. That is, after calling this function, @window
// will no longer have an invalid/dirty region; the update area is removed
// from @window and handed to you. If a window has no update area,
// gdk_window_get_update_area() returns nil. You are responsible for calling
// cairo_region_destroy() on the returned region if it’s non-nil.
func (w window) UpdateArea() *cairo.Region {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.cairo_region_t
	var ret1 *cairo.Region

	cret = C.gdk_window_get_update_area(arg0)

	ret1 = cairo.WrapRegion(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *cairo.Region) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// UserData retrieves the user data for @window, which is normally the
// widget that @window belongs to. See gdk_window_set_user_data().
func (w window) UserData() interface{} {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var arg1 C.gpointer
	var ret1 interface{}

	C.gdk_window_get_user_data(arg0, &arg1)

	ret1 = C.gpointer(arg1)

	return ret1
}

// VisibleRegion computes the region of the @window that is potentially
// visible. This does not necessarily take into account if the window is
// obscured by other windows, but no area outside of this region is visible.
func (w window) VisibleRegion() *cairo.Region {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.cairo_region_t
	var ret1 *cairo.Region

	cret = C.gdk_window_get_visible_region(arg0)

	ret1 = cairo.WrapRegion(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *cairo.Region) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}

// Visual gets the Visual describing the pixel format of @window.
func (w window) Visual() Visual {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GdkVisual
	var ret1 Visual

	cret = C.gdk_window_get_visual(arg0)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Visual)

	return ret1
}

// Width returns the width of the given @window.
//
// On the X11 platform the returned size is the size reported in the
// most-recently-processed configure event, rather than the current size on
// the X server.
func (w window) Width() int {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.int
	var ret1 int

	cret = C.gdk_window_get_width(arg0)

	ret1 = C.int(cret)

	return ret1
}

// WindowType gets the type of the window. See WindowType.
func (w window) WindowType() WindowType {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.GdkWindowType
	var ret1 WindowType

	cret = C.gdk_window_get_window_type(arg0)

	ret1 = WindowType(cret)

	return ret1
}

// HasNative checks whether the window has a native window or not. Note that
// you can use gdk_window_ensure_native() if a native window is needed.
func (w window) HasNative() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_has_native(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Hide: for toplevel windows, withdraws them, so they will no longer be
// known to the window manager; for all windows, unmaps them, so they won’t
// be displayed. Normally done automatically as part of gtk_widget_hide().
func (w window) Hide() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_hide(arg0)
}

// Iconify asks to iconify (minimize) @window. The window manager may choose
// to ignore the request, but normally will honor it. Using
// gtk_window_iconify() is preferred, if you have a Window widget.
//
// This function only makes sense when @window is a toplevel window.
func (w window) Iconify() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_iconify(arg0)
}

// InputShapeCombineRegion: like gdk_window_shape_combine_region(), but the
// shape applies only to event handling. Mouse events which happen while the
// pointer position corresponds to an unset bit in the mask will be passed
// on the window below @window.
//
// An input shape is typically used with RGBA windows. The alpha channel of
// the window defines which pixels are invisible and allows for nicely
// antialiased borders, and the input shape controls where the window is
// “clickable”.
//
// On the X11 platform, this requires version 1.1 of the shape extension.
//
// On the Win32 platform, this functionality is not present and the function
// does nothing.
func (w window) InputShapeCombineRegion(shapeRegion *cairo.Region, offsetX int, offsetY int) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(shapeRegion.Native()))
	arg2 = C.gint(offsetX)
	arg3 = C.gint(offsetY)

	C.gdk_window_input_shape_combine_region(arg0, shapeRegion, offsetX, offsetY)
}

// InvalidateMaybeRecurse adds @region to the update area for @window. The
// update area is the region that needs to be redrawn, or “dirty region.”
// The call gdk_window_process_updates() sends one or more expose events to
// the window, which together cover the entire update area. An application
// would normally redraw the contents of @window in response to those expose
// events.
//
// GDK will call gdk_window_process_all_updates() on your behalf whenever
// your program returns to the main loop and becomes idle, so normally
// there’s no need to do that manually, you just need to invalidate regions
// that you know should be redrawn.
//
// The @child_func parameter controls whether the region of each child
// window that intersects @region will also be invalidated. Only children
// for which @child_func returns UE will have the area invalidated.
func (w window) InvalidateMaybeRecurse(region *cairo.Region, childFunc WindowChildFunc) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_invalidate_maybe_recurse(arg0, region, childFunc, userData)
}

// InvalidateRect: a convenience wrapper around
// gdk_window_invalidate_region() which invalidates a rectangular region.
// See gdk_window_invalidate_region() for details.
func (w window) InvalidateRect(rect *Rectangle, invalidateChildren bool) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkRectangle
	var arg2 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))
	if invalidateChildren {
		arg2 = C.gboolean(1)
	}

	C.gdk_window_invalidate_rect(arg0, rect, invalidateChildren)
}

// InvalidateRegion adds @region to the update area for @window. The update
// area is the region that needs to be redrawn, or “dirty region.” The call
// gdk_window_process_updates() sends one or more expose events to the
// window, which together cover the entire update area. An application would
// normally redraw the contents of @window in response to those expose
// events.
//
// GDK will call gdk_window_process_all_updates() on your behalf whenever
// your program returns to the main loop and becomes idle, so normally
// there’s no need to do that manually, you just need to invalidate regions
// that you know should be redrawn.
//
// The @invalidate_children parameter controls whether the region of each
// child window that intersects @region will also be invalidated. If false,
// then the update area for child windows will remain unaffected. See
// gdk_window_invalidate_maybe_recurse if you need fine grained control over
// which children are invalidated.
func (w window) InvalidateRegion(region *cairo.Region, invalidateChildren bool) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t
	var arg2 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	if invalidateChildren {
		arg2 = C.gboolean(1)
	}

	C.gdk_window_invalidate_region(arg0, region, invalidateChildren)
}

// IsDestroyed: check to see if a window is destroyed..
func (w window) IsDestroyed() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_is_destroyed(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsInputOnly determines whether or not the window is an input only window.
func (w window) IsInputOnly() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_is_input_only(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsShaped determines whether or not the window is shaped.
func (w window) IsShaped() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_is_shaped(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsViewable: check if the window and all ancestors of the window are
// mapped. (This is not necessarily "viewable" in the X sense, since we only
// check as far as we have GDK window parents, not to the root window.)
func (w window) IsViewable() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_is_viewable(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// IsVisible checks whether the window has been mapped (with
// gdk_window_show() or gdk_window_show_unraised()).
func (w window) IsVisible() bool {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_is_visible(arg0)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// Lower lowers @window to the bottom of the Z-order (stacking order), so
// that other windows with the same parent window appear above @window. This
// is true whether or not the other windows are visible.
//
// If @window is a toplevel, the window manager may choose to deny the
// request to move the window in the Z-order, gdk_window_lower() only
// requests the restack, does not guarantee it.
//
// Note that gdk_window_show() raises the window again, so don’t call this
// function before gdk_window_show(). (Try gdk_window_show_unraised().)
func (w window) Lower() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_lower(arg0)
}

// MarkPaintFromClip: if you call this during a paint (e.g. between
// gdk_window_begin_paint_region() and gdk_window_end_paint() then GDK will
// mark the current clip region of the window as being drawn. This is
// required when mixing GL rendering via gdk_cairo_draw_from_gl() and cairo
// rendering, as otherwise GDK has no way of knowing when something paints
// over the GL-drawn regions.
//
// This is typically called automatically by GTK+ and you don't need to care
// about this.
func (w window) MarkPaintFromClip(cr *cairo.Context) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_t

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gdk_window_mark_paint_from_clip(arg0, cr)
}

// Maximize maximizes the window. If the window was already maximized, then
// this function does nothing.
//
// On X11, asks the window manager to maximize @window, if the window
// manager supports this operation. Not all window managers support this,
// and some deliberately ignore it or don’t have a concept of “maximized”;
// so you can’t rely on the maximization actually happening. But it will
// happen with most standard window managers, and GDK makes a best effort to
// get it to happen.
//
// On Windows, reliably maximizes the window.
func (w window) Maximize() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_maximize(arg0)
}

// MergeChildInputShapes merges the input shape masks for any child windows
// into the input shape mask for @window. i.e. the union of all input masks
// for @window and its children will become the new input mask for @window.
// See gdk_window_input_shape_combine_region().
//
// This function is distinct from gdk_window_set_child_input_shapes()
// because it includes @window’s input shape mask in the set of shapes to be
// merged.
func (w window) MergeChildInputShapes() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_merge_child_input_shapes(arg0)
}

// MergeChildShapes merges the shape masks for any child windows into the
// shape mask for @window. i.e. the union of all masks for @window and its
// children will become the new mask for @window. See
// gdk_window_shape_combine_region().
//
// This function is distinct from gdk_window_set_child_shapes() because it
// includes @window’s shape mask in the set of shapes to be merged.
func (w window) MergeChildShapes() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_merge_child_shapes(arg0)
}

// Move repositions a window relative to its parent window. For toplevel
// windows, window managers may ignore or modify the move; you should
// probably use gtk_window_move() on a Window widget anyway, instead of
// using GDK functions. For child windows, the move will reliably succeed.
//
// If you’re also planning to resize the window, use
// gdk_window_move_resize() to both move and resize simultaneously, for a
// nicer visual effect.
func (w window) Move(x int, y int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	C.gdk_window_move(arg0, x, y)
}

// MoveRegion: move the part of @window indicated by @region by @dy pixels
// in the Y direction and @dx pixels in the X direction. The portions of
// @region that not covered by the new position of @region are invalidated.
//
// Child windows are not moved.
func (w window) MoveRegion(region *cairo.Region, dx int, dy int) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	arg2 = C.gint(dx)
	arg3 = C.gint(dy)

	C.gdk_window_move_region(arg0, region, dx, dy)
}

// MoveResize: equivalent to calling gdk_window_move() and
// gdk_window_resize(), except that both operations are performed at once,
// avoiding strange visual effects. (i.e. the user may be able to see the
// window first move, then resize, if you don’t use
// gdk_window_move_resize().)
func (w window) MoveResize(x int, y int, width int, height int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)
	arg3 = C.gint(width)
	arg4 = C.gint(height)

	C.gdk_window_move_resize(arg0, x, y, width, height)
}

// MoveToRect moves @window to @rect, aligning their anchor points.
//
// @rect is relative to the top-left corner of the window that @window is
// transient for. @rect_anchor and @window_anchor determine anchor points on
// @rect and @window to pin together. @rect's anchor point can optionally be
// offset by @rect_anchor_dx and @rect_anchor_dy, which is equivalent to
// offsetting the position of @window.
//
// @anchor_hints determines how @window will be moved if the anchor points
// cause it to move off-screen. For example, GDK_ANCHOR_FLIP_X will replace
// GDK_GRAVITY_NORTH_WEST with GDK_GRAVITY_NORTH_EAST and vice versa if
// @window extends beyond the left or right edges of the monitor.
//
// Connect to the Window::moved-to-rect signal to find out how it was
// actually positioned.
func (w window) MoveToRect(rect *Rectangle, rectAnchor Gravity, windowAnchor Gravity, anchorHints AnchorHints, rectAnchorDx int, rectAnchorDy int) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkRectangle
	var arg2 C.GdkGravity
	var arg3 C.GdkGravity
	var arg4 C.GdkAnchorHints
	var arg5 C.gint
	var arg6 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))
	arg2 = (C.GdkGravity)(rectAnchor)
	arg3 = (C.GdkGravity)(windowAnchor)
	arg4 = (C.GdkAnchorHints)(anchorHints)
	arg5 = C.gint(rectAnchorDx)
	arg6 = C.gint(rectAnchorDy)

	C.gdk_window_move_to_rect(arg0, rect, rectAnchor, windowAnchor, anchorHints, rectAnchorDx, rectAnchorDy)
}

// PeekChildren: like gdk_window_get_children(), but does not copy the list
// of children, so the list does not need to be freed.
func (w window) PeekChildren() *glib.List {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	var cret *C.GList
	var ret1 *glib.List

	cret = C.gdk_window_peek_children(arg0)

	ret1 = glib.WrapList(unsafe.Pointer(cret))

	return ret1
}

// ProcessUpdates sends one or more expose events to @window. The areas in
// each expose event will cover the entire update area for the window (see
// gdk_window_invalidate_region() for details). Normally GDK calls
// gdk_window_process_all_updates() on your behalf, so there’s no need to
// call this function unless you want to force expose events to be delivered
// immediately and synchronously (vs. the usual case, where GDK delivers
// them in an idle handler). Occasionally this is useful to produce nicer
// scrolling behavior, for example.
func (w window) ProcessUpdates(updateChildren bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if updateChildren {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_process_updates(arg0, updateChildren)
}

// Raise raises @window to the top of the Z-order (stacking order), so that
// other windows with the same parent window appear below @window. This is
// true whether or not the windows are visible.
//
// If @window is a toplevel, the window manager may choose to deny the
// request to move the window in the Z-order, gdk_window_raise() only
// requests the restack, does not guarantee it.
func (w window) Raise() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_raise(arg0)
}

// RegisterDnd registers a window as a potential drop destination.
func (w window) RegisterDnd() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_register_dnd(arg0)
}

// RemoveFilter: remove a filter previously added with
// gdk_window_add_filter().
func (w window) RemoveFilter(function FilterFunc) {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_remove_filter(arg0, function, data)
}

// Reparent reparents @window into the given @new_parent. The window being
// reparented will be unmapped as a side effect.
func (w window) Reparent(newParent Window, x int, y int) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkWindow
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(newParent.Native()))
	arg2 = C.gint(x)
	arg3 = C.gint(y)

	C.gdk_window_reparent(arg0, newParent, x, y)
}

// Resize resizes @window; for toplevel windows, asks the window manager to
// resize the window. The window manager may not allow the resize. When
// using GTK+, use gtk_window_resize() instead of this low-level GDK
// function.
//
// Windows may not be resized below 1x1.
//
// If you’re also planning to move the window, use gdk_window_move_resize()
// to both move and resize simultaneously, for a nicer visual effect.
func (w window) Resize(width int, height int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(width)
	arg2 = C.gint(height)

	C.gdk_window_resize(arg0, width, height)
}

// Restack changes the position of @window in the Z-order (stacking order),
// so that it is above @sibling (if @above is true) or below @sibling (if
// @above is false).
//
// If @sibling is nil, then this either raises (if @above is true) or lowers
// the window.
//
// If @window is a toplevel, the window manager may choose to deny the
// request to move the window in the Z-order, gdk_window_restack() only
// requests the restack, does not guarantee it.
func (w window) Restack(sibling Window, above bool) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkWindow
	var arg2 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(sibling.Native()))
	if above {
		arg2 = C.gboolean(1)
	}

	C.gdk_window_restack(arg0, sibling, above)
}

// Scroll: scroll the contents of @window, both pixels and children, by the
// given amount. @window itself does not move. Portions of the window that
// the scroll operation brings in from offscreen areas are invalidated. The
// invalidated region may be bigger than what would strictly be necessary.
//
// For X11, a minimum area will be invalidated if the window has no
// subwindows, or if the edges of the window’s parent do not extend beyond
// the edges of the window. In other cases, a multi-step process is used to
// scroll the window which may produce temporary visual artifacts and
// unnecessary invalidations.
func (w window) Scroll(dx int, dy int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(dx)
	arg2 = C.gint(dy)

	C.gdk_window_scroll(arg0, dx, dy)
}

// SetAcceptFocus: setting @accept_focus to false hints the desktop
// environment that the window doesn’t want to receive input focus.
//
// On X, it is the responsibility of the window manager to interpret this
// hint. ICCCM-compliant window manager usually respect it.
func (w window) SetAcceptFocus(acceptFocus bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if acceptFocus {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_accept_focus(arg0, acceptFocus)
}

// SetBackground sets the background color of @window.
//
// However, when using GTK+, influence the background of a widget using a
// style class or CSS — if you’re an application — or with
// gtk_style_context_set_background() — if you're implementing a custom
// widget.
func (w window) SetBackground(color *Color) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkColor

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkColor)(unsafe.Pointer(color.Native()))

	C.gdk_window_set_background(arg0, color)
}

// SetBackgroundPattern sets the background of @window.
//
// A background of nil means that the window won't have any background. On
// the X11 backend it's also possible to inherit the background from the
// parent window using gdk_x11_get_parent_relative_pattern().
//
// The windowing system will normally fill a window with its background when
// the window is obscured then exposed.
func (w window) SetBackgroundPattern(pattern *cairo.Pattern) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_pattern_t

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_pattern_t)(unsafe.Pointer(pattern.Native()))

	C.gdk_window_set_background_pattern(arg0, pattern)
}

// SetBackgroundRGBA sets the background color of @window.
//
// See also gdk_window_set_background_pattern().
func (w window) SetBackgroundRGBA(rgba *RGBA) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkRGBA

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

	C.gdk_window_set_background_rgba(arg0, rgba)
}

// SetChildInputShapes sets the input shape mask of @window to the union of
// input shape masks for all children of @window, ignoring the input shape
// mask of @window itself. Contrast with
// gdk_window_merge_child_input_shapes() which includes the input shape mask
// of @window in the masks to be merged.
func (w window) SetChildInputShapes() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_set_child_input_shapes(arg0)
}

// SetChildShapes sets the shape mask of @window to the union of shape masks
// for all children of @window, ignoring the shape mask of @window itself.
// Contrast with gdk_window_merge_child_shapes() which includes the shape
// mask of @window in the masks to be merged.
func (w window) SetChildShapes() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_set_child_shapes(arg0)
}

// SetComposited sets a Window as composited, or unsets it. Composited
// windows do not automatically have their contents drawn to the screen.
// Drawing is redirected to an offscreen buffer and an expose event is
// emitted on the parent of the composited window. It is the responsibility
// of the parent’s expose handler to manually merge the off-screen content
// onto the screen in whatever way it sees fit.
//
// It only makes sense for child windows to be composited; see
// gdk_window_set_opacity() if you need translucent toplevel windows.
//
// An additional effect of this call is that the area of this window is no
// longer clipped from regions marked for invalidation on its parent. Draws
// done on the parent window are also no longer clipped by the child.
//
// This call is only supported on some systems (currently, only X11 with new
// enough Xcomposite and Xdamage extensions). You must call
// gdk_display_supports_composite() to check if setting a window as
// composited is supported before attempting to do so.
func (w window) SetComposited(composited bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if composited {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_composited(arg0, composited)
}

// SetCursor sets the default mouse pointer for a Window.
//
// Note that @cursor must be for the same display as @window.
//
// Use gdk_cursor_new_for_display() or gdk_cursor_new_from_pixbuf() to
// create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
// Passing nil for the @cursor argument to gdk_window_set_cursor() means
// that @window will use the cursor of its parent window. Most windows
// should use this default.
func (w window) SetCursor(cursor Cursor) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkCursor

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gdk_window_set_cursor(arg0, cursor)
}

// SetDecorations: “Decorations” are the features the window manager adds to
// a toplevel Window. This function sets the traditional Motif window
// manager hints that tell the window manager which decorations you would
// like your window to have. Usually you should use
// gtk_window_set_decorated() on a Window instead of using the GDK function
// directly.
//
// The @decorations argument is the logical OR of the fields in the
// WMDecoration enumeration. If K_DECOR_ALL is included in the mask, the
// other bits indicate which decorations should be turned off. If
// K_DECOR_ALL is not included, then the other bits indicate which
// decorations should be turned on.
//
// Most window managers honor a decorations hint of 0 to disable all
// decorations, but very few honor all possible combinations of bits.
func (w window) SetDecorations(decorations WMDecoration) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkWMDecoration

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWMDecoration)(decorations)

	C.gdk_window_set_decorations(arg0, decorations)
}

// SetDeviceCursor sets a specific Cursor for a given device when it gets
// inside @window. Use gdk_cursor_new_for_display() or
// gdk_cursor_new_from_pixbuf() to create the cursor. To make the cursor
// invisible, use GDK_BLANK_CURSOR. Passing nil for the @cursor argument to
// gdk_window_set_cursor() means that @window will use the cursor of its
// parent window. Most windows should use this default.
func (w window) SetDeviceCursor(device Device, cursor Cursor) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice
	var arg2 *C.GdkCursor

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg2 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

	C.gdk_window_set_device_cursor(arg0, device, cursor)
}

// SetDeviceEvents sets the event mask for a given device (Normally a
// floating device, not attached to any visible pointer) to @window. For
// example, an event mask including K_BUTTON_PRESS_MASK means the window
// should report button press events. The event mask is the bitwise OR of
// values from the EventMask enumeration.
//
// See the [input handling overview][event-masks] for details.
func (w window) SetDeviceEvents(device Device, eventMask EventMask) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkDevice
	var arg2 C.GdkEventMask

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
	arg2 = (C.GdkEventMask)(eventMask)

	C.gdk_window_set_device_events(arg0, device, eventMask)
}

// SetEventCompression determines whether or not extra unprocessed motion
// events in the event queue can be discarded. If true only the most recent
// event will be delivered.
//
// Some types of applications, e.g. paint programs, need to see all motion
// events and will benefit from turning off event compression.
//
// By default, event compression is enabled.
func (w window) SetEventCompression(eventCompression bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if eventCompression {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_event_compression(arg0, eventCompression)
}

// SetEvents: the event mask for a window determines which events will be
// reported for that window from all master input devices. For example, an
// event mask including K_BUTTON_PRESS_MASK means the window should report
// button press events. The event mask is the bitwise OR of values from the
// EventMask enumeration.
//
// See the [input handling overview][event-masks] for details.
func (w window) SetEvents(eventMask EventMask) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkEventMask

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkEventMask)(eventMask)

	C.gdk_window_set_events(arg0, eventMask)
}

// SetFocusOnMap: setting @focus_on_map to false hints the desktop
// environment that the window doesn’t want to receive input focus when it
// is mapped. focus_on_map should be turned off for windows that aren’t
// triggered interactively (such as popups from network activity).
//
// On X, it is the responsibility of the window manager to interpret this
// hint. Window managers following the freedesktop.org window manager
// extension specification should respect it.
func (w window) SetFocusOnMap(focusOnMap bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if focusOnMap {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_focus_on_map(arg0, focusOnMap)
}

// SetFullscreenMode specifies whether the @window should span over all
// monitors (in a multi-head setup) or only the current monitor when in
// fullscreen mode.
//
// The @mode argument is from the FullscreenMode enumeration. If
// K_FULLSCREEN_ON_ALL_MONITORS is specified, the fullscreen @window will
// span over all monitors from the Screen.
//
// On X11, searches through the list of monitors from the Screen the ones
// which delimit the 4 edges of the entire Screen and will ask the window
// manager to span the @window over these monitors.
//
// If the XINERAMA extension is not available or not usable, this function
// has no effect.
//
// Not all window managers support this, so you can’t rely on the fullscreen
// window to span over the multiple monitors when
// K_FULLSCREEN_ON_ALL_MONITORS is specified.
func (w window) SetFullscreenMode(mode FullscreenMode) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkFullscreenMode

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkFullscreenMode)(mode)

	C.gdk_window_set_fullscreen_mode(arg0, mode)
}

// SetFunctions sets hints about the window management functions to make
// available via buttons on the window frame.
//
// On the X backend, this function sets the traditional Motif window manager
// hint for this purpose. However, few window managers do anything reliable
// or interesting with this hint. Many ignore it entirely.
//
// The @functions argument is the logical OR of values from the WMFunction
// enumeration. If the bitmask includes K_FUNC_ALL, then the other bits
// indicate which functions to disable; if it doesn’t include K_FUNC_ALL, it
// indicates which functions to enable.
func (w window) SetFunctions(functions WMFunction) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkWMFunction

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWMFunction)(functions)

	C.gdk_window_set_functions(arg0, functions)
}

// SetGeometryHints sets the geometry hints for @window. Hints flagged in
// @geom_mask are set, hints not flagged in @geom_mask are unset. To unset
// all hints, use a @geom_mask of 0 and a @geometry of nil.
//
// This function provides hints to the windowing system about acceptable
// sizes for a toplevel window. The purpose of this is to constrain user
// resizing, but the windowing system will typically (but is not required
// to) also constrain the current size of the window to the provided values
// and constrain programatic resizing via gdk_window_resize() or
// gdk_window_move_resize().
//
// Note that on X11, this effect has no effect on windows of type
// GDK_WINDOW_TEMP or windows where override redirect has been turned on via
// gdk_window_set_override_redirect() since these windows are not resizable
// by the user.
//
// Since you can’t count on the windowing system doing the constraints for
// programmatic resizes, you should generally call
// gdk_window_constrain_size() yourself to determine appropriate sizes.
func (w window) SetGeometryHints(geometry *Geometry, geomMask WindowHints) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkGeometry
	var arg2 C.GdkWindowHints

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkGeometry)(unsafe.Pointer(geometry.Native()))
	arg2 = (C.GdkWindowHints)(geomMask)

	C.gdk_window_set_geometry_hints(arg0, geometry, geomMask)
}

// SetGroup sets the group leader window for @window. By default, GDK sets
// the group leader for all toplevel windows to a global window implicitly
// created by GDK. With this function you can override this default.
//
// The group leader window allows the window manager to distinguish all
// windows that belong to a single application. It may for example allow
// users to minimize/unminimize all windows belonging to an application at
// once. You should only set a non-default group window if your application
// pretends to be multiple applications.
func (w window) SetGroup(leader Window) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(leader.Native()))

	C.gdk_window_set_group(arg0, leader)
}

// SetIconList sets a list of icons for the window. One of these will be
// used to represent the window when it has been iconified. The icon is
// usually shown in an icon box or some sort of task bar. Which icon size is
// shown depends on the window manager. The window manager can scale the
// icon but setting several size icons can give better image quality since
// the window manager may only need to scale the icon by a small amount or
// not at all.
//
// Note that some platforms don't support window icons.
func (w window) SetIconList(pixbufs *glib.List) {
	var arg0 *C.GdkWindow
	var arg1 *C.GList

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GList)(unsafe.Pointer(pixbufs.Native()))

	C.gdk_window_set_icon_list(arg0, pixbufs)
}

// SetIconName windows may have a name used while minimized, distinct from
// the name they display in their titlebar. Most of the time this is a bad
// idea from a user interface standpoint. But you can set such a name with
// this function, if you like.
//
// After calling this with a non-nil @name, calls to gdk_window_set_title()
// will not update the icon title.
//
// Using nil for @name unsets the icon title; further calls to
// gdk_window_set_title() will again update the icon title as well.
//
// Note that some platforms don't support window icons.
func (w window) SetIconName(name string) {
	var arg0 *C.GdkWindow
	var arg1 *C.gchar

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_window_set_icon_name(arg0, name)
}

// SetKeepAbove: set if @window must be kept above other windows. If the
// window was already above, then this function does nothing.
//
// On X11, asks the window manager to keep @window above, if the window
// manager supports this operation. Not all window managers support this,
// and some deliberately ignore it or don’t have a concept of “keep above”;
// so you can’t rely on the window being kept above. But it will happen with
// most standard window managers, and GDK makes a best effort to get it to
// happen.
func (w window) SetKeepAbove(setting bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_keep_above(arg0, setting)
}

// SetKeepBelow: set if @window must be kept below other windows. If the
// window was already below, then this function does nothing.
//
// On X11, asks the window manager to keep @window below, if the window
// manager supports this operation. Not all window managers support this,
// and some deliberately ignore it or don’t have a concept of “keep below”;
// so you can’t rely on the window being kept below. But it will happen with
// most standard window managers, and GDK makes a best effort to get it to
// happen.
func (w window) SetKeepBelow(setting bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if setting {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_keep_below(arg0, setting)
}

// SetModalHint: the application can use this hint to tell the window
// manager that a certain window has modal behaviour. The window manager can
// use this information to handle modal windows in a special way.
//
// You should only use this on windows for which you have previously called
// gdk_window_set_transient_for()
func (w window) SetModalHint(modal bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if modal {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_modal_hint(arg0, modal)
}

// SetOpacity: set @window to render as partially transparent, with opacity
// 0 being fully transparent and 1 fully opaque. (Values of the opacity
// parameter are clamped to the [0,1] range.)
//
// For toplevel windows this depends on support from the windowing system
// that may not always be there. For instance, On X11, this works only on X
// screens with a compositing manager running. On Wayland, there is no
// per-window opacity value that the compositor would apply. Instead, use
// `gdk_window_set_opaque_region (window, NULL)` to tell the compositor that
// the entire window is (potentially) non-opaque, and draw your content with
// alpha, or use gtk_widget_set_opacity() to set an overall opacity for your
// widgets.
//
// For child windows this function only works for non-native windows.
//
// For setting up per-pixel alpha topelevels, see
// gdk_screen_get_rgba_visual(), and for non-toplevels, see
// gdk_window_set_composited().
//
// Support for non-toplevel windows was added in 3.8.
func (w window) SetOpacity(opacity float64) {
	var arg0 *C.GdkWindow
	var arg1 C.gdouble

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gdouble(opacity)

	C.gdk_window_set_opacity(arg0, opacity)
}

// SetOpaqueRegion: for optimisation purposes, compositing window managers
// may like to not draw obscured regions of windows, or turn off blending
// during for these regions. With RGB windows with no transparency, this is
// just the shape of the window, but with ARGB32 windows, the compositor
// does not know what regions of the window are transparent or not.
//
// This function only works for toplevel windows.
//
// GTK+ will update this property automatically if the @window background is
// opaque, as we know where the opaque regions are. If your window
// background is not opaque, please update this property in your
// Widget::style-updated handler.
func (w window) SetOpaqueRegion(region *cairo.Region) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gdk_window_set_opaque_region(arg0, region)
}

// SetOverrideRedirect: an override redirect window is not under the control
// of the window manager. This means it won’t have a titlebar, won’t be
// minimizable, etc. - it will be entirely under the control of the
// application. The window manager can’t see the override redirect window at
// all.
//
// Override redirect should only be used for short-lived temporary windows,
// such as popup menus. Menu uses an override redirect window in its
// implementation, for example.
func (w window) SetOverrideRedirect(overrideRedirect bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if overrideRedirect {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_override_redirect(arg0, overrideRedirect)
}

// SetPassThrough sets whether input to the window is passed through to the
// window below.
//
// The default value of this is false, which means that pointer events that
// happen inside the window are send first to the window, but if the event
// is not selected by the event mask then the event is sent to the parent
// window, and so on up the hierarchy.
//
// If @pass_through is true then such pointer events happen as if the window
// wasn't there at all, and thus will be sent first to any windows below
// @window. This is useful if the window is used in a transparent fashion.
// In the terminology of the web this would be called "pointer-events:
// none".
//
// Note that a window with @pass_through true can still have a subwindow
// without pass through, so you can get events on a subset of a window. And
// in that cases you would get the in-between related events such as the
// pointer enter/leave events on its way to the destination window.
func (w window) SetPassThrough(passThrough bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if passThrough {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_pass_through(arg0, passThrough)
}

// SetRole: when using GTK+, typically you should use gtk_window_set_role()
// instead of this low-level function.
//
// The window manager and session manager use a window’s role to distinguish
// it from other kinds of window in the same application. When an
// application is restarted after being saved in a previous session, all
// windows with the same title and role are treated as interchangeable. So
// if you have two windows with the same title that should be distinguished
// for session management purposes, you should set the role on those
// windows. It doesn’t matter what string you use for the role, as long as
// you have a different role for each non-interchangeable kind of window.
func (w window) SetRole(role string) {
	var arg0 *C.GdkWindow
	var arg1 *C.gchar

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(role))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_window_set_role(arg0, role)
}

// SetShadowWidth: newer GTK+ windows using client-side decorations use
// extra geometry around their frames for effects like shadows and invisible
// borders. Window managers that want to maximize windows or snap to edges
// need to know where the extents of the actual frame lie, so that users
// don’t feel like windows are snapping against random invisible edges.
//
// Note that this property is automatically updated by GTK+, so this
// function should only be used by applications which do not use GTK+ to
// create toplevel windows.
func (w window) SetShadowWidth(left int, right int, top int, bottom int) {
	var arg0 *C.GdkWindow
	var arg1 C.gint
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = C.gint(left)
	arg2 = C.gint(right)
	arg3 = C.gint(top)
	arg4 = C.gint(bottom)

	C.gdk_window_set_shadow_width(arg0, left, right, top, bottom)
}

// SetSkipPagerHint toggles whether a window should appear in a pager
// (workspace switcher, or other desktop utility program that displays a
// small thumbnail representation of the windows on the desktop). If a
// window’s semantic type as specified with gdk_window_set_type_hint()
// already fully describes the window, this function should not be called in
// addition, instead you should allow the window to be treated according to
// standard policy for its semantic type.
func (w window) SetSkipPagerHint(skipsPager bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if skipsPager {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_skip_pager_hint(arg0, skipsPager)
}

// SetSkipTaskbarHint toggles whether a window should appear in a task list
// or window list. If a window’s semantic type as specified with
// gdk_window_set_type_hint() already fully describes the window, this
// function should not be called in addition, instead you should allow the
// window to be treated according to standard policy for its semantic type.
func (w window) SetSkipTaskbarHint(skipsTaskbar bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if skipsTaskbar {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_skip_taskbar_hint(arg0, skipsTaskbar)
}

// SetSourceEvents sets the event mask for any floating device (i.e. not
// attached to any visible pointer) that has the source defined as @source.
// This event mask will be applied both to currently existing, newly added
// devices after this call, and devices being attached/detached.
func (w window) SetSourceEvents(source InputSource, eventMask EventMask) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkInputSource
	var arg2 C.GdkEventMask

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkInputSource)(source)
	arg2 = (C.GdkEventMask)(eventMask)

	C.gdk_window_set_source_events(arg0, source, eventMask)
}

// SetStartupID: when using GTK+, typically you should use
// gtk_window_set_startup_id() instead of this low-level function.
func (w window) SetStartupID(startupID string) {
	var arg0 *C.GdkWindow
	var arg1 *C.gchar

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_window_set_startup_id(arg0, startupID)
}

// SetStaticGravities: used to set the bit gravity of the given window to
// static, and flag it so all children get static subwindow gravity. This is
// used if you are implementing scary features that involve deep knowledge
// of the windowing system. Don’t worry about it.
func (w window) SetStaticGravities(useStatic bool) bool {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if useStatic {
		arg1 = C.gboolean(1)
	}

	var cret C.gboolean
	var ret1 bool

	cret = C.gdk_window_set_static_gravities(arg0, useStatic)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SetSupportMultidevice: this function will enable multidevice features in
// @window.
//
// Multidevice aware windows will need to handle properly multiple, per
// device enter/leave events, device grabs and grab ownerships.
func (w window) SetSupportMultidevice(supportMultidevice bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if supportMultidevice {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_support_multidevice(arg0, supportMultidevice)
}

// SetTitle sets the title of a toplevel window, to be displayed in the
// titlebar. If you haven’t explicitly set the icon name for the window
// (using gdk_window_set_icon_name()), the icon name will be set to @title
// as well. @title must be in UTF-8 encoding (as with all user-readable
// strings in GDK/GTK+). @title may not be nil.
func (w window) SetTitle(title string) {
	var arg0 *C.GdkWindow
	var arg1 *C.gchar

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.gchar)(C.CString(title))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_window_set_title(arg0, title)
}

// SetTransientFor indicates to the window manager that @window is a
// transient dialog associated with the application window @parent. This
// allows the window manager to do things like center @window on @parent and
// keep @window above @parent.
//
// See gtk_window_set_transient_for() if you’re using Window or Dialog.
func (w window) SetTransientFor(parent Window) {
	var arg0 *C.GdkWindow
	var arg1 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(parent.Native()))

	C.gdk_window_set_transient_for(arg0, parent)
}

// SetTypeHint: the application can use this call to provide a hint to the
// window manager about the functionality of a window. The window manager
// can use this information when determining the decoration and behaviour of
// the window.
//
// The hint must be set before the window is mapped.
func (w window) SetTypeHint(hint WindowTypeHint) {
	var arg0 *C.GdkWindow
	var arg1 C.GdkWindowTypeHint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (C.GdkWindowTypeHint)(hint)

	C.gdk_window_set_type_hint(arg0, hint)
}

// SetUrgencyHint toggles whether a window needs the user's urgent
// attention.
func (w window) SetUrgencyHint(urgent bool) {
	var arg0 *C.GdkWindow
	var arg1 C.gboolean

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	if urgent {
		arg1 = C.gboolean(1)
	}

	C.gdk_window_set_urgency_hint(arg0, urgent)
}

// SetUserData: for most purposes this function is deprecated in favor of
// g_object_set_data(). However, for historical reasons GTK+ stores the
// Widget that owns a Window as user data on the Window. So, custom widget
// implementations should use this function for that. If GTK+ receives an
// event for a Window, and the user data for the window is non-nil, GTK+
// will assume the user data is a Widget, and forward the event to that
// widget.
func (w window) SetUserData(userData gextras.Objector) {
	var arg0 *C.GdkWindow
	var arg1 C.gpointer

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.GObject)(unsafe.Pointer(userData.Native()))

	C.gdk_window_set_user_data(arg0, userData)
}

// ShapeCombineRegion makes pixels in @window outside @shape_region be
// transparent, so that the window may be nonrectangular.
//
// If @shape_region is nil, the shape will be unset, so the whole window
// will be opaque again. @offset_x and @offset_y are ignored if
// @shape_region is nil.
//
// On the X11 platform, this uses an X server extension which is widely
// available on most common platforms, but not available on very old X
// servers, and occasionally the implementation will be buggy. On servers
// without the shape extension, this function will do nothing.
//
// This function works on both toplevel and child windows.
func (w window) ShapeCombineRegion(shapeRegion *cairo.Region, offsetX int, offsetY int) {
	var arg0 *C.GdkWindow
	var arg1 *C.cairo_region_t
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))
	arg1 = (*C.cairo_region_t)(unsafe.Pointer(shapeRegion.Native()))
	arg2 = C.gint(offsetX)
	arg3 = C.gint(offsetY)

	C.gdk_window_shape_combine_region(arg0, shapeRegion, offsetX, offsetY)
}

// Show: like gdk_window_show_unraised(), but also raises the window to the
// top of the window stack (moves the window to the front of the Z-order).
//
// This function maps a window so it’s visible onscreen. Its opposite is
// gdk_window_hide().
//
// When implementing a Widget, you should call this function on the widget's
// Window as part of the “map” method.
func (w window) Show() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_show(arg0)
}

// ShowUnraised shows a Window onscreen, but does not modify its stacking
// order. In contrast, gdk_window_show() will raise the window to the top of
// the window stack.
//
// On the X11 platform, in Xlib terms, this function calls XMapWindow() (it
// also updates some internal GDK state, which means that you can’t really
// use XMapWindow() directly on a GDK window).
func (w window) ShowUnraised() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_show_unraised(arg0)
}

// Stick: “Pins” a window such that it’s on all workspaces and does not
// scroll with viewports, for window managers that have scrollable
// viewports. (When using Window, gtk_window_stick() may be more useful.)
//
// On the X11 platform, this function depends on window manager support, so
// may have no effect with many window managers. However, GDK will do the
// best it can to convince the window manager to stick the window. For
// window managers that don’t support this operation, there’s nothing you
// can do to force it to happen.
func (w window) Stick() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_stick(arg0)
}

// ThawToplevelUpdatesLibgtkOnly thaws a window frozen with
// gdk_window_freeze_toplevel_updates_libgtk_only().
//
// This function is not part of the GDK public API and is only for use by
// GTK+.
func (w window) ThawToplevelUpdatesLibgtkOnly() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_thaw_toplevel_updates_libgtk_only(arg0)
}

// ThawUpdates thaws a window frozen with gdk_window_freeze_updates().
func (w window) ThawUpdates() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_thaw_updates(arg0)
}

// Unfullscreen moves the window out of fullscreen mode. If the window was
// not fullscreen, does nothing.
//
// On X11, asks the window manager to move @window out of the fullscreen
// state, if the window manager supports this operation. Not all window
// managers support this, and some deliberately ignore it or don’t have a
// concept of “fullscreen”; so you can’t rely on the unfullscreenification
// actually happening. But it will happen with most standard window
// managers, and GDK makes a best effort to get it to happen.
func (w window) Unfullscreen() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_unfullscreen(arg0)
}

// Unmaximize unmaximizes the window. If the window wasn’t maximized, then
// this function does nothing.
//
// On X11, asks the window manager to unmaximize @window, if the window
// manager supports this operation. Not all window managers support this,
// and some deliberately ignore it or don’t have a concept of “maximized”;
// so you can’t rely on the unmaximization actually happening. But it will
// happen with most standard window managers, and GDK makes a best effort to
// get it to happen.
//
// On Windows, reliably unmaximizes the window.
func (w window) Unmaximize() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_unmaximize(arg0)
}

// Unstick: reverse operation for gdk_window_stick(); see
// gdk_window_stick(), and gtk_window_unstick().
func (w window) Unstick() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_unstick(arg0)
}

// Withdraw withdraws a window (unmaps it and asks the window manager to
// forget about it). This function is not really useful as gdk_window_hide()
// automatically withdraws toplevel windows before hiding them.
func (w window) Withdraw() {
	var arg0 *C.GdkWindow

	arg0 = (*C.GdkWindow)(unsafe.Pointer(w.Native()))

	C.gdk_window_withdraw(arg0)
}

// Geometry: the Geometry struct gives the window manager information about a
// window’s geometry constraints. Normally you would set these on the GTK+ level
// using gtk_window_set_geometry_hints(). Window then sets the hints on the
// Window it creates.
//
// gdk_window_set_geometry_hints() expects the hints to be fully valid already
// and simply passes them to the window manager; in contrast,
// gtk_window_set_geometry_hints() performs some interpretation. For example,
// Window will apply the hints to the geometry widget instead of the toplevel
// window, if you set a geometry widget. Also, the
// @min_width/@min_height/@max_width/@max_height fields may be set to -1, and
// Window will substitute the size request of the window or geometry widget. If
// the minimum size hint is not provided, Window will use its requisition as the
// minimum size. If the minimum size is provided and a geometry widget is set,
// Window will take the minimum size as the minimum size of the geometry widget
// rather than the entire window. The base size is treated similarly.
//
// The canonical use-case for gtk_window_set_geometry_hints() is to get a
// terminal widget to resize properly. Here, the terminal text area should be
// the geometry widget; Window will then automatically set the base size to the
// size of other widgets in the terminal window, such as the menubar and
// scrollbar. Then, the @width_inc and @height_inc fields should be set to the
// size of one character in the terminal. Finally, the base size should be set
// to the size of one character. The net effect is that the minimum size of the
// terminal will have a 1x1 character terminal area, and only terminal sizes on
// the “character grid” will be allowed.
//
// Here’s an example of how the terminal example would be implemented, assuming
// a terminal area widget called “terminal” and a toplevel window “toplevel”:
//
//    	GdkGeometry hints;
//
//    	hints.base_width = terminal->char_width;
//            hints.base_height = terminal->char_height;
//            hints.min_width = terminal->char_width;
//            hints.min_height = terminal->char_height;
//            hints.width_inc = terminal->char_width;
//            hints.height_inc = terminal->char_height;
//
//     gtk_window_set_geometry_hints (GTK_WINDOW (toplevel),
//                                    GTK_WIDGET (terminal),
//                                    &hints,
//                                    GDK_HINT_RESIZE_INC |
//                                    GDK_HINT_MIN_SIZE |
//                                    GDK_HINT_BASE_SIZE);
//
// The other useful fields are the @min_aspect and @max_aspect fields; these
// contain a width/height ratio as a floating point number. If a geometry widget
// is set, the aspect applies to the geometry widget rather than the entire
// window. The most common use of these hints is probably to set @min_aspect and
// @max_aspect to the same value, thus forcing the window to keep a constant
// aspect ratio.
type Geometry struct {
	native C.GdkGeometry
}

// WrapGeometry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGeometry(ptr unsafe.Pointer) *Geometry {
	if ptr == nil {
		return nil
	}

	return (*Geometry)(ptr)
}

func marshalGeometry(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGeometry(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *Geometry) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// MinWidth gets the field inside the struct.
func (g *Geometry) MinWidth() int {
	v = C.gint(g.native.min_width)
}

// MinHeight gets the field inside the struct.
func (g *Geometry) MinHeight() int {
	v = C.gint(g.native.min_height)
}

// MaxWidth gets the field inside the struct.
func (g *Geometry) MaxWidth() int {
	v = C.gint(g.native.max_width)
}

// MaxHeight gets the field inside the struct.
func (g *Geometry) MaxHeight() int {
	v = C.gint(g.native.max_height)
}

// BaseWidth gets the field inside the struct.
func (g *Geometry) BaseWidth() int {
	v = C.gint(g.native.base_width)
}

// BaseHeight gets the field inside the struct.
func (g *Geometry) BaseHeight() int {
	v = C.gint(g.native.base_height)
}

// WidthInc gets the field inside the struct.
func (g *Geometry) WidthInc() int {
	v = C.gint(g.native.width_inc)
}

// HeightInc gets the field inside the struct.
func (g *Geometry) HeightInc() int {
	v = C.gint(g.native.height_inc)
}

// MinAspect gets the field inside the struct.
func (g *Geometry) MinAspect() float64 {
	v = C.gdouble(g.native.min_aspect)
}

// MaxAspect gets the field inside the struct.
func (g *Geometry) MaxAspect() float64 {
	v = C.gdouble(g.native.max_aspect)
}

// WinGravity gets the field inside the struct.
func (g *Geometry) WinGravity() Gravity {
	v = Gravity(g.native.win_gravity)
}

// WindowAttr attributes to use for a newly-created window.
type WindowAttr struct {
	native C.GdkWindowAttr
}

// WrapWindowAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowAttr(ptr unsafe.Pointer) *WindowAttr {
	if ptr == nil {
		return nil
	}

	return (*WindowAttr)(ptr)
}

func marshalWindowAttr(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowAttr(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// Title gets the field inside the struct.
func (w *WindowAttr) Title() string {
	v = C.GoString(w.native.title)
}

// EventMask gets the field inside the struct.
func (w *WindowAttr) EventMask() int {
	v = C.gint(w.native.event_mask)
}

// X gets the field inside the struct.
func (w *WindowAttr) X() int {
	v = C.gint(w.native.x)
}

// Y gets the field inside the struct.
func (w *WindowAttr) Y() int {
	v = C.gint(w.native.y)
}

// Width gets the field inside the struct.
func (w *WindowAttr) Width() int {
	v = C.gint(w.native.width)
}

// Height gets the field inside the struct.
func (w *WindowAttr) Height() int {
	v = C.gint(w.native.height)
}

// Wclass gets the field inside the struct.
func (w *WindowAttr) Wclass() WindowWindowClass {
	v = WindowWindowClass(w.native.wclass)
}

// Visual gets the field inside the struct.
func (w *WindowAttr) Visual() Visual {
	v = gextras.CastObject(externglib.Take(unsafe.Pointer(w.native.visual.Native()))).(Visual)
}

// WindowType gets the field inside the struct.
func (w *WindowAttr) WindowType() WindowType {
	v = WindowType(w.native.window_type)
}

// Cursor gets the field inside the struct.
func (w *WindowAttr) Cursor() Cursor {
	v = gextras.CastObject(externglib.Take(unsafe.Pointer(w.native.cursor.Native()))).(Cursor)
}

// WmclassName gets the field inside the struct.
func (w *WindowAttr) WmclassName() string {
	v = C.GoString(w.native.wmclass_name)
}

// WmclassClass gets the field inside the struct.
func (w *WindowAttr) WmclassClass() string {
	v = C.GoString(w.native.wmclass_class)
}

// OverrideRedirect gets the field inside the struct.
func (w *WindowAttr) OverrideRedirect() bool {
	v = C.bool(w.native.override_redirect) != C.false
}

// TypeHint gets the field inside the struct.
func (w *WindowAttr) TypeHint() WindowTypeHint {
	v = WindowTypeHint(w.native.type_hint)
}

type WindowRedirect struct {
	native C.GdkWindowRedirect
}

// WrapWindowRedirect wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWindowRedirect(ptr unsafe.Pointer) *WindowRedirect {
	if ptr == nil {
		return nil
	}

	return (*WindowRedirect)(ptr)
}

func marshalWindowRedirect(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWindowRedirect(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WindowRedirect) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}
