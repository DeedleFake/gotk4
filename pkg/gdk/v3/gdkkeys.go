// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_keymap_get_type()), F: marshalKeymap},
	})
}

// KeyvalConvertCase obtains the upper- and lower-case versions of the keyval
// @symbol. Examples of keyvals are K_KEY_a, K_KEY_Enter, K_KEY_F1, etc.
func KeyvalConvertCase(symbol uint) (lower uint, upper uint) {
	var _arg1 C.guint // out
	var _arg2 C.guint // in
	var _arg3 C.guint // in

	_arg1 = C.guint(symbol)

	C.gdk_keyval_convert_case(_arg1, &_arg2, &_arg3)

	var _lower uint // out
	var _upper uint // out

	_lower = uint(_arg2)
	_upper = uint(_arg3)

	return _lower, _upper
}

// KeyvalFromName converts a key name to a key value.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalFromName(keyvalName string) uint {
	var _arg1 *C.gchar // out
	var _cret C.guint  // in

	_arg1 = (*C.gchar)(C.CString(keyvalName))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_keyval_from_name(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalIsLower returns true if the given key value is in lower case.
func KeyvalIsLower(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_lower(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalIsUpper returns true if the given key value is in upper case.
func KeyvalIsUpper(keyval uint) bool {
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_is_upper(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalName converts a key value into a symbolic name.
//
// The names are the same as those in the `gdk/gdkkeysyms.h` header file but
// without the leading “GDK_KEY_”.
func KeyvalName(keyval uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// KeyvalToLower converts a key value to lower case, if applicable.
func KeyvalToLower(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_lower(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding ISO10646
// (Unicode) character.
func KeyvalToUnicode(keyval uint) uint32 {
	var _arg1 C.guint   // out
	var _cret C.guint32 // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_unicode(_arg1)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// KeyvalToUpper converts a key value to upper case, if applicable.
func KeyvalToUpper(keyval uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(keyval)

	_cret = C.gdk_keyval_to_upper(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UnicodeToKeyval: convert from a ISO10646 character to a key symbol.
func UnicodeToKeyval(wc uint32) uint {
	var _arg1 C.guint32 // out
	var _cret C.guint   // in

	_arg1 = C.guint32(wc)

	_cret = C.gdk_unicode_to_keyval(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Keymap: a Keymap defines the translation from keyboard state (including a
// hardware key, a modifier mask, and active keyboard group) to a keyval. This
// translation has two phases. The first phase is to determine the effective
// keyboard group and level for the keyboard state; the second phase is to look
// up the keycode/group/level triplet in the keymap and see what keyval it
// corresponds to.
type Keymap interface {
	gextras.Objector

	// CapsLockState:
	CapsLockState() bool
	// Direction:
	Direction() pango.Direction
	// EntriesForKeycode:
	EntriesForKeycode(hardwareKeycode uint) ([]KeymapKey, []uint, bool)
	// EntriesForKeyval:
	EntriesForKeyval(keyval uint) ([]KeymapKey, bool)
	// ModifierMask:
	ModifierMask(intent ModifierIntent) ModifierType
	// ModifierState:
	ModifierState() uint
	// NumLockState:
	NumLockState() bool
	// ScrollLockState:
	ScrollLockState() bool
	// HaveBidiLayoutsKeymap:
	HaveBidiLayoutsKeymap() bool
	// LookupKeyKeymap:
	LookupKeyKeymap(key *KeymapKey) uint
	// TranslateKeyboardStateKeymap:
	TranslateKeyboardStateKeymap(hardwareKeycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumedModifiers ModifierType, ok bool)
}

// keymap implements the Keymap class.
type keymap struct {
	gextras.Objector
}

// WrapKeymap wraps a GObject to the right type. It is
// primarily used internally.
func WrapKeymap(obj *externglib.Object) Keymap {
	return keymap{
		Objector: obj,
	}
}

func marshalKeymap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapKeymap(obj), nil
}

func (k keymap) CapsLockState() bool {
	var _arg0 *C.GdkKeymap // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_get_caps_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (k keymap) Direction() pango.Direction {
	var _arg0 *C.GdkKeymap     // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_get_direction(_arg0)

	var _direction pango.Direction // out

	_direction = pango.Direction(_cret)

	return _direction
}

func (k keymap) EntriesForKeycode(hardwareKeycode uint) ([]KeymapKey, []uint, bool) {
	var _arg0 *C.GdkKeymap // out
	var _arg1 C.guint      // out
	var _arg2 *C.GdkKeymapKey
	var _arg4 C.gint // in
	var _arg3 *C.guint
	var _arg4 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	_arg1 = C.guint(hardwareKeycode)

	_cret = C.gdk_keymap_get_entries_for_keycode(_arg0, _arg1, &_arg2, &_arg3, &_arg4)

	var _keys []KeymapKey
	var _keyvals []uint
	var _ok bool // out

	_keys = unsafe.Slice((*KeymapKey)(unsafe.Pointer(_arg2)), _arg4)
	runtime.SetFinalizer(&_keys, func(v *[]KeymapKey) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	_keyvals = unsafe.Slice((*uint)(unsafe.Pointer(_arg3)), _arg4)
	runtime.SetFinalizer(&_keyvals, func(v *[]uint) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _keys, _keyvals, _ok
}

func (k keymap) EntriesForKeyval(keyval uint) ([]KeymapKey, bool) {
	var _arg0 *C.GdkKeymap // out
	var _arg1 C.guint      // out
	var _arg2 *C.GdkKeymapKey
	var _arg3 C.gint     // in
	var _cret C.gboolean // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	_arg1 = C.guint(keyval)

	_cret = C.gdk_keymap_get_entries_for_keyval(_arg0, _arg1, &_arg2, &_arg3)

	var _keys []KeymapKey
	var _ok bool // out

	_keys = unsafe.Slice((*KeymapKey)(unsafe.Pointer(_arg2)), _arg3)
	runtime.SetFinalizer(&_keys, func(v *[]KeymapKey) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})
	if _cret != 0 {
		_ok = true
	}

	return _keys, _ok
}

func (k keymap) ModifierMask(intent ModifierIntent) ModifierType {
	var _arg0 *C.GdkKeymap        // out
	var _arg1 C.GdkModifierIntent // out
	var _cret C.GdkModifierType   // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	_arg1 = C.GdkModifierIntent(intent)

	_cret = C.gdk_keymap_get_modifier_mask(_arg0, _arg1)

	var _modifierType ModifierType // out

	_modifierType = ModifierType(_cret)

	return _modifierType
}

func (k keymap) ModifierState() uint {
	var _arg0 *C.GdkKeymap // out
	var _cret C.guint      // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_get_modifier_state(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (k keymap) NumLockState() bool {
	var _arg0 *C.GdkKeymap // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_get_num_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (k keymap) ScrollLockState() bool {
	var _arg0 *C.GdkKeymap // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_get_scroll_lock_state(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (k keymap) HaveBidiLayoutsKeymap() bool {
	var _arg0 *C.GdkKeymap // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	_cret = C.gdk_keymap_have_bidi_layouts(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (k keymap) LookupKeyKeymap(key *KeymapKey) uint {
	var _arg0 *C.GdkKeymap    // out
	var _arg1 *C.GdkKeymapKey // out
	var _cret C.guint         // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	_arg1 = (*C.GdkKeymapKey)(unsafe.Pointer(key.Native()))

	_cret = C.gdk_keymap_lookup_key(_arg0, _arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (k keymap) TranslateKeyboardStateKeymap(hardwareKeycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumedModifiers ModifierType, ok bool) {
	var _arg0 *C.GdkKeymap      // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _arg3 C.gint            // out
	var _arg4 C.guint           // in
	var _arg5 C.gint            // in
	var _arg6 C.gint            // in
	var _arg7 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	_arg1 = C.guint(hardwareKeycode)
	_arg2 = C.GdkModifierType(state)
	_arg3 = C.gint(group)

	_cret = C.gdk_keymap_translate_keyboard_state(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)

	var _keyval uint                    // out
	var _effectiveGroup int             // out
	var _level int                      // out
	var _consumedModifiers ModifierType // out
	var _ok bool                        // out

	_keyval = uint(_arg4)
	_effectiveGroup = int(_arg5)
	_level = int(_arg6)
	_consumedModifiers = ModifierType(_arg7)
	if _cret != 0 {
		_ok = true
	}

	return _keyval, _effectiveGroup, _level, _consumedModifiers, _ok
}

// KeymapKey: a KeymapKey is a hardware key that can be mapped to a keyval.
type KeymapKey C.GdkKeymapKey

// WrapKeymapKey wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapKeymapKey(ptr unsafe.Pointer) *KeymapKey {
	return (*KeymapKey)(ptr)
}

// Native returns the underlying C source pointer.
func (k *KeymapKey) Native() unsafe.Pointer {
	return unsafe.Pointer(k)
}
