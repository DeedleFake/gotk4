// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_status_get_type()), F: marshalStatus},
		{T: externglib.Type(C.gdk_device_tool_get_type()), F: marshalDeviceTool},
		{T: externglib.Type(C.gdk_drag_context_get_type()), F: marshalDragContext},
	})
}

type Status int

const (
	StatusOk         Status = 0
	StatusError      Status = -1
	StatusErrorParam Status = -2
	StatusErrorFile  Status = -3
	StatusErrorMem   Status = -4
)

func marshalStatus(p uintptr) (interface{}, error) {
	return Status(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type DeviceTool interface {
	gextras.Objector

	// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
	// When non-zero, the identificator is unique for the given tool model,
	// meaning that two identical tools will share the same @hardware_id, but
	// will have different serial numbers (see gdk_device_tool_get_serial()).
	//
	// This is a more concrete (and device specific) method to identify a
	// DeviceTool than gdk_device_tool_get_tool_type(), as a tablet may support
	// multiple devices with the same DeviceToolType, but having different
	// hardware identificators.
	HardwareID() uint64
	// Serial gets the serial of this tool, this value can be used to identify a
	// physical tool (eg. a tablet pen) across program executions.
	Serial() uint64
	// ToolType gets the DeviceToolType of the tool.
	ToolType() DeviceToolType
}

// DeviceToolClass implements the DeviceTool interface.
type DeviceToolClass struct {
	*externglib.Object
}

var _ DeviceTool = (*DeviceToolClass)(nil)

func wrapDeviceTool(obj *externglib.Object) DeviceTool {
	return &DeviceToolClass{
		Object: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDeviceTool(obj), nil
}

// HardwareID gets the hardware ID of this tool, or 0 if it's not known. When
// non-zero, the identificator is unique for the given tool model, meaning that
// two identical tools will share the same @hardware_id, but will have different
// serial numbers (see gdk_device_tool_get_serial()).
//
// This is a more concrete (and device specific) method to identify a DeviceTool
// than gdk_device_tool_get_tool_type(), as a tablet may support multiple
// devices with the same DeviceToolType, but having different hardware
// identificators.
func (t *DeviceToolClass) HardwareID() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_hardware_id(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Serial gets the serial of this tool, this value can be used to identify a
// physical tool (eg. a tablet pen) across program executions.
func (t *DeviceToolClass) Serial() uint64 {
	var _arg0 *C.GdkDeviceTool // out
	var _cret C.guint64        // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_serial(_arg0)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToolType gets the DeviceToolType of the tool.
func (t *DeviceToolClass) ToolType() DeviceToolType {
	var _arg0 *C.GdkDeviceTool    // out
	var _cret C.GdkDeviceToolType // in

	_arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	_cret = C.gdk_device_tool_get_tool_type(_arg0)

	var _deviceToolType DeviceToolType // out

	_deviceToolType = (DeviceToolType)(_cret)

	return _deviceToolType
}

type DragContext interface {
	gextras.Objector

	// Actions determines the bitmask of actions proposed by the source if
	// gdk_drag_context_get_suggested_action() returns GDK_ACTION_ASK.
	Actions() DragAction
	// DestWindow returns the destination window for the DND operation.
	DestWindow() *WindowClass
	// Device returns the Device associated to the drag context.
	Device() *DeviceClass
	// DragWindow returns the window on which the drag icon should be rendered
	// during the drag operation. Note that the window may not be available
	// until the drag operation has begun. GDK will move the window in
	// accordance with the ongoing drag operation. The window is owned by
	// @context and will be destroyed when the drag operation is over.
	DragWindow() *WindowClass
	// Protocol returns the drag protocol that is used by this context.
	Protocol() DragProtocol
	// SelectedAction determines the action chosen by the drag destination.
	SelectedAction() DragAction
	// SourceWindow returns the Window where the DND operation started.
	SourceWindow() *WindowClass
	// SuggestedAction determines the suggested drag action of the context.
	SuggestedAction() DragAction
	// SetDevice associates a Device to @context, so all Drag and Drop events
	// for @context are emitted as if they came from this device.
	SetDevice(device Device)
	// SetHotspot sets the position of the drag window that will be kept under
	// the cursor hotspot. Initially, the hotspot is at the top left corner of
	// the drag window.
	SetHotspot(hotX int, hotY int)
}

// DragContextClass implements the DragContext interface.
type DragContextClass struct {
	*externglib.Object
}

var _ DragContext = (*DragContextClass)(nil)

func wrapDragContext(obj *externglib.Object) DragContext {
	return &DragContextClass{
		Object: obj,
	}
}

func marshalDragContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDragContext(obj), nil
}

// Actions determines the bitmask of actions proposed by the source if
// gdk_drag_context_get_suggested_action() returns GDK_ACTION_ASK.
func (c *DragContextClass) Actions() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_actions(_arg0)

	var _dragAction DragAction // out

	_dragAction = (DragAction)(_cret)

	return _dragAction
}

// DestWindow returns the destination window for the DND operation.
func (c *DragContextClass) DestWindow() *WindowClass {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_dest_window(_arg0)

	var _window *WindowClass // out

	_window = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*WindowClass)

	return _window
}

// Device returns the Device associated to the drag context.
func (c *DragContextClass) Device() *DeviceClass {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkDevice      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_device(_arg0)

	var _device *DeviceClass // out

	_device = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*DeviceClass)

	return _device
}

// DragWindow returns the window on which the drag icon should be rendered
// during the drag operation. Note that the window may not be available until
// the drag operation has begun. GDK will move the window in accordance with the
// ongoing drag operation. The window is owned by @context and will be destroyed
// when the drag operation is over.
func (c *DragContextClass) DragWindow() *WindowClass {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_drag_window(_arg0)

	var _window *WindowClass // out

	_window = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*WindowClass)

	return _window
}

// Protocol returns the drag protocol that is used by this context.
func (c *DragContextClass) Protocol() DragProtocol {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragProtocol // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_protocol(_arg0)

	var _dragProtocol DragProtocol // out

	_dragProtocol = (DragProtocol)(_cret)

	return _dragProtocol
}

// SelectedAction determines the action chosen by the drag destination.
func (c *DragContextClass) SelectedAction() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_selected_action(_arg0)

	var _dragAction DragAction // out

	_dragAction = (DragAction)(_cret)

	return _dragAction
}

// SourceWindow returns the Window where the DND operation started.
func (c *DragContextClass) SourceWindow() *WindowClass {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_source_window(_arg0)

	var _window *WindowClass // out

	_window = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(*WindowClass)

	return _window
}

// SuggestedAction determines the suggested drag action of the context.
func (c *DragContextClass) SuggestedAction() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	_cret = C.gdk_drag_context_get_suggested_action(_arg0)

	var _dragAction DragAction // out

	_dragAction = (DragAction)(_cret)

	return _dragAction
}

// SetDevice associates a Device to @context, so all Drag and Drop events for
// @context are emitted as if they came from this device.
func (c *DragContextClass) SetDevice(device Device) {
	var _arg0 *C.GdkDragContext // out
	var _arg1 *C.GdkDevice      // out

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gdk_drag_context_set_device(_arg0, _arg1)
}

// SetHotspot sets the position of the drag window that will be kept under the
// cursor hotspot. Initially, the hotspot is at the top left corner of the drag
// window.
func (c *DragContextClass) SetHotspot(hotX int, hotY int) {
	var _arg0 *C.GdkDragContext // out
	var _arg1 C.gint            // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))
	_arg1 = C.gint(hotX)
	_arg2 = C.gint(hotY)

	C.gdk_drag_context_set_hotspot(_arg0, _arg1, _arg2)
}
