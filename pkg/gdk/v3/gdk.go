// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk/gdk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_axis_use_get_type()), F: marshalAxisUse},
		{T: externglib.Type(C.gdk_byte_order_get_type()), F: marshalByteOrder},
		{T: externglib.Type(C.gdk_crossing_mode_get_type()), F: marshalCrossingMode},
		{T: externglib.Type(C.gdk_cursor_type_get_type()), F: marshalCursorType},
		{T: externglib.Type(C.gdk_device_pad_feature_get_type()), F: marshalDevicePadFeature},
		{T: externglib.Type(C.gdk_device_tool_type_get_type()), F: marshalDeviceToolType},
		{T: externglib.Type(C.gdk_device_type_get_type()), F: marshalDeviceType},
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_drag_protocol_get_type()), F: marshalDragProtocol},
		{T: externglib.Type(C.gdk_event_type_get_type()), F: marshalEventType},
		{T: externglib.Type(C.gdk_filter_return_get_type()), F: marshalFilterReturn},
		{T: externglib.Type(C.gdk_fullscreen_mode_get_type()), F: marshalFullscreenMode},
		{T: externglib.Type(C.gdk_gl_error_get_type()), F: marshalGLError},
		{T: externglib.Type(C.gdk_grab_ownership_get_type()), F: marshalGrabOwnership},
		{T: externglib.Type(C.gdk_grab_status_get_type()), F: marshalGrabStatus},
		{T: externglib.Type(C.gdk_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.gdk_input_mode_get_type()), F: marshalInputMode},
		{T: externglib.Type(C.gdk_input_source_get_type()), F: marshalInputSource},
		{T: externglib.Type(C.gdk_modifier_intent_get_type()), F: marshalModifierIntent},
		{T: externglib.Type(C.gdk_notify_type_get_type()), F: marshalNotifyType},
		{T: externglib.Type(C.gdk_owner_change_get_type()), F: marshalOwnerChange},
		{T: externglib.Type(C.gdk_prop_mode_get_type()), F: marshalPropMode},
		{T: externglib.Type(C.gdk_property_state_get_type()), F: marshalPropertyState},
		{T: externglib.Type(C.gdk_scroll_direction_get_type()), F: marshalScrollDirection},
		{T: externglib.Type(C.gdk_setting_action_get_type()), F: marshalSettingAction},
		{T: externglib.Type(C.gdk_status_get_type()), F: marshalStatus},
		{T: externglib.Type(C.gdk_subpixel_layout_get_type()), F: marshalSubpixelLayout},
		{T: externglib.Type(C.gdk_touchpad_gesture_phase_get_type()), F: marshalTouchpadGesturePhase},
		{T: externglib.Type(C.gdk_visibility_state_get_type()), F: marshalVisibilityState},
		{T: externglib.Type(C.gdk_visual_type_get_type()), F: marshalVisualType},
		{T: externglib.Type(C.gdk_window_edge_get_type()), F: marshalWindowEdge},
		{T: externglib.Type(C.gdk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gdk_window_type_hint_get_type()), F: marshalWindowTypeHint},
		{T: externglib.Type(C.gdk_window_window_class_get_type()), F: marshalWindowWindowClass},
		{T: externglib.Type(C.gdk_anchor_hints_get_type()), F: marshalAnchorHints},
		{T: externglib.Type(C.gdk_axis_flags_get_type()), F: marshalAxisFlags},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
		{T: externglib.Type(C.gdk_event_mask_get_type()), F: marshalEventMask},
		{T: externglib.Type(C.gdk_frame_clock_phase_get_type()), F: marshalFrameClockPhase},
		{T: externglib.Type(C.gdk_modifier_type_get_type()), F: marshalModifierType},
		{T: externglib.Type(C.gdk_seat_capabilities_get_type()), F: marshalSeatCapabilities},
		{T: externglib.Type(C.gdk_wm_decoration_get_type()), F: marshalWMDecoration},
		{T: externglib.Type(C.gdk_wm_function_get_type()), F: marshalWMFunction},
		{T: externglib.Type(C.gdk_window_attributes_type_get_type()), F: marshalWindowAttributesType},
		{T: externglib.Type(C.gdk_window_hints_get_type()), F: marshalWindowHints},
		{T: externglib.Type(C.gdk_window_state_get_type()), F: marshalWindowState},
		{T: externglib.Type(C.gdk_app_launch_context_get_type()), F: marshalAppLaunchContext},
		{T: externglib.Type(C.gdk_cursor_get_type()), F: marshalCursor},
		{T: externglib.Type(C.gdk_device_get_type()), F: marshalDevice},
		{T: externglib.Type(C.gdk_device_manager_get_type()), F: marshalDeviceManager},
		{T: externglib.Type(C.gdk_device_tool_get_type()), F: marshalDeviceTool},
		{T: externglib.Type(C.gdk_display_get_type()), F: marshalDisplay},
		{T: externglib.Type(C.gdk_display_manager_get_type()), F: marshalDisplayManager},
		{T: externglib.Type(C.gdk_drag_context_get_type()), F: marshalDragContext},
		{T: externglib.Type(C.gdk_gl_context_get_type()), F: marshalGLContext},
		{T: externglib.Type(C.gdk_keymap_get_type()), F: marshalKeymap},
		{T: externglib.Type(C.gdk_screen_get_type()), F: marshalScreen},
		{T: externglib.Type(C.gdk_seat_get_type()), F: marshalSeat},
		{T: externglib.Type(C.gdk_visual_get_type()), F: marshalVisual},
	})
}

// AxisUse: an enumeration describing the way in which a device axis (valuator)
// maps onto the predefined valuator types that GTK+ understands.
//
// Note that the X and Y axes are not really needed; pointer devices report
// their location via the x/y members of events regardless. Whether X and Y are
// present as axes depends on the GDK backend.
type AxisUse int

const (
	// AxisUseIgnore: the axis is ignored.
	AxisUseIgnore AxisUse = 0
	// AxisUseX: the axis is used as the x axis.
	AxisUseX AxisUse = 1
	// AxisUseY: the axis is used as the y axis.
	AxisUseY AxisUse = 2
	// AxisUsePressure: the axis is used for pressure information.
	AxisUsePressure AxisUse = 3
	// AxisUseXtilt: the axis is used for x tilt information.
	AxisUseXtilt AxisUse = 4
	// AxisUseYtilt: the axis is used for y tilt information.
	AxisUseYtilt AxisUse = 5
	// AxisUseWheel: the axis is used for wheel information.
	AxisUseWheel AxisUse = 6
	// AxisUseDistance: the axis is used for pen/tablet distance information.
	// (Since: 3.22)
	AxisUseDistance AxisUse = 7
	// AxisUseRotation: the axis is used for pen rotation information. (Since:
	// 3.22)
	AxisUseRotation AxisUse = 8
	// AxisUseSlider: the axis is used for pen slider information. (Since: 3.22)
	AxisUseSlider AxisUse = 9
	// AxisUseLast: a constant equal to the numerically highest axis value.
	AxisUseLast AxisUse = 10
)

func marshalAxisUse(p uintptr) (interface{}, error) {
	return AxisUse(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ByteOrder: a set of values describing the possible byte-orders for storing
// pixel values in memory.
type ByteOrder int

const (
	// ByteOrderLsbFirst: the values are stored with the least-significant byte
	// first. For instance, the 32-bit value 0xffeecc would be stored in memory
	// as 0xcc, 0xee, 0xff, 0x00.
	ByteOrderLsbFirst ByteOrder = 0
	// ByteOrderMsbFirst: the values are stored with the most-significant byte
	// first. For instance, the 32-bit value 0xffeecc would be stored in memory
	// as 0x00, 0xff, 0xee, 0xcc.
	ByteOrderMsbFirst ByteOrder = 1
)

func marshalByteOrder(p uintptr) (interface{}, error) {
	return ByteOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CrossingMode specifies the crossing mode for EventCrossing.
type CrossingMode int

const (
	// CrossingModeNormal: crossing because of pointer motion.
	CrossingModeNormal CrossingMode = 0
	// CrossingModeGrab: crossing because a grab is activated.
	CrossingModeGrab CrossingMode = 1
	// CrossingModeUngrab: crossing because a grab is deactivated.
	CrossingModeUngrab CrossingMode = 2
	// CrossingModeGTKGrab: crossing because a GTK+ grab is activated.
	CrossingModeGTKGrab CrossingMode = 3
	// CrossingModeGTKUngrab: crossing because a GTK+ grab is deactivated.
	CrossingModeGTKUngrab CrossingMode = 4
	// CrossingModeStateChanged: crossing because a GTK+ widget changed state
	// (e.g. sensitivity).
	CrossingModeStateChanged CrossingMode = 5
	// CrossingModeTouchBegin: crossing because a touch sequence has begun, this
	// event is synthetic as the pointer might have not left the window.
	CrossingModeTouchBegin CrossingMode = 6
	// CrossingModeTouchEnd: crossing because a touch sequence has ended, this
	// event is synthetic as the pointer might have not left the window.
	CrossingModeTouchEnd CrossingMode = 7
	// CrossingModeDeviceSwitch: crossing because of a device switch (i.e. a
	// mouse taking control of the pointer after a touch device), this event is
	// synthetic as the pointer didn’t leave the window.
	CrossingModeDeviceSwitch CrossingMode = 8
)

func marshalCrossingMode(p uintptr) (interface{}, error) {
	return CrossingMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CursorType: predefined cursors.
//
// Note that these IDs are directly taken from the X cursor font, and many of
// these cursors are either not useful, or are not available on other platforms.
//
// The recommended way to create cursors is to use gdk_cursor_new_from_name().
type CursorType int

const (
	// CursorTypeXCursor: ! (X_cursor.png)
	CursorTypeXCursor CursorType = 0
	// CursorTypeArrow: ! (arrow.png)
	CursorTypeArrow CursorType = 2
	// CursorTypeBasedArrowDown: ! (based_arrow_down.png)
	CursorTypeBasedArrowDown CursorType = 4
	// CursorTypeBasedArrowUp: ! (based_arrow_up.png)
	CursorTypeBasedArrowUp CursorType = 6
	// CursorTypeBoat: ! (boat.png)
	CursorTypeBoat CursorType = 8
	// CursorTypeBogosity: ! (bogosity.png)
	CursorTypeBogosity CursorType = 10
	// CursorTypeBottomLeftCorner: ! (bottom_left_corner.png)
	CursorTypeBottomLeftCorner CursorType = 12
	// CursorTypeBottomRightCorner: ! (bottom_right_corner.png)
	CursorTypeBottomRightCorner CursorType = 14
	// CursorTypeBottomSide: ! (bottom_side.png)
	CursorTypeBottomSide CursorType = 16
	// CursorTypeBottomTee: ! (bottom_tee.png)
	CursorTypeBottomTee CursorType = 18
	// CursorTypeBoxSpiral: ! (box_spiral.png)
	CursorTypeBoxSpiral CursorType = 20
	// CursorTypeCenterPtr: ! (center_ptr.png)
	CursorTypeCenterPtr CursorType = 22
	// CursorTypeCircle: ! (circle.png)
	CursorTypeCircle CursorType = 24
	// CursorTypeClock: ! (clock.png)
	CursorTypeClock CursorType = 26
	// CursorTypeCoffeeMug: ! (coffee_mug.png)
	CursorTypeCoffeeMug CursorType = 28
	// CursorTypeCross: ! (cross.png)
	CursorTypeCross CursorType = 30
	// CursorTypeCrossReverse: ! (cross_reverse.png)
	CursorTypeCrossReverse CursorType = 32
	// CursorTypeCrosshair: ! (crosshair.png)
	CursorTypeCrosshair CursorType = 34
	// CursorTypeDiamondCross: ! (diamond_cross.png)
	CursorTypeDiamondCross CursorType = 36
	// CursorTypeDot: ! (dot.png)
	CursorTypeDot CursorType = 38
	// CursorTypeDotbox: ! (dotbox.png)
	CursorTypeDotbox CursorType = 40
	// CursorTypeDoubleArrow: ! (double_arrow.png)
	CursorTypeDoubleArrow CursorType = 42
	// CursorTypeDraftLarge: ! (draft_large.png)
	CursorTypeDraftLarge CursorType = 44
	// CursorTypeDraftSmall: ! (draft_small.png)
	CursorTypeDraftSmall CursorType = 46
	// CursorTypeDrapedBox: ! (draped_box.png)
	CursorTypeDrapedBox CursorType = 48
	// CursorTypeExchange: ! (exchange.png)
	CursorTypeExchange CursorType = 50
	// CursorTypeFleur: ! (fleur.png)
	CursorTypeFleur CursorType = 52
	// CursorTypeGobbler: ! (gobbler.png)
	CursorTypeGobbler CursorType = 54
	// CursorTypeGumby: ! (gumby.png)
	CursorTypeGumby CursorType = 56
	// CursorTypeHand1: ! (hand1.png)
	CursorTypeHand1 CursorType = 58
	// CursorTypeHand2: ! (hand2.png)
	CursorTypeHand2 CursorType = 60
	// CursorTypeHeart: ! (heart.png)
	CursorTypeHeart CursorType = 62
	// CursorTypeIcon: ! (icon.png)
	CursorTypeIcon CursorType = 64
	// CursorTypeIronCross: ! (iron_cross.png)
	CursorTypeIronCross CursorType = 66
	// CursorTypeLeftPtr: ! (left_ptr.png)
	CursorTypeLeftPtr CursorType = 68
	// CursorTypeLeftSide: ! (left_side.png)
	CursorTypeLeftSide CursorType = 70
	// CursorTypeLeftTee: ! (left_tee.png)
	CursorTypeLeftTee CursorType = 72
	// CursorTypeLeftbutton: ! (leftbutton.png)
	CursorTypeLeftbutton CursorType = 74
	// CursorTypeLlAngle: ! (ll_angle.png)
	CursorTypeLlAngle CursorType = 76
	// CursorTypeLrAngle: ! (lr_angle.png)
	CursorTypeLrAngle CursorType = 78
	// CursorTypeMan: ! (man.png)
	CursorTypeMan CursorType = 80
	// CursorTypeMiddlebutton: ! (middlebutton.png)
	CursorTypeMiddlebutton CursorType = 82
	// CursorTypeMouse: ! (mouse.png)
	CursorTypeMouse CursorType = 84
	// CursorTypePencil: ! (pencil.png)
	CursorTypePencil CursorType = 86
	// CursorTypePirate: ! (pirate.png)
	CursorTypePirate CursorType = 88
	// CursorTypePlus: ! (plus.png)
	CursorTypePlus CursorType = 90
	// CursorTypeQuestionArrow: ! (question_arrow.png)
	CursorTypeQuestionArrow CursorType = 92
	// CursorTypeRightPtr: ! (right_ptr.png)
	CursorTypeRightPtr CursorType = 94
	// CursorTypeRightSide: ! (right_side.png)
	CursorTypeRightSide CursorType = 96
	// CursorTypeRightTee: ! (right_tee.png)
	CursorTypeRightTee CursorType = 98
	// CursorTypeRightbutton: ! (rightbutton.png)
	CursorTypeRightbutton CursorType = 100
	// CursorTypeRTLLogo: ! (rtl_logo.png)
	CursorTypeRTLLogo CursorType = 102
	// CursorTypeSailboat: ! (sailboat.png)
	CursorTypeSailboat CursorType = 104
	// CursorTypeSbDownArrow: ! (sb_down_arrow.png)
	CursorTypeSbDownArrow CursorType = 106
	// CursorTypeSbHDoubleArrow: ! (sb_h_double_arrow.png)
	CursorTypeSbHDoubleArrow CursorType = 108
	// CursorTypeSbLeftArrow: ! (sb_left_arrow.png)
	CursorTypeSbLeftArrow CursorType = 110
	// CursorTypeSbRightArrow: ! (sb_right_arrow.png)
	CursorTypeSbRightArrow CursorType = 112
	// CursorTypeSbUpArrow: ! (sb_up_arrow.png)
	CursorTypeSbUpArrow CursorType = 114
	// CursorTypeSbVDoubleArrow: ! (sb_v_double_arrow.png)
	CursorTypeSbVDoubleArrow CursorType = 116
	// CursorTypeShuttle: ! (shuttle.png)
	CursorTypeShuttle CursorType = 118
	// CursorTypeSizing: ! (sizing.png)
	CursorTypeSizing CursorType = 120
	// CursorTypeSpider: ! (spider.png)
	CursorTypeSpider CursorType = 122
	// CursorTypeSpraycan: ! (spraycan.png)
	CursorTypeSpraycan CursorType = 124
	// CursorTypeStar: ! (star.png)
	CursorTypeStar CursorType = 126
	// CursorTypeTarget: ! (target.png)
	CursorTypeTarget CursorType = 128
	// CursorTypeTcross: ! (tcross.png)
	CursorTypeTcross CursorType = 130
	// CursorTypeTopLeftArrow: ! (top_left_arrow.png)
	CursorTypeTopLeftArrow CursorType = 132
	// CursorTypeTopLeftCorner: ! (top_left_corner.png)
	CursorTypeTopLeftCorner CursorType = 134
	// CursorTypeTopRightCorner: ! (top_right_corner.png)
	CursorTypeTopRightCorner CursorType = 136
	// CursorTypeTopSide: ! (top_side.png)
	CursorTypeTopSide CursorType = 138
	// CursorTypeTopTee: ! (top_tee.png)
	CursorTypeTopTee CursorType = 140
	// CursorTypeTrek: ! (trek.png)
	CursorTypeTrek CursorType = 142
	// CursorTypeUlAngle: ! (ul_angle.png)
	CursorTypeUlAngle CursorType = 144
	// CursorTypeUmbrella: ! (umbrella.png)
	CursorTypeUmbrella CursorType = 146
	// CursorTypeUrAngle: ! (ur_angle.png)
	CursorTypeUrAngle CursorType = 148
	// CursorTypeWatch: ! (watch.png)
	CursorTypeWatch CursorType = 150
	// CursorTypeXterm: ! (xterm.png)
	CursorTypeXterm CursorType = 152
	// CursorTypeLastCursor: last cursor type
	CursorTypeLastCursor CursorType = 153
	// CursorTypeBlankCursor: blank cursor. Since 2.16
	CursorTypeBlankCursor CursorType = -2
	// CursorTypeCursorIsPixmap: type of cursors constructed with
	// gdk_cursor_new_from_pixbuf()
	CursorTypeCursorIsPixmap CursorType = -1
)

func marshalCursorType(p uintptr) (interface{}, error) {
	return CursorType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DevicePadFeature: a pad feature.
type DevicePadFeature int

const (
	// DevicePadFeatureButton: a button
	DevicePadFeatureButton DevicePadFeature = 0
	// DevicePadFeatureRing: a ring-shaped interactive area
	DevicePadFeatureRing DevicePadFeature = 1
	// DevicePadFeatureStrip: a straight interactive area
	DevicePadFeatureStrip DevicePadFeature = 2
)

func marshalDevicePadFeature(p uintptr) (interface{}, error) {
	return DevicePadFeature(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeviceToolType indicates the specific type of tool being used being a tablet.
// Such as an airbrush, pencil, etc.
type DeviceToolType int

const (
	// DeviceToolTypeUnknown: tool is of an unknown type.
	DeviceToolTypeUnknown DeviceToolType = 0
	// DeviceToolTypePen: tool is a standard tablet stylus.
	DeviceToolTypePen DeviceToolType = 1
	// DeviceToolTypeEraser: tool is standard tablet eraser.
	DeviceToolTypeEraser DeviceToolType = 2
	// DeviceToolTypeBrush: tool is a brush stylus.
	DeviceToolTypeBrush DeviceToolType = 3
	// DeviceToolTypePencil: tool is a pencil stylus.
	DeviceToolTypePencil DeviceToolType = 4
	// DeviceToolTypeAirbrush: tool is an airbrush stylus.
	DeviceToolTypeAirbrush DeviceToolType = 5
	// DeviceToolTypeMouse: tool is a mouse.
	DeviceToolTypeMouse DeviceToolType = 6
	// DeviceToolTypeLens: tool is a lens cursor.
	DeviceToolTypeLens DeviceToolType = 7
)

func marshalDeviceToolType(p uintptr) (interface{}, error) {
	return DeviceToolType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DeviceType indicates the device type. See
// [above][GdkDeviceManager.description] for more information about the meaning
// of these device types.
type DeviceType int

const (
	// DeviceTypeMaster: device is a master (or virtual) device. There will be
	// an associated focus indicator on the screen.
	DeviceTypeMaster DeviceType = 0
	// DeviceTypeSlave: device is a slave (or physical) device.
	DeviceTypeSlave DeviceType = 1
	// DeviceTypeFloating: device is a physical device, currently not attached
	// to any virtual device.
	DeviceTypeFloating DeviceType = 2
)

func marshalDeviceType(p uintptr) (interface{}, error) {
	return DeviceType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragCancelReason: used in DragContext to the reason of a cancelled DND
// operation.
type DragCancelReason int

const (
	// DragCancelReasonNoTarget: there is no suitable drop target.
	DragCancelReasonNoTarget DragCancelReason = 0
	// DragCancelReasonUserCancelled: drag cancelled by the user
	DragCancelReasonUserCancelled DragCancelReason = 1
	// DragCancelReasonError: unspecified error.
	DragCancelReasonError DragCancelReason = 2
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragProtocol: used in DragContext to indicate the protocol according to which
// DND is done.
type DragProtocol int

const (
	// DragProtocolNone: no protocol.
	DragProtocolNone DragProtocol = 0
	// DragProtocolMotif: the Motif DND protocol. No longer supported
	DragProtocolMotif DragProtocol = 1
	// DragProtocolXdnd: the Xdnd protocol.
	DragProtocolXdnd DragProtocol = 2
	// DragProtocolRootwin: an extension to the Xdnd protocol for unclaimed root
	// window drops.
	DragProtocolRootwin DragProtocol = 3
	// DragProtocolWin32Dropfiles: the simple WM_DROPFILES protocol.
	DragProtocolWin32Dropfiles DragProtocol = 4
	// DragProtocolOle2: the complex OLE2 DND protocol (not implemented).
	DragProtocolOle2 DragProtocol = 5
	// DragProtocolLocal: intra-application DND.
	DragProtocolLocal DragProtocol = 6
	// DragProtocolWayland: wayland DND protocol.
	DragProtocolWayland DragProtocol = 7
)

func marshalDragProtocol(p uintptr) (interface{}, error) {
	return DragProtocol(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventType specifies the type of the event.
//
// Do not confuse these events with the signals that GTK+ widgets emit. Although
// many of these events result in corresponding signals being emitted, the
// events are often transformed or filtered along the way.
//
// In some language bindings, the values GDK_2BUTTON_PRESS and GDK_3BUTTON_PRESS
// would translate into something syntactically invalid (eg
// `Gdk.EventType.2ButtonPress`, where a symbol is not allowed to start with a
// number). In that case, the aliases GDK_DOUBLE_BUTTON_PRESS and
// GDK_TRIPLE_BUTTON_PRESS can be used instead.
type EventType int

const (
	// EventTypeNothing: a special code to indicate a null event.
	EventTypeNothing EventType = -1
	// EventTypeDelete: the window manager has requested that the toplevel
	// window be hidden or destroyed, usually when the user clicks on a special
	// icon in the title bar.
	EventTypeDelete EventType = 0
	// EventTypeDestroy: the window has been destroyed.
	EventTypeDestroy EventType = 1
	// EventTypeExpose: all or part of the window has become visible and needs
	// to be redrawn.
	EventTypeExpose EventType = 2
	// EventTypeMotionNotify: the pointer (usually a mouse) has moved.
	EventTypeMotionNotify EventType = 3
	// EventTypeButtonPress: a mouse button has been pressed.
	EventTypeButtonPress EventType = 4
	// EventType2ButtonPress: a mouse button has been double-clicked (clicked
	// twice within a short period of time). Note that each click also generates
	// a GDK_BUTTON_PRESS event.
	EventType2ButtonPress EventType = 5
	// EventTypeDoubleButtonPress alias for GDK_2BUTTON_PRESS, added in 3.6.
	EventTypeDoubleButtonPress EventType = 5
	// EventType3ButtonPress: a mouse button has been clicked 3 times in a short
	// period of time. Note that each click also generates a GDK_BUTTON_PRESS
	// event.
	EventType3ButtonPress EventType = 6
	// EventTypeTripleButtonPress alias for GDK_3BUTTON_PRESS, added in 3.6.
	EventTypeTripleButtonPress EventType = 6
	// EventTypeButtonRelease: a mouse button has been released.
	EventTypeButtonRelease EventType = 7
	// EventTypeKeyPress: a key has been pressed.
	EventTypeKeyPress EventType = 8
	// EventTypeKeyRelease: a key has been released.
	EventTypeKeyRelease EventType = 9
	// EventTypeEnterNotify: the pointer has entered the window.
	EventTypeEnterNotify EventType = 10
	// EventTypeLeaveNotify: the pointer has left the window.
	EventTypeLeaveNotify EventType = 11
	// EventTypeFocusChange: the keyboard focus has entered or left the window.
	EventTypeFocusChange EventType = 12
	// EventTypeConfigure: the size, position or stacking order of the window
	// has changed. Note that GTK+ discards these events for GDK_WINDOW_CHILD
	// windows.
	EventTypeConfigure EventType = 13
	// EventTypeMap: the window has been mapped.
	EventTypeMap EventType = 14
	// EventTypeUnmap: the window has been unmapped.
	EventTypeUnmap EventType = 15
	// EventTypePropertyNotify: a property on the window has been changed or
	// deleted.
	EventTypePropertyNotify EventType = 16
	// EventTypeSelectionClear: the application has lost ownership of a
	// selection.
	EventTypeSelectionClear EventType = 17
	// EventTypeSelectionRequest: another application has requested a selection.
	EventTypeSelectionRequest EventType = 18
	// EventTypeSelectionNotify: a selection has been received.
	EventTypeSelectionNotify EventType = 19
	// EventTypeProximityIn: an input device has moved into contact with a
	// sensing surface (e.g. a touchscreen or graphics tablet).
	EventTypeProximityIn EventType = 20
	// EventTypeProximityOut: an input device has moved out of contact with a
	// sensing surface.
	EventTypeProximityOut EventType = 21
	// EventTypeDragEnter: the mouse has entered the window while a drag is in
	// progress.
	EventTypeDragEnter EventType = 22
	// EventTypeDragLeave: the mouse has left the window while a drag is in
	// progress.
	EventTypeDragLeave EventType = 23
	// EventTypeDragMotion: the mouse has moved in the window while a drag is in
	// progress.
	EventTypeDragMotion EventType = 24
	// EventTypeDragStatus: the status of the drag operation initiated by the
	// window has changed.
	EventTypeDragStatus EventType = 25
	// EventTypeDropStart: a drop operation onto the window has started.
	EventTypeDropStart EventType = 26
	// EventTypeDropFinished: the drop operation initiated by the window has
	// completed.
	EventTypeDropFinished EventType = 27
	// EventTypeClientEvent: a message has been received from another
	// application.
	EventTypeClientEvent EventType = 28
	// EventTypeVisibilityNotify: the window visibility status has changed.
	EventTypeVisibilityNotify EventType = 29
	// EventTypeScroll: the scroll wheel was turned
	EventTypeScroll EventType = 31
	// EventTypeWindowState: the state of a window has changed. See WindowState
	// for the possible window states
	EventTypeWindowState EventType = 32
	// EventTypeSetting: a setting has been modified.
	EventTypeSetting EventType = 33
	// EventTypeOwnerChange: the owner of a selection has changed. This event
	// type was added in 2.6
	EventTypeOwnerChange EventType = 34
	// EventTypeGrabBroken: a pointer or keyboard grab was broken. This event
	// type was added in 2.8.
	EventTypeGrabBroken EventType = 35
	// EventTypeDamage: the content of the window has been changed. This event
	// type was added in 2.14.
	EventTypeDamage EventType = 36
	// EventTypeTouchBegin: a new touch event sequence has just started. This
	// event type was added in 3.4.
	EventTypeTouchBegin EventType = 37
	// EventTypeTouchUpdate: a touch event sequence has been updated. This event
	// type was added in 3.4.
	EventTypeTouchUpdate EventType = 38
	// EventTypeTouchEnd: a touch event sequence has finished. This event type
	// was added in 3.4.
	EventTypeTouchEnd EventType = 39
	// EventTypeTouchCancel: a touch event sequence has been canceled. This
	// event type was added in 3.4.
	EventTypeTouchCancel EventType = 40
	// EventTypeTouchpadSwipe: a touchpad swipe gesture event, the current state
	// is determined by its phase field. This event type was added in 3.18.
	EventTypeTouchpadSwipe EventType = 41
	// EventTypeTouchpadPinch: a touchpad pinch gesture event, the current state
	// is determined by its phase field. This event type was added in 3.18.
	EventTypeTouchpadPinch EventType = 42
	// EventTypePadButtonPress: a tablet pad button press event. This event type
	// was added in 3.22.
	EventTypePadButtonPress EventType = 43
	// EventTypePadButtonRelease: a tablet pad button release event. This event
	// type was added in 3.22.
	EventTypePadButtonRelease EventType = 44
	// EventTypePadRing: a tablet pad axis event from a "ring". This event type
	// was added in 3.22.
	EventTypePadRing EventType = 45
	// EventTypePadStrip: a tablet pad axis event from a "strip". This event
	// type was added in 3.22.
	EventTypePadStrip EventType = 46
	// EventTypePadGroupMode: a tablet pad group mode change. This event type
	// was added in 3.22.
	EventTypePadGroupMode EventType = 47
	// EventTypeEventLast marks the end of the GdkEventType enumeration. Added
	// in 2.18
	EventTypeEventLast EventType = 48
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FilterReturn specifies the result of applying a FilterFunc to a native event.
type FilterReturn int

const (
	// FilterReturnContinue: event not handled, continue processing.
	FilterReturnContinue FilterReturn = 0
	// FilterReturnTranslate: native event translated into a GDK event and
	// stored in the `event` structure that was passed in.
	FilterReturnTranslate FilterReturn = 1
	// FilterReturnRemove: event handled, terminate processing.
	FilterReturnRemove FilterReturn = 2
)

func marshalFilterReturn(p uintptr) (interface{}, error) {
	return FilterReturn(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FullscreenMode indicates which monitor (in a multi-head setup) a window
// should span over when in fullscreen mode.
type FullscreenMode int

const (
	// FullscreenModeCurrentMonitor: fullscreen on current monitor only.
	FullscreenModeCurrentMonitor FullscreenMode = 0
	// FullscreenModeAllMonitors: span across all monitors when fullscreen.
	FullscreenModeAllMonitors FullscreenMode = 1
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GLError: error enumeration for GLContext.
type GLError int

const (
	// GLErrorNotAvailable: openGL support is not available
	GLErrorNotAvailable GLError = 0
	// GLErrorUnsupportedFormat: the requested visual format is not supported
	GLErrorUnsupportedFormat GLError = 1
	// GLErrorUnsupportedProfile: the requested profile is not supported
	GLErrorUnsupportedProfile GLError = 2
)

func marshalGLError(p uintptr) (interface{}, error) {
	return GLError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GrabOwnership defines how device grabs interact with other devices.
type GrabOwnership int

const (
	// GrabOwnershipNone: all other devices’ events are allowed.
	GrabOwnershipNone GrabOwnership = 0
	// GrabOwnershipWindow: other devices’ events are blocked for the grab
	// window.
	GrabOwnershipWindow GrabOwnership = 1
	// GrabOwnershipApplication: other devices’ events are blocked for the whole
	// application.
	GrabOwnershipApplication GrabOwnership = 2
)

func marshalGrabOwnership(p uintptr) (interface{}, error) {
	return GrabOwnership(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GrabStatus: returned by gdk_device_grab(), gdk_pointer_grab() and
// gdk_keyboard_grab() to indicate success or the reason for the failure of the
// grab attempt.
type GrabStatus int

const (
	// GrabStatusSuccess: the resource was successfully grabbed.
	GrabStatusSuccess GrabStatus = 0
	// GrabStatusAlreadyGrabbed: the resource is actively grabbed by another
	// client.
	GrabStatusAlreadyGrabbed GrabStatus = 1
	// GrabStatusInvalidTime: the resource was grabbed more recently than the
	// specified time.
	GrabStatusInvalidTime GrabStatus = 2
	// GrabStatusNotViewable: the grab window or the @confine_to window are not
	// viewable.
	GrabStatusNotViewable GrabStatus = 3
	// GrabStatusFrozen: the resource is frozen by an active grab of another
	// client.
	GrabStatusFrozen GrabStatus = 4
	// GrabStatusFailed: the grab failed for some other reason. Since 3.16
	GrabStatusFailed GrabStatus = 5
)

func marshalGrabStatus(p uintptr) (interface{}, error) {
	return GrabStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity defines the reference point of a window and the meaning of
// coordinates passed to gtk_window_move(). See gtk_window_move() and the
// "implementation notes" section of the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) specification for more
// details.
type Gravity int

const (
	// GravityNorthWest: the reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: the reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: the reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: the reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: the reference point is at the center of the window.
	GravityCenter Gravity = 5
	// GravityEast: the reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: the reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: the reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: the reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: the reference point is at the top left corner of the
	// window itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputMode: an enumeration that describes the mode of an input device.
type InputMode int

const (
	// InputModeDisabled: the device is disabled and will not report any events.
	InputModeDisabled InputMode = 0
	// InputModeScreen: the device is enabled. The device’s coordinate space
	// maps to the entire screen.
	InputModeScreen InputMode = 1
	// InputModeWindow: the device is enabled. The device’s coordinate space is
	// mapped to a single window. The manner in which this window is chosen is
	// undefined, but it will typically be the same way in which the focus
	// window for key events is determined.
	InputModeWindow InputMode = 2
)

func marshalInputMode(p uintptr) (interface{}, error) {
	return InputMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// InputSource: an enumeration describing the type of an input device in general
// terms.
type InputSource int

const (
	// InputSourceMouse: the device is a mouse. (This will be reported for the
	// core pointer, even if it is something else, such as a trackball.)
	InputSourceMouse InputSource = 0
	// InputSourcePen: the device is a stylus of a graphics tablet or similar
	// device.
	InputSourcePen InputSource = 1
	// InputSourceEraser: the device is an eraser. Typically, this would be the
	// other end of a stylus on a graphics tablet.
	InputSourceEraser InputSource = 2
	// InputSourceCursor: the device is a graphics tablet “puck” or similar
	// device.
	InputSourceCursor InputSource = 3
	// InputSourceKeyboard: the device is a keyboard.
	InputSourceKeyboard InputSource = 4
	// InputSourceTouchscreen: the device is a direct-input touch device, such
	// as a touchscreen or tablet. This device type has been added in 3.4.
	InputSourceTouchscreen InputSource = 5
	// InputSourceTouchpad: the device is an indirect touch device, such as a
	// touchpad. This device type has been added in 3.4.
	InputSourceTouchpad InputSource = 6
	// InputSourceTrackpoint: the device is a trackpoint. This device type has
	// been added in 3.22
	InputSourceTrackpoint InputSource = 7
	// InputSourceTabletPad: the device is a "pad", a collection of buttons,
	// rings and strips found in drawing tablets. This device type has been
	// added in 3.22.
	InputSourceTabletPad InputSource = 8
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierIntent: this enum is used with gdk_keymap_get_modifier_mask() in
// order to determine what modifiers the currently used windowing system backend
// uses for particular purposes. For example, on X11/Windows, the Control key is
// used for invoking menu shortcuts (accelerators), whereas on Apple computers
// it’s the Command key (which correspond to GDK_CONTROL_MASK and GDK_MOD2_MASK,
// respectively).
type ModifierIntent int

const (
	// ModifierIntentPrimaryAccelerator: the primary modifier used to invoke
	// menu accelerators.
	ModifierIntentPrimaryAccelerator ModifierIntent = 0
	// ModifierIntentContextMenu: the modifier used to invoke context menus.
	// Note that mouse button 3 always triggers context menus. When this
	// modifier is not 0, it additionally triggers context menus when used with
	// mouse button 1.
	ModifierIntentContextMenu ModifierIntent = 1
	// ModifierIntentExtendSelection: the modifier used to extend selections
	// using `modifier`-click or `modifier`-cursor-key
	ModifierIntentExtendSelection ModifierIntent = 2
	// ModifierIntentModifySelection: the modifier used to modify selections,
	// which in most cases means toggling the clicked item into or out of the
	// selection.
	ModifierIntentModifySelection ModifierIntent = 3
	// ModifierIntentNoTextInput: when any of these modifiers is pressed, the
	// key event cannot produce a symbol directly. This is meant to be used for
	// input methods, and for use cases like typeahead search.
	ModifierIntentNoTextInput ModifierIntent = 4
	// ModifierIntentShiftGroup: the modifier that switches between keyboard
	// groups (AltGr on X11/Windows and Option/Alt on OS X).
	ModifierIntentShiftGroup ModifierIntent = 5
	// ModifierIntentDefaultModMask: the set of modifier masks accepted as
	// modifiers in accelerators. Needed because Command is mapped to MOD2 on
	// OSX, which is widely used, but on X11 MOD2 is NumLock and using that for
	// a mod key is problematic at best. Ref:
	// https://bugzilla.gnome.org/show_bug.cgi?id=736125.
	ModifierIntentDefaultModMask ModifierIntent = 6
)

func marshalModifierIntent(p uintptr) (interface{}, error) {
	return ModifierIntent(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NotifyType specifies the kind of crossing for EventCrossing.
//
// See the X11 protocol specification of LeaveNotify for full details of
// crossing event generation.
type NotifyType int

const (
	// NotifyTypeAncestor: the window is entered from an ancestor or left
	// towards an ancestor.
	NotifyTypeAncestor NotifyType = 0
	// NotifyTypeVirtual: the pointer moves between an ancestor and an inferior
	// of the window.
	NotifyTypeVirtual NotifyType = 1
	// NotifyTypeInferior: the window is entered from an inferior or left
	// towards an inferior.
	NotifyTypeInferior NotifyType = 2
	// NotifyTypeNonlinear: the window is entered from or left towards a window
	// which is neither an ancestor nor an inferior.
	NotifyTypeNonlinear NotifyType = 3
	// NotifyTypeNonlinearVirtual: the pointer moves between two windows which
	// are not ancestors of each other and the window is part of the ancestor
	// chain between one of these windows and their least common ancestor.
	NotifyTypeNonlinearVirtual NotifyType = 4
	// NotifyTypeUnknown: an unknown type of enter/leave event occurred.
	NotifyTypeUnknown NotifyType = 5
)

func marshalNotifyType(p uintptr) (interface{}, error) {
	return NotifyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// OwnerChange specifies why a selection ownership was changed.
type OwnerChange int

const (
	// OwnerChangeNewOwner: some other app claimed the ownership
	OwnerChangeNewOwner OwnerChange = 0
	// OwnerChangeDestroy: the window was destroyed
	OwnerChangeDestroy OwnerChange = 1
	// OwnerChangeClose: the client was closed
	OwnerChangeClose OwnerChange = 2
)

func marshalOwnerChange(p uintptr) (interface{}, error) {
	return OwnerChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropMode describes how existing data is combined with new data when using
// gdk_property_change().
type PropMode int

const (
	// PropModeReplace: the new data replaces the existing data.
	PropModeReplace PropMode = 0
	// PropModePrepend: the new data is prepended to the existing data.
	PropModePrepend PropMode = 1
	// PropModeAppend: the new data is appended to the existing data.
	PropModeAppend PropMode = 2
)

func marshalPropMode(p uintptr) (interface{}, error) {
	return PropMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// PropertyState specifies the type of a property change for a EventProperty.
type PropertyState int

const (
	// PropertyStateNewValue: the property value was changed.
	PropertyStateNewValue PropertyState = 0
	// PropertyStateDelete: the property was deleted.
	PropertyStateDelete PropertyState = 1
)

func marshalPropertyState(p uintptr) (interface{}, error) {
	return PropertyState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ScrollDirection specifies the direction for EventScroll.
type ScrollDirection int

const (
	// ScrollDirectionUp: the window is scrolled up.
	ScrollDirectionUp ScrollDirection = 0
	// ScrollDirectionDown: the window is scrolled down.
	ScrollDirectionDown ScrollDirection = 1
	// ScrollDirectionLeft: the window is scrolled to the left.
	ScrollDirectionLeft ScrollDirection = 2
	// ScrollDirectionRight: the window is scrolled to the right.
	ScrollDirectionRight ScrollDirection = 3
	// ScrollDirectionSmooth: the scrolling is determined by the delta values in
	// EventScroll. See gdk_event_get_scroll_deltas(). Since: 3.4
	ScrollDirectionSmooth ScrollDirection = 4
)

func marshalScrollDirection(p uintptr) (interface{}, error) {
	return ScrollDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SettingAction specifies the kind of modification applied to a setting in a
// EventSetting.
type SettingAction int

const (
	// SettingActionNew: a setting was added.
	SettingActionNew SettingAction = 0
	// SettingActionChanged: a setting was changed.
	SettingActionChanged SettingAction = 1
	// SettingActionDeleted: a setting was deleted.
	SettingActionDeleted SettingAction = 2
)

func marshalSettingAction(p uintptr) (interface{}, error) {
	return SettingAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

type Status int

const (
	StatusOk         Status = 0
	StatusError      Status = -1
	StatusErrorParam Status = -2
	StatusErrorFile  Status = -3
	StatusErrorMem   Status = -4
)

func marshalStatus(p uintptr) (interface{}, error) {
	return Status(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SubpixelLayout: this enumeration describes how the red, green and blue
// components of physical pixels on an output device are laid out.
type SubpixelLayout int

const (
	// SubpixelLayoutUnknown: the layout is not known
	SubpixelLayoutUnknown SubpixelLayout = 0
	// SubpixelLayoutNone: not organized in this way
	SubpixelLayoutNone SubpixelLayout = 1
	// SubpixelLayoutHorizontalRGB: the layout is horizontal, the order is RGB
	SubpixelLayoutHorizontalRGB SubpixelLayout = 2
	// SubpixelLayoutHorizontalBGR: the layout is horizontal, the order is BGR
	SubpixelLayoutHorizontalBGR SubpixelLayout = 3
	// SubpixelLayoutVerticalRGB: the layout is vertical, the order is RGB
	SubpixelLayoutVerticalRGB SubpixelLayout = 4
	// SubpixelLayoutVerticalBGR: the layout is vertical, the order is BGR
	SubpixelLayoutVerticalBGR SubpixelLayout = 5
)

func marshalSubpixelLayout(p uintptr) (interface{}, error) {
	return SubpixelLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TouchpadGesturePhase specifies the current state of a touchpad gesture. All
// gestures are guaranteed to begin with an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_BEGIN, followed by 0 or several events with phase
// GDK_TOUCHPAD_GESTURE_PHASE_UPDATE.
//
// A finished gesture may have 2 possible outcomes, an event with phase
// GDK_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is considered
// successful, this should be used as the hint to perform any permanent changes.
//
// Cancelled gestures may be so for a variety of reasons, due to hardware or the
// compositor, or due to the gesture recognition layers hinting the gesture did
// not finish resolutely (eg. a 3rd finger being added during a pinch gesture).
// In these cases, the last event will report the phase
// GDK_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint to undo any
// visible/permanent changes that were done throughout the progress of the
// gesture.
//
// See also EventTouchpadSwipe and EventTouchpadPinch.
type TouchpadGesturePhase int

const (
	// TouchpadGesturePhaseBegin: the gesture has begun.
	TouchpadGesturePhaseBegin TouchpadGesturePhase = 0
	// TouchpadGesturePhaseUpdate: the gesture has been updated.
	TouchpadGesturePhaseUpdate TouchpadGesturePhase = 1
	// TouchpadGesturePhaseEnd: the gesture was finished, changes should be
	// permanently applied.
	TouchpadGesturePhaseEnd TouchpadGesturePhase = 2
	// TouchpadGesturePhaseCancel: the gesture was cancelled, all changes should
	// be undone.
	TouchpadGesturePhaseCancel TouchpadGesturePhase = 3
)

func marshalTouchpadGesturePhase(p uintptr) (interface{}, error) {
	return TouchpadGesturePhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VisibilityState specifies the visiblity status of a window for a
// EventVisibility.
type VisibilityState int

const (
	// VisibilityStateUnobscured: the window is completely visible.
	VisibilityStateUnobscured VisibilityState = 0
	// VisibilityStatePartial: the window is partially visible.
	VisibilityStatePartial VisibilityState = 1
	// VisibilityStateFullyObscured: the window is not visible at all.
	VisibilityStateFullyObscured VisibilityState = 2
)

func marshalVisibilityState(p uintptr) (interface{}, error) {
	return VisibilityState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// VisualType: a set of values that describe the manner in which the pixel
// values for a visual are converted into RGB values for display.
type VisualType int

const (
	// VisualTypeStaticGray: each pixel value indexes a grayscale value
	// directly.
	VisualTypeStaticGray VisualType = 0
	// VisualTypeGrayscale: each pixel is an index into a color map that maps
	// pixel values into grayscale values. The color map can be changed by an
	// application.
	VisualTypeGrayscale VisualType = 1
	// VisualTypeStaticColor: each pixel value is an index into a predefined,
	// unmodifiable color map that maps pixel values into RGB values.
	VisualTypeStaticColor VisualType = 2
	// VisualTypePseudoColor: each pixel is an index into a color map that maps
	// pixel values into rgb values. The color map can be changed by an
	// application.
	VisualTypePseudoColor VisualType = 3
	// VisualTypeTrueColor: each pixel value directly contains red, green, and
	// blue components. Use gdk_visual_get_red_pixel_details(), etc, to obtain
	// information about how the components are assembled into a pixel value.
	VisualTypeTrueColor VisualType = 4
	// VisualTypeDirectColor: each pixel value contains red, green, and blue
	// components as for GDK_VISUAL_TRUE_COLOR, but the components are mapped
	// via a color table into the final output table instead of being converted
	// directly.
	VisualTypeDirectColor VisualType = 5
)

func marshalVisualType(p uintptr) (interface{}, error) {
	return VisualType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowEdge determines a window edge or corner.
type WindowEdge int

const (
	// WindowEdgeNorthWest: the top left corner.
	WindowEdgeNorthWest WindowEdge = 0
	// WindowEdgeNorth: the top edge.
	WindowEdgeNorth WindowEdge = 1
	// WindowEdgeNorthEast: the top right corner.
	WindowEdgeNorthEast WindowEdge = 2
	// WindowEdgeWest: the left edge.
	WindowEdgeWest WindowEdge = 3
	// WindowEdgeEast: the right edge.
	WindowEdgeEast WindowEdge = 4
	// WindowEdgeSouthWest: the lower left corner.
	WindowEdgeSouthWest WindowEdge = 5
	// WindowEdgeSouth: the lower edge.
	WindowEdgeSouth WindowEdge = 6
	// WindowEdgeSouthEast: the lower right corner.
	WindowEdgeSouthEast WindowEdge = 7
)

func marshalWindowEdge(p uintptr) (interface{}, error) {
	return WindowEdge(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowType describes the kind of window.
type WindowType int

const (
	// WindowTypeRoot: root window; this window has no parent, covers the entire
	// screen, and is created by the window system
	WindowTypeRoot WindowType = 0
	// WindowTypeToplevel: toplevel window (used to implement Window)
	WindowTypeToplevel WindowType = 1
	// WindowTypeChild: child window (used to implement e.g. Entry)
	WindowTypeChild WindowType = 2
	// WindowTypeTemp: override redirect temporary window (used to implement
	// Menu)
	WindowTypeTemp WindowType = 3
	// WindowTypeForeign: foreign window (see gdk_window_foreign_new())
	WindowTypeForeign WindowType = 4
	// WindowTypeOffscreen: offscreen window (see [Offscreen
	// Windows][OFFSCREEN-WINDOWS]). Since 2.18
	WindowTypeOffscreen WindowType = 5
	// WindowTypeSubsurface: subsurface-based window; This window is visually
	// tied to a toplevel, and is moved/stacked with it. Currently this window
	// type is only implemented in Wayland. Since 3.14
	WindowTypeSubsurface WindowType = 6
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowTypeHint: these are hints for the window manager that indicate what
// type of function the window has. The window manager can use this when
// determining decoration and behaviour of the window. The hint must be set
// before mapping the window.
//
// See the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) specification for more details
// about window types.
type WindowTypeHint int

const (
	// WindowTypeHintNormal: normal toplevel window.
	WindowTypeHintNormal WindowTypeHint = 0
	// WindowTypeHintDialog: dialog window.
	WindowTypeHintDialog WindowTypeHint = 1
	// WindowTypeHintMenu: window used to implement a menu; GTK+ uses this hint
	// only for torn-off menus, see TearoffMenuItem.
	WindowTypeHintMenu WindowTypeHint = 2
	// WindowTypeHintToolbar: window used to implement toolbars.
	WindowTypeHintToolbar WindowTypeHint = 3
	// WindowTypeHintSplashscreen: window used to display a splash screen during
	// application startup.
	WindowTypeHintSplashscreen WindowTypeHint = 4
	// WindowTypeHintUtility: utility windows which are not detached toolbars or
	// dialogs.
	WindowTypeHintUtility WindowTypeHint = 5
	// WindowTypeHintDock: used for creating dock or panel windows.
	WindowTypeHintDock WindowTypeHint = 6
	// WindowTypeHintDesktop: used for creating the desktop background window.
	WindowTypeHintDesktop WindowTypeHint = 7
	// WindowTypeHintDropdownMenu: a menu that belongs to a menubar.
	WindowTypeHintDropdownMenu WindowTypeHint = 8
	// WindowTypeHintPopupMenu: a menu that does not belong to a menubar, e.g. a
	// context menu.
	WindowTypeHintPopupMenu WindowTypeHint = 9
	// WindowTypeHintTooltip: a tooltip.
	WindowTypeHintTooltip WindowTypeHint = 10
	// WindowTypeHintNotification: a notification - typically a “bubble” that
	// belongs to a status icon.
	WindowTypeHintNotification WindowTypeHint = 11
	// WindowTypeHintCombo: a popup from a combo box.
	WindowTypeHintCombo WindowTypeHint = 12
	// WindowTypeHintDnd: a window that is used to implement a DND cursor.
	WindowTypeHintDnd WindowTypeHint = 13
)

func marshalWindowTypeHint(p uintptr) (interface{}, error) {
	return WindowTypeHint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowWindowClass: @GDK_INPUT_OUTPUT windows are the standard kind of window
// you might expect. Such windows receive events and are also displayed on
// screen. @GDK_INPUT_ONLY windows are invisible; they are usually placed above
// other windows in order to trap or filter the events. You can’t draw on
// @GDK_INPUT_ONLY windows.
type WindowWindowClass int

const (
	// WindowWindowClassInputOutput: window for graphics and events
	WindowWindowClassInputOutput WindowWindowClass = 0
	// WindowWindowClassInputOnly: window for events only
	WindowWindowClassInputOnly WindowWindowClass = 1
)

func marshalWindowWindowClass(p uintptr) (interface{}, error) {
	return WindowWindowClass(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AnchorHints: positioning hints for aligning a window relative to a rectangle.
//
// These hints determine how the window should be positioned in the case that
// the window would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the window extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the window can be shifted horizontally to fit
// on-screen. If GDK_ANCHOR_RESIZE_X is set, the window can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints int

const (
	// AnchorHintsFlipX: allow flipping anchors horizontally
	AnchorHintsFlipX AnchorHints = 1
	// AnchorHintsFlipY: allow flipping anchors vertically
	AnchorHintsFlipY AnchorHints = 2
	// AnchorHintsSlideX: allow sliding window horizontally
	AnchorHintsSlideX AnchorHints = 4
	// AnchorHintsSlideY: allow sliding window vertically
	AnchorHintsSlideY AnchorHints = 8
	// AnchorHintsResizeX: allow resizing window horizontally
	AnchorHintsResizeX AnchorHints = 16
	// AnchorHintsResizeY: allow resizing window vertically
	AnchorHintsResizeY AnchorHints = 32
	// AnchorHintsFlip: allow flipping anchors on both axes
	AnchorHintsFlip AnchorHints = 3
	// AnchorHintsSlide: allow sliding window on both axes
	AnchorHintsSlide AnchorHints = 12
	// AnchorHintsResize: allow resizing window on both axes
	AnchorHintsResize AnchorHints = 48
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AxisFlags flags describing the current capabilities of a device/tool.
type AxisFlags int

const (
	// AxisFlagsX: x axis is present
	AxisFlagsX AxisFlags = 2
	// AxisFlagsY: y axis is present
	AxisFlagsY AxisFlags = 4
	// AxisFlagsPressure: pressure axis is present
	AxisFlagsPressure AxisFlags = 8
	// AxisFlagsXtilt: x tilt axis is present
	AxisFlagsXtilt AxisFlags = 16
	// AxisFlagsYtilt: y tilt axis is present
	AxisFlagsYtilt AxisFlags = 32
	// AxisFlagsWheel: wheel axis is present
	AxisFlagsWheel AxisFlags = 64
	// AxisFlagsDistance: distance axis is present
	AxisFlagsDistance AxisFlags = 128
	// AxisFlagsRotation z-axis rotation is present
	AxisFlagsRotation AxisFlags = 256
	// AxisFlagsSlider: slider axis is present
	AxisFlagsSlider AxisFlags = 512
)

func marshalAxisFlags(p uintptr) (interface{}, error) {
	return AxisFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// DragAction: used in DragContext to indicate what the destination should do
// with the dropped data.
type DragAction int

const (
	// DragActionDefault means nothing, and should not be used.
	DragActionDefault DragAction = 1
	// DragActionCopy: copy the data.
	DragActionCopy DragAction = 2
	// DragActionMove: move the data, i.e. first copy it, then delete it from
	// the source using the DELETE target of the X selection protocol.
	DragActionMove DragAction = 4
	// DragActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means.
	DragActionLink DragAction = 8
	// DragActionPrivate: special action which tells the source that the
	// destination will do something that the source doesn’t understand.
	DragActionPrivate DragAction = 16
	// DragActionAsk: ask the user what to do with the data.
	DragActionAsk DragAction = 32
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EventMask: a set of bit-flags to indicate which events a window is to
// receive. Most of these masks map onto one or more of the EventType event
// types above.
//
// See the [input handling overview][chap-input-handling] for details of [event
// masks][event-masks] and [event propagation][event-propagation].
//
// GDK_POINTER_MOTION_HINT_MASK is deprecated. It is a special mask to reduce
// the number of GDK_MOTION_NOTIFY events received. When using
// GDK_POINTER_MOTION_HINT_MASK, fewer GDK_MOTION_NOTIFY events will be sent,
// some of which are marked as a hint (the is_hint member is true). To receive
// more motion events after a motion hint event, the application needs to asks
// for more, by calling gdk_event_request_motions().
//
// Since GTK 3.8, motion events are already compressed by default, independent
// of this mechanism. This compression can be disabled with
// gdk_window_set_event_compression(). See the documentation of that function
// for details.
//
// If GDK_TOUCH_MASK is enabled, the window will receive touch events from
// touch-enabled devices. Those will come as sequences of EventTouch with type
// GDK_TOUCH_UPDATE, enclosed by two events with type GDK_TOUCH_BEGIN and
// GDK_TOUCH_END (or GDK_TOUCH_CANCEL). gdk_event_get_event_sequence() returns
// the event sequence for these events, so different sequences may be
// distinguished.
type EventMask int

const (
	// EventMaskExposureMask: receive expose events
	EventMaskExposureMask EventMask = 2
	// EventMaskPointerMotionMask: receive all pointer motion events
	EventMaskPointerMotionMask EventMask = 4
	// EventMaskPointerMotionHintMask: deprecated. see the explanation above
	EventMaskPointerMotionHintMask EventMask = 8
	// EventMaskButtonMotionMask: receive pointer motion events while any button
	// is pressed
	EventMaskButtonMotionMask EventMask = 16
	// EventMaskButton1MotionMask: receive pointer motion events while 1 button
	// is pressed
	EventMaskButton1MotionMask EventMask = 32
	// EventMaskButton2MotionMask: receive pointer motion events while 2 button
	// is pressed
	EventMaskButton2MotionMask EventMask = 64
	// EventMaskButton3MotionMask: receive pointer motion events while 3 button
	// is pressed
	EventMaskButton3MotionMask EventMask = 128
	// EventMaskButtonPressMask: receive button press events
	EventMaskButtonPressMask EventMask = 256
	// EventMaskButtonReleaseMask: receive button release events
	EventMaskButtonReleaseMask EventMask = 512
	// EventMaskKeyPressMask: receive key press events
	EventMaskKeyPressMask EventMask = 1024
	// EventMaskKeyReleaseMask: receive key release events
	EventMaskKeyReleaseMask EventMask = 2048
	// EventMaskEnterNotifyMask: receive window enter events
	EventMaskEnterNotifyMask EventMask = 4096
	// EventMaskLeaveNotifyMask: receive window leave events
	EventMaskLeaveNotifyMask EventMask = 8192
	// EventMaskFocusChangeMask: receive focus change events
	EventMaskFocusChangeMask EventMask = 16384
	// EventMaskStructureMask: receive events about window configuration change
	EventMaskStructureMask EventMask = 32768
	// EventMaskPropertyChangeMask: receive property change events
	EventMaskPropertyChangeMask EventMask = 65536
	// EventMaskVisibilityNotifyMask: receive visibility change events
	EventMaskVisibilityNotifyMask EventMask = 131072
	// EventMaskProximityInMask: receive proximity in events
	EventMaskProximityInMask EventMask = 262144
	// EventMaskProximityOutMask: receive proximity out events
	EventMaskProximityOutMask EventMask = 524288
	// EventMaskSubstructureMask: receive events about window configuration
	// changes of child windows
	EventMaskSubstructureMask EventMask = 1048576
	// EventMaskScrollMask: receive scroll events
	EventMaskScrollMask EventMask = 2097152
	// EventMaskTouchMask: receive touch events. Since 3.4
	EventMaskTouchMask EventMask = 4194304
	// EventMaskSmoothScrollMask: receive smooth scrolling events. Since 3.4
	EventMaskSmoothScrollMask EventMask = 8388608
	// EventMaskTouchpadGestureMask: receive touchpad gesture events. Since 3.18
	EventMaskTouchpadGestureMask EventMask = 16777216
	// EventMaskTabletPadMask: receive tablet pad events. Since 3.22
	EventMaskTabletPadMask EventMask = 33554432
	// EventMaskAllEventsMask: the combination of all the above event masks.
	EventMaskAllEventsMask EventMask = 67108862
)

func marshalEventMask(p uintptr) (interface{}, error) {
	return EventMask(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FrameClockPhase is used to represent the different paint clock phases that
// can be requested. The elements of the enumeration correspond to the signals
// of FrameClock.
type FrameClockPhase int

const (
	// FrameClockPhaseNone: no phase
	FrameClockPhaseNone FrameClockPhase = 0
	// FrameClockPhaseFlushEvents corresponds to GdkFrameClock::flush-events.
	// Should not be handled by applications.
	FrameClockPhaseFlushEvents FrameClockPhase = 1
	// FrameClockPhaseBeforePaint corresponds to GdkFrameClock::before-paint.
	// Should not be handled by applications.
	FrameClockPhaseBeforePaint FrameClockPhase = 2
	// FrameClockPhaseUpdate corresponds to GdkFrameClock::update.
	FrameClockPhaseUpdate FrameClockPhase = 4
	// FrameClockPhaseLayout corresponds to GdkFrameClock::layout.
	FrameClockPhaseLayout FrameClockPhase = 8
	// FrameClockPhasePaint corresponds to GdkFrameClock::paint.
	FrameClockPhasePaint FrameClockPhase = 16
	// FrameClockPhaseResumeEvents corresponds to GdkFrameClock::resume-events.
	// Should not be handled by applications.
	FrameClockPhaseResumeEvents FrameClockPhase = 32
	// FrameClockPhaseAfterPaint corresponds to GdkFrameClock::after-paint.
	// Should not be handled by applications.
	FrameClockPhaseAfterPaint FrameClockPhase = 64
)

func marshalFrameClockPhase(p uintptr) (interface{}, error) {
	return FrameClockPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ModifierType: a set of bit-flags to indicate the state of modifier keys and
// mouse buttons in various event types. Typical modifier keys are Shift,
// Control, Meta, Super, Hyper, Alt, Compose, Apple, CapsLock or ShiftLock.
//
// Like the X Window System, GDK supports 8 modifier keys and 5 mouse buttons.
//
// Since 2.10, GDK recognizes which of the Meta, Super or Hyper keys are mapped
// to Mod2 - Mod5, and indicates this by setting GDK_SUPER_MASK, GDK_HYPER_MASK
// or GDK_META_MASK in the state field of key events.
//
// Note that GDK may add internal values to events which include reserved values
// such as GDK_MODIFIER_RESERVED_13_MASK. Your code should preserve and ignore
// them. You can use GDK_MODIFIER_MASK to remove all reserved values.
//
// Also note that the GDK X backend interprets button press events for button
// 4-7 as scroll events, so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never be
// set.
type ModifierType int

const (
	// ModifierTypeShiftMask: the Shift key.
	ModifierTypeShiftMask ModifierType = 1
	// ModifierTypeLockMask: a Lock key (depending on the modifier mapping of
	// the X server this may either be CapsLock or ShiftLock).
	ModifierTypeLockMask ModifierType = 2
	// ModifierTypeControlMask: the Control key.
	ModifierTypeControlMask ModifierType = 4
	// ModifierTypeMod1Mask: the fourth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier, but
	// normally it is the Alt key).
	ModifierTypeMod1Mask ModifierType = 8
	// ModifierTypeMod2Mask: the fifth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier).
	ModifierTypeMod2Mask ModifierType = 16
	// ModifierTypeMod3Mask: the sixth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier).
	ModifierTypeMod3Mask ModifierType = 32
	// ModifierTypeMod4Mask: the seventh modifier key (it depends on the
	// modifier mapping of the X server which key is interpreted as this
	// modifier).
	ModifierTypeMod4Mask ModifierType = 64
	// ModifierTypeMod5Mask: the eighth modifier key (it depends on the modifier
	// mapping of the X server which key is interpreted as this modifier).
	ModifierTypeMod5Mask ModifierType = 128
	// ModifierTypeButton1Mask: the first mouse button.
	ModifierTypeButton1Mask ModifierType = 256
	// ModifierTypeButton2Mask: the second mouse button.
	ModifierTypeButton2Mask ModifierType = 512
	// ModifierTypeButton3Mask: the third mouse button.
	ModifierTypeButton3Mask ModifierType = 1024
	// ModifierTypeButton4Mask: the fourth mouse button.
	ModifierTypeButton4Mask ModifierType = 2048
	// ModifierTypeButton5Mask: the fifth mouse button.
	ModifierTypeButton5Mask ModifierType = 4096
	// ModifierTypeModifierReserved13Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved13Mask ModifierType = 8192
	// ModifierTypeModifierReserved14Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved14Mask ModifierType = 16384
	// ModifierTypeModifierReserved15Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved15Mask ModifierType = 32768
	// ModifierTypeModifierReserved16Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved16Mask ModifierType = 65536
	// ModifierTypeModifierReserved17Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved17Mask ModifierType = 131072
	// ModifierTypeModifierReserved18Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved18Mask ModifierType = 262144
	// ModifierTypeModifierReserved19Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved19Mask ModifierType = 524288
	// ModifierTypeModifierReserved20Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved20Mask ModifierType = 1048576
	// ModifierTypeModifierReserved21Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved21Mask ModifierType = 2097152
	// ModifierTypeModifierReserved22Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved22Mask ModifierType = 4194304
	// ModifierTypeModifierReserved23Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved23Mask ModifierType = 8388608
	// ModifierTypeModifierReserved24Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved24Mask ModifierType = 16777216
	// ModifierTypeModifierReserved25Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved25Mask ModifierType = 33554432
	// ModifierTypeSuperMask: the Super modifier. Since 2.10
	ModifierTypeSuperMask ModifierType = 67108864
	// ModifierTypeHyperMask: the Hyper modifier. Since 2.10
	ModifierTypeHyperMask ModifierType = 134217728
	// ModifierTypeMetaMask: the Meta modifier. Since 2.10
	ModifierTypeMetaMask ModifierType = 268435456
	// ModifierTypeModifierReserved29Mask: a reserved bit flag; do not use in
	// your own code
	ModifierTypeModifierReserved29Mask ModifierType = 536870912
	// ModifierTypeReleaseMask: not used in GDK itself. GTK+ uses it to
	// differentiate between (keyval, modifiers) pairs from key press and
	// release events.
	ModifierTypeReleaseMask ModifierType = 1073741824
	// ModifierTypeModifierMask: a mask covering all modifier types.
	ModifierTypeModifierMask ModifierType = 1543512063
)

func marshalModifierType(p uintptr) (interface{}, error) {
	return ModifierType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// SeatCapabilities flags describing the seat capabilities.
type SeatCapabilities int

const (
	// SeatCapabilitiesNone: no input capabilities
	SeatCapabilitiesNone SeatCapabilities = 0
	// SeatCapabilitiesPointer: the seat has a pointer (e.g. mouse)
	SeatCapabilitiesPointer SeatCapabilities = 1
	// SeatCapabilitiesTouch: the seat has touchscreen(s) attached
	SeatCapabilitiesTouch SeatCapabilities = 2
	// SeatCapabilitiesTabletStylus: the seat has drawing tablet(s) attached
	SeatCapabilitiesTabletStylus SeatCapabilities = 4
	// SeatCapabilitiesKeyboard: the seat has keyboard(s) attached
	SeatCapabilitiesKeyboard SeatCapabilities = 8
	// SeatCapabilitiesAllPointing: the union of all pointing capabilities
	SeatCapabilitiesAllPointing SeatCapabilities = 7
	// SeatCapabilitiesAll: the union of all capabilities
	SeatCapabilitiesAll SeatCapabilities = 15
)

func marshalSeatCapabilities(p uintptr) (interface{}, error) {
	return SeatCapabilities(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WMDecoration: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining how to decorate the window. The
// hint must be set before mapping the window.
type WMDecoration int

const (
	// WMDecorationAll: all decorations should be applied.
	WMDecorationAll WMDecoration = 1
	// WMDecorationBorder: a frame should be drawn around the window.
	WMDecorationBorder WMDecoration = 2
	// WMDecorationResizeh: the frame should have resize handles.
	WMDecorationResizeh WMDecoration = 4
	// WMDecorationTitle: a titlebar should be placed above the window.
	WMDecorationTitle WMDecoration = 8
	// WMDecorationMenu: a button for opening a menu should be included.
	WMDecorationMenu WMDecoration = 16
	// WMDecorationMinimize: a minimize button should be included.
	WMDecorationMinimize WMDecoration = 32
	// WMDecorationMaximize: a maximize button should be included.
	WMDecorationMaximize WMDecoration = 64
)

func marshalWMDecoration(p uintptr) (interface{}, error) {
	return WMDecoration(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WMFunction: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining the functions to offer for the
// window. The hint must be set before mapping the window.
type WMFunction int

const (
	// WMFunctionAll: all functions should be offered.
	WMFunctionAll WMFunction = 1
	// WMFunctionResize: the window should be resizable.
	WMFunctionResize WMFunction = 2
	// WMFunctionMove: the window should be movable.
	WMFunctionMove WMFunction = 4
	// WMFunctionMinimize: the window should be minimizable.
	WMFunctionMinimize WMFunction = 8
	// WMFunctionMaximize: the window should be maximizable.
	WMFunctionMaximize WMFunction = 16
	// WMFunctionClose: the window should be closable.
	WMFunctionClose WMFunction = 32
)

func marshalWMFunction(p uintptr) (interface{}, error) {
	return WMFunction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowAttributesType: used to indicate which fields in the WindowAttr struct
// should be honored. For example, if you filled in the “cursor” and “x” fields
// of WindowAttr, pass “@GDK_WA_X | @GDK_WA_CURSOR” to gdk_window_new(). Fields
// in WindowAttr not covered by a bit in this enum are required; for example,
// the @width/@height, @wclass, and @window_type fields are required, they have
// no corresponding flag in WindowAttributesType.
type WindowAttributesType int

const (
	// WindowAttributesTypeTitle: honor the title field
	WindowAttributesTypeTitle WindowAttributesType = 2
	// WindowAttributesTypeX: honor the X coordinate field
	WindowAttributesTypeX WindowAttributesType = 4
	// WindowAttributesTypeY: honor the Y coordinate field
	WindowAttributesTypeY WindowAttributesType = 8
	// WindowAttributesTypeCursor: honor the cursor field
	WindowAttributesTypeCursor WindowAttributesType = 16
	// WindowAttributesTypeVisual: honor the visual field
	WindowAttributesTypeVisual WindowAttributesType = 32
	// WindowAttributesTypeWmclass: honor the wmclass_class and wmclass_name
	// fields
	WindowAttributesTypeWmclass WindowAttributesType = 64
	// WindowAttributesTypeNoredir: honor the override_redirect field
	WindowAttributesTypeNoredir WindowAttributesType = 128
	// WindowAttributesTypeTypeHint: honor the type_hint field
	WindowAttributesTypeTypeHint WindowAttributesType = 256
)

func marshalWindowAttributesType(p uintptr) (interface{}, error) {
	return WindowAttributesType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowHints: used to indicate which fields of a Geometry struct should be
// paid attention to. Also, the presence/absence of @GDK_HINT_POS,
// @GDK_HINT_USER_POS, and @GDK_HINT_USER_SIZE is significant, though they don't
// directly refer to Geometry fields. @GDK_HINT_USER_POS will be set
// automatically by Window if you call gtk_window_move(). @GDK_HINT_USER_POS and
// @GDK_HINT_USER_SIZE should be set if the user specified a size/position using
// a --geometry command-line argument; gtk_window_parse_geometry() automatically
// sets these flags.
type WindowHints int

const (
	// WindowHintsPos indicates that the program has positioned the window
	WindowHintsPos WindowHints = 1
	// WindowHintsMinSize: min size fields are set
	WindowHintsMinSize WindowHints = 2
	// WindowHintsMaxSize: max size fields are set
	WindowHintsMaxSize WindowHints = 4
	// WindowHintsBaseSize: base size fields are set
	WindowHintsBaseSize WindowHints = 8
	// WindowHintsAspect: aspect ratio fields are set
	WindowHintsAspect WindowHints = 16
	// WindowHintsResizeInc: resize increment fields are set
	WindowHintsResizeInc WindowHints = 32
	// WindowHintsWinGravity: window gravity field is set
	WindowHintsWinGravity WindowHints = 64
	// WindowHintsUserPos indicates that the window’s position was explicitly
	// set by the user
	WindowHintsUserPos WindowHints = 128
	// WindowHintsUserSize indicates that the window’s size was explicitly set
	// by the user
	WindowHintsUserSize WindowHints = 256
)

func marshalWindowHints(p uintptr) (interface{}, error) {
	return WindowHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WindowState specifies the state of a toplevel window.
type WindowState int

const (
	// WindowStateWithdrawn: the window is not shown.
	WindowStateWithdrawn WindowState = 1
	// WindowStateIconified: the window is minimized.
	WindowStateIconified WindowState = 2
	// WindowStateMaximized: the window is maximized.
	WindowStateMaximized WindowState = 4
	// WindowStateSticky: the window is sticky.
	WindowStateSticky WindowState = 8
	// WindowStateFullscreen: the window is maximized without decorations.
	WindowStateFullscreen WindowState = 16
	// WindowStateAbove: the window is kept above other windows.
	WindowStateAbove WindowState = 32
	// WindowStateBelow: the window is kept below other windows.
	WindowStateBelow WindowState = 64
	// WindowStateFocused: the window is presented as focused (with active
	// decorations).
	WindowStateFocused WindowState = 128
	// WindowStateTiled: the window is in a tiled state, Since 3.10. Since
	// 3.22.23, this is deprecated in favor of per-edge information.
	WindowStateTiled WindowState = 256
	// WindowStateTopTiled: whether the top edge is tiled, Since 3.22.23
	WindowStateTopTiled WindowState = 512
	// WindowStateTopResizable: whether the top edge is resizable, Since 3.22.23
	WindowStateTopResizable WindowState = 1024
	// WindowStateRightTiled: whether the right edge is tiled, Since 3.22.23
	WindowStateRightTiled WindowState = 2048
	// WindowStateRightResizable: whether the right edge is resizable, Since
	// 3.22.23
	WindowStateRightResizable WindowState = 4096
	// WindowStateBottomTiled: whether the bottom edge is tiled, Since 3.22.23
	WindowStateBottomTiled WindowState = 8192
	// WindowStateBottomResizable: whether the bottom edge is resizable, Since
	// 3.22.23
	WindowStateBottomResizable WindowState = 16384
	// WindowStateLeftTiled: whether the left edge is tiled, Since 3.22.23
	WindowStateLeftTiled WindowState = 32768
	// WindowStateLeftResizable: whether the left edge is resizable, Since
	// 3.22.23
	WindowStateLeftResizable WindowState = 65536
)

func marshalWindowState(p uintptr) (interface{}, error) {
	return WindowState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AppLaunchContext: gdkAppLaunchContext is an implementation of LaunchContext
// that handles launching an application in a graphical context. It provides
// startup notification and allows to launch applications on a specific screen
// or workspace.
//
// Launching an application
//
//    GdkAppLaunchContext *context;
//
//    context = gdk_display_get_app_launch_context (display);
//
//    gdk_app_launch_context_set_screen (screen);
//    gdk_app_launch_context_set_timestamp (event->time);
//
//    if (!g_app_info_launch_default_for_uri ("http://www.gtk.org", context, &error))
//      g_warning ("Launching failed: s\n", error->message);
//
//    g_object_unref (context);
type AppLaunchContext interface {
	gio.AppLaunchContext

	// SetDesktop sets the workspace on which applications will be launched when
	// using this context when running under a window manager that supports
	// multiple workspaces, as described in the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec).
	//
	// When the workspace is not specified or @desktop is set to -1, it is up to
	// the window manager to pick one, typically it will be the current
	// workspace.
	SetDesktop(desktop int)
	// SetDisplay sets the display on which applications will be launched when
	// using this context. See also gdk_app_launch_context_set_screen().
	SetDisplay(display Display)
	// SetIcon sets the icon for applications that are launched with this
	// context.
	//
	// Window Managers can use this information when displaying startup
	// notification.
	//
	// See also gdk_app_launch_context_set_icon_name().
	SetIcon(icon gio.Icon)
	// SetIconName sets the icon for applications that are launched with this
	// context. The @icon_name will be interpreted in the same way as the Icon
	// field in desktop files. See also gdk_app_launch_context_set_icon().
	//
	// If both @icon and @icon_name are set, the @icon_name takes priority. If
	// neither @icon or @icon_name is set, the icon is taken from either the
	// file that is passed to launched application or from the Info for the
	// launched application itself.
	SetIconName(iconName string)
	// SetScreen sets the screen on which applications will be launched when
	// using this context. See also gdk_app_launch_context_set_display().
	//
	// If both @screen and @display are set, the @screen takes priority. If
	// neither @screen or @display are set, the default screen and display are
	// used.
	SetScreen(screen Screen)
	// SetTimestamp sets the timestamp of @context. The timestamp should ideally
	// be taken from the event that triggered the launch.
	//
	// Window managers can use this information to avoid moving the focus to the
	// newly launched application when the user is busy typing in another
	// window. This is also known as 'focus stealing prevention'.
	SetTimestamp(timestamp uint32)
}

// appLaunchContext implements the AppLaunchContext interface.
type appLaunchContext struct {
	gio.AppLaunchContext
}

var _ AppLaunchContext = (*appLaunchContext)(nil)

// WrapAppLaunchContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapAppLaunchContext(obj *externglib.Object) AppLaunchContext {
	return AppLaunchContext{
		gio.AppLaunchContext: gio.WrapAppLaunchContext(obj),
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapAppLaunchContext(obj), nil
}

// NewAppLaunchContext constructs a class AppLaunchContext.
func NewAppLaunchContext() AppLaunchContext {
	var cret C.GdkAppLaunchContext

	cret = C.gdk_app_launch_context_new()

	var appLaunchContext AppLaunchContext

	appLaunchContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(AppLaunchContext)

	return appLaunchContext
}

// SetDesktop sets the workspace on which applications will be launched when
// using this context when running under a window manager that supports
// multiple workspaces, as described in the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec).
//
// When the workspace is not specified or @desktop is set to -1, it is up to
// the window manager to pick one, typically it will be the current
// workspace.
func (c appLaunchContext) SetDesktop(desktop int) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 C.gint

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = C.gint(desktop)

	C.gdk_app_launch_context_set_desktop(arg0, arg1)
}

// SetDisplay sets the display on which applications will be launched when
// using this context. See also gdk_app_launch_context_set_screen().
func (c appLaunchContext) SetDisplay(display Display) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.GdkDisplay

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gdk_app_launch_context_set_display(arg0, arg1)
}

// SetIcon sets the icon for applications that are launched with this
// context.
//
// Window Managers can use this information when displaying startup
// notification.
//
// See also gdk_app_launch_context_set_icon_name().
func (c appLaunchContext) SetIcon(icon gio.Icon) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.GIcon

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

	C.gdk_app_launch_context_set_icon(arg0, arg1)
}

// SetIconName sets the icon for applications that are launched with this
// context. The @icon_name will be interpreted in the same way as the Icon
// field in desktop files. See also gdk_app_launch_context_set_icon().
//
// If both @icon and @icon_name are set, the @icon_name takes priority. If
// neither @icon or @icon_name is set, the icon is taken from either the
// file that is passed to launched application or from the Info for the
// launched application itself.
func (c appLaunchContext) SetIconName(iconName string) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.char

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.char)(C.CString(iconName))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_app_launch_context_set_icon_name(arg0, arg1)
}

// SetScreen sets the screen on which applications will be launched when
// using this context. See also gdk_app_launch_context_set_display().
//
// If both @screen and @display are set, the @screen takes priority. If
// neither @screen or @display are set, the default screen and display are
// used.
func (c appLaunchContext) SetScreen(screen Screen) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 *C.GdkScreen

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gdk_app_launch_context_set_screen(arg0, arg1)
}

// SetTimestamp sets the timestamp of @context. The timestamp should ideally
// be taken from the event that triggered the launch.
//
// Window managers can use this information to avoid moving the focus to the
// newly launched application when the user is busy typing in another
// window. This is also known as 'focus stealing prevention'.
func (c appLaunchContext) SetTimestamp(timestamp uint32) {
	var arg0 *C.GdkAppLaunchContext
	var arg1 C.guint32

	arg0 = (*C.GdkAppLaunchContext)(unsafe.Pointer(c.Native()))
	arg1 = C.guint32(timestamp)

	C.gdk_app_launch_context_set_timestamp(arg0, arg1)
}

// Cursor: a Cursor represents a cursor. Its contents are private.
type Cursor interface {
	gextras.Objector

	// CursorType returns the cursor type for this cursor.
	CursorType() CursorType
	// Display returns the display on which the Cursor is defined.
	Display() Display
	// Image returns a Pixbuf with the image used to display the cursor.
	//
	// Note that depending on the capabilities of the windowing system and on
	// the cursor, GDK may not be able to obtain the image data. In this case,
	// nil is returned.
	Image() gdkpixbuf.Pixbuf
	// Surface returns a cairo image surface with the image used to display the
	// cursor.
	//
	// Note that depending on the capabilities of the windowing system and on
	// the cursor, GDK may not be able to obtain the image data. In this case,
	// nil is returned.
	Surface() (xHot float64, yHot float64, surface *cairo.Surface)
	// Ref adds a reference to @cursor.
	Ref() Cursor
	// Unref removes a reference from @cursor, deallocating the cursor if no
	// references remain.
	Unref()
}

// cursor implements the Cursor interface.
type cursor struct {
	gextras.Objector
}

var _ Cursor = (*cursor)(nil)

// WrapCursor wraps a GObject to the right type. It is
// primarily used internally.
func WrapCursor(obj *externglib.Object) Cursor {
	return Cursor{
		Objector: obj,
	}
}

func marshalCursor(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCursor(obj), nil
}

// NewCursor constructs a class Cursor.
func NewCursor(cursorType CursorType) Cursor {
	var arg1 C.GdkCursorType

	arg1 = (C.GdkCursorType)(cursorType)

	var cret C.GdkCursor

	cret = C.gdk_cursor_new(arg1)

	var cursor Cursor

	cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return cursor
}

// NewCursorForDisplay constructs a class Cursor.
func NewCursorForDisplay(display Display, cursorType CursorType) Cursor {
	var arg1 *C.GdkDisplay
	var arg2 C.GdkCursorType

	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	arg2 = (C.GdkCursorType)(cursorType)

	var cret C.GdkCursor

	cret = C.gdk_cursor_new_for_display(arg1, arg2)

	var cursor Cursor

	cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return cursor
}

// NewCursorFromName constructs a class Cursor.
func NewCursorFromName(display Display, name string) Cursor {
	var arg1 *C.GdkDisplay
	var arg2 *C.gchar

	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	arg2 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg2))

	var cret C.GdkCursor

	cret = C.gdk_cursor_new_from_name(arg1, arg2)

	var cursor Cursor

	cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return cursor
}

// NewCursorFromPixbuf constructs a class Cursor.
func NewCursorFromPixbuf(display Display, pixbuf gdkpixbuf.Pixbuf, x int, y int) Cursor {
	var arg1 *C.GdkDisplay
	var arg2 *C.GdkPixbuf
	var arg3 C.gint
	var arg4 C.gint

	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	arg3 = C.gint(x)
	arg4 = C.gint(y)

	var cret C.GdkCursor

	cret = C.gdk_cursor_new_from_pixbuf(arg1, arg2, arg3, arg4)

	var cursor Cursor

	cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return cursor
}

// NewCursorFromSurface constructs a class Cursor.
func NewCursorFromSurface(display Display, surface *cairo.Surface, x float64, y float64) Cursor {
	var arg1 *C.GdkDisplay
	var arg2 *C.cairo_surface_t
	var arg3 C.gdouble
	var arg4 C.gdouble

	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
	arg2 = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))
	arg3 = C.gdouble(x)
	arg4 = C.gdouble(y)

	var cret C.GdkCursor

	cret = C.gdk_cursor_new_from_surface(arg1, arg2, arg3, arg4)

	var cursor Cursor

	cursor = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return cursor
}

// CursorType returns the cursor type for this cursor.
func (c cursor) CursorType() CursorType {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	var cret C.GdkCursorType

	cret = C.gdk_cursor_get_cursor_type(arg0)

	var cursorType CursorType

	cursorType = CursorType(cret)

	return cursorType
}

// Display returns the display on which the Cursor is defined.
func (c cursor) Display() Display {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_cursor_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// Image returns a Pixbuf with the image used to display the cursor.
//
// Note that depending on the capabilities of the windowing system and on
// the cursor, GDK may not be able to obtain the image data. In this case,
// nil is returned.
func (c cursor) Image() gdkpixbuf.Pixbuf {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	var cret *C.GdkPixbuf

	cret = C.gdk_cursor_get_image(arg0)

	var pixbuf gdkpixbuf.Pixbuf

	pixbuf = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)

	return pixbuf
}

// Surface returns a cairo image surface with the image used to display the
// cursor.
//
// Note that depending on the capabilities of the windowing system and on
// the cursor, GDK may not be able to obtain the image data. In this case,
// nil is returned.
func (c cursor) Surface() (xHot float64, yHot float64, surface *cairo.Surface) {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	var arg1 C.gdouble
	var arg2 C.gdouble
	var cret *C.cairo_surface_t

	cret = C.gdk_cursor_get_surface(arg0, &arg1, &arg2)

	var xHot float64
	var yHot float64
	var surface *cairo.Surface

	xHot = (float64)(arg1)
	yHot = (float64)(arg2)
	surface = cairo.WrapSurface(unsafe.Pointer(cret))
	runtime.SetFinalizer(surface, func(v *cairo.Surface) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return xHot, yHot, surface
}

// Ref adds a reference to @cursor.
func (c cursor) Ref() Cursor {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	var cret *C.GdkCursor

	cret = C.gdk_cursor_ref(arg0)

	var ret Cursor

	ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Cursor)

	return ret
}

// Unref removes a reference from @cursor, deallocating the cursor if no
// references remain.
func (c cursor) Unref() {
	var arg0 *C.GdkCursor

	arg0 = (*C.GdkCursor)(unsafe.Pointer(c.Native()))

	C.gdk_cursor_unref(arg0)
}

// Device: the Device object represents a single input device, such as a
// keyboard, a mouse, a touchpad, etc.
//
// See the DeviceManager documentation for more information about the various
// kinds of master and slave devices, and their relationships.
type Device interface {
	gextras.Objector

	// AssociatedDevice returns the associated device to @device, if @device is
	// of type GDK_DEVICE_TYPE_MASTER, it will return the paired pointer or
	// keyboard.
	//
	// If @device is of type GDK_DEVICE_TYPE_SLAVE, it will return the master
	// device to which @device is attached to.
	//
	// If @device is of type GDK_DEVICE_TYPE_FLOATING, nil will be returned, as
	// there is no associated device.
	AssociatedDevice() Device
	// Axes returns the axes currently available on the device.
	Axes() AxisFlags
	// AxisUse returns the axis use for @index_.
	AxisUse(index_ uint) AxisUse
	// DeviceType returns the device type for @device.
	DeviceType() DeviceType
	// Display returns the Display to which @device pertains.
	Display() Display
	// HasCursor determines whether the pointer follows device motion. This is
	// not meaningful for keyboard devices, which don't have a pointer.
	HasCursor() bool
	// History obtains the motion history for a pointer device; given a starting
	// and ending timestamp, return all events in the motion history for the
	// device in the given range of time. Some windowing systems do not support
	// motion history, in which case, false will be returned. (This is not
	// distinguishable from the case where motion history is supported and no
	// events were found.)
	//
	// Note that there is also gdk_window_set_event_compression() to get more
	// motion events delivered directly, independent of the windowing system.
	History(window Window, start uint32, stop uint32) bool
	// Key: if @index_ has a valid keyval, this function will return true and
	// fill in @keyval and @modifiers with the keyval settings.
	Key(index_ uint) (keyval uint, modifiers ModifierType, ok bool)
	// LastEventWindow gets information about which window the given pointer
	// device is in, based on events that have been received so far from the
	// display server. If another application has a pointer grab, or this
	// application has a grab with owner_events = false, nil may be returned
	// even if the pointer is physically over one of this application's windows.
	LastEventWindow() Window
	// Mode determines the mode of the device.
	Mode() InputMode
	// NAxes returns the number of axes the device currently has.
	NAxes() int
	// NKeys returns the number of keys the device currently has.
	NKeys() int
	// Name determines the name of the device.
	Name() string
	// Position gets the current location of @device. As a slave device
	// coordinates are those of its master pointer, This function may not be
	// called on devices of type GDK_DEVICE_TYPE_SLAVE, unless there is an
	// ongoing grab on them, see gdk_device_grab().
	Position() (screen Screen, x int, y int)
	// PositionDouble gets the current location of @device in double precision.
	// As a slave device's coordinates are those of its master pointer, this
	// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
	// unless there is an ongoing grab on them. See gdk_device_grab().
	PositionDouble() (screen Screen, x float64, y float64)
	// ProductID returns the product ID of this device, or nil if this
	// information couldn't be obtained. This ID is retrieved from the device,
	// and is thus constant for it. See gdk_device_get_vendor_id() for more
	// information.
	ProductID() string
	// Seat returns the Seat the device belongs to.
	Seat() Seat
	// Source determines the type of the device.
	Source() InputSource
	// VendorID returns the vendor ID of this device, or nil if this information
	// couldn't be obtained. This ID is retrieved from the device, and is thus
	// constant for it.
	//
	// This function, together with gdk_device_get_product_id(), can be used to
	// eg. compose #GSettings paths to store settings for this device.
	//
	//     static GSettings *
	//     get_device_settings (GdkDevice *device)
	//     {
	//       const gchar *vendor, *product;
	//       GSettings *settings;
	//       GdkDevice *device;
	//       gchar *path;
	//
	//       vendor = gdk_device_get_vendor_id (device);
	//       product = gdk_device_get_product_id (device);
	//
	//       path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
	//       settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
	//       g_free (path);
	//
	//       return settings;
	//     }
	VendorID() string
	// WindowAtPosition obtains the window underneath @device, returning the
	// location of the device in @win_x and @win_y. Returns nil if the window
	// tree under @device is not known to GDK (for example, belongs to another
	// application).
	//
	// As a slave device coordinates are those of its master pointer, This
	// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
	// unless there is an ongoing grab on them, see gdk_device_grab().
	WindowAtPosition() (winX int, winY int, window Window)
	// WindowAtPositionDouble obtains the window underneath @device, returning
	// the location of the device in @win_x and @win_y in double precision.
	// Returns nil if the window tree under @device is not known to GDK (for
	// example, belongs to another application).
	//
	// As a slave device coordinates are those of its master pointer, This
	// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
	// unless there is an ongoing grab on them, see gdk_device_grab().
	WindowAtPositionDouble() (winX float64, winY float64, window Window)
	// Grab grabs the device so that all events coming from this device are
	// passed to this application until the device is ungrabbed with
	// gdk_device_ungrab(), or the window becomes unviewable. This overrides any
	// previous grab on the device by this client.
	//
	// Note that @device and @window need to be on the same display.
	//
	// Device grabs are used for operations which need complete control over the
	// given device events (either pointer or keyboard). For example in GTK+
	// this is used for Drag and Drop operations, popup menus and such.
	//
	// Note that if the event mask of an X window has selected both button press
	// and button release events, then a button press event will cause an
	// automatic pointer grab until the button is released. X does this
	// automatically since most applications expect to receive button press and
	// release events in pairs. It is equivalent to a pointer grab on the window
	// with @owner_events set to true.
	//
	// If you set up anything at the time you take the grab that needs to be
	// cleaned up when the grab ends, you should handle the EventGrabBroken
	// events that are emitted when the grab ends unvoluntarily.
	Grab(window Window, grabOwnership GrabOwnership, ownerEvents bool, eventMask EventMask, cursor Cursor, time_ uint32) GrabStatus
	// ListAxes returns a #GList of Atoms, containing the labels for the axes
	// that @device currently has.
	ListAxes() *glib.List
	// ListSlaveDevices: if the device if of type GDK_DEVICE_TYPE_MASTER, it
	// will return the list of slave devices attached to it, otherwise it will
	// return nil
	ListSlaveDevices() *glib.List
	// SetAxisUse specifies how an axis of a device is used.
	SetAxisUse(index_ uint, use AxisUse)
	// SetKey specifies the X key event to generate when a macro button of a
	// device is pressed.
	SetKey(index_ uint, keyval uint, modifiers ModifierType)
	// SetMode sets a the mode of an input device. The mode controls if the
	// device is active and whether the device’s range is mapped to the entire
	// screen or to a single window.
	//
	// Note: This is only meaningful for floating devices, master devices (and
	// slaves connected to these) drive the pointer cursor, which is not limited
	// by the input mode.
	SetMode(mode InputMode) bool
	// Ungrab: release any grab on @device.
	Ungrab(time_ uint32)
	// Warp warps @device in @display to the point @x,@y on the screen @screen,
	// unless the device is confined to a window by a grab, in which case it
	// will be moved as far as allowed by the grab. Warping the pointer creates
	// events as if the user had moved the mouse instantaneously to the
	// destination.
	//
	// Note that the pointer should normally be under the control of the user.
	// This function was added to cover some rare use cases like keyboard
	// navigation support for the color picker in the ColorSelectionDialog.
	Warp(screen Screen, x int, y int)
}

// device implements the Device interface.
type device struct {
	gextras.Objector
}

var _ Device = (*device)(nil)

// WrapDevice wraps a GObject to the right type. It is
// primarily used internally.
func WrapDevice(obj *externglib.Object) Device {
	return Device{
		Objector: obj,
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDevice(obj), nil
}

// AssociatedDevice returns the associated device to @device, if @device is
// of type GDK_DEVICE_TYPE_MASTER, it will return the paired pointer or
// keyboard.
//
// If @device is of type GDK_DEVICE_TYPE_SLAVE, it will return the master
// device to which @device is attached to.
//
// If @device is of type GDK_DEVICE_TYPE_FLOATING, nil will be returned, as
// there is no associated device.
func (d device) AssociatedDevice() Device {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GdkDevice

	cret = C.gdk_device_get_associated_device(arg0)

	var ret Device

	ret = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Device)

	return ret
}

// Axes returns the axes currently available on the device.
func (d device) Axes() AxisFlags {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.GdkAxisFlags

	cret = C.gdk_device_get_axes(arg0)

	var axisFlags AxisFlags

	axisFlags = AxisFlags(cret)

	return axisFlags
}

// AxisUse returns the axis use for @index_.
func (d device) AxisUse(index_ uint) AxisUse {
	var arg0 *C.GdkDevice
	var arg1 C.guint

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(index_)

	var cret C.GdkAxisUse

	cret = C.gdk_device_get_axis_use(arg0, arg1)

	var axisUse AxisUse

	axisUse = AxisUse(cret)

	return axisUse
}

// DeviceType returns the device type for @device.
func (d device) DeviceType() DeviceType {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.GdkDeviceType

	cret = C.gdk_device_get_device_type(arg0)

	var deviceType DeviceType

	deviceType = DeviceType(cret)

	return deviceType
}

// Display returns the Display to which @device pertains.
func (d device) Display() Display {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_device_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// HasCursor determines whether the pointer follows device motion. This is
// not meaningful for keyboard devices, which don't have a pointer.
func (d device) HasCursor() bool {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_device_get_has_cursor(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// History obtains the motion history for a pointer device; given a starting
// and ending timestamp, return all events in the motion history for the
// device in the given range of time. Some windowing systems do not support
// motion history, in which case, false will be returned. (This is not
// distinguishable from the case where motion history is supported and no
// events were found.)
//
// Note that there is also gdk_window_set_event_compression() to get more
// motion events delivered directly, independent of the windowing system.
func (d device) History(window Window, start uint32, stop uint32) bool {
	var arg0 *C.GdkDevice
	var arg1 *C.GdkWindow
	var arg2 C.guint32
	var arg3 C.guint32

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	arg2 = C.guint32(start)
	arg3 = C.guint32(stop)

	var cret C.gboolean

	cret = C.gdk_device_get_history(arg0, arg1, arg2, arg3)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Key: if @index_ has a valid keyval, this function will return true and
// fill in @keyval and @modifiers with the keyval settings.
func (d device) Key(index_ uint) (keyval uint, modifiers ModifierType, ok bool) {
	var arg0 *C.GdkDevice
	var arg1 C.guint

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(index_)

	var arg2 C.guint
	var arg3 C.GdkModifierType
	var cret C.gboolean

	cret = C.gdk_device_get_key(arg0, arg1, &arg2, &arg3)

	var keyval uint
	var modifiers ModifierType
	var ok bool

	keyval = (uint)(arg2)
	modifiers = ModifierType(arg3)
	if cret {
		ok = true
	}

	return keyval, modifiers, ok
}

// LastEventWindow gets information about which window the given pointer
// device is in, based on events that have been received so far from the
// display server. If another application has a pointer grab, or this
// application has a grab with owner_events = false, nil may be returned
// even if the pointer is physically over one of this application's windows.
func (d device) LastEventWindow() Window {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_device_get_last_event_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// Mode determines the mode of the device.
func (d device) Mode() InputMode {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.GdkInputMode

	cret = C.gdk_device_get_mode(arg0)

	var inputMode InputMode

	inputMode = InputMode(cret)

	return inputMode
}

// NAxes returns the number of axes the device currently has.
func (d device) NAxes() int {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.gint

	cret = C.gdk_device_get_n_axes(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NKeys returns the number of keys the device currently has.
func (d device) NKeys() int {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.gint

	cret = C.gdk_device_get_n_keys(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Name determines the name of the device.
func (d device) Name() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.gchar

	cret = C.gdk_device_get_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Position gets the current location of @device. As a slave device
// coordinates are those of its master pointer, This function may not be
// called on devices of type GDK_DEVICE_TYPE_SLAVE, unless there is an
// ongoing grab on them, see gdk_device_grab().
func (d device) Position() (screen Screen, x int, y int) {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var arg1 **C.GdkScreen
	var arg2 C.gint
	var arg3 C.gint

	C.gdk_device_get_position(arg0, arg1, &arg2, &arg3)

	var screen Screen
	var x int
	var y int

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(Screen)
	x = (int)(arg2)
	y = (int)(arg3)

	return screen, x, y
}

// PositionDouble gets the current location of @device in double precision.
// As a slave device's coordinates are those of its master pointer, this
// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
// unless there is an ongoing grab on them. See gdk_device_grab().
func (d device) PositionDouble() (screen Screen, x float64, y float64) {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var arg1 **C.GdkScreen
	var arg2 C.gdouble
	var arg3 C.gdouble

	C.gdk_device_get_position_double(arg0, arg1, &arg2, &arg3)

	var screen Screen
	var x float64
	var y float64

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(Screen)
	x = (float64)(arg2)
	y = (float64)(arg3)

	return screen, x, y
}

// ProductID returns the product ID of this device, or nil if this
// information couldn't be obtained. This ID is retrieved from the device,
// and is thus constant for it. See gdk_device_get_vendor_id() for more
// information.
func (d device) ProductID() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.gchar

	cret = C.gdk_device_get_product_id(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Seat returns the Seat the device belongs to.
func (d device) Seat() Seat {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GdkSeat

	cret = C.gdk_device_get_seat(arg0)

	var seat Seat

	seat = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Seat)

	return seat
}

// Source determines the type of the device.
func (d device) Source() InputSource {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret C.GdkInputSource

	cret = C.gdk_device_get_source(arg0)

	var inputSource InputSource

	inputSource = InputSource(cret)

	return inputSource
}

// VendorID returns the vendor ID of this device, or nil if this information
// couldn't be obtained. This ID is retrieved from the device, and is thus
// constant for it.
//
// This function, together with gdk_device_get_product_id(), can be used to
// eg. compose #GSettings paths to store settings for this device.
//
//     static GSettings *
//     get_device_settings (GdkDevice *device)
//     {
//       const gchar *vendor, *product;
//       GSettings *settings;
//       GdkDevice *device;
//       gchar *path;
//
//       vendor = gdk_device_get_vendor_id (device);
//       product = gdk_device_get_product_id (device);
//
//       path = g_strdup_printf ("/org/example/app/devices/s:s/", vendor, product);
//       settings = g_settings_new_with_path (DEVICE_SCHEMA, path);
//       g_free (path);
//
//       return settings;
//     }
func (d device) VendorID() string {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.gchar

	cret = C.gdk_device_get_vendor_id(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// WindowAtPosition obtains the window underneath @device, returning the
// location of the device in @win_x and @win_y. Returns nil if the window
// tree under @device is not known to GDK (for example, belongs to another
// application).
//
// As a slave device coordinates are those of its master pointer, This
// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
// unless there is an ongoing grab on them, see gdk_device_grab().
func (d device) WindowAtPosition() (winX int, winY int, window Window) {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var arg1 C.gint
	var arg2 C.gint
	var cret *C.GdkWindow

	cret = C.gdk_device_get_window_at_position(arg0, &arg1, &arg2)

	var winX int
	var winY int
	var window Window

	winX = (int)(arg1)
	winY = (int)(arg2)
	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return winX, winY, window
}

// WindowAtPositionDouble obtains the window underneath @device, returning
// the location of the device in @win_x and @win_y in double precision.
// Returns nil if the window tree under @device is not known to GDK (for
// example, belongs to another application).
//
// As a slave device coordinates are those of its master pointer, This
// function may not be called on devices of type GDK_DEVICE_TYPE_SLAVE,
// unless there is an ongoing grab on them, see gdk_device_grab().
func (d device) WindowAtPositionDouble() (winX float64, winY float64, window Window) {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var arg1 C.gdouble
	var arg2 C.gdouble
	var cret *C.GdkWindow

	cret = C.gdk_device_get_window_at_position_double(arg0, &arg1, &arg2)

	var winX float64
	var winY float64
	var window Window

	winX = (float64)(arg1)
	winY = (float64)(arg2)
	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return winX, winY, window
}

// Grab grabs the device so that all events coming from this device are
// passed to this application until the device is ungrabbed with
// gdk_device_ungrab(), or the window becomes unviewable. This overrides any
// previous grab on the device by this client.
//
// Note that @device and @window need to be on the same display.
//
// Device grabs are used for operations which need complete control over the
// given device events (either pointer or keyboard). For example in GTK+
// this is used for Drag and Drop operations, popup menus and such.
//
// Note that if the event mask of an X window has selected both button press
// and button release events, then a button press event will cause an
// automatic pointer grab until the button is released. X does this
// automatically since most applications expect to receive button press and
// release events in pairs. It is equivalent to a pointer grab on the window
// with @owner_events set to true.
//
// If you set up anything at the time you take the grab that needs to be
// cleaned up when the grab ends, you should handle the EventGrabBroken
// events that are emitted when the grab ends unvoluntarily.
func (d device) Grab(window Window, grabOwnership GrabOwnership, ownerEvents bool, eventMask EventMask, cursor Cursor, time_ uint32) GrabStatus {
	var arg0 *C.GdkDevice
	var arg1 *C.GdkWindow
	var arg2 C.GdkGrabOwnership
	var arg3 C.gboolean
	var arg4 C.GdkEventMask
	var arg5 *C.GdkCursor
	var arg6 C.guint32

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))
	arg2 = (C.GdkGrabOwnership)(grabOwnership)
	if ownerEvents {
		arg3 = C.gboolean(1)
	}
	arg4 = (C.GdkEventMask)(eventMask)
	arg5 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))
	arg6 = C.guint32(time_)

	var cret C.GdkGrabStatus

	cret = C.gdk_device_grab(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

	var grabStatus GrabStatus

	grabStatus = GrabStatus(cret)

	return grabStatus
}

// ListAxes returns a #GList of Atoms, containing the labels for the axes
// that @device currently has.
func (d device) ListAxes() *glib.List {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GList

	cret = C.gdk_device_list_axes(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// ListSlaveDevices: if the device if of type GDK_DEVICE_TYPE_MASTER, it
// will return the list of slave devices attached to it, otherwise it will
// return nil
func (d device) ListSlaveDevices() *glib.List {
	var arg0 *C.GdkDevice

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))

	var cret *C.GList

	cret = C.gdk_device_list_slave_devices(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// SetAxisUse specifies how an axis of a device is used.
func (d device) SetAxisUse(index_ uint, use AxisUse) {
	var arg0 *C.GdkDevice
	var arg1 C.guint
	var arg2 C.GdkAxisUse

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(index_)
	arg2 = (C.GdkAxisUse)(use)

	C.gdk_device_set_axis_use(arg0, arg1, arg2)
}

// SetKey specifies the X key event to generate when a macro button of a
// device is pressed.
func (d device) SetKey(index_ uint, keyval uint, modifiers ModifierType) {
	var arg0 *C.GdkDevice
	var arg1 C.guint
	var arg2 C.guint
	var arg3 C.GdkModifierType

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(index_)
	arg2 = C.guint(keyval)
	arg3 = (C.GdkModifierType)(modifiers)

	C.gdk_device_set_key(arg0, arg1, arg2, arg3)
}

// SetMode sets a the mode of an input device. The mode controls if the
// device is active and whether the device’s range is mapped to the entire
// screen or to a single window.
//
// Note: This is only meaningful for floating devices, master devices (and
// slaves connected to these) drive the pointer cursor, which is not limited
// by the input mode.
func (d device) SetMode(mode InputMode) bool {
	var arg0 *C.GdkDevice
	var arg1 C.GdkInputMode

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = (C.GdkInputMode)(mode)

	var cret C.gboolean

	cret = C.gdk_device_set_mode(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Ungrab: release any grab on @device.
func (d device) Ungrab(time_ uint32) {
	var arg0 *C.GdkDevice
	var arg1 C.guint32

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = C.guint32(time_)

	C.gdk_device_ungrab(arg0, arg1)
}

// Warp warps @device in @display to the point @x,@y on the screen @screen,
// unless the device is confined to a window by a grab, in which case it
// will be moved as far as allowed by the grab. Warping the pointer creates
// events as if the user had moved the mouse instantaneously to the
// destination.
//
// Note that the pointer should normally be under the control of the user.
// This function was added to cover some rare use cases like keyboard
// navigation support for the color picker in the ColorSelectionDialog.
func (d device) Warp(screen Screen, x int, y int) {
	var arg0 *C.GdkDevice
	var arg1 *C.GdkScreen
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkDevice)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	arg2 = C.gint(x)
	arg3 = C.gint(y)

	C.gdk_device_warp(arg0, arg1, arg2, arg3)
}

// DeviceManager: in addition to a single pointer and keyboard for user
// interface input, GDK contains support for a variety of input devices,
// including graphics tablets, touchscreens and multiple pointers/keyboards
// interacting simultaneously with the user interface. Such input devices often
// have additional features, such as sub-pixel positioning information and
// additional device-dependent information.
//
// In order to query the device hierarchy and be aware of changes in the device
// hierarchy (such as virtual devices being created or removed, or physical
// devices being plugged or unplugged), GDK provides DeviceManager.
//
// By default, and if the platform supports it, GDK is aware of multiple
// keyboard/pointer pairs and multitouch devices. This behavior can be changed
// by calling gdk_disable_multidevice() before gdk_display_open(). There should
// rarely be a need to do that though, since GDK defaults to a compatibility
// mode in which it will emit just one enter/leave event pair for all devices on
// a window. To enable per-device enter/leave events and other multi-pointer
// interaction features, gdk_window_set_support_multidevice() must be called on
// Windows (or gtk_widget_set_support_multidevice() on widgets). window. See the
// gdk_window_set_support_multidevice() documentation for more information.
//
// On X11, multi-device support is implemented through XInput 2. Unless
// gdk_disable_multidevice() is called, the XInput 2 DeviceManager
// implementation will be used as the input source. Otherwise either the core or
// XInput 1 implementations will be used.
//
// For simple applications that don’t have any special interest in input
// devices, the so-called “client pointer” provides a reasonable approximation
// to a simple setup with a single pointer and keyboard. The device that has
// been set as the client pointer can be accessed via
// gdk_device_manager_get_client_pointer().
//
// Conceptually, in multidevice mode there are 2 device types. Virtual devices
// (or master devices) are represented by the pointer cursors and keyboard foci
// that are seen on the screen. Physical devices (or slave devices) represent
// the hardware that is controlling the virtual devices, and thus have no
// visible cursor on the screen.
//
// Virtual devices are always paired, so there is a keyboard device for every
// pointer device. Associations between devices may be inspected through
// gdk_device_get_associated_device().
//
// There may be several virtual devices, and several physical devices could be
// controlling each of these virtual devices. Physical devices may also be
// “floating”, which means they are not attached to any virtual device.
//
// Master and slave devices
//
//    carlos@sacarino:~$ xinput list
//    ⎡ Virtual core pointer                          id=2    [master pointer  (3)]
//    ⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
//    ⎜   ↳ Wacom ISDv4 E6 Pen stylus                 id=10   [slave  pointer  (2)]
//    ⎜   ↳ Wacom ISDv4 E6 Finger touch               id=11   [slave  pointer  (2)]
//    ⎜   ↳ SynPS/2 Synaptics TouchPad                id=13   [slave  pointer  (2)]
//    ⎜   ↳ TPPS/2 IBM TrackPoint                     id=14   [slave  pointer  (2)]
//    ⎜   ↳ Wacom ISDv4 E6 Pen eraser                 id=16   [slave  pointer  (2)]
//    ⎣ Virtual core keyboard                         id=3    [master keyboard (2)]
//        ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
//        ↳ Power Button                              id=6    [slave  keyboard (3)]
//        ↳ Video Bus                                 id=7    [slave  keyboard (3)]
//        ↳ Sleep Button                              id=8    [slave  keyboard (3)]
//        ↳ Integrated Camera                         id=9    [slave  keyboard (3)]
//        ↳ AT Translated Set 2 keyboard              id=12   [slave  keyboard (3)]
//        ↳ ThinkPad Extra Buttons                    id=15   [slave  keyboard (3)]
//
// By default, GDK will automatically listen for events coming from all master
// devices, setting the Device for all events coming from input devices. Events
// containing device information are K_MOTION_NOTIFY, K_BUTTON_PRESS,
// K_2BUTTON_PRESS, K_3BUTTON_PRESS, K_BUTTON_RELEASE, K_SCROLL, K_KEY_PRESS,
// K_KEY_RELEASE, K_ENTER_NOTIFY, K_LEAVE_NOTIFY, K_FOCUS_CHANGE,
// K_PROXIMITY_IN, K_PROXIMITY_OUT, K_DRAG_ENTER, K_DRAG_LEAVE, K_DRAG_MOTION,
// K_DRAG_STATUS, K_DROP_START, K_DROP_FINISHED and K_GRAB_BROKEN. When dealing
// with an event on a master device, it is possible to get the source (slave)
// device that the event originated from via gdk_event_get_source_device().
//
// On a standard session, all physical devices are connected by default to the
// "Virtual Core Pointer/Keyboard" master devices, hence routing all events
// through these. This behavior is only modified by device grabs, where the
// slave device is temporarily detached for as long as the grab is held, and
// more permanently by user modifications to the device hierarchy.
//
// On certain application specific setups, it may make sense to detach a
// physical device from its master pointer, and mapping it to an specific
// window. This can be achieved by the combination of gdk_device_grab() and
// gdk_device_set_mode().
//
// In order to listen for events coming from devices other than a virtual
// device, gdk_window_set_device_events() must be called. Generally, this
// function can be used to modify the event mask for any given device.
//
// Input devices may also provide additional information besides X/Y. For
// example, graphics tablets may also provide pressure and X/Y tilt information.
// This information is device-dependent, and may be queried through
// gdk_device_get_axis(). In multidevice mode, virtual devices will change axes
// in order to always represent the physical device that is routing events
// through it. Whenever the physical device changes, the Device:n-axes property
// will be notified, and gdk_device_list_axes() will return the new device axes.
//
// Devices may also have associated “keys” or macro buttons. Such keys can be
// globally set to map into normal X keyboard events. The mapping is set using
// gdk_device_set_key().
//
// In GTK+ 3.20, a new Seat object has been introduced that supersedes
// DeviceManager and should be preferred in newly written code.
type DeviceManager interface {
	gextras.Objector

	// ClientPointer returns the client pointer, that is, the master pointer
	// that acts as the core pointer for this application. In X11, window
	// managers may change this depending on the interaction pattern under the
	// presence of several pointers.
	//
	// You should use this function seldomly, only in code that isn’t triggered
	// by a Event and there aren’t other means to get a meaningful Device to
	// operate on.
	ClientPointer() Device
	// Display gets the Display associated to @device_manager.
	Display() Display
	// ListDevices returns the list of devices of type @type currently attached
	// to @device_manager.
	ListDevices(typ DeviceType) *glib.List
}

// deviceManager implements the DeviceManager interface.
type deviceManager struct {
	gextras.Objector
}

var _ DeviceManager = (*deviceManager)(nil)

// WrapDeviceManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapDeviceManager(obj *externglib.Object) DeviceManager {
	return DeviceManager{
		Objector: obj,
	}
}

func marshalDeviceManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDeviceManager(obj), nil
}

// ClientPointer returns the client pointer, that is, the master pointer
// that acts as the core pointer for this application. In X11, window
// managers may change this depending on the interaction pattern under the
// presence of several pointers.
//
// You should use this function seldomly, only in code that isn’t triggered
// by a Event and there aren’t other means to get a meaningful Device to
// operate on.
func (d deviceManager) ClientPointer() Device {
	var arg0 *C.GdkDeviceManager

	arg0 = (*C.GdkDeviceManager)(unsafe.Pointer(d.Native()))

	var cret *C.GdkDevice

	cret = C.gdk_device_manager_get_client_pointer(arg0)

	var device Device

	device = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Device)

	return device
}

// Display gets the Display associated to @device_manager.
func (d deviceManager) Display() Display {
	var arg0 *C.GdkDeviceManager

	arg0 = (*C.GdkDeviceManager)(unsafe.Pointer(d.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_device_manager_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// ListDevices returns the list of devices of type @type currently attached
// to @device_manager.
func (d deviceManager) ListDevices(typ DeviceType) *glib.List {
	var arg0 *C.GdkDeviceManager
	var arg1 C.GdkDeviceType

	arg0 = (*C.GdkDeviceManager)(unsafe.Pointer(d.Native()))
	arg1 = (C.GdkDeviceType)(typ)

	var cret *C.GList

	cret = C.gdk_device_manager_list_devices(arg0, arg1)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

type DeviceTool interface {
	gextras.Objector

	// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
	// When non-zero, the identificator is unique for the given tool model,
	// meaning that two identical tools will share the same @hardware_id, but
	// will have different serial numbers (see gdk_device_tool_get_serial()).
	//
	// This is a more concrete (and device specific) method to identify a
	// DeviceTool than gdk_device_tool_get_tool_type(), as a tablet may support
	// multiple devices with the same DeviceToolType, but having different
	// hardware identificators.
	HardwareID() uint64
	// Serial gets the serial of this tool, this value can be used to identify a
	// physical tool (eg. a tablet pen) across program executions.
	Serial() uint64
	// ToolType gets the DeviceToolType of the tool.
	ToolType() DeviceToolType
}

// deviceTool implements the DeviceTool interface.
type deviceTool struct {
	gextras.Objector
}

var _ DeviceTool = (*deviceTool)(nil)

// WrapDeviceTool wraps a GObject to the right type. It is
// primarily used internally.
func WrapDeviceTool(obj *externglib.Object) DeviceTool {
	return DeviceTool{
		Objector: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDeviceTool(obj), nil
}

// HardwareID gets the hardware ID of this tool, or 0 if it's not known.
// When non-zero, the identificator is unique for the given tool model,
// meaning that two identical tools will share the same @hardware_id, but
// will have different serial numbers (see gdk_device_tool_get_serial()).
//
// This is a more concrete (and device specific) method to identify a
// DeviceTool than gdk_device_tool_get_tool_type(), as a tablet may support
// multiple devices with the same DeviceToolType, but having different
// hardware identificators.
func (t deviceTool) HardwareID() uint64 {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	var cret C.guint64

	cret = C.gdk_device_tool_get_hardware_id(arg0)

	var guint64 uint64

	guint64 = (uint64)(cret)

	return guint64
}

// Serial gets the serial of this tool, this value can be used to identify a
// physical tool (eg. a tablet pen) across program executions.
func (t deviceTool) Serial() uint64 {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	var cret C.guint64

	cret = C.gdk_device_tool_get_serial(arg0)

	var guint64 uint64

	guint64 = (uint64)(cret)

	return guint64
}

// ToolType gets the DeviceToolType of the tool.
func (t deviceTool) ToolType() DeviceToolType {
	var arg0 *C.GdkDeviceTool

	arg0 = (*C.GdkDeviceTool)(unsafe.Pointer(t.Native()))

	var cret C.GdkDeviceToolType

	cret = C.gdk_device_tool_get_tool_type(arg0)

	var deviceToolType DeviceToolType

	deviceToolType = DeviceToolType(cret)

	return deviceToolType
}

// Display objects purpose are two fold:
//
// - To manage and provide information about input devices (pointers and
// keyboards)
//
// - To manage and provide information about the available Screens
//
// GdkDisplay objects are the GDK representation of an X Display, which can be
// described as a workstation consisting of a keyboard, a pointing device (such
// as a mouse) and one or more screens. It is used to open and keep track of
// various GdkScreen objects currently instantiated by the application. It is
// also used to access the keyboard(s) and mouse pointer(s) of the display.
//
// Most of the input device handling has been factored out into the separate
// DeviceManager object. Every display has a device manager, which you can
// obtain using gdk_display_get_device_manager().
type Display interface {
	gextras.Objector

	// Beep emits a short beep on @display
	Beep()
	// Close closes the connection to the windowing system for the given
	// display, and cleans up associated resources.
	Close()
	// DeviceIsGrabbed returns true if there is an ongoing grab on @device for
	// @display.
	DeviceIsGrabbed(device Device) bool
	// Flush flushes any requests queued for the windowing system; this happens
	// automatically when the main loop blocks waiting for new events, but if
	// your application is drawing without returning control to the main loop,
	// you may need to call this function explicitly. A common case where this
	// function needs to be called is when an application is executing drawing
	// commands from a thread other than the thread where the main loop is
	// running.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	Flush()
	// AppLaunchContext returns a AppLaunchContext suitable for launching
	// applications on the given display.
	AppLaunchContext() AppLaunchContext
	// DefaultCursorSize returns the default size to use for cursors on
	// @display.
	DefaultCursorSize() uint
	// DefaultGroup returns the default group leader window for all toplevel
	// windows on @display. This window is implicitly created by GDK. See
	// gdk_window_set_group().
	DefaultGroup() Window
	// DefaultScreen: get the default Screen for @display.
	DefaultScreen() Screen
	// DefaultSeat returns the default Seat for this display.
	DefaultSeat() Seat
	// DeviceManager returns the DeviceManager associated to @display.
	DeviceManager() DeviceManager
	// MaximalCursorSize gets the maximal size to use for cursors on @display.
	MaximalCursorSize() (width uint, height uint)
	// Monitor gets a monitor associated with this display.
	Monitor(monitorNum int) Monitor
	// MonitorAtPoint gets the monitor in which the point (@x, @y) is located,
	// or a nearby monitor if the point is not in any monitor.
	MonitorAtPoint(x int, y int) Monitor
	// MonitorAtWindow gets the monitor in which the largest area of @window
	// resides, or a monitor close to @window if it is outside of all monitors.
	MonitorAtWindow(window Window) Monitor
	// NMonitors gets the number of monitors that belong to @display.
	//
	// The returned number is valid until the next emission of the
	// Display::monitor-added or Display::monitor-removed signal.
	NMonitors() int
	// NScreens gets the number of screen managed by the @display.
	NScreens() int
	// Name gets the name of the display.
	Name() string
	// Pointer gets the current location of the pointer and the current modifier
	// mask for a given display.
	Pointer() (screen Screen, x int, y int, mask ModifierType)
	// PrimaryMonitor gets the primary monitor for the display.
	//
	// The primary monitor is considered the monitor where the “main desktop”
	// lives. While normal application windows typically allow the window
	// manager to place the windows, specialized desktop applications such as
	// panels should place themselves on the primary monitor.
	PrimaryMonitor() Monitor
	// Screen returns a screen object for one of the screens of the display.
	Screen(screenNum int) Screen
	// WindowAtPointer obtains the window underneath the mouse pointer,
	// returning the location of the pointer in that window in @win_x, @win_y
	// for @screen. Returns nil if the window under the mouse pointer is not
	// known to GDK (for example, belongs to another application).
	WindowAtPointer() (winX int, winY int, window Window)
	// HasPending returns whether the display has events that are waiting to be
	// processed.
	HasPending() bool
	// IsClosed finds out if the display has been closed.
	IsClosed() bool
	// KeyboardUngrab: release any keyboard grab
	KeyboardUngrab(time_ uint32)
	// ListDevices returns the list of available input devices attached to
	// @display. The list is statically allocated and should not be freed.
	ListDevices() *glib.List
	// ListSeats returns the list of seats known to @display.
	ListSeats() *glib.List
	// NotifyStartupComplete indicates to the GUI environment that the
	// application has finished loading, using a given identifier.
	//
	// GTK+ will call this function automatically for Window with custom
	// startup-notification identifier unless
	// gtk_window_set_auto_startup_notification() is called to disable that
	// feature.
	NotifyStartupComplete(startupId string)
	// PointerIsGrabbed: test if the pointer is grabbed.
	PointerIsGrabbed() bool
	// PointerUngrab: release any pointer grab.
	PointerUngrab(time_ uint32)
	// RequestSelectionNotification: request EventOwnerChange events for
	// ownership changes of the selection named by the given atom.
	RequestSelectionNotification(selection Atom) bool
	// SetDoubleClickDistance sets the double click distance (two clicks within
	// this distance count as a double click and result in a K_2BUTTON_PRESS
	// event). See also gdk_display_set_double_click_time(). Applications should
	// not set this, it is a global user-configured setting.
	SetDoubleClickDistance(distance uint)
	// SetDoubleClickTime sets the double click time (two clicks within this
	// time interval count as a double click and result in a K_2BUTTON_PRESS
	// event). Applications should not set this, it is a global user-configured
	// setting.
	SetDoubleClickTime(msec uint)
	// StoreClipboard issues a request to the clipboard manager to store the
	// clipboard data. On X11, this is a special program that works according to
	// the FreeDesktop Clipboard Specification
	// (http://www.freedesktop.org/Standards/clipboard-manager-spec).
	StoreClipboard()
	// SupportsClipboardPersistence returns whether the speicifed display
	// supports clipboard persistance; i.e. if it’s possible to store the
	// clipboard data after an application has quit. On X11 this checks if a
	// clipboard daemon is running.
	SupportsClipboardPersistence() bool
	// SupportsComposite returns true if gdk_window_set_composited() can be used
	// to redirect drawing on the window using compositing.
	//
	// Currently this only works on X11 with XComposite and XDamage extensions
	// available.
	SupportsComposite() bool
	// SupportsCursorAlpha returns true if cursors can use an 8bit alpha channel
	// on @display. Otherwise, cursors are restricted to bilevel alpha (i.e. a
	// mask).
	SupportsCursorAlpha() bool
	// SupportsCursorColor returns true if multicolored cursors are supported on
	// @display. Otherwise, cursors have only a forground and a background
	// color.
	SupportsCursorColor() bool
	// SupportsInputShapes returns true if gdk_window_input_shape_combine_mask()
	// can be used to modify the input shape of windows on @display.
	SupportsInputShapes() bool
	// SupportsSelectionNotification returns whether EventOwnerChange events
	// will be sent when the owner of a selection changes.
	SupportsSelectionNotification() bool
	// SupportsShapes returns true if gdk_window_shape_combine_mask() can be
	// used to create shaped windows on @display.
	SupportsShapes() bool
	// Sync flushes any requests queued for the windowing system and waits until
	// all requests have been handled. This is often used for making sure that
	// the display is synchronized with the current state of the program.
	// Calling gdk_display_sync() before gdk_error_trap_pop() makes sure that
	// any errors generated from earlier requests are handled before the error
	// trap is removed.
	//
	// This is most useful for X11. On windowing systems where requests are
	// handled synchronously, this function will do nothing.
	Sync()
	// WarpPointer warps the pointer of @display to the point @x,@y on the
	// screen @screen, unless the pointer is confined to a window by a grab, in
	// which case it will be moved as far as allowed by the grab. Warping the
	// pointer creates events as if the user had moved the mouse instantaneously
	// to the destination.
	//
	// Note that the pointer should normally be under the control of the user.
	// This function was added to cover some rare use cases like keyboard
	// navigation support for the color picker in the ColorSelectionDialog.
	WarpPointer(screen Screen, x int, y int)
}

// display implements the Display interface.
type display struct {
	gextras.Objector
}

var _ Display = (*display)(nil)

// WrapDisplay wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplay(obj *externglib.Object) Display {
	return Display{
		Objector: obj,
	}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplay(obj), nil
}

// Beep emits a short beep on @display
func (d display) Beep() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_beep(arg0)
}

// Close closes the connection to the windowing system for the given
// display, and cleans up associated resources.
func (d display) Close() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_close(arg0)
}

// DeviceIsGrabbed returns true if there is an ongoing grab on @device for
// @display.
func (d display) DeviceIsGrabbed(device Device) bool {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	var cret C.gboolean

	cret = C.gdk_display_device_is_grabbed(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Flush flushes any requests queued for the windowing system; this happens
// automatically when the main loop blocks waiting for new events, but if
// your application is drawing without returning control to the main loop,
// you may need to call this function explicitly. A common case where this
// function needs to be called is when an application is executing drawing
// commands from a thread other than the thread where the main loop is
// running.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (d display) Flush() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_flush(arg0)
}

// AppLaunchContext returns a AppLaunchContext suitable for launching
// applications on the given display.
func (d display) AppLaunchContext() AppLaunchContext {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkAppLaunchContext

	cret = C.gdk_display_get_app_launch_context(arg0)

	var appLaunchContext AppLaunchContext

	appLaunchContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(AppLaunchContext)

	return appLaunchContext
}

// DefaultCursorSize returns the default size to use for cursors on
// @display.
func (d display) DefaultCursorSize() uint {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.guint

	cret = C.gdk_display_get_default_cursor_size(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// DefaultGroup returns the default group leader window for all toplevel
// windows on @display. This window is implicitly created by GDK. See
// gdk_window_set_group().
func (d display) DefaultGroup() Window {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_display_get_default_group(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// DefaultScreen: get the default Screen for @display.
func (d display) DefaultScreen() Screen {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkScreen

	cret = C.gdk_display_get_default_screen(arg0)

	var screen Screen

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Screen)

	return screen
}

// DefaultSeat returns the default Seat for this display.
func (d display) DefaultSeat() Seat {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkSeat

	cret = C.gdk_display_get_default_seat(arg0)

	var seat Seat

	seat = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Seat)

	return seat
}

// DeviceManager returns the DeviceManager associated to @display.
func (d display) DeviceManager() DeviceManager {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkDeviceManager

	cret = C.gdk_display_get_device_manager(arg0)

	var deviceManager DeviceManager

	deviceManager = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(DeviceManager)

	return deviceManager
}

// MaximalCursorSize gets the maximal size to use for cursors on @display.
func (d display) MaximalCursorSize() (width uint, height uint) {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var arg1 C.guint
	var arg2 C.guint

	C.gdk_display_get_maximal_cursor_size(arg0, &arg1, &arg2)

	var width uint
	var height uint

	width = (uint)(arg1)
	height = (uint)(arg2)

	return width, height
}

// Monitor gets a monitor associated with this display.
func (d display) Monitor(monitorNum int) Monitor {
	var arg0 *C.GdkDisplay
	var arg1 C.int

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.int(monitorNum)

	var cret *C.GdkMonitor

	cret = C.gdk_display_get_monitor(arg0, arg1)

	var monitor Monitor

	monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Monitor)

	return monitor
}

// MonitorAtPoint gets the monitor in which the point (@x, @y) is located,
// or a nearby monitor if the point is not in any monitor.
func (d display) MonitorAtPoint(x int, y int) Monitor {
	var arg0 *C.GdkDisplay
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.int(x)
	arg2 = C.int(y)

	var cret *C.GdkMonitor

	cret = C.gdk_display_get_monitor_at_point(arg0, arg1, arg2)

	var monitor Monitor

	monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Monitor)

	return monitor
}

// MonitorAtWindow gets the monitor in which the largest area of @window
// resides, or a monitor close to @window if it is outside of all monitors.
func (d display) MonitorAtWindow(window Window) Monitor {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkWindow

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret *C.GdkMonitor

	cret = C.gdk_display_get_monitor_at_window(arg0, arg1)

	var monitor Monitor

	monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Monitor)

	return monitor
}

// NMonitors gets the number of monitors that belong to @display.
//
// The returned number is valid until the next emission of the
// Display::monitor-added or Display::monitor-removed signal.
func (d display) NMonitors() int {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.int

	cret = C.gdk_display_get_n_monitors(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// NScreens gets the number of screen managed by the @display.
func (d display) NScreens() int {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gint

	cret = C.gdk_display_get_n_screens(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Name gets the name of the display.
func (d display) Name() string {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.gchar

	cret = C.gdk_display_get_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)

	return utf8
}

// Pointer gets the current location of the pointer and the current modifier
// mask for a given display.
func (d display) Pointer() (screen Screen, x int, y int, mask ModifierType) {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var arg1 **C.GdkScreen
	var arg2 C.gint
	var arg3 C.gint
	var arg4 C.GdkModifierType

	C.gdk_display_get_pointer(arg0, arg1, &arg2, &arg3, &arg4)

	var screen Screen
	var x int
	var y int
	var mask ModifierType

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(arg1.Native()))).(Screen)
	x = (int)(arg2)
	y = (int)(arg3)
	mask = ModifierType(arg4)

	return screen, x, y, mask
}

// PrimaryMonitor gets the primary monitor for the display.
//
// The primary monitor is considered the monitor where the “main desktop”
// lives. While normal application windows typically allow the window
// manager to place the windows, specialized desktop applications such as
// panels should place themselves on the primary monitor.
func (d display) PrimaryMonitor() Monitor {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GdkMonitor

	cret = C.gdk_display_get_primary_monitor(arg0)

	var monitor Monitor

	monitor = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Monitor)

	return monitor
}

// Screen returns a screen object for one of the screens of the display.
func (d display) Screen(screenNum int) Screen {
	var arg0 *C.GdkDisplay
	var arg1 C.gint

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.gint(screenNum)

	var cret *C.GdkScreen

	cret = C.gdk_display_get_screen(arg0, arg1)

	var screen Screen

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Screen)

	return screen
}

// WindowAtPointer obtains the window underneath the mouse pointer,
// returning the location of the pointer in that window in @win_x, @win_y
// for @screen. Returns nil if the window under the mouse pointer is not
// known to GDK (for example, belongs to another application).
func (d display) WindowAtPointer() (winX int, winY int, window Window) {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var arg1 C.gint
	var arg2 C.gint
	var cret *C.GdkWindow

	cret = C.gdk_display_get_window_at_pointer(arg0, &arg1, &arg2)

	var winX int
	var winY int
	var window Window

	winX = (int)(arg1)
	winY = (int)(arg2)
	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return winX, winY, window
}

// HasPending returns whether the display has events that are waiting to be
// processed.
func (d display) HasPending() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_has_pending(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// IsClosed finds out if the display has been closed.
func (d display) IsClosed() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_is_closed(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// KeyboardUngrab: release any keyboard grab
func (d display) KeyboardUngrab(time_ uint32) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint32

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.guint32(time_)

	C.gdk_display_keyboard_ungrab(arg0, arg1)
}

// ListDevices returns the list of available input devices attached to
// @display. The list is statically allocated and should not be freed.
func (d display) ListDevices() *glib.List {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GList

	cret = C.gdk_display_list_devices(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))

	return list
}

// ListSeats returns the list of seats known to @display.
func (d display) ListSeats() *glib.List {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret *C.GList

	cret = C.gdk_display_list_seats(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// NotifyStartupComplete indicates to the GUI environment that the
// application has finished loading, using a given identifier.
//
// GTK+ will call this function automatically for Window with custom
// startup-notification identifier unless
// gtk_window_set_auto_startup_notification() is called to disable that
// feature.
func (d display) NotifyStartupComplete(startupId string) {
	var arg0 *C.GdkDisplay
	var arg1 *C.gchar

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = (*C.gchar)(C.CString(startupId))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_display_notify_startup_complete(arg0, arg1)
}

// PointerIsGrabbed: test if the pointer is grabbed.
func (d display) PointerIsGrabbed() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_pointer_is_grabbed(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// PointerUngrab: release any pointer grab.
func (d display) PointerUngrab(time_ uint32) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint32

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.guint32(time_)

	C.gdk_display_pointer_ungrab(arg0, arg1)
}

// RequestSelectionNotification: request EventOwnerChange events for
// ownership changes of the selection named by the given atom.
func (d display) RequestSelectionNotification(selection Atom) bool {
	var arg0 *C.GdkDisplay
	var arg1 C.GdkAtom

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = (C.GdkAtom)(unsafe.Pointer(selection.Native()))

	var cret C.gboolean

	cret = C.gdk_display_request_selection_notification(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetDoubleClickDistance sets the double click distance (two clicks within
// this distance count as a double click and result in a K_2BUTTON_PRESS
// event). See also gdk_display_set_double_click_time(). Applications should
// not set this, it is a global user-configured setting.
func (d display) SetDoubleClickDistance(distance uint) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(distance)

	C.gdk_display_set_double_click_distance(arg0, arg1)
}

// SetDoubleClickTime sets the double click time (two clicks within this
// time interval count as a double click and result in a K_2BUTTON_PRESS
// event). Applications should not set this, it is a global user-configured
// setting.
func (d display) SetDoubleClickTime(msec uint) {
	var arg0 *C.GdkDisplay
	var arg1 C.guint

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = C.guint(msec)

	C.gdk_display_set_double_click_time(arg0, arg1)
}

// StoreClipboard issues a request to the clipboard manager to store the
// clipboard data. On X11, this is a special program that works according to
// the FreeDesktop Clipboard Specification
// (http://www.freedesktop.org/Standards/clipboard-manager-spec).
func (d display) StoreClipboard() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_store_clipboard(arg0)
}

// SupportsClipboardPersistence returns whether the speicifed display
// supports clipboard persistance; i.e. if it’s possible to store the
// clipboard data after an application has quit. On X11 this checks if a
// clipboard daemon is running.
func (d display) SupportsClipboardPersistence() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_clipboard_persistence(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsComposite returns true if gdk_window_set_composited() can be used
// to redirect drawing on the window using compositing.
//
// Currently this only works on X11 with XComposite and XDamage extensions
// available.
func (d display) SupportsComposite() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_composite(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsCursorAlpha returns true if cursors can use an 8bit alpha channel
// on @display. Otherwise, cursors are restricted to bilevel alpha (i.e. a
// mask).
func (d display) SupportsCursorAlpha() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_cursor_alpha(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsCursorColor returns true if multicolored cursors are supported on
// @display. Otherwise, cursors have only a forground and a background
// color.
func (d display) SupportsCursorColor() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_cursor_color(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsInputShapes returns true if gdk_window_input_shape_combine_mask()
// can be used to modify the input shape of windows on @display.
func (d display) SupportsInputShapes() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_input_shapes(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsSelectionNotification returns whether EventOwnerChange events
// will be sent when the owner of a selection changes.
func (d display) SupportsSelectionNotification() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_selection_notification(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SupportsShapes returns true if gdk_window_shape_combine_mask() can be
// used to create shaped windows on @display.
func (d display) SupportsShapes() bool {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	var cret C.gboolean

	cret = C.gdk_display_supports_shapes(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Sync flushes any requests queued for the windowing system and waits until
// all requests have been handled. This is often used for making sure that
// the display is synchronized with the current state of the program.
// Calling gdk_display_sync() before gdk_error_trap_pop() makes sure that
// any errors generated from earlier requests are handled before the error
// trap is removed.
//
// This is most useful for X11. On windowing systems where requests are
// handled synchronously, this function will do nothing.
func (d display) Sync() {
	var arg0 *C.GdkDisplay

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))

	C.gdk_display_sync(arg0)
}

// WarpPointer warps the pointer of @display to the point @x,@y on the
// screen @screen, unless the pointer is confined to a window by a grab, in
// which case it will be moved as far as allowed by the grab. Warping the
// pointer creates events as if the user had moved the mouse instantaneously
// to the destination.
//
// Note that the pointer should normally be under the control of the user.
// This function was added to cover some rare use cases like keyboard
// navigation support for the color picker in the ColorSelectionDialog.
func (d display) WarpPointer(screen Screen, x int, y int) {
	var arg0 *C.GdkDisplay
	var arg1 *C.GdkScreen
	var arg2 C.gint
	var arg3 C.gint

	arg0 = (*C.GdkDisplay)(unsafe.Pointer(d.Native()))
	arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	arg2 = C.gint(x)
	arg3 = C.gint(y)

	C.gdk_display_warp_pointer(arg0, arg1, arg2, arg3)
}

// DisplayManager: the purpose of the DisplayManager singleton object is to
// offer notification when displays appear or disappear or the default display
// changes.
//
// You can use gdk_display_manager_get() to obtain the DisplayManager singleton,
// but that should be rarely necessary. Typically, initializing GTK+ opens a
// display that you can work with without ever accessing the DisplayManager.
//
// The GDK library can be built with support for multiple backends. The
// DisplayManager object determines which backend is used at runtime.
//
// When writing backend-specific code that is supposed to work with multiple GDK
// backends, you have to consider both compile time and runtime. At compile
// time, use the K_WINDOWING_X11, K_WINDOWING_WIN32 macros, etc. to find out
// which backends are present in the GDK library you are building your
// application against. At runtime, use type-check macros like
// GDK_IS_X11_DISPLAY() to find out which backend is in use:
//
// Backend-specific code
//
//    #ifdef GDK_WINDOWING_X11
//      if (GDK_IS_X11_DISPLAY (display))
//        {
//          // make X11-specific calls here
//        }
//      else
//    #endif
//    #ifdef GDK_WINDOWING_QUARTZ
//      if (GDK_IS_QUARTZ_DISPLAY (display))
//        {
//          // make Quartz-specific calls here
//        }
//      else
//    #endif
//      g_error ("Unsupported GDK backend");
type DisplayManager interface {
	gextras.Objector

	// DefaultDisplay gets the default Display.
	DefaultDisplay() Display
	// ListDisplays: list all currently open displays.
	ListDisplays() *glib.SList
	// OpenDisplay opens a display.
	OpenDisplay(name string) Display
	// SetDefaultDisplay sets @display as the default display.
	SetDefaultDisplay(display Display)
}

// displayManager implements the DisplayManager interface.
type displayManager struct {
	gextras.Objector
}

var _ DisplayManager = (*displayManager)(nil)

// WrapDisplayManager wraps a GObject to the right type. It is
// primarily used internally.
func WrapDisplayManager(obj *externglib.Object) DisplayManager {
	return DisplayManager{
		Objector: obj,
	}
}

func marshalDisplayManager(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDisplayManager(obj), nil
}

// DefaultDisplay gets the default Display.
func (m displayManager) DefaultDisplay() Display {
	var arg0 *C.GdkDisplayManager

	arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_display_manager_get_default_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// ListDisplays: list all currently open displays.
func (m displayManager) ListDisplays() *glib.SList {
	var arg0 *C.GdkDisplayManager

	arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))

	var cret *C.GSList

	cret = C.gdk_display_manager_list_displays(arg0)

	var sList *glib.SList

	sList = glib.WrapSList(unsafe.Pointer(cret))
	runtime.SetFinalizer(sList, func(v *glib.SList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return sList
}

// OpenDisplay opens a display.
func (m displayManager) OpenDisplay(name string) Display {
	var arg0 *C.GdkDisplayManager
	var arg1 *C.gchar

	arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret *C.GdkDisplay

	cret = C.gdk_display_manager_open_display(arg0, arg1)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// SetDefaultDisplay sets @display as the default display.
func (m displayManager) SetDefaultDisplay(display Display) {
	var arg0 *C.GdkDisplayManager
	var arg1 *C.GdkDisplay

	arg0 = (*C.GdkDisplayManager)(unsafe.Pointer(m.Native()))
	arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

	C.gdk_display_manager_set_default_display(arg0, arg1)
}

type DragContext interface {
	gextras.Objector

	// Actions determines the bitmask of actions proposed by the source if
	// gdk_drag_context_get_suggested_action() returns GDK_ACTION_ASK.
	Actions() DragAction
	// DestWindow returns the destination window for the DND operation.
	DestWindow() Window
	// Device returns the Device associated to the drag context.
	Device() Device
	// DragWindow returns the window on which the drag icon should be rendered
	// during the drag operation. Note that the window may not be available
	// until the drag operation has begun. GDK will move the window in
	// accordance with the ongoing drag operation. The window is owned by
	// @context and will be destroyed when the drag operation is over.
	DragWindow() Window
	// Protocol returns the drag protocol that is used by this context.
	Protocol() DragProtocol
	// SelectedAction determines the action chosen by the drag destination.
	SelectedAction() DragAction
	// SourceWindow returns the Window where the DND operation started.
	SourceWindow() Window
	// SuggestedAction determines the suggested drag action of the context.
	SuggestedAction() DragAction
	// ListTargets retrieves the list of targets of the context.
	ListTargets() *glib.List
	// ManageDnd requests the drag and drop operation to be managed by @context.
	// When a drag and drop operation becomes managed, the DragContext will
	// internally handle all input and source-side EventDND events as required
	// by the windowing system.
	//
	// Once the drag and drop operation is managed, the drag context will emit
	// the following signals: - The DragContext::action-changed signal whenever
	// the final action to be performed by the drag and drop operation changes.
	// - The DragContext::drop-performed signal after the user performs the drag
	// and drop gesture (typically by releasing the mouse button). - The
	// DragContext::dnd-finished signal after the drag and drop operation
	// concludes (after all Selection transfers happen). - The
	// DragContext::cancel signal if the drag and drop operation is finished but
	// doesn't happen over an accepting destination, or is cancelled through
	// other means.
	ManageDnd(ipcWindow Window, actions DragAction) bool
	// SetDevice associates a Device to @context, so all Drag and Drop events
	// for @context are emitted as if they came from this device.
	SetDevice(device Device)
	// SetHotspot sets the position of the drag window that will be kept under
	// the cursor hotspot. Initially, the hotspot is at the top left corner of
	// the drag window.
	SetHotspot(hotX int, hotY int)
}

// dragContext implements the DragContext interface.
type dragContext struct {
	gextras.Objector
}

var _ DragContext = (*dragContext)(nil)

// WrapDragContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapDragContext(obj *externglib.Object) DragContext {
	return DragContext{
		Objector: obj,
	}
}

func marshalDragContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDragContext(obj), nil
}

// Actions determines the bitmask of actions proposed by the source if
// gdk_drag_context_get_suggested_action() returns GDK_ACTION_ASK.
func (c dragContext) Actions() DragAction {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret C.GdkDragAction

	cret = C.gdk_drag_context_get_actions(arg0)

	var dragAction DragAction

	dragAction = DragAction(cret)

	return dragAction
}

// DestWindow returns the destination window for the DND operation.
func (c dragContext) DestWindow() Window {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_drag_context_get_dest_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// Device returns the Device associated to the drag context.
func (c dragContext) Device() Device {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkDevice

	cret = C.gdk_drag_context_get_device(arg0)

	var device Device

	device = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Device)

	return device
}

// DragWindow returns the window on which the drag icon should be rendered
// during the drag operation. Note that the window may not be available
// until the drag operation has begun. GDK will move the window in
// accordance with the ongoing drag operation. The window is owned by
// @context and will be destroyed when the drag operation is over.
func (c dragContext) DragWindow() Window {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_drag_context_get_drag_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// Protocol returns the drag protocol that is used by this context.
func (c dragContext) Protocol() DragProtocol {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret C.GdkDragProtocol

	cret = C.gdk_drag_context_get_protocol(arg0)

	var dragProtocol DragProtocol

	dragProtocol = DragProtocol(cret)

	return dragProtocol
}

// SelectedAction determines the action chosen by the drag destination.
func (c dragContext) SelectedAction() DragAction {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret C.GdkDragAction

	cret = C.gdk_drag_context_get_selected_action(arg0)

	var dragAction DragAction

	dragAction = DragAction(cret)

	return dragAction
}

// SourceWindow returns the Window where the DND operation started.
func (c dragContext) SourceWindow() Window {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_drag_context_get_source_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// SuggestedAction determines the suggested drag action of the context.
func (c dragContext) SuggestedAction() DragAction {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret C.GdkDragAction

	cret = C.gdk_drag_context_get_suggested_action(arg0)

	var dragAction DragAction

	dragAction = DragAction(cret)

	return dragAction
}

// ListTargets retrieves the list of targets of the context.
func (c dragContext) ListTargets() *glib.List {
	var arg0 *C.GdkDragContext

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))

	var cret *C.GList

	cret = C.gdk_drag_context_list_targets(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))

	return list
}

// ManageDnd requests the drag and drop operation to be managed by @context.
// When a drag and drop operation becomes managed, the DragContext will
// internally handle all input and source-side EventDND events as required
// by the windowing system.
//
// Once the drag and drop operation is managed, the drag context will emit
// the following signals: - The DragContext::action-changed signal whenever
// the final action to be performed by the drag and drop operation changes.
// - The DragContext::drop-performed signal after the user performs the drag
// and drop gesture (typically by releasing the mouse button). - The
// DragContext::dnd-finished signal after the drag and drop operation
// concludes (after all Selection transfers happen). - The
// DragContext::cancel signal if the drag and drop operation is finished but
// doesn't happen over an accepting destination, or is cancelled through
// other means.
func (c dragContext) ManageDnd(ipcWindow Window, actions DragAction) bool {
	var arg0 *C.GdkDragContext
	var arg1 *C.GdkWindow
	var arg2 C.GdkDragAction

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(ipcWindow.Native()))
	arg2 = (C.GdkDragAction)(actions)

	var cret C.gboolean

	cret = C.gdk_drag_context_manage_dnd(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SetDevice associates a Device to @context, so all Drag and Drop events
// for @context are emitted as if they came from this device.
func (c dragContext) SetDevice(device Device) {
	var arg0 *C.GdkDragContext
	var arg1 *C.GdkDevice

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))
	arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gdk_drag_context_set_device(arg0, arg1)
}

// SetHotspot sets the position of the drag window that will be kept under
// the cursor hotspot. Initially, the hotspot is at the top left corner of
// the drag window.
func (c dragContext) SetHotspot(hotX int, hotY int) {
	var arg0 *C.GdkDragContext
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkDragContext)(unsafe.Pointer(c.Native()))
	arg1 = C.gint(hotX)
	arg2 = C.gint(hotY)

	C.gdk_drag_context_set_hotspot(arg0, arg1, arg2)
}

// GLContext is an object representing the platform-specific OpenGL drawing
// context.
//
// GLContexts are created for a Window using gdk_window_create_gl_context(), and
// the context will match the Visual of the window.
//
// A GLContext is not tied to any particular normal framebuffer. For instance,
// it cannot draw to the Window back buffer. The GDK repaint system is in full
// control of the painting to that. Instead, you can create render buffers or
// textures and use gdk_cairo_draw_from_gl() in the draw function of your widget
// to draw them. Then GDK will handle the integration of your rendering with
// that of other widgets.
//
// Support for GLContext is platform-specific, context creation can fail,
// returning nil context.
//
// A GLContext has to be made "current" in order to start using it, otherwise
// any OpenGL call will be ignored.
//
// Creating a new OpenGL context ##
//
// In order to create a new GLContext instance you need a Window, which you
// typically get during the realize call of a widget.
//
// A GLContext is not realized until either gdk_gl_context_make_current(), or
// until it is realized using gdk_gl_context_realize(). It is possible to
// specify details of the GL context like the OpenGL version to be used, or
// whether the GL context should have extra state validation enabled after
// calling gdk_window_create_gl_context() by calling gdk_gl_context_realize().
// If the realization fails you have the option to change the settings of the
// GLContext and try again.
//
// Using a GdkGLContext ##
//
// You will need to make the GLContext the current context before issuing OpenGL
// calls; the system sends OpenGL commands to whichever context is current. It
// is possible to have multiple contexts, so you always need to ensure that the
// one which you want to draw with is the current one before issuing commands:
//
//    gdk_gl_context_make_current (context);
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which GLContext is the current one by using
// gdk_gl_context_get_current(); you can also unset any GLContext that is
// currently set by calling gdk_gl_context_clear_current().
type GLContext interface {
	gextras.Objector

	// DebugEnabled retrieves the value set using
	// gdk_gl_context_set_debug_enabled().
	DebugEnabled() bool
	// Display retrieves the Display the @context is created for
	Display() Display
	// ForwardCompatible retrieves the value set using
	// gdk_gl_context_set_forward_compatible().
	ForwardCompatible() bool
	// RequiredVersion retrieves the major and minor version requested by
	// calling gdk_gl_context_set_required_version().
	RequiredVersion() (major int, minor int)
	// SharedContext retrieves the GLContext that this @context share data with.
	SharedContext() GLContext
	// UseES checks whether the @context is using an OpenGL or OpenGL ES
	// profile.
	UseES() bool
	// Version retrieves the OpenGL version of the @context.
	//
	// The @context must be realized prior to calling this function.
	Version() (major int, minor int)
	// Window retrieves the Window used by the @context.
	Window() Window
	// IsLegacy: whether the GLContext is in legacy mode or not.
	//
	// The GLContext must be realized before calling this function.
	//
	// When realizing a GL context, GDK will try to use the OpenGL 3.2 core
	// profile; this profile removes all the OpenGL API that was deprecated
	// prior to the 3.2 version of the specification. If the realization is
	// successful, this function will return false.
	//
	// If the underlying OpenGL implementation does not support core profiles,
	// GDK will fall back to a pre-3.2 compatibility profile, and this function
	// will return true.
	//
	// You can use the value returned by this function to decide which kind of
	// OpenGL API to use, or whether to do extension discovery, or what kind of
	// shader programs to load.
	IsLegacy() bool
	// MakeCurrent makes the @context the current one.
	MakeCurrent()
	// Realize realizes the given GLContext.
	//
	// It is safe to call this function on a realized GLContext.
	Realize() error
	// SetDebugEnabled sets whether the GLContext should perform extra
	// validations and run time checking. This is useful during development, but
	// has additional overhead.
	//
	// The GLContext must not be realized or made current prior to calling this
	// function.
	SetDebugEnabled(enabled bool)
	// SetForwardCompatible sets whether the GLContext should be forward
	// compatible.
	//
	// Forward compatibile contexts must not support OpenGL functionality that
	// has been marked as deprecated in the requested version; non-forward
	// compatible contexts, on the other hand, must support both deprecated and
	// non deprecated functionality.
	//
	// The GLContext must not be realized or made current prior to calling this
	// function.
	SetForwardCompatible(compatible bool)
	// SetRequiredVersion sets the major and minor version of OpenGL to request.
	//
	// Setting @major and @minor to zero will use the default values.
	//
	// The GLContext must not be realized or made current prior to calling this
	// function.
	SetRequiredVersion(major int, minor int)
	// SetUseES requests that GDK create a OpenGL ES context instead of an
	// OpenGL one, if the platform and windowing system allows it.
	//
	// The @context must not have been realized.
	//
	// By default, GDK will attempt to automatically detect whether the
	// underlying GL implementation is OpenGL or OpenGL ES once the @context is
	// realized.
	//
	// You should check the return value of gdk_gl_context_get_use_es() after
	// calling gdk_gl_context_realize() to decide whether to use the OpenGL or
	// OpenGL ES API, extensions, or shaders.
	SetUseES(useEs int)
}

// glContext implements the GLContext interface.
type glContext struct {
	gextras.Objector
}

var _ GLContext = (*glContext)(nil)

// WrapGLContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapGLContext(obj *externglib.Object) GLContext {
	return GLContext{
		Objector: obj,
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapGLContext(obj), nil
}

// DebugEnabled retrieves the value set using
// gdk_gl_context_set_debug_enabled().
func (c glContext) DebugEnabled() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gdk_gl_context_get_debug_enabled(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Display retrieves the Display the @context is created for
func (c glContext) Display() Display {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_gl_context_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// ForwardCompatible retrieves the value set using
// gdk_gl_context_set_forward_compatible().
func (c glContext) ForwardCompatible() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gdk_gl_context_get_forward_compatible(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// RequiredVersion retrieves the major and minor version requested by
// calling gdk_gl_context_set_required_version().
func (c glContext) RequiredVersion() (major int, minor int) {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var arg1 C.int
	var arg2 C.int

	C.gdk_gl_context_get_required_version(arg0, &arg1, &arg2)

	var major int
	var minor int

	major = (int)(arg1)
	minor = (int)(arg2)

	return major, minor
}

// SharedContext retrieves the GLContext that this @context share data with.
func (c glContext) SharedContext() GLContext {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkGLContext

	cret = C.gdk_gl_context_get_shared_context(arg0)

	var glContext GLContext

	glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(GLContext)

	return glContext
}

// UseES checks whether the @context is using an OpenGL or OpenGL ES
// profile.
func (c glContext) UseES() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gdk_gl_context_get_use_es(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Version retrieves the OpenGL version of the @context.
//
// The @context must be realized prior to calling this function.
func (c glContext) Version() (major int, minor int) {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var arg1 C.int
	var arg2 C.int

	C.gdk_gl_context_get_version(arg0, &arg1, &arg2)

	var major int
	var minor int

	major = (int)(arg1)
	minor = (int)(arg2)

	return major, minor
}

// Window retrieves the Window used by the @context.
func (c glContext) Window() Window {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_gl_context_get_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// IsLegacy: whether the GLContext is in legacy mode or not.
//
// The GLContext must be realized before calling this function.
//
// When realizing a GL context, GDK will try to use the OpenGL 3.2 core
// profile; this profile removes all the OpenGL API that was deprecated
// prior to the 3.2 version of the specification. If the realization is
// successful, this function will return false.
//
// If the underlying OpenGL implementation does not support core profiles,
// GDK will fall back to a pre-3.2 compatibility profile, and this function
// will return true.
//
// You can use the value returned by this function to decide which kind of
// OpenGL API to use, or whether to do extension discovery, or what kind of
// shader programs to load.
func (c glContext) IsLegacy() bool {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cret C.gboolean

	cret = C.gdk_gl_context_is_legacy(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// MakeCurrent makes the @context the current one.
func (c glContext) MakeCurrent() {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	C.gdk_gl_context_make_current(arg0)
}

// Realize realizes the given GLContext.
//
// It is safe to call this function on a realized GLContext.
func (c glContext) Realize() error {
	var arg0 *C.GdkGLContext

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))

	var cerr *C.GError

	C.gdk_gl_context_realize(arg0, cerr)

	var goerr error

	goerr = gerror.Take(unsafe.Pointer(cerr))

	return goerr
}

// SetDebugEnabled sets whether the GLContext should perform extra
// validations and run time checking. This is useful during development, but
// has additional overhead.
//
// The GLContext must not be realized or made current prior to calling this
// function.
func (c glContext) SetDebugEnabled(enabled bool) {
	var arg0 *C.GdkGLContext
	var arg1 C.gboolean

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	if enabled {
		arg1 = C.gboolean(1)
	}

	C.gdk_gl_context_set_debug_enabled(arg0, arg1)
}

// SetForwardCompatible sets whether the GLContext should be forward
// compatible.
//
// Forward compatibile contexts must not support OpenGL functionality that
// has been marked as deprecated in the requested version; non-forward
// compatible contexts, on the other hand, must support both deprecated and
// non deprecated functionality.
//
// The GLContext must not be realized or made current prior to calling this
// function.
func (c glContext) SetForwardCompatible(compatible bool) {
	var arg0 *C.GdkGLContext
	var arg1 C.gboolean

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	if compatible {
		arg1 = C.gboolean(1)
	}

	C.gdk_gl_context_set_forward_compatible(arg0, arg1)
}

// SetRequiredVersion sets the major and minor version of OpenGL to request.
//
// Setting @major and @minor to zero will use the default values.
//
// The GLContext must not be realized or made current prior to calling this
// function.
func (c glContext) SetRequiredVersion(major int, minor int) {
	var arg0 *C.GdkGLContext
	var arg1 C.int
	var arg2 C.int

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	arg1 = C.int(major)
	arg2 = C.int(minor)

	C.gdk_gl_context_set_required_version(arg0, arg1, arg2)
}

// SetUseES requests that GDK create a OpenGL ES context instead of an
// OpenGL one, if the platform and windowing system allows it.
//
// The @context must not have been realized.
//
// By default, GDK will attempt to automatically detect whether the
// underlying GL implementation is OpenGL or OpenGL ES once the @context is
// realized.
//
// You should check the return value of gdk_gl_context_get_use_es() after
// calling gdk_gl_context_realize() to decide whether to use the OpenGL or
// OpenGL ES API, extensions, or shaders.
func (c glContext) SetUseES(useEs int) {
	var arg0 *C.GdkGLContext
	var arg1 C.int

	arg0 = (*C.GdkGLContext)(unsafe.Pointer(c.Native()))
	arg1 = C.int(useEs)

	C.gdk_gl_context_set_use_es(arg0, arg1)
}

// Keymap: a Keymap defines the translation from keyboard state (including a
// hardware key, a modifier mask, and active keyboard group) to a keyval. This
// translation has two phases. The first phase is to determine the effective
// keyboard group and level for the keyboard state; the second phase is to look
// up the keycode/group/level triplet in the keymap and see what keyval it
// corresponds to.
type Keymap interface {
	gextras.Objector

	// AddVirtualModifiers maps the non-virtual modifiers (i.e Mod2, Mod3, ...)
	// which are set in @state to the virtual modifiers (i.e. Super, Hyper and
	// Meta) and set the corresponding bits in @state.
	//
	// GDK already does this before delivering key events, but for compatibility
	// reasons, it only sets the first virtual modifier it finds, whereas this
	// function sets all matching virtual modifiers.
	//
	// This function is useful when matching key events against accelerators.
	AddVirtualModifiers(state *ModifierType)
	// CapsLockState returns whether the Caps Lock modifer is locked.
	CapsLockState() bool
	// Direction returns the direction of effective layout of the keymap.
	Direction() pango.Direction
	// EntriesForKeycode returns the keyvals bound to @hardware_keycode. The Nth
	// KeymapKey in @keys is bound to the Nth keyval in @keyvals. Free the
	// returned arrays with g_free(). When a keycode is pressed by the user, the
	// keyval from this list of entries is selected by considering the effective
	// keyboard group and level. See gdk_keymap_translate_keyboard_state().
	EntriesForKeycode(hardwareKeycode uint) bool
	// EntriesForKeyval obtains a list of keycode/group/level combinations that
	// will generate @keyval. Groups and levels are two kinds of keyboard mode;
	// in general, the level determines whether the top or bottom symbol on a
	// key is used, and the group determines whether the left or right symbol is
	// used. On US keyboards, the shift key changes the keyboard level, and
	// there are no groups. A group switch key might convert a keyboard between
	// Hebrew to English modes, for example. EventKey contains a group field
	// that indicates the active keyboard group. The level is computed from the
	// modifier mask. The returned array should be freed with g_free().
	EntriesForKeyval(keyval uint) bool
	// ModifierMask returns the modifier mask the @keymap’s windowing system
	// backend uses for a particular purpose.
	//
	// Note that this function always returns real hardware modifiers, not
	// virtual ones (e.g. it will return K_MOD1_MASK rather than K_META_MASK if
	// the backend maps MOD1 to META), so there are use cases where the return
	// value of this function has to be transformed by
	// gdk_keymap_add_virtual_modifiers() in order to contain the expected
	// result.
	ModifierMask(intent ModifierIntent) ModifierType
	// ModifierState returns the current modifier state.
	ModifierState() uint
	// NumLockState returns whether the Num Lock modifer is locked.
	NumLockState() bool
	// ScrollLockState returns whether the Scroll Lock modifer is locked.
	ScrollLockState() bool
	// HaveBidiLayouts determines if keyboard layouts for both right-to-left and
	// left-to-right languages are in use.
	HaveBidiLayouts() bool
	// LookupKey looks up the keyval mapped to a keycode/group/level triplet. If
	// no keyval is bound to @key, returns 0. For normal user input, you want to
	// use gdk_keymap_translate_keyboard_state() instead of this function, since
	// the effective group/level may not be the same as the current keyboard
	// state.
	LookupKey(key *KeymapKey) uint
	// MapVirtualModifiers maps the virtual modifiers (i.e. Super, Hyper and
	// Meta) which are set in @state to their non-virtual counterparts (i.e.
	// Mod2, Mod3,...) and set the corresponding bits in @state.
	//
	// This function is useful when matching key events against accelerators.
	MapVirtualModifiers(state *ModifierType) bool
	// TranslateKeyboardState translates the contents of a EventKey into a
	// keyval, effective group, and level. Modifiers that affected the
	// translation and are thus unavailable for application use are returned in
	// @consumed_modifiers. See [Groups][key-group-explanation] for an
	// explanation of groups and levels. The @effective_group is the group that
	// was actually used for the translation; some keys such as Enter are not
	// affected by the active keyboard group. The @level is derived from @state.
	// For convenience, EventKey already contains the translated keyval, so this
	// function isn’t as useful as you might think.
	//
	// @consumed_modifiers gives modifiers that should be masked outfrom @state
	// when comparing this key press to a hot key. For instance, on a US
	// keyboard, the `plus` symbol is shifted, so when comparing a key press to
	// a `<Control>plus` accelerator `<Shift>` should be masked out.
	//
	//    // XXX Don’t do this XXX
	//    if (keyval == accel_keyval &&
	//        (event->state & ~consumed & ALL_ACCELS_MASK) == (accel_mods & ~consumed))
	//      // Accelerator was pressed
	//
	// However, this did not work if multi-modifier combinations were used in
	// the keymap, since, for instance, `<Control>` would be masked out even if
	// only `<Control><Alt>` was used in the keymap. To support this usage as
	// well as well as possible, all single modifier combinations that could
	// affect the key for any combination of modifiers will be returned in
	// @consumed_modifiers; multi-modifier combinations are returned only when
	// actually found in @state. When you store accelerators, you should always
	// store them with consumed modifiers removed. Store `<Control>plus`, not
	// `<Control><Shift>plus`,
	TranslateKeyboardState(hardwareKeycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumedModifiers ModifierType, ok bool)
}

// keymap implements the Keymap interface.
type keymap struct {
	gextras.Objector
}

var _ Keymap = (*keymap)(nil)

// WrapKeymap wraps a GObject to the right type. It is
// primarily used internally.
func WrapKeymap(obj *externglib.Object) Keymap {
	return Keymap{
		Objector: obj,
	}
}

func marshalKeymap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapKeymap(obj), nil
}

// AddVirtualModifiers maps the non-virtual modifiers (i.e Mod2, Mod3, ...)
// which are set in @state to the virtual modifiers (i.e. Super, Hyper and
// Meta) and set the corresponding bits in @state.
//
// GDK already does this before delivering key events, but for compatibility
// reasons, it only sets the first virtual modifier it finds, whereas this
// function sets all matching virtual modifiers.
//
// This function is useful when matching key events against accelerators.
func (k keymap) AddVirtualModifiers(state *ModifierType) {
	var arg0 *C.GdkKeymap
	var arg1 *C.GdkModifierType

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = (*C.GdkModifierType)(state)

	C.gdk_keymap_add_virtual_modifiers(arg0, arg1)
}

// CapsLockState returns whether the Caps Lock modifer is locked.
func (k keymap) CapsLockState() bool {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.gboolean

	cret = C.gdk_keymap_get_caps_lock_state(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// Direction returns the direction of effective layout of the keymap.
func (k keymap) Direction() pango.Direction {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.PangoDirection

	cret = C.gdk_keymap_get_direction(arg0)

	var direction pango.Direction

	direction = pango.Direction(cret)

	return direction
}

// EntriesForKeycode returns the keyvals bound to @hardware_keycode. The Nth
// KeymapKey in @keys is bound to the Nth keyval in @keyvals. Free the
// returned arrays with g_free(). When a keycode is pressed by the user, the
// keyval from this list of entries is selected by considering the effective
// keyboard group and level. See gdk_keymap_translate_keyboard_state().
func (k keymap) EntriesForKeycode(hardwareKeycode uint) bool {
	var arg0 *C.GdkKeymap
	var arg1 C.guint

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = C.guint(hardwareKeycode)

	var cret C.gboolean

	cret = C.gdk_keymap_get_entries_for_keycode(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// EntriesForKeyval obtains a list of keycode/group/level combinations that
// will generate @keyval. Groups and levels are two kinds of keyboard mode;
// in general, the level determines whether the top or bottom symbol on a
// key is used, and the group determines whether the left or right symbol is
// used. On US keyboards, the shift key changes the keyboard level, and
// there are no groups. A group switch key might convert a keyboard between
// Hebrew to English modes, for example. EventKey contains a group field
// that indicates the active keyboard group. The level is computed from the
// modifier mask. The returned array should be freed with g_free().
func (k keymap) EntriesForKeyval(keyval uint) bool {
	var arg0 *C.GdkKeymap
	var arg1 C.guint

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = C.guint(keyval)

	var cret C.gboolean

	cret = C.gdk_keymap_get_entries_for_keyval(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ModifierMask returns the modifier mask the @keymap’s windowing system
// backend uses for a particular purpose.
//
// Note that this function always returns real hardware modifiers, not
// virtual ones (e.g. it will return K_MOD1_MASK rather than K_META_MASK if
// the backend maps MOD1 to META), so there are use cases where the return
// value of this function has to be transformed by
// gdk_keymap_add_virtual_modifiers() in order to contain the expected
// result.
func (k keymap) ModifierMask(intent ModifierIntent) ModifierType {
	var arg0 *C.GdkKeymap
	var arg1 C.GdkModifierIntent

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = (C.GdkModifierIntent)(intent)

	var cret C.GdkModifierType

	cret = C.gdk_keymap_get_modifier_mask(arg0, arg1)

	var modifierType ModifierType

	modifierType = ModifierType(cret)

	return modifierType
}

// ModifierState returns the current modifier state.
func (k keymap) ModifierState() uint {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.guint

	cret = C.gdk_keymap_get_modifier_state(arg0)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// NumLockState returns whether the Num Lock modifer is locked.
func (k keymap) NumLockState() bool {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.gboolean

	cret = C.gdk_keymap_get_num_lock_state(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ScrollLockState returns whether the Scroll Lock modifer is locked.
func (k keymap) ScrollLockState() bool {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.gboolean

	cret = C.gdk_keymap_get_scroll_lock_state(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// HaveBidiLayouts determines if keyboard layouts for both right-to-left and
// left-to-right languages are in use.
func (k keymap) HaveBidiLayouts() bool {
	var arg0 *C.GdkKeymap

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))

	var cret C.gboolean

	cret = C.gdk_keymap_have_bidi_layouts(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// LookupKey looks up the keyval mapped to a keycode/group/level triplet. If
// no keyval is bound to @key, returns 0. For normal user input, you want to
// use gdk_keymap_translate_keyboard_state() instead of this function, since
// the effective group/level may not be the same as the current keyboard
// state.
func (k keymap) LookupKey(key *KeymapKey) uint {
	var arg0 *C.GdkKeymap
	var arg1 *C.GdkKeymapKey

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = (*C.GdkKeymapKey)(unsafe.Pointer(key.Native()))

	var cret C.guint

	cret = C.gdk_keymap_lookup_key(arg0, arg1)

	var guint uint

	guint = (uint)(cret)

	return guint
}

// MapVirtualModifiers maps the virtual modifiers (i.e. Super, Hyper and
// Meta) which are set in @state to their non-virtual counterparts (i.e.
// Mod2, Mod3,...) and set the corresponding bits in @state.
//
// This function is useful when matching key events against accelerators.
func (k keymap) MapVirtualModifiers(state *ModifierType) bool {
	var arg0 *C.GdkKeymap
	var arg1 *C.GdkModifierType

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = (*C.GdkModifierType)(state)

	var cret C.gboolean

	cret = C.gdk_keymap_map_virtual_modifiers(arg0, arg1)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// TranslateKeyboardState translates the contents of a EventKey into a
// keyval, effective group, and level. Modifiers that affected the
// translation and are thus unavailable for application use are returned in
// @consumed_modifiers. See [Groups][key-group-explanation] for an
// explanation of groups and levels. The @effective_group is the group that
// was actually used for the translation; some keys such as Enter are not
// affected by the active keyboard group. The @level is derived from @state.
// For convenience, EventKey already contains the translated keyval, so this
// function isn’t as useful as you might think.
//
// @consumed_modifiers gives modifiers that should be masked outfrom @state
// when comparing this key press to a hot key. For instance, on a US
// keyboard, the `plus` symbol is shifted, so when comparing a key press to
// a `<Control>plus` accelerator `<Shift>` should be masked out.
//
//    // XXX Don’t do this XXX
//    if (keyval == accel_keyval &&
//        (event->state & ~consumed & ALL_ACCELS_MASK) == (accel_mods & ~consumed))
//      // Accelerator was pressed
//
// However, this did not work if multi-modifier combinations were used in
// the keymap, since, for instance, `<Control>` would be masked out even if
// only `<Control><Alt>` was used in the keymap. To support this usage as
// well as well as possible, all single modifier combinations that could
// affect the key for any combination of modifiers will be returned in
// @consumed_modifiers; multi-modifier combinations are returned only when
// actually found in @state. When you store accelerators, you should always
// store them with consumed modifiers removed. Store `<Control>plus`, not
// `<Control><Shift>plus`,
func (k keymap) TranslateKeyboardState(hardwareKeycode uint, state ModifierType, group int) (keyval uint, effectiveGroup int, level int, consumedModifiers ModifierType, ok bool) {
	var arg0 *C.GdkKeymap
	var arg1 C.guint
	var arg2 C.GdkModifierType
	var arg3 C.gint

	arg0 = (*C.GdkKeymap)(unsafe.Pointer(k.Native()))
	arg1 = C.guint(hardwareKeycode)
	arg2 = (C.GdkModifierType)(state)
	arg3 = C.gint(group)

	var arg4 C.guint
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.GdkModifierType
	var cret C.gboolean

	cret = C.gdk_keymap_translate_keyboard_state(arg0, arg1, arg2, arg3, &arg4, &arg5, &arg6, &arg7)

	var keyval uint
	var effectiveGroup int
	var level int
	var consumedModifiers ModifierType
	var ok bool

	keyval = (uint)(arg4)
	effectiveGroup = (int)(arg5)
	level = (int)(arg6)
	consumedModifiers = ModifierType(arg7)
	if cret {
		ok = true
	}

	return keyval, effectiveGroup, level, consumedModifiers, ok
}

// Screen objects are the GDK representation of the screen on which windows can
// be displayed and on which the pointer moves. X originally identified screens
// with physical screens, but nowadays it is more common to have a single Screen
// which combines several physical monitors (see gdk_screen_get_n_monitors()).
//
// GdkScreen is used throughout GDK and GTK+ to specify which screen the top
// level windows are to be displayed on. it is also used to query the screen
// specification and default settings such as the default visual
// (gdk_screen_get_system_visual()), the dimensions of the physical monitors
// (gdk_screen_get_monitor_geometry()), etc.
type Screen interface {
	gextras.Objector

	// ActiveWindow returns the screen’s currently active window.
	//
	// On X11, this is done by inspecting the _NET_ACTIVE_WINDOW property on the
	// root window, as described in the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec). If there is no currently
	// currently active window, or the window manager does not support the
	// _NET_ACTIVE_WINDOW hint, this function returns nil.
	//
	// On other platforms, this function may return nil, depending on whether it
	// is implementable on that platform.
	//
	// The returned window should be unrefed using g_object_unref() when no
	// longer needed.
	ActiveWindow() Window
	// Display gets the display to which the @screen belongs.
	Display() Display
	// FontOptions gets any options previously set with
	// gdk_screen_set_font_options().
	FontOptions() *cairo.FontOptions
	// Height gets the height of @screen in pixels. The returned size is in
	// ”application pixels”, not in ”device pixels” (see
	// gdk_screen_get_monitor_scale_factor()).
	Height() int
	// HeightMm returns the height of @screen in millimeters.
	//
	// Note that this value is somewhat ill-defined when the screen has multiple
	// monitors of different resolution. It is recommended to use the monitor
	// dimensions instead.
	HeightMm() int
	// MonitorAtPoint returns the monitor number in which the point (@x,@y) is
	// located.
	MonitorAtPoint(x int, y int) int
	// MonitorAtWindow returns the number of the monitor in which the largest
	// area of the bounding rectangle of @window resides.
	MonitorAtWindow(window Window) int
	// MonitorGeometry retrieves the Rectangle representing the size and
	// position of the individual monitor within the entire screen area. The
	// returned geometry is in ”application pixels”, not in ”device pixels” (see
	// gdk_screen_get_monitor_scale_factor()).
	//
	// Monitor numbers start at 0. To obtain the number of monitors of @screen,
	// use gdk_screen_get_n_monitors().
	//
	// Note that the size of the entire screen area can be retrieved via
	// gdk_screen_get_width() and gdk_screen_get_height().
	MonitorGeometry(monitorNum int) Rectangle
	// MonitorHeightMm gets the height in millimeters of the specified monitor.
	MonitorHeightMm(monitorNum int) int
	// MonitorPlugName returns the output name of the specified monitor. Usually
	// something like VGA, DVI, or TV, not the actual product name of the
	// display device.
	MonitorPlugName(monitorNum int) string
	// MonitorScaleFactor returns the internal scale factor that maps from
	// monitor coordinates to the actual device pixels. On traditional systems
	// this is 1, but on very high density outputs this can be a higher value
	// (often 2).
	//
	// This can be used if you want to create pixel based data for a particular
	// monitor, but most of the time you’re drawing to a window where it is
	// better to use gdk_window_get_scale_factor() instead.
	MonitorScaleFactor(monitorNum int) int
	// MonitorWidthMm gets the width in millimeters of the specified monitor, if
	// available.
	MonitorWidthMm(monitorNum int) int
	// MonitorWorkarea retrieves the Rectangle representing the size and
	// position of the “work area” on a monitor within the entire screen area.
	// The returned geometry is in ”application pixels”, not in ”device pixels”
	// (see gdk_screen_get_monitor_scale_factor()).
	//
	// The work area should be considered when positioning menus and similar
	// popups, to avoid placing them below panels, docks or other desktop
	// components.
	//
	// Note that not all backends may have a concept of workarea. This function
	// will return the monitor geometry if a workarea is not available, or does
	// not apply.
	//
	// Monitor numbers start at 0. To obtain the number of monitors of @screen,
	// use gdk_screen_get_n_monitors().
	MonitorWorkarea(monitorNum int) Rectangle
	// NMonitors returns the number of monitors which @screen consists of.
	NMonitors() int
	// Number gets the index of @screen among the screens in the display to
	// which it belongs. (See gdk_screen_get_display())
	Number() int
	// PrimaryMonitor gets the primary monitor for @screen. The primary monitor
	// is considered the monitor where the “main desktop” lives. While normal
	// application windows typically allow the window manager to place the
	// windows, specialized desktop applications such as panels should place
	// themselves on the primary monitor.
	//
	// If no primary monitor is configured by the user, the return value will be
	// 0, defaulting to the first monitor.
	PrimaryMonitor() int
	// Resolution gets the resolution for font handling on the screen; see
	// gdk_screen_set_resolution() for full details.
	Resolution() float64
	// RGBAVisual gets a visual to use for creating windows with an alpha
	// channel. The windowing system on which GTK+ is running may not support
	// this capability, in which case nil will be returned. Even if a non-nil
	// value is returned, its possible that the window’s alpha channel won’t be
	// honored when displaying the window on the screen: in particular, for X an
	// appropriate windowing manager and compositing manager must be running to
	// provide appropriate display.
	//
	// This functionality is not implemented in the Windows backend.
	//
	// For setting an overall opacity for a top-level window, see
	// gdk_window_set_opacity().
	RGBAVisual() Visual
	// RootWindow gets the root window of @screen.
	RootWindow() Window
	// Setting retrieves a desktop-wide setting such as double-click time for
	// the Screen @screen.
	//
	// FIXME needs a list of valid settings here, or a link to more information.
	Setting(name string, value **externglib.Value) bool
	// SystemVisual: get the system’s default visual for @screen. This is the
	// visual for the root window of the display. The return value should not be
	// freed.
	SystemVisual() Visual
	// ToplevelWindows obtains a list of all toplevel windows known to GDK on
	// the screen @screen. A toplevel window is a child of the root window (see
	// gdk_get_default_root_window()).
	//
	// The returned list should be freed with g_list_free(), but its elements
	// need not be freed.
	ToplevelWindows() *glib.List
	// Width gets the width of @screen in pixels. The returned size is in
	// ”application pixels”, not in ”device pixels” (see
	// gdk_screen_get_monitor_scale_factor()).
	Width() int
	// WidthMm gets the width of @screen in millimeters.
	//
	// Note that this value is somewhat ill-defined when the screen has multiple
	// monitors of different resolution. It is recommended to use the monitor
	// dimensions instead.
	WidthMm() int
	// WindowStack returns a #GList of Windows representing the current window
	// stack.
	//
	// On X11, this is done by inspecting the _NET_CLIENT_LIST_STACKING property
	// on the root window, as described in the Extended Window Manager Hints
	// (http://www.freedesktop.org/Standards/wm-spec). If the window manager
	// does not support the _NET_CLIENT_LIST_STACKING hint, this function
	// returns nil.
	//
	// On other platforms, this function may return nil, depending on whether it
	// is implementable on that platform.
	//
	// The returned list is newly allocated and owns references to the windows
	// it contains, so it should be freed using g_list_free() and its windows
	// unrefed using g_object_unref() when no longer needed.
	WindowStack() *glib.List
	// IsComposited returns whether windows with an RGBA visual can reasonably
	// be expected to have their alpha channel drawn correctly on the screen.
	//
	// On X11 this function returns whether a compositing manager is compositing
	// @screen.
	IsComposited() bool
	// ListVisuals lists the available visuals for the specified @screen. A
	// visual describes a hardware image data format. For example, a visual
	// might support 24-bit color, or 8-bit color, and might expect pixels to be
	// in a certain format.
	//
	// Call g_list_free() on the return value when you’re finished with it.
	ListVisuals() *glib.List
	// MakeDisplayName determines the name to pass to gdk_display_open() to get
	// a Display with this screen as the default screen.
	MakeDisplayName() string
	// SetFontOptions sets the default font options for the screen. These
	// options will be set on any Context’s newly created with
	// gdk_pango_context_get_for_screen(). Changing the default set of font
	// options does not affect contexts that have already been created.
	SetFontOptions(options *cairo.FontOptions)
	// SetResolution sets the resolution for font handling on the screen. This
	// is a scale factor between points specified in a FontDescription and cairo
	// units. The default value is 96, meaning that a 10 point font will be 13
	// units high. (10 * 96. / 72. = 13.3).
	SetResolution(dpi float64)
}

// screen implements the Screen interface.
type screen struct {
	gextras.Objector
}

var _ Screen = (*screen)(nil)

// WrapScreen wraps a GObject to the right type. It is
// primarily used internally.
func WrapScreen(obj *externglib.Object) Screen {
	return Screen{
		Objector: obj,
	}
}

func marshalScreen(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapScreen(obj), nil
}

// ActiveWindow returns the screen’s currently active window.
//
// On X11, this is done by inspecting the _NET_ACTIVE_WINDOW property on the
// root window, as described in the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec). If there is no currently
// currently active window, or the window manager does not support the
// _NET_ACTIVE_WINDOW hint, this function returns nil.
//
// On other platforms, this function may return nil, depending on whether it
// is implementable on that platform.
//
// The returned window should be unrefed using g_object_unref() when no
// longer needed.
func (s screen) ActiveWindow() Window {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_screen_get_active_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// Display gets the display to which the @screen belongs.
func (s screen) Display() Display {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_screen_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// FontOptions gets any options previously set with
// gdk_screen_set_font_options().
func (s screen) FontOptions() *cairo.FontOptions {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.cairo_font_options_t

	cret = C.gdk_screen_get_font_options(arg0)

	var fontOptions *cairo.FontOptions

	fontOptions = cairo.WrapFontOptions(unsafe.Pointer(cret))

	return fontOptions
}

// Height gets the height of @screen in pixels. The returned size is in
// ”application pixels”, not in ”device pixels” (see
// gdk_screen_get_monitor_scale_factor()).
func (s screen) Height() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_height(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// HeightMm returns the height of @screen in millimeters.
//
// Note that this value is somewhat ill-defined when the screen has multiple
// monitors of different resolution. It is recommended to use the monitor
// dimensions instead.
func (s screen) HeightMm() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_height_mm(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorAtPoint returns the monitor number in which the point (@x,@y) is
// located.
func (s screen) MonitorAtPoint(x int, y int) int {
	var arg0 *C.GdkScreen
	var arg1 C.gint
	var arg2 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(x)
	arg2 = C.gint(y)

	var cret C.gint

	cret = C.gdk_screen_get_monitor_at_point(arg0, arg1, arg2)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorAtWindow returns the number of the monitor in which the largest
// area of the bounding rectangle of @window resides.
func (s screen) MonitorAtWindow(window Window) int {
	var arg0 *C.GdkScreen
	var arg1 *C.GdkWindow

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = (*C.GdkWindow)(unsafe.Pointer(window.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_monitor_at_window(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorGeometry retrieves the Rectangle representing the size and
// position of the individual monitor within the entire screen area. The
// returned geometry is in ”application pixels”, not in ”device pixels” (see
// gdk_screen_get_monitor_scale_factor()).
//
// Monitor numbers start at 0. To obtain the number of monitors of @screen,
// use gdk_screen_get_n_monitors().
//
// Note that the size of the entire screen area can be retrieved via
// gdk_screen_get_width() and gdk_screen_get_height().
func (s screen) MonitorGeometry(monitorNum int) Rectangle {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var dest Rectangle

	C.gdk_screen_get_monitor_geometry(arg0, arg1, (*C.GdkRectangle)(unsafe.Pointer(&dest)))

	return dest
}

// MonitorHeightMm gets the height in millimeters of the specified monitor.
func (s screen) MonitorHeightMm(monitorNum int) int {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var cret C.gint

	cret = C.gdk_screen_get_monitor_height_mm(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorPlugName returns the output name of the specified monitor. Usually
// something like VGA, DVI, or TV, not the actual product name of the
// display device.
func (s screen) MonitorPlugName(monitorNum int) string {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var cret *C.gchar

	cret = C.gdk_screen_get_monitor_plug_name(arg0, arg1)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// MonitorScaleFactor returns the internal scale factor that maps from
// monitor coordinates to the actual device pixels. On traditional systems
// this is 1, but on very high density outputs this can be a higher value
// (often 2).
//
// This can be used if you want to create pixel based data for a particular
// monitor, but most of the time you’re drawing to a window where it is
// better to use gdk_window_get_scale_factor() instead.
func (s screen) MonitorScaleFactor(monitorNum int) int {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var cret C.gint

	cret = C.gdk_screen_get_monitor_scale_factor(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorWidthMm gets the width in millimeters of the specified monitor, if
// available.
func (s screen) MonitorWidthMm(monitorNum int) int {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var cret C.gint

	cret = C.gdk_screen_get_monitor_width_mm(arg0, arg1)

	var gint int

	gint = (int)(cret)

	return gint
}

// MonitorWorkarea retrieves the Rectangle representing the size and
// position of the “work area” on a monitor within the entire screen area.
// The returned geometry is in ”application pixels”, not in ”device pixels”
// (see gdk_screen_get_monitor_scale_factor()).
//
// The work area should be considered when positioning menus and similar
// popups, to avoid placing them below panels, docks or other desktop
// components.
//
// Note that not all backends may have a concept of workarea. This function
// will return the monitor geometry if a workarea is not available, or does
// not apply.
//
// Monitor numbers start at 0. To obtain the number of monitors of @screen,
// use gdk_screen_get_n_monitors().
func (s screen) MonitorWorkarea(monitorNum int) Rectangle {
	var arg0 *C.GdkScreen
	var arg1 C.gint

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gint(monitorNum)

	var dest Rectangle

	C.gdk_screen_get_monitor_workarea(arg0, arg1, (*C.GdkRectangle)(unsafe.Pointer(&dest)))

	return dest
}

// NMonitors returns the number of monitors which @screen consists of.
func (s screen) NMonitors() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_n_monitors(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Number gets the index of @screen among the screens in the display to
// which it belongs. (See gdk_screen_get_display())
func (s screen) Number() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_number(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// PrimaryMonitor gets the primary monitor for @screen. The primary monitor
// is considered the monitor where the “main desktop” lives. While normal
// application windows typically allow the window manager to place the
// windows, specialized desktop applications such as panels should place
// themselves on the primary monitor.
//
// If no primary monitor is configured by the user, the return value will be
// 0, defaulting to the first monitor.
func (s screen) PrimaryMonitor() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_primary_monitor(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Resolution gets the resolution for font handling on the screen; see
// gdk_screen_set_resolution() for full details.
func (s screen) Resolution() float64 {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gdouble

	cret = C.gdk_screen_get_resolution(arg0)

	var gdouble float64

	gdouble = (float64)(cret)

	return gdouble
}

// RGBAVisual gets a visual to use for creating windows with an alpha
// channel. The windowing system on which GTK+ is running may not support
// this capability, in which case nil will be returned. Even if a non-nil
// value is returned, its possible that the window’s alpha channel won’t be
// honored when displaying the window on the screen: in particular, for X an
// appropriate windowing manager and compositing manager must be running to
// provide appropriate display.
//
// This functionality is not implemented in the Windows backend.
//
// For setting an overall opacity for a top-level window, see
// gdk_window_set_opacity().
func (s screen) RGBAVisual() Visual {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GdkVisual

	cret = C.gdk_screen_get_rgba_visual(arg0)

	var visual Visual

	visual = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Visual)

	return visual
}

// RootWindow gets the root window of @screen.
func (s screen) RootWindow() Window {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GdkWindow

	cret = C.gdk_screen_get_root_window(arg0)

	var window Window

	window = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Window)

	return window
}

// Setting retrieves a desktop-wide setting such as double-click time for
// the Screen @screen.
//
// FIXME needs a list of valid settings here, or a link to more information.
func (s screen) Setting(name string, value **externglib.Value) bool {
	var arg0 *C.GdkScreen
	var arg1 *C.gchar
	var arg2 *C.GValue

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GValue)(value.GValue)

	var cret C.gboolean

	cret = C.gdk_screen_get_setting(arg0, arg1, arg2)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// SystemVisual: get the system’s default visual for @screen. This is the
// visual for the root window of the display. The return value should not be
// freed.
func (s screen) SystemVisual() Visual {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GdkVisual

	cret = C.gdk_screen_get_system_visual(arg0)

	var visual Visual

	visual = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Visual)

	return visual
}

// ToplevelWindows obtains a list of all toplevel windows known to GDK on
// the screen @screen. A toplevel window is a child of the root window (see
// gdk_get_default_root_window()).
//
// The returned list should be freed with g_list_free(), but its elements
// need not be freed.
func (s screen) ToplevelWindows() *glib.List {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GList

	cret = C.gdk_screen_get_toplevel_windows(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// Width gets the width of @screen in pixels. The returned size is in
// ”application pixels”, not in ”device pixels” (see
// gdk_screen_get_monitor_scale_factor()).
func (s screen) Width() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_width(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// WidthMm gets the width of @screen in millimeters.
//
// Note that this value is somewhat ill-defined when the screen has multiple
// monitors of different resolution. It is recommended to use the monitor
// dimensions instead.
func (s screen) WidthMm() int {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gint

	cret = C.gdk_screen_get_width_mm(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// WindowStack returns a #GList of Windows representing the current window
// stack.
//
// On X11, this is done by inspecting the _NET_CLIENT_LIST_STACKING property
// on the root window, as described in the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec). If the window manager
// does not support the _NET_CLIENT_LIST_STACKING hint, this function
// returns nil.
//
// On other platforms, this function may return nil, depending on whether it
// is implementable on that platform.
//
// The returned list is newly allocated and owns references to the windows
// it contains, so it should be freed using g_list_free() and its windows
// unrefed using g_object_unref() when no longer needed.
func (s screen) WindowStack() *glib.List {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GList

	cret = C.gdk_screen_get_window_stack(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// IsComposited returns whether windows with an RGBA visual can reasonably
// be expected to have their alpha channel drawn correctly on the screen.
//
// On X11 this function returns whether a compositing manager is compositing
// @screen.
func (s screen) IsComposited() bool {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret C.gboolean

	cret = C.gdk_screen_is_composited(arg0)

	var ok bool

	if cret {
		ok = true
	}

	return ok
}

// ListVisuals lists the available visuals for the specified @screen. A
// visual describes a hardware image data format. For example, a visual
// might support 24-bit color, or 8-bit color, and might expect pixels to be
// in a certain format.
//
// Call g_list_free() on the return value when you’re finished with it.
func (s screen) ListVisuals() *glib.List {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.GList

	cret = C.gdk_screen_list_visuals(arg0)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// MakeDisplayName determines the name to pass to gdk_display_open() to get
// a Display with this screen as the default screen.
func (s screen) MakeDisplayName() string {
	var arg0 *C.GdkScreen

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))

	var cret *C.gchar

	cret = C.gdk_screen_make_display_name(arg0)

	var utf8 string

	utf8 = C.GoString(cret)
	defer C.free(unsafe.Pointer(cret))

	return utf8
}

// SetFontOptions sets the default font options for the screen. These
// options will be set on any Context’s newly created with
// gdk_pango_context_get_for_screen(). Changing the default set of font
// options does not affect contexts that have already been created.
func (s screen) SetFontOptions(options *cairo.FontOptions) {
	var arg0 *C.GdkScreen
	var arg1 *C.cairo_font_options_t

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

	C.gdk_screen_set_font_options(arg0, arg1)
}

// SetResolution sets the resolution for font handling on the screen. This
// is a scale factor between points specified in a FontDescription and cairo
// units. The default value is 96, meaning that a 10 point font will be 13
// units high. (10 * 96. / 72. = 13.3).
func (s screen) SetResolution(dpi float64) {
	var arg0 *C.GdkScreen
	var arg1 C.gdouble

	arg0 = (*C.GdkScreen)(unsafe.Pointer(s.Native()))
	arg1 = C.gdouble(dpi)

	C.gdk_screen_set_resolution(arg0, arg1)
}

// Seat: the Seat object represents a collection of input devices that belong to
// a user.
type Seat interface {
	gextras.Objector

	// Capabilities returns the capabilities this Seat currently has.
	Capabilities() SeatCapabilities
	// Display returns the Display this seat belongs to.
	Display() Display
	// Keyboard returns the master device that routes keyboard events.
	Keyboard() Device
	// Pointer returns the master device that routes pointer events.
	Pointer() Device
	// Slaves returns the slave devices that match the given capabilities.
	Slaves(capabilities SeatCapabilities) *glib.List
	// Grab grabs the seat so that all events corresponding to the given
	// @capabilities are passed to this application until the seat is ungrabbed
	// with gdk_seat_ungrab(), or the window becomes hidden. This overrides any
	// previous grab on the seat by this client.
	//
	// As a rule of thumb, if a grab is desired over
	// GDK_SEAT_CAPABILITY_POINTER, all other "pointing" capabilities (eg.
	// GDK_SEAT_CAPABILITY_TOUCH) should be grabbed too, so the user is able to
	// interact with all of those while the grab holds, you should thus use
	// GDK_SEAT_CAPABILITY_ALL_POINTING most commonly.
	//
	// Grabs are used for operations which need complete control over the events
	// corresponding to the given capabilities. For example in GTK+ this is used
	// for Drag and Drop operations, popup menus and such.
	//
	// Note that if the event mask of a Window has selected both button press
	// and button release events, or touch begin and touch end, then a press
	// event will cause an automatic grab until the button is released,
	// equivalent to a grab on the window with @owner_events set to true. This
	// is done because most applications expect to receive paired press and
	// release events.
	//
	// If you set up anything at the time you take the grab that needs to be
	// cleaned up when the grab ends, you should handle the EventGrabBroken
	// events that are emitted when the grab ends unvoluntarily.
	Grab() GrabStatus
	// Ungrab releases a grab added through gdk_seat_grab().
	Ungrab()
}

// seat implements the Seat interface.
type seat struct {
	gextras.Objector
}

var _ Seat = (*seat)(nil)

// WrapSeat wraps a GObject to the right type. It is
// primarily used internally.
func WrapSeat(obj *externglib.Object) Seat {
	return Seat{
		Objector: obj,
	}
}

func marshalSeat(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapSeat(obj), nil
}

// Capabilities returns the capabilities this Seat currently has.
func (s seat) Capabilities() SeatCapabilities {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	var cret C.GdkSeatCapabilities

	cret = C.gdk_seat_get_capabilities(arg0)

	var seatCapabilities SeatCapabilities

	seatCapabilities = SeatCapabilities(cret)

	return seatCapabilities
}

// Display returns the Display this seat belongs to.
func (s seat) Display() Display {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDisplay

	cret = C.gdk_seat_get_display(arg0)

	var display Display

	display = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Display)

	return display
}

// Keyboard returns the master device that routes keyboard events.
func (s seat) Keyboard() Device {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDevice

	cret = C.gdk_seat_get_keyboard(arg0)

	var device Device

	device = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Device)

	return device
}

// Pointer returns the master device that routes pointer events.
func (s seat) Pointer() Device {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	var cret *C.GdkDevice

	cret = C.gdk_seat_get_pointer(arg0)

	var device Device

	device = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Device)

	return device
}

// Slaves returns the slave devices that match the given capabilities.
func (s seat) Slaves(capabilities SeatCapabilities) *glib.List {
	var arg0 *C.GdkSeat
	var arg1 C.GdkSeatCapabilities

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))
	arg1 = (C.GdkSeatCapabilities)(capabilities)

	var cret *C.GList

	cret = C.gdk_seat_get_slaves(arg0, arg1)

	var list *glib.List

	list = glib.WrapList(unsafe.Pointer(cret))
	runtime.SetFinalizer(list, func(v *glib.List) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return list
}

// Grab grabs the seat so that all events corresponding to the given
// @capabilities are passed to this application until the seat is ungrabbed
// with gdk_seat_ungrab(), or the window becomes hidden. This overrides any
// previous grab on the seat by this client.
//
// As a rule of thumb, if a grab is desired over
// GDK_SEAT_CAPABILITY_POINTER, all other "pointing" capabilities (eg.
// GDK_SEAT_CAPABILITY_TOUCH) should be grabbed too, so the user is able to
// interact with all of those while the grab holds, you should thus use
// GDK_SEAT_CAPABILITY_ALL_POINTING most commonly.
//
// Grabs are used for operations which need complete control over the events
// corresponding to the given capabilities. For example in GTK+ this is used
// for Drag and Drop operations, popup menus and such.
//
// Note that if the event mask of a Window has selected both button press
// and button release events, or touch begin and touch end, then a press
// event will cause an automatic grab until the button is released,
// equivalent to a grab on the window with @owner_events set to true. This
// is done because most applications expect to receive paired press and
// release events.
//
// If you set up anything at the time you take the grab that needs to be
// cleaned up when the grab ends, you should handle the EventGrabBroken
// events that are emitted when the grab ends unvoluntarily.
func (s seat) Grab() GrabStatus {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	var cret C.GdkGrabStatus

	cret = C.gdk_seat_grab(arg0)

	var grabStatus GrabStatus

	grabStatus = GrabStatus(cret)

	return grabStatus
}

// Ungrab releases a grab added through gdk_seat_grab().
func (s seat) Ungrab() {
	var arg0 *C.GdkSeat

	arg0 = (*C.GdkSeat)(unsafe.Pointer(s.Native()))

	C.gdk_seat_ungrab(arg0)
}

// Visual: a Visual contains information about a particular visual.
type Visual interface {
	gextras.Objector

	// BitsPerRGB returns the number of significant bits per red, green and blue
	// value.
	//
	// Not all GDK backend provide a meaningful value for this function.
	BitsPerRGB() int
	// BluePixelDetails obtains values that are needed to calculate blue pixel
	// values in TrueColor and DirectColor. The “mask” is the significant bits
	// within the pixel. The “shift” is the number of bits left we must shift a
	// primary for it to be in position (according to the "mask"). Finally,
	// "precision" refers to how much precision the pixel value contains for a
	// particular primary.
	BluePixelDetails() (mask uint32, shift int, precision int)
	// ByteOrder returns the byte order of this visual.
	//
	// The information returned by this function is only relevant when working
	// with XImages, and not all backends return meaningful information for
	// this.
	ByteOrder() ByteOrder
	// ColormapSize returns the size of a colormap for this visual.
	//
	// You have to use platform-specific APIs to manipulate colormaps.
	ColormapSize() int
	// Depth returns the bit depth of this visual.
	Depth() int
	// GreenPixelDetails obtains values that are needed to calculate green pixel
	// values in TrueColor and DirectColor. The “mask” is the significant bits
	// within the pixel. The “shift” is the number of bits left we must shift a
	// primary for it to be in position (according to the "mask"). Finally,
	// "precision" refers to how much precision the pixel value contains for a
	// particular primary.
	GreenPixelDetails() (mask uint32, shift int, precision int)
	// RedPixelDetails obtains values that are needed to calculate red pixel
	// values in TrueColor and DirectColor. The “mask” is the significant bits
	// within the pixel. The “shift” is the number of bits left we must shift a
	// primary for it to be in position (according to the "mask"). Finally,
	// "precision" refers to how much precision the pixel value contains for a
	// particular primary.
	RedPixelDetails() (mask uint32, shift int, precision int)
	// Screen gets the screen to which this visual belongs
	Screen() Screen
	// VisualType returns the type of visual this is (PseudoColor, TrueColor,
	// etc).
	VisualType() VisualType
}

// visual implements the Visual interface.
type visual struct {
	gextras.Objector
}

var _ Visual = (*visual)(nil)

// WrapVisual wraps a GObject to the right type. It is
// primarily used internally.
func WrapVisual(obj *externglib.Object) Visual {
	return Visual{
		Objector: obj,
	}
}

func marshalVisual(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapVisual(obj), nil
}

// BitsPerRGB returns the number of significant bits per red, green and blue
// value.
//
// Not all GDK backend provide a meaningful value for this function.
func (v visual) BitsPerRGB() int {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret C.gint

	cret = C.gdk_visual_get_bits_per_rgb(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// BluePixelDetails obtains values that are needed to calculate blue pixel
// values in TrueColor and DirectColor. The “mask” is the significant bits
// within the pixel. The “shift” is the number of bits left we must shift a
// primary for it to be in position (according to the "mask"). Finally,
// "precision" refers to how much precision the pixel value contains for a
// particular primary.
func (v visual) BluePixelDetails() (mask uint32, shift int, precision int) {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var arg1 C.guint32
	var arg2 C.gint
	var arg3 C.gint

	C.gdk_visual_get_blue_pixel_details(arg0, &arg1, &arg2, &arg3)

	var mask uint32
	var shift int
	var precision int

	mask = (uint32)(arg1)
	shift = (int)(arg2)
	precision = (int)(arg3)

	return mask, shift, precision
}

// ByteOrder returns the byte order of this visual.
//
// The information returned by this function is only relevant when working
// with XImages, and not all backends return meaningful information for
// this.
func (v visual) ByteOrder() ByteOrder {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret C.GdkByteOrder

	cret = C.gdk_visual_get_byte_order(arg0)

	var byteOrder ByteOrder

	byteOrder = ByteOrder(cret)

	return byteOrder
}

// ColormapSize returns the size of a colormap for this visual.
//
// You have to use platform-specific APIs to manipulate colormaps.
func (v visual) ColormapSize() int {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret C.gint

	cret = C.gdk_visual_get_colormap_size(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// Depth returns the bit depth of this visual.
func (v visual) Depth() int {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret C.gint

	cret = C.gdk_visual_get_depth(arg0)

	var gint int

	gint = (int)(cret)

	return gint
}

// GreenPixelDetails obtains values that are needed to calculate green pixel
// values in TrueColor and DirectColor. The “mask” is the significant bits
// within the pixel. The “shift” is the number of bits left we must shift a
// primary for it to be in position (according to the "mask"). Finally,
// "precision" refers to how much precision the pixel value contains for a
// particular primary.
func (v visual) GreenPixelDetails() (mask uint32, shift int, precision int) {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var arg1 C.guint32
	var arg2 C.gint
	var arg3 C.gint

	C.gdk_visual_get_green_pixel_details(arg0, &arg1, &arg2, &arg3)

	var mask uint32
	var shift int
	var precision int

	mask = (uint32)(arg1)
	shift = (int)(arg2)
	precision = (int)(arg3)

	return mask, shift, precision
}

// RedPixelDetails obtains values that are needed to calculate red pixel
// values in TrueColor and DirectColor. The “mask” is the significant bits
// within the pixel. The “shift” is the number of bits left we must shift a
// primary for it to be in position (according to the "mask"). Finally,
// "precision" refers to how much precision the pixel value contains for a
// particular primary.
func (v visual) RedPixelDetails() (mask uint32, shift int, precision int) {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var arg1 C.guint32
	var arg2 C.gint
	var arg3 C.gint

	C.gdk_visual_get_red_pixel_details(arg0, &arg1, &arg2, &arg3)

	var mask uint32
	var shift int
	var precision int

	mask = (uint32)(arg1)
	shift = (int)(arg2)
	precision = (int)(arg3)

	return mask, shift, precision
}

// Screen gets the screen to which this visual belongs
func (v visual) Screen() Screen {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret *C.GdkScreen

	cret = C.gdk_visual_get_screen(arg0)

	var screen Screen

	screen = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(Screen)

	return screen
}

// VisualType returns the type of visual this is (PseudoColor, TrueColor,
// etc).
func (v visual) VisualType() VisualType {
	var arg0 *C.GdkVisual

	arg0 = (*C.GdkVisual)(unsafe.Pointer(v.Native()))

	var cret C.GdkVisualType

	cret = C.gdk_visual_get_visual_type(arg0)

	var visualType VisualType

	visualType = VisualType(cret)

	return visualType
}
