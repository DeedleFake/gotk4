// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"reflect"
	"runtime"
	"unsafe"
)

// #cgo pkg-config: gdk-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <gdk/gdk.h>
import "C"

// AtomIntern finds or creates an atom corresponding to a given string.
func AtomIntern(atomName string, onlyIfExists bool) Atom {
	var arg1 *C.gchar
	var arg2 C.gboolean

	arg1 = (*C.gchar)(C.CString(atomName))
	defer C.free(unsafe.Pointer(arg1))
	if onlyIfExists {
		arg2 = C.TRUE
	}

	ret := C.gdk_atom_intern(arg1, arg2)

	var ret0 Atom

	{
		ret0 = WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// AtomInternStaticString finds or creates an atom corresponding to a given
// string.
//
// Note that this function is identical to gdk_atom_intern() except that if a
// new Atom is created the string itself is used rather than a copy. This saves
// memory, but can only be used if the string will always exist. It can be used
// with statically allocated strings in the main program, but not with
// statically allocated memory in dynamically loaded modules, if you expect to
// ever unload the module again (e.g. do not use this function in GTK+ theme
// engines).
func AtomInternStaticString(atomName string) Atom {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(atomName))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_atom_intern_static_string(arg1)

	var ret0 Atom

	{
		ret0 = WrapAtom(unsafe.Pointer(ret))
	}

	return ret0
}

// PropertyChange changes the contents of a property on a window.
func PropertyChange(window Window, property Atom, typ Atom, format int, mode PropMode, data byte, nelements int) {
	var arg1 *C.GdkWindow
	var arg2 C.GdkAtom
	var arg3 C.GdkAtom
	var arg4 C.gint
	var arg5 C.GdkPropMode
	var arg6 *C.guchar
	var arg7 C.gint

	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = (C.GdkAtom)(property.Native())
	arg3 = (C.GdkAtom)(typ.Native())
	arg4 = C.gint(format)
	arg5 = (C.GdkPropMode)(mode)
	arg6 = (*C.guchar)(data)
	arg7 = C.gint(nelements)

	C.gdk_property_change(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
}

// PropertyDelete deletes a property from a window.
func PropertyDelete(window Window, property Atom) {
	var arg1 *C.GdkWindow
	var arg2 C.GdkAtom

	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = (C.GdkAtom)(property.Native())

	C.gdk_property_delete(arg1, arg2)
}

// PropertyGet retrieves a portion of the contents of a property. If the
// property does not exist, then the function returns false, and GDK_NONE will
// be stored in @actual_property_type.
//
// The XGetWindowProperty() function that gdk_property_get() uses has a very
// confusing and complicated set of semantics. Unfortunately, gdk_property_get()
// makes the situation worse instead of better (the semantics should be
// considered undefined), and also prints warnings to stderr in cases where it
// should return a useful error to the program. You are advised to use
// XGetWindowProperty() directly until a replacement function for
// gdk_property_get() is provided.
func PropertyGet(window Window, property Atom, typ Atom, offset uint32, length uint32, pdelete int) (actualPropertyType Atom, actualFormat int, actualLength int, data []byte, ok bool) {
	var arg1 *C.GdkWindow
	var arg2 C.GdkAtom
	var arg3 C.GdkAtom
	var arg4 C.gulong
	var arg5 C.gulong
	var arg6 C.gint
	var arg7 *C.GdkAtom  // out
	var arg8 *C.gint     // out
	var arg9 *C.gint     // out
	var arg10 **C.guchar // out

	arg1 = (*C.GdkWindow)(window.Native())
	arg2 = (C.GdkAtom)(property.Native())
	arg3 = (C.GdkAtom)(typ.Native())
	arg4 = C.gulong(offset)
	arg5 = C.gulong(length)
	arg6 = C.gint(pdelete)

	ret := C.gdk_property_get(arg1, arg2, arg3, arg4, arg5, arg6, &arg7, &arg8, &arg9, &arg10)

	var ret0 *Atom
	var ret1 int
	var ret2 int
	var ret3 []byte
	var ret4 bool

	{
		ret0 = WrapAtom(unsafe.Pointer(arg7))
	}

	ret1 = int(arg8)

	ret2 = int(arg9)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret3))
		sliceHeader.Data = uintptr(unsafe.Pointer(arg10))
		sliceHeader.Len = arg9
		sliceHeader.Cap = arg9
		runtime.SetFinalizer(&arg10, func() {
			C.free(unsafe.Pointer(arg10))
		})
		defer runtime.KeepAlive(arg10)
	}

	ret4 = C.bool(ret) != 0

	return ret0, ret1, ret2, ret3, ret4
}

// TextPropertyToUTF8ListForDisplay converts a text property in the given
// encoding to a list of UTF-8 strings.
func TextPropertyToUTF8ListForDisplay(display Display, encoding Atom, format int, text []byte) (list []string, gint int) {
	var arg1 *C.GdkDisplay
	var arg2 C.GdkAtom
	var arg3 C.gint
	var arg4 *C.guchar
	var arg5 C.gint
	var arg6 ***C.gchar // out

	arg1 = (*C.GdkDisplay)(display.Native())
	arg2 = (C.GdkAtom)(encoding.Native())
	arg3 = C.gint(format)
	arg4 = (*C.guchar)(unsafe.Pointer(&text[0]))
	arg5 = len(text)
	defer runtime.KeepAlive(text)

	ret := C.gdk_text_property_to_utf8_list_for_display(arg1, arg2, arg3, arg4, arg5, &arg6)

	var ret0 []string
	var ret1 int

	{
		var length uint
		for p := unsafe.Pointer(arg6); *p != 0; p = unsafe.Pointer(uintptr(p) + 1) {
			length++
		}

		ret0 = make([]string, length)
		for i := 0; i < length; i++ {
			src := (**C.gchar)(unsafe.Pointer(uintptr(unsafe.Pointer(arg6)) + i))
			ret0[i] = C.GoString(src)
			C.free(unsafe.Pointer(src))
		}
	}

	ret1 = int(ret)

	return ret0, ret1
}

// UTF8ToStringTarget converts an UTF-8 string into the best possible
// representation as a STRING. The representation of characters not in STRING is
// not specified; it may be as pseudo-escape sequences \x{ABCD}, or it may be in
// some other form of approximation.
func UTF8ToStringTarget(str string) string {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(str))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.gdk_utf8_to_string_target(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}
