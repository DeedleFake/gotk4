// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"reflect"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gdk-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdbool.h>
// #include <gdk/gdk.h>
import "C"

// AddOptionEntriesLibgtkOnly appends gdk option entries to the passed in option
// group. This is not public API and must not be used by applications.
func AddOptionEntriesLibgtkOnly(group *glib.OptionGroup) {
	var arg1 *C.GOptionGroup

	arg1 = (*C.GOptionGroup)(group.Native())

	C.gdk_add_option_entries_libgtk_only(arg1)
}

// Beep emits a short beep on the default display.
func Beep() {
	C.gdk_beep()
}

// DisableMultidevice disables multidevice support in GDK. This call must happen
// prior to gdk_display_open(), gtk_init(), gtk_init_with_args() or
// gtk_init_check() in order to take effect.
//
// Most common GTK+ applications won’t ever need to call this. Only applications
// that do mixed GDK/Xlib calls could want to disable multidevice support if
// such Xlib code deals with input devices in any way and doesn’t observe the
// presence of XInput 2.
func DisableMultidevice() {
	C.gdk_disable_multidevice()
}

// ErrorTrapPop removes an error trap pushed with gdk_error_trap_push(). May
// block until an error has been definitively received or not received from the
// X server. gdk_error_trap_pop_ignored() is preferred if you don’t need to know
// whether an error occurred, because it never has to block. If you don't need
// the return value of gdk_error_trap_pop(), use gdk_error_trap_pop_ignored().
//
// Prior to GDK 3.0, this function would not automatically sync for you, so you
// had to gdk_flush() if your last call to Xlib was not a blocking round trip.
func ErrorTrapPop() int {
	ret := C.gdk_error_trap_pop()

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// ErrorTrapPopIgnored removes an error trap pushed with gdk_error_trap_push(),
// but without bothering to wait and see whether an error occurred. If an error
// arrives later asynchronously that was triggered while the trap was pushed,
// that error will be ignored.
func ErrorTrapPopIgnored() {
	C.gdk_error_trap_pop_ignored()
}

// ErrorTrapPush: this function allows X errors to be trapped instead of the
// normal behavior of exiting the application. It should only be used if it is
// not possible to avoid the X error in any other way. Errors are ignored on all
// Display currently known to the DisplayManager. If you don’t care which error
// happens and just want to ignore everything, pop with
// gdk_error_trap_pop_ignored(). If you need the error code, use
// gdk_error_trap_pop() which may have to block and wait for the error to arrive
// from the X server.
//
// This API exists on all platforms but only does anything on X.
//
// You can use gdk_x11_display_error_trap_push() to ignore errors on only a
// single display.
//
// Trapping an X error
//
//    gdk_error_trap_push ();
//
//     // ... Call the X function which may cause an error here ...
//
//
//    if (gdk_error_trap_pop ())
//     {
//       // ... Handle the error here ...
//     }
func ErrorTrapPush() {
	C.gdk_error_trap_push()
}

// Flush flushes the output buffers of all display connections and waits until
// all requests have been processed. This is rarely needed by applications.
func Flush() {
	C.gdk_flush()
}

// GetDisplay gets the name of the display, which usually comes from the
// `DISPLAY` environment variable or the `--display` command line option.
func GetDisplay() string {
	ret := C.gdk_get_display()

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// GetDisplayArgName gets the display name specified in the command line
// arguments passed to gdk_init() or gdk_parse_args(), if any.
func GetDisplayArgName() string {
	ret := C.gdk_get_display_arg_name()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// GetProgramClass gets the program class. Unless the program class has
// explicitly been set with gdk_set_program_class() or with the `--class`
// commandline option, the default value is the program name (determined with
// g_get_prgname()) with the first character converted to uppercase.
func GetProgramClass() string {
	ret := C.gdk_get_program_class()

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Init initializes the GDK library and connects to the windowing system. If
// initialization fails, a warning message is output and the application
// terminates with a call to `exit(1)`.
//
// Any arguments used by GDK are removed from the array and @argc and @argv are
// updated accordingly.
//
// GTK+ initializes GDK in gtk_init() and so this function is not usually needed
// by GTK+ applications.
func Init(argc int, argv []string) {
	var arg1 *C.gint
	var arg2 ***C.gchar

	{
		var dst []**C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.gchar)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	C.gdk_init(arg1, arg2)
}

// InitCheck initializes the GDK library and connects to the windowing system,
// returning true on success.
//
// Any arguments used by GDK are removed from the array and @argc and @argv are
// updated accordingly.
//
// GTK+ initializes GDK in gtk_init() and so this function is not usually needed
// by GTK+ applications.
func InitCheck(argc int, argv []string) bool {
	var arg1 *C.gint
	var arg2 ***C.gchar

	{
		var dst []**C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.gchar)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	ret := C.gdk_init_check(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// KeyboardGrab grabs the keyboard so that all events are passed to this
// application until the keyboard is ungrabbed with gdk_keyboard_ungrab(). This
// overrides any previous keyboard grab by this client.
//
// If you set up anything at the time you take the grab that needs to be cleaned
// up when the grab ends, you should handle the EventGrabBroken events that are
// emitted when the grab ends unvoluntarily.
func KeyboardGrab(window Window, ownerEvents bool, time_ uint32) GrabStatus {
	var arg1 *C.GdkWindow
	var arg2 C.gboolean
	var arg3 C.guint32

	arg1 = (*C.GdkWindow)(window.Native())
	if ownerEvents {
		arg2 = C.TRUE
	}
	arg3 = C.guint32(time_)

	ret := C.gdk_keyboard_grab(arg1, arg2, arg3)

	var ret0 GrabStatus

	ret0 = GrabStatus(ret)

	return ret0
}

// KeyboardUngrab ungrabs the keyboard on the default display, if it is grabbed
// by this application.
func KeyboardUngrab(time_ uint32) {
	var arg1 C.guint32

	arg1 = C.guint32(time_)

	C.gdk_keyboard_ungrab(arg1)
}

// NotifyStartupComplete indicates to the GUI environment that the application
// has finished loading. If the applications opens windows, this function is
// normally called after opening the application’s initial set of windows.
//
// GTK+ will call this function automatically after opening the first Window
// unless gtk_window_set_auto_startup_notification() is called to disable that
// feature.
func NotifyStartupComplete() {
	C.gdk_notify_startup_complete()
}

// NotifyStartupCompleteWithID indicates to the GUI environment that the
// application has finished loading, using a given identifier.
//
// GTK+ will call this function automatically for Window with custom
// startup-notification identifier unless
// gtk_window_set_auto_startup_notification() is called to disable that feature.
func NotifyStartupCompleteWithID(startupID string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(startupID))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_notify_startup_complete_with_id(arg1)
}

// ParseArgs: parse command line arguments, and store for future use by calls to
// gdk_display_open().
//
// Any arguments used by GDK are removed from the array and @argc and @argv are
// updated accordingly.
//
// You shouldn’t call this function explicitly if you are using gtk_init(),
// gtk_init_check(), gdk_init(), or gdk_init_check().
func ParseArgs(argc int, argv []string) {
	var arg1 *C.gint
	var arg2 ***C.gchar

	{
		var dst []**C.gchar
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(argv))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(argv)
		sliceHeader.Cap = len(argv)

		for i := 0; i < len(argv); i++ {
			src := argv[i]
			dst[i] = (*C.gchar)(C.CString(src))
		}

		arg2 = (***C.gchar)(unsafe.Pointer(ptr))
		arg1 = len(argv)
	}

	C.gdk_parse_args(arg1, arg2)
}

// PointerGrab grabs the pointer (usually a mouse) so that all events are passed
// to this application until the pointer is ungrabbed with gdk_pointer_ungrab(),
// or the grab window becomes unviewable. This overrides any previous pointer
// grab by this client.
//
// Pointer grabs are used for operations which need complete control over mouse
// events, even if the mouse leaves the application. For example in GTK+ it is
// used for Drag and Drop, for dragging the handle in the HPaned and VPaned
// widgets.
//
// Note that if the event mask of an X window has selected both button press and
// button release events, then a button press event will cause an automatic
// pointer grab until the button is released. X does this automatically since
// most applications expect to receive button press and release events in pairs.
// It is equivalent to a pointer grab on the window with @owner_events set to
// true.
//
// If you set up anything at the time you take the grab that needs to be cleaned
// up when the grab ends, you should handle the EventGrabBroken events that are
// emitted when the grab ends unvoluntarily.
func PointerGrab(window Window, ownerEvents bool, eventMask EventMask, confineTo Window, cursor Cursor, time_ uint32) GrabStatus {
	var arg1 *C.GdkWindow
	var arg2 C.gboolean
	var arg3 C.GdkEventMask
	var arg4 *C.GdkWindow
	var arg5 *C.GdkCursor
	var arg6 C.guint32

	arg1 = (*C.GdkWindow)(window.Native())
	if ownerEvents {
		arg2 = C.TRUE
	}
	arg3 = (C.GdkEventMask)(eventMask)
	arg4 = (*C.GdkWindow)(confineTo.Native())
	arg5 = (*C.GdkCursor)(cursor.Native())
	arg6 = C.guint32(time_)

	ret := C.gdk_pointer_grab(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 GrabStatus

	ret0 = GrabStatus(ret)

	return ret0
}

// PointerIsGrabbed returns true if the pointer on the default display is
// currently grabbed by this application.
//
// Note that this does not take the inmplicit pointer grab on button presses
// into account.
func PointerIsGrabbed() bool {
	ret := C.gdk_pointer_is_grabbed()

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// PointerUngrab ungrabs the pointer on the default display, if it is grabbed by
// this application.
func PointerUngrab(time_ uint32) {
	var arg1 C.guint32

	arg1 = C.guint32(time_)

	C.gdk_pointer_ungrab(arg1)
}

// PreParseLibgtkOnly: prepare for parsing command line arguments for GDK. This
// is not public API and should not be used in application code.
func PreParseLibgtkOnly() {
	C.gdk_pre_parse_libgtk_only()
}

// SetAllowedBackends sets a list of backends that GDK should try to use.
//
// This can be be useful if your application does not work with certain GDK
// backends.
//
// By default, GDK tries all included backends.
//
// For example,
//
//    gdk_set_allowed_backends ("wayland,quartz,*");
//
// instructs GDK to try the Wayland backend first, followed by the Quartz
// backend, and then all others.
//
// If the `GDK_BACKEND` environment variable is set, it determines what backends
// are tried in what order, while still respecting the set of allowed backends
// that are specified by this function.
//
// The possible backend names are x11, win32, quartz, broadway, wayland. You can
// also include a * in the list to try all remaining backends.
//
// This call must happen prior to gdk_display_open(), gtk_init(),
// gtk_init_with_args() or gtk_init_check() in order to take effect.
func SetAllowedBackends(backends string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(backends))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_set_allowed_backends(arg1)
}

// SetDoubleClickTime: set the double click time for the default display. See
// gdk_display_set_double_click_time(). See also
// gdk_display_set_double_click_distance(). Applications should not set this, it
// is a global user-configured setting.
func SetDoubleClickTime(msec uint) {
	var arg1 C.guint

	arg1 = C.guint(msec)

	C.gdk_set_double_click_time(arg1)
}

// SetProgramClass sets the program class. The X11 backend uses the program
// class to set the class name part of the `WM_CLASS` property on toplevel
// windows; see the ICCCM.
//
// The program class can still be overridden with the --class command line
// option.
func SetProgramClass(programClass string) {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(programClass))
	defer C.free(unsafe.Pointer(arg1))

	C.gdk_set_program_class(arg1)
}
