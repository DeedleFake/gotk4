// Code generated by girgen. DO NOT EDIT.

package gdkpixdata

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config:
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gdk-pixbuf/gdk-pixdata.h>
import "C"

// PixdataDumpType: an enumeration which is used by gdk_pixdata_to_csource() to
// determine the form of C source to be generated. The three values
// @GDK_PIXDATA_DUMP_PIXDATA_STREAM, @GDK_PIXDATA_DUMP_PIXDATA_STRUCT and
// @GDK_PIXDATA_DUMP_MACROS are mutually exclusive, as are
// @GDK_PIXBUF_DUMP_GTYPES and @GDK_PIXBUF_DUMP_CTYPES. The remaining elements
// are optional flags that can be freely added.
type PixdataDumpType int

const (
	// PixdataDumpTypePixdataStream: generate pixbuf data stream (a single
	// string containing a serialized Pixdata structure in network byte order).
	PixdataDumpTypePixdataStream PixdataDumpType = 0b0
	// PixdataDumpTypePixdataStruct: generate Pixdata structure (needs the
	// Pixdata structure definition from gdk-pixdata.h).
	PixdataDumpTypePixdataStruct PixdataDumpType = 0b1
	// PixdataDumpTypeMacros: generate <function>*_ROWSTRIDE</function>,
	// <function>*_WIDTH</function>, <function>*_HEIGHT</function>,
	// <function>*_BYTES_PER_PIXEL</function> and
	// <function>*_RLE_PIXEL_DATA</function> or
	// <function>*_PIXEL_DATA</function> macro definitions for the image.
	PixdataDumpTypeMacros PixdataDumpType = 0b10
	// PixdataDumpTypeGTypes: generate GLib data types instead of standard C
	// data types.
	PixdataDumpTypeGTypes PixdataDumpType = 0b0
	// PixdataDumpTypeCtypes: generate standard C data types instead of GLib
	// data types.
	PixdataDumpTypeCtypes PixdataDumpType = 0b100000000
	// PixdataDumpTypeStatic: generate static symbols.
	PixdataDumpTypeStatic PixdataDumpType = 0b1000000000
	// PixdataDumpTypeConst: generate const symbols.
	PixdataDumpTypeConst PixdataDumpType = 0b10000000000
	// PixdataDumpTypeRleDecoder: provide a
	// <function>*_RUN_LENGTH_DECODE(image_buf, rle_data, size, bpp)</function>
	// macro definition to decode run-length encoded image data.
	PixdataDumpTypeRleDecoder PixdataDumpType = 0b10000000000000000
)

// PixdataType: an enumeration containing three sets of flags for a Pixdata
// struct: one for the used colorspace, one for the width of the samples and one
// for the encoding of the pixel data.
type PixdataType int

const (
	// PixdataTypeColorTypeRGB: each pixel has red, green and blue samples.
	PixdataTypeColorTypeRGB PixdataType = 0b1
	// PixdataTypeColorTypeRGBA: each pixel has red, green and blue samples and
	// an alpha value.
	PixdataTypeColorTypeRGBA PixdataType = 0b10
	// PixdataTypeColorTypeMask: mask for the colortype flags of the enum.
	PixdataTypeColorTypeMask PixdataType = 0b11111111
	// PixdataTypeSampleWidth8: each sample has 8 bits.
	PixdataTypeSampleWidth8 PixdataType = 0b10000000000000000
	// PixdataTypeSampleWidthMask: mask for the sample width flags of the enum.
	PixdataTypeSampleWidthMask PixdataType = 0b11110000000000000000
	// PixdataTypeEncodingRaw: the pixel data is in raw form.
	PixdataTypeEncodingRaw PixdataType = 0b1000000000000000000000000
	// PixdataTypeEncodingRle: the pixel data is run-length encoded. Runs may be
	// up to 127 bytes long; their length is stored in a single byte preceding
	// the pixel data for the run. If a run is constant, its length byte has the
	// high bit set and the pixel data consists of a single pixel which must be
	// repeated.
	PixdataTypeEncodingRle PixdataType = 0b10000000000000000000000000
	// PixdataTypeEncodingMask: mask for the encoding flags of the enum.
	PixdataTypeEncodingMask PixdataType = 0b1111000000000000000000000000
)

// PixbufFromPixdata converts a Pixdata to a Pixbuf. If @copy_pixels is true or
// if the pixel data is run-length-encoded, the pixel data is copied into
// newly-allocated memory; otherwise it is reused.
func PixbufFromPixdata(pixdata *Pixdata, copyPixels bool) (pixbuf gdkpixbuf.Pixbuf, err error) {
	var arg1 *C.GdkPixdata
	var arg2 C.gboolean
	var errout *C.GError

	arg1 = (*C.GdkPixdata)(unsafe.Pointer(pixdata.Native()))
	if copyPixels {
		arg2 = C.gboolean(1)
	}

	var cret *C.GdkPixbuf
	var ret1 gdkpixbuf.Pixbuf
	var goerr error

	cret = C.gdk_pixbuf_from_pixdata(pixdata, copyPixels, &errout)

	ret1 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(cret.Native()))).(gdkpixbuf.Pixbuf)
	if errout != nil {
		goerr = fmt.Errorf("%d: %s", errout.code, C.GoString(errout.message))
		C.g_error_free(errout)
	}

	return ret1, goerr
}

// Pixdata: a Pixdata contains pixbuf information in a form suitable for
// serialization and streaming.
type Pixdata struct {
	native C.GdkPixdata
}

// WrapPixdata wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapPixdata(ptr unsafe.Pointer) *Pixdata {
	if ptr == nil {
		return nil
	}

	return (*Pixdata)(ptr)
}

func marshalPixdata(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapPixdata(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *Pixdata) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Magic gets the field inside the struct.
func (p *Pixdata) Magic() uint32 {
	v = C.guint32(p.native.magic)
}

// Length gets the field inside the struct.
func (p *Pixdata) Length() int32 {
	v = C.gint32(p.native.length)
}

// PixdataType gets the field inside the struct.
func (p *Pixdata) PixdataType() uint32 {
	v = C.guint32(p.native.pixdata_type)
}

// Rowstride gets the field inside the struct.
func (p *Pixdata) Rowstride() uint32 {
	v = C.guint32(p.native.rowstride)
}

// Width gets the field inside the struct.
func (p *Pixdata) Width() uint32 {
	v = C.guint32(p.native.width)
}

// Height gets the field inside the struct.
func (p *Pixdata) Height() uint32 {
	v = C.guint32(p.native.height)
}

// FromPixbuf converts a Pixbuf to a Pixdata. If @use_rle is true, the pixel
// data is run-length encoded into newly-allocated memory and a pointer to that
// memory is returned.
func (p *Pixdata) FromPixbuf(pixbuf gdkpixbuf.Pixbuf, useRle bool) interface{} {
	var arg0 *C.GdkPixdata
	var arg1 *C.GdkPixbuf
	var arg2 C.gboolean

	arg0 = (*C.GdkPixdata)(unsafe.Pointer(p.Native()))
	arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	if useRle {
		arg2 = C.gboolean(1)
	}

	var cret C.gpointer
	var ret1 interface{}

	cret = C.gdk_pixdata_from_pixbuf(arg0, pixbuf, useRle)

	ret1 = C.gpointer(cret)

	return ret1
}

// Serialize serializes a Pixdata structure into a byte stream. The byte stream
// consists of a straightforward writeout of the Pixdata fields in network byte
// order, plus the @pixel_data bytes the structure points to.
func (p *Pixdata) Serialize() (streamLengthP uint, guint8s []byte) {
	var arg0 *C.GdkPixdata

	arg0 = (*C.GdkPixdata)(unsafe.Pointer(p.Native()))

	var cret *C.guint8
	var arg1 *C.guint
	var ret2 []byte

	cret = C.gdk_pixdata_serialize(arg0, &arg1)

	ptr.SetSlice(unsafe.Pointer(&ret2), unsafe.Pointer(cret), int(arg1))
	runtime.SetFinalizer(&ret2, func(v *[]byte) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return ret1, ret2
}

// ToCsource generates C source code suitable for compiling images directly into
// programs.
//
// gdk-pixbuf ships with a program called
// [gdk-pixbuf-csource][gdk-pixbuf-csource], which offers a command line
// interface to this function.
func (p *Pixdata) ToCsource(name string, dumpType PixdataDumpType) *glib.String {
	var arg0 *C.GdkPixdata
	var arg1 *C.gchar
	var arg2 C.GdkPixdataDumpType

	arg0 = (*C.GdkPixdata)(unsafe.Pointer(p.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (C.GdkPixdataDumpType)(dumpType)

	var cret *C.GString
	var ret1 *glib.String

	cret = C.gdk_pixdata_to_csource(arg0, name, dumpType)

	ret1 = glib.WrapString(unsafe.Pointer(cret))
	runtime.SetFinalizer(ret1, func(v *glib.String) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return ret1
}
