// Code generated by girgen. DO NOT EDIT.

package pangofc

import (
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pangofc
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <pango/pangofc-fontmap.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_fc_decoder_get_type()), F: marshalDecoder},
	})
}

// Decoder: `PangoFcDecoder` is a virtual base class that implementations will
// inherit from.
//
// It's the interface that is used to define a custom encoding for a font. These
// objects are created in your code from a function callback that was originally
// registered with [method@PangoFc.FontMap.add_decoder_find_func]. Pango
// requires information about the supported charset for a font as well as the
// individual character to glyph conversions. Pango gets that information via
// the #get_charset and #get_glyph callbacks into your object implementation.
type Decoder interface {
	gextras.Objector

	// Glyph generates a `PangoGlyph` for the given Unicode point using the
	// custom decoder.
	//
	// For complex scripts where there can be multiple glyphs for a single
	// character, the decoder will return whatever glyph is most convenient for
	// it. (Usually whatever glyph is directly in the fonts character map
	// table.)
	Glyph(fcfont Font, wc uint32) pango.Glyph
}

// decoder implements the Decoder interface.
type decoder struct {
	gextras.Objector
}

var _ Decoder = (*decoder)(nil)

// WrapDecoder wraps a GObject to the right type. It is
// primarily used internally.
func WrapDecoder(obj *externglib.Object) Decoder {
	return Decoder{
		Objector: obj,
	}
}

func marshalDecoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapDecoder(obj), nil
}

// Glyph generates a `PangoGlyph` for the given Unicode point using the
// custom decoder.
//
// For complex scripts where there can be multiple glyphs for a single
// character, the decoder will return whatever glyph is most convenient for
// it. (Usually whatever glyph is directly in the fonts character map
// table.)
func (d decoder) Glyph(fcfont Font, wc uint32) pango.Glyph {
	var arg0 *C.PangoFcDecoder
	var arg1 *C.PangoFcFont
	var arg2 C.guint32

	arg0 = (*C.PangoFcDecoder)(d.Native())
	arg1 = (*C.PangoFcFont)(fcfont.Native())
	arg2 = C.guint32(wc)

	ret := C.pango_fc_decoder_get_glyph(arg0, arg1, arg2)

	var ret0 pango.Glyph

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = pango.Glyph(tmp)
	}

	return ret0
}
