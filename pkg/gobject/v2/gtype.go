// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	"github.com/diamondburned/gotk4/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// Type: a numerical value which represents the unique identifier of a
// registered type.
type Type = uint

// TypeDebugFlags: these flags used to be passed to
// g_type_init_with_debug_flags() which is now deprecated.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
//
// Deprecated: since version 2.36.
type TypeDebugFlags int

const (
	// TypeDebugFlagsNone: print no messages
	TypeDebugFlagsNone TypeDebugFlags = 0b0
	// TypeDebugFlagsObjects: print messages about object bookkeeping
	TypeDebugFlagsObjects TypeDebugFlags = 0b1
	// TypeDebugFlagsSignals: print messages about signal emissions
	TypeDebugFlagsSignals TypeDebugFlags = 0b10
	// TypeDebugFlagsInstanceCount: keep a count of instances of each type
	TypeDebugFlagsInstanceCount TypeDebugFlags = 0b100
	// TypeDebugFlagsMask: mask covering all debug flags
	TypeDebugFlagsMask TypeDebugFlags = 0b111
)

// TypeFlags: bit masks used to check or determine characteristics of a type.
type TypeFlags int

const (
	// TypeFlagsAbstract indicates an abstract type. No instances can be created
	// for an abstract type
	TypeFlagsAbstract TypeFlags = 0b10000
	// TypeFlagsValueAbstract indicates an abstract value type, i.e. a type that
	// introduces a value table, but can't be used for g_value_init()
	TypeFlagsValueAbstract TypeFlags = 0b100000
)

// TypeFundamentalFlags: bit masks used to check or determine specific
// characteristics of a fundamental type.
type TypeFundamentalFlags int

const (
	// TypeFundamentalFlagsClassed indicates a classed type
	TypeFundamentalFlagsClassed TypeFundamentalFlags = 0b1
	// TypeFundamentalFlagsInstantiatable indicates an instantiatable type
	// (implies classed)
	TypeFundamentalFlagsInstantiatable TypeFundamentalFlags = 0b10
	// TypeFundamentalFlagsDerivable indicates a flat derivable type
	TypeFundamentalFlagsDerivable TypeFundamentalFlags = 0b100
	// TypeFundamentalFlagsDeepDerivable indicates a deep derivable type
	// (implies derivable)
	TypeFundamentalFlagsDeepDerivable TypeFundamentalFlags = 0b1000
)

// TypeAddClassPrivate registers a private class structure for a classed type;
// when the class is allocated, the private structures for the class and all of
// its parent types are allocated sequentially in the same memory block as the
// public structures, and are zero-filled.
//
// This function should be called in the type's get_type() function after the
// type is registered. The private structure can be retrieved using the
// G_TYPE_CLASS_GET_PRIVATE() macro.
func TypeAddClassPrivate(classType externglib.Type, privateSize uint) {
	var _arg1 C.GType // out
	var _arg2 C.gsize // out

	_arg1 = (C.GType)(classType)
	_arg2 = C.gsize(privateSize)

	C.g_type_add_class_private(_arg1, _arg2)
}

func TypeAddInstancePrivate(classType externglib.Type, privateSize uint) int {
	var _arg1 C.GType // out
	var _arg2 C.gsize // out
	var _cret C.gint  // in

	_arg1 = (C.GType)(classType)
	_arg2 = C.gsize(privateSize)

	_cret = C.g_type_add_instance_private(_arg1, _arg2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TypeAddInterfaceDynamic adds @interface_type to the dynamic @instance_type.
// The information contained in the Plugin structure pointed to by @plugin is
// used to manage the relationship.
func TypeAddInterfaceDynamic(instanceType externglib.Type, interfaceType externglib.Type, plugin TypePlugin) {
	var _arg1 C.GType        // out
	var _arg2 C.GType        // out
	var _arg3 *C.GTypePlugin // out

	_arg1 = (C.GType)(instanceType)
	_arg2 = (C.GType)(interfaceType)
	_arg3 = (*C.GTypePlugin)(unsafe.Pointer(plugin.Native()))

	C.g_type_add_interface_dynamic(_arg1, _arg2, _arg3)
}

// TypeAddInterfaceStatic adds @interface_type to the static @instance_type. The
// information contained in the Info structure pointed to by @info is used to
// manage the relationship.
func TypeAddInterfaceStatic(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo) {
	var _arg1 C.GType           // out
	var _arg2 C.GType           // out
	var _arg3 *C.GInterfaceInfo // out

	_arg1 = (C.GType)(instanceType)
	_arg2 = (C.GType)(interfaceType)
	_arg3 = (*C.GInterfaceInfo)(unsafe.Pointer(info.Native()))

	C.g_type_add_interface_static(_arg1, _arg2, _arg3)
}

// TypeCheckInstance: private helper function to aid implementation of the
// G_TYPE_CHECK_INSTANCE() macro.
func TypeCheckInstance(instance *TypeInstance) bool {
	var _arg1 *C.GTypeInstance // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	_cret = C.g_type_check_instance(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func TypeCheckInstanceIsA(instance *TypeInstance, ifaceType externglib.Type) bool {
	var _arg1 *C.GTypeInstance // out
	var _arg2 C.GType          // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))
	_arg2 = (C.GType)(ifaceType)

	_cret = C.g_type_check_instance_is_a(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func TypeCheckInstanceIsFundamentallyA(instance *TypeInstance, fundamentalType externglib.Type) bool {
	var _arg1 *C.GTypeInstance // out
	var _arg2 C.GType          // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))
	_arg2 = (C.GType)(fundamentalType)

	_cret = C.g_type_check_instance_is_fundamentally_a(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func TypeCheckIsValueType(typ externglib.Type) bool {
	var _arg1 C.GType    // out
	var _cret C.gboolean // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_check_is_value_type(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func TypeCheckValue(value externglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))

	_cret = C.g_type_check_value(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func TypeCheckValueHolds(value externglib.Value, typ externglib.Type) bool {
	var _arg1 *C.GValue  // out
	var _arg2 C.GType    // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(&value.GValue))
	_arg2 = (C.GType)(typ)

	_cret = C.g_type_check_value_holds(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TypeDepth returns the length of the ancestry of the passed in type. This
// includes the type itself, so that e.g. a fundamental type has depth 1.
func TypeDepth(typ externglib.Type) uint {
	var _arg1 C.GType // out
	var _cret C.guint // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_depth(_arg1)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TypeEnsure ensures that the indicated @type has been registered with the type
// system, and its _class_init() method has been run.
//
// In theory, simply calling the type's _get_type() method (or using the
// corresponding macro) is supposed take care of this. However, _get_type()
// methods are often marked G_GNUC_CONST for performance reasons, even though
// this is technically incorrect (since G_GNUC_CONST requires that the function
// not have side effects, which _get_type() methods do on the first call). As a
// result, if you write a bare call to a _get_type() macro, it may get optimized
// out by the compiler. Using g_type_ensure() guarantees that the type's
// _get_type() method is called.
func TypeEnsure(typ externglib.Type) {
	var _arg1 C.GType // out

	_arg1 = (C.GType)(typ)

	C.g_type_ensure(_arg1)
}

// TypeFreeInstance frees an instance of a type, returning it to the instance
// pool for the type, if there is one.
//
// Like g_type_create_instance(), this function is reserved for implementors of
// fundamental types.
func TypeFreeInstance(instance *TypeInstance) {
	var _arg1 *C.GTypeInstance // out

	_arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	C.g_type_free_instance(_arg1)
}

// TypeFromName: look up the type ID from a given type name, returning 0 if no
// type has been registered under this name (this is the preferred method to
// find out by name whether a specific type has been registered yet).
func TypeFromName(name string) externglib.Type {
	var _arg1 *C.gchar // out
	var _cret C.GType  // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_type_from_name(_arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeFundamental: internal function, used to extract the fundamental type ID
// portion. Use G_TYPE_FUNDAMENTAL() instead.
func TypeFundamental(typeId externglib.Type) externglib.Type {
	var _arg1 C.GType // out
	var _cret C.GType // in

	_arg1 = (C.GType)(typeId)

	_cret = C.g_type_fundamental(_arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeFundamentalNext returns the next free fundamental type id which can be
// used to register a new fundamental type with g_type_register_fundamental().
// The returned type ID represents the highest currently registered fundamental
// type identifier.
func TypeFundamentalNext() externglib.Type {
	var _cret C.GType // in

	_cret = C.g_type_fundamental_next()

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeGetInstanceCount returns the number of instances allocated of the
// particular type; this is only available if GLib is built with debugging
// support and the instance_count debug flag is set (by setting the
// GOBJECT_DEBUG variable to include instance-count).
func TypeGetInstanceCount(typ externglib.Type) int {
	var _arg1 C.GType // out
	var _cret C.int   // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_get_instance_count(_arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TypeGetPlugin returns the Plugin structure for @type.
func TypeGetPlugin(typ externglib.Type) TypePlugin {
	var _arg1 C.GType        // out
	var _cret *C.GTypePlugin // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_get_plugin(_arg1)

	var _typePlugin TypePlugin // out

	_typePlugin = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TypePlugin)

	return _typePlugin
}

// TypeGetTypeRegistrationSerial returns an opaque serial number that represents
// the state of the set of registered types. Any time a type is registered this
// serial changes, which means you can cache information based on type lookups
// (such as g_type_from_name()) and know if the cache is still valid at a later
// time by comparing the current serial with the one at the type lookup.
func TypeGetTypeRegistrationSerial() uint {
	var _cret C.guint // in

	_cret = C.g_type_get_type_registration_serial()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TypeInit: this function used to initialise the type system. Since GLib 2.36,
// the type system is initialised automatically and this function does nothing.
//
// Deprecated: since version 2.36.
func TypeInit() {
	C.g_type_init()
}

// TypeInitWithDebugFlags: this function used to initialise the type system with
// debugging flags. Since GLib 2.36, the type system is initialised
// automatically and this function does nothing.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
//
// Deprecated: since version 2.36.
func TypeInitWithDebugFlags(debugFlags TypeDebugFlags) {
	var _arg1 C.GTypeDebugFlags // out

	_arg1 = C.GTypeDebugFlags(debugFlags)

	C.g_type_init_with_debug_flags(_arg1)
}

// TypeIsA: if @is_a_type is a derivable type, check whether @type is a
// descendant of @is_a_type. If @is_a_type is an interface, check whether @type
// conforms to it.
func TypeIsA(typ externglib.Type, isAType externglib.Type) bool {
	var _arg1 C.GType    // out
	var _arg2 C.GType    // out
	var _cret C.gboolean // in

	_arg1 = (C.GType)(typ)
	_arg2 = (C.GType)(isAType)

	_cret = C.g_type_is_a(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TypeName: get the unique name that is assigned to a type ID. Note that this
// function (like all other GType API) cannot cope with invalid type IDs.
// G_TYPE_INVALID may be passed to this function, as may be any other validly
// registered type ID, but randomized type IDs should not be passed in and will
// most likely lead to a crash.
func TypeName(typ externglib.Type) string {
	var _arg1 C.GType  // out
	var _cret *C.gchar // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func TypeNameFromInstance(instance *TypeInstance) string {
	var _arg1 *C.GTypeInstance // out
	var _cret *C.gchar         // in

	_arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	_cret = C.g_type_name_from_instance(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// TypeNextBase: given a @leaf_type and a @root_type which is contained in its
// ancestry, return the type that @root_type is the immediate parent of. In
// other words, this function determines the type that is derived directly from
// @root_type which is also a base class of @leaf_type. Given a root type and a
// leaf type, this function can be used to determine the types and order in
// which the leaf type is descended from the root type.
func TypeNextBase(leafType externglib.Type, rootType externglib.Type) externglib.Type {
	var _arg1 C.GType // out
	var _arg2 C.GType // out
	var _cret C.GType // in

	_arg1 = (C.GType)(leafType)
	_arg2 = (C.GType)(rootType)

	_cret = C.g_type_next_base(_arg1, _arg2)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeParent: return the direct parent type of the passed in type. If the
// passed in type has no parent, i.e. is a fundamental type, 0 is returned.
func TypeParent(typ externglib.Type) externglib.Type {
	var _arg1 C.GType // out
	var _cret C.GType // in

	_arg1 = (C.GType)(typ)

	_cret = C.g_type_parent(_arg1)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeQuery queries the type system for information about a specific type. This
// function will fill in a user-provided structure to hold type-specific
// information. If an invalid #GType is passed in, the @type member of the Query
// is 0. All members filled into the Query structure should be considered
// constant and have to be left untouched.
func TypeQuery(typ externglib.Type) TypeQuery {
	var _arg1 C.GType      // out
	var _arg2 C.GTypeQuery // in

	_arg1 = (C.GType)(typ)

	C.g_type_query(_arg1, &_arg2)

	var _query TypeQuery // out

	{
		var refTmpIn *C.GTypeQuery
		var refTmpOut *TypeQuery

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*TypeQuery)(unsafe.Pointer(refTmpIn))

		_query = *refTmpOut
	}

	return _query
}

// TypeRegisterDynamic registers @type_name as the name of a new dynamic type
// derived from @parent_type. The type system uses the information contained in
// the Plugin structure pointed to by @plugin to manage the type and its
// instances (if not abstract). The value of @flags determines the nature (e.g.
// abstract or not) of the type.
func TypeRegisterDynamic(parentType externglib.Type, typeName string, plugin TypePlugin, flags TypeFlags) externglib.Type {
	var _arg1 C.GType        // out
	var _arg2 *C.gchar       // out
	var _arg3 *C.GTypePlugin // out
	var _arg4 C.GTypeFlags   // out
	var _cret C.GType        // in

	_arg1 = (C.GType)(parentType)
	_arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GTypePlugin)(unsafe.Pointer(plugin.Native()))
	_arg4 = C.GTypeFlags(flags)

	_cret = C.g_type_register_dynamic(_arg1, _arg2, _arg3, _arg4)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeRegisterFundamental registers @type_id as the predefined identifier and
// @type_name as the name of a fundamental type. If @type_id is already
// registered, or a type named @type_name is already registered, the behaviour
// is undefined. The type system uses the information contained in the Info
// structure pointed to by @info and the FundamentalInfo structure pointed to by
// @finfo to manage the type and its instances. The value of @flags determines
// additional characteristics of the fundamental type.
func TypeRegisterFundamental(typeId externglib.Type, typeName string, info *TypeInfo, finfo *TypeFundamentalInfo, flags TypeFlags) externglib.Type {
	var _arg1 C.GType                 // out
	var _arg2 *C.gchar                // out
	var _arg3 *C.GTypeInfo            // out
	var _arg4 *C.GTypeFundamentalInfo // out
	var _arg5 C.GTypeFlags            // out
	var _cret C.GType                 // in

	_arg1 = (C.GType)(typeId)
	_arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GTypeInfo)(unsafe.Pointer(info.Native()))
	_arg4 = (*C.GTypeFundamentalInfo)(unsafe.Pointer(finfo.Native()))
	_arg5 = C.GTypeFlags(flags)

	_cret = C.g_type_register_fundamental(_arg1, _arg2, _arg3, _arg4, _arg5)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// TypeRegisterStatic registers @type_name as the name of a new static type
// derived from @parent_type. The type system uses the information contained in
// the Info structure pointed to by @info to manage the type and its instances
// (if not abstract). The value of @flags determines the nature (e.g. abstract
// or not) of the type.
func TypeRegisterStatic(parentType externglib.Type, typeName string, info *TypeInfo, flags TypeFlags) externglib.Type {
	var _arg1 C.GType      // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.GTypeInfo // out
	var _arg4 C.GTypeFlags // out
	var _cret C.GType      // in

	_arg1 = (C.GType)(parentType)
	_arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GTypeInfo)(unsafe.Pointer(info.Native()))
	_arg4 = C.GTypeFlags(flags)

	_cret = C.g_type_register_static(_arg1, _arg2, _arg3, _arg4)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

func TypeTestFlags(typ externglib.Type, flags uint) bool {
	var _arg1 C.GType    // out
	var _arg2 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = (C.GType)(typ)
	_arg2 = C.guint(flags)

	_cret = C.g_type_test_flags(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterfaceInfo: a structure that provides information to the type system which
// is used specifically for managing interface types.
type InterfaceInfo C.GInterfaceInfo

// WrapInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInterfaceInfo(ptr unsafe.Pointer) *InterfaceInfo {
	return (*InterfaceInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (i *InterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(i)
}

// TypeFundamentalInfo: a structure that provides information to the type system
// which is used specifically for managing fundamental types.
type TypeFundamentalInfo C.GTypeFundamentalInfo

// WrapTypeFundamentalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeFundamentalInfo(ptr unsafe.Pointer) *TypeFundamentalInfo {
	return (*TypeFundamentalInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TypeFundamentalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// TypeInfo: this structure is used to provide the type system with the
// information required to initialize and destruct (finalize) a type's class and
// its instances.
//
// The initialized structure is passed to the g_type_register_static() function
// (or is copied into the provided Info structure in the
// g_type_plugin_complete_type_info()). The type system will perform a deep copy
// of this structure, so its memory does not need to be persistent across
// invocation of g_type_register_static().
type TypeInfo C.GTypeInfo

// WrapTypeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInfo(ptr unsafe.Pointer) *TypeInfo {
	return (*TypeInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TypeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// TypeInstance: an opaque structure used as the base of all type instances.
type TypeInstance C.GTypeInstance

// WrapTypeInstance wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInstance(ptr unsafe.Pointer) *TypeInstance {
	return (*TypeInstance)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TypeInstance) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

func (i *TypeInstance) Private(privateType externglib.Type) interface{} {
	var _arg0 *C.GTypeInstance // out
	var _arg1 C.GType          // out
	var _cret C.gpointer       // in

	_arg0 = (*C.GTypeInstance)(unsafe.Pointer(i.Native()))
	_arg1 = (C.GType)(privateType)

	_cret = C.g_type_instance_get_private(_arg0, _arg1)

	var _gpointer interface{} // out

	_gpointer = box.Get(uintptr(_cret))

	return _gpointer
}

// TypeQuery: a structure holding information for a specific type. It is filled
// in by the g_type_query() function.
type TypeQuery C.GTypeQuery

// WrapTypeQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeQuery(ptr unsafe.Pointer) *TypeQuery {
	return (*TypeQuery)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TypeQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}

// TypeValueTable: the ValueTable provides the functions required by the #GValue
// implementation, to serve as a container for values of a type.
type TypeValueTable C.GTypeValueTable

// WrapTypeValueTable wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeValueTable(ptr unsafe.Pointer) *TypeValueTable {
	return (*TypeValueTable)(ptr)
}

// Native returns the underlying C source pointer.
func (t *TypeValueTable) Native() unsafe.Pointer {
	return unsafe.Pointer(t)
}
