// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib-object.h>
import "C"

// Type: a numerical value which represents the unique identifier of a
// registered type.
type Type uint

// TypeDebugFlags: these flags used to be passed to
// g_type_init_with_debug_flags() which is now deprecated.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
type TypeDebugFlags int

const (
	// TypeDebugFlagsNone: print no messages
	TypeDebugFlagsNone TypeDebugFlags = 0b0
	// TypeDebugFlagsObjects: print messages about object bookkeeping
	TypeDebugFlagsObjects TypeDebugFlags = 0b1
	// TypeDebugFlagsSignals: print messages about signal emissions
	TypeDebugFlagsSignals TypeDebugFlags = 0b10
	// TypeDebugFlagsInstanceCount: keep a count of instances of each type
	TypeDebugFlagsInstanceCount TypeDebugFlags = 0b100
	// TypeDebugFlagsMask: mask covering all debug flags
	TypeDebugFlagsMask TypeDebugFlags = 0b111
)

// TypeFlags: bit masks used to check or determine characteristics of a type.
type TypeFlags int

const (
	// TypeFlagsAbstract indicates an abstract type. No instances can be created
	// for an abstract type
	TypeFlagsAbstract TypeFlags = 0b10000
	// TypeFlagsValueAbstract indicates an abstract value type, i.e. a type that
	// introduces a value table, but can't be used for g_value_init()
	TypeFlagsValueAbstract TypeFlags = 0b100000
)

// TypeFundamentalFlags: bit masks used to check or determine specific
// characteristics of a fundamental type.
type TypeFundamentalFlags int

const (
	// TypeFundamentalFlagsClassed indicates a classed type
	TypeFundamentalFlagsClassed TypeFundamentalFlags = 0b1
	// TypeFundamentalFlagsInstantiatable indicates an instantiable type
	// (implies classed)
	TypeFundamentalFlagsInstantiatable TypeFundamentalFlags = 0b10
	// TypeFundamentalFlagsDerivable indicates a flat derivable type
	TypeFundamentalFlagsDerivable TypeFundamentalFlags = 0b100
	// TypeFundamentalFlagsDeepDerivable indicates a deep derivable type
	// (implies derivable)
	TypeFundamentalFlagsDeepDerivable TypeFundamentalFlags = 0b1000
)

// TypeAddClassPrivate registers a private class structure for a classed type;
// when the class is allocated, the private structures for the class and all of
// its parent types are allocated sequentially in the same memory block as the
// public structures, and are zero-filled.
//
// This function should be called in the type's get_type() function after the
// type is registered. The private structure can be retrieved using the
// G_TYPE_CLASS_GET_PRIVATE() macro.
func TypeAddClassPrivate(classType externglib.Type, privateSize uint) {
	var arg1 C.GType
	var arg2 C.gsize

	arg1 := C.GType(classType)
	arg2 = C.gsize(privateSize)

	C.g_type_add_class_private(classType, privateSize)
}

func TypeAddInstancePrivate(classType externglib.Type, privateSize uint) int {
	var arg1 C.GType
	var arg2 C.gsize

	arg1 := C.GType(classType)
	arg2 = C.gsize(privateSize)

	var cret C.gint
	var ret1 int

	cret = C.g_type_add_instance_private(classType, privateSize)

	ret1 = C.gint(cret)

	return ret1
}

// TypeAddInterfaceDynamic adds @interface_type to the dynamic
// @instantiable_type. The information contained in the Plugin structure pointed
// to by @plugin is used to manage the relationship.
func TypeAddInterfaceDynamic(instanceType externglib.Type, interfaceType externglib.Type, plugin TypePlugin) {
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GTypePlugin

	arg1 := C.GType(instanceType)
	arg2 := C.GType(interfaceType)
	arg3 = (*C.GTypePlugin)(unsafe.Pointer(plugin.Native()))

	C.g_type_add_interface_dynamic(instanceType, interfaceType, plugin)
}

// TypeAddInterfaceStatic adds @interface_type to the static @instantiable_type.
// The information contained in the Info structure pointed to by @info is used
// to manage the relationship.
func TypeAddInterfaceStatic(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo) {
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GInterfaceInfo

	arg1 := C.GType(instanceType)
	arg2 := C.GType(interfaceType)
	arg3 = (*C.GInterfaceInfo)(unsafe.Pointer(info.Native()))

	C.g_type_add_interface_static(instanceType, interfaceType, info)
}

// TypeCheckInstance: private helper function to aid implementation of the
// G_TYPE_CHECK_INSTANCE() macro.
func TypeCheckInstance(instance *TypeInstance) bool {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_instance(instance)

	ret1 = C.bool(cret) != C.false

	return ret1
}

func TypeCheckInstanceCast(instance *TypeInstance, ifaceType externglib.Type) *TypeInstance {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))
	arg2 := C.GType(ifaceType)

	var cret *C.GTypeInstance
	var ret1 *TypeInstance

	cret = C.g_type_check_instance_cast(instance, ifaceType)

	ret1 = WrapTypeInstance(unsafe.Pointer(cret))

	return ret1
}

func TypeCheckInstanceIsA(instance *TypeInstance, ifaceType externglib.Type) bool {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))
	arg2 := C.GType(ifaceType)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_instance_is_a(instance, ifaceType)

	ret1 = C.bool(cret) != C.false

	return ret1
}

func TypeCheckInstanceIsFundamentallyA(instance *TypeInstance, fundamentalType externglib.Type) bool {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))
	arg2 := C.GType(fundamentalType)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_instance_is_fundamentally_a(instance, fundamentalType)

	ret1 = C.bool(cret) != C.false

	return ret1
}

func TypeCheckIsValueType(typ externglib.Type) bool {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_is_value_type(typ)

	ret1 = C.bool(cret) != C.false

	return ret1
}

func TypeCheckValue(value *externglib.Value) bool {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_value(value)

	ret1 = C.bool(cret) != C.false

	return ret1
}

func TypeCheckValueHolds(value *externglib.Value, typ externglib.Type) bool {
	var arg1 *C.GValue
	var arg2 C.GType

	arg1 = (*C.GValue)(value.GValue)
	arg2 := C.GType(typ)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_check_value_holds(value, typ)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// TypeChildren: return a newly allocated and 0-terminated array of type IDs,
// listing the child types of @type.
func TypeChildren(typ externglib.Type) (nChildren uint, gTypes []externglib.Type) {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret *C.GType
	var arg2 *C.guint
	var ret2 []externglib.Type

	cret = C.g_type_children(typ, &arg2)

	ret2 = make([]externglib.Type, arg2)
	for i := 0; i < uintptr(arg2); i++ {
		src := (C.GType)(ptr.Add(unsafe.Pointer(cret), i))
		ret2[i] = externglib.Type(src)
	}

	return ret2, ret2
}

func TypeClassAdjustPrivateOffset(gClass interface{}, privateSizeOrOffset int) {
	var arg1 C.gpointer
	var arg2 *C.gint

	arg1 = C.gpointer(gClass)
	arg2 = *C.gint(privateSizeOrOffset)

	C.g_type_class_adjust_private_offset(gClass, privateSizeOrOffset)
}

// TypeCreateInstance creates and initializes an instance of @type if @type is
// valid and can be instantiated. The type system only performs basic allocation
// and structure setups for instances: actual instance creation should happen
// through functions supplied by the type's fundamental type implementation. So
// use of g_type_create_instance() is reserved for implementers of fundamental
// types only. E.g. instances of the #GObject hierarchy should be created via
// g_object_new() and never directly through g_type_create_instance() which
// doesn't handle things like singleton objects or object construction.
//
// The extended members of the returned instance are guaranteed to be filled
// with zeros.
//
// Note: Do not use this function, unless you're implementing a fundamental
// type. Also language bindings should not use this function, but g_object_new()
// instead.
func TypeCreateInstance(typ externglib.Type) *TypeInstance {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret *C.GTypeInstance
	var ret1 *TypeInstance

	cret = C.g_type_create_instance(typ)

	ret1 = WrapTypeInstance(unsafe.Pointer(cret))

	return ret1
}

// TypeDepth returns the length of the ancestry of the passed in type. This
// includes the type itself, so that e.g. a fundamental type has depth 1.
func TypeDepth(typ externglib.Type) uint {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret C.guint
	var ret1 uint

	cret = C.g_type_depth(typ)

	ret1 = C.guint(cret)

	return ret1
}

// TypeEnsure ensures that the indicated @type has been registered with the type
// system, and its _class_init() method has been run.
//
// In theory, simply calling the type's _get_type() method (or using the
// corresponding macro) is supposed take care of this. However, _get_type()
// methods are often marked G_GNUC_CONST for performance reasons, even though
// this is technically incorrect (since G_GNUC_CONST requires that the function
// not have side effects, which _get_type() methods do on the first call). As a
// result, if you write a bare call to a _get_type() macro, it may get optimized
// out by the compiler. Using g_type_ensure() guarantees that the type's
// _get_type() method is called.
func TypeEnsure(typ externglib.Type) {
	var arg1 C.GType

	arg1 := C.GType(typ)

	C.g_type_ensure(typ)
}

// TypeFreeInstance frees an instance of a type, returning it to the instance
// pool for the type, if there is one.
//
// Like g_type_create_instance(), this function is reserved for implementors of
// fundamental types.
func TypeFreeInstance(instance *TypeInstance) {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	C.g_type_free_instance(instance)
}

// TypeFromName: look up the type ID from a given type name, returning 0 if no
// type has been registered under this name (this is the preferred method to
// find out by name whether a specific type has been registered yet).
func TypeFromName(name string) externglib.Type {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_from_name(name)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeFundamental: internal function, used to extract the fundamental type ID
// portion. Use G_TYPE_FUNDAMENTAL() instead.
func TypeFundamental(typeID externglib.Type) externglib.Type {
	var arg1 C.GType

	arg1 := C.GType(typeID)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_fundamental(typeID)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeFundamentalNext returns the next free fundamental type id which can be
// used to register a new fundamental type with g_type_register_fundamental().
// The returned type ID represents the highest currently registered fundamental
// type identifier.
func TypeFundamentalNext() externglib.Type {
	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_fundamental_next()

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeGetInstanceCount returns the number of instances allocated of the
// particular type; this is only available if GLib is built with debugging
// support and the instance_count debug flag is set (by setting the
// GOBJECT_DEBUG variable to include instance-count).
func TypeGetInstanceCount(typ externglib.Type) int {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret C.int
	var ret1 int

	cret = C.g_type_get_instance_count(typ)

	ret1 = C.int(cret)

	return ret1
}

// TypeGetPlugin returns the Plugin structure for @type.
func TypeGetPlugin(typ externglib.Type) TypePlugin {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret *C.GTypePlugin
	var ret1 TypePlugin

	cret = C.g_type_get_plugin(typ)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TypePlugin)

	return ret1
}

// TypeGetTypeRegistrationSerial returns an opaque serial number that represents
// the state of the set of registered types. Any time a type is registered this
// serial changes, which means you can cache information based on type lookups
// (such as g_type_from_name()) and know if the cache is still valid at a later
// time by comparing the current serial with the one at the type lookup.
func TypeGetTypeRegistrationSerial() uint {
	var cret C.guint
	var ret1 uint

	cret = C.g_type_get_type_registration_serial()

	ret1 = C.guint(cret)

	return ret1
}

// TypeInit: this function used to initialise the type system. Since GLib 2.36,
// the type system is initialised automatically and this function does nothing.
func TypeInit() {
	C.g_type_init()
}

// TypeInitWithDebugFlags: this function used to initialise the type system with
// debugging flags. Since GLib 2.36, the type system is initialised
// automatically and this function does nothing.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
func TypeInitWithDebugFlags(debugFlags TypeDebugFlags) {
	var arg1 C.GTypeDebugFlags

	arg1 = (C.GTypeDebugFlags)(debugFlags)

	C.g_type_init_with_debug_flags(debugFlags)
}

// TypeInterfaceAddPrerequisite adds @prerequisite_type to the list of
// prerequisites of @interface_type. This means that any type implementing
// @interface_type must also implement @prerequisite_type. Prerequisites can be
// thought of as an alternative to interface derivation (which GType doesn't
// support). An interface can have at most one instantiatable prerequisite type.
func TypeInterfaceAddPrerequisite(interfaceType externglib.Type, prerequisiteType externglib.Type) {
	var arg1 C.GType
	var arg2 C.GType

	arg1 := C.GType(interfaceType)
	arg2 := C.GType(prerequisiteType)

	C.g_type_interface_add_prerequisite(interfaceType, prerequisiteType)
}

// TypeInterfaceGetPlugin returns the Plugin structure for the dynamic interface
// @interface_type which has been added to @instance_type, or nil if
// @interface_type has not been added to @instance_type or does not have a
// Plugin structure. See g_type_add_interface_dynamic().
func TypeInterfaceGetPlugin(instanceType externglib.Type, interfaceType externglib.Type) TypePlugin {
	var arg1 C.GType
	var arg2 C.GType

	arg1 := C.GType(instanceType)
	arg2 := C.GType(interfaceType)

	var cret *C.GTypePlugin
	var ret1 TypePlugin

	cret = C.g_type_interface_get_plugin(instanceType, interfaceType)

	ret1 = gextras.CastObject(externglib.Take(unsafe.Pointer(cret.Native()))).(TypePlugin)

	return ret1
}

// TypeInterfacePrerequisites returns the prerequisites of an interfaces type.
func TypeInterfacePrerequisites(interfaceType externglib.Type) (nPrerequisites uint, gTypes []externglib.Type) {
	var arg1 C.GType

	arg1 := C.GType(interfaceType)

	var cret *C.GType
	var arg2 *C.guint
	var ret2 []externglib.Type

	cret = C.g_type_interface_prerequisites(interfaceType, &arg2)

	ret2 = make([]externglib.Type, arg2)
	for i := 0; i < uintptr(arg2); i++ {
		src := (C.GType)(ptr.Add(unsafe.Pointer(cret), i))
		ret2[i] = externglib.Type(src)
	}

	return ret2, ret2
}

// TypeInterfaces: return a newly allocated and 0-terminated array of type IDs,
// listing the interface types that @type conforms to.
func TypeInterfaces(typ externglib.Type) (nInterfaces uint, gTypes []externglib.Type) {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret *C.GType
	var arg2 *C.guint
	var ret2 []externglib.Type

	cret = C.g_type_interfaces(typ, &arg2)

	ret2 = make([]externglib.Type, arg2)
	for i := 0; i < uintptr(arg2); i++ {
		src := (C.GType)(ptr.Add(unsafe.Pointer(cret), i))
		ret2[i] = externglib.Type(src)
	}

	return ret2, ret2
}

// TypeIsA: if @is_a_type is a derivable type, check whether @type is a
// descendant of @is_a_type. If @is_a_type is an interface, check whether @type
// conforms to it.
func TypeIsA(typ externglib.Type, isAType externglib.Type) bool {
	var arg1 C.GType
	var arg2 C.GType

	arg1 := C.GType(typ)
	arg2 := C.GType(isAType)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_is_a(typ, isAType)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// TypeName: get the unique name that is assigned to a type ID. Note that this
// function (like all other GType API) cannot cope with invalid type IDs.
// G_TYPE_INVALID may be passed to this function, as may be any other validly
// registered type ID, but randomized type IDs should not be passed in and will
// most likely lead to a crash.
func TypeName(typ externglib.Type) string {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret *C.gchar
	var ret1 string

	cret = C.g_type_name(typ)

	ret1 = C.GoString(cret)

	return ret1
}

func TypeNameFromInstance(instance *TypeInstance) string {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(unsafe.Pointer(instance.Native()))

	var cret *C.gchar
	var ret1 string

	cret = C.g_type_name_from_instance(instance)

	ret1 = C.GoString(cret)

	return ret1
}

// TypeNextBase: given a @leaf_type and a @root_type which is contained in its
// anchestry, return the type that @root_type is the immediate parent of. In
// other words, this function determines the type that is derived directly from
// @root_type which is also a base class of @leaf_type. Given a root type and a
// leaf type, this function can be used to determine the types and order in
// which the leaf type is descended from the root type.
func TypeNextBase(leafType externglib.Type, rootType externglib.Type) externglib.Type {
	var arg1 C.GType
	var arg2 C.GType

	arg1 := C.GType(leafType)
	arg2 := C.GType(rootType)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_next_base(leafType, rootType)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeParent: return the direct parent type of the passed in type. If the
// passed in type has no parent, i.e. is a fundamental type, 0 is returned.
func TypeParent(typ externglib.Type) externglib.Type {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_parent(typ)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeQuery queries the type system for information about a specific type. This
// function will fill in a user-provided structure to hold type-specific
// information. If an invalid #GType is passed in, the @type member of the Query
// is 0. All members filled into the Query structure should be considered
// constant and have to be left untouched.
func TypeQuery(typ externglib.Type) TypeQuery {
	var arg1 C.GType

	arg1 := C.GType(typ)

	var arg2 C.GTypeQuery
	var ret2 *TypeQuery

	C.g_type_query(typ, &arg2)

	ret2 = WrapTypeQuery(unsafe.Pointer(arg2))

	return ret2
}

// TypeRegisterDynamic registers @type_name as the name of a new dynamic type
// derived from @parent_type. The type system uses the information contained in
// the Plugin structure pointed to by @plugin to manage the type and its
// instances (if not abstract). The value of @flags determines the nature (e.g.
// abstract or not) of the type.
func TypeRegisterDynamic(parentType externglib.Type, typeName string, plugin TypePlugin, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypePlugin
	var arg4 C.GTypeFlags

	arg1 := C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypePlugin)(unsafe.Pointer(plugin.Native()))
	arg4 = (C.GTypeFlags)(flags)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_register_dynamic(parentType, typeName, plugin, flags)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeRegisterFundamental registers @type_id as the predefined identifier and
// @type_name as the name of a fundamental type. If @type_id is already
// registered, or a type named @type_name is already registered, the behaviour
// is undefined. The type system uses the information contained in the Info
// structure pointed to by @info and the FundamentalInfo structure pointed to by
// @finfo to manage the type and its instances. The value of @flags determines
// additional characteristics of the fundamental type.
func TypeRegisterFundamental(typeID externglib.Type, typeName string, info *TypeInfo, finfo *TypeFundamentalInfo, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 *C.GTypeFundamentalInfo
	var arg5 C.GTypeFlags

	arg1 := C.GType(typeID)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(unsafe.Pointer(info.Native()))
	arg4 = (*C.GTypeFundamentalInfo)(unsafe.Pointer(finfo.Native()))
	arg5 = (C.GTypeFlags)(flags)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_register_fundamental(typeID, typeName, info, finfo, flags)

	ret1 = externglib.Type(cret)

	return ret1
}

// TypeRegisterStatic registers @type_name as the name of a new static type
// derived from @parent_type. The type system uses the information contained in
// the Info structure pointed to by @info to manage the type and its instances
// (if not abstract). The value of @flags determines the nature (e.g. abstract
// or not) of the type.
func TypeRegisterStatic(parentType externglib.Type, typeName string, info *TypeInfo, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 C.GTypeFlags

	arg1 := C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(unsafe.Pointer(info.Native()))
	arg4 = (C.GTypeFlags)(flags)

	var cret C.GType
	var ret1 externglib.Type

	cret = C.g_type_register_static(parentType, typeName, info, flags)

	ret1 = externglib.Type(cret)

	return ret1
}

func TypeTestFlags(typ externglib.Type, flags uint) bool {
	var arg1 C.GType
	var arg2 C.guint

	arg1 := C.GType(typ)
	arg2 = C.guint(flags)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_type_test_flags(typ, flags)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// InterfaceInfo: a structure that provides information to the type system which
// is used specifically for managing interface types.
type InterfaceInfo struct {
	native C.GInterfaceInfo
}

// WrapInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInterfaceInfo(ptr unsafe.Pointer) *InterfaceInfo {
	if ptr == nil {
		return nil
	}

	return (*InterfaceInfo)(ptr)
}

func marshalInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInterfaceInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *InterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// InterfaceData gets the field inside the struct.
func (i *InterfaceInfo) InterfaceData() interface{} {
	v = C.gpointer(i.native.interface_data)
}

// TypeFundamentalInfo: a structure that provides information to the type system
// which is used specifically for managing fundamental types.
type TypeFundamentalInfo struct {
	native C.GTypeFundamentalInfo
}

// WrapTypeFundamentalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeFundamentalInfo(ptr unsafe.Pointer) *TypeFundamentalInfo {
	if ptr == nil {
		return nil
	}

	return (*TypeFundamentalInfo)(ptr)
}

func marshalTypeFundamentalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeFundamentalInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeFundamentalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TypeFlags gets the field inside the struct.
func (t *TypeFundamentalInfo) TypeFlags() TypeFundamentalFlags {
	v = TypeFundamentalFlags(t.native.type_flags)
}

// TypeInfo: this structure is used to provide the type system with the
// information required to initialize and destruct (finalize) a type's class and
// its instances.
//
// The initialized structure is passed to the g_type_register_static() function
// (or is copied into the provided Info structure in the
// g_type_plugin_complete_type_info()). The type system will perform a deep copy
// of this structure, so its memory does not need to be persistent across
// invocation of g_type_register_static().
type TypeInfo struct {
	native C.GTypeInfo
}

// WrapTypeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInfo(ptr unsafe.Pointer) *TypeInfo {
	if ptr == nil {
		return nil
	}

	return (*TypeInfo)(ptr)
}

func marshalTypeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// ClassSize gets the field inside the struct.
func (t *TypeInfo) ClassSize() uint16 {
	v = C.guint16(t.native.class_size)
}

// ClassData gets the field inside the struct.
func (t *TypeInfo) ClassData() interface{} {
	v = C.gpointer(t.native.class_data)
}

// InstanceSize gets the field inside the struct.
func (t *TypeInfo) InstanceSize() uint16 {
	v = C.guint16(t.native.instance_size)
}

// NPreallocs gets the field inside the struct.
func (t *TypeInfo) NPreallocs() uint16 {
	v = C.guint16(t.native.n_preallocs)
}

// TypeInstance: an opaque structure used as the base of all type instances.
type TypeInstance struct {
	native C.GTypeInstance
}

// WrapTypeInstance wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInstance(ptr unsafe.Pointer) *TypeInstance {
	if ptr == nil {
		return nil
	}

	return (*TypeInstance)(ptr)
}

func marshalTypeInstance(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeInstance(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeInstance) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

func (i *TypeInstance) Private(privateType externglib.Type) interface{} {
	var arg0 *C.GTypeInstance
	var arg1 C.GType

	arg0 = (*C.GTypeInstance)(unsafe.Pointer(i.Native()))
	arg1 := C.GType(privateType)

	var cret C.gpointer
	var ret1 interface{}

	cret = C.g_type_instance_get_private(arg0, privateType)

	ret1 = C.gpointer(cret)

	return ret1
}

// TypeQuery: a structure holding information for a specific type. It is filled
// in by the g_type_query() function.
type TypeQuery struct {
	native C.GTypeQuery
}

// WrapTypeQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeQuery(ptr unsafe.Pointer) *TypeQuery {
	if ptr == nil {
		return nil
	}

	return (*TypeQuery)(ptr)
}

func marshalTypeQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Type gets the field inside the struct.
func (t *TypeQuery) Type() externglib.Type {
	v = externglib.Type(t.native._type)
}

// TypeName gets the field inside the struct.
func (t *TypeQuery) TypeName() string {
	v = C.GoString(t.native.type_name)
}

// ClassSize gets the field inside the struct.
func (t *TypeQuery) ClassSize() uint {
	v = C.guint(t.native.class_size)
}

// InstanceSize gets the field inside the struct.
func (t *TypeQuery) InstanceSize() uint {
	v = C.guint(t.native.instance_size)
}
