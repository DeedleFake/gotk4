// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
//
// extern gboolean gotk4_BindingTransformFunc(GBinding* _0, const GValue* _1, GValue* _2, gpointer _3);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_binding_flags_get_type()), F: marshalBindingFlags},
		{T: externglib.Type(C.g_type_plugin_get_type()), F: marshalTypePlugin},
		{T: externglib.Type(C.g_value_array_get_type()), F: marshalValueArray},
		{T: externglib.Type(C.g_binding_get_type()), F: marshalBinding},
		{T: externglib.Type(C.g_type_module_get_type()), F: marshalTypeModule},
	})
}

// SignalCMarshaller: this is the signature of marshaller functions, required to
// marshall arrays of parameter values to signal emissions into C language
// callback invocations. It is merely an alias to Marshal since the #GClosure
// mechanism takes over responsibility of actual function invocation for the
// signal system.
type SignalCMarshaller ClosureMarshal

// SignalCVaMarshaller: this is the signature of va_list marshaller functions,
// an optional marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type SignalCVaMarshaller VaClosureMarshal

// BindingFlags flags to be passed to g_object_bind_property() or
// g_object_bind_property_full().
//
// This enumeration can be extended at later date.
type BindingFlags int

const (
	// BindingFlagsDefault: the default binding; if the source property changes,
	// the target property is updated with its value.
	BindingFlagsDefault BindingFlags = 0b0
	// BindingFlagsBidirectional: bidirectional binding; if either the property
	// of the source or the property of the target changes, the other is
	// updated.
	BindingFlagsBidirectional BindingFlags = 0b1
	// BindingFlagsSyncCreate: synchronize the values of the source and target
	// properties when creating the binding; the direction of the
	// synchronization is always from the source to the target.
	BindingFlagsSyncCreate BindingFlags = 0b10
	// BindingFlagsInvertBoolean: if the two properties being bound are
	// booleans, setting one to true will result in the other being set to false
	// and vice versa. This flag will only work for boolean properties, and
	// cannot be used when passing custom transformation functions to
	// g_object_bind_property_full().
	BindingFlagsInvertBoolean BindingFlags = 0b100
)

func marshalBindingFlags(p uintptr) (interface{}, error) {
	return BindingFlags(C.g_value_get_bitfield((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ConnectFlags: the connection flags are used to specify the behaviour of a
// signal's connection.
type ConnectFlags int

const (
	// ConnectFlagsAfter: whether the handler should be called before or after
	// the default handler of the signal.
	ConnectFlagsAfter ConnectFlags = 0b1
	// ConnectFlagsSwapped: whether the instance and data should be swapped when
	// calling the handler; see g_signal_connect_swapped() for an example.
	ConnectFlagsSwapped ConnectFlags = 0b10
)

// ParamFlags: through the Flags flag values, certain aspects of parameters can
// be configured. See also PARAM_STATIC_STRINGS.
type ParamFlags int

const (
	// ParamFlagsReadable: the parameter is readable
	ParamFlagsReadable ParamFlags = 0b1
	// ParamFlagsWritable: the parameter is writable
	ParamFlagsWritable ParamFlags = 0b10
	// ParamFlagsReadwrite alias for G_PARAM_READABLE | G_PARAM_WRITABLE
	ParamFlagsReadwrite ParamFlags = 0b11
	// ParamFlagsConstruct: the parameter will be set upon object construction
	ParamFlagsConstruct ParamFlags = 0b100
	// ParamFlagsConstructOnly: the parameter can only be set upon object
	// construction
	ParamFlagsConstructOnly ParamFlags = 0b1000
	// ParamFlagsLaxValidation: upon parameter conversion (see
	// g_param_value_convert()) strict validation is not required
	ParamFlagsLaxValidation ParamFlags = 0b10000
	// ParamFlagsStaticName: the string used as name when constructing the
	// parameter is guaranteed to remain valid and unmodified for the lifetime
	// of the parameter. Since 2.8
	ParamFlagsStaticName ParamFlags = 0b100000
	// ParamFlagsPrivate: internal
	ParamFlagsPrivate ParamFlags = 0b100000
	// ParamFlagsStaticNick: the string used as nick when constructing the
	// parameter is guaranteed to remain valid and unmmodified for the lifetime
	// of the parameter. Since 2.8
	ParamFlagsStaticNick ParamFlags = 0b1000000
	// ParamFlagsStaticBlurb: the string used as blurb when constructing the
	// parameter is guaranteed to remain valid and unmodified for the lifetime
	// of the parameter. Since 2.8
	ParamFlagsStaticBlurb ParamFlags = 0b10000000
	// ParamFlagsExplicitNotify calls to g_object_set_property() for this
	// property will not automatically result in a "notify" signal being
	// emitted: the implementation must call g_object_notify() themselves in
	// case the property actually changes. Since: 2.42.
	ParamFlagsExplicitNotify ParamFlags = 0b1000000000000000000000000000000
	// ParamFlagsDeprecated: the parameter is deprecated and will be removed in
	// a future version. A warning will be generated if it is used while running
	// with G_ENABLE_DIAGNOSTIC=1. Since 2.26
	ParamFlagsDeprecated ParamFlags = 0b10000000000000000000000000000000
)

// SignalFlags: the signal flags are used to specify a signal's behaviour, the
// overall signal description outlines how especially the RUN flags control the
// stages of a signal emission.
type SignalFlags int

const (
	// SignalFlagsRunFirst: invoke the object method handler in the first
	// emission stage.
	SignalFlagsRunFirst SignalFlags = 0b1
	// SignalFlagsRunLast: invoke the object method handler in the third
	// emission stage.
	SignalFlagsRunLast SignalFlags = 0b10
	// SignalFlagsRunCleanup: invoke the object method handler in the last
	// emission stage.
	SignalFlagsRunCleanup SignalFlags = 0b100
	// SignalFlagsNoRecurse signals being emitted for an object while currently
	// being in emission for this very object will not be emitted recursively,
	// but instead cause the first emission to be restarted.
	SignalFlagsNoRecurse SignalFlags = 0b1000
	// SignalFlagsDetailed: this signal supports "::detail" appendices to the
	// signal name upon handler connections and emissions.
	SignalFlagsDetailed SignalFlags = 0b10000
	// SignalFlagsAction: action signals are signals that may freely be emitted
	// on alive objects from user code via g_signal_emit() and friends, without
	// the need of being embedded into extra code that performs pre or post
	// emission adjustments on the object. They can also be thought of as object
	// methods which can be called generically by third-party code.
	SignalFlagsAction SignalFlags = 0b100000
	// SignalFlagsNoHooks: no emissions hooks are supported for this signal.
	SignalFlagsNoHooks SignalFlags = 0b1000000
	// SignalFlagsMustCollect varargs signal emission will always collect the
	// arguments, even if there are no signal handlers connected. Since 2.30.
	SignalFlagsMustCollect SignalFlags = 0b10000000
	// SignalFlagsDeprecated: the signal is deprecated and will be removed in a
	// future version. A warning will be generated if it is connected while
	// running with G_ENABLE_DIAGNOSTIC=1. Since 2.32.
	SignalFlagsDeprecated SignalFlags = 0b100000000
)

// SignalMatchType: the match types specify what
// g_signal_handlers_block_matched(), g_signal_handlers_unblock_matched() and
// g_signal_handlers_disconnect_matched() match signals by.
type SignalMatchType int

const (
	// SignalMatchTypeID: the signal id must be equal.
	SignalMatchTypeID SignalMatchType = 0b1
	// SignalMatchTypeDetail: the signal detail must be equal.
	SignalMatchTypeDetail SignalMatchType = 0b10
	// SignalMatchTypeClosure: the closure must be the same.
	SignalMatchTypeClosure SignalMatchType = 0b100
	// SignalMatchTypeFunc: the C closure callback must be the same.
	SignalMatchTypeFunc SignalMatchType = 0b1000
	// SignalMatchTypeData: the closure data must be the same.
	SignalMatchTypeData SignalMatchType = 0b10000
	// SignalMatchTypeUnblocked: only unblocked signals may be matched.
	SignalMatchTypeUnblocked SignalMatchType = 0b100000
)

// TypeDebugFlags: these flags used to be passed to
// g_type_init_with_debug_flags() which is now deprecated.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
type TypeDebugFlags int

const (
	// TypeDebugFlagsNone: print no messages
	TypeDebugFlagsNone TypeDebugFlags = 0b0
	// TypeDebugFlagsObjects: print messages about object bookkeeping
	TypeDebugFlagsObjects TypeDebugFlags = 0b1
	// TypeDebugFlagsSignals: print messages about signal emissions
	TypeDebugFlagsSignals TypeDebugFlags = 0b10
	// TypeDebugFlagsInstanceCount: keep a count of instances of each type
	TypeDebugFlagsInstanceCount TypeDebugFlags = 0b100
	// TypeDebugFlagsMask: mask covering all debug flags
	TypeDebugFlagsMask TypeDebugFlags = 0b111
)

// TypeFlags: bit masks used to check or determine characteristics of a type.
type TypeFlags int

const (
	// TypeFlagsAbstract indicates an abstract type. No instances can be created
	// for an abstract type
	TypeFlagsAbstract TypeFlags = 0b10000
	// TypeFlagsValueAbstract indicates an abstract value type, i.e. a type that
	// introduces a value table, but can't be used for g_value_init()
	TypeFlagsValueAbstract TypeFlags = 0b100000
)

// TypeFundamentalFlags: bit masks used to check or determine specific
// characteristics of a fundamental type.
type TypeFundamentalFlags int

const (
	// TypeFundamentalFlagsClassed indicates a classed type
	TypeFundamentalFlagsClassed TypeFundamentalFlags = 0b1
	// TypeFundamentalFlagsInstantiatable indicates an instantiable type
	// (implies classed)
	TypeFundamentalFlagsInstantiatable TypeFundamentalFlags = 0b10
	// TypeFundamentalFlagsDerivable indicates a flat derivable type
	TypeFundamentalFlagsDerivable TypeFundamentalFlags = 0b100
	// TypeFundamentalFlagsDeepDerivable indicates a deep derivable type
	// (implies derivable)
	TypeFundamentalFlagsDeepDerivable TypeFundamentalFlags = 0b1000
)

// BindingTransformFunc: a function to be called to transform @from_value to
// @to_value. If this is the @transform_to function of a binding, then
// @from_value is the @source_property on the @source object, and @to_value is
// the @target_property on the @target object. If this is the @transform_from
// function of a G_BINDING_BIDIRECTIONAL binding, then those roles are reversed.
type BindingTransformFunc func(binding Binding, fromValue *externglib.Value, toValue *externglib.Value) bool

//export gotk4_BindingTransformFunc
func gotk4_BindingTransformFunc(arg0 *C.GBinding, arg1 *C.GValue, arg2 *C.GValue, arg3 C.gpointer) C.gboolean {
	v := box.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var binding Binding
	var fromValue *externglib.Value
	var toValue *externglib.Value

	binding = gextras.CastObject(externglib.Take(unsafe.Pointer(arg0.Native()))).(Binding)

	fromValue = externglib.ValueFromNative(unsafe.Pointer(arg1))

	toValue = externglib.ValueFromNative(unsafe.Pointer(arg2))

	ok := v.(BindingTransformFunc)(binding, fromValue, toValue)
}

// BoxedCopy: provide a copy of a boxed structure @src_boxed which is of type
// @boxed_type.
func BoxedCopy(boxedType externglib.Type, srcBoxed interface{}) interface{} {
	var arg1 C.GType
	var arg2 C.gpointer

	arg1 = C.GType(boxedType)
	arg2 = C.gpointer(box.Assign(srcBoxed))

	ret := C.g_boxed_copy(arg1, arg2)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// BoxedFree: free the boxed structure @boxed which is of type @boxed_type.
func BoxedFree(boxedType externglib.Type, boxed interface{}) {
	var arg1 C.GType
	var arg2 C.gpointer

	arg1 = C.GType(boxedType)
	arg2 = C.gpointer(box.Assign(boxed))

	C.g_boxed_free(arg1, arg2)
}

// ClearObject clears a reference to a #GObject.
//
// @object_ptr must not be nil.
//
// If the reference is nil then this function does nothing. Otherwise, the
// reference count of the object is decreased and the pointer is set to nil.
//
// A macro is also included that allows this function to be used without pointer
// casts.
func ClearObject(objectPtr gextras.Objector) {
	var arg1 **C.GObject

	arg1 = (*C.GObject)(objectPtr.Native())

	C.g_clear_object(arg1)
}

// ClearSignalHandler disconnects a handler from @instance so it will not be
// called during any future or currently ongoing emissions of the signal it has
// been connected to. The @handler_id_ptr is then set to zero, which is never a
// valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// A macro is also included that allows this function to be used without pointer
// casts.
func ClearSignalHandler(handlerIDPtr uint32, instance gextras.Objector) {
	var arg1 *C.gulong
	var arg2 C.gpointer

	arg1 = (*C.gulong)(handlerIDPtr)
	arg2 = (*C.GObject)(instance.Native())

	C.g_clear_signal_handler(arg1, arg2)
}

// EnumCompleteTypeInfo: this function is meant to be called from the
// `complete_type_info` function of a Plugin implementation, as in the following
// example:
//
//    static void
//    my_enum_complete_type_info (GTypePlugin     *plugin,
//                                GType            g_type,
//                                GTypeInfo       *info,
//                                GTypeValueTable *value_table)
//    {
//      static const GEnumValue values[] = {
//        { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
//        { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
//        { 0, NULL, NULL }
//      };
//
//      g_enum_complete_type_info (type, info, values);
//    }
func EnumCompleteTypeInfo(gEnumType externglib.Type, constValues *EnumValue) TypeInfo {
	var arg1 C.GType
	var arg2 *C.GTypeInfo // out
	var arg3 *C.GEnumValue

	arg1 = C.GType(gEnumType)
	arg3 = (*C.GEnumValue)(constValues.Native())

	C.g_enum_complete_type_info(arg1, &arg2, arg3)

	var ret0 *TypeInfo

	{
		ret0 = WrapTypeInfo(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v *TypeInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// EnumRegisterStatic registers a new static enumeration type with the name
// @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums], generate
// a my_enum_get_type() function from a usual C enumeration definition than to
// write one yourself using g_enum_register_static().
func EnumRegisterStatic(name string, constStaticValues *EnumValue) externglib.Type {
	var arg1 *C.gchar
	var arg2 *C.GEnumValue

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GEnumValue)(constStaticValues.Native())

	ret := C.g_enum_register_static(arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// EnumToString pretty-prints @value in the form of the enum’s name.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func EnumToString(gEnumType externglib.Type, value int) string {
	var arg1 C.GType
	var arg2 C.gint

	arg1 = C.GType(gEnumType)
	arg2 = C.gint(value)

	ret := C.g_enum_to_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FlagsCompleteTypeInfo: this function is meant to be called from the
// complete_type_info() function of a Plugin implementation, see the example for
// g_enum_complete_type_info() above.
func FlagsCompleteTypeInfo(gFlagsType externglib.Type, constValues *FlagsValue) TypeInfo {
	var arg1 C.GType
	var arg2 *C.GTypeInfo // out
	var arg3 *C.GFlagsValue

	arg1 = C.GType(gFlagsType)
	arg3 = (*C.GFlagsValue)(constValues.Native())

	C.g_flags_complete_type_info(arg1, &arg2, arg3)

	var ret0 *TypeInfo

	{
		ret0 = WrapTypeInfo(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v *TypeInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FlagsRegisterStatic registers a new static flags type with the name @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums] generate a
// my_flags_get_type() function from a usual C enumeration definition than to
// write one yourself using g_flags_register_static().
func FlagsRegisterStatic(name string, constStaticValues *FlagsValue) externglib.Type {
	var arg1 *C.gchar
	var arg2 *C.GFlagsValue

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GFlagsValue)(constStaticValues.Native())

	ret := C.g_flags_register_static(arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// FlagsToString pretty-prints @value in the form of the flag names separated by
// ` | ` and sorted. Any extra bits will be shown at the end as a hexadecimal
// number.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func FlagsToString(flagsType externglib.Type, value uint) string {
	var arg1 C.GType
	var arg2 C.guint

	arg1 = C.GType(flagsType)
	arg2 = C.guint(value)

	ret := C.g_flags_to_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

func GTypeGetType() externglib.Type {

	ret := C.g_gtype_get_type()

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// ParamSpecBoolean creates a new SpecBoolean instance specifying a
// G_TYPE_BOOLEAN property. In many cases, it may be more appropriate to use an
// enum with g_param_spec_enum(), both to improve code clarity by using
// explicitly named values, and to allow for more values to be added in future
// without breaking API.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecBoolean(name string, nick string, blurb string, defaultValue bool, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gboolean
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	if defaultValue {
		arg4 = C.TRUE
	}
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_boolean(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecBoxed creates a new SpecBoxed instance specifying a G_TYPE_BOXED
// derived property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecBoxed(name string, nick string, blurb string, boxedType externglib.Type, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(boxedType)
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_boxed(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecChar creates a new SpecChar instance specifying a G_TYPE_CHAR
// property.
func ParamSpecChar(name string, nick string, blurb string, minimum int8, maximum int8, defaultValue int8, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gint8
	var arg5 C.gint8
	var arg6 C.gint8
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint8(minimum)
	arg5 = C.gint8(maximum)
	arg6 = C.gint8(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_char(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecDouble creates a new SpecDouble instance specifying a G_TYPE_DOUBLE
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecDouble(name string, nick string, blurb string, minimum float64, maximum float64, defaultValue float64, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gdouble
	var arg5 C.gdouble
	var arg6 C.gdouble
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gdouble(minimum)
	arg5 = C.gdouble(maximum)
	arg6 = C.gdouble(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_double(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecEnum creates a new SpecEnum instance specifying a G_TYPE_ENUM
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecEnum(name string, nick string, blurb string, enumType externglib.Type, defaultValue int, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.gint
	var arg6 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(enumType)
	arg5 = C.gint(defaultValue)
	arg6 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_enum(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecFlags creates a new SpecFlags instance specifying a G_TYPE_FLAGS
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecFlags(name string, nick string, blurb string, flagsType externglib.Type, defaultValue uint, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.guint
	var arg6 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(flagsType)
	arg5 = C.guint(defaultValue)
	arg6 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_flags(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecFloat creates a new SpecFloat instance specifying a G_TYPE_FLOAT
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecFloat(name string, nick string, blurb string, minimum float32, maximum float32, defaultValue float32, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gfloat
	var arg5 C.gfloat
	var arg6 C.gfloat
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gfloat(minimum)
	arg5 = C.gfloat(maximum)
	arg6 = C.gfloat(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_float(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecGType creates a new SpecGType instance specifying a G_TYPE_GTYPE
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecGType(name string, nick string, blurb string, isAType externglib.Type, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(isAType)
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_gtype(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecInt creates a new SpecInt instance specifying a G_TYPE_INT property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecInt(name string, nick string, blurb string, minimum int, maximum int, defaultValue int, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gint
	var arg5 C.gint
	var arg6 C.gint
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint(minimum)
	arg5 = C.gint(maximum)
	arg6 = C.gint(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_int(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecInt64 creates a new SpecInt64 instance specifying a G_TYPE_INT64
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecInt64(name string, nick string, blurb string, minimum int64, maximum int64, defaultValue int64, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gint64
	var arg5 C.gint64
	var arg6 C.gint64
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gint64(minimum)
	arg5 = C.gint64(maximum)
	arg6 = C.gint64(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_int64(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecLong creates a new SpecLong instance specifying a G_TYPE_LONG
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecLong(name string, nick string, blurb string, minimum int32, maximum int32, defaultValue int32, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.glong
	var arg5 C.glong
	var arg6 C.glong
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.glong(minimum)
	arg5 = C.glong(maximum)
	arg6 = C.glong(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_long(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecObject creates a new SpecBoxed instance specifying a G_TYPE_OBJECT
// derived property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecObject(name string, nick string, blurb string, objectType externglib.Type, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(objectType)
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_object(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecOverride creates a new property of type SpecOverride. This is used
// to direct operations to another paramspec, and will not be directly useful
// unless you are implementing a new base type similar to GObject.
func ParamSpecOverride(name string, overridden ParamSpec) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.GParamSpec

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GParamSpec)(overridden.Native())

	ret := C.g_param_spec_override(arg1, arg2)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecParam creates a new SpecParam instance specifying a G_TYPE_PARAM
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecParam(name string, nick string, blurb string, paramType externglib.Type, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GType
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.GType(paramType)
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_param(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecPointer creates a new SpecPointer instance specifying a pointer
// property. Where possible, it is better to use g_param_spec_object() or
// g_param_spec_boxed() to expose memory management information.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecPointer(name string, nick string, blurb string, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_pointer(arg1, arg2, arg3, arg4)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// NewParamSpecPool creates a new SpecPool.
//
// If @type_prefixing is true, lookups in the newly created pool will allow to
// specify the owner as a colon-separated prefix of the property name, like
// "GtkContainer:border-width". This feature is deprecated, so you should always
// set @type_prefixing to false.
func NewParamSpecPool(typePrefixing bool) *ParamSpecPool {
	var arg1 C.gboolean

	if typePrefixing {
		arg1 = C.TRUE
	}

	ret := C.g_param_spec_pool_new(arg1)

	var ret0 *ParamSpecPool

	{
		ret0 = WrapParamSpecPool(unsafe.Pointer(ret))
	}

	return ret0
}

// ParamSpecString creates a new SpecString instance.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecString(name string, nick string, blurb string, defaultValue string, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.gchar
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.gchar)(C.CString(defaultValue))
	defer C.free(unsafe.Pointer(arg4))
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_string(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecUchar creates a new SpecUChar instance specifying a G_TYPE_UCHAR
// property.
func ParamSpecUchar(name string, nick string, blurb string, minimum byte, maximum byte, defaultValue byte, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.guint8
	var arg5 C.guint8
	var arg6 C.guint8
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.guint8(minimum)
	arg5 = C.guint8(maximum)
	arg6 = C.guint8(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_uchar(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecUint creates a new SpecUInt instance specifying a G_TYPE_UINT
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecUint(name string, nick string, blurb string, minimum uint, maximum uint, defaultValue uint, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.guint
	var arg5 C.guint
	var arg6 C.guint
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.guint(minimum)
	arg5 = C.guint(maximum)
	arg6 = C.guint(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_uint(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecUint64 creates a new SpecUInt64 instance specifying a G_TYPE_UINT64
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecUint64(name string, nick string, blurb string, minimum uint64, maximum uint64, defaultValue uint64, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.guint64
	var arg5 C.guint64
	var arg6 C.guint64
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.guint64(minimum)
	arg5 = C.guint64(maximum)
	arg6 = C.guint64(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_uint64(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecUlong creates a new SpecULong instance specifying a G_TYPE_ULONG
// property.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecUlong(name string, nick string, blurb string, minimum uint32, maximum uint32, defaultValue uint32, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gulong
	var arg5 C.gulong
	var arg6 C.gulong
	var arg7 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gulong(minimum)
	arg5 = C.gulong(maximum)
	arg6 = C.gulong(defaultValue)
	arg7 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_ulong(arg1, arg2, arg3, arg4, arg5, arg6, arg7)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecUnichar creates a new SpecUnichar instance specifying a G_TYPE_UINT
// property. #GValue structures for this property can be accessed with
// g_value_set_uint() and g_value_get_uint().
//
// See g_param_spec_internal() for details on property names.
func ParamSpecUnichar(name string, nick string, blurb string, defaultValue uint32, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 C.gunichar
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = C.gunichar(defaultValue)
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_unichar(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecValueArray creates a new SpecValueArray instance specifying a
// G_TYPE_VALUE_ARRAY property. G_TYPE_VALUE_ARRAY is a G_TYPE_BOXED type, as
// such, #GValue structures for this property can be accessed with
// g_value_set_boxed() and g_value_get_boxed().
//
// See g_param_spec_internal() for details on property names.
func ParamSpecValueArray(name string, nick string, blurb string, elementSpec ParamSpec, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.GParamSpec
	var arg5 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GParamSpec)(elementSpec.Native())
	arg5 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_value_array(arg1, arg2, arg3, arg4, arg5)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamSpecVariant creates a new SpecVariant instance specifying a #GVariant
// property.
//
// If @default_value is floating, it is consumed.
//
// See g_param_spec_internal() for details on property names.
func ParamSpecVariant(name string, nick string, blurb string, typ *glib.VariantType, defaultValue *glib.Variant, flags ParamFlags) ParamSpec {
	var arg1 *C.gchar
	var arg2 *C.gchar
	var arg3 *C.gchar
	var arg4 *C.GVariantType
	var arg5 *C.GVariant
	var arg6 C.GParamFlags

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.gchar)(C.CString(nick))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.gchar)(C.CString(blurb))
	defer C.free(unsafe.Pointer(arg3))
	arg4 = (*C.GVariantType)(typ.Native())
	arg5 = (*C.GVariant)(defaultValue.Native())
	arg6 = (C.GParamFlags)(flags)

	ret := C.g_param_spec_variant(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// ParamValueConvert transforms @src_value into @dest_value if possible, and
// then validates @dest_value, in order for it to conform to @pspec. If
// @strict_validation is true this function will only succeed if the transformed
// @dest_value complied to @pspec without modifications.
//
// See also g_value_type_transformable(), g_value_transform() and
// g_param_value_validate().
func ParamValueConvert(pspec ParamSpec, srcValue *externglib.Value, destValue *externglib.Value, strictValidation bool) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gboolean

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GValue)(srcValue.GValue)
	arg3 = (*C.GValue)(destValue.GValue)
	if strictValidation {
		arg4 = C.TRUE
	}

	ret := C.g_param_value_convert(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ParamValueDefaults checks whether @value contains the default value as
// specified in @pspec.
func ParamValueDefaults(pspec ParamSpec, value *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GValue)(value.GValue)

	ret := C.g_param_value_defaults(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ParamValueSetDefault sets @value to its default value as specified in @pspec.
func ParamValueSetDefault(pspec ParamSpec, value *externglib.Value) {
	var arg1 *C.GParamSpec
	var arg2 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GValue)(value.GValue)

	C.g_param_value_set_default(arg1, arg2)
}

// ParamValueValidate ensures that the contents of @value comply with the
// specifications set out by @pspec. For example, a SpecInt might require that
// integers stored in @value may not be smaller than -42 and not be greater than
// +42. If @value contains an integer outside of this range, it is modified
// accordingly, so the resulting value will fit into the range -42 .. +42.
func ParamValueValidate(pspec ParamSpec, value *externglib.Value) bool {
	var arg1 *C.GParamSpec
	var arg2 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GValue)(value.GValue)

	ret := C.g_param_value_validate(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ParamValuesCmp compares @value1 with @value2 according to @pspec, and return
// -1, 0 or +1, if @value1 is found to be less than, equal to or greater than
// @value2, respectively.
func ParamValuesCmp(pspec ParamSpec, value1 *externglib.Value, value2 *externglib.Value) int {
	var arg1 *C.GParamSpec
	var arg2 *C.GValue
	var arg3 *C.GValue

	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = (*C.GValue)(value1.GValue)
	arg3 = (*C.GValue)(value2.GValue)

	ret := C.g_param_values_cmp(arg1, arg2, arg3)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// PointerTypeRegisterStatic creates a new G_TYPE_POINTER derived type id for a
// new pointer type with name @name.
func PointerTypeRegisterStatic(name string) externglib.Type {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_pointer_type_register_static(arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// SignalAccumulatorFirstWins: a predefined Accumulator for signals intended to
// be used as a hook for application code to provide a particular value. Usually
// only one such value is desired and multiple handlers for the same signal
// don't make much sense (except for the case of the default handler defined in
// the class structure, in which case you will usually want the signal
// connection to override the class handler).
//
// This accumulator will use the return value from the first signal handler that
// is run as the return value for the signal and not run any further handlers
// (ie: the first handler "wins").
func SignalAccumulatorFirstWins(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(ihint.Native())
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(box.Assign(dummy))

	ret := C.g_signal_accumulator_first_wins(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SignalAccumulatorTrueHandled: a predefined Accumulator for signals that
// return a boolean values. The behavior that this accumulator gives is that a
// return of true stops the signal emission: no further callbacks will be
// invoked, while a return of false allows the emission to continue. The idea
// here is that a true return indicates that the callback handled the signal,
// and no further handling is needed.
func SignalAccumulatorTrueHandled(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(ihint.Native())
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(box.Assign(dummy))

	ret := C.g_signal_accumulator_true_handled(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SignalGetInvocationHint returns the invocation hint of the innermost signal
// emission of instance.
func SignalGetInvocationHint(instance gextras.Objector) *SignalInvocationHint {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(instance.Native())

	ret := C.g_signal_get_invocation_hint(arg1)

	var ret0 *SignalInvocationHint

	{
		ret0 = WrapSignalInvocationHint(unsafe.Pointer(ret))
	}

	return ret0
}

// SignalHandlerBlock blocks a handler of an instance so it will not be called
// during any signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler has to be
// unblocked exactly the same amount of times it has been blocked before to
// become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerBlock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_block(arg1, arg2)
}

// SignalHandlerDisconnect disconnects a handler from an instance so it will not
// be called during any future or currently ongoing emissions of the signal it
// has been connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerDisconnect(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_disconnect(arg1, arg2)
}

// SignalHandlerIsConnected returns whether @handler_id is the ID of a handler
// connected to @instance.
func SignalHandlerIsConnected(instance gextras.Objector, handlerID uint32) bool {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	ret := C.g_signal_handler_is_connected(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SignalHandlerUnblock undoes the effect of a previous g_signal_handler_block()
// call. A blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been blocked
// before) reverts its "blocked" state, so the handler will be recognized by the
// signal system and is called upon future or currently ongoing signal emissions
// (since the order in which handlers are called during signal emissions is
// deterministic, whether the unblocked handler in question is called as part of
// a currently ongoing emission depends on how far that emission has proceeded
// yet).
//
// The @handler_id has to be a valid id of a signal handler that is connected to
// a signal of @instance and is currently blocked.
func SignalHandlerUnblock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_unblock(arg1, arg2)
}

// SignalHandlersDestroy: destroy all signal handlers of a type instance. This
// function is an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(instance gextras.Objector) {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(instance.Native())

	C.g_signal_handlers_destroy(arg1)
}

// SignalIsValidName: validate a signal name. This can be useful for
// dynamically-generated signals which need to be validated at run-time before
// actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of the
// rules for valid names. The rules for signal names are the same as those for
// property names.
func SignalIsValidName(name string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_signal_is_valid_name(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// SignalListIds lists the signals by id that a certain instance or interface
// type created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIds(itype externglib.Type) (nIds uint, guints []uint) {
	var arg1 C.GType
	var arg2 *C.guint // out

	arg1 = C.GType(itype)

	ret := C.g_signal_list_ids(arg1, &arg2)

	var ret0 uint
	var ret1 []uint

	ret0 = uint(arg2)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// SignalLookup: given the name of the signal and the type of object it connects
// to, gets the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype externglib.Type) uint {
	var arg1 *C.gchar
	var arg2 C.GType

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(itype)

	ret := C.g_signal_lookup(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SignalName: given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(signalID uint) string {
	var arg1 C.guint

	arg1 = C.guint(signalID)

	ret := C.g_signal_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SignalParseName: internal function to parse a signal name into its @signal_id
// and @detail quark.
func SignalParseName(detailedSignal string, itype externglib.Type, forceDetailQuark bool) (signalIDP uint, detailP glib.Quark, ok bool) {
	var arg1 *C.gchar
	var arg2 C.GType
	var arg3 *C.guint  // out
	var arg4 *C.GQuark // out
	var arg5 C.gboolean

	arg1 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(itype)
	if forceDetailQuark {
		arg5 = C.TRUE
	}

	ret := C.g_signal_parse_name(arg1, arg2, &arg3, &arg4, arg5)

	var ret0 uint
	var ret1 *glib.Quark
	var ret2 bool

	ret0 = uint(arg3)

	{
		var tmp uint32
		tmp = uint32(arg4)
		ret1 = *glib.Quark(tmp)
	}

	ret2 = C.BOOL(ret) != 0

	return ret0, ret1, ret2
}

// SignalQuery queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided structure to hold
// signal-specific information. If an invalid signal id is passed in, the
// @signal_id member of the Query is 0. All members filled into the Query
// structure should be considered constant and have to be left untouched.
func SignalQuery(signalID uint) SignalQuery {
	var arg1 C.guint
	var arg2 *C.GSignalQuery // out

	arg1 = C.guint(signalID)

	C.g_signal_query(arg1, &arg2)

	var ret0 *SignalQuery

	{
		ret0 = WrapSignalQuery(unsafe.Pointer(arg2))
	}

	return ret0
}

// SignalRemoveEmissionHook deletes an emission hook.
func SignalRemoveEmissionHook(signalID uint, hookID uint32) {
	var arg1 C.guint
	var arg2 C.gulong

	arg1 = C.guint(signalID)
	arg2 = C.gulong(hookID)

	C.g_signal_remove_emission_hook(arg1, arg2)
}

// SignalStopEmissionByName stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the signal
// id for you.
func SignalStopEmissionByName(instance gextras.Objector, detailedSignal string) {
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg1 = (*C.GObject)(instance.Native())
	arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg2))

	C.g_signal_stop_emission_by_name(arg1, arg2)
}

// SourceSetDummyCallback sets a dummy callback for @source. The callback will
// do nothing, and if the source expects a #gboolean return value, it will
// return true. (If the source expects any other type of return value, it will
// return a 0/nil value; whatever g_value_init() initializes a #GValue to for
// that type.)
//
// If the source is not one of the standard GLib types, the @closure_callback
// and @closure_marshal fields of the Funcs structure must have been filled in
// with pointers to appropriate functions.
func SourceSetDummyCallback(source *glib.Source) {
	var arg1 *C.GSource

	arg1 = (*C.GSource)(source.Native())

	C.g_source_set_dummy_callback(arg1)
}

// StrdupValueContents: return a newly allocated string, which describes the
// contents of a #GValue. The main purpose of this function is to describe
// #GValue contents for debugging output, the way in which the contents are
// described may change between different GLib versions.
func StrdupValueContents(value *externglib.Value) string {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	ret := C.g_strdup_value_contents(arg1)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// TypeAddClassPrivate registers a private class structure for a classed type;
// when the class is allocated, the private structures for the class and all of
// its parent types are allocated sequentially in the same memory block as the
// public structures, and are zero-filled.
//
// This function should be called in the type's get_type() function after the
// type is registered. The private structure can be retrieved using the
// G_TYPE_CLASS_GET_PRIVATE() macro.
func TypeAddClassPrivate(classType externglib.Type, privateSize uint) {
	var arg1 C.GType
	var arg2 C.gsize

	arg1 = C.GType(classType)
	arg2 = C.gsize(privateSize)

	C.g_type_add_class_private(arg1, arg2)
}

func TypeAddInstancePrivate(classType externglib.Type, privateSize uint) int {
	var arg1 C.GType
	var arg2 C.gsize

	arg1 = C.GType(classType)
	arg2 = C.gsize(privateSize)

	ret := C.g_type_add_instance_private(arg1, arg2)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TypeAddInterfaceDynamic adds @interface_type to the dynamic
// @instantiable_type. The information contained in the Plugin structure pointed
// to by @plugin is used to manage the relationship.
func TypeAddInterfaceDynamic(instanceType externglib.Type, interfaceType externglib.Type, plugin TypePlugin) {
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GTypePlugin

	arg1 = C.GType(instanceType)
	arg2 = C.GType(interfaceType)
	arg3 = (*C.GTypePlugin)(plugin.Native())

	C.g_type_add_interface_dynamic(arg1, arg2, arg3)
}

// TypeAddInterfaceStatic adds @interface_type to the static @instantiable_type.
// The information contained in the Info structure pointed to by @info is used
// to manage the relationship.
func TypeAddInterfaceStatic(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo) {
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GInterfaceInfo

	arg1 = C.GType(instanceType)
	arg2 = C.GType(interfaceType)
	arg3 = (*C.GInterfaceInfo)(info.Native())

	C.g_type_add_interface_static(arg1, arg2, arg3)
}

// TypeCheckInstance: private helper function to aid implementation of the
// G_TYPE_CHECK_INSTANCE() macro.
func TypeCheckInstance(instance *TypeInstance) bool {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(instance.Native())

	ret := C.g_type_check_instance(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func TypeCheckInstanceCast(instance *TypeInstance, ifaceType externglib.Type) *TypeInstance {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(instance.Native())
	arg2 = C.GType(ifaceType)

	ret := C.g_type_check_instance_cast(arg1, arg2)

	var ret0 *TypeInstance

	{
		ret0 = WrapTypeInstance(unsafe.Pointer(ret))
	}

	return ret0
}

func TypeCheckInstanceIsA(instance *TypeInstance, ifaceType externglib.Type) bool {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(instance.Native())
	arg2 = C.GType(ifaceType)

	ret := C.g_type_check_instance_is_a(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func TypeCheckInstanceIsFundamentallyA(instance *TypeInstance, fundamentalType externglib.Type) bool {
	var arg1 *C.GTypeInstance
	var arg2 C.GType

	arg1 = (*C.GTypeInstance)(instance.Native())
	arg2 = C.GType(fundamentalType)

	ret := C.g_type_check_instance_is_fundamentally_a(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func TypeCheckIsValueType(typ externglib.Type) bool {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_check_is_value_type(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func TypeCheckValue(value *externglib.Value) bool {
	var arg1 *C.GValue

	arg1 = (*C.GValue)(value.GValue)

	ret := C.g_type_check_value(arg1)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

func TypeCheckValueHolds(value *externglib.Value, typ externglib.Type) bool {
	var arg1 *C.GValue
	var arg2 C.GType

	arg1 = (*C.GValue)(value.GValue)
	arg2 = C.GType(typ)

	ret := C.g_type_check_value_holds(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TypeChildren: return a newly allocated and 0-terminated array of type IDs,
// listing the child types of @type.
func TypeChildren(typ externglib.Type) (nChildren uint, gTypes []externglib.Type) {
	var arg1 C.GType
	var arg2 *C.guint // out

	arg1 = C.GType(typ)

	ret := C.g_type_children(arg1, &arg2)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg2)

	{
		ret1 = make([]externglib.Type, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = externglib.Type(src)
		}
	}

	return ret0, ret1
}

func TypeClassAdjustPrivateOffset(gClass interface{}, privateSizeOrOffset int) {
	var arg1 C.gpointer
	var arg2 *C.gint

	arg1 = C.gpointer(box.Assign(gClass))
	arg2 = (*C.gint)(privateSizeOrOffset)

	C.g_type_class_adjust_private_offset(arg1, arg2)
}

// TypeCreateInstance creates and initializes an instance of @type if @type is
// valid and can be instantiated. The type system only performs basic allocation
// and structure setups for instances: actual instance creation should happen
// through functions supplied by the type's fundamental type implementation. So
// use of g_type_create_instance() is reserved for implementers of fundamental
// types only. E.g. instances of the #GObject hierarchy should be created via
// g_object_new() and never directly through g_type_create_instance() which
// doesn't handle things like singleton objects or object construction.
//
// The extended members of the returned instance are guaranteed to be filled
// with zeros.
//
// Note: Do not use this function, unless you're implementing a fundamental
// type. Also language bindings should not use this function, but g_object_new()
// instead.
func TypeCreateInstance(typ externglib.Type) *TypeInstance {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_create_instance(arg1)

	var ret0 *TypeInstance

	{
		ret0 = WrapTypeInstance(unsafe.Pointer(ret))
	}

	return ret0
}

// TypeDepth returns the length of the ancestry of the passed in type. This
// includes the type itself, so that e.g. a fundamental type has depth 1.
func TypeDepth(typ externglib.Type) uint {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_depth(arg1)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TypeEnsure ensures that the indicated @type has been registered with the type
// system, and its _class_init() method has been run.
//
// In theory, simply calling the type's _get_type() method (or using the
// corresponding macro) is supposed take care of this. However, _get_type()
// methods are often marked G_GNUC_CONST for performance reasons, even though
// this is technically incorrect (since G_GNUC_CONST requires that the function
// not have side effects, which _get_type() methods do on the first call). As a
// result, if you write a bare call to a _get_type() macro, it may get optimized
// out by the compiler. Using g_type_ensure() guarantees that the type's
// _get_type() method is called.
func TypeEnsure(typ externglib.Type) {
	var arg1 C.GType

	arg1 = C.GType(typ)

	C.g_type_ensure(arg1)
}

// TypeFreeInstance frees an instance of a type, returning it to the instance
// pool for the type, if there is one.
//
// Like g_type_create_instance(), this function is reserved for implementors of
// fundamental types.
func TypeFreeInstance(instance *TypeInstance) {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(instance.Native())

	C.g_type_free_instance(arg1)
}

// TypeFromName: look up the type ID from a given type name, returning 0 if no
// type has been registered under this name (this is the preferred method to
// find out by name whether a specific type has been registered yet).
func TypeFromName(name string) externglib.Type {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_type_from_name(arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeFundamental: internal function, used to extract the fundamental type ID
// portion. Use G_TYPE_FUNDAMENTAL() instead.
func TypeFundamental(typeID externglib.Type) externglib.Type {
	var arg1 C.GType

	arg1 = C.GType(typeID)

	ret := C.g_type_fundamental(arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeFundamentalNext returns the next free fundamental type id which can be
// used to register a new fundamental type with g_type_register_fundamental().
// The returned type ID represents the highest currently registered fundamental
// type identifier.
func TypeFundamentalNext() externglib.Type {

	ret := C.g_type_fundamental_next()

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeGetInstanceCount returns the number of instances allocated of the
// particular type; this is only available if GLib is built with debugging
// support and the instance_count debug flag is set (by setting the
// GOBJECT_DEBUG variable to include instance-count).
func TypeGetInstanceCount(typ externglib.Type) int {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_get_instance_count(arg1)

	var ret0 int

	ret0 = int(ret)

	return ret0
}

// TypeGetPlugin returns the Plugin structure for @type.
func TypeGetPlugin(typ externglib.Type) TypePlugin {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_get_plugin(arg1)

	var ret0 TypePlugin

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TypePlugin)

	return ret0
}

// TypeGetTypeRegistrationSerial returns an opaque serial number that represents
// the state of the set of registered types. Any time a type is registered this
// serial changes, which means you can cache information based on type lookups
// (such as g_type_from_name()) and know if the cache is still valid at a later
// time by comparing the current serial with the one at the type lookup.
func TypeGetTypeRegistrationSerial() uint {

	ret := C.g_type_get_type_registration_serial()

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// TypeInit: this function used to initialise the type system. Since GLib 2.36,
// the type system is initialised automatically and this function does nothing.
func TypeInit() {

	C.g_type_init()
}

// TypeInitWithDebugFlags: this function used to initialise the type system with
// debugging flags. Since GLib 2.36, the type system is initialised
// automatically and this function does nothing.
//
// If you need to enable debugging features, use the GOBJECT_DEBUG environment
// variable.
func TypeInitWithDebugFlags(debugFlags TypeDebugFlags) {
	var arg1 C.GTypeDebugFlags

	arg1 = (C.GTypeDebugFlags)(debugFlags)

	C.g_type_init_with_debug_flags(arg1)
}

// TypeInterfaceAddPrerequisite adds @prerequisite_type to the list of
// prerequisites of @interface_type. This means that any type implementing
// @interface_type must also implement @prerequisite_type. Prerequisites can be
// thought of as an alternative to interface derivation (which GType doesn't
// support). An interface can have at most one instantiatable prerequisite type.
func TypeInterfaceAddPrerequisite(interfaceType externglib.Type, prerequisiteType externglib.Type) {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(interfaceType)
	arg2 = C.GType(prerequisiteType)

	C.g_type_interface_add_prerequisite(arg1, arg2)
}

// TypeInterfaceGetPlugin returns the Plugin structure for the dynamic interface
// @interface_type which has been added to @instance_type, or nil if
// @interface_type has not been added to @instance_type or does not have a
// Plugin structure. See g_type_add_interface_dynamic().
func TypeInterfaceGetPlugin(instanceType externglib.Type, interfaceType externglib.Type) TypePlugin {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(instanceType)
	arg2 = C.GType(interfaceType)

	ret := C.g_type_interface_get_plugin(arg1, arg2)

	var ret0 TypePlugin

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(TypePlugin)

	return ret0
}

// TypeInterfacePrerequisites returns the prerequisites of an interfaces type.
func TypeInterfacePrerequisites(interfaceType externglib.Type) (nPrerequisites uint, gTypes []externglib.Type) {
	var arg1 C.GType
	var arg2 *C.guint // out

	arg1 = C.GType(interfaceType)

	ret := C.g_type_interface_prerequisites(arg1, &arg2)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg2)

	{
		ret1 = make([]externglib.Type, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = externglib.Type(src)
		}
	}

	return ret0, ret1
}

// TypeInterfaces: return a newly allocated and 0-terminated array of type IDs,
// listing the interface types that @type conforms to.
func TypeInterfaces(typ externglib.Type) (nInterfaces uint, gTypes []externglib.Type) {
	var arg1 C.GType
	var arg2 *C.guint // out

	arg1 = C.GType(typ)

	ret := C.g_type_interfaces(arg1, &arg2)

	var ret0 uint
	var ret1 []externglib.Type

	ret0 = uint(arg2)

	{
		ret1 = make([]externglib.Type, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = externglib.Type(src)
		}
	}

	return ret0, ret1
}

// TypeIsA: if @is_a_type is a derivable type, check whether @type is a
// descendant of @is_a_type. If @is_a_type is an interface, check whether @type
// conforms to it.
func TypeIsA(typ externglib.Type, isAType externglib.Type) bool {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(typ)
	arg2 = C.GType(isAType)

	ret := C.g_type_is_a(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TypeName: get the unique name that is assigned to a type ID. Note that this
// function (like all other GType API) cannot cope with invalid type IDs.
// G_TYPE_INVALID may be passed to this function, as may be any other validly
// registered type ID, but randomized type IDs should not be passed in and will
// most likely lead to a crash.
func TypeName(typ externglib.Type) string {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

func TypeNameFromInstance(instance *TypeInstance) string {
	var arg1 *C.GTypeInstance

	arg1 = (*C.GTypeInstance)(instance.Native())

	ret := C.g_type_name_from_instance(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// TypeNextBase: given a @leaf_type and a @root_type which is contained in its
// anchestry, return the type that @root_type is the immediate parent of. In
// other words, this function determines the type that is derived directly from
// @root_type which is also a base class of @leaf_type. Given a root type and a
// leaf type, this function can be used to determine the types and order in
// which the leaf type is descended from the root type.
func TypeNextBase(leafType externglib.Type, rootType externglib.Type) externglib.Type {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(leafType)
	arg2 = C.GType(rootType)

	ret := C.g_type_next_base(arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeParent: return the direct parent type of the passed in type. If the
// passed in type has no parent, i.e. is a fundamental type, 0 is returned.
func TypeParent(typ externglib.Type) externglib.Type {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_parent(arg1)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeQname: get the corresponding quark of the type IDs name.
func TypeQname(typ externglib.Type) glib.Quark {
	var arg1 C.GType

	arg1 = C.GType(typ)

	ret := C.g_type_qname(arg1)

	var ret0 glib.Quark

	{
		var tmp uint32
		tmp = uint32(ret)
		ret0 = glib.Quark(tmp)
	}

	return ret0
}

// TypeQuery queries the type system for information about a specific type. This
// function will fill in a user-provided structure to hold type-specific
// information. If an invalid #GType is passed in, the @type member of the Query
// is 0. All members filled into the Query structure should be considered
// constant and have to be left untouched.
func TypeQuery(typ externglib.Type) TypeQuery {
	var arg1 C.GType
	var arg2 *C.GTypeQuery // out

	arg1 = C.GType(typ)

	C.g_type_query(arg1, &arg2)

	var ret0 *TypeQuery

	{
		ret0 = WrapTypeQuery(unsafe.Pointer(arg2))
	}

	return ret0
}

// TypeRegisterDynamic registers @type_name as the name of a new dynamic type
// derived from @parent_type. The type system uses the information contained in
// the Plugin structure pointed to by @plugin to manage the type and its
// instances (if not abstract). The value of @flags determines the nature (e.g.
// abstract or not) of the type.
func TypeRegisterDynamic(parentType externglib.Type, typeName string, plugin TypePlugin, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypePlugin
	var arg4 C.GTypeFlags

	arg1 = C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypePlugin)(plugin.Native())
	arg4 = (C.GTypeFlags)(flags)

	ret := C.g_type_register_dynamic(arg1, arg2, arg3, arg4)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeRegisterFundamental registers @type_id as the predefined identifier and
// @type_name as the name of a fundamental type. If @type_id is already
// registered, or a type named @type_name is already registered, the behaviour
// is undefined. The type system uses the information contained in the Info
// structure pointed to by @info and the FundamentalInfo structure pointed to by
// @finfo to manage the type and its instances. The value of @flags determines
// additional characteristics of the fundamental type.
func TypeRegisterFundamental(typeID externglib.Type, typeName string, info *TypeInfo, finfo *TypeFundamentalInfo, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 *C.GTypeFundamentalInfo
	var arg5 C.GTypeFlags

	arg1 = C.GType(typeID)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(info.Native())
	arg4 = (*C.GTypeFundamentalInfo)(finfo.Native())
	arg5 = (C.GTypeFlags)(flags)

	ret := C.g_type_register_fundamental(arg1, arg2, arg3, arg4, arg5)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// TypeRegisterStatic registers @type_name as the name of a new static type
// derived from @parent_type. The type system uses the information contained in
// the Info structure pointed to by @info to manage the type and its instances
// (if not abstract). The value of @flags determines the nature (e.g. abstract
// or not) of the type.
func TypeRegisterStatic(parentType externglib.Type, typeName string, info *TypeInfo, flags TypeFlags) externglib.Type {
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 C.GTypeFlags

	arg1 = C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(info.Native())
	arg4 = (C.GTypeFlags)(flags)

	ret := C.g_type_register_static(arg1, arg2, arg3, arg4)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

func TypeTestFlags(typ externglib.Type, flags uint) bool {
	var arg1 C.GType
	var arg2 C.guint

	arg1 = C.GType(typ)
	arg2 = C.guint(flags)

	ret := C.g_type_test_flags(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ValueTypeCompatible returns whether a #GValue of type @src_type can be copied
// into a #GValue of type @dest_type.
func ValueTypeCompatible(srcType externglib.Type, destType externglib.Type) bool {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(srcType)
	arg2 = C.GType(destType)

	ret := C.g_value_type_compatible(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// ValueTypeTransformable: check whether g_value_transform() is able to
// transform values of type @src_type into values of type @dest_type. Note that
// for the types to be transformable, they must be compatible or a
// transformation function must be registered.
func ValueTypeTransformable(srcType externglib.Type, destType externglib.Type) bool {
	var arg1 C.GType
	var arg2 C.GType

	arg1 = C.GType(srcType)
	arg2 = C.GType(destType)

	ret := C.g_value_type_transformable(arg1, arg2)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}

// TypePlugin: the GObject type system supports dynamic loading of types. The
// Plugin interface is used to handle the lifecycle of dynamically loaded types.
// It goes as follows:
//
// 1. The type is initially introduced (usually upon loading the module the
// first time, or by your main application that knows what modules introduces
// what types), like this: |[<!-- language="C" --> new_type_id =
// g_type_register_dynamic (parent_type_id, "TypeName", new_type_plugin,
// type_flags); ]| where @new_type_plugin is an implementation of the Plugin
// interface.
//
// 2. The type's implementation is referenced, e.g. through g_type_class_ref()
// or through g_type_create_instance() (this is being called by g_object_new())
// or through one of the above done on a type derived from @new_type_id.
//
// 3. This causes the type system to load the type's implementation by calling
// g_type_plugin_use() and g_type_plugin_complete_type_info() on
// @new_type_plugin.
//
// 4. At some point the type's implementation isn't required anymore, e.g. after
// g_type_class_unref() or g_type_free_instance() (called when the reference
// count of an instance drops to zero).
//
// 5. This causes the type system to throw away the information retrieved from
// g_type_plugin_complete_type_info() and then it calls g_type_plugin_unuse() on
// @new_type_plugin.
//
// 6. Things may repeat from the second step.
//
// So basically, you need to implement a Plugin type that carries a use_count,
// once use_count goes from zero to one, you need to load the implementation to
// successfully handle the upcoming g_type_plugin_complete_type_info() call.
// Later, maybe after succeeding use/unuse calls, once use_count drops to zero,
// you can unload the implementation again. The type system makes sure to call
// g_type_plugin_use() and g_type_plugin_complete_type_info() again when the
// type is needed again.
//
// Module is an implementation of Plugin that already implements most of this
// except for the actual module loading and unloading. It even handles multiple
// registered types per module.
type TypePlugin interface {
	gextras.Objector

	// CompleteInterfaceInfo calls the @complete_interface_info function from
	// the PluginClass of @plugin. There should be no need to use this function
	// outside of the GObject type system itself.
	CompleteInterfaceInfo(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo)
	// Unuse calls the @unuse_plugin function from the PluginClass of @plugin.
	// There should be no need to use this function outside of the GObject type
	// system itself.
	Unuse()
	// Use calls the @use_plugin function from the PluginClass of @plugin. There
	// should be no need to use this function outside of the GObject type system
	// itself.
	Use()
}

// typePlugin implements the TypePlugin interface.
type typePlugin struct {
	gextras.Objector
}

var _ TypePlugin = (*typePlugin)(nil)

// WrapTypePlugin wraps a GObject to a type that implements interface
// TypePlugin. It is primarily used internally.
func WrapTypePlugin(obj *externglib.Object) TypePlugin {
	return TypePlugin{
		Objector: obj,
	}
}

func marshalTypePlugin(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTypePlugin(obj), nil
}

// CompleteInterfaceInfo calls the @complete_interface_info function from
// the PluginClass of @plugin. There should be no need to use this function
// outside of the GObject type system itself.
func (plugin typePlugin) CompleteInterfaceInfo(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo) {
	var arg0 *C.GTypePlugin
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GInterfaceInfo

	arg0 = (*C.GTypePlugin)(plugin.Native())
	arg1 = C.GType(instanceType)
	arg2 = C.GType(interfaceType)
	arg3 = (*C.GInterfaceInfo)(info.Native())

	C.g_type_plugin_complete_interface_info(arg0, arg1, arg2, arg3)
}

// Unuse calls the @unuse_plugin function from the PluginClass of @plugin.
// There should be no need to use this function outside of the GObject type
// system itself.
func (plugin typePlugin) Unuse() {
	var arg0 *C.GTypePlugin

	arg0 = (*C.GTypePlugin)(plugin.Native())

	C.g_type_plugin_unuse(arg0)
}

// Use calls the @use_plugin function from the PluginClass of @plugin. There
// should be no need to use this function outside of the GObject type system
// itself.
func (plugin typePlugin) Use() {
	var arg0 *C.GTypePlugin

	arg0 = (*C.GTypePlugin)(plugin.Native())

	C.g_type_plugin_use(arg0)
}

// CClosure: a Closure is a specialization of #GClosure for C function
// callbacks.
type CClosure struct {
	native C.GCClosure
}

// WrapCClosure wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCClosure(ptr unsafe.Pointer) *CClosure {
	if ptr == nil {
		return nil
	}

	return (*CClosure)(ptr)
}

func marshalCClosure(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapCClosure(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *CClosure) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Callback gets the field inside the struct.
func (c *CClosure) Callback() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(c.native.callback))
	return ret
}

type ClosureNotifyData struct {
	native C.GClosureNotifyData
}

// WrapClosureNotifyData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapClosureNotifyData(ptr unsafe.Pointer) *ClosureNotifyData {
	if ptr == nil {
		return nil
	}

	return (*ClosureNotifyData)(ptr)
}

func marshalClosureNotifyData(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapClosureNotifyData(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *ClosureNotifyData) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Data gets the field inside the struct.
func (c *ClosureNotifyData) Data() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(c.native.data))
	return ret
}

// EnumValue: a structure which contains a single enum value, its name, and its
// nickname.
type EnumValue struct {
	native C.GEnumValue
}

// WrapEnumValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEnumValue(ptr unsafe.Pointer) *EnumValue {
	if ptr == nil {
		return nil
	}

	return (*EnumValue)(ptr)
}

func marshalEnumValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEnumValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EnumValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// Value gets the field inside the struct.
func (e *EnumValue) Value() int {
	var ret int
	ret = int(e.native.value)
	return ret
}

// ValueName gets the field inside the struct.
func (e *EnumValue) ValueName() string {
	var ret string
	ret = C.GoString(e.native.value_name)
	return ret
}

// ValueNick gets the field inside the struct.
func (e *EnumValue) ValueNick() string {
	var ret string
	ret = C.GoString(e.native.value_nick)
	return ret
}

// FlagsValue: a structure which contains a single flags value, its name, and
// its nickname.
type FlagsValue struct {
	native C.GFlagsValue
}

// WrapFlagsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFlagsValue(ptr unsafe.Pointer) *FlagsValue {
	if ptr == nil {
		return nil
	}

	return (*FlagsValue)(ptr)
}

func marshalFlagsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFlagsValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FlagsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Value gets the field inside the struct.
func (f *FlagsValue) Value() uint {
	var ret uint
	ret = uint(f.native.value)
	return ret
}

// ValueName gets the field inside the struct.
func (f *FlagsValue) ValueName() string {
	var ret string
	ret = C.GoString(f.native.value_name)
	return ret
}

// ValueNick gets the field inside the struct.
func (f *FlagsValue) ValueNick() string {
	var ret string
	ret = C.GoString(f.native.value_nick)
	return ret
}

// InterfaceInfo: a structure that provides information to the type system which
// is used specifically for managing interface types.
type InterfaceInfo struct {
	native C.GInterfaceInfo
}

// WrapInterfaceInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapInterfaceInfo(ptr unsafe.Pointer) *InterfaceInfo {
	if ptr == nil {
		return nil
	}

	return (*InterfaceInfo)(ptr)
}

func marshalInterfaceInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapInterfaceInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (i *InterfaceInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// InterfaceData gets the field inside the struct.
func (i *InterfaceInfo) InterfaceData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(i.native.interface_data))
	return ret
}

// ObjectConstructParam: the GObjectConstructParam struct is an auxiliary
// structure used to hand Spec/#GValue pairs to the @constructor of a Class.
type ObjectConstructParam struct {
	native C.GObjectConstructParam
}

// WrapObjectConstructParam wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapObjectConstructParam(ptr unsafe.Pointer) *ObjectConstructParam {
	if ptr == nil {
		return nil
	}

	return (*ObjectConstructParam)(ptr)
}

func marshalObjectConstructParam(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapObjectConstructParam(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (o *ObjectConstructParam) Native() unsafe.Pointer {
	return unsafe.Pointer(&o.native)
}

// Pspec gets the field inside the struct.
func (o *ObjectConstructParam) Pspec() ParamSpec {
	var ret ParamSpec
	ret = gextras.CastObject(externglib.Take(unsafe.Pointer(o.native.pspec.Native()))).(ParamSpec)
	return ret
}

// Value gets the field inside the struct.
func (o *ObjectConstructParam) Value() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(o.native.value))
	return ret
}

// ParamSpecPool: a SpecPool maintains a collection of Specs which can be
// quickly accessed by owner and name. The implementation of the #GObject
// property system uses such a pool to store the Specs of the properties all
// object types.
type ParamSpecPool struct {
	native C.GParamSpecPool
}

// WrapParamSpecPool wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParamSpecPool(ptr unsafe.Pointer) *ParamSpecPool {
	if ptr == nil {
		return nil
	}

	return (*ParamSpecPool)(ptr)
}

func marshalParamSpecPool(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapParamSpecPool(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *ParamSpecPool) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Insert inserts a Spec in the pool.
func (pool *ParamSpecPool) Insert(pspec ParamSpec, ownerType externglib.Type) {
	var arg0 *C.GParamSpecPool
	var arg1 *C.GParamSpec
	var arg2 C.GType

	arg0 = (*C.GParamSpecPool)(pool.Native())
	arg1 = (*C.GParamSpec)(pspec.Native())
	arg2 = C.GType(ownerType)

	C.g_param_spec_pool_insert(arg0, arg1, arg2)
}

// List gets an array of all Specs owned by @owner_type in the pool.
func (pool *ParamSpecPool) List(ownerType externglib.Type) (nPspecsP uint, paramSpecs []ParamSpec) {
	var arg0 *C.GParamSpecPool
	var arg1 C.GType
	var arg2 *C.guint // out

	arg0 = (*C.GParamSpecPool)(pool.Native())
	arg1 = C.GType(ownerType)

	ret := C.g_param_spec_pool_list(arg0, arg1, &arg2)

	var ret0 uint
	var ret1 []ParamSpec

	ret0 = uint(arg2)

	{
		ret1 = make([]ParamSpec, arg2)
		for i := 0; i < uintptr(arg2); i++ {
			src := (*C.GParamSpec)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret1[i] = gextras.CastObject(externglib.Take(unsafe.Pointer(src.Native()))).(ParamSpec)
		}
	}

	return ret0, ret1
}

// ListOwned gets an #GList of all Specs owned by @owner_type in the pool.
func (pool *ParamSpecPool) ListOwned(ownerType externglib.Type) *glib.List {
	var arg0 *C.GParamSpecPool
	var arg1 C.GType

	arg0 = (*C.GParamSpecPool)(pool.Native())
	arg1 = C.GType(ownerType)

	ret := C.g_param_spec_pool_list_owned(arg0, arg1)

	var ret0 *glib.List

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Lookup looks up a Spec in the pool.
func (pool *ParamSpecPool) Lookup(paramName string, ownerType externglib.Type, walkAncestors bool) ParamSpec {
	var arg0 *C.GParamSpecPool
	var arg1 *C.gchar
	var arg2 C.GType
	var arg3 C.gboolean

	arg0 = (*C.GParamSpecPool)(pool.Native())
	arg1 = (*C.gchar)(C.CString(paramName))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(ownerType)
	if walkAncestors {
		arg3 = C.TRUE
	}

	ret := C.g_param_spec_pool_lookup(arg0, arg1, arg2, arg3)

	var ret0 ParamSpec

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(ParamSpec)

	return ret0
}

// Remove removes a Spec from the pool.
func (pool *ParamSpecPool) Remove(pspec ParamSpec) {
	var arg0 *C.GParamSpecPool
	var arg1 *C.GParamSpec

	arg0 = (*C.GParamSpecPool)(pool.Native())
	arg1 = (*C.GParamSpec)(pspec.Native())

	C.g_param_spec_pool_remove(arg0, arg1)
}

// Parameter: the GParameter struct is an auxiliary structure used to hand
// parameter name/value pairs to g_object_newv().
type Parameter struct {
	native C.GParameter
}

// WrapParameter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapParameter(ptr unsafe.Pointer) *Parameter {
	if ptr == nil {
		return nil
	}

	return (*Parameter)(ptr)
}

func marshalParameter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapParameter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (p *Parameter) Native() unsafe.Pointer {
	return unsafe.Pointer(&p.native)
}

// Name gets the field inside the struct.
func (p *Parameter) Name() string {
	var ret string
	ret = C.GoString(p.native.name)
	return ret
}

// Value gets the field inside the struct.
func (p *Parameter) Value() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(p.native.value))
	return ret
}

// SignalInvocationHint: the InvocationHint structure is used to pass on
// additional information to callbacks during a signal emission.
type SignalInvocationHint struct {
	native C.GSignalInvocationHint
}

// WrapSignalInvocationHint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalInvocationHint(ptr unsafe.Pointer) *SignalInvocationHint {
	if ptr == nil {
		return nil
	}

	return (*SignalInvocationHint)(ptr)
}

func marshalSignalInvocationHint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalInvocationHint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalInvocationHint) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalInvocationHint) SignalID() uint {
	var ret uint
	ret = uint(s.native.signal_id)
	return ret
}

// Detail gets the field inside the struct.
func (s *SignalInvocationHint) Detail() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(s.native.detail)
		ret = glib.Quark(tmp)
	}
	return ret
}

// RunType gets the field inside the struct.
func (s *SignalInvocationHint) RunType() SignalFlags {
	var ret SignalFlags
	ret = SignalFlags(s.native.run_type)
	return ret
}

// SignalQuery: a structure holding in-depth information for a specific signal.
// It is filled in by the g_signal_query() function.
type SignalQuery struct {
	native C.GSignalQuery
}

// WrapSignalQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalQuery(ptr unsafe.Pointer) *SignalQuery {
	if ptr == nil {
		return nil
	}

	return (*SignalQuery)(ptr)
}

func marshalSignalQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalQuery) SignalID() uint {
	var ret uint
	ret = uint(s.native.signal_id)
	return ret
}

// SignalName gets the field inside the struct.
func (s *SignalQuery) SignalName() string {
	var ret string
	ret = C.GoString(s.native.signal_name)
	return ret
}

// Itype gets the field inside the struct.
func (s *SignalQuery) Itype() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(s.native.itype)
	return ret
}

// SignalFlags gets the field inside the struct.
func (s *SignalQuery) SignalFlags() SignalFlags {
	var ret SignalFlags
	ret = SignalFlags(s.native.signal_flags)
	return ret
}

// ReturnType gets the field inside the struct.
func (s *SignalQuery) ReturnType() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(s.native.return_type)
	return ret
}

// NParams gets the field inside the struct.
func (s *SignalQuery) NParams() uint {
	var ret uint
	ret = uint(s.native.n_params)
	return ret
}

// ParamTypes gets the field inside the struct.
func (s *SignalQuery) ParamTypes() []externglib.Type {
	var ret []externglib.Type
	{
		ret = make([]externglib.Type, s.native.n_params)
		for i := 0; i < uintptr(s.native.n_params); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret[i] = externglib.Type(src)
		}
	}
	return ret
}

// TypeFundamentalInfo: a structure that provides information to the type system
// which is used specifically for managing fundamental types.
type TypeFundamentalInfo struct {
	native C.GTypeFundamentalInfo
}

// WrapTypeFundamentalInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeFundamentalInfo(ptr unsafe.Pointer) *TypeFundamentalInfo {
	if ptr == nil {
		return nil
	}

	return (*TypeFundamentalInfo)(ptr)
}

func marshalTypeFundamentalInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeFundamentalInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeFundamentalInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// TypeFlags gets the field inside the struct.
func (t *TypeFundamentalInfo) TypeFlags() TypeFundamentalFlags {
	var ret TypeFundamentalFlags
	ret = TypeFundamentalFlags(t.native.type_flags)
	return ret
}

// TypeInfo: this structure is used to provide the type system with the
// information required to initialize and destruct (finalize) a type's class and
// its instances.
//
// The initialized structure is passed to the g_type_register_static() function
// (or is copied into the provided Info structure in the
// g_type_plugin_complete_type_info()). The type system will perform a deep copy
// of this structure, so its memory does not need to be persistent across
// invocation of g_type_register_static().
type TypeInfo struct {
	native C.GTypeInfo
}

// WrapTypeInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInfo(ptr unsafe.Pointer) *TypeInfo {
	if ptr == nil {
		return nil
	}

	return (*TypeInfo)(ptr)
}

func marshalTypeInfo(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeInfo(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// ClassSize gets the field inside the struct.
func (t *TypeInfo) ClassSize() uint16 {
	var ret uint16
	ret = uint16(t.native.class_size)
	return ret
}

// ClassData gets the field inside the struct.
func (t *TypeInfo) ClassData() interface{} {
	var ret interface{}
	ret = box.Get(uintptr(t.native.class_data))
	return ret
}

// InstanceSize gets the field inside the struct.
func (t *TypeInfo) InstanceSize() uint16 {
	var ret uint16
	ret = uint16(t.native.instance_size)
	return ret
}

// NPreallocs gets the field inside the struct.
func (t *TypeInfo) NPreallocs() uint16 {
	var ret uint16
	ret = uint16(t.native.n_preallocs)
	return ret
}

// TypeInstance: an opaque structure used as the base of all type instances.
type TypeInstance struct {
	native C.GTypeInstance
}

// WrapTypeInstance wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeInstance(ptr unsafe.Pointer) *TypeInstance {
	if ptr == nil {
		return nil
	}

	return (*TypeInstance)(ptr)
}

func marshalTypeInstance(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeInstance(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeInstance) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

func (instance *TypeInstance) Private(privateType externglib.Type) interface{} {
	var arg0 *C.GTypeInstance
	var arg1 C.GType

	arg0 = (*C.GTypeInstance)(instance.Native())
	arg1 = C.GType(privateType)

	ret := C.g_type_instance_get_private(arg0, arg1)

	var ret0 interface{}

	ret0 = box.Get(uintptr(ret)).(interface{})

	return ret0
}

// TypeQuery: a structure holding information for a specific type. It is filled
// in by the g_type_query() function.
type TypeQuery struct {
	native C.GTypeQuery
}

// WrapTypeQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTypeQuery(ptr unsafe.Pointer) *TypeQuery {
	if ptr == nil {
		return nil
	}

	return (*TypeQuery)(ptr)
}

func marshalTypeQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTypeQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TypeQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Type gets the field inside the struct.
func (t *TypeQuery) Type() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(t.native._type)
	return ret
}

// TypeName gets the field inside the struct.
func (t *TypeQuery) TypeName() string {
	var ret string
	ret = C.GoString(t.native.type_name)
	return ret
}

// ClassSize gets the field inside the struct.
func (t *TypeQuery) ClassSize() uint {
	var ret uint
	ret = uint(t.native.class_size)
	return ret
}

// InstanceSize gets the field inside the struct.
func (t *TypeQuery) InstanceSize() uint {
	var ret uint
	ret = uint(t.native.instance_size)
	return ret
}

// ValueArray: a Array contains an array of #GValue elements.
type ValueArray struct {
	native C.GValueArray
}

// WrapValueArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapValueArray(ptr unsafe.Pointer) *ValueArray {
	if ptr == nil {
		return nil
	}

	return (*ValueArray)(ptr)
}

func marshalValueArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapValueArray(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (v *ValueArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&v.native)
}

// NewValueArray constructs a struct ValueArray.
func NewValueArray(nPrealloced uint) *ValueArray {
	var arg1 C.guint

	arg1 = C.guint(nPrealloced)

	ret := C.g_value_array_new(arg1)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ValueArray) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// NValues gets the field inside the struct.
func (v *ValueArray) NValues() uint {
	var ret uint
	ret = uint(v.native.n_values)
	return ret
}

// Values gets the field inside the struct.
func (v *ValueArray) Values() *externglib.Value {
	var ret *externglib.Value
	ret = externglib.ValueFromNative(unsafe.Pointer(v.native.values))
	return ret
}

// Append: insert a copy of @value as last element of @value_array. If @value is
// nil, an uninitialized value is appended.
func (valueArray *ValueArray) Append(value *externglib.Value) *ValueArray {
	var arg0 *C.GValueArray
	var arg1 *C.GValue

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = (*C.GValue)(value.GValue)

	ret := C.g_value_array_append(arg0, arg1)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
	}

	return ret0
}

// Copy: construct an exact copy of a Array by duplicating all its contents.
func (valueArray *ValueArray) Copy() *ValueArray {
	var arg0 *C.GValueArray

	arg0 = (*C.GValueArray)(valueArray.Native())

	ret := C.g_value_array_copy(arg0)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *ValueArray) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// Free: free a Array including its contents.
func (valueArray *ValueArray) Free() {
	var arg0 *C.GValueArray

	arg0 = (*C.GValueArray)(valueArray.Native())

	C.g_value_array_free(arg0)
}

// Nth: return a pointer to the value at @index_ containd in @value_array.
func (valueArray *ValueArray) Nth(index_ uint) *externglib.Value {
	var arg0 *C.GValueArray
	var arg1 C.guint

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = C.guint(index_)

	ret := C.g_value_array_get_nth(arg0, arg1)

	var ret0 *externglib.Value

	ret0 = externglib.ValueFromNative(unsafe.Pointer(ret))

	return ret0
}

// Insert: insert a copy of @value at specified position into @value_array. If
// @value is nil, an uninitialized value is inserted.
func (valueArray *ValueArray) Insert(index_ uint, value *externglib.Value) *ValueArray {
	var arg0 *C.GValueArray
	var arg1 C.guint
	var arg2 *C.GValue

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = C.guint(index_)
	arg2 = (*C.GValue)(value.GValue)

	ret := C.g_value_array_insert(arg0, arg1, arg2)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
	}

	return ret0
}

// Prepend: insert a copy of @value as first element of @value_array. If @value
// is nil, an uninitialized value is prepended.
func (valueArray *ValueArray) Prepend(value *externglib.Value) *ValueArray {
	var arg0 *C.GValueArray
	var arg1 *C.GValue

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = (*C.GValue)(value.GValue)

	ret := C.g_value_array_prepend(arg0, arg1)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
	}

	return ret0
}

// Remove: remove the value at position @index_ from @value_array.
func (valueArray *ValueArray) Remove(index_ uint) *ValueArray {
	var arg0 *C.GValueArray
	var arg1 C.guint

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = C.guint(index_)

	ret := C.g_value_array_remove(arg0, arg1)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
	}

	return ret0
}

// SortWithData: sort @value_array using @compare_func to compare the elements
// according to the semantics of DataFunc.
//
// The current implementation uses the same sorting algorithm as standard C
// qsort() function.
func (valueArray *ValueArray) SortWithData(compareFunc glib.CompareDataFunc) *ValueArray {
	var arg0 *C.GValueArray
	var arg1 C.GCompareDataFunc
	var arg2 C.gpointer

	arg0 = (*C.GValueArray)(valueArray.Native())
	arg1 = (*[0]byte)(C.gotk4_CompareDataFunc)
	arg2 = C.gpointer(box.Assign(compareFunc))

	ret := C.g_value_array_sort_with_data(arg0, arg1, arg2)

	var ret0 *ValueArray

	{
		ret0 = WrapValueArray(unsafe.Pointer(ret))
	}

	return ret0
}

// WeakRef: a structure containing a weak reference to a #GObject. It can either
// be empty (i.e. point to nil), or point to an object for as long as at least
// one "strong" reference to that object exists. Before the object's
// Class.dispose method is called, every Ref associated with becomes empty (i.e.
// points to nil).
//
// Like #GValue, Ref can be statically allocated, stack- or heap-allocated, or
// embedded in larger structures.
//
// Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
// reference is thread-safe: converting a weak pointer to a reference is atomic
// with respect to invalidation of weak pointers to destroyed objects.
//
// If the object's Class.dispose method results in additional references to the
// object being held, any Refs taken before it was disposed will continue to
// point to nil. If Refs are taken after the object is disposed and
// re-referenced, they will continue to point to it until its refcount goes back
// to zero, at which point they too will be invalidated.
type WeakRef struct {
	native C.GWeakRef
}

// WrapWeakRef wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapWeakRef(ptr unsafe.Pointer) *WeakRef {
	if ptr == nil {
		return nil
	}

	return (*WeakRef)(ptr)
}

func marshalWeakRef(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapWeakRef(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (w *WeakRef) Native() unsafe.Pointer {
	return unsafe.Pointer(&w.native)
}

// Clear frees resources associated with a non-statically-allocated Ref. After
// this call, the Ref is left in an undefined state.
//
// You should only call this on a Ref that previously had g_weak_ref_init()
// called on it.
func (weakRef *WeakRef) Clear() {
	var arg0 *C.GWeakRef

	arg0 = (*C.GWeakRef)(weakRef.Native())

	C.g_weak_ref_clear(arg0)
}

// Get: if @weak_ref is not empty, atomically acquire a strong reference to the
// object it points to, and return that reference.
//
// This function is needed because of the potential race between taking the
// pointer value and g_object_ref() on it, if the object was losing its last
// reference at the same time in a different thread.
//
// The caller should release the resulting reference in the usual way, by using
// g_object_unref().
func (weakRef *WeakRef) Get() gextras.Objector {
	var arg0 *C.GWeakRef

	arg0 = (*C.GWeakRef)(weakRef.Native())

	ret := C.g_weak_ref_get(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// Init: initialise a non-statically-allocated Ref.
//
// This function also calls g_weak_ref_set() with @object on the
// freshly-initialised weak reference.
//
// This function should always be matched with a call to g_weak_ref_clear(). It
// is not necessary to use this function for a Ref in static storage because it
// will already be properly initialised. Just use g_weak_ref_set() directly.
func (weakRef *WeakRef) Init(object gextras.Objector) {
	var arg0 *C.GWeakRef
	var arg1 C.gpointer

	arg0 = (*C.GWeakRef)(weakRef.Native())
	arg1 = (*C.GObject)(object.Native())

	C.g_weak_ref_init(arg0, arg1)
}

// Set: change the object to which @weak_ref points, or set it to nil.
//
// You must own a strong reference on @object while calling this function.
func (weakRef *WeakRef) Set(object gextras.Objector) {
	var arg0 *C.GWeakRef
	var arg1 C.gpointer

	arg0 = (*C.GWeakRef)(weakRef.Native())
	arg1 = (*C.GObject)(object.Native())

	C.g_weak_ref_set(arg0, arg1)
}

// Binding is the representation of a binding between a property on a #GObject
// instance (or source) and another property on another #GObject instance (or
// target). Whenever the source property changes, the same value is applied to
// the target property; for instance, the following binding:
//
//    g_object_bind_property_full (adjustment1, "value",
//                                 adjustment2, "value",
//                                 G_BINDING_BIDIRECTIONAL,
//                                 celsius_to_fahrenheit,
//                                 fahrenheit_to_celsius,
//                                 NULL, NULL);
//
// will keep the "value" property of the two adjustments in sync; the
// @celsius_to_fahrenheit function will be called whenever the "value" property
// of @adjustment1 changes and will transform the current value of the property
// before applying it to the "value" property of @adjustment2.
//
// Vice versa, the @fahrenheit_to_celsius function will be called whenever the
// "value" property of @adjustment2 changes, and will transform the current
// value of the property before applying it to the "value" property of
// @adjustment1.
//
// Note that #GBinding does not resolve cycles by itself; a cycle like
//
//    object1:propertyA -> object2:propertyB
//    object2:propertyB -> object3:propertyC
//    object3:propertyC -> object1:propertyA
//
// might lead to an infinite loop. The loop, in this particular case, can be
// avoided if the objects emit the #GObject::notify signal only if the value has
// effectively been changed. A binding is implemented using the #GObject::notify
// signal, so it is susceptible to all the various ways of blocking a signal
// emission, like g_signal_stop_emission() or g_signal_handler_block().
//
// A binding will be severed, and the resources it allocates freed, whenever
// either one of the #GObject instances it refers to are finalized, or when the
// #GBinding instance loses its last reference.
//
// Bindings for languages with garbage collection can use g_binding_unbind() to
// explicitly release a binding between the source and target properties,
// instead of relying on the last reference on the binding, source, and target
// instances to drop.
//
// #GBinding is available since GObject 2.26
type Binding interface {
	gextras.Objector

	// Flags retrieves the flags passed when constructing the #GBinding.
	Flags() BindingFlags
	// Source retrieves the #GObject instance used as the source of the binding.
	Source() gextras.Objector
	// SourceProperty retrieves the name of the property of #GBinding:source
	// used as the source of the binding.
	SourceProperty() string
	// Target retrieves the #GObject instance used as the target of the binding.
	Target() gextras.Objector
	// TargetProperty retrieves the name of the property of #GBinding:target
	// used as the target of the binding.
	TargetProperty() string
	// Unbind: explicitly releases the binding between the source and the target
	// property expressed by @binding.
	//
	// This function will release the reference that is being held on the
	// @binding instance; if you want to hold on to the #GBinding instance after
	// calling g_binding_unbind(), you will need to hold a reference to it.
	Unbind()
}

// binding implements the Binding interface.
type binding struct {
	gextras.Objector
}

var _ Binding = (*binding)(nil)

// WrapBinding wraps a GObject to the right type. It is
// primarily used internally.
func WrapBinding(obj *externglib.Object) Binding {
	return Binding{
		Objector: obj,
	}
}

func marshalBinding(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapBinding(obj), nil
}

// Flags retrieves the flags passed when constructing the #GBinding.
func (binding binding) Flags() BindingFlags {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	ret := C.g_binding_get_flags(arg0)

	var ret0 BindingFlags

	ret0 = BindingFlags(ret)

	return ret0
}

// Source retrieves the #GObject instance used as the source of the binding.
func (binding binding) Source() gextras.Objector {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	ret := C.g_binding_get_source(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// SourceProperty retrieves the name of the property of #GBinding:source
// used as the source of the binding.
func (binding binding) SourceProperty() string {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	ret := C.g_binding_get_source_property(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Target retrieves the #GObject instance used as the target of the binding.
func (binding binding) Target() gextras.Objector {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	ret := C.g_binding_get_target(arg0)

	var ret0 gextras.Objector

	ret0 = gextras.CastObject(externglib.Take(unsafe.Pointer(ret.Native()))).(gextras.Objector)

	return ret0
}

// TargetProperty retrieves the name of the property of #GBinding:target
// used as the target of the binding.
func (binding binding) TargetProperty() string {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	ret := C.g_binding_get_target_property(arg0)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// Unbind: explicitly releases the binding between the source and the target
// property expressed by @binding.
//
// This function will release the reference that is being held on the
// @binding instance; if you want to hold on to the #GBinding instance after
// calling g_binding_unbind(), you will need to hold a reference to it.
func (binding binding) Unbind() {
	var arg0 *C.GBinding

	arg0 = (*C.GBinding)(binding.Native())

	C.g_binding_unbind(arg0)
}

// TypeModule provides a simple implementation of the Plugin interface. The
// model of Module is a dynamically loaded module which implements some number
// of types and interface implementations. When the module is loaded, it
// registers its types and interfaces using g_type_module_register_type() and
// g_type_module_add_interface(). As long as any instances of these types and
// interface implementations are in use, the module is kept loaded. When the
// types and interfaces are gone, the module may be unloaded. If the types and
// interfaces become used again, the module will be reloaded. Note that the last
// unref cannot happen in module code, since that would lead to the caller's
// code being unloaded before g_object_unref() returns to it.
//
// Keeping track of whether the module should be loaded or not is done by using
// a use count - it starts at zero, and whenever it is greater than zero, the
// module is loaded. The use count is maintained internally by the type system,
// but also can be explicitly controlled by g_type_module_use() and
// g_type_module_unuse(). Typically, when loading a module for the first type,
// g_type_module_use() will be used to load it so that it can initialize its
// types. At some later point, when the module no longer needs to be loaded
// except for the type implementations it contains, g_type_module_unuse() is
// called.
//
// Module does not actually provide any implementation of module loading and
// unloading. To create a particular module type you must derive from Module and
// implement the load and unload functions in ModuleClass.
type TypeModule interface {
	gextras.Objector
	TypePlugin

	// AddInterface registers an additional interface for a type, whose
	// interface lives in the given type plugin. If the interface was already
	// registered for the type in this plugin, nothing will be done.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_add_interface_static()
	// instead. This can be used when making a static build of the module.
	AddInterface(instanceType externglib.Type, interfaceType externglib.Type, interfaceInfo *InterfaceInfo)
	// RegisterEnum looks up or registers an enumeration that is implemented
	// with a particular type plugin. If a type with name @type_name was
	// previously registered, the #GType identifier for the type is returned,
	// otherwise the type is newly registered, and the resulting #GType
	// identifier returned.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterEnum(name string, constStaticValues *EnumValue) externglib.Type
	// RegisterFlags looks up or registers a flags type that is implemented with
	// a particular type plugin. If a type with name @type_name was previously
	// registered, the #GType identifier for the type is returned, otherwise the
	// type is newly registered, and the resulting #GType identifier returned.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterFlags(name string, constStaticValues *FlagsValue) externglib.Type
	// RegisterType looks up or registers a type that is implemented with a
	// particular type plugin. If a type with name @type_name was previously
	// registered, the #GType identifier for the type is returned, otherwise the
	// type is newly registered, and the resulting #GType identifier returned.
	//
	// When reregistering a type (typically because a module is unloaded then
	// reloaded, and reinitialized), @module and @parent_type must be the same
	// as they were previously.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterType(parentType externglib.Type, typeName string, typeInfo *TypeInfo, flags TypeFlags) externglib.Type
	// SetName sets the name for a Module
	SetName(name string)
	// Unuse decreases the use count of a Module by one. If the result is zero,
	// the module will be unloaded. (However, the Module will not be freed, and
	// types associated with the Module are not unregistered. Once a Module is
	// initialized, it must exist forever.)
	Unuse()
	// Use increases the use count of a Module by one. If the use count was zero
	// before, the plugin will be loaded. If loading the plugin fails, the use
	// count is reset to its prior value.
	Use() bool
}

// typeModule implements the TypeModule interface.
type typeModule struct {
	gextras.Objector
	TypePlugin
}

var _ TypeModule = (*typeModule)(nil)

// WrapTypeModule wraps a GObject to the right type. It is
// primarily used internally.
func WrapTypeModule(obj *externglib.Object) TypeModule {
	return TypeModule{
		Objector:   obj,
		TypePlugin: WrapTypePlugin(obj),
	}
}

func marshalTypeModule(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTypeModule(obj), nil
}

// AddInterface registers an additional interface for a type, whose
// interface lives in the given type plugin. If the interface was already
// registered for the type in this plugin, nothing will be done.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_add_interface_static()
// instead. This can be used when making a static build of the module.
func (module typeModule) AddInterface(instanceType externglib.Type, interfaceType externglib.Type, interfaceInfo *InterfaceInfo) {
	var arg0 *C.GTypeModule
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GInterfaceInfo

	arg0 = (*C.GTypeModule)(module.Native())
	arg1 = C.GType(instanceType)
	arg2 = C.GType(interfaceType)
	arg3 = (*C.GInterfaceInfo)(interfaceInfo.Native())

	C.g_type_module_add_interface(arg0, arg1, arg2, arg3)
}

// RegisterEnum looks up or registers an enumeration that is implemented
// with a particular type plugin. If a type with name @type_name was
// previously registered, the #GType identifier for the type is returned,
// otherwise the type is newly registered, and the resulting #GType
// identifier returned.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (module typeModule) RegisterEnum(name string, constStaticValues *EnumValue) externglib.Type {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar
	var arg2 *C.GEnumValue

	arg0 = (*C.GTypeModule)(module.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GEnumValue)(constStaticValues.Native())

	ret := C.g_type_module_register_enum(arg0, arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// RegisterFlags looks up or registers a flags type that is implemented with
// a particular type plugin. If a type with name @type_name was previously
// registered, the #GType identifier for the type is returned, otherwise the
// type is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (module typeModule) RegisterFlags(name string, constStaticValues *FlagsValue) externglib.Type {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar
	var arg2 *C.GFlagsValue

	arg0 = (*C.GTypeModule)(module.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GFlagsValue)(constStaticValues.Native())

	ret := C.g_type_module_register_flags(arg0, arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// RegisterType looks up or registers a type that is implemented with a
// particular type plugin. If a type with name @type_name was previously
// registered, the #GType identifier for the type is returned, otherwise the
// type is newly registered, and the resulting #GType identifier returned.
//
// When reregistering a type (typically because a module is unloaded then
// reloaded, and reinitialized), @module and @parent_type must be the same
// as they were previously.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (module typeModule) RegisterType(parentType externglib.Type, typeName string, typeInfo *TypeInfo, flags TypeFlags) externglib.Type {
	var arg0 *C.GTypeModule
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 C.GTypeFlags

	arg0 = (*C.GTypeModule)(module.Native())
	arg1 = C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(typeInfo.Native())
	arg4 = (C.GTypeFlags)(flags)

	ret := C.g_type_module_register_type(arg0, arg1, arg2, arg3, arg4)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// SetName sets the name for a Module
func (module typeModule) SetName(name string) {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar

	arg0 = (*C.GTypeModule)(module.Native())
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_type_module_set_name(arg0, arg1)
}

// Unuse decreases the use count of a Module by one. If the result is zero,
// the module will be unloaded. (However, the Module will not be freed, and
// types associated with the Module are not unregistered. Once a Module is
// initialized, it must exist forever.)
func (module typeModule) Unuse() {
	var arg0 *C.GTypeModule

	arg0 = (*C.GTypeModule)(module.Native())

	C.g_type_module_unuse(arg0)
}

// Use increases the use count of a Module by one. If the use count was zero
// before, the plugin will be loaded. If loading the plugin fails, the use
// count is reset to its prior value.
func (module typeModule) Use() bool {
	var arg0 *C.GTypeModule

	arg0 = (*C.GTypeModule)(module.Native())

	ret := C.g_type_module_use(arg0)

	var ret0 bool

	ret0 = C.BOOL(ret) != 0

	return ret0
}
