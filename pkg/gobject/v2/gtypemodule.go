// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_type_module_get_type()), F: marshalTypeModule},
	})
}

// TypeModule provides a simple implementation of the Plugin interface. The
// model of Module is a dynamically loaded module which implements some number
// of types and interface implementations. When the module is loaded, it
// registers its types and interfaces using g_type_module_register_type() and
// g_type_module_add_interface(). As long as any instances of these types and
// interface implementations are in use, the module is kept loaded. When the
// types and interfaces are gone, the module may be unloaded. If the types and
// interfaces become used again, the module will be reloaded. Note that the last
// unref cannot happen in module code, since that would lead to the caller's
// code being unloaded before g_object_unref() returns to it.
//
// Keeping track of whether the module should be loaded or not is done by using
// a use count - it starts at zero, and whenever it is greater than zero, the
// module is loaded. The use count is maintained internally by the type system,
// but also can be explicitly controlled by g_type_module_use() and
// g_type_module_unuse(). Typically, when loading a module for the first type,
// g_type_module_use() will be used to load it so that it can initialize its
// types. At some later point, when the module no longer needs to be loaded
// except for the type implementations it contains, g_type_module_unuse() is
// called.
//
// Module does not actually provide any implementation of module loading and
// unloading. To create a particular module type you must derive from Module and
// implement the load and unload functions in ModuleClass.
type TypeModule interface {
	TypePlugin
}

// typeModule implements the TypeModule class.
type typeModule struct {
	gextras.Objector
}

// WrapTypeModule wraps a GObject to the right type. It is
// primarily used internally.
func WrapTypeModule(obj *externglib.Object) TypeModule {
	return typeModule{
		Objector: obj,
	}
}

func marshalTypeModule(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTypeModule(obj), nil
}

func (p typeModule) CompleteInterfaceInfo(instanceType externglib.Type, interfaceType externglib.Type, info *InterfaceInfo) {
	WrapTypePlugin(gextras.InternObject(p)).CompleteInterfaceInfo(instanceType, interfaceType, info)
}

func (p typeModule) CompleteTypeInfo(gType externglib.Type, info *TypeInfo, valueTable *TypeValueTable) {
	WrapTypePlugin(gextras.InternObject(p)).CompleteTypeInfo(gType, info, valueTable)
}

func (p typeModule) Unuse() {
	WrapTypePlugin(gextras.InternObject(p)).Unuse()
}

func (p typeModule) Use() {
	WrapTypePlugin(gextras.InternObject(p)).Use()
}
