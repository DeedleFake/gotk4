// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_type_module_get_type()), F: marshalTypeModule},
	})
}

// TypeModule provides a simple implementation of the Plugin interface. The
// model of Module is a dynamically loaded module which implements some number
// of types and interface implementations. When the module is loaded, it
// registers its types and interfaces using g_type_module_register_type() and
// g_type_module_add_interface(). As long as any instances of these types and
// interface implementations are in use, the module is kept loaded. When the
// types and interfaces are gone, the module may be unloaded. If the types and
// interfaces become used again, the module will be reloaded. Note that the last
// unref cannot happen in module code, since that would lead to the caller's
// code being unloaded before g_object_unref() returns to it.
//
// Keeping track of whether the module should be loaded or not is done by using
// a use count - it starts at zero, and whenever it is greater than zero, the
// module is loaded. The use count is maintained internally by the type system,
// but also can be explicitly controlled by g_type_module_use() and
// g_type_module_unuse(). Typically, when loading a module for the first type,
// g_type_module_use() will be used to load it so that it can initialize its
// types. At some later point, when the module no longer needs to be loaded
// except for the type implementations it contains, g_type_module_unuse() is
// called.
//
// Module does not actually provide any implementation of module loading and
// unloading. To create a particular module type you must derive from Module and
// implement the load and unload functions in ModuleClass.
type TypeModule interface {
	gextras.Objector
	TypePlugin

	// AddInterface registers an additional interface for a type, whose
	// interface lives in the given type plugin. If the interface was already
	// registered for the type in this plugin, nothing will be done.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_add_interface_static()
	// instead. This can be used when making a static build of the module.
	AddInterface(m TypeModule, instanceType externglib.Type, interfaceType externglib.Type, interfaceInfo *InterfaceInfo)
	// RegisterEnum looks up or registers an enumeration that is implemented
	// with a particular type plugin. If a type with name @type_name was
	// previously registered, the #GType identifier for the type is returned,
	// otherwise the type is newly registered, and the resulting #GType
	// identifier returned.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterEnum(m TypeModule, name string, constStaticValues *EnumValue)
	// RegisterFlags looks up or registers a flags type that is implemented with
	// a particular type plugin. If a type with name @type_name was previously
	// registered, the #GType identifier for the type is returned, otherwise the
	// type is newly registered, and the resulting #GType identifier returned.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterFlags(m TypeModule, name string, constStaticValues *FlagsValue)
	// RegisterType looks up or registers a type that is implemented with a
	// particular type plugin. If a type with name @type_name was previously
	// registered, the #GType identifier for the type is returned, otherwise the
	// type is newly registered, and the resulting #GType identifier returned.
	//
	// When reregistering a type (typically because a module is unloaded then
	// reloaded, and reinitialized), @module and @parent_type must be the same
	// as they were previously.
	//
	// As long as any instances of the type exist, the type plugin will not be
	// unloaded.
	//
	// Since 2.56 if @module is nil this will call g_type_register_static()
	// instead. This can be used when making a static build of the module.
	RegisterType(m TypeModule, parentType externglib.Type, typeName string, typeInfo *TypeInfo, flags TypeFlags)
	// SetName sets the name for a Module
	SetName(m TypeModule, name string)
	// Unuse decreases the use count of a Module by one. If the result is zero,
	// the module will be unloaded. (However, the Module will not be freed, and
	// types associated with the Module are not unregistered. Once a Module is
	// initialized, it must exist forever.)
	Unuse(m TypeModule)
	// Use increases the use count of a Module by one. If the use count was zero
	// before, the plugin will be loaded. If loading the plugin fails, the use
	// count is reset to its prior value.
	Use(m TypeModule) bool
}

// typeModule implements the TypeModule interface.
type typeModule struct {
	gextras.Objector
	TypePlugin
}

var _ TypeModule = (*typeModule)(nil)

// WrapTypeModule wraps a GObject to the right type. It is
// primarily used internally.
func WrapTypeModule(obj *externglib.Object) TypeModule {
	return TypeModule{
		Objector:   obj,
		TypePlugin: WrapTypePlugin(obj),
	}
}

func marshalTypeModule(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapTypeModule(obj), nil
}

// AddInterface registers an additional interface for a type, whose
// interface lives in the given type plugin. If the interface was already
// registered for the type in this plugin, nothing will be done.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_add_interface_static()
// instead. This can be used when making a static build of the module.
func (m typeModule) AddInterface(m TypeModule, instanceType externglib.Type, interfaceType externglib.Type, interfaceInfo *InterfaceInfo) {
	var arg0 *C.GTypeModule
	var arg1 C.GType
	var arg2 C.GType
	var arg3 *C.GInterfaceInfo

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))
	arg1 := C.GType(instanceType)
	arg2 := C.GType(interfaceType)
	arg3 = (*C.GInterfaceInfo)(unsafe.Pointer(interfaceInfo.Native()))

	C.g_type_module_add_interface(arg0, arg1, arg2, arg3)
}

// RegisterEnum looks up or registers an enumeration that is implemented
// with a particular type plugin. If a type with name @type_name was
// previously registered, the #GType identifier for the type is returned,
// otherwise the type is newly registered, and the resulting #GType
// identifier returned.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (m typeModule) RegisterEnum(m TypeModule, name string, constStaticValues *EnumValue) {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar
	var arg2 *C.GEnumValue

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GEnumValue)(unsafe.Pointer(constStaticValues.Native()))

	C.g_type_module_register_enum(arg0, arg1, arg2)
}

// RegisterFlags looks up or registers a flags type that is implemented with
// a particular type plugin. If a type with name @type_name was previously
// registered, the #GType identifier for the type is returned, otherwise the
// type is newly registered, and the resulting #GType identifier returned.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (m typeModule) RegisterFlags(m TypeModule, name string, constStaticValues *FlagsValue) {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar
	var arg2 *C.GFlagsValue

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GFlagsValue)(unsafe.Pointer(constStaticValues.Native()))

	C.g_type_module_register_flags(arg0, arg1, arg2)
}

// RegisterType looks up or registers a type that is implemented with a
// particular type plugin. If a type with name @type_name was previously
// registered, the #GType identifier for the type is returned, otherwise the
// type is newly registered, and the resulting #GType identifier returned.
//
// When reregistering a type (typically because a module is unloaded then
// reloaded, and reinitialized), @module and @parent_type must be the same
// as they were previously.
//
// As long as any instances of the type exist, the type plugin will not be
// unloaded.
//
// Since 2.56 if @module is nil this will call g_type_register_static()
// instead. This can be used when making a static build of the module.
func (m typeModule) RegisterType(m TypeModule, parentType externglib.Type, typeName string, typeInfo *TypeInfo, flags TypeFlags) {
	var arg0 *C.GTypeModule
	var arg1 C.GType
	var arg2 *C.gchar
	var arg3 *C.GTypeInfo
	var arg4 C.GTypeFlags

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))
	arg1 := C.GType(parentType)
	arg2 = (*C.gchar)(C.CString(typeName))
	defer C.free(unsafe.Pointer(arg2))
	arg3 = (*C.GTypeInfo)(unsafe.Pointer(typeInfo.Native()))
	arg4 = (C.GTypeFlags)(flags)

	C.g_type_module_register_type(arg0, arg1, arg2, arg3, arg4)
}

// SetName sets the name for a Module
func (m typeModule) SetName(m TypeModule, name string) {
	var arg0 *C.GTypeModule
	var arg1 *C.gchar

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))
	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	C.g_type_module_set_name(arg0, arg1)
}

// Unuse decreases the use count of a Module by one. If the result is zero,
// the module will be unloaded. (However, the Module will not be freed, and
// types associated with the Module are not unregistered. Once a Module is
// initialized, it must exist forever.)
func (m typeModule) Unuse(m TypeModule) {
	var arg0 *C.GTypeModule

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))

	C.g_type_module_unuse(arg0)
}

// Use increases the use count of a Module by one. If the use count was zero
// before, the plugin will be loaded. If loading the plugin fails, the use
// count is reset to its prior value.
func (m typeModule) Use(m TypeModule) bool {
	var arg0 *C.GTypeModule

	arg0 = (*C.GTypeModule)(unsafe.Pointer(m.Native()))

	var cret C.gboolean
	var ok bool

	cret = C.g_type_module_use(arg0)

	if cret {
		ok = true
	}

	return ok
}
