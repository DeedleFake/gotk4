// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_closure_get_type()), F: marshalClosure},
	})
}

// NewSignalTypeCclosure creates a new closure which invokes the function found
// at the offset @struct_offset in the class structure of the interface or
// classed type identified by @itype.
func NewSignalTypeCclosure(itype externglib.Type, structOffset uint) *Closure {
	var _arg1 C.GType     // out
	var _arg2 C.guint     // out
	var _cret *C.GClosure // in

	_arg1 = (C.GType)(itype)
	_arg2 = C.guint(structOffset)

	_cret = C.g_signal_type_cclosure_new(_arg1, _arg2)

	var _closure *Closure // out

	_closure = (*Closure)(unsafe.Pointer(_cret))

	return _closure
}

// CClosure: a Closure is a specialization of #GClosure for C function
// callbacks.
type CClosure C.GCClosure

// WrapCClosure wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapCClosure(ptr unsafe.Pointer) *CClosure {
	return (*CClosure)(ptr)
}

// Native returns the underlying C source pointer.
func (c *CClosure) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// Closure: a #GClosure represents a callback supplied by the programmer. It
// will generally comprise a function of some kind and a marshaller used to call
// it. It is the responsibility of the marshaller to convert the arguments for
// the invocation from #GValues into a suitable form, perform the callback on
// the converted arguments, and transform the return value back into a #GValue.
//
// In the case of C programs, a closure usually just holds a pointer to a
// function and maybe a data argument, and the marshaller converts between
// #GValue and native C types. The GObject library provides the Closure type for
// this purpose. Bindings for other languages need marshallers which convert
// between #GValues and suitable representations in the runtime of the language
// in order to use functions written in that language as callbacks. Use
// g_closure_set_marshal() to set the marshaller on such a custom closure
// implementation.
//
// Within GObject, closures play an important role in the implementation of
// signals. When a signal is registered, the @c_marshaller argument to
// g_signal_new() specifies the default C marshaller for any closure which is
// connected to this signal. GObject provides a number of C marshallers for this
// purpose, see the g_cclosure_marshal_*() functions. Additional C marshallers
// can be generated with the [glib-genmarshal][glib-genmarshal] utility.
// Closures can be explicitly connected to signals with
// g_signal_connect_closure(), but it usually more convenient to let GObject
// create a closure automatically by using one of the g_signal_connect_*()
// functions which take a callback function/user data pair.
//
// Using closures has a number of important advantages over a simple callback
// function/data pointer combination:
//
// - Closures allow the callee to get the types of the callback parameters,
// which means that language bindings don't have to write individual glue for
// each callback type.
//
// - The reference counting of #GClosure makes it easy to handle reentrancy
// right; if a callback is removed while it is being invoked, the closure and
// its parameters won't be freed until the invocation finishes.
//
// - g_closure_invalidate() and invalidation notifiers allow callbacks to be
// automatically removed when the objects they point to go away.
type Closure C.GClosure

// WrapClosure wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapClosure(ptr unsafe.Pointer) *Closure {
	return (*Closure)(ptr)
}

func marshalClosure(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*Closure)(unsafe.Pointer(b)), nil
}

// NewClosureObject constructs a struct Closure.
func NewClosureObject(sizeofClosure uint, object gextras.Objector) *Closure {
	var _arg1 C.guint     // out
	var _arg2 *C.GObject  // out
	var _cret *C.GClosure // in

	_arg1 = C.guint(sizeofClosure)
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

	_cret = C.g_closure_new_object(_arg1, _arg2)

	var _closure *Closure // out

	_closure = (*Closure)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(&_closure, func(v **Closure) {
		C.free(unsafe.Pointer(v))
	})

	return _closure
}

// NewClosureSimple constructs a struct Closure.
func NewClosureSimple(sizeofClosure uint, data interface{}) *Closure {
	var _arg1 C.guint     // out
	var _arg2 C.gpointer  // out
	var _cret *C.GClosure // in

	_arg1 = C.guint(sizeofClosure)
	_arg2 = C.gpointer(box.Assign(unsafe.Pointer(data)))

	_cret = C.g_closure_new_simple(_arg1, _arg2)

	var _closure *Closure // out

	_closure = (*Closure)(unsafe.Pointer(_cret))

	return _closure
}

// Native returns the underlying C source pointer.
func (c *Closure) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}

// Invalidate decrements the reference count of a closure after it was
// previously incremented by the same caller. If no other callers are using the
// closure, then the closure will be destroyed and freed.
func (c *Closure) Invalidate() {
	var _arg0 *C.GClosure // out

	_arg0 = (*C.GClosure)(unsafe.Pointer(c.Native()))

	C.g_closure_invalidate(_arg0)
}

// Invoke decrements the reference count of a closure after it was previously
// incremented by the same caller. If no other callers are using the closure,
// then the closure will be destroyed and freed.
func (c *Closure) Invoke(paramValues []externglib.Value, invocationHint interface{}) externglib.Value {
	var _arg0 *C.GClosure // out
	var _arg1 C.GValue    // in
	var _arg3 *C.GValue
	var _arg2 C.guint
	var _arg4 C.gpointer // out

	_arg0 = (*C.GClosure)(unsafe.Pointer(c.Native()))
	_arg2 = C.guint(len(paramValues))
	_arg3 = (*C.GValue)(C.malloc(C.ulong(len(paramValues)) * C.ulong(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice(_arg3, len(paramValues))
		for i := range paramValues {
			{
				var refTmpIn *externglib.Value
				var refTmpOut *C.GValue

				in0 := &paramValues[i]
				refTmpIn = in0

				refTmpOut = (*C.GValue)(unsafe.Pointer(&refTmpIn.GValue))

				out[i] = *refTmpOut
			}
		}
	}
	_arg4 = C.gpointer(box.Assign(unsafe.Pointer(invocationHint)))

	C.g_closure_invoke(_arg0, &_arg1, _arg2, _arg3, _arg4)

	var _returnValue externglib.Value // out

	{
		var refTmpIn *C.GValue
		var refTmpOut *externglib.Value

		in0 := &_arg1
		refTmpIn = in0

		refTmpOut = externglib.ValueFromNative(unsafe.Pointer(refTmpIn))

		_returnValue = *refTmpOut
	}

	return _returnValue
}

// Ref decrements the reference count of a closure after it was previously
// incremented by the same caller. If no other callers are using the closure,
// then the closure will be destroyed and freed.
func (c *Closure) Ref() *Closure {
	var _arg0 *C.GClosure // out
	var _cret *C.GClosure // in

	_arg0 = (*C.GClosure)(unsafe.Pointer(c.Native()))

	_cret = C.g_closure_ref(_arg0)

	var _ret *Closure // out

	_ret = (*Closure)(unsafe.Pointer(_cret))

	return _ret
}

// Sink decrements the reference count of a closure after it was previously
// incremented by the same caller. If no other callers are using the closure,
// then the closure will be destroyed and freed.
func (c *Closure) Sink() {
	var _arg0 *C.GClosure // out

	_arg0 = (*C.GClosure)(unsafe.Pointer(c.Native()))

	C.g_closure_sink(_arg0)
}

// Unref decrements the reference count of a closure after it was previously
// incremented by the same caller. If no other callers are using the closure,
// then the closure will be destroyed and freed.
func (c *Closure) Unref() {
	var _arg0 *C.GClosure // out

	_arg0 = (*C.GClosure)(unsafe.Pointer(c.Native()))

	C.g_closure_unref(_arg0)
}

type ClosureNotifyData C.GClosureNotifyData

// WrapClosureNotifyData wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapClosureNotifyData(ptr unsafe.Pointer) *ClosureNotifyData {
	return (*ClosureNotifyData)(ptr)
}

// Native returns the underlying C source pointer.
func (c *ClosureNotifyData) Native() unsafe.Pointer {
	return unsafe.Pointer(c)
}
