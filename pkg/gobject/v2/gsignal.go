// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib-object.h>
import "C"

// SignalCMarshaller: this is the signature of marshaller functions, required to
// marshall arrays of parameter values to signal emissions into C language
// callback invocations. It is merely an alias to Marshal since the #GClosure
// mechanism takes over responsibility of actual function invocation for the
// signal system.
type SignalCMarshaller ClosureMarshal

// SignalCVaMarshaller: this is the signature of va_list marshaller functions,
// an optional marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type SignalCVaMarshaller VaClosureMarshal

// ConnectFlags: the connection flags are used to specify the behaviour of a
// signal's connection.
type ConnectFlags int

const (
	// ConnectFlagsAfter: whether the handler should be called before or after
	// the default handler of the signal.
	ConnectFlagsAfter ConnectFlags = 0b1
	// ConnectFlagsSwapped: whether the instance and data should be swapped when
	// calling the handler; see g_signal_connect_swapped() for an example.
	ConnectFlagsSwapped ConnectFlags = 0b10
)

// SignalFlags: the signal flags are used to specify a signal's behaviour, the
// overall signal description outlines how especially the RUN flags control the
// stages of a signal emission.
type SignalFlags int

const (
	// SignalFlagsRunFirst: invoke the object method handler in the first
	// emission stage.
	SignalFlagsRunFirst SignalFlags = 0b1
	// SignalFlagsRunLast: invoke the object method handler in the third
	// emission stage.
	SignalFlagsRunLast SignalFlags = 0b10
	// SignalFlagsRunCleanup: invoke the object method handler in the last
	// emission stage.
	SignalFlagsRunCleanup SignalFlags = 0b100
	// SignalFlagsNoRecurse signals being emitted for an object while currently
	// being in emission for this very object will not be emitted recursively,
	// but instead cause the first emission to be restarted.
	SignalFlagsNoRecurse SignalFlags = 0b1000
	// SignalFlagsDetailed: this signal supports "::detail" appendices to the
	// signal name upon handler connections and emissions.
	SignalFlagsDetailed SignalFlags = 0b10000
	// SignalFlagsAction: action signals are signals that may freely be emitted
	// on alive objects from user code via g_signal_emit() and friends, without
	// the need of being embedded into extra code that performs pre or post
	// emission adjustments on the object. They can also be thought of as object
	// methods which can be called generically by third-party code.
	SignalFlagsAction SignalFlags = 0b100000
	// SignalFlagsNoHooks: no emissions hooks are supported for this signal.
	SignalFlagsNoHooks SignalFlags = 0b1000000
	// SignalFlagsMustCollect varargs signal emission will always collect the
	// arguments, even if there are no signal handlers connected. Since 2.30.
	SignalFlagsMustCollect SignalFlags = 0b10000000
	// SignalFlagsDeprecated: the signal is deprecated and will be removed in a
	// future version. A warning will be generated if it is connected while
	// running with G_ENABLE_DIAGNOSTIC=1. Since 2.32.
	SignalFlagsDeprecated SignalFlags = 0b100000000
)

// SignalMatchType: the match types specify what
// g_signal_handlers_block_matched(), g_signal_handlers_unblock_matched() and
// g_signal_handlers_disconnect_matched() match signals by.
type SignalMatchType int

const (
	// SignalMatchTypeID: the signal id must be equal.
	SignalMatchTypeID SignalMatchType = 0b1
	// SignalMatchTypeDetail: the signal detail must be equal.
	SignalMatchTypeDetail SignalMatchType = 0b10
	// SignalMatchTypeClosure: the closure must be the same.
	SignalMatchTypeClosure SignalMatchType = 0b100
	// SignalMatchTypeFunc: the C closure callback must be the same.
	SignalMatchTypeFunc SignalMatchType = 0b1000
	// SignalMatchTypeData: the closure data must be the same.
	SignalMatchTypeData SignalMatchType = 0b10000
	// SignalMatchTypeUnblocked: only unblocked signals may be matched.
	SignalMatchTypeUnblocked SignalMatchType = 0b100000
)

// ClearSignalHandler disconnects a handler from @instance so it will not be
// called during any future or currently ongoing emissions of the signal it has
// been connected to. The @handler_id_ptr is then set to zero, which is never a
// valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// A macro is also included that allows this function to be used without pointer
// casts.
func ClearSignalHandler(handlerIDPtr uint32, instance gextras.Objector) {
	var arg1 *C.gulong
	var arg2 C.gpointer

	arg1 = *C.gulong(handlerIDPtr)
	arg2 = (*C.GObject)(unsafe.Pointer(instance.Native()))

	C.g_clear_signal_handler(handlerIDPtr, instance)
}

// SignalAccumulatorFirstWins: a predefined Accumulator for signals intended to
// be used as a hook for application code to provide a particular value. Usually
// only one such value is desired and multiple handlers for the same signal
// don't make much sense (except for the case of the default handler defined in
// the class structure, in which case you will usually want the signal
// connection to override the class handler).
//
// This accumulator will use the return value from the first signal handler that
// is run as the return value for the signal and not run any further handlers
// (ie: the first handler "wins").
func SignalAccumulatorFirstWins(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(dummy)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_signal_accumulator_first_wins(ihint, returnAccu, handlerReturn, dummy)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SignalAccumulatorTrueHandled: a predefined Accumulator for signals that
// return a boolean values. The behavior that this accumulator gives is that a
// return of true stops the signal emission: no further callbacks will be
// invoked, while a return of false allows the emission to continue. The idea
// here is that a true return indicates that the callback handled the signal,
// and no further handling is needed.
func SignalAccumulatorTrueHandled(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(dummy)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_signal_accumulator_true_handled(ihint, returnAccu, handlerReturn, dummy)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SignalAddEmissionHook adds an emission hook for a signal, which will get
// called for any emission of that signal, independent of the instance. This is
// possible only for signals which don't have SIGNAL_NO_HOOKS flag set.
func SignalAddEmissionHook(signalID uint, detail glib.Quark, hookFunc SignalEmissionHook) uint32 {

	var cret C.gulong
	var ret1 uint32

	cret = C.g_signal_add_emission_hook(signalID, detail, hookFunc, hookData, dataDestroy)

	ret1 = C.gulong(cret)

	return ret1
}

// SignalGetInvocationHint returns the invocation hint of the innermost signal
// emission of instance.
func SignalGetInvocationHint(instance gextras.Objector) *SignalInvocationHint {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))

	var cret *C.GSignalInvocationHint
	var ret1 *SignalInvocationHint

	cret = C.g_signal_get_invocation_hint(instance)

	ret1 = WrapSignalInvocationHint(unsafe.Pointer(cret))

	return ret1
}

// SignalHandlerBlock blocks a handler of an instance so it will not be called
// during any signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler has to be
// unblocked exactly the same amount of times it has been blocked before to
// become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerBlock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_block(instance, handlerID)
}

// SignalHandlerDisconnect disconnects a handler from an instance so it will not
// be called during any future or currently ongoing emissions of the signal it
// has been connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerDisconnect(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_disconnect(instance, handlerID)
}

// SignalHandlerIsConnected returns whether @handler_id is the ID of a handler
// connected to @instance.
func SignalHandlerIsConnected(instance gextras.Objector, handlerID uint32) bool {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	arg2 = C.gulong(handlerID)

	var cret C.gboolean
	var ret1 bool

	cret = C.g_signal_handler_is_connected(instance, handlerID)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SignalHandlerUnblock undoes the effect of a previous g_signal_handler_block()
// call. A blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been blocked
// before) reverts its "blocked" state, so the handler will be recognized by the
// signal system and is called upon future or currently ongoing signal emissions
// (since the order in which handlers are called during signal emissions is
// deterministic, whether the unblocked handler in question is called as part of
// a currently ongoing emission depends on how far that emission has proceeded
// yet).
//
// The @handler_id has to be a valid id of a signal handler that is connected to
// a signal of @instance and is currently blocked.
func SignalHandlerUnblock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_unblock(instance, handlerID)
}

// SignalHandlersDestroy: destroy all signal handlers of a type instance. This
// function is an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(instance gextras.Objector) {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))

	C.g_signal_handlers_destroy(instance)
}

// SignalIsValidName: validate a signal name. This can be useful for
// dynamically-generated signals which need to be validated at run-time before
// actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of the
// rules for valid names. The rules for signal names are the same as those for
// property names.
func SignalIsValidName(name string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	var cret C.gboolean
	var ret1 bool

	cret = C.g_signal_is_valid_name(name)

	ret1 = C.bool(cret) != C.false

	return ret1
}

// SignalListIds lists the signals by id that a certain instance or interface
// type created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIds(itype externglib.Type) (nIds uint, guints []uint) {
	var arg1 C.GType

	arg1 := C.GType(itype)

	var cret *C.guint
	var arg2 *C.guint
	var ret2 []uint

	cret = C.g_signal_list_ids(itype, &arg2)

	ptr.SetSlice(unsafe.Pointer(&ret2), unsafe.Pointer(cret), int(arg2))
	runtime.SetFinalizer(&ret2, func(v *[]uint) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return ret2, ret2
}

// SignalLookup: given the name of the signal and the type of object it connects
// to, gets the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype externglib.Type) uint {
	var arg1 *C.gchar
	var arg2 C.GType

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 := C.GType(itype)

	var cret C.guint
	var ret1 uint

	cret = C.g_signal_lookup(name, itype)

	ret1 = C.guint(cret)

	return ret1
}

// SignalName: given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(signalID uint) string {
	var arg1 C.guint

	arg1 = C.guint(signalID)

	var cret *C.gchar
	var ret1 string

	cret = C.g_signal_name(signalID)

	ret1 = C.GoString(cret)

	return ret1
}

// SignalQuery queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided structure to hold
// signal-specific information. If an invalid signal id is passed in, the
// @signal_id member of the Query is 0. All members filled into the Query
// structure should be considered constant and have to be left untouched.
func SignalQuery(signalID uint) SignalQuery {
	var arg1 C.guint

	arg1 = C.guint(signalID)

	var arg2 C.GSignalQuery
	var ret2 *SignalQuery

	C.g_signal_query(signalID, &arg2)

	*ret2 = WrapSignalQuery(unsafe.Pointer(arg2))

	return ret2
}

// SignalRemoveEmissionHook deletes an emission hook.
func SignalRemoveEmissionHook(signalID uint, hookID uint32) {
	var arg1 C.guint
	var arg2 C.gulong

	arg1 = C.guint(signalID)
	arg2 = C.gulong(hookID)

	C.g_signal_remove_emission_hook(signalID, hookID)
}

// SignalStopEmissionByName stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the signal
// id for you.
func SignalStopEmissionByName(instance gextras.Objector, detailedSignal string) {
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg2))

	C.g_signal_stop_emission_by_name(instance, detailedSignal)
}

// SignalInvocationHint: the InvocationHint structure is used to pass on
// additional information to callbacks during a signal emission.
type SignalInvocationHint struct {
	native C.GSignalInvocationHint
}

// WrapSignalInvocationHint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalInvocationHint(ptr unsafe.Pointer) *SignalInvocationHint {
	if ptr == nil {
		return nil
	}

	return (*SignalInvocationHint)(ptr)
}

func marshalSignalInvocationHint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalInvocationHint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalInvocationHint) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalInvocationHint) SignalID() uint {
	v = C.guint(s.native.signal_id)
}

// RunType gets the field inside the struct.
func (s *SignalInvocationHint) RunType() SignalFlags {
	v = SignalFlags(s.native.run_type)
}

// SignalQuery: a structure holding in-depth information for a specific signal.
// It is filled in by the g_signal_query() function.
type SignalQuery struct {
	native C.GSignalQuery
}

// WrapSignalQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalQuery(ptr unsafe.Pointer) *SignalQuery {
	if ptr == nil {
		return nil
	}

	return (*SignalQuery)(ptr)
}

func marshalSignalQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalQuery) SignalID() uint {
	v = C.guint(s.native.signal_id)
}

// SignalName gets the field inside the struct.
func (s *SignalQuery) SignalName() string {
	v = C.GoString(s.native.signal_name)
}

// Itype gets the field inside the struct.
func (s *SignalQuery) Itype() externglib.Type {
	v = externglib.Type(s.native.itype)
}

// SignalFlags gets the field inside the struct.
func (s *SignalQuery) SignalFlags() SignalFlags {
	v = SignalFlags(s.native.signal_flags)
}

// ReturnType gets the field inside the struct.
func (s *SignalQuery) ReturnType() externglib.Type {
	v = externglib.Type(s.native.return_type)
}

// NParams gets the field inside the struct.
func (s *SignalQuery) NParams() uint {
	v = C.guint(s.native.n_params)
}
