// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/ptr"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0 glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// SignalCMarshaller: this is the signature of marshaller functions, required to
// marshall arrays of parameter values to signal emissions into C language
// callback invocations. It is merely an alias to Marshal since the #GClosure
// mechanism takes over responsibility of actual function invocation for the
// signal system.
type SignalCMarshaller ClosureMarshal

// SignalCVaMarshaller: this is the signature of va_list marshaller functions,
// an optional marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type SignalCVaMarshaller VaClosureMarshal

// ConnectFlags: the connection flags are used to specify the behaviour of a
// signal's connection.
type ConnectFlags int

const (
	// ConnectFlagsAfter: whether the handler should be called before or after
	// the default handler of the signal.
	ConnectFlagsAfter ConnectFlags = 1
	// ConnectFlagsSwapped: whether the instance and data should be swapped when
	// calling the handler; see g_signal_connect_swapped() for an example.
	ConnectFlagsSwapped ConnectFlags = 2
)

// SignalFlags: the signal flags are used to specify a signal's behaviour, the
// overall signal description outlines how especially the RUN flags control the
// stages of a signal emission.
type SignalFlags int

const (
	// SignalFlagsRunFirst: invoke the object method handler in the first
	// emission stage.
	SignalFlagsRunFirst SignalFlags = 1
	// SignalFlagsRunLast: invoke the object method handler in the third
	// emission stage.
	SignalFlagsRunLast SignalFlags = 2
	// SignalFlagsRunCleanup: invoke the object method handler in the last
	// emission stage.
	SignalFlagsRunCleanup SignalFlags = 4
	// SignalFlagsNoRecurse signals being emitted for an object while currently
	// being in emission for this very object will not be emitted recursively,
	// but instead cause the first emission to be restarted.
	SignalFlagsNoRecurse SignalFlags = 8
	// SignalFlagsDetailed: this signal supports "::detail" appendices to the
	// signal name upon handler connections and emissions.
	SignalFlagsDetailed SignalFlags = 16
	// SignalFlagsAction: action signals are signals that may freely be emitted
	// on alive objects from user code via g_signal_emit() and friends, without
	// the need of being embedded into extra code that performs pre or post
	// emission adjustments on the object. They can also be thought of as object
	// methods which can be called generically by third-party code.
	SignalFlagsAction SignalFlags = 32
	// SignalFlagsNoHooks: no emissions hooks are supported for this signal.
	SignalFlagsNoHooks SignalFlags = 64
	// SignalFlagsMustCollect varargs signal emission will always collect the
	// arguments, even if there are no signal handlers connected. Since 2.30.
	SignalFlagsMustCollect SignalFlags = 128
	// SignalFlagsDeprecated: the signal is deprecated and will be removed in a
	// future version. A warning will be generated if it is connected while
	// running with G_ENABLE_DIAGNOSTIC=1. Since 2.32.
	SignalFlagsDeprecated SignalFlags = 256
	// SignalFlagsAccumulatorFirstRun: only used in Accumulator accumulator
	// functions for the InvocationHint::run_type field to mark the first call
	// to the accumulator function for a signal emission. Since 2.68.
	SignalFlagsAccumulatorFirstRun SignalFlags = 131072
)

// SignalMatchType: the match types specify what
// g_signal_handlers_block_matched(), g_signal_handlers_unblock_matched() and
// g_signal_handlers_disconnect_matched() match signals by.
type SignalMatchType int

const (
	// SignalMatchTypeID: the signal id must be equal.
	SignalMatchTypeID SignalMatchType = 1
	// SignalMatchTypeDetail: the signal detail must be equal.
	SignalMatchTypeDetail SignalMatchType = 2
	// SignalMatchTypeClosure: the closure must be the same.
	SignalMatchTypeClosure SignalMatchType = 4
	// SignalMatchTypeFunc: the C closure callback must be the same.
	SignalMatchTypeFunc SignalMatchType = 8
	// SignalMatchTypeData: the closure data must be the same.
	SignalMatchTypeData SignalMatchType = 16
	// SignalMatchTypeUnblocked: only unblocked signals may be matched.
	SignalMatchTypeUnblocked SignalMatchType = 32
)

// ClearSignalHandler disconnects a handler from @instance so it will not be
// called during any future or currently ongoing emissions of the signal it has
// been connected to. The @handler_id_ptr is then set to zero, which is never a
// valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// There is also a macro version of this function so that the code will be
// inlined.
func ClearSignalHandler(handlerIdPtr *uint32, instance gextras.Objector) {
	var _arg1 *C.gulong  // out
	var _arg2 C.gpointer // out

	_arg1 = *C.gulong(handlerIdPtr)
	_arg2 = (*C.GObject)(unsafe.Pointer(instance.Native()))

	C.g_clear_signal_handler(_arg1, _arg2)
}

// SignalAccumulatorFirstWins: a predefined Accumulator for signals intended to
// be used as a hook for application code to provide a particular value. Usually
// only one such value is desired and multiple handlers for the same signal
// don't make much sense (except for the case of the default handler defined in
// the class structure, in which case you will usually want the signal
// connection to override the class handler).
//
// This accumulator will use the return value from the first signal handler that
// is run as the return value for the signal and not run any further handlers
// (ie: the first handler "wins").
func SignalAccumulatorFirstWins(ihint *SignalInvocationHint, returnAccu **externglib.Value, handlerReturn **externglib.Value, dummy interface{}) bool {
	var _arg1 *C.GSignalInvocationHint // out
	var _arg2 *C.GValue                // out
	var _arg3 *C.GValue                // out
	var _arg4 C.gpointer               // out

	_arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	_arg2 = (*C.GValue)(returnAccu.GValue)
	_arg3 = (*C.GValue)(handlerReturn.GValue)
	_arg4 = C.gpointer(dummy)

	var _cret C.gboolean // in

	_cret = C.g_signal_accumulator_first_wins(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SignalAccumulatorTrueHandled: a predefined Accumulator for signals that
// return a boolean values. The behavior that this accumulator gives is that a
// return of true stops the signal emission: no further callbacks will be
// invoked, while a return of false allows the emission to continue. The idea
// here is that a true return indicates that the callback handled the signal,
// and no further handling is needed.
func SignalAccumulatorTrueHandled(ihint *SignalInvocationHint, returnAccu **externglib.Value, handlerReturn **externglib.Value, dummy interface{}) bool {
	var _arg1 *C.GSignalInvocationHint // out
	var _arg2 *C.GValue                // out
	var _arg3 *C.GValue                // out
	var _arg4 C.gpointer               // out

	_arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	_arg2 = (*C.GValue)(returnAccu.GValue)
	_arg3 = (*C.GValue)(handlerReturn.GValue)
	_arg4 = C.gpointer(dummy)

	var _cret C.gboolean // in

	_cret = C.g_signal_accumulator_true_handled(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SignalHandlerBlock blocks a handler of an instance so it will not be called
// during any signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler has to be
// unblocked exactly the same amount of times it has been blocked before to
// become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerBlock(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_block(_arg1, _arg2)
}

// SignalHandlerDisconnect disconnects a handler from an instance so it will not
// be called during any future or currently ongoing emissions of the signal it
// has been connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerDisconnect(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_disconnect(_arg1, _arg2)
}

// SignalHandlerIsConnected returns whether @handler_id is the ID of a handler
// connected to @instance.
func SignalHandlerIsConnected(instance gextras.Objector, handlerId uint32) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	var _cret C.gboolean // in

	_cret = C.g_signal_handler_is_connected(_arg1, _arg2)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SignalHandlerUnblock undoes the effect of a previous g_signal_handler_block()
// call. A blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been blocked
// before) reverts its "blocked" state, so the handler will be recognized by the
// signal system and is called upon future or currently ongoing signal emissions
// (since the order in which handlers are called during signal emissions is
// deterministic, whether the unblocked handler in question is called as part of
// a currently ongoing emission depends on how far that emission has proceeded
// yet).
//
// The @handler_id has to be a valid id of a signal handler that is connected to
// a signal of @instance and is currently blocked.
func SignalHandlerUnblock(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_unblock(_arg1, _arg2)
}

// SignalHandlersDestroy: destroy all signal handlers of a type instance. This
// function is an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(instance gextras.Objector) {
	var _arg1 C.gpointer // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))

	C.g_signal_handlers_destroy(_arg1)
}

// SignalIsValidName: validate a signal name. This can be useful for
// dynamically-generated signals which need to be validated at run-time before
// actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of the
// rules for valid names. The rules for signal names are the same as those for
// property names.
func SignalIsValidName(name string) bool {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	var _cret C.gboolean // in

	_cret = C.g_signal_is_valid_name(_arg1)

	var _ok bool // out

	if _cret {
		_ok = true
	}

	return _ok
}

// SignalListIds lists the signals by id that a certain instance or interface
// type created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIds(itype externglib.Type) []uint {
	var _arg1 C.GType // out

	_arg1 = C.GType(itype)

	var _cret *C.guint
	var _arg2 C.guint // in

	_cret = C.g_signal_list_ids(_arg1, &_arg2)

	var _guints []uint

	ptr.SetSlice(unsafe.Pointer(&_guints), unsafe.Pointer(_cret), int(_arg2))
	runtime.SetFinalizer(&_guints, func(v *[]uint) {
		C.free(ptr.Slice(unsafe.Pointer(v)))
	})

	return _guints
}

// SignalLookup: given the name of the signal and the type of object it connects
// to, gets the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype externglib.Type) uint {
	var _arg1 *C.gchar // out
	var _arg2 C.GType  // out

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(itype)

	var _cret C.guint // in

	_cret = C.g_signal_lookup(_arg1, _arg2)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// SignalName: given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(signalId uint) string {
	var _arg1 C.guint // out

	_arg1 = C.guint(signalId)

	var _cret *C.gchar // in

	_cret = C.g_signal_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SignalQuery queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided structure to hold
// signal-specific information. If an invalid signal id is passed in, the
// @signal_id member of the Query is 0. All members filled into the Query
// structure should be considered constant and have to be left untouched.
func SignalQuery(signalId uint) SignalQuery {
	var _arg1 C.guint // out

	_arg1 = C.guint(signalId)

	var _query SignalQuery

	C.g_signal_query(_arg1, (*C.GSignalQuery)(unsafe.Pointer(&_query)))

	return _query
}

// SignalRemoveEmissionHook deletes an emission hook.
func SignalRemoveEmissionHook(signalId uint, hookId uint32) {
	var _arg1 C.guint  // out
	var _arg2 C.gulong // out

	_arg1 = C.guint(signalId)
	_arg2 = C.gulong(hookId)

	C.g_signal_remove_emission_hook(_arg1, _arg2)
}

// SignalStopEmissionByName stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the signal
// id for you.
func SignalStopEmissionByName(instance gextras.Objector, detailedSignal string) {
	var _arg1 C.gpointer // out
	var _arg2 *C.gchar   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(instance.Native()))
	_arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_signal_stop_emission_by_name(_arg1, _arg2)
}

// SignalInvocationHint: the InvocationHint structure is used to pass on
// additional information to callbacks during a signal emission.
type SignalInvocationHint struct {
	native C.GSignalInvocationHint
}

// WrapSignalInvocationHint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalInvocationHint(ptr unsafe.Pointer) *SignalInvocationHint {
	if ptr == nil {
		return nil
	}

	return (*SignalInvocationHint)(ptr)
}

func marshalSignalInvocationHint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalInvocationHint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalInvocationHint) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalInvocationHint) SignalID() uint {
	var v uint // out
	v = (uint)(s.native.signal_id)
	return v
}

// SignalQuery: a structure holding in-depth information for a specific signal.
// It is filled in by the g_signal_query() function.
type SignalQuery struct {
	native C.GSignalQuery
}

// WrapSignalQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalQuery(ptr unsafe.Pointer) *SignalQuery {
	if ptr == nil {
		return nil
	}

	return (*SignalQuery)(ptr)
}

func marshalSignalQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalQuery) SignalID() uint {
	var v uint // out
	v = (uint)(s.native.signal_id)
	return v
}

// SignalName gets the field inside the struct.
func (s *SignalQuery) SignalName() string {
	var v string // out
	v = C.GoString(s.native.signal_name)
	return v
}

// Itype gets the field inside the struct.
func (s *SignalQuery) Itype() externglib.Type {
	var v externglib.Type // out
	v = externglib.Type(s.native.itype)
	return v
}

// ReturnType gets the field inside the struct.
func (s *SignalQuery) ReturnType() externglib.Type {
	var v externglib.Type // out
	v = externglib.Type(s.native.return_type)
	return v
}

// NParams gets the field inside the struct.
func (s *SignalQuery) NParams() uint {
	var v uint // out
	v = (uint)(s.native.n_params)
	return v
}
