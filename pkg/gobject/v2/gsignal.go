// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/box"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// ConnectFlags: the connection flags are used to specify the behaviour of a
// signal's connection.
type ConnectFlags int

const (
	// ConnectFlagsAfter: whether the handler should be called before or after
	// the default handler of the signal.
	ConnectFlagsAfter ConnectFlags = 0b1
	// ConnectFlagsSwapped: whether the instance and data should be swapped when
	// calling the handler; see g_signal_connect_swapped() for an example.
	ConnectFlagsSwapped ConnectFlags = 0b10
)

// SignalFlags: the signal flags are used to specify a signal's behaviour, the
// overall signal description outlines how especially the RUN flags control the
// stages of a signal emission.
type SignalFlags int

const (
	// SignalFlagsRunFirst: invoke the object method handler in the first
	// emission stage.
	SignalFlagsRunFirst SignalFlags = 0b1
	// SignalFlagsRunLast: invoke the object method handler in the third
	// emission stage.
	SignalFlagsRunLast SignalFlags = 0b10
	// SignalFlagsRunCleanup: invoke the object method handler in the last
	// emission stage.
	SignalFlagsRunCleanup SignalFlags = 0b100
	// SignalFlagsNoRecurse signals being emitted for an object while currently
	// being in emission for this very object will not be emitted recursively,
	// but instead cause the first emission to be restarted.
	SignalFlagsNoRecurse SignalFlags = 0b1000
	// SignalFlagsDetailed: this signal supports "::detail" appendices to the
	// signal name upon handler connections and emissions.
	SignalFlagsDetailed SignalFlags = 0b10000
	// SignalFlagsAction: action signals are signals that may freely be emitted
	// on alive objects from user code via g_signal_emit() and friends, without
	// the need of being embedded into extra code that performs pre or post
	// emission adjustments on the object. They can also be thought of as object
	// methods which can be called generically by third-party code.
	SignalFlagsAction SignalFlags = 0b100000
	// SignalFlagsNoHooks: no emissions hooks are supported for this signal.
	SignalFlagsNoHooks SignalFlags = 0b1000000
	// SignalFlagsMustCollect varargs signal emission will always collect the
	// arguments, even if there are no signal handlers connected. Since 2.30.
	SignalFlagsMustCollect SignalFlags = 0b10000000
	// SignalFlagsDeprecated: the signal is deprecated and will be removed in a
	// future version. A warning will be generated if it is connected while
	// running with G_ENABLE_DIAGNOSTIC=1. Since 2.32.
	SignalFlagsDeprecated SignalFlags = 0b100000000
	// SignalFlagsAccumulatorFirstRun: only used in Accumulator accumulator
	// functions for the InvocationHint::run_type field to mark the first call
	// to the accumulator function for a signal emission. Since 2.68.
	SignalFlagsAccumulatorFirstRun SignalFlags = 0b100000000000000000
)

// SignalMatchType: the match types specify what
// g_signal_handlers_block_matched(), g_signal_handlers_unblock_matched() and
// g_signal_handlers_disconnect_matched() match signals by.
type SignalMatchType int

const (
	// SignalMatchTypeID: the signal id must be equal.
	SignalMatchTypeID SignalMatchType = 0b1
	// SignalMatchTypeDetail: the signal detail must be equal.
	SignalMatchTypeDetail SignalMatchType = 0b10
	// SignalMatchTypeClosure: the closure must be the same.
	SignalMatchTypeClosure SignalMatchType = 0b100
	// SignalMatchTypeFunc: the C closure callback must be the same.
	SignalMatchTypeFunc SignalMatchType = 0b1000
	// SignalMatchTypeData: the closure data must be the same.
	SignalMatchTypeData SignalMatchType = 0b10000
	// SignalMatchTypeUnblocked: only unblocked signals may be matched.
	SignalMatchTypeUnblocked SignalMatchType = 0b100000
)

// ClearSignalHandler disconnects a handler from @instance so it will not be
// called during any future or currently ongoing emissions of the signal it has
// been connected to. The @handler_id_ptr is then set to zero, which is never a
// valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// There is also a macro version of this function so that the code will be
// inlined.
func ClearSignalHandler(handlerIdPtr *uint32, instance gextras.Objector) {
	var _arg1 *C.gulong  // out
	var _arg2 C.gpointer // out

	_arg1 = (*C.gulong)(unsafe.Pointer(handlerIdPtr))
	_arg2 = (C.gpointer)(unsafe.Pointer(instance.Native()))

	C.g_clear_signal_handler(_arg1, _arg2)
}

// SignalAccumulatorFirstWins: a predefined Accumulator for signals intended to
// be used as a hook for application code to provide a particular value. Usually
// only one such value is desired and multiple handlers for the same signal
// don't make much sense (except for the case of the default handler defined in
// the class structure, in which case you will usually want the signal
// connection to override the class handler).
//
// This accumulator will use the return value from the first signal handler that
// is run as the return value for the signal and not run any further handlers
// (ie: the first handler "wins").
func SignalAccumulatorFirstWins(ihint *SignalInvocationHint, returnAccu externglib.Value, handlerReturn externglib.Value, dummy interface{}) bool {
	var _arg1 *C.GSignalInvocationHint // out
	var _arg2 *C.GValue                // out
	var _arg3 *C.GValue                // out
	var _arg4 C.gpointer               // out
	var _cret C.gboolean               // in

	_arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(&returnAccu.GValue))
	_arg3 = (*C.GValue)(unsafe.Pointer(&handlerReturn.GValue))
	_arg4 = C.gpointer(box.Assign(unsafe.Pointer(dummy)))

	_cret = C.g_signal_accumulator_first_wins(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SignalAccumulatorTrueHandled: a predefined Accumulator for signals that
// return a boolean values. The behavior that this accumulator gives is that a
// return of true stops the signal emission: no further callbacks will be
// invoked, while a return of false allows the emission to continue. The idea
// here is that a true return indicates that the callback handled the signal,
// and no further handling is needed.
func SignalAccumulatorTrueHandled(ihint *SignalInvocationHint, returnAccu externglib.Value, handlerReturn externglib.Value, dummy interface{}) bool {
	var _arg1 *C.GSignalInvocationHint // out
	var _arg2 *C.GValue                // out
	var _arg3 *C.GValue                // out
	var _arg4 C.gpointer               // out
	var _cret C.gboolean               // in

	_arg1 = (*C.GSignalInvocationHint)(unsafe.Pointer(ihint.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(&returnAccu.GValue))
	_arg3 = (*C.GValue)(unsafe.Pointer(&handlerReturn.GValue))
	_arg4 = C.gpointer(box.Assign(unsafe.Pointer(dummy)))

	_cret = C.g_signal_accumulator_true_handled(_arg1, _arg2, _arg3, _arg4)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SignalConnectClosure connects a closure to a signal for a particular object.
func SignalConnectClosure(instance gextras.Objector, detailedSignal string, closure *Closure, after bool) uint32 {
	var _arg1 C.gpointer  // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.GClosure // out
	var _arg4 C.gboolean  // out
	var _cret C.gulong    // in

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GClosure)(unsafe.Pointer(closure.Native()))
	if after {
		_arg4 = C.TRUE
	}

	_cret = C.g_signal_connect_closure(_arg1, _arg2, _arg3, _arg4)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// SignalGetInvocationHint returns the invocation hint of the innermost signal
// emission of instance.
func SignalGetInvocationHint(instance gextras.Objector) *SignalInvocationHint {
	var _arg1 C.gpointer               // out
	var _cret *C.GSignalInvocationHint // in

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))

	_cret = C.g_signal_get_invocation_hint(_arg1)

	var _signalInvocationHint *SignalInvocationHint // out

	_signalInvocationHint = (*SignalInvocationHint)(unsafe.Pointer(_cret))

	return _signalInvocationHint
}

// SignalHandlerBlock blocks a handler of an instance so it will not be called
// during any signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler has to be
// unblocked exactly the same amount of times it has been blocked before to
// become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerBlock(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_block(_arg1, _arg2)
}

// SignalHandlerDisconnect disconnects a handler from an instance so it will not
// be called during any future or currently ongoing emissions of the signal it
// has been connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerDisconnect(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_disconnect(_arg1, _arg2)
}

// SignalHandlerIsConnected returns whether @handler_id is the ID of a handler
// connected to @instance.
func SignalHandlerIsConnected(instance gextras.Objector, handlerId uint32) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	_cret = C.g_signal_handler_is_connected(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SignalHandlerUnblock undoes the effect of a previous g_signal_handler_block()
// call. A blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been blocked
// before) reverts its "blocked" state, so the handler will be recognized by the
// signal system and is called upon future or currently ongoing signal emissions
// (since the order in which handlers are called during signal emissions is
// deterministic, whether the unblocked handler in question is called as part of
// a currently ongoing emission depends on how far that emission has proceeded
// yet).
//
// The @handler_id has to be a valid id of a signal handler that is connected to
// a signal of @instance and is currently blocked.
func SignalHandlerUnblock(instance gextras.Objector, handlerId uint32) {
	var _arg1 C.gpointer // out
	var _arg2 C.gulong   // out

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = C.gulong(handlerId)

	C.g_signal_handler_unblock(_arg1, _arg2)
}

// SignalHandlersDestroy: destroy all signal handlers of a type instance. This
// function is an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(instance gextras.Objector) {
	var _arg1 C.gpointer // out

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))

	C.g_signal_handlers_destroy(_arg1)
}

// SignalIsValidName: validate a signal name. This can be useful for
// dynamically-generated signals which need to be validated at run-time before
// actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of the
// rules for valid names. The rules for signal names are the same as those for
// property names.
func SignalIsValidName(name string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_signal_is_valid_name(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SignalLookup: given the name of the signal and the type of object it connects
// to, gets the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype externglib.Type) uint {
	var _arg1 *C.gchar // out
	var _arg2 C.GType  // out
	var _cret C.guint  // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.GType)(itype)

	_cret = C.g_signal_lookup(_arg1, _arg2)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SignalName: given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(signalId uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(signalId)

	_cret = C.g_signal_name(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// SignalOverrideClassClosure overrides the class closure (i.e. the default
// handler) for the given signal for emissions on instances of @instance_type.
// @instance_type must be derived from the type to which the signal belongs.
//
// See g_signal_chain_from_overridden() and
// g_signal_chain_from_overridden_handler() for how to chain up to the parent
// class closure from inside the overridden one.
func SignalOverrideClassClosure(signalId uint, instanceType externglib.Type, classClosure *Closure) {
	var _arg1 C.guint     // out
	var _arg2 C.GType     // out
	var _arg3 *C.GClosure // out

	_arg1 = C.guint(signalId)
	_arg2 = (C.GType)(instanceType)
	_arg3 = (*C.GClosure)(unsafe.Pointer(classClosure.Native()))

	C.g_signal_override_class_closure(_arg1, _arg2, _arg3)
}

// SignalQuery queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided structure to hold
// signal-specific information. If an invalid signal id is passed in, the
// @signal_id member of the Query is 0. All members filled into the Query
// structure should be considered constant and have to be left untouched.
func SignalQuery(signalId uint) SignalQuery {
	var _arg1 C.guint        // out
	var _arg2 C.GSignalQuery // in

	_arg1 = C.guint(signalId)

	C.g_signal_query(_arg1, &_arg2)

	var _query SignalQuery // out

	{
		var refTmpIn *C.GSignalQuery
		var refTmpOut *SignalQuery

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*SignalQuery)(unsafe.Pointer(refTmpIn))

		_query = *refTmpOut
	}

	return _query
}

// SignalRemoveEmissionHook deletes an emission hook.
func SignalRemoveEmissionHook(signalId uint, hookId uint32) {
	var _arg1 C.guint  // out
	var _arg2 C.gulong // out

	_arg1 = C.guint(signalId)
	_arg2 = C.gulong(hookId)

	C.g_signal_remove_emission_hook(_arg1, _arg2)
}

// SignalStopEmissionByName stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the signal
// id for you.
func SignalStopEmissionByName(instance gextras.Objector, detailedSignal string) {
	var _arg1 C.gpointer // out
	var _arg2 *C.gchar   // out

	_arg1 = (C.gpointer)(unsafe.Pointer(instance.Native()))
	_arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_signal_stop_emission_by_name(_arg1, _arg2)
}

// SignalInvocationHint: the InvocationHint structure is used to pass on
// additional information to callbacks during a signal emission.
type SignalInvocationHint C.GSignalInvocationHint

// WrapSignalInvocationHint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalInvocationHint(ptr unsafe.Pointer) *SignalInvocationHint {
	return (*SignalInvocationHint)(ptr)
}

// Native returns the underlying C source pointer.
func (s *SignalInvocationHint) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}

// SignalQuery: a structure holding in-depth information for a specific signal.
// It is filled in by the g_signal_query() function.
type SignalQuery C.GSignalQuery

// WrapSignalQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalQuery(ptr unsafe.Pointer) *SignalQuery {
	return (*SignalQuery)(ptr)
}

// Native returns the underlying C source pointer.
func (s *SignalQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(s)
}
