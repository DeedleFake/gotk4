// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/box"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <stdbool.h>
// #include <glib-object.h>
import "C"

// SignalCMarshaller: this is the signature of marshaller functions, required to
// marshall arrays of parameter values to signal emissions into C language
// callback invocations. It is merely an alias to Marshal since the #GClosure
// mechanism takes over responsibility of actual function invocation for the
// signal system.
type SignalCMarshaller ClosureMarshal

// SignalCVaMarshaller: this is the signature of va_list marshaller functions,
// an optional marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type SignalCVaMarshaller VaClosureMarshal

// ConnectFlags: the connection flags are used to specify the behaviour of a
// signal's connection.
type ConnectFlags int

const (
	// ConnectFlagsAfter: whether the handler should be called before or after
	// the default handler of the signal.
	ConnectFlagsAfter ConnectFlags = 0b1
	// ConnectFlagsSwapped: whether the instance and data should be swapped when
	// calling the handler; see g_signal_connect_swapped() for an example.
	ConnectFlagsSwapped ConnectFlags = 0b10
)

// SignalFlags: the signal flags are used to specify a signal's behaviour, the
// overall signal description outlines how especially the RUN flags control the
// stages of a signal emission.
type SignalFlags int

const (
	// SignalFlagsRunFirst: invoke the object method handler in the first
	// emission stage.
	SignalFlagsRunFirst SignalFlags = 0b1
	// SignalFlagsRunLast: invoke the object method handler in the third
	// emission stage.
	SignalFlagsRunLast SignalFlags = 0b10
	// SignalFlagsRunCleanup: invoke the object method handler in the last
	// emission stage.
	SignalFlagsRunCleanup SignalFlags = 0b100
	// SignalFlagsNoRecurse signals being emitted for an object while currently
	// being in emission for this very object will not be emitted recursively,
	// but instead cause the first emission to be restarted.
	SignalFlagsNoRecurse SignalFlags = 0b1000
	// SignalFlagsDetailed: this signal supports "::detail" appendices to the
	// signal name upon handler connections and emissions.
	SignalFlagsDetailed SignalFlags = 0b10000
	// SignalFlagsAction: action signals are signals that may freely be emitted
	// on alive objects from user code via g_signal_emit() and friends, without
	// the need of being embedded into extra code that performs pre or post
	// emission adjustments on the object. They can also be thought of as object
	// methods which can be called generically by third-party code.
	SignalFlagsAction SignalFlags = 0b100000
	// SignalFlagsNoHooks: no emissions hooks are supported for this signal.
	SignalFlagsNoHooks SignalFlags = 0b1000000
	// SignalFlagsMustCollect varargs signal emission will always collect the
	// arguments, even if there are no signal handlers connected. Since 2.30.
	SignalFlagsMustCollect SignalFlags = 0b10000000
	// SignalFlagsDeprecated: the signal is deprecated and will be removed in a
	// future version. A warning will be generated if it is connected while
	// running with G_ENABLE_DIAGNOSTIC=1. Since 2.32.
	SignalFlagsDeprecated SignalFlags = 0b100000000
	// SignalFlagsAccumulatorFirstRun: only used in Accumulator accumulator
	// functions for the InvocationHint::run_type field to mark the first call
	// to the accumulator function for a signal emission. Since 2.68.
	SignalFlagsAccumulatorFirstRun SignalFlags = 0b100000000000000000
)

// SignalMatchType: the match types specify what
// g_signal_handlers_block_matched(), g_signal_handlers_unblock_matched() and
// g_signal_handlers_disconnect_matched() match signals by.
type SignalMatchType int

const (
	// SignalMatchTypeID: the signal id must be equal.
	SignalMatchTypeID SignalMatchType = 0b1
	// SignalMatchTypeDetail: the signal detail must be equal.
	SignalMatchTypeDetail SignalMatchType = 0b10
	// SignalMatchTypeClosure: the closure must be the same.
	SignalMatchTypeClosure SignalMatchType = 0b100
	// SignalMatchTypeFunc: the C closure callback must be the same.
	SignalMatchTypeFunc SignalMatchType = 0b1000
	// SignalMatchTypeData: the closure data must be the same.
	SignalMatchTypeData SignalMatchType = 0b10000
	// SignalMatchTypeUnblocked: only unblocked signals may be matched.
	SignalMatchTypeUnblocked SignalMatchType = 0b100000
)

// ClearSignalHandler disconnects a handler from @instance so it will not be
// called during any future or currently ongoing emissions of the signal it has
// been connected to. The @handler_id_ptr is then set to zero, which is never a
// valid handler ID value (see g_signal_connect()).
//
// If the handler ID is 0 then this function does nothing.
//
// There is also a macro version of this function so that the code will be
// inlined.
func ClearSignalHandler(handlerIDPtr uint32, instance gextras.Objector) {
	var arg1 *C.gulong
	var arg2 C.gpointer

	arg1 = (*C.gulong)(handlerIDPtr)
	arg2 = (*C.GObject)(instance.Native())

	C.g_clear_signal_handler(arg1, arg2)
}

// SignalAccumulatorFirstWins: a predefined Accumulator for signals intended to
// be used as a hook for application code to provide a particular value. Usually
// only one such value is desired and multiple handlers for the same signal
// don't make much sense (except for the case of the default handler defined in
// the class structure, in which case you will usually want the signal
// connection to override the class handler).
//
// This accumulator will use the return value from the first signal handler that
// is run as the return value for the signal and not run any further handlers
// (ie: the first handler "wins").
func SignalAccumulatorFirstWins(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(ihint.Native())
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(box.Assign(dummy))

	ret := C.g_signal_accumulator_first_wins(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// SignalAccumulatorTrueHandled: a predefined Accumulator for signals that
// return a boolean values. The behavior that this accumulator gives is that a
// return of true stops the signal emission: no further callbacks will be
// invoked, while a return of false allows the emission to continue. The idea
// here is that a true return indicates that the callback handled the signal,
// and no further handling is needed.
func SignalAccumulatorTrueHandled(ihint *SignalInvocationHint, returnAccu *externglib.Value, handlerReturn *externglib.Value, dummy interface{}) bool {
	var arg1 *C.GSignalInvocationHint
	var arg2 *C.GValue
	var arg3 *C.GValue
	var arg4 C.gpointer

	arg1 = (*C.GSignalInvocationHint)(ihint.Native())
	arg2 = (*C.GValue)(returnAccu.GValue)
	arg3 = (*C.GValue)(handlerReturn.GValue)
	arg4 = C.gpointer(box.Assign(dummy))

	ret := C.g_signal_accumulator_true_handled(arg1, arg2, arg3, arg4)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// SignalConnectData connects a #GCallback function to a signal for a particular
// object. Similar to g_signal_connect(), but allows to provide a Notify for the
// data which will be called when the signal handler is disconnected and no
// longer used. Specify @connect_flags if you need `..._after()` or
// `..._swapped()` variants of this function.
func SignalConnectData(instance gextras.Objector, detailedSignal string, cHandler Callback, destroyData ClosureNotify, connectFlags ConnectFlags) uint32 {
	var arg1 C.gpointer
	var arg2 *C.gchar
	var arg3 C.GCallback
	var arg4 C.gpointer
	var arg5 C.GClosureNotify
	var arg6 C.GConnectFlags

	arg1 = (*C.GObject)(instance.Native())
	arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg2))
	arg6 = (C.GConnectFlags)(connectFlags)

	ret := C.g_signal_connect_data(arg1, arg2, arg3, arg4, arg5, arg6)

	var ret0 uint32

	ret0 = uint32(ret)

	return ret0
}

// SignalGetInvocationHint returns the invocation hint of the innermost signal
// emission of instance.
func SignalGetInvocationHint(instance gextras.Objector) *SignalInvocationHint {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(instance.Native())

	ret := C.g_signal_get_invocation_hint(arg1)

	var ret0 *SignalInvocationHint

	{
		ret0 = WrapSignalInvocationHint(unsafe.Pointer(ret))
	}

	return ret0
}

// SignalHandlerBlock blocks a handler of an instance so it will not be called
// during any signal emissions unless it is unblocked again. Thus "blocking" a
// signal handler means to temporarily deactivate it, a signal handler has to be
// unblocked exactly the same amount of times it has been blocked before to
// become active again.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerBlock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_block(arg1, arg2)
}

// SignalHandlerDisconnect disconnects a handler from an instance so it will not
// be called during any future or currently ongoing emissions of the signal it
// has been connected to. The @handler_id becomes invalid and may be reused.
//
// The @handler_id has to be a valid signal handler id, connected to a signal of
// @instance.
func SignalHandlerDisconnect(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_disconnect(arg1, arg2)
}

// SignalHandlerIsConnected returns whether @handler_id is the ID of a handler
// connected to @instance.
func SignalHandlerIsConnected(instance gextras.Objector, handlerID uint32) bool {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	ret := C.g_signal_handler_is_connected(arg1, arg2)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// SignalHandlerUnblock undoes the effect of a previous g_signal_handler_block()
// call. A blocked handler is skipped during signal emissions and will not be
// invoked, unblocking it (for exactly the amount of times it has been blocked
// before) reverts its "blocked" state, so the handler will be recognized by the
// signal system and is called upon future or currently ongoing signal emissions
// (since the order in which handlers are called during signal emissions is
// deterministic, whether the unblocked handler in question is called as part of
// a currently ongoing emission depends on how far that emission has proceeded
// yet).
//
// The @handler_id has to be a valid id of a signal handler that is connected to
// a signal of @instance and is currently blocked.
func SignalHandlerUnblock(instance gextras.Objector, handlerID uint32) {
	var arg1 C.gpointer
	var arg2 C.gulong

	arg1 = (*C.GObject)(instance.Native())
	arg2 = C.gulong(handlerID)

	C.g_signal_handler_unblock(arg1, arg2)
}

// SignalHandlersDestroy: destroy all signal handlers of a type instance. This
// function is an implementation detail of the #GObject dispose implementation,
// and should not be used outside of the type system.
func SignalHandlersDestroy(instance gextras.Objector) {
	var arg1 C.gpointer

	arg1 = (*C.GObject)(instance.Native())

	C.g_signal_handlers_destroy(arg1)
}

// SignalIsValidName: validate a signal name. This can be useful for
// dynamically-generated signals which need to be validated at run-time before
// actually trying to create them.
//
// See [canonical parameter names][canonical-parameter-names] for details of the
// rules for valid names. The rules for signal names are the same as those for
// property names.
func SignalIsValidName(name string) bool {
	var arg1 *C.gchar

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))

	ret := C.g_signal_is_valid_name(arg1)

	var ret0 bool

	ret0 = C.bool(ret) != 0

	return ret0
}

// SignalListIds lists the signals by id that a certain instance or interface
// type created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIds(itype externglib.Type) (nIds uint, guints []uint) {
	var arg1 C.GType
	var arg2 *C.guint // out

	arg1 = C.GType(itype)

	ret := C.g_signal_list_ids(arg1, &arg2)

	var ret0 uint
	var ret1 []uint

	ret0 = uint(arg2)

	{
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&ret1))
		sliceHeader.Data = uintptr(unsafe.Pointer(ret))
		sliceHeader.Len = arg2
		sliceHeader.Cap = arg2
		runtime.SetFinalizer(&ret, func() {
			C.free(unsafe.Pointer(ret))
		})
		defer runtime.KeepAlive(ret)
	}

	return ret0, ret1
}

// SignalLookup: given the name of the signal and the type of object it connects
// to, gets the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
//
// Also tries the ancestors of the given type.
//
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
//
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype externglib.Type) uint {
	var arg1 *C.gchar
	var arg2 C.GType

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(itype)

	ret := C.g_signal_lookup(arg1, arg2)

	var ret0 uint

	ret0 = uint(ret)

	return ret0
}

// SignalName: given the signal's identifier, finds its name.
//
// Two different signals may have the same name, if they have differing types.
func SignalName(signalID uint) string {
	var arg1 C.guint

	arg1 = C.guint(signalID)

	ret := C.g_signal_name(arg1)

	var ret0 string

	ret0 = C.GoString(ret)

	return ret0
}

// SignalParseName: internal function to parse a signal name into its @signal_id
// and @detail quark.
func SignalParseName(detailedSignal string, itype externglib.Type, forceDetailQuark bool) (signalIDP uint, detailP glib.Quark, ok bool) {
	var arg1 *C.gchar
	var arg2 C.GType
	var arg3 *C.guint  // out
	var arg4 *C.GQuark // out
	var arg5 C.gboolean

	arg1 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = C.GType(itype)
	if forceDetailQuark {
		arg5 = C.TRUE
	}

	ret := C.g_signal_parse_name(arg1, arg2, &arg3, &arg4, arg5)

	var ret0 uint
	var ret1 *glib.Quark
	var ret2 bool

	ret0 = uint(arg3)

	{
		var tmp uint32
		tmp = uint32(arg4)
		ret1 = *glib.Quark(tmp)
	}

	ret2 = C.bool(ret) != 0

	return ret0, ret1, ret2
}

// SignalQuery queries the signal system for in-depth information about a
// specific signal. This function will fill in a user-provided structure to hold
// signal-specific information. If an invalid signal id is passed in, the
// @signal_id member of the Query is 0. All members filled into the Query
// structure should be considered constant and have to be left untouched.
func SignalQuery(signalID uint) SignalQuery {
	var arg1 C.guint
	var arg2 *C.GSignalQuery // out

	arg1 = C.guint(signalID)

	C.g_signal_query(arg1, &arg2)

	var ret0 *SignalQuery

	{
		ret0 = WrapSignalQuery(unsafe.Pointer(arg2))
	}

	return ret0
}

// SignalRemoveEmissionHook deletes an emission hook.
func SignalRemoveEmissionHook(signalID uint, hookID uint32) {
	var arg1 C.guint
	var arg2 C.gulong

	arg1 = C.guint(signalID)
	arg2 = C.gulong(hookID)

	C.g_signal_remove_emission_hook(arg1, arg2)
}

// SignalStopEmissionByName stops a signal's current emission.
//
// This is just like g_signal_stop_emission() except it will look up the signal
// id for you.
func SignalStopEmissionByName(instance gextras.Objector, detailedSignal string) {
	var arg1 C.gpointer
	var arg2 *C.gchar

	arg1 = (*C.GObject)(instance.Native())
	arg2 = (*C.gchar)(C.CString(detailedSignal))
	defer C.free(unsafe.Pointer(arg2))

	C.g_signal_stop_emission_by_name(arg1, arg2)
}

// SignalInvocationHint: the InvocationHint structure is used to pass on
// additional information to callbacks during a signal emission.
type SignalInvocationHint struct {
	native C.GSignalInvocationHint
}

// WrapSignalInvocationHint wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalInvocationHint(ptr unsafe.Pointer) *SignalInvocationHint {
	if ptr == nil {
		return nil
	}

	return (*SignalInvocationHint)(ptr)
}

func marshalSignalInvocationHint(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalInvocationHint(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalInvocationHint) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalInvocationHint) SignalID() uint {
	var ret uint
	ret = uint(s.native.signal_id)
	return ret
}

// Detail gets the field inside the struct.
func (s *SignalInvocationHint) Detail() glib.Quark {
	var ret glib.Quark
	{
		var tmp uint32
		tmp = uint32(s.native.detail)
		ret = glib.Quark(tmp)
	}
	return ret
}

// RunType gets the field inside the struct.
func (s *SignalInvocationHint) RunType() SignalFlags {
	var ret SignalFlags
	ret = SignalFlags(s.native.run_type)
	return ret
}

// SignalQuery: a structure holding in-depth information for a specific signal.
// It is filled in by the g_signal_query() function.
type SignalQuery struct {
	native C.GSignalQuery
}

// WrapSignalQuery wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapSignalQuery(ptr unsafe.Pointer) *SignalQuery {
	if ptr == nil {
		return nil
	}

	return (*SignalQuery)(ptr)
}

func marshalSignalQuery(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapSignalQuery(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (s *SignalQuery) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// SignalID gets the field inside the struct.
func (s *SignalQuery) SignalID() uint {
	var ret uint
	ret = uint(s.native.signal_id)
	return ret
}

// SignalName gets the field inside the struct.
func (s *SignalQuery) SignalName() string {
	var ret string
	ret = C.GoString(s.native.signal_name)
	return ret
}

// Itype gets the field inside the struct.
func (s *SignalQuery) Itype() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(s.native.itype)
	return ret
}

// SignalFlags gets the field inside the struct.
func (s *SignalQuery) SignalFlags() SignalFlags {
	var ret SignalFlags
	ret = SignalFlags(s.native.signal_flags)
	return ret
}

// ReturnType gets the field inside the struct.
func (s *SignalQuery) ReturnType() externglib.Type {
	var ret externglib.Type
	ret = externglib.Type(s.native.return_type)
	return ret
}

// NParams gets the field inside the struct.
func (s *SignalQuery) NParams() uint {
	var ret uint
	ret = uint(s.native.n_params)
	return ret
}

// ParamTypes gets the field inside the struct.
func (s *SignalQuery) ParamTypes() []externglib.Type {
	var ret []externglib.Type
	{
		ret = make([]externglib.Type, s.native.n_params)
		for i := 0; i < uintptr(s.native.n_params); i++ {
			src := (C.GType)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + i))
			ret[i] = externglib.Type(src)
		}
	}
	return ret
}
