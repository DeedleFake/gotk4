// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// EnumCompleteTypeInfo: this function is meant to be called from the
// `complete_type_info` function of a Plugin implementation, as in the following
// example:
//
//    static void
//    my_enum_complete_type_info (GTypePlugin     *plugin,
//                                GType            g_type,
//                                GTypeInfo       *info,
//                                GTypeValueTable *value_table)
//    {
//      static const GEnumValue values[] = {
//        { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
//        { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
//        { 0, NULL, NULL }
//      };
//
//      g_enum_complete_type_info (type, info, values);
//    }
func EnumCompleteTypeInfo(gEnumType externglib.Type, constValues *EnumValue) TypeInfo {
	var _arg1 C.GType
	var _arg3 *C.GEnumValue

	_arg1 = C.GType(gEnumType)
	_arg3 = (*C.GEnumValue)(unsafe.Pointer(constValues.Native()))

	var _info TypeInfo

	C.g_enum_complete_type_info(_arg1, _arg3, (*C.GTypeInfo)(unsafe.Pointer(&_info)))

	return _info
}

// EnumRegisterStatic registers a new static enumeration type with the name
// @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums], generate
// a my_enum_get_type() function from a usual C enumeration definition than to
// write one yourself using g_enum_register_static().
func EnumRegisterStatic(name string, constStaticValues *EnumValue) externglib.Type {
	var _arg1 *C.gchar
	var _arg2 *C.GEnumValue

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GEnumValue)(unsafe.Pointer(constStaticValues.Native()))

	var _cret C.GType

	cret = C.g_enum_register_static(_arg1, _arg2)

	var _gType externglib.Type

	_gType = externglib.Type(_cret)

	return _gType
}

// EnumToString pretty-prints @value in the form of the enumâ€™s name.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func EnumToString(gEnumType externglib.Type, value int) string {
	var _arg1 C.GType
	var _arg2 C.gint

	_arg1 = C.GType(gEnumType)
	_arg2 = C.gint(value)

	var _cret *C.gchar

	cret = C.g_enum_to_string(_arg1, _arg2)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FlagsCompleteTypeInfo: this function is meant to be called from the
// complete_type_info() function of a Plugin implementation, see the example for
// g_enum_complete_type_info() above.
func FlagsCompleteTypeInfo(gFlagsType externglib.Type, constValues *FlagsValue) TypeInfo {
	var _arg1 C.GType
	var _arg3 *C.GFlagsValue

	_arg1 = C.GType(gFlagsType)
	_arg3 = (*C.GFlagsValue)(unsafe.Pointer(constValues.Native()))

	var _info TypeInfo

	C.g_flags_complete_type_info(_arg1, _arg3, (*C.GTypeInfo)(unsafe.Pointer(&_info)))

	return _info
}

// FlagsRegisterStatic registers a new static flags type with the name @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums] generate a
// my_flags_get_type() function from a usual C enumeration definition than to
// write one yourself using g_flags_register_static().
func FlagsRegisterStatic(name string, constStaticValues *FlagsValue) externglib.Type {
	var _arg1 *C.gchar
	var _arg2 *C.GFlagsValue

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GFlagsValue)(unsafe.Pointer(constStaticValues.Native()))

	var _cret C.GType

	cret = C.g_flags_register_static(_arg1, _arg2)

	var _gType externglib.Type

	_gType = externglib.Type(_cret)

	return _gType
}

// FlagsToString pretty-prints @value in the form of the flag names separated by
// ` | ` and sorted. Any extra bits will be shown at the end as a hexadecimal
// number.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func FlagsToString(flagsType externglib.Type, value uint) string {
	var _arg1 C.GType
	var _arg2 C.guint

	_arg1 = C.GType(flagsType)
	_arg2 = C.guint(value)

	var _cret *C.gchar

	cret = C.g_flags_to_string(_arg1, _arg2)

	var _utf8 string

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// EnumValue: a structure which contains a single enum value, its name, and its
// nickname.
type EnumValue struct {
	native C.GEnumValue
}

// WrapEnumValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEnumValue(ptr unsafe.Pointer) *EnumValue {
	if ptr == nil {
		return nil
	}

	return (*EnumValue)(ptr)
}

func marshalEnumValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEnumValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EnumValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// Value gets the field inside the struct.
func (e *EnumValue) Value() int {
	var v int
	v = (int)(e.native.value)
	return v
}

// ValueName gets the field inside the struct.
func (e *EnumValue) ValueName() string {
	var v string
	v = C.GoString(e.native.value_name)
	return v
}

// ValueNick gets the field inside the struct.
func (e *EnumValue) ValueNick() string {
	var v string
	v = C.GoString(e.native.value_nick)
	return v
}

// FlagsValue: a structure which contains a single flags value, its name, and
// its nickname.
type FlagsValue struct {
	native C.GFlagsValue
}

// WrapFlagsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFlagsValue(ptr unsafe.Pointer) *FlagsValue {
	if ptr == nil {
		return nil
	}

	return (*FlagsValue)(ptr)
}

func marshalFlagsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFlagsValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FlagsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Value gets the field inside the struct.
func (f *FlagsValue) Value() uint {
	var v uint
	v = (uint)(f.native.value)
	return v
}

// ValueName gets the field inside the struct.
func (f *FlagsValue) ValueName() string {
	var v string
	v = C.GoString(f.native.value_name)
	return v
}

// ValueNick gets the field inside the struct.
func (f *FlagsValue) ValueNick() string {
	var v string
	v = C.GoString(f.native.value_nick)
	return v
}
