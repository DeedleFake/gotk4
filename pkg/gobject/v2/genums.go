// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
//
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// EnumCompleteTypeInfo: this function is meant to be called from the
// `complete_type_info` function of a Plugin implementation, as in the following
// example:
//
//    static void
//    my_enum_complete_type_info (GTypePlugin     *plugin,
//                                GType            g_type,
//                                GTypeInfo       *info,
//                                GTypeValueTable *value_table)
//    {
//      static const GEnumValue values[] = {
//        { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
//        { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
//        { 0, NULL, NULL }
//      };
//
//      g_enum_complete_type_info (type, info, values);
//    }
func EnumCompleteTypeInfo(gEnumType externglib.Type, constValues *EnumValue) TypeInfo {
	var _arg1 C.GType       // out
	var _arg2 C.GTypeInfo   // in
	var _arg3 *C.GEnumValue // out

	_arg1 = (C.GType)(gEnumType)
	_arg3 = (*C.GEnumValue)(unsafe.Pointer(constValues.Native()))

	C.g_enum_complete_type_info(_arg1, &_arg2, _arg3)

	var _info TypeInfo // out

	{
		var refTmpIn *C.GTypeInfo
		var refTmpOut *TypeInfo

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*TypeInfo)(unsafe.Pointer(refTmpIn))
		runtime.SetFinalizer(&refTmpOut, func(v **TypeInfo) {
			C.free(unsafe.Pointer(v))
		})

		_info = *refTmpOut
	}

	return _info
}

// EnumRegisterStatic registers a new static enumeration type with the name
// @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums], generate
// a my_enum_get_type() function from a usual C enumeration definition than to
// write one yourself using g_enum_register_static().
func EnumRegisterStatic(name string, constStaticValues *EnumValue) externglib.Type {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GEnumValue // out
	var _cret C.GType       // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GEnumValue)(unsafe.Pointer(constStaticValues.Native()))

	_cret = C.g_enum_register_static(_arg1, _arg2)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// EnumToString pretty-prints @value in the form of the enumâ€™s name.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func EnumToString(gEnumType externglib.Type, value int) string {
	var _arg1 C.GType  // out
	var _arg2 C.gint   // out
	var _cret *C.gchar // in

	_arg1 = (C.GType)(gEnumType)
	_arg2 = C.gint(value)

	_cret = C.g_enum_to_string(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FlagsCompleteTypeInfo: this function is meant to be called from the
// complete_type_info() function of a Plugin implementation, see the example for
// g_enum_complete_type_info() above.
func FlagsCompleteTypeInfo(gFlagsType externglib.Type, constValues *FlagsValue) TypeInfo {
	var _arg1 C.GType        // out
	var _arg2 C.GTypeInfo    // in
	var _arg3 *C.GFlagsValue // out

	_arg1 = (C.GType)(gFlagsType)
	_arg3 = (*C.GFlagsValue)(unsafe.Pointer(constValues.Native()))

	C.g_flags_complete_type_info(_arg1, &_arg2, _arg3)

	var _info TypeInfo // out

	{
		var refTmpIn *C.GTypeInfo
		var refTmpOut *TypeInfo

		in0 := &_arg2
		refTmpIn = in0

		refTmpOut = (*TypeInfo)(unsafe.Pointer(refTmpIn))
		runtime.SetFinalizer(&refTmpOut, func(v **TypeInfo) {
			C.free(unsafe.Pointer(v))
		})

		_info = *refTmpOut
	}

	return _info
}

// FlagsRegisterStatic registers a new static flags type with the name @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums] generate a
// my_flags_get_type() function from a usual C enumeration definition than to
// write one yourself using g_flags_register_static().
func FlagsRegisterStatic(name string, constStaticValues *FlagsValue) externglib.Type {
	var _arg1 *C.gchar       // out
	var _arg2 *C.GFlagsValue // out
	var _cret C.GType        // in

	_arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GFlagsValue)(unsafe.Pointer(constStaticValues.Native()))

	_cret = C.g_flags_register_static(_arg1, _arg2)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// FlagsToString pretty-prints @value in the form of the flag names separated by
// ` | ` and sorted. Any extra bits will be shown at the end as a hexadecimal
// number.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func FlagsToString(flagsType externglib.Type, value uint) string {
	var _arg1 C.GType  // out
	var _arg2 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = (C.GType)(flagsType)
	_arg2 = C.guint(value)

	_cret = C.g_flags_to_string(_arg1, _arg2)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// EnumValue: a structure which contains a single enum value, its name, and its
// nickname.
type EnumValue C.GEnumValue

// WrapEnumValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEnumValue(ptr unsafe.Pointer) *EnumValue {
	return (*EnumValue)(ptr)
}

// Native returns the underlying C source pointer.
func (e *EnumValue) Native() unsafe.Pointer {
	return unsafe.Pointer(e)
}

// FlagsValue: a structure which contains a single flags value, its name, and
// its nickname.
type FlagsValue C.GFlagsValue

// WrapFlagsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFlagsValue(ptr unsafe.Pointer) *FlagsValue {
	return (*FlagsValue)(ptr)
}

// Native returns the underlying C source pointer.
func (f *FlagsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(f)
}
