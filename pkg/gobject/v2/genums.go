// Code generated by girgen. DO NOT EDIT.

package gobject

import (
	"runtime"
	"unsafe"

	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib-object.h>
import "C"

// EnumCompleteTypeInfo: this function is meant to be called from the
// `complete_type_info` function of a Plugin implementation, as in the following
// example:
//
//    static void
//    my_enum_complete_type_info (GTypePlugin     *plugin,
//                                GType            g_type,
//                                GTypeInfo       *info,
//                                GTypeValueTable *value_table)
//    {
//      static const GEnumValue values[] = {
//        { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
//        { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
//        { 0, NULL, NULL }
//      };
//
//      g_enum_complete_type_info (type, info, values);
//    }
func EnumCompleteTypeInfo(gEnumType externglib.Type, constValues *EnumValue) TypeInfo {
	var arg1 C.GType
	var arg2 *C.GTypeInfo // out
	var arg3 *C.GEnumValue

	arg1 = C.GType(gEnumType)
	arg3 = (*C.GEnumValue)(constValues.Native())

	C.g_enum_complete_type_info(arg1, &arg2, arg3)

	var ret0 *TypeInfo

	{
		ret0 = WrapTypeInfo(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v *TypeInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// EnumRegisterStatic registers a new static enumeration type with the name
// @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums], generate
// a my_enum_get_type() function from a usual C enumeration definition than to
// write one yourself using g_enum_register_static().
func EnumRegisterStatic(name string, constStaticValues *EnumValue) externglib.Type {
	var arg1 *C.gchar
	var arg2 *C.GEnumValue

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GEnumValue)(constStaticValues.Native())

	ret := C.g_enum_register_static(arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// EnumToString pretty-prints @value in the form of the enumâ€™s name.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func EnumToString(gEnumType externglib.Type, value int) string {
	var arg1 C.GType
	var arg2 C.gint

	arg1 = C.GType(gEnumType)
	arg2 = C.gint(value)

	ret := C.g_enum_to_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// FlagsCompleteTypeInfo: this function is meant to be called from the
// complete_type_info() function of a Plugin implementation, see the example for
// g_enum_complete_type_info() above.
func FlagsCompleteTypeInfo(gFlagsType externglib.Type, constValues *FlagsValue) TypeInfo {
	var arg1 C.GType
	var arg2 *C.GTypeInfo // out
	var arg3 *C.GFlagsValue

	arg1 = C.GType(gFlagsType)
	arg3 = (*C.GFlagsValue)(constValues.Native())

	C.g_flags_complete_type_info(arg1, &arg2, arg3)

	var ret0 *TypeInfo

	{
		ret0 = WrapTypeInfo(unsafe.Pointer(arg2))
		runtime.SetFinalizer(ret0, func(v *TypeInfo) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	return ret0
}

// FlagsRegisterStatic registers a new static flags type with the name @name.
//
// It is normally more convenient to let [glib-mkenums][glib-mkenums] generate a
// my_flags_get_type() function from a usual C enumeration definition than to
// write one yourself using g_flags_register_static().
func FlagsRegisterStatic(name string, constStaticValues *FlagsValue) externglib.Type {
	var arg1 *C.gchar
	var arg2 *C.GFlagsValue

	arg1 = (*C.gchar)(C.CString(name))
	defer C.free(unsafe.Pointer(arg1))
	arg2 = (*C.GFlagsValue)(constStaticValues.Native())

	ret := C.g_flags_register_static(arg1, arg2)

	var ret0 externglib.Type

	ret0 = externglib.Type(ret)

	return ret0
}

// FlagsToString pretty-prints @value in the form of the flag names separated by
// ` | ` and sorted. Any extra bits will be shown at the end as a hexadecimal
// number.
//
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func FlagsToString(flagsType externglib.Type, value uint) string {
	var arg1 C.GType
	var arg2 C.guint

	arg1 = C.GType(flagsType)
	arg2 = C.guint(value)

	ret := C.g_flags_to_string(arg1, arg2)

	var ret0 string

	ret0 = C.GoString(ret)
	C.free(unsafe.Pointer(ret))

	return ret0
}

// EnumValue: a structure which contains a single enum value, its name, and its
// nickname.
type EnumValue struct {
	native C.GEnumValue
}

// WrapEnumValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapEnumValue(ptr unsafe.Pointer) *EnumValue {
	if ptr == nil {
		return nil
	}

	return (*EnumValue)(ptr)
}

func marshalEnumValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapEnumValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (e *EnumValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&e.native)
}

// Value gets the field inside the struct.
func (e *EnumValue) Value() int {
	var ret int
	ret = int(e.native.value)
	return ret
}

// ValueName gets the field inside the struct.
func (e *EnumValue) ValueName() string {
	var ret string
	ret = C.GoString(e.native.value_name)
	return ret
}

// ValueNick gets the field inside the struct.
func (e *EnumValue) ValueNick() string {
	var ret string
	ret = C.GoString(e.native.value_nick)
	return ret
}

// FlagsValue: a structure which contains a single flags value, its name, and
// its nickname.
type FlagsValue struct {
	native C.GFlagsValue
}

// WrapFlagsValue wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFlagsValue(ptr unsafe.Pointer) *FlagsValue {
	if ptr == nil {
		return nil
	}

	return (*FlagsValue)(ptr)
}

func marshalFlagsValue(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFlagsValue(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FlagsValue) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// Value gets the field inside the struct.
func (f *FlagsValue) Value() uint {
	var ret uint
	ret = uint(f.native.value)
	return ret
}

// ValueName gets the field inside the struct.
func (f *FlagsValue) ValueName() string {
	var ret string
	ret = C.GoString(f.native.value_name)
	return ret
}

// ValueNick gets the field inside the struct.
func (f *FlagsValue) ValueNick() string {
	var ret string
	ret = C.GoString(f.native.value_nick)
	return ret
}
