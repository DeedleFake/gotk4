package girgen

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/diamondburned/gotk4/gir"
	"github.com/diamondburned/gotk4/internal/pen"
	"github.com/pkg/errors"
)

// FileGenerator contains values to fully construct a generated file.
type FileGenerator struct {
	parent *NamespaceGenerator
	pen    *pen.PaperString // body

	name       string
	marshalers []string

	SideEffects
}

// NewFileGenerator creates a new FileGenerator.
func NewFileGenerator(parent *NamespaceGenerator, goFile string) *FileGenerator {
	fg := FileGenerator{
		parent: parent,
		pen:    pen.NewPaperStringSize(2 * 1024 * 1024), // 2MB
		name:   goFile,
		// overallocate
		marshalers: make([]string, 0, 0+
			len(parent.current.Namespace.Enums)+
			len(parent.current.Namespace.Bitfields)+
			len(parent.current.Namespace.Records)+
			len(parent.current.Namespace.Classes)+
			len(parent.current.Namespace.Interfaces),
		),
	}

	return &fg
}

func replaceExt(name, ext string) string {
	parts := strings.Split(name, ".")

	switch len(parts) {
	case 0:
		return ""
	case 1:
		return parts[0] + ext
	default:
		return strings.Join(parts[:len(parts)-1], ".") + ext
	}
}

// isRootFile returns true if the current file is the origin file, or the file
// that is the fallback..
func (fg *FileGenerator) isRootFile() bool {
	return strings.Split(fg.name, ".")[0] == fg.parent.PackageName()
}

func (fg *FileGenerator) generate() ([]byte, error) {
	if len(fg.marshalers) > 0 {
		fg.addImportAlias("github.com/gotk3/gotk3/glib", "externglib")
	}

	if fg.CallbackDelete {
		fg.addImportInternal("box")
		fg.addCallbackHeader("extern void callbackDelete(gpointer);")
	}

	var out bytes.Buffer
	// Preallocate 10KB + existing buffers.
	out.Grow(10*1024 + fg.pen.Len())

	pen := pen.NewPen(&out)
	pen.Words("// Code generated by girgen. DO NOT EDIT.")
	pen.EmptyLine()

	pen.Words("package", fg.parent.PackageName())
	pen.EmptyLine()

	if len(fg.Imports) > 0 {
		builtin := make([]string, 0, len(fg.Imports))
		externs := make([]string, 0, len(fg.Imports))

		for path, alias := range fg.Imports {
			// Skip importing the current package.
			if path == fg.parent.pkgPath {
				continue
			}

			if !strings.Contains(path, "/") {
				builtin = append(builtin, makeImport(path, alias))
			} else {
				externs = append(externs, makeImport(path, alias))
			}
		}

		sort.Strings(builtin)
		sort.Strings(externs)

		pen.Words("import (")

		for _, str := range builtin {
			pen.Words(str)
		}
		if len(builtin) > 0 && len(externs) > 0 {
			pen.EmptyLine()
		}
		for _, str := range externs {
			pen.Words(str)
		}

		pen.Line(")")
		pen.EmptyLine()
		pen.EmptyLine()
	}

	pen.Words(append([]string{"// #cgo pkg-config:"}, fg.pkgconfig()...)...)
	pen.Words("// #cgo CFLAGS: -Wno-deprecated-declarations")

	for _, cIncl := range fg.cIncludes() {
		pen.Linef("// #include <%s>", cIncl)
	}

	if len(fg.Callbacks) > 0 {
		pen.Words("//")
		for _, callback := range fg.callbackHeaders() {
			pen.Words("//", callback)
		}
	}

	pen.Words(`import "C"`)
	pen.EmptyLine()

	if len(fg.marshalers) > 0 {
		pen.Words("func init() {")
		pen.Words("  externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{")

		for _, marshaler := range fg.marshalers {
			pen.Words("      " + marshaler)
		}

		pen.Words("  })")
		pen.Words("}")
		pen.EmptyLine()
	}

	// Only write the Go definition in one file.
	if fg.CallbackDelete && fg.isRootFile() {
		pen.Words("//export callbackDelete")
		pen.Words("func callbackDelete(ptr C.gpointer) {")
		pen.Words("  box.Delete(box.Callback, uintptr(ptr))")
		pen.Words("}")
		pen.EmptyLine()
	}

	pen.WriteString(fg.pen.String())

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		fg.Logln(LogError, "failed to fmt file", fg.name)
		return out.Bytes(), errors.Wrap(err, "fmt file "+fg.name)
	}

	return formatted, nil
}

func makeImport(importPath, alias string) string {
	pathBase := path.Base(importPath)

	// Check if the base is a version part.
	if strings.HasPrefix(pathBase, "v") {
		_, err := strconv.Atoi(strings.TrimPrefix(pathBase, "v"))
		if err == nil {
			// Valid version part. Trim it.
			pathBase = path.Base(path.Dir(importPath))
		}
	}

	if alias == "" || alias == pathBase {
		return strconv.Quote(importPath)
	}

	// Only use the import alias if it's provided and does not match the base
	// name of the import path for idiomaticity.
	return alias + " " + strconv.Quote(importPath)
}

func (fg *FileGenerator) pkgconfig() []string {
	parentPkgs := fg.parent.pkgconfig()
	packages := make([]string, 0, len(fg.Packages)+len(parentPkgs))

	packages = append(packages, parentPkgs...)
	for pkg := range fg.Packages {
		packages = append(packages, pkg)
	}

	sort.Strings(packages)
	return packages
}

// addMarshaler adds the type marshaler into the init header. It also adds
// imports.
func (fg *FileGenerator) addMarshaler(glibGetType, goName string) {
	fg.marshalers = append(fg.marshalers, fmt.Sprintf(
		`{T: externglib.Type(C.%s()), F: marshal%s},`, glibGetType, goName,
	))
	// Need this for g_value functions inside marshal.
	fg.needsGLibObject()
	// Need this for the pointer cast.
	fg.addImport("unsafe")
}

func (fg *FileGenerator) cIncludes() []string {
	includes := make([]string, 0,
		len(fg.CIncludes)+len(fg.parent.current.Repository.CIncludes))

	for cIncl := range fg.CIncludes {
		includes = append(includes, cIncl)
	}
	for _, cIncl := range fg.parent.current.Repository.CIncludes {
		includes = append(includes, cIncl.Name)
	}

	sort.Strings(includes)
	return includes
}

// callbackHeaders returns the sorted C callback headers.
func (fg *FileGenerator) callbackHeaders() []string {
	headers := make([]string, 0, len(fg.Callbacks))
	for callback := range fg.Callbacks {
		headers = append(headers, callback)
	}

	sort.Strings(headers)
	return headers
}

// Namespace returns the generator's namespace that includes the repository it's
// in.
func (fg *FileGenerator) Namespace() *gir.NamespaceFindResult {
	return fg.parent.current
}

func (fg *FileGenerator) Logln(level LogLevel, v ...interface{}) {
	prefix := []interface{}{fg.name + ":"}
	prefix = append(prefix, v...)

	fg.parent.Logln(level, prefix...)
}

func (fg *FileGenerator) warnUnknownType(typ string) {
	fg.Logln(LogUnknown, strconv.Quote(typ))
}

// applyConvertedFxs applies all side effects of the given list of type converted
// results.
func (fg *FileGenerator) applyConvertedFxs(results []ValueConverted) {
	for _, result := range results {
		result.ApplySideEffects(&fg.SideEffects)
	}
}

// SideEffects describes the side effects of the conversion, such as
// importing new things or modifying the Cgo preamble.
type SideEffects struct {
	Imports        map[string]string
	CIncludes      map[string]struct{}
	Packages       map[string]struct{} // for pkg-config
	Callbacks      map[string]struct{}
	CallbackDelete bool
}

const internalImportPath = "github.com/diamondburned/gotk4/internal"

func (sides *SideEffects) addImportInternal(internal string) {
	sides.addImport(internalImportPath + "/" + internal)
}

func (sides *SideEffects) addImport(path string) {
	sides.addImportAlias(path, "")
}

func (sides *SideEffects) addImportAlias(path, alias string) {
	if sides.Imports == nil {
		sides.Imports = map[string]string{}
	}

	sides.Imports[path] = alias
}

func (sides *SideEffects) addGLibImport() {
	sides.addImportAlias("github.com/gotk3/gotk3/glib", "externglib")
}

func (sides *SideEffects) importPubl(resolved *ResolvedType) {
	if resolved == nil {
		return
	}

	sides.importResolvedType(resolved.PublImport)
	if resolved.IsCallback() {
		sides.addCallbackHeader(CallbackCHeader(resolved.Extern.Result.Callback))
	}
}

func (sides *SideEffects) importImpl(resolved *ResolvedType) {
	if resolved == nil {
		return
	}

	sides.importResolvedType(resolved.ImplImport)
	if resolved.IsCallback() {
		sides.addCallbackHeader(CallbackCHeader(resolved.Extern.Result.Callback))
	}
}

func (sides *SideEffects) importResolvedType(imports ResolvedTypeImport) {
	if imports.Path != "" {
		sides.addImportAlias(imports.Path, imports.Package)
	}
}

func (sides *SideEffects) addCallback(callback *gir.Callback) {
	sides.addCallbackHeader(CallbackCHeader(callback))
}

func (sides *SideEffects) addCallbackHeader(header string) {
	if sides.Callbacks == nil {
		sides.Callbacks = map[string]struct{}{}
	}

	sides.Callbacks[header] = struct{}{}
}

// addPackage adds a pkg-config package.
func (sides *SideEffects) addPackage(pkg string) {
	if sides.Packages == nil {
		sides.Packages = map[string]struct{}{}
	}

	sides.Packages[pkg] = struct{}{}
}

// includeC adds a C header file into the cgo preamble.
func (sides *SideEffects) includeC(include string) {
	if sides.CIncludes == nil {
		sides.CIncludes = map[string]struct{}{}
	}

	sides.CIncludes[include] = struct{}{}
}

// needsCbool adds the C stdbool.h include.
func (sides *SideEffects) needsCbool() {
	sides.includeC("stdbool.h")
}

// needsGLibObject adds the glib-object.h include and the glib-2.0 package.
func (sides *SideEffects) needsGLibObject() {
	// Need this for g_value_get_boxed.
	sides.includeC("glib-object.h")
	// Need this for the above header.
	sides.addPackage("glib-2.0")
}

// ApplySideEffects applies the side effects of the conversion. The caller is
// responsible for calling this.
func (sides *SideEffects) ApplySideEffects(dst *SideEffects) {
	if sides.CallbackDelete {
		dst.CallbackDelete = true
	}
	for path, alias := range sides.Imports {
		dst.addImportAlias(path, alias)
	}
	for callback := range sides.Callbacks {
		dst.addCallbackHeader(callback)
	}
	for cIncl := range sides.CIncludes {
		dst.includeC(cIncl)
	}
	for pkg := range sides.Packages {
		dst.addPackage(pkg)
	}
}
