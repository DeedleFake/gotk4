package girgen

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/diamondburned/gotk4/gir"
	"github.com/diamondburned/gotk4/internal/pen"
	"github.com/pkg/errors"
)

// FileGenerator contains values to fully construct a generated file.
type FileGenerator struct {
	parent *NamespaceGenerator

	pen *pen.Paper // body
	pre *pen.Paper
	cgo *pen.Paper

	name       string
	imports    map[string]string // optional alias value
	includes   []string          // C include
	marshalers []string

	// inserted keeps track of what was inserted once.
	inserted struct {
		CallbackDelete bool
		IncludeGObject bool
		IncludeStdbool bool
	}
}

// NewFileGenerator creates a new FileGenerator.
func NewFileGenerator(parent *NamespaceGenerator, goFile string) *FileGenerator {
	fg := FileGenerator{
		pen: pen.NewPaper(),          // 2MB
		pre: pen.NewPaperSize(10240), // 10KB
		cgo: pen.NewPaperSize(10240), // 10KB

		name:    goFile,
		parent:  parent,
		imports: map[string]string{},

		// overallocate
		marshalers: make([]string, 0, 0+
			len(parent.current.Namespace.Enums)+
			len(parent.current.Namespace.Bitfields)+
			len(parent.current.Namespace.Records)+
			len(parent.current.Namespace.Classes)+
			len(parent.current.Namespace.Interfaces),
		),
	}

	return &fg
}

func replaceExt(name, ext string) string {
	parts := strings.Split(name, ".")

	switch len(parts) {
	case 0:
		return ""
	case 1:
		return parts[0] + ext
	default:
		return strings.Join(parts[:len(parts)-1], ".") + ext
	}
}

func (fg *FileGenerator) generate() ([]byte, error) {
	if len(fg.marshalers) > 0 {
		fg.addImportAlias("github.com/gotk3/gotk3/glib", "externglib")
	}

	pen.Flush(fg.pen, fg.cgo, fg.pre)

	var out bytes.Buffer
	// Preallocate 10KB + existing buffers.
	out.Grow(10*1024 + fg.pen.Size() + fg.cgo.Size() + fg.pre.Size())

	pen := pen.New(&out)
	pen.Words("// Code generated by girgen. DO NOT EDIT.")
	pen.Line()

	pen.Words("package", fg.parent.PackageName())
	pen.Line()

	if len(fg.imports) > 0 {
		builtin := make([]string, len(fg.imports))
		externs := make([]string, len(fg.imports))

		for path, alias := range fg.imports {
			if !strings.Contains(path, "/") {
				builtin = append(builtin, makeImport(path, alias))
			} else {
				externs = append(externs, makeImport(path, alias))
			}
		}

		sort.Strings(builtin)
		sort.Strings(externs)

		pen.Words("import (")

		for _, str := range builtin {
			pen.Words(str)
		}
		if len(builtin) > 0 && len(externs) > 0 {
			pen.Line()
		}
		for _, str := range externs {
			pen.Words(str)
		}

		pen.Block(")")
		pen.Line()
	}

	pen.Words(append([]string{"// #cgo pkg-config:"}, fg.parent.pkgconfig()...)...)
	pen.Words("// #cgo CFLAGS: -Wno-deprecated-declarations")

	for _, cIncl := range fg.includes {
		pen.Wordf("// #include <%s>", cIncl)
	}
	for _, cIncl := range fg.parent.current.Repository.CIncludes {
		pen.Wordf("// #include <%s>", cIncl.Name)
	}

	if !fg.cgo.IsEmpty() {
		pen.Words("//")
		for _, line := range strings.Split(fg.cgo.String(), "\n") {
			pen.Words("//", line)
		}
	}

	pen.Words(`import "C"`)
	pen.Line()

	if len(fg.marshalers) > 0 {
		pen.Words("func init() {")
		pen.Words("  externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{")

		for _, marshaler := range fg.marshalers {
			pen.Words("      " + marshaler)
		}

		pen.Words("  })")
		pen.Words("}")
		pen.Line()
	}

	pen.WriteString(fg.pre.String())
	pen.WriteString(fg.pen.String())

	pen.Flush()

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		fg.Logln(LogError, "failed to fmt file", fg.name)
		return out.Bytes(), errors.Wrap(err, "failed to fmt")
	}

	return formatted, nil
}

func makeImport(importPath, alias string) string {
	pathBase := path.Base(importPath)

	// Check if the base is a version part.
	if strings.HasPrefix(pathBase, "v") {
		_, err := strconv.Atoi(strings.TrimPrefix(pathBase, "v"))
		if err == nil {
			// Valid version part. Trim it.
			pathBase = path.Base(path.Dir(importPath))
		}
	}

	if alias == "" || alias == pathBase {
		return strconv.Quote(importPath)
	}

	// Only use the import alias if it's provided and does not match the base
	// name of the import path for idiomaticity.
	return alias + " " + strconv.Quote(importPath)
}

func (fg *FileGenerator) addMarshaler(glibGetType, goName string) {
	fg.marshalers = append(fg.marshalers, fmt.Sprintf(
		`{T: externglib.Type(C.%s()), F: marshal%s},`, glibGetType, goName,
	))
}

func (fg *FileGenerator) needsStdbool() {
	if !fg.inserted.IncludeStdbool {
		fg.inserted.IncludeStdbool = true

		fg.includes = append(fg.includes, "stdbool.h")
	}
}

func (fg *FileGenerator) needsGLibObject() {
	if !fg.inserted.IncludeGObject {
		fg.inserted.IncludeGObject = true

		// Need this for g_value_get_boxed.
		fg.includes = append(fg.includes, "glib-object.h")
	}
}

func (fg *FileGenerator) needsCallbackDelete() {
	if fg.inserted.CallbackDelete {
		return
	}

	fg.inserted.CallbackDelete = true
	fg.addImport("github.com/diamondburned/gotk4/internal/box")

	fg.cgo.Words("extern void callbackDelete(gpointer);")

	fg.pre.Words("//export callbackDelete")
	fg.pre.Words("func callbackDelete(ptr C.gpointer) {")
	fg.pre.Words("  box.Delete(box.Callback, uintptr(ptr))")
	fg.pre.Words("}")

	fg.pre.Line()
}

func (fg *FileGenerator) addImport(pkgPath string) {
	fg.addImportAlias(pkgPath, "")
}

func (fg *FileGenerator) addImportAlias(pkgPath, alias string) {
	_, ok := fg.imports[pkgPath]
	if ok {
		return
	}

	fg.imports[pkgPath] = alias
}

func (fg *FileGenerator) addResolvedImport(resolved *ResolvedType) {
	if resolved != nil && resolved.Import != "" && resolved.Import != fg.parent.pkgPath {
		fg.addImportAlias(resolved.Import, resolved.Package)
	}
}

// addGLibImport adds the gotk3/glib import.
func (fg *FileGenerator) addGLibImport() {
	fg.addResolvedImport(externGLibType("", gir.Type{}, ""))
}

// Namespace returns the generator's namespace that includes the repository it's
// in.
func (fg *FileGenerator) Namespace() *gir.NamespaceFindResult {
	return fg.parent.current
}

func (fg *FileGenerator) Logln(level LogLevel, v ...interface{}) {
	prefix := []interface{}{fg.name + ":"}
	prefix = append(prefix, v...)

	fg.parent.Logln(level, prefix...)
}

func (fg *FileGenerator) warnUnknownType(typ string) {
	fg.Logln(LogUnknown, strconv.Quote(typ))
}
