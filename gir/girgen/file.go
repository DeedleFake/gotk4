package girgen

import (
	"bytes"
	"errors"
	"fmt"
	"path"
	"sort"
	"strconv"
	"strings"

	"github.com/diamondburned/gotk4/core/pen"
	"github.com/diamondburned/gotk4/gir"
	"github.com/diamondburned/gotk4/gir/girgen/file"
	"github.com/diamondburned/gotk4/gir/girgen/generators"
	"github.com/diamondburned/gotk4/gir/girgen/logger"
	"github.com/diamondburned/gotk4/gir/girgen/types"
)

// FileGenerator is a file generator.
type FileGenerator struct {
	*NamespaceGenerator
	BuildTags []string // go:build lines, joined by AND (&&)

	pen    *pen.PaperBuffer
	header file.Header
}

var (
	_ types.FileGenerator      = (*FileGenerator)(nil)
	_ generators.FileGenerator = (*FileGenerator)(nil)
	_ generators.FileWriter    = (*FileGenerator)(nil)
)

// NewFileGenerator creates a new empty FileGenerator instance.
func NewFileGenerator(n *NamespaceGenerator) *FileGenerator {
	fg := FileGenerator{
		NamespaceGenerator: n,
		pen:                pen.NewPaperBufferSize(10 * 1024), // 10KB
	}
	fg.Reset()
	return &fg
}

// Reset resets the FileGenerator to the empty state.
func (f *FileGenerator) Reset() {
	f.BuildTags = f.BuildTags[:0]
	f.BuildTags = append(f.BuildTags, "cgo")

	f.pen.Reset()
	f.header.Reset()
}

// Header returns the current file's header.
func (f *FileGenerator) Header() *file.Header {
	return &f.header
}

// Pen returns the current file's writing pen.
func (f *FileGenerator) Pen() *pen.Pen {
	return &f.pen.Pen
}

func (f *FileGenerator) Logln(lvl logger.Level, v ...interface{}) {
	p := fmt.Sprintf("package %s/v%s", f.PkgName, gir.MajorVersion(f.current.Namespace.Version))
	f.NamespaceGenerator.Logln(lvl, logger.Prefix(v, p))
}

// Generate generates the final file content, completed with gofmt.
func (f *FileGenerator) Generate() ([]byte, error) {
	if len(f.header.Marshalers) > 0 {
		// Import externglib for the RegisterMarshal function.
		f.header.NeedsExternGLib()
	}

	if f.header.CallbackDelete {
		f.header.ImportCore("box")
		f.header.AddCallbackHeader("extern void callbackDelete(gpointer);")
	}

	var out bytes.Buffer
	out.Grow(4096 + f.pen.Len()) // 4KB + pen

	fpen := pen.NewPen(&out)
	fpen.Words("// Code generated by girgen. DO NOT EDIT.")
	fpen.EmptyLine()

	fpen.Words("package", f.PkgName)
	fpen.EmptyLine()

	if len(f.header.Imports) > 0 {
		builtins := make([]string, 0, len(f.header.Imports))
		externs := make([]string, 0, len(f.header.Imports))

		for path, alias := range f.header.Imports {
			// If path matches the import path, then this is a bug elsewhere.
			if path == f.PkgPath {
				f.Logln(logger.Error, "importing self")
				return nil, errors.New("cyclical import on self")
			}

			// Path containing a dot probably indicates it has a domain name.
			if !strings.Contains(path, ".") {
				builtins = append(builtins, makeImport(path, alias))
			} else {
				externs = append(externs, makeImport(path, alias))
			}
		}

		sort.Strings(builtins)
		sort.Strings(externs)

		fpen.Words("import", "(")

		for _, line := range builtins {
			fpen.Words(line)
		}
		if len(builtins) > 0 && len(externs) > 0 {
			fpen.EmptyLine()
		}
		for _, line := range externs {
			fpen.Words(line)
		}

		fpen.Words(")")
		fpen.EmptyLine()
	}

	fpen.Words("append()")
}

func makeImport(importPath, alias string) string {
	pathBase := path.Base(importPath)

	// Check if the base is a version part.
	if strings.HasPrefix(pathBase, "v") {
		_, err := strconv.Atoi(strings.TrimPrefix(pathBase, "v"))
		if err == nil {
			// Valid version part. Trim it.
			pathBase = path.Base(path.Dir(importPath))
		}
	}

	if alias == "" || alias == pathBase {
		return strconv.Quote(importPath)
	}

	// Only use the import alias if it's provided and does not match the base
	// name of the import path for idiomaticity.
	return alias + " " + strconv.Quote(importPath)
}
