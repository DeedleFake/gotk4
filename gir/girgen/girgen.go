package girgen

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/diamondburned/gotk4/gir"
	"github.com/diamondburned/gotk4/internal/pen"
)

// Generator is a big generator that manages multiple repositories.
type Generator struct {
	// KnownTypes contains a list of type checks that return true if the given
	// type matches a known type.
	KnownTypes []func(string) bool

	Repos   gir.Repositories
	current gir.NamespaceFindResult

	logger *log.Logger
}

// NewGenerator creates a new generator with sane defaults.
func NewGenerator(repos gir.Repositories) *Generator {
	return &Generator{Repos: repos}
}

// WithLogger sets the generator's logger.
func (g *Generator) WithLogger(logger *log.Logger) {
	g.logger = logger
}

func (g *Generator) debugln(v ...interface{}) {
	if g.logger != nil {
		g.logger.Println(v...)
	}
}

// UseNamespace creates a new namespace generator using the given namespace.
func (g *Generator) UseNamespace(namespace string) *NamespaceGenerator {
	res := g.Repos.FindNamespace(namespace, "")
	if res == nil {
		return nil
	}

	buf := bytes.Buffer{}
	buf.Grow(4 * 1024 * 1024) // 4MB

	return &NamespaceGenerator{
		pen:  pen.New(&buf),
		body: &buf,

		imports: map[string]struct{}{},
		gen:     g,
		current: res,
	}
}

// NamespaceGenerator is a generator for a specific namespace.
type NamespaceGenerator struct {
	pen  *pen.Pen
	body *bytes.Buffer

	imports map[string]struct{}

	gen     *Generator
	current *gir.NamespaceFindResult
}

// Generate generates the current namespace into the given writer.
func (ng *NamespaceGenerator) Generate(w io.Writer) error {
	ng.addImport("unsafe")
	ng.addImport("github.com/gotk3/gotk3/glib")
	ng.addImport("github.com/diamondburned/gotk4/internal/gextras")
	ng.addImport("github.com/diamondburned/gotk4/internal/callback")

	// CALL GENERATION FUNCTIONS HERE !!!
	// CALL GENERATION FUNCTIONS HERE !!!
	// CALL GENERATION FUNCTIONS HERE !!!
	// CALL GENERATION FUNCTIONS HERE !!!
	// CALL GENERATION FUNCTIONS HERE !!!

	pen := pen.New(w)
	pen.Words("// Code generated by girgen. DO NOT EDIT.")
	pen.Line()

	pen.Words("package", gir.GoNamespace(ng.current.Namespace))
	pen.Line()

	if len(ng.imports) > 0 {
		pen.Words("import (")
		for imp := range ng.imports {
			pen.Words(strconv.Quote(imp))
		}
		pen.WriteString(")")
		pen.Line()
	}

	pen.Words("// #cgo pkg-config", ng.current.Repository.Pkg)
	pen.Words("// #cgo CFLAGS: -Wno-deprecated-declarations") // opt to warn over comments
	for _, cIncl := range ng.current.Repository.CIncludes {
		pen.Words("// #include", fmt.Sprintf("<%s>", cIncl.Name))
	}
	pen.Words("// extern void callbackDelete(gpointer);")
	pen.Words(`import "C"`)
	pen.Line()

	pen.Words("//export callbackDelete")
	pen.Block(`func callbackDelete(ptr C.pointer) { callback.Delete(ptr) }`)

	pen.Write(ng.body.Bytes())

	return pen.Flush()
}

func (ng *NamespaceGenerator) addImport(pkgPath string) {
	_, ok := ng.imports[pkgPath]
	if ok {
		return
	}

	ng.imports[pkgPath] = struct{}{}
}

func (ng *NamespaceGenerator) findType(girType string) *gir.TypeFindResult {
	return ng.gen.Repos.FindType(ng.current.Namespace.Name, ng.current.Namespace.Version, girType)
}

// resolveType resolves the given type from the GIR type field. It returns nil
// if the type is not known.
func (ng *NamespaceGenerator) resolveType(girType string) *resolvedType {
	typ := ng._resolveType(girType)
	if typ.Import != "" {
		ng.addImport(typ.Import)
	}

	return typ
}

func (ng *NamespaceGenerator) _resolveType(girType string) *resolvedType {
	// Resolve the unknown namespace that is GLib and primitive types.
	switch girType {
	case "void", "none":
		return voidType
	case "gboolean":
		return builtinType("bool")
	case "gfloat":
		return builtinType("float32")
	case "gdouble":
		return builtinType("float64")
	case "gint":
		return builtinType("int")
	case "gint8":
		return builtinType("int8")
	case "gint16":
		return builtinType("int16")
	case "gint32":
		return builtinType("int32")
	case "gint64":
		return builtinType("int64")
	case "guint":
		return builtinType("uint")
	case "guint8":
		return builtinType("uint8")
	case "guint16":
		return builtinType("uint16")
	case "guint32":
		return builtinType("uint32")
	case "guint64":
		return builtinType("uint64")
	case "utf8":
		return builtinType("string")
	case "gpointer":
		// TODO: ignore field
		// TODO: aaaaaaaaaaaaaaaaaaaaaaa
		return builtinType("unsafe.Pointer")
	case "GLib.DestroyNotify": // This should be handled externally.
		return builtinType("unsafe.Pointer")
	case "GType":
		return builtinType("glib.Type")
	case "GObject.GValue":
		return builtinType("*glib.Value")
	case "GObject.Object":
		return builtinType("*glib.Object")
	case "GObject.GInitiallyUnowned":
		return builtinType("glib.InitiallyUnowned")

	// We don't know what these types translates to.
	case "GObject.EnumValue": // TODO: Find a way to map EnumValue type.
		return nil
	}

	// Types that aren't in the switch tree that match any of these patterns are
	// types that must be in the switch tree, so them not being in there is a
	// bug.
	for _, check := range ng.gen.KnownTypes {
		if check(girType) {
			log.Fatalf("missing gir type %s in the type tree\n", girType)
		}
	}

	result := ng.findType(girType)
	if result == nil {
		ng.gen.debugln("unknown gir type", girType)
		return nil
	}

	return typeFromResult(result)
}

type resolvedType struct {
	GoType string
	Import string              // optional
	Result *gir.TypeFindResult // known types (inside gir) only
}

// voidType is an empty type.
var voidType = &resolvedType{}

// builtinType is a convenient function to make a new resolvedType.
func builtinType(typ string) *resolvedType {
	return &resolvedType{GoType: typ}
}

// typeFromResult creates a resolved type from the given type result.
func typeFromResult(result *gir.TypeFindResult) *resolvedType {
	name, _ := result.Info()

	// same namespace, no package qual required.
	if result.SameNamespace {
		typ := &resolvedType{name, "", result}
		typ.setPtr()
		return typ
	}

	// different namespace.
	pkg := gir.GoNamespace(result.Namespace)
	path := gir.ImportPath(pkg)

	typ := &resolvedType{pkg + "." + name, path, nil}
	typ.setPtr()
	return typ
}

func (typ *resolvedType) setPtr() {
	if typ.Result != nil && typ.Result.IsPtr() {
		typ.GoType = strings.Repeat("*", typ.Result.Ptr())
	}
}
