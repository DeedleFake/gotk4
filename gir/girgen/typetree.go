package girgen

import (
	"github.com/davecgh/go-spew/spew"
	"github.com/diamondburned/gotk4/gir"
	"github.com/diamondburned/gotk4/internal/pen"
)

// TypeTree is a structure for a type that is resolved to the lowest level of
// inheritance.
type TypeTree struct {
	Resolved *ResolvedType
	Requires []TypeTree

	ng *NamespaceGenerator
}

// TypeTree returns a new type tree for resolving.
func (ng *NamespaceGenerator) TypeTree() *TypeTree {
	return &TypeTree{ng: ng}
}

func (tree *TypeTree) reset() {
	// Zero out the fields to prevent dangling pointers.
	for i := range tree.Requires {
		tree.Requires[i] = TypeTree{}
	}

	tree.Resolved = nil
	tree.Requires = tree.Requires[:0]
}

// IsInterface returns true if the current type in the tree is an interface.
func (tree *TypeTree) IsInterface() bool {
	return tree.Resolved.Extern != nil && tree.Resolved.Extern.Result.Interface != nil
}

// Resolve resolves the given toplevel type into the TypeTree, overriding the
// Resolved and Requires fields. True is returned if the tree is successfully
// resolved.
func (tree *TypeTree) Resolve(toplevel string) bool {
	resolved := tree.ng.ResolveTypeName(toplevel)
	if resolved == nil {
		tree.reset()
		return false
	}

	return tree.ResolveFromType(resolved)
}

// ResolveFromType is like Resolve, but the caller directly supplies the
// resolved top-level type.
func (tree *TypeTree) ResolveFromType(toplevel *ResolvedType) bool {
	tree.reset()
	tree.Resolved = toplevel

	// Edge cases for builtin types.
	if tree.Resolved.Builtin != nil {
		if toplevel.IsExternGLib("InitiallyUnowned") {
			return tree.resolveParents(
				externGLibType("*Object", gir.Type{}, "GObject*"),
			)
		}

		return true
	}

	switch {
	case tree.Resolved.Extern.Result.Class != nil:
		if !tree.resolveName(tree.Resolved.Extern.Result.Class.Parent) {
			return false
		}

		for _, impl := range tree.Resolved.Extern.Result.Class.Implements {
			if !tree.resolveName(impl.Name) {
				return false
			}
		}

	case tree.Resolved.Extern.Result.Interface != nil:
		// All interfaces are derived from GObjects, so we override the list if
		// it's empty.
		if len(tree.Resolved.Extern.Result.Interface.Prerequisites) == 0 {
			return tree.resolveParents(
				externGLibType("*Object", gir.Type{}, "GObject*"),
			)
		}

		for _, prereq := range tree.Resolved.Extern.Result.Interface.Prerequisites {
			if !tree.resolveName(prereq.Name) {
				return false
			}
		}
	}

	return true
}

// resolveName resolves and adds the resolved type into the TypeTree.
func (tree *TypeTree) resolveName(name string) bool {
	parent := TypeTree{ng: tree.ng}
	if !parent.Resolve(name) {
		return false
	}

	tree.Requires = append(tree.Requires, parent)
	return true
}

// resolveParents manually adds the given parents and resolve them to be added
// into the TypeTree.
func (tree *TypeTree) resolveParents(parents ...*ResolvedType) bool {
	for _, parent := range parents {
		parentTree := TypeTree{ng: tree.ng}
		if !parentTree.ResolveFromType(parent) {
			// This shouldn't happen, unless the parent type made above is
			// invalid.
			return false
		}

		tree.Requires = append(tree.Requires, parentTree)
	}

	return true
}

// PublicChildren returns the list of the toplevel type's children as Go
// exported type names. The namespaces are appropriately prepended if needed.
func (tree *TypeTree) PublicChildren() []string {
	names := make([]string, len(tree.Requires))

	for i, req := range tree.Requires {
		namespace := req.Resolved.NeedsNamespace(tree.ng.current)
		names[i] = req.Resolved.PublicType(namespace)
	}

	return names
}

// Wrap creates a wrapper that uses public fields to create code that wraps the
// type tree to the top-level type. The fields are assumed to be public
// (exported) types. Types are assumed to all have valid wrap functions, so no
// nested wraps will actually be done.
//
// Wrapper functions for all types are assumed to follow this format:
//
//    func WrapTypeName(obj *externglib.Object) TypeName
//
func (tree *TypeTree) Wrap(obj string) string {
	p := pen.NewPiece()
	p.Write(tree.Resolved.PublicType(false)).Char('{')
	p.EmptyLine()

	for _, typ := range tree.Requires {
		if typ.Resolved.Builtin != nil {
			// If these cases hit, then the type is an Objector (as deefined by
			// gextras.Objector), so obj satisfies it.
			for _, glibType := range []string{"InitiallyUnowned", "Object"} {
				if typ.Resolved.IsExternGLib(glibType) {
					p.Line("Objector: obj,")
					goto glibContinue
				}
			}

			tree.ng.logln(logUnknown, "builtin wrapping:", spew.Sdump(typ.Resolved))

		glibContinue:
			continue
		}

		// Extern types are generated by us, so the wrapper guarantee is
		// provided.
		namespace := typ.Resolved.NeedsNamespace(tree.ng.current)

		p.Linef(
			"%s: %s(%s),",
			typ.Resolved.PublicType(namespace),
			typ.Resolved.WrapName(namespace),
			obj,
		)
	}

	p.Char('}')
	return p.String()
}
